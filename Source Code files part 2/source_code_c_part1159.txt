(HWND)wParam,hwnd,aItem,retval))
                {
                    GlobalFree(hdata);
                }
            }
            else if (aItem != NULL)
            {
                GlobalDeleteAtom (aItem);
            }
            break;
        }
    case WM_DDE_UNADVISE:
        {
            intrDebugOut((DEB_ITRACE,
                          "DDIC: WM_DDE_UNADVISE hwnd=%x aItem=%x(%ws)\n",
                          hwnd,
                          aItem,
                          wAtomName(aItem)));

            retval = lpclient->UnAdviseData ((HWND)wParam, aItem);

            if (!PostAckToClient((HWND)wParam,hwnd,aItem,retval))
            {
                goto errRtn;
            }
            break;
        }
    case WM_DDE_REQUEST:
        {
            intrDebugOut((DEB_ITRACE,
                          "DDIC: WM_DDE_REQUEST hwnd=%x aItem=%x(%ws) cfFormat=%x\n",
                          hwnd,
                          aItem,
                          wAtomName(aItem),
                          (USHORT)LOWORD(pDocData->lParam)));

            retval = lpclient->RequestData ((HWND)wParam,
                                            aItem,
                                            LOWORD(pDocData->lParam),
                                            (HANDLE FAR *)&hdata);

            if (retval == NOERROR)
            {
                // post the data message and we are not asking for any
                // acknowledge.

                intrDebugOut((DEB_ITRACE,
                              "DDIC: posting WM_DDE_DATA\n"));

                LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_DATA,hdata,aItem);
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_DATA, (WPARAM) hwnd,lp))
                {
                    // hdata will be freed by the client because fRelease
                    // was set to true by MakeDdeData (called by RequestData)

                    DDEFREE(WM_DDE_DATA,lp);
                    goto errRtn;
                }
            }
            else
            {
                if (!PostAckToClient((HWND)wParam,hwnd,aItem,retval))
                {
                    goto errRtn;
                }
            }
            break;
        }
    default:
        //
        // Whoops, this is very bad. We should never get here.
        //
        intrAssert(!"Unknown MSG in DocWndProc: Very Bad indeed");


    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
                  "0 _OUT DocDispatchIncomingCall pDocData(%x) hr = 0\n",
                  pDocData));

    return(NOERROR);
errRtn:
    intrDebugOut((DEB_IERROR,
                  "***** ERROR DDIC pDocData(%x) Post ACK failed. \n",
                  pDocData));

    if (aItem != NULL)
    {
        GlobalDeleteAtom (aItem);
    }
    goto exitRtn;
}


//+---------------------------------------------------------------------------
//
//  Function:   DocWndProc
//
//  Synopsis:   Document Window Procedure
//
//  Effects:    Processes DDE messages for a document window.
//
//  Arguments:  [hwnd] --
//              [msg] --
//              [wParam] --
//              [lParam] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-05-94   kevinro Commented/cleaned
//
//  Notes:
//
//  When running in a VDM, it is possible that this window was dispatched
//  without having a full window handle. This happens when the getmessage
//  was dispatched from 16-bit. Therefore, we need to convert the hwnd to
//  a full hwnd before doing any comparision functions.
//
//----------------------------------------------------------------------------
STDAPI_(LRESULT) DocWndProc (
HWND        hwndIn,
UINT        msg,
WPARAM      wParam,
LPARAM      lParam
)
{

    //
    // Since this is the DocWndProc, we aren't going to initialize
    // any of the local variables. This function is called as a WNDPROC,
    // which is pretty often.
    //

    DOCDISPATCHDATA     docData;
    LPCLIENT            lpclient;
    WORD                status=0;
    HANDLE              hdata;
    ATOM                aItem;
    HRESULT             retval;
    LPOLEOBJECT         lpoleObj;
    HWND                hwnd;
    DebugOnly (HWND     hwndClient;)

    // REVIEW: We need to take care of the bug, related to
    // Excel. Excel does the sys level connection and sends
    // terminates immediately before making the connection
    // to the doc level. If we send release to classfactory
    // app may revoke the classfactory.


    // REVIEW: It may not be necessary to do the blocking.
    // ReVIEW: For fixing the ref count right way for
    // CreateInstance Vs. WM_DDE_INIT

#ifdef  LATER
    if (AddMessage (hwnd, msg, wParam, lParam, WT_DOC))
        return 0L;
#endif

    switch (msg){

    case WM_CREATE:
        intrDebugOut((DEB_ITRACE,
                      "DocWndProc: CreateWindow hwndIn=%x\n",
                      hwndIn));
            break;


    case WM_DDE_INITIATE:
        hwnd = ConvertToFullHWND(hwndIn);
        intrAssert(IsWindowValid(hwnd));
        lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

        intrDebugOut((DEB_ITRACE,
                      "DocWndProc: WM_DDE_INITIATE hwnd=%x\n",
                      hwnd));

        ChkC(lpclient);


        // REVIEW: We may not allow  initiates to get thru
        // while we are waiting for terminates. So, this case
        // may not arise

        // Need to verify that m_pCI is not NULL during incoming
        // calls from the client.
        //
        if (lpclient->m_fCallData)
        {
            intrDebugOut((DEB_ITRACE,
                "DocWndProc: No initiates while waiting on terminate\n"));

                break;
        }
        // if we are the document then respond.

        if (! (lpclient->m_aItem == (ATOM)(HIWORD(lParam))))
        {
                break;
        }

        // We can enterain this client. Put this window in the client list
        // and acknowledge the initiate.

        if (!AddClient ((LPHANDLE)&lpclient->m_hcli, (HWND)wParam, (HWND)wParam))
        {
                break;
        }


        // post the acknowledge
        DuplicateAtom (LOWORD(lParam));
        DuplicateAtom (HIWORD(lParam));
        SSSendMessage ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lParam);

        lpclient->m_cClients++;
        lpclient->m_fCreatedNotConnected = FALSE;
        lpoleObj = lpclient->m_lpoleObj;

        // we have added an addref because of createinstance.

        if (lpclient->m_bCreateInst)
        {
            lpclient->m_bCreateInst = FALSE;
        }

        return 1L; // fAckSent
        break;


    case WM_DDE_EXECUTE:
       {
            hwnd = ConvertToFullHWND(hwndIn);
            intrAssert(IsWindowValid(hwnd));
            lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

            hdata = GET_WM_DDE_EXECUTE_HDATA(wParam,lParam);
            intrDebugOut((DEB_ITRACE,
                          "DocWndProc: WM_DDE_EXECUTE hwnd=%x hdata=%x\n",
                          hwnd,
                          hdata));

            ChkC(lpclient);

#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpclient->m_hcli, (HWND)wParam, FALSE);
            AssertSz (hwndClient, "Client is missing from the server");
#endif
            if (!IsWindowValid  ((HWND)wParam) || lpclient->m_fCallData)
            {
                if (lpclient->m_fCallData)
                {
                    // This means the terminate has already been sent
                    // to this window (from AdviseSink::OnClose) so
                    // we can ignore the StdCloseDocument.
                }
                else
                {
                    intrAssert(!"Execute received from dead sending window");
                }
                // Since we are not sending an ACK, the sender will not
                // have the chance to free the hCommands handle.
                DDEFREE(WM_DDE_ACK,lParam);
                // GlobalFree (hdata);
                break;
            }

            //
            // Fill in the used items in DocData
            //
            docData.hwnd = hwnd;
            docData.msg = msg;
            docData.wParam = wParam;
            docData.hdata = hdata;
            docData.lpclient = lpclient;

            retval = DocHandleIncomingCall(&docData);

            //
            // If error return, then we didn't call DocDispatchIncomingCall
            // and therefore need to send a NACK
            //
            if (retval != NOERROR)
            {
                lpclient->SendExecuteAck (retval);
            }
            break;
       }
       case WM_DDE_TERMINATE:
            hwnd = ConvertToFullHWND(hwndIn);
            intrAssert(IsWindowValid(hwnd));
            lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

            intrDebugOut((DEB_ITRACE,
                          "DocWndProc: WM_DDE_TERMINATE hwnd=%x\n",
                          hwnd));

            ChkC(lpclient);

            //
            // If m_fCallData, then we are are waiting for a terminate, which
            // means we generated the original terminate message. If
            // this is so, then we are waiting for a reply to the
            // terminate. Set the AckState and break;
            //
            if (lpclient->m_fCallData)
            {
                lpclient->SetCallState(SERVERCALLEX_ISHANDLED);
                break;
            }


#ifdef _DEBUG
            // find the client in the client list.
            hwndClient = (HWND)FindClient (lpclient->m_hcli,(HWND)wParam, FALSE);
            AssertSz(hwndClient, "Client is missing from the server");
#endif
            AssertIsDoc (lpclient);
            Assert (lpclient->m_cClients > 0);
            lpclient->m_cClients--;

            // Necessary safety bracket
            lpclient->m_pUnkOuter->AddRef();

            // terminate has to be handled always
            // The DocHandleIncomingCall() routine will set the
            // calltype to be CALLTYPE_ASYNC
            // async calls are never rejected

            docData.hwnd = hwnd;
            docData.msg = msg;
            docData.wParam = wParam;
            docData.lpclient = lpclient;

            retval = DocHandleIncomingCall(&docData);

            intrAssert(retval == NOERROR);

            // Necessary safety bracket
            lpclient->m_pUnkOuter->Release();
            break;

       case WM_DESTROY:

            intrDebugOut((DEB_ITRACE,
                          "DocWndProc: WM_DESTROY\n"));
            break;

       case WM_DDE_POKE:
            {
                hwnd = ConvertToFullHWND(hwndIn);
                intrAssert(IsWindowValid(hwnd));
                lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);
                hdata = GET_WM_DDE_POKE_HDATA(wParam,lParam);
                aItem = GET_WM_DDE_POKE_ITEM(wParam,lParam);
                ChkC(lpclient);

                if (!IsWindowValid  ((HWND) wParam) || lpclient->m_fCallData)
                {
                    // The sending window is invalid or we have already sent a
                    // TERMINATE to it (as indicated by m_pCI != NULL).
                    // We cannot ACK the message, so we must free any
                    // handles or atoms.
                    Warn ("Ignoring message");

                    FreePokeData (hdata);
LDeleteAtom:

                if (aItem != NULL)
                {
                    GlobalDeleteAtom (aItem);
                }
                break;
            }

            docData.hwnd = hwnd;
            docData.msg = msg;
            docData.wParam = wParam;
            docData.hdata = hdata;
            docData.aItem = aItem;
            docData.lpclient = lpclient;

            retval = DocHandleIncomingCall(&docData);
            if (retval != NOERROR)
            {
                SET_MSG_STATUS (retval, status);

                // !!! If the fRelease is false and the post fails
                // then we are not freeing the hdata. Are we supposed to

                // REVIEW: The assumption is
                LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM) hwnd,lp))
                {
                    DDEFREE(WM_DDE_ACK,lp);
                    goto LDeleteAtom;
                }
            }
                        // johannp: set the busy bit here in the status word
            break;
       }


    case WM_DDE_ADVISE:
        {
            hwnd = ConvertToFullHWND(hwndIn);
            intrAssert(IsWindowValid(hwnd));
            lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);
            HANDLE hOptions = GET_WM_DDE_ADVISE_HOPTIONS(wParam,lParam);
            aItem = GET_WM_DDE_ADVISE_ITEM(wParam,lParam);

            ChkC(lpclient);
            if (!IsWindowValid  ((HWND)wParam) || lpclient->m_fCallData)
            {
AdviseErr:
                Warn ("Ignoring advise message");
                //
                // GlobalFree wants a handle, we are giving it a DWORD.
                //
                if(hOptions) GlobalFree (hOptions);
                break;
            }
            docData.hwnd = hwnd;
            docData.msg = msg;
            docData.wParam = wParam;
            docData.hdata = hOptions;
            docData.aItem = aItem;
            docData.lpclient = lpclient;

            retval = DocHandleIncomingCall(&docData);

            if (retval != NOERROR)
            {
                SET_MSG_STATUS (retval, status);

                LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM) hwnd,lp))
                {
                    DDEFREE(WM_DDE_ACK,lp);
                    goto AdviseErr;
                }
            }
            break;
        }
    case WM_DDE_UNADVISE:
     {
        hwnd = ConvertToFullHWND(hwndIn);
        intrAssert(IsWindowValid(hwnd));
        lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

        aItem = HIWORD(lParam);
        ChkC(lpclient);
        if (!IsWindowValid  ((HWND)wParam) || lpclient->m_fCallData)
        {
                goto LDeleteAtom;
        }
        docData.hwnd = hwnd;
        docData.msg = msg;
        docData.wParam = wParam;
        docData.aItem = aItem;
        docData.lpclient = lpclient;

        retval = DocHandleIncomingCall(&docData);

        if (retval != NOERROR)
        {
            SET_MSG_STATUS (retval, status);
            LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);

            if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM) hwnd,lp))
            {
                DDEFREE(WM_DDE_ACK,lp);
                goto LDeleteAtom;
            }
        }

        break;
     }
    case WM_DDE_REQUEST:
     {
        hwnd = ConvertToFullHWND(hwndIn);
        intrAssert(IsWindowValid(hwnd));
        lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

        aItem = HIWORD(lParam);

        ChkC(lpclient);
        if (!IsWindowValid  ((HWND) wParam) || lpclient->m_fCallData)
        {
                goto LDeleteAtom;
        }
        docData.hwnd = hwnd;
        docData.msg = msg;
        docData.wParam = wParam;
        docData.lParam = lParam;
        docData.aItem = aItem;
        docData.lpclient = lpclient;

        retval = DocHandleIncomingCall(&docData);
        if (retval != NOERROR)
        {
            if (retval == RPC_E_DDE_BUSY)
            {
                    status = 0x4000;
            }
            else
            {
                    status = 0; // negative acknowledge
            }

            LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);
            // if request failed, then acknowledge with error.
            if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM) hwnd,lp))
            {
                DDEFREE(WM_DDE_ACK,lp);
                goto LDeleteAtom;
            }
        }
        break;
     }
    default:
            return SSDefWindowProc (hwndIn, msg, wParam, lParam);

    }

    return 0L;

}




INTERNAL_(void) CDefClient::SendExecuteAck
    (HRESULT hresult)
{
    AssertIsDoc (this);
    WORD  status = NULL;
    SET_MSG_STATUS (hresult, status);

    m_ExecuteAck.f = FALSE;

    LPARAM lParam = MAKE_DDE_LPARAM (WM_DDE_ACK,status,
                                     m_ExecuteAck.hdata);
    // Post the acknowledge to the client
    if (!PostMessageToClient (m_ExecuteAck.hwndFrom, WM_DDE_ACK,
                              (WPARAM) m_ExecuteAck.hwndTo, lParam))
    {
        Assert (0);
        // the window either died or post failed, delete the data
        DDEFREE (WM_DDE_ACK,lParam);
        GlobalFree (m_ExecuteAck.hdata);
    }
}



//DocExecute: Interprets the execute command for the
//document conversation.


INTERNAL CDefClient::DocExecute
    (HANDLE      hdata)
{

    ATOM            acmd;
    BOOL            fShow;
    BOOL            fActivate;

    HANDLE          hdup   = NULL;
    HRESULT           retval = ReportResult(0, S_OOM, 0, 0);

    LPSTR           lpitemname;
    LPSTR           lpopt;
    LPSTR           lpnextarg;
    LPSTR           lpdata = NULL;
    LPSTR           lpverb = NULL;
    INT         verb;
    WORD            wCmdType;

    ChkC(this);

    intrDebugOut((DEB_ITRACE,
                  "%p _IN CDefClient::DocExecute(hdata=%x)\n",
                  this,
                  hdata));

    // !!!Can we modify the string which has been passed to us
    // rather than duplicating the data. This will get some speed
    // and save some space.

    if(!(hdup = UtDupGlobal(hdata,GMEM_MOVEABLE)))
        goto    errRtn;

    if (!(lpdata  = (LPSTR)GlobalLock (hdup)))
        goto    errRtn;

    retval = ReportResult(0, RPC_E_DDE_SYNTAX_EXECUTE, 0, 0);

    intrDebugOut((DEB_ITRACE,
                  "%p _IN CDefClient::DocExecute command=(%s)\n",
                  this,
                  lpdata));

    if(*lpdata++ != '[') // commands start with the left sqaure bracket
        goto  errRtn;

    // scan the command and scan upto the first arg.
    if (!(wCmdType = ScanCommand(lpdata, WT_DOC, &lpnextarg, &acmd)))
        goto errRtn;

    if (wCmdType == NON_OLE_COMMAND) {

#ifdef  LATER
        if (lpsrvr =  (LPSRVR) GetWindowLongPtr (GetParent (hwnd), 0)) {
            if (!UtilQueryProtocol (lpsrvr->aClass, PROTOCOL_EXECUTE))
                retval = OLE_ERROR_PROTOCOL;
            else {
#ifdef FIREWALLS
                if (!CheckPointer (lpoledoc, WRITE_ACCESS))
                    AssertSz (0, "Invalid LPOLESERVERDOC");
                else if (!CheckPointer (lpoledoc->lpvtbl, WRITE_ACCESS))
                    AssertSz (0, "Invalid LPOLESERVERDOCVTBL");
                else
                    AssertSz (lpoledoc->lpvtbl->Execute,
                        "Invalid pointer to Execute method");
#endif

                retval = (*lpoledoc->lpvtbl->Execute) (lpoledoc, hdata);
            }

        }
#endif
        AssertSz(0, "Doc level execute is being called");

        goto errRtn;
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // [StdCloseDocument]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd == aStdClose){

        LPCLIENT lpclient=NULL;
        // if not terminated by NULL error
        if (*lpnextarg)
            goto errRtn;

        if ((retval = FindItem (NULL, (LPCLIENT FAR *)&lpclient)) != NOERROR)
        {
            goto errRtn;
        }


        lpclient->m_fGotStdCloseDoc = TRUE;
        retval = lpclient->m_lpoleObj->Close (OLECLOSE_SAVEIFDIRTY);
        goto end;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdDoVerbItem("itemname", verb, BOOL, BOOL]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd == aStdDoVerbItem){
        lpitemname = lpnextarg;

        if(!(lpverb = ScanArg(lpnextarg)))
            goto errRtn;


    if(!(lpnextarg = ScanNumArg(lpverb, &verb)))
            goto errRtn;

#ifdef  FIREWALLS
        AssertSz (verb < 9 , "Unexpected verb number");
#endif

        // now scan the show BOOL

        if (!(lpnextarg = ScanBoolArg (lpnextarg, (BOOL FAR *)&fShow)))
            goto errRtn;

        fActivate = FALSE;

        // if activate BOOL is present, scan it.

        if (*lpnextarg) {
            if (!(lpnextarg = ScanBoolArg (lpnextarg, (BOOL FAR *)&fActivate)))
                goto errRtn;
        }

        if (*lpnextarg)
            goto errRtn;

        if (m_fEmbed)
        {
            // This is a totally bogus call to SetHostNames whose only
            // purpose is to notify the server that this is an embedded
            // (not linked) object.
            if (!m_fDidRealSetHostNames)
            {
                Puts ("Bogus call to SetHostNames before DoVerb\r\n");
                m_lpoleObj->SetHostNames (OLESTR("Container"), OLESTR("Object"));
            }
        }
        // REVIEW: We are assuming that calling the Docdoverb method
        // will not post any more DDE messahes.

        retval = DocDoVerbItem (lpitemname, (WORD) verb, fShow, !fActivate);
        goto end;
    }





    //////////////////////////////////////////////////////////////////////////
    //
    // [StdShowItem("itemname"[, "true"])]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd != aStdShowItem)
        goto errRtn;

    lpitemname = lpnextarg;

    if(!(lpopt = ScanArg(lpitemname)))
        goto errRtn;

    // Now scan for optional parameter.

    fActivate = FALSE;

    if (*lpopt) {

        if(!(lpnextarg = ScanBoolArg (lpopt, (BOOL FAR *)&fActivate)))
            goto errRtn;

        if (*lpnextarg)
            goto errRtn;


    }

    if (m_fEmbed)
    {
        // This is a totally bogus call to SetHostNames whose only
        // purpose is to notify the server that this is an embedded
        // (not linked) object.
        // REVIEW LINK
        if (!m_fDidRealSetHostNames)
        {
            Puts ("Bogus call to SetHostNames before ShowItem\r\n");
            m_lpoleObj->SetHostNames (OLESTR("Container"), OLESTR("Object"));
        }
    }

    retval = DocShowItem (lpitemname, !fActivate);

end:
errRtn:
   if (lpdata)
        GlobalUnlock (hdup);

   if (hdup)
        GlobalFree (hdup);

    intrDebugOut((DEB_ITRACE,
                  "%p _OUT CDefClient::DocExecute(hdata=%x) hresult=%x\n",
                  this,
                  hdata,
                  retval));

   return (HRESULT)retval;
}



INTERNAL_(HRESULT)   CDefClient::DocShowItem
(
LPSTR       lpAnsiitemname,
BOOL        fAct
)
{
    LPCLIENT        lpclient;
    HRESULT             retval;
    LPOLEOBJECT lpoleObj;

    ChkC(this);
    WCHAR       lpitemname[MAX_STR];

    if (MultiByteToWideChar(CP_ACP,0,lpAnsiitemname,-1,lpitemname,MAX_STR) == FALSE)
    {
        Assert(!"Unable to convert characters");
        return(E_UNEXPECTED);
    }

    if ((retval = FindItem (lpitemname, (LPCLIENT FAR *)&lpclient))
           != NOERROR)
       return retval;

    ChkC(lpclient);

    lpoleObj = lpclient->m_lpoleObj;


#ifdef FIREWALLS1
        if (!CheckPointer (lpoleObj->lpvtbl, WRITE_ACCESS))
            AssertSz (0, "Invalid LPOLEOBJECTVTBL");
        else
            AssertSz (lpoleObj->lpvtbl->DoVerb,
                "Invalid pointer to DoVerb method");
#endif

    // protocol sends false for activating and TRUE for not activating.
    // for api send TRUE for avtivating and FALSE for not activating.
    return lpclient->m_lpoleObj->DoVerb(OLEVERB_SHOW, NULL, NULL, NULL, NULL, NULL);
}



INTERNAL_(HRESULT)   CDefClient::DocDoVerbItem
(
LPSTR       lpAnsiitemname,
WORD        verb,
BOOL        fShow,
BOOL        fAct
)
{
    LPCLIENT    lpclient;
    HRESULT     retval;

    WCHAR       lpitemname[MAX_STR];

    if (MultiByteToWideChar(CP_ACP,0,lpAnsiitemname,-1,lpitemname,MAX_STR) == FALSE)
    {
        Assert(!"Unable to convert characters");
        return(E_UNEXPECTED);
    }

    ChkC(this);
    Puts ("DefClient::DocDoVerbItem\r\n");
    if ((retval = FindItem (lpitemname, (LPCLIENT FAR *)&lpclient))
           != NOERROR)
       return retval;
    ChkC(lpclient);

#ifdef FIREWALLS1
        if (!CheckPointer (lpclient->lpoleObj->lpvtbl, WRITE_ACCESS))
            AssertSz (0, "Invalid LPOLEOBJECTVTBL");
        else
            AssertSz (lpclient->lpoleObj->lpvtbl->DoVerb,
                "Invalid pointer to DoVerb method");
#endif

    // pass TRUE to activate and False not to activate. Differnt from
    // protocol.

    retval = lpclient->m_lpoleObj->DoVerb(verb, NULL, &m_OleClientSite, NULL, NULL, NULL);
    // Apparently an obsolete version of Lotus Notes is the only
    // container (other than Cltest) that sets fShow=FALSE
    if (!fShow && lpclient->m_lpoleObj && lpclient->m_fEmbed)
        lpclient->m_lpoleObj->DoVerb(OLEIVERB_HIDE, NULL, &m_OleClientSite, NULL, NULL, NULL);
    return retval;
}

INTERNAL CDefClient::DoInitNew()
{
        HRESULT hresult;
        ATOM aClass;
        LPPERSISTSTORAGE pPersistStg=NULL;

        hresult = m_lpoleObj->QueryInterface(IID_IPersistStorage,
                                                                (LPLPVOID)&pPersistStg);
        if (hresult == NOERROR)
        {
                CLSID clsid;
                RetZ (pPersistStg);
                ErrRtnH (CreateILockBytesOnHGlobal ((HGLOBAL)NULL,
                                                           /*fDeleteOnRelease*/ TRUE,
                                                           &m_plkbytNative));
            ErrZS (m_plkbytNative, E_OUTOFMEMORY);

        ErrRtnH (StgCreateDocfileOnILockBytes
                                                (m_plkbytNative,
                                                 grfCreateStg, 0,
                                                 &m_pstgNative));

            ErrZS (m_pstgNative, E_OUTOFMEMORY);

                aClass = m_psrvrParent->m_cnvtyp == cnvtypTreatAs ? m_psrvrParent->m_aOriginalClass
                                                                : m_psrvrParent->m_aClass;
                // Write appropriate class tag
                ErrZS (CLSIDFromAtom (aClass,(LPCLSID)&clsid),
                                       REGDB_E_CLASSNOTREG);
                ErrRtnH (WriteClassStg (m_pstgNative, clsid));

                // Provide server with a storage to use for its persistent
                // storage, i.e., native data.  We remember this IStorage and the
                // ILockBytes it is built on.
        ErrRtnH (pPersistStg->InitNew(m_pstgNative));
                m_fGotEditNoPokeNativeYet = FALSE;

                // Now that we have initialized the object, we are allowed to
                // set the client site, and advise.
                ErrRtnH (SetClientSite());

                // This is for Packager, in particular.  If client does not advise
                // on any data, we still need to do an OLE advise so we can get
                // OnClose notifications.
                DoOle20Advise (OLE_CLOSED, (CLIPFORMAT)0);
        }
        else
        {
                AssertSz (0, "Can't get IPersistStorage from OleObj\r\n");
        }

        m_fEmbed = TRUE;

errRtn:
   if (pPersistStg)
                pPersistStg->Release();
        return hresult;
}


// FreePokeData: Frees the poked dats.
INTERNAL_(void) FreePokeData
(
HANDLE  hdde
)
{
    DDEPOKE FAR * lpdde;
    Puts ("FreePokeData\r\n");

    if (hdde) {
        if (lpdde = (DDEPOKE FAR *) GlobalLock (hdde)) {
            GlobalUnlock (hdde);
#ifdef _WIN64
            if (lpdde->cfFormat == CF_METAFILEPICT)
            	FreeGDIdata(*(void* _unaligned*)lpdde->Value, lpdde->cfFormat);
            else
#endif            	
                FreeGDIdata (LongToHandle(*(LONG*)lpdde->Value), lpdde->cfFormat);
        }

        GlobalFree (hdde);
    }
}



// Returns TRUE if GDI format else returns FALSE

INTERNAL_(BOOL) FreeGDIdata
(
HANDLE          hData,
CLIPFORMAT      cfFormat
)
{
    Puts ("FreeGDIData\r\n");
    if (cfFormat == CF_METAFILEPICT) {
        LPMETAFILEPICT  lpMfp;

        if (lpMfp = (LPMETAFILEPICT) GlobalLock (hData)) {
            GlobalUnlock (hData);
            DeleteMetaFile (lpMfp->hMF);
        }

        GlobalFree (hData);
    }
    else if (cfFormat == CF_BITMAP)
        DeleteObject (hData);
    else if (cfFormat == CF_DIB)
        GlobalFree (hData);
    else
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\itemutil.cxx ===
// itemutil.h//
// routines used by item.cpp
// They used to be in item.cpp but it got too big.


#include "ole2int.h"
#include "srvr.h"
#include "itemutil.h"
#include "ddedebug.h"

ASSERTDATA


//ScanItemOptions: Scan for the item options like Close/Save etc.

INTERNAL_(HRESULT) ScanItemOptions
(
LPOLESTR   lpbuf,
int far *lpoptions
)
{

    ATOM    aModifier;

    *lpoptions = OLE_CHANGED;
    while ( *lpbuf && *lpbuf != '/') lpbuf++;

    // no modifier same as /change

    if (*lpbuf == NULL)
	return NOERROR;

    *lpbuf++ = NULL;        // seperate out the item string
			    // We are using this in the caller.

    if (!(aModifier = GlobalFindAtom (lpbuf)))
	return ReportResult(0, RPC_E_DDE_SYNTAX_ITEM, 0, 0);

    if (aModifier == aChange)
	return NOERROR;

    // Is it a save?
    if (aModifier == aSave){
	*lpoptions = OLE_SAVED;
	return  NOERROR;
    }
    // Is it a Close?
    if (aModifier == aClose){
	*lpoptions = OLE_CLOSED;
	return NOERROR;
    }

    // unknow modifier
    return ReportResult(0, RPC_E_DDE_SYNTAX_ITEM, 0, 0);

}




//MakeDDEData: Create a Global DDE data handle from the server
// app data handle.

INTERNAL_(BOOL) MakeDDEData
(
HANDLE      hdata,
int         format,
LPHANDLE    lph,
BOOL        fResponse
)
{
    DWORD       size;
    HANDLE      hdde   = NULL;
    DDEDATA FAR *lpdata= NULL;
    BOOL	bnative;
    LPSTR       lpdst;
    LPSTR       lpsrc;

    Puts ("MakeDDEData\r\n");

    if (!hdata) {
	*lph = NULL;
	return TRUE;
    }

	
    if (bnative = !(format == CF_METAFILEPICT
            || format == CF_ENHMETAFILE
            || format == CF_DIB
            || format == CF_BITMAP))
    {
	// g_cfNative, CF_TEXT, g_cfBinary
       size = (ULONG) GlobalSize (hdata) + sizeof (DDEDATA);
    }
    else
       size = sizeof (HANDLE_PTR) + sizeof (DDEDATA);


    hdde = (HANDLE) GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, size);
    if (hdde == NULL || (lpdata = (DDEDATA FAR *) GlobalLock (hdde)) == NULL)
	goto errRtn;

    // set the data otions. Ask the client to delete
    // it always.

    lpdata->fAckReq  = FALSE;
    lpdata->fRelease = TRUE;  // release the data
    lpdata->cfFormat = (CLIPFORMAT) format;
    lpdata->fResponse = fResponse;

    if (!bnative) {

	// If not native, stick in the handle what the server gave us.
#ifdef _WIN64
        if (format == CF_METAFILEPICT)
            *(void* __unaligned*)lpdata->Value = hdata;
        else
#endif
            *(LONG*)lpdata->Value = HandleToLong(hdata);
    }
    else {
	// copy the native data junk here.
	lpdst = (LPSTR)lpdata->Value;
	if(!(lpsrc = (LPSTR)GlobalLock (hdata)))
	    goto errRtn;

	 size -= sizeof (DDEDATA);
	 memcpy (lpdst, lpsrc, size);
	 GlobalUnlock (hdata);
	 GlobalFree (hdata);

    }

    GlobalUnlock (hdde);
    *lph = hdde;
    return TRUE;

errRtn:
    if (lpdata)
	GlobalUnlock (hdde);

    if (hdde)
	GlobalFree (hdde);

    if (bnative)
	 GlobalFree (hdata);

    return FALSE;
}



// IsAdviseStdItems: returns true if the item is one of the standard items
// StdDocName;
INTERNAL_(BOOL)     IsAdviseStdItems (
ATOM   aItem
)
{

    if ( aItem == aStdDocName)
	return TRUE;
    else
	return FALSE;
}



// GetStdItemIndex: returns index to Stditems in the "stdStrTable" if the item
// is one of the standard items StdHostNames, StdTargetDevice,
// StdDocDimensions, StdColorScheme
WCHAR * stdStrTable[STDHOSTNAMES+1] = {NULL,
				       OLESTR("StdTargetDevice"),
				       OLESTR("StdDocDimensions"),
				       OLESTR("StdColorScheme"),
				       OLESTR("StdHostNames")};

INTERNAL_(int)  GetStdItemIndex (
ATOM   aItem
)
{

    WCHAR    str[MAX_STR];

    if (!aItem)
	return NULL;

    if (!GlobalGetAtomName (aItem, str, MAX_STR))
	return NULL;

    if (!lstrcmpiW (str, stdStrTable[STDTARGETDEVICE]))
	return STDTARGETDEVICE;
    else if (!lstrcmpiW (str, stdStrTable[STDHOSTNAMES]))
	return STDHOSTNAMES;
    else if (!lstrcmpiW (str, stdStrTable[STDDOCDIMENSIONS]))
	return STDDOCDIMENSIONS;
    else if (!lstrcmpiW (str, stdStrTable[STDCOLORSCHEME]))
	return STDCOLORSCHEME;

    return NULL;
}




void ChangeOwner
    (HANDLE hmfp)
{

#ifndef WIN32
    LPMETAFILEPICT  lpmfp;
    if (lpmfp = (LPMETAFILEPICT) GlobalLock (hmfp))
    {
	SetMetaFileBitsBetter (lpmfp->hMF);
	GlobalUnlock (hmfp);
    }
#endif
}


INTERNAL_(HANDLE)  MakeItemData
(
DDEPOKE FAR *   lpPoke,
HANDLE  	hPoke,
CLIPFORMAT      cfFormat
)
{
    HANDLE  hnew;
    LPBYTE   lpnew;
    DWORD   dwSize;

    Puts ("MakeItemData\r\n");

    if (cfFormat == CF_METAFILEPICT) {
#ifdef _WIN64
        return DuplicateMetaFile(*(void* __unaligned*)lpPoke->Value);
#else
	return DuplicateMetaFile (*(LPHANDLE)lpPoke->Value);
#endif
    }
    
    if (cfFormat == CF_BITMAP)
	return (HANDLE)DuplicateBitmap ((HBITMAP)LongToHandle(*(LONG*)lpPoke->Value));

    if (cfFormat == CF_DIB)
	return UtDupGlobal (LongToHandle(*(LONG*)lpPoke->Value), GMEM_MOVEABLE);

    // Now we are dealing with normal case
    if (!(dwSize = (DWORD) GlobalSize (hPoke)))
	return NULL;

    dwSize -= sizeof (DDEPOKE) - sizeof(BYTE);

    // Use GMEM_ZEROINIT so there is no garbage after the data in field Value.
    // This may be important when making an IStorage from native data,
    // but I'm not sure.
    // Note that the Value field itself could have garbage
    // at the end if the hData of the DDE_POKE message is bigger than
    // necessary, i.e.,
    // GlobalSize(hData) > sizeof(DDEPOKE) - sizeof(Value) + realsize(Value)

    // A DocFile is of size 512n
    DebugOnly (
    if (cfFormat==g_cfNative && dwSize%512 != 0)
    {
	Putsi(dwSize);
	Puts ("DDE_POKE.Value not of size 512n\r\n");
    }
    )

    if (hnew = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT, dwSize)) {
	if (lpnew = (LPBYTE) GlobalLock (hnew)) {
	    memcpy (lpnew, lpPoke->Value, dwSize);
	    GlobalUnlock (hnew);
	}
	else {
	    GlobalFree (hnew);
	    hnew = NULL;
	}
    }

    return hnew;
}



INTERNAL_(HANDLE)  DuplicateMetaFile
(
HANDLE hSrcData
)
{
    LPMETAFILEPICT  lpSrcMfp;
    LPMETAFILEPICT  lpDstMfp = NULL;
    HANDLE          hMF = NULL;
    HANDLE          hDstMfp = NULL;

    Puts ("DuplicateMetaFile\r\n");
	
    if (!(lpSrcMfp = (LPMETAFILEPICT) GlobalLock(hSrcData)))
	return NULL;
	
    GlobalUnlock (hSrcData);
	
    if (!(hMF = CopyMetaFile (lpSrcMfp->hMF, NULL)))
	return NULL;
	
    if (!(hDstMfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
	goto errMfp;

    if (!(lpDstMfp = (LPMETAFILEPICT) GlobalLock (hDstMfp)))
	goto errMfp;
	
    GlobalUnlock (hDstMfp);
	
    *lpDstMfp = *lpSrcMfp;
    lpDstMfp->hMF = (HMETAFILE)hMF;
    return hDstMfp;
errMfp:
    //
    // The following Metafile was created in this
    // process. Therefore, the delete shouldn't need to
    // call the DDE functions for deleting the DDE pair
    //
    if (hMF)
	DeleteMetaFile ((HMETAFILE)hMF);
	
    if (hDstMfp)
	GlobalFree (hDstMfp);
	
     return NULL;
}



INTERNAL_(HBITMAP)  DuplicateBitmap
(
HBITMAP     hold
)
{
    HBITMAP     hnew;
    HANDLE      hMem;
    LPBYTE      lpMem;
    LONG	retVal = TRUE;
    DWORD       dwSize;
    BITMAP      bm;

     // !!! another way to duplicate the bitmap

    Puts ("DuplicateBitmap\r\n");

    GetObject (hold, sizeof(BITMAP), (LPSTR) &bm);
    dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) *
	     ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);

    if (!(hMem = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, dwSize)))
	return NULL;

    if (!(lpMem = (LPBYTE) GlobalLock (hMem))){
	GlobalFree (hMem);
	return NULL;
    }

    GetBitmapBits (hold, dwSize, lpMem);
    if (hnew = CreateBitmap (bm.bmWidth, bm.bmHeight,
		    bm.bmPlanes, bm.bmBitsPixel, NULL))
	retVal = SetBitmapBits (hnew, dwSize, lpMem);

    GlobalUnlock (hMem);
    GlobalFree (hMem);

    if (hnew && (!retVal)) {
	DeleteObject (hnew);
	hnew = NULL;
    }

    return hnew;
}




// CDefClient::GetData
//
// Perform a normal GetData on m_lpdataObj, but if g_cfNative is requested,
// do an OleSave onto our IStorage implemented
// on top of an ILockBytes, then convert the ILockBytes to an hGlobal.
// This flattened IStorage will be used as the native data.
//
INTERNAL CDefClient::GetData
    (LPFORMATETC    pformatetc,
    LPSTGMEDIUM     pmedium)
{
    LPPERSISTSTORAGE pPersistStg=NULL;
    HANDLE           hNative    =NULL;
    HANDLE           hNativeDup =NULL;
    HRESULT          hresult    =NOERROR;
    BOOL	     fFreeHNative = FALSE;
    CLSID	     clsid;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::GetData(%x,%x)\n",
		  this,
		  pformatetc,
		  pmedium));

    intrDebugOut((DEB_ITRACE,
		  " ::GetData format=%x\n",
		  pformatetc->cfFormat));

    if (pformatetc->cfFormat==g_cfNative)
    {
	ErrRtnH (m_lpdataObj->QueryInterface (IID_IPersistStorage,
					  (LPLPVOID) &pPersistStg));
	ErrZ (pPersistStg);
	if (NULL==m_pstgNative)
	{
	    // Embed from file case
	    Assert (NULL==m_plkbytNative);
	    ErrRtnH (CreateILockBytesOnHGlobal (NULL,
					       /*fDeleteOnRelease*/TRUE,
					       &m_plkbytNative));

	    Assert (m_plkbytNative);

	    ErrRtnH (StgCreateDocfileOnILockBytes (m_plkbytNative,
					    grfCreateStg, 0, &m_pstgNative));

	    ErrZ (m_pstgNative);
	    Assert (NOERROR==StgIsStorageILockBytes(m_plkbytNative));

	    m_fInOleSave = TRUE;
	    hresult = OleSave (pPersistStg, m_pstgNative, FALSE);
	    pPersistStg->SaveCompleted(NULL);
	    m_fInOleSave = FALSE;
	    ErrRtnH (hresult);
	}
	else
	{
	    // Get the native data by calling OleSave
	    m_fInOleSave = TRUE;
	    hresult = OleSave (pPersistStg, m_pstgNative, TRUE);
	    pPersistStg->SaveCompleted(NULL);
	    m_fInOleSave = FALSE;
	    ErrRtnH (hresult);
	}

	ErrRtnH (ReadClassStg (m_pstgNative, &clsid));

	if (CoIsOle1Class (clsid))
	{
	    // TreatAs case:
	    // Get Native data from "\1Ole10Native" stream
	    fFreeHNative = TRUE;
	    ErrRtnH (StRead10NativeData (m_pstgNative, &hNative));

	    pmedium->hGlobal = hNative;
	}
	else
	{

	    Assert (NOERROR==StgIsStorageILockBytes (m_plkbytNative));
	    ErrRtnH (GetHGlobalFromILockBytes (m_plkbytNative, &hNative));


	    // Must duplicate because we let the client free the handle,
	    // so it can't be the one our ILockBytes depends on.
	    hNativeDup = UtDupGlobal (hNative, GMEM_DDESHARE | GMEM_MOVEABLE);
	    ErrZ (wIsValidHandle (hNativeDup, g_cfNative));

	    if (hNativeDup && (GlobalSize(hNativeDup) % 512 != 0))
	    {
		Puts ("WARNING:\r\n\t");
		Putsi (GlobalSize(hNativeDup));
	    }


	    pmedium->hGlobal = hNativeDup;
	}

	ErrZ (wIsValidHandle (pmedium->hGlobal,g_cfNative));

	pmedium->tymed  	= TYMED_HGLOBAL;
	pmedium->pUnkForRelease = NULL;

	pPersistStg->Release();
	hresult = NOERROR;
	goto exitRtn;
    }
    else
    {
	// Anything but native
	hresult = m_lpdataObj->GetData (pformatetc, pmedium);
//	AssertOutStgmedium(hresult, pmedium);
	goto exitRtn;
    }


errRtn:
    if (hNative && fFreeHNative)
	GlobalFree (hNative);
    if (pPersistStg)
	pPersistStg->Release();

    pmedium->tymed = TYMED_NULL;
    pmedium->pUnkForRelease = NULL;

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x OUT CDefClient::GetData() return %x\n",
		  this,
		  hresult));
    return hresult;
}


// Set pformatetc->tymed based on pformatetc->cfFormat
//
INTERNAL wSetTymed
    (LPFORMATETC pformatetc)
{
    if (pformatetc->cfFormat == CF_METAFILEPICT)
    {
	    pformatetc->tymed = TYMED_MFPICT;
    }
    else if (pformatetc->cfFormat == CF_ENHMETAFILE)
    {
	    pformatetc->tymed = TYMED_ENHMF;
    }
    else if (pformatetc->cfFormat == CF_PALETTE ||
	     pformatetc->cfFormat == CF_BITMAP)
    {
	pformatetc->tymed = TYMED_GDI;
    }
    else
    {
	pformatetc->tymed = TYMED_HGLOBAL;
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\item.cxx ===
/****************************** Module Header ******************************\
* Module Name: Item.c Object(item) main module
*
* Purpose: Includes All the object releated routiens.
*
* Created: Oct 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*
*
\***************************************************************************/


#include "ole2int.h"
//#include "cmacs.h"
#include <dde.h>
#include "ddeatoms.h"
#include "ddedebug.h"
#include "srvr.h"
#include "itemutil.h"

ASSERTDATA


// !!!change child enumeration.
// !!!No consistency in errors (Sometimes Bools and sometimes HRESULT).


//SearchItem: Searches for a given item in a document tree.
//If found, returns the corresponding client ptr.

INTERNAL_(LPCLIENT)   CDefClient::SearchItem
(
LPOLESTR        lpitemname
)

{
    ATOM    aItem;
    LPCLIENT    lpclient;

    ChkC(this);
    Assert (m_pdoc==this);
    Assert (m_bContainer);

    Puts ("DefClient::SearchItem\r\n");
    // If the item passed is an atom, get its name.
    if (!HIWORD(lpitemname))
    aItem = (ATOM) (LOWORD(PtrToUlong (lpitemname)));
    else if (!lpitemname[0])
    aItem = NULL;
    else
    aItem = GlobalFindAtom (lpitemname);

    // walk thru the items list and mtach for the itemname.
    lpclient = this;

    while (lpclient) {
    ChkC(lpclient);
    if (lpclient->m_aItem == aItem)
        return lpclient;
    // The NULL item is the client that is a container (the whole doc).
    // REVIEW: jasonful
    if (lpclient->m_bContainer && aItem==NULL)
        return lpclient;
    lpclient = lpclient->m_lpNextItem;
    }

    Puts ("SearchItem failed\r\n");
    return NULL;

}



// FindItem: Given the itemname and the doc obj ptr,
// searches for the the item (object) in the document tree.
// Items are lonked to the doc obj.

INTERNAL_(HRESULT)  CDefClient::FindItem
(
LPOLESTR        lpitemname,
LPCLIENT FAR *      lplpclient
)
{
    LPCLIENT    lpclient;
    WCHAR   buf[MAX_STR];

    Puts ("DefClient::FindItem "); Puts (lpitemname); Putn();
    ChkC(this);

    if (lpclient = SearchItem (lpitemname)) {
    // we found the item window

        ChkC(lpclient);
        *lplpclient = lpclient;
        return NOERROR;

    }

    if (!HIWORD(lpitemname)){
    if (LOWORD(lpitemname))
        GlobalGetAtomName ((ATOM)LOWORD(PtrToUlong (lpitemname)),
                   buf, MAX_STR);
    else
        buf[0] = NULL;
    
    lpitemname = buf;
    }

    // Item (object)window is not created yet. Let us create one.
    return RegisterItem (lpitemname, lplpclient, TRUE);
}



//RegisterItem: Given the document handle and the item string
//creates item with the given name in the doc obj list..

INTERNAL  CDefClient::RegisterItem
    (LPOLESTR          lpitemname,
    LPCLIENT FAR *  lplpclient,
    BOOL        bSrvr)
{
    LPCLIENT        pitemNew = NULL;
    HRESULT         hresult   = ReportResult(0, E_UNEXPECTED, 0, 0);
    LPOLEOBJECT     lpoleObj = NULL;
    LPOLEITEMCONTAINER  lpcontainer;

    intrDebugOut((DEB_ITRACE,
          "%x _IN CDefClient::RegisterItem(%ws)\n",
          this,WIDECHECK(lpitemname)));
    ChkC(this);
    AssertIsDoc(this);
    *lplpclient  = NULL;

    ErrZS (pitemNew = new CDefClient(NULL), E_OUTOFMEMORY);

    pitemNew->m_bTerminate = FALSE;
    pitemNew->m_bContainer = FALSE;       // not a container, i.e.,document


    // Set containing document
    pitemNew->m_pdoc = this;
    m_pUnkOuter->AddRef(); // item keeps its document alive
            // Corresponding Release is in CDefClient::~CDefClient

    if (!HIWORD(lpitemname)) {
    AssertSz (!bSrvr, "invalid lpitemname in RegisterItem\r\n");
    pitemNew->m_aItem = LOWORD(PtrToUlong (lpitemname));
    }
    else if (!lpitemname[0])
    pitemNew->m_aItem = NULL;
    else
    pitemNew->m_aItem = wGlobalAddAtom (lpitemname);

    lpoleObj = m_lpoleObj;

    // Call the server if the item is not one of the standard items.
    if (bSrvr) {

    // Call the server app for container interface
    hresult = lpoleObj->QueryInterface (IID_IOleItemContainer, (LPVOID FAR *)&lpcontainer);

    if (hresult != NOERROR)
    {
        intrDebugOut((DEB_IERROR,
              "%x ::RegisterItem(%ws) No IOleContainer intr\n",
              this,WIDECHECK(lpitemname)));
        goto errRtn;
    }

    hresult = lpcontainer->GetObject(lpitemname, BINDSPEED_INDEFINITE, 0,
        IID_IOleObject, (LPLPVOID)&pitemNew->m_lpoleObj);

        if (hresult != NOERROR)
    {
        intrDebugOut((DEB_ERROR,
              "IOleItemContainer::GetObject(%ws,...) failed (hr=%x)\n",
              lpitemname,
              hresult));
    }

    lpcontainer->Release ();
    if (hresult != NOERROR)
        goto errRtn;

    hresult = pitemNew->m_lpoleObj->QueryInterface (IID_IDataObject, (LPLPVOID)
                           &pitemNew->m_lpdataObj);

        if (hresult != NOERROR)
    {
        intrDebugOut((DEB_ERROR,
              "::QueryInterface(IID_IDataObject) failed (hr=%x)\n",
              hresult));
        pitemNew->m_lpoleObj->Release();
            goto errRtn;
    }


    // This is for Packager, in particular.  If client does not advise
    // on any data, we still need to do an OLE advise so we can get
    // OnClose notifications.
    pitemNew->DoOle20Advise (OLE_CLOSED, (CLIPFORMAT)0);
    }



    // This keeps the CDefClient alive until _we_ are done with it
    // The corresponding Release is in CDefClient::Revoke
    pitemNew->m_pUnkOuter->AddRef();

    pitemNew->m_lpNextItem    = m_lpNextItem;
    pitemNew->m_hwnd          = m_hwnd; // set the window handle to
                    // same as the doc level window

    m_lpNextItem = pitemNew;
    *lplpclient  = pitemNew;

    hresult = NOERROR;
    goto exitRtn;

errRtn:
    if (pitemNew) {
    delete pitemNew;
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
          "%x CDefClient::RegisterItem(%ws) hresult=%x\n",
          this,WIDECHECK(lpitemname),hresult));


    return(hresult);
}



// Return NOERROR if "this" document has no items which have connections
// (client windows).
//
INTERNAL CDefClient::NoItemConnections (void)
{
    PCLINFO       pclinfo = NULL;
    HANDLE        hcliPrev = NULL;
    HANDLE        hcli;
    PCLILIST      pcli;
    HANDLE        *phandle;

    ChkCR (this);
    AssertIsDoc (this);
    LPCLIENT pitem;
    for (pitem = m_lpNextItem;
     pitem;
     pitem = pitem->m_lpNextItem)
    {
    ChkCR (pitem);
    if (pitem->m_aItem == aStdDocName)
        continue;
    hcli = pitem->m_hcliInfo;
    while (hcli)
    {
        if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
        return ResultFromScode (S_FALSE);

        phandle = (HANDLE *) (pcli->info);
        while (phandle < (HANDLE *)(pcli + 1))
        {
        if (*phandle)
        {
            LocalUnlock (hcli);
            return ResultFromScode (S_FALSE);
        }
        else
        {
            phandle++;
            phandle++;
        }
        }

        hcliPrev = hcli;
        hcli = pcli->hcliNext;
        LocalUnlock (hcliPrev);
    }
    }
    return NOERROR;
}
    


INTERNAL_(void) CDefClient::DeleteAdviseInfo (void)
{


    PCLINFO       pclinfo = NULL;
    HANDLE        hcliPrev = NULL;
    PCLILIST      pcli;
    HANDLE        *phandle;
    HANDLE        hcli;
    HANDLE        hcliInfo;

    Puts ("DefClient::DeleteAdviseInfo\r\n");
    ChkC(this);
    hcli = m_hcliInfo;
    while (hcli) {
    if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
        return;

    phandle = (HANDLE *) (pcli->info);
    while (phandle < (HANDLE *)(pcli + 1)) {
        if (*phandle) {
        *phandle++ = 0;

        // delete the printer dev info block
        if(pclinfo = (PCLINFO)LocalLock ((hcliInfo = *phandle++))){
            if(pclinfo->hdevInfo)
            GlobalFree (pclinfo->hdevInfo);

            LocalUnlock (hcliInfo);
            // no free if lock failed
            LocalFree (hcliInfo);
        }
        } else {
        phandle++;
        phandle++;

        }
    }

    hcliPrev = hcli;
    hcli = pcli->hcliNext;
    LocalUnlock (hcliPrev);
    LocalFree (hcliPrev);       // free the block;
    }
    m_hcliInfo = NULL;
}



//DeleteFromItemsList: Deletes a client from the object lists of
//all the objects of a given  document. Thie client possibly
//is terminating the conversation with our doc window.
//
INTERNAL_(void) CDefClient::DeleteFromItemsList
    (HWND hwndClient)
{
    HANDLE          hclinfo;
    PCLINFO         pclinfo;
    LPCLIENT        lpclient;
    LPCLIENT FAR*   ppitemLast = NULL;
    BOOL        fRevokedDoc = FALSE;
    static int staticcounter;
    int counter = ++staticcounter;

    Puts ("DefClient::DeleteFromItemsList "); Puti(counter); Putn();
    AssertIsDoc(this);
    lpclient = this;
    ppitemLast = &m_lpNextItem;
    while (lpclient)
    {
    ChkC(lpclient);
    BOOL fDoc = (lpclient==this);
    if (fDoc)
    {
        AssertIsDoc (lpclient);
        // Remove window from doc's master list
        HWND hwnd = (HWND) FindClient (lpclient->m_hcli, hwndClient, /*fDelete*/TRUE);
        Assert (hwnd==hwndClient);
    }

    hclinfo = FindClient (lpclient->m_hcliInfo, hwndClient, /*fDelete*/TRUE);
    LPCLIENT pitemNext = lpclient->m_lpNextItem;

    // We must make sure no other client is connected (linked)
    // to this item before deleting.
    if (!fDoc && AreNoClients (lpclient->m_hcliInfo))
    {
        Assert (ppitemLast);
        if (ppitemLast && !fDoc)
        {
        // Remove from linked list
        *ppitemLast = lpclient->m_lpNextItem;
        }
        fRevokedDoc |= fDoc;
        lpclient->Revoke ();
    }
    else
    {
        ppitemLast = &(lpclient->m_lpNextItem);
    }
    if (hclinfo)
    {
        if(pclinfo = (PCLINFO)LocalLock (hclinfo))
        {
        if(pclinfo->hdevInfo)
            GlobalFree (pclinfo->hdevInfo);
        LocalUnlock (hclinfo);
        }
        LocalFree (hclinfo);
    }
    lpclient = pitemNext;
    }

    // Handle invisible update
    if (!fRevokedDoc && !m_fEmbed //&& !m_fGotDdeAdvise
    && NOERROR ==NoItemConnections()
    && AreNoClients (m_hcliInfo)
    && AreNoClients (m_hcli) )
    {
    ChkC (this);
    Assert (m_lpoleObj);
    Assert (m_lpdataObj);
    ReleaseObjPtrs();
    }
    
    Puts ("DefClient::DeleteFromItemsList Done "); Puti(counter); Putn();
}


INTERNAL_(void) CDefClient::RemoveItemFromItemList
    (void)
{
    // Make sure it's an item
    Assert (m_pdoc != this && !m_bContainer);

    LPCLIENT lpclient = m_pdoc;
    ChkC (lpclient);
    LPCLIENT FAR* ppitemLast = &(m_pdoc->m_lpNextItem);

    while (lpclient)
    {
        ChkC(lpclient);
        if (lpclient==this)
        {
            // Remove from linked list
            *ppitemLast = lpclient->m_lpNextItem;
            break;
        }       
        ppitemLast = &(lpclient->m_lpNextItem);
        lpclient = lpclient->m_lpNextItem;
    }
    Revoke();
}




INTERNAL_(void) CDefClient::ReleaseAllItems ()
{
    LPCLIENT        lpclient;

    Puts ("DefClient::ReleaseAllItems\r\n");
    AssertIsDoc(this);

    // leave the doc level object.
    lpclient = m_lpNextItem;

    while (lpclient)
    {
    ChkC(this);
    LPCLIENT pitemNext = lpclient->m_lpNextItem;
    lpclient->Revoke();
    lpclient = pitemNext;
    }
    // After revoking all the items, we can't keep any refernces to them.
    m_lpNextItem = NULL;
}



INTERNAL_(void)   CDefClient::DeleteAllItems ()
{
    LPCLIENT    lpclient;

    Puts ("DefClient::DeleteAllItems\r\n");
    AssertIsDoc(this);

    // leave the doc level object.
    lpclient = m_lpNextItem;

    while (lpclient)
    {
    ChkC(lpclient);
    if (ISATOM(lpclient->m_aItem))
        GlobalDeleteAtom (lpclient->m_aItem);
    // Delete client advise info
    lpclient->DeleteAdviseInfo ();

    lpclient = lpclient->m_lpNextItem;
    }
}




// PokeData: Prepares and gives the data to the server app thru
// the SetData object method.

INTERNAL CDefClient::PokeData(HWND hwndClient,ATOM aItem,HANDLE hPoke)
{
    HRESULT         hresult = ReportResult(0, E_UNEXPECTED, 0, 0);
    DDEPOKE FAR *   lpPoke = NULL;
    int         format;
    BOOL        fRelease       = FALSE;
    LPPERSISTSTORAGE pPersistStg=NULL;
    FORMATETC       formatetc;
    STGMEDIUM       medium;

    // Due to a C7 bug, do not use a structure initialization for STGMEDIUM
    medium.tymed = TYMED_HGLOBAL;
    medium.hGlobal = NULL; // invalid
    medium.pUnkForRelease= NULL;

    intrDebugOut((DEB_ITRACE,
          "%p CDefClient::PokeData(hwndClient=%x,aItem=%x,hPoke=%x)\n",
          this,hwndClient,aItem,hPoke));

    ChkC(this);
    AssertIsDoc (this);


    // Until now, m_aItem had been the client-generated (ugly) document name.
    // Now it becomes the actual item name, which will almost always be NULL.
    // Only in the TreatAs/ConvertTo case will it be non-NULL.
    m_aItem = aItem;

    formatetc.cfFormat = 0; /* invalid */
    formatetc.ptd = m_ptd;
    formatetc.lindex = DEF_LINDEX;
    formatetc.dwAspect = DVASPECT_CONTENT;
    formatetc.tymed = TYMED_HGLOBAL;

    ErrZS (hPoke && (lpPoke = (DDEPOKE FAR *) GlobalLock (hPoke)),
       E_OUTOFMEMORY);

    format = formatetc.cfFormat = (UINT)(unsigned short)lpPoke->cfFormat;
    Assert (format);
    fRelease = lpPoke->fRelease;

    // We found the item. Now prepare the data to be given to the object
    // MakeItemData returns a newly allocated handle.
    if (!(medium.hGlobal = MakeItemData (lpPoke, hPoke, (CLIPFORMAT) format)))
    goto errRtn;

    // Change type acording to format (not that default has been set above)
    if (format == CF_METAFILEPICT)
    formatetc.tymed = medium.tymed = TYMED_MFPICT;
    else
    if (format == CF_BITMAP)
    formatetc.tymed = medium.tymed = TYMED_GDI;

    // Now send the data to the object
    

    if (formatetc.cfFormat==g_cfNative)
    {
        m_fGotEditNoPokeNativeYet = FALSE;

        // Cannot do SetData.  Must do PersisStg::Load on an IStorage
        // made from the native data, i.e., medium.hGlobal.

        Assert (m_plkbytNative==NULL);
        hresult = CreateILockBytesOnHGlobal (medium.hGlobal,
                            /*fDeleteOnRelease*/TRUE,
                            &m_plkbytNative);

        if (hresult != NOERROR)
        {
            if(medium.hGlobal) ReleaseStgMedium(&medium);
            medium.hGlobal = NULL;
            ErrRtnH(hresult);
        }


        Assert (m_pstgNative==NULL);

        if (NOERROR==StgIsStorageILockBytes(m_plkbytNative))
        {
            // This is a flattened 2.0 storage
            ErrRtnH (StgOpenStorageOnILockBytes (m_plkbytNative,
                            (LPSTORAGE)NULL,
                STGM_READWRITE| STGM_SHARE_EXCLUSIVE| STGM_DIRECT,
                            (SNB)NULL,
                            0,
                            &m_pstgNative));
        }
        else
        {
            // It is a raw 1.0 Native handle.
            // This is the TreatAs/ ConvertTo case.
            LPLOCKBYTES plkbyt = NULL;
            Assert (m_psrvrParent->m_aOriginalClass);

            ErrRtnH (wCreateStgAroundNative (medium.hGlobal,
                             m_psrvrParent->m_aOriginalClass,
                             m_psrvrParent->m_aClass,
                             m_psrvrParent->m_cnvtyp,
                             m_aItem,
                             &m_pstgNative,
                             &plkbyt));


            Assert (m_plkbytNative);
            if (m_plkbytNative)
            {
            // This should free the original native hGlobal also.
            m_plkbytNative->Release();
            medium.hGlobal = NULL;
            }
            m_plkbytNative = plkbyt;

        }

        RetZ (m_pstgNative);
        Assert (m_lpoleObj);
        ErrRtnH (m_lpoleObj->QueryInterface (IID_IPersistStorage,
                            (LPLPVOID) &pPersistStg));
        hresult = pPersistStg->Load (m_pstgNative);
        pPersistStg->Release();
        pPersistStg=NULL;
        ErrRtnH (hresult);

        // Now that we have initialized the object, we can call SetClientSite
        ErrRtnH (SetClientSite() );

        // This is for Packager, in particular.  If client does not advise
        // on any data, we still need to do an OLE advise so we can get
        // OnClose notifications.
        ErrRtnH (DoOle20Advise (OLE_CLOSED, (CLIPFORMAT)0));
    }
    else
    {
        if (m_fGotEditNoPokeNativeYet)
        {
            // We got StdEdit, but instead of getting Poke for native data,
            // we got poke for someother format. So we want to generate
            // InitNew() call for the object.

            hresult = DoInitNew();
            if (hresult != NOERROR)
            {
                if(medium.hGlobal) ReleaseStgMedium(&medium);
                medium.hGlobal = NULL;
                ErrRtnH(hresult);
            }
        }
            
        // Not native format, do SetData
        // Callee frees medium, i.e., the hglobal returned by MakeItemData
        Assert (m_lpdataObj);
        hresult = m_lpdataObj->SetData (&formatetc, &medium, TRUE);

#ifdef _DEBUG
        if (hresult != NOERROR)
        {
            Puts ("****WARNING: SetData failed. cfFormat==");
            WCHAR sz[100];
            GetClipboardFormatName (formatetc.cfFormat, sz, 100);
            Puts (sz);
            Putn();
        }
#endif
        // We free the data if server deos not return NOERROR.
        // Otherwise server must've deleted it.
        if (hresult == NOERROR)
            medium.hGlobal = NULL;
        else if(medium.hGlobal)
            ReleaseStgMedium(&medium);
    }


errRtn:
    GlobalUnlock (hPoke);

    if (fRelease && hPoke)
        GlobalFree (hPoke);

// Do NOT free medium.hGlobal, because it becomes the hGlobal on which
// m_plkbytNative (and therefore m_pstgNative) is based.
// It will be freed when m_plkbytNative is Release().
//    if (medium.hGlobal)
//        ReleaseStgMedium(&medium);
    

    if (pPersistStg)
        pPersistStg->Release();

    return hresult;
}



INTERNAL_(HRESULT)   CDefClient::UnAdviseData
    (HWND            hwndClient,
     ATOM        aItem)
{
    WCHAR       buf[MAX_STR];
    int         options;
    LPCLIENT        lpclient;
    HRESULT         hresult  = ReportResult(0, E_UNEXPECTED, 0, 0);
    HANDLE          hclinfo = NULL;
    PCLINFO         pclinfo = NULL;

    Puts ("DefClient::UnadviseData\r\n");
    ChkC(this);

    if (aItem == NULL)
    {
    buf[0] = NULL;
    }
    else
    {
    GlobalGetAtomName (aItem, buf, MAX_STR);
    }

    // Scan for the advise options like "Close", "Save" etc
    // at the end of the item.

    ErrRtnH (ScanItemOptions (buf, (int far *)&options));

    // Now get the corresponding object.
    ErrRtnH (FindItem (buf, (LPCLIENT FAR *)&lpclient));

    // Find the client structure to be attached to the object.
    if ((hclinfo = FindClient (lpclient->m_hcliInfo, hwndClient, FALSE)) == NULL ||
    (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL )
    {
        hresult = ReportResult(0, E_OUTOFMEMORY, 0, 0);
        goto errRtn;
    }

    pclinfo->options &= (~(0x0001 << options));

errRtn:
    if (pclinfo)
    LocalUnlock (hclinfo);
    return hresult;

}



// AdviseStdItems: This routine takes care of the DDEADVISE for a
//particular object in given document. Creates a client strutcure
//and attaches to the property list of the object window.

INTERNAL_(HRESULT)   CDefClient::AdviseStdItems
(

HWND        hwndClient,
ATOM        aItem,
HANDLE      hopt,
BOOL FAR *  lpfack
)
{

    DDEADVISE FAR       *lpopt;
    HRESULT         hresult = ReportResult(0, E_UNEXPECTED, 0, 0);


    intrDebugOut((DEB_ITRACE,
          "%x _IN CDefClient::AdviseStdItems(hwndClient=%x,aItem=%x(%ws),hopt=%x)\n",
          this,
          hwndClient,
          aItem,
          wAtomName(aItem),
          hopt));

    ChkC(this);
    ErrZS (lpopt = (DDEADVISE FAR *) GlobalLock (hopt), E_OUTOFMEMORY);

    AssertSz (aItem == aStdDocName, "AdviseStdItem is not Documentname");

    *lpfack = lpopt->fAckReq;
    hresult = (HRESULT)SetStdInfo (hwndClient, OLESTR("StdDocumentName"),  NULL);


    if (lpopt)
    GlobalUnlock (hopt);

errRtn:

    if (hresult == NOERROR)
    {
    // Rules say to free handle if ACK will be positive
    GlobalFree (hopt);
    }
    Assert (hresult==NOERROR);
    intrDebugOut((DEB_ITRACE,
          "%x _OUT CDefClient::AdviseStdItems hresult=%x\n",
          this,
          hresult));

    return hresult;
}



//AdviseData: This routine takes care of the DDE_ADVISE for a
//particular object in given document. Creates a client strutcure
//and attaches to the property list of the object window.

INTERNAL CDefClient::AdviseData
(
HWND        hwndClient,
ATOM        aItem,
HANDLE      hopt,
BOOL FAR *  lpfack
)
{
    DDEADVISE FAR   *lpopt = NULL;
    int         format = NULL;
    WCHAR       buf[MAX_STR];
    OLE_NOTIFICATION  options;
    LPCLIENT        lpclient;
    HRESULT         hresult  = ReportResult(0, E_UNEXPECTED, 0, 0);
    HANDLE          hclinfo = NULL;
    PCLINFO         pclinfo = NULL;
    BOOL            fAllocatedClInfo = FALSE;

    intrDebugOut((DEB_ITRACE,
          "%x _IN CDefClient::AdviseData(hwndClient=%x,aItem=%x(%ws),hopt=%x)\n",
          this,
          hwndClient,
          aItem,
          wAtomName(aItem),
          hopt));
    ChkC(this);
    if (m_fGotEditNoPokeNativeYet) {
        // We got StdEdit, but instead of getting Poke for native data,
        // we got advise. So we want to generate InitNew() call for
        // the object.

        DoInitNew();    // the function clears the flag
    }

    m_fGotDdeAdvise = TRUE;

    ErrZS (lpopt = (DDEADVISE FAR *) GlobalLock (hopt), E_OUTOFMEMORY);

    if (!aItem)
    buf[0] = NULL;
    else
    GlobalGetAtomName (aItem, buf, MAX_STR);

    // Scan for the advise options like "Close", "Save" etc
    // at the end of the item.

    // ack flag should be set before the error return. Otherwise the
    // the atom is getting deleted.

    *lpfack = lpopt->fAckReq;
    ErrRtnH (ScanItemOptions (buf, (int far *)&options));

    // Now get the corresponding item.
    ErrRtnH (FindItem (buf, (LPCLIENT FAR *)&lpclient));

    if (!IsFormatAvailable ((CLIPFORMAT)(unsigned short)lpopt->cfFormat)){
    hresult = ReportResult(0, DV_E_CLIPFORMAT, 0, 0);       // this format is not supported;
    goto errRtn;
    }

    lpclient->DoOle20Advise (options, (CLIPFORMAT)(unsigned short)lpopt->cfFormat);


    // Create the client structure to be attcahed to the object.
    if (!(hclinfo = FindClient (lpclient->m_hcliInfo, hwndClient, FALSE)))
    {
    hclinfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (CLINFO));
    fAllocatedClInfo = TRUE;
    }


    if (hclinfo == NULL || (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL){
    hresult = ReportResult(0, E_OUTOFMEMORY, 0, 0);
    goto errRtn;
    }

    // Remember the client window (Needed for sending DATA later on
    // when the data change message comes from the server)

    pclinfo->hwnd = hwndClient;
    if ((CLIPFORMAT)(unsigned short)lpopt->cfFormat == g_cfNative)
    pclinfo->bnative = TRUE;
    else
    pclinfo->format = (CLIPFORMAT)(unsigned short)lpopt->cfFormat;

    // Remeber the data transfer options
    pclinfo->options |= (1 << options) ;

    pclinfo->bdata = !lpopt->fDeferUpd;
    LocalUnlock (hclinfo);
    pclinfo = NULL;

    // if the entry exists already, delete it.
    FindClient (lpclient->m_hcliInfo, hwndClient, /*fDelete*/TRUE);

    // Now add this client to item client list
    // !!! This error recovery is not correct.
    if(!AddClient ((LPHANDLE)&lpclient->m_hcliInfo, hwndClient, hclinfo))
    goto errRtn;


errRtn:
    if (lpopt)
    GlobalUnlock (hopt);

    if (pclinfo)
    LocalUnlock (hclinfo);

    if (hresult==NOERROR)
    {
    // hresult==NOERROR iff we will send a postive ACK, so we must
    // free the hOptions handle.
    GlobalFree (hopt);
    }
    else
    {
    intrDebugOut((DEB_IERROR,
              "%x ::AdviseData() failing.\n",this));
    // We free hclinfo because it was not stored in the item's
    // client list via the AddClient just before the errRtn label.
        if (hclinfo && fAllocatedClInfo)
            LocalFree (hclinfo);

    }

    intrDebugOut((DEB_ITRACE,
          "%x _OUT CDefClient::AdviseData() returns hresult = %x\n",
          this, hresult));

    return hresult;

}





INTERNAL_(BOOL)  CDefClient::IsFormatAvailable
    (CLIPFORMAT cfFormat)
{
    intrDebugOut((DEB_ITRACE,
          "%x _IN CDefClient::IsFormatAvailable(cfFormat=%x)\n",
          this, cfFormat));

    ChkC(this);

    BOOL f = ((cfFormat==g_cfNative) || UtIsFormatSupported (m_lpdataObj, DATADIR_GET, cfFormat));

    intrDebugOut((DEB_ITRACE,
          "%x _OUT CDefClient::IsFormatAvailable(cfFormat=%x) returning %x\n",
          this, cfFormat,f));

    return f;
}


//RequestData: Sends data in response to a DDE Request message.
// for  agiven doc and an object.

INTERNAL_(HRESULT)   CDefClient::RequestData
(
HWND        hwndClient,
ATOM        aItem,
USHORT      cfFormat,
LPHANDLE    lphdde
)
{

    HRESULT       hresult = NOERROR;
    LPCLIENT    lpclient;
    FORMATETC   formatetc;
    STGMEDIUM   medium;
    // Due to a C7 bug, do not use a structure initialization for STGMEDIUM
    medium.tymed = TYMED_NULL;
    medium.hGlobal = 0;
    medium.pUnkForRelease= NULL;

    intrDebugOut((DEB_ITRACE,
          "%x _IN CDefClient::RequestData(hwndClient=%x,aItem=%x(%ws),cfFormat=%x,lphdde=%x)\n",
          this,
          hwndClient,
          aItem,
          wAtomName(aItem),
          cfFormat,
          lphdde));
    ChkC(this);

    // If edit environment Send data if we can
    if (aItem == aEditItems)
    {
    hresult = RequestDataStd (aItem, lphdde);
    goto exitRtn;
    }

    hresult = FindItem ((LPOLESTR) MAKEINTATOM(aItem),(LPCLIENT FAR *)&lpclient);
    if (hresult != NOERROR)
    {
    goto errRtn;
    }

    ChkC (lpclient);

    formatetc.cfFormat  = cfFormat;
    formatetc.ptd       = lpclient->m_ptd;
    formatetc.lindex    = DEF_LINDEX;
    formatetc.dwAspect  = DVASPECT_CONTENT;
    formatetc.tymed     = TYMED_HGLOBAL;


    hresult = ReportResult(0, DV_E_FORMATETC, 0, 0);
    if (!lpclient->IsFormatAvailable (formatetc.cfFormat))
    {
    goto errRtn;
    }


    // Now ask the item for the given format  data
    
    SendDevInfo (hwndClient);

    wSetTymed (&formatetc);
    hresult = lpclient->GetData (&formatetc, &medium);
    if (hresult != NOERROR)
    {
    intrDebugOut((DEB_IERROR,
              "GetData returns hresult=%x\n",
              hresult));
    goto errRtn;
    }
    if (medium.tymed & ~(TYMED_HGLOBAL | TYMED_MFPICT | TYMED_GDI))
    {
    AssertSz (0, "Got a storage medium of type other than hGlobal");
    goto errRtn;
    }
    if (cfFormat == CF_METAFILEPICT)
    {
    ChangeOwner (medium.hGlobal);
    }


    // Duplicate the DDE data
    // medium.hGlobal is freed by MakeDdeData or by the client once the
    // DDE_DATA is posted with *lphdde.
    if (MakeDDEData (medium.hGlobal, cfFormat, lphdde, TRUE)){
    // !!! Why do we have to duplicate the atom
    DuplicateAtom (aItem);
    hresult = NOERROR;
    }
    else
    hresult = E_OUTOFMEMORY;

errRtn:
exitRtn:
    intrDebugOut((DEB_ITRACE,
          "%x _OUT CDefClient::RequestData() returning %x\n",
          this, hresult));

    return hresult;
}



// REVIEW: needs review. Item callvback has to be split

// ItemCallback: Calback routine for the server to inform the
// data changes. When the change message is received, DDE data
// message is sent to each of the clients depending on the
// options.

INTERNAL_(HRESULT)  CDefClient::ItemCallBack
(
    int msg,         // notification message
    LPOLESTR szNewName  // for OLE_RENAMED notification
)
{
    intrDebugOut((DEB_ITRACE,
          "%x _IN CDefClient::ItemCallBack(msg=%x,szNewName=%x)\n",
          this,
          szNewName));

    HRESULT       hresult = NOERROR;
    BOOL    bSaved;
    LPCLIENT    lpclientRename;
    LPCLIENT    lpclient;

    ChkC(this);

    if (msg == OLE_RENAMED) {
    
    Assert (szNewName);
    intrDebugOut((DEB_ITRACE,
             "%x ::ItemCallBack(szNewName=(%ws))\n",
             WIDECHECK(szNewName)));


    if (!m_bContainer)
    {
        lpclient = (LPCLIENT)GetWindowLongPtr (m_hwnd, 0);
        Assert (lpclient==m_pdoc);
    }
    else
        lpclient = this;

    Assert (lpclient->m_chk==chkDefClient);

    // Replace the internally-stored name
    if (lpclient->m_aItem)
    {
        GlobalDeleteAtom (lpclient->m_aItem);
        lpclient->m_aItem = wGlobalAddAtom (szNewName);
    }
    

    // find if any StdDocName item is present at all
    if (lpclientRename =
         lpclient->SearchItem ((LPOLESTR) MAKEINTATOM(aStdDocName)))
    {
        HANDLE hDdeData=NULL;

        //
        // We have a new name in UNICODE. Need to create a new
        // name in ANSI.
        //
        LPSTR lpName = CreateAnsiFromUnicode(szNewName);
        if (!lpName)
        {
        hresult = ReportResult(0, E_OUTOFMEMORY, 0, 0);
        goto errrtn;
        }

        HANDLE hNewName = wNewHandle (lpName, strlen(lpName) + 1);

        PrivMemFree(lpName);

        // hNewName is freed by MakeDDEData

        if (!MakeDDEData (hNewName, (int)g_cfBinary, &hDdeData, FALSE))
        {
        hresult = ReportResult(0, E_OUTOFMEMORY, 0, 0);
        goto errrtn;
        }

        Assert (hDdeData);
        lpclientRename->SendRenameMsgs (hDdeData);
        GlobalFree (hDdeData);

        // Post termination for each of the doc clients that did not
        // advise on rename
        lpclient->TerminateNonRenameClients (lpclientRename);
    }


    Assert (FALSE == lpclient->m_fEmbed);

    // REVIEW: what is this?
    //lpclient->m_fEmbed = FALSE;

    hresult = NOERROR;

     errrtn:
    Assert (hresult == NOERROR);
    goto exitRtn;

    } else {

    // Enumerate all the clients and send DDE_DATA if necessary.
    bSaved =  SendDataMsg ((WORD)msg);

    // REVIEW: Hack from 1.0 for old pre-OLE-library apps
    if ((msg == OLE_SAVED) && m_fEmbed && !bSaved)
        return ReportResult(0, RPC_E_DDE_CANT_UPDATE, 0, 0);

    hresult = NOERROR;
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
          "%x _OUT CDefClient::ItemCallBack() returning hresult=%x\n",
          this,hresult));

    return(hresult);
}


// This func should definitely be replaced by use of MFC map. (IsEmpty)
INTERNAL_(BOOL) AreNoClients (HANDLE hcli)
{
    HANDLE        hcliPrev = NULL;
    PCLILIST      pcli;
    HANDLE        *phandle;

    while (hcli) {
    if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
    {
        Puth (hcli);
        Putn();
        Assert(0);
        return TRUE;
    }

    phandle = (HANDLE *) pcli->info;
    while (phandle < (HANDLE *)(pcli + 1))
    {
        if (*phandle)
        {
        LocalUnlock (hcli);
        return FALSE;
        }
        phandle++;
        phandle++;
    }
    hcliPrev = hcli;
    hcli = pcli->hcliNext;
    LocalUnlock (hcliPrev);
    }
    return TRUE;
}


#ifdef _DEBUG
// For use in CodeView
// NOTE: Returns a static string
INTERNAL_(LPOLESTR)  a2s (ATOM a)
{
    static WCHAR sz[256];
    GlobalGetAtomName (a, sz, 256);
    return sz;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\item2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       item2.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6-07-94   kevinro   Converted to NT and commented
//
//----------------------------------------------------------------------------

#include "ole2int.h"
#include <dde.h>
#include "ddeatoms.h"
#include "ddedebug.h"
#include "srvr.h"
#include "itemutil.h"
#include "trgt_dev.h"
#include <stddef.h>
#include <limits.h>
#ifndef WIN32
// #include <print.h>
#endif

ASSERTDATA


INTERNAL_(void)    CDefClient::TerminateNonRenameClients
(
LPCLIENT    lprenameClient
)
{

    HANDLE          hcliPrev = NULL;
    PCLILIST        pcli;
    HANDLE          *phandle;
    HANDLE          hcli;
    HWND	    hwndClient;
    LPCLIENT       lpdocClient;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::TerminateNonRenameClients(lprenClient=%x)\n",
		  this,
		  lprenameClient));

    // items also keep the parents window handle.
    hwndClient  =  m_hwnd;
    lpdocClient = (LPCLIENT)GetWindowLongPtr (m_hwnd, 0);


    hcli = m_hcliInfo;
    while (hcli)
    {
	if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
	{
	    break;
	}

	phandle = (HANDLE *) (pcli->info);
	while (phandle < (HANDLE *)(pcli + 1))
	{
	    if (*phandle)
	    {
		// This client is in the rename list. So, no termination
		if(!FindClient (lprenameClient->m_hcliInfo, *phandle, FALSE))
		{
		    //
		    // Terminate will send a WM_DDE_TERMINATE at the client
		    //
		    Terminate((HWND)*phandle,hwndClient);

		    // delete this client from all the items lists.
		    lpdocClient->DeleteFromItemsList ((HWND)*phandle);
		}
	    }
	    phandle++;
	    phandle++;
	}

	hcliPrev = hcli;
	hcli = pcli->hcliNext;
	LocalUnlock (hcliPrev);
    }
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::TerminateNonRenameClients\n",
		  this));

}



INTERNAL CDefClient::Terminate
	(HWND hwndTo,
	HWND hwndFrom)
{
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::Terminate hwndTo=%x hwndFrom=%x\n",
		  this,
		  hwndTo,
		  hwndFrom));

    DDECALLDATA DdeCD;
    HRESULT hresult;

    DdeCD.hwndSvr = hwndTo;
    DdeCD.hwndCli = hwndFrom;
    DdeCD.wMsg = WM_DDE_TERMINATE;
    DdeCD.wParam = (WPARAM)hwndFrom,
    DdeCD.lParam = 0;

    //
    // Setting the fCallData variable effects the way that the
    // DocWndProc handles WM_DDE_TERMINATE. If it is set, then this
    // object initiated the terminate, and will not reply to the
    // TERMINATE. It will allow us to leave the CallRunModalLoop
    //
    m_fCallData = TRUE;

    RPCOLEMESSAGE RpcOleMsg;
    RpcOleMsg.Buffer = &DdeCD;

    // Figure out the MsgQ input flags based on the callcat of the call.
    DWORD dwMsgQInputFlag = gMsgQInputFlagTbl[CALLCAT_SYNCHRONOUS];

    // Now construct a modal loop object for the call that is about to
    // be made. It maintains the call state and exits when the call has
    // been completed, cancelled, or rejected.

    CCliModalLoop CML(0, dwMsgQInputFlag,0);

    do
    {
	DWORD status = 0;
	hresult = CML.SendReceive(&RpcOleMsg, &status, &m_pCallMgr);

    }  while (hresult == RPC_E_SERVERCALL_RETRYLATER);


    m_fCallData = FALSE;

    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::Terminate hresult = %x\n",
		  this,hresult));

    return(hresult);
}


INTERNAL_(void)   CDefClient::SendTerminateMsg ()
{

    HANDLE          hcliPrev = NULL;
    PCLILIST        pcli;
    HANDLE          *phandle;
    HANDLE          hcli;
    HWND	    hwnd;
    LPCLIENT        lpdocClient;
    static int staticcounter;
    int counter = ++staticcounter;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::SendTerminateMsg\n",
		  this));

    // items also keep the document's window handle

    Assert (IsWindow (m_hwnd));

    if (!IsWindow (m_hwnd))
    {
	goto exitRtn;
    }

    hwnd = m_hwnd;

    lpdocClient = (LPCLIENT)GetWindowLongPtr (m_hwnd, 0);

    Assert (lpdocClient);

    if (NULL==lpdocClient)
    {
	goto exitRtn;
    }

    Assert (lpdocClient==m_pdoc);
    AssertIsDoc (lpdocClient);
    // If "this" is a document (container) then iterate through
    // and terminate all its client windows.  If "this" is an item
    // just terminate that item's client windows.
    hcli = m_bContainer ? lpdocClient->m_hcli : m_hcliInfo;
    while (hcli)
    {
	if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
	{
	    goto exitRtn;
	}
	phandle = (HANDLE *) (pcli->info);
	while (phandle < (HANDLE *)(pcli + 1))
	{
	    if ((HWND)*phandle)
	    {
		intrDebugOut((DEB_ITRACE,
		              "%x ::SendTerminateMsg on hwnd=%x\n",
			      this,
			      (HWND)*phandle));

		Terminate ((HWND)*phandle, hwnd);

		Assert (lpdocClient->m_cClients > 0);

		lpdocClient->m_cClients--;

		HWND hwndClient = *(HWND *)phandle;
		// This window is no longer a client.

		// Remove window from document's master list
		// and its item's list.
		lpdocClient->DeleteFromItemsList (hwndClient);
	    }
	    //
	    // (KevinRo): Don't understand why the phandle is
	    // incremented twice. This is the same as the original
	    // code. Leaving it for now, since I don't have enough
	    // information.
	    //
	    phandle++;
	    phandle++;
	}

	hcliPrev = hcli;
	hcli = pcli->hcliNext;
	LocalUnlock (hcliPrev);
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::SendTerminateMsg\n",
		  this));

}



// SendRenameMsg: enumerates the clients for the rename item
// and sends rename message for all the clients.

INTERNAL_(void)    CDefClient::SendRenameMsgs
(
HANDLE      hddeRename
)
{
    ATOM	    aData    = NULL;
    HANDLE          hdde     = NULL;
    PCLINFO         pclinfo = NULL;
    HWND	    hwndClient;

    HANDLE          hcliPrev = NULL;
    PCLILIST        pcli;
    HANDLE          *phandle;
    HANDLE          hcli;
    HANDLE          hcliInfo;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::SendRenameMsgs(hddeRename=%x)\n",
		  this,
		  hddeRename));

    hcli = m_hcliInfo;
    LPARAM lp;
    while (hcli)
    {
	if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
	{
    	    goto exitRtn;
	}


	phandle = (HANDLE *) (pcli->info);
	while (phandle < (HANDLE *)(pcli + 1))
	{
	    if (*phandle++)
	    {
		hdde = NULL;
		aData = NULL;

		if (!(pclinfo = (PCLINFO) LocalLock (hcliInfo = *phandle++)))
		{
		    goto exitRtn;
		}


		// Make the item atom with the options.
		aData = DuplicateAtom (aStdDocName);
		hdde  = UtDupGlobal (hddeRename,GMEM_MOVEABLE);

		hwndClient  = pclinfo->hwnd;
		LocalUnlock (hcliInfo);

		// Post the message

		lp = MAKE_DDE_LPARAM(WM_DDE_DATA,hdde,aData);

		if (!PostMessageToClient (hwndClient,
					  WM_DDE_DATA,
					  (WPARAM) m_hwnd,
					  lp))
                {
		    DDEFREE(WM_DDE_DATA,lp);
		    if (hdde)
			GlobalFree (hdde);
		    if (aData)
			GlobalDeleteAtom (aData);
		}
	    }
	    else
	    {
		phandle++;
	    }

	}

	hcliPrev = hcli;
	hcli = pcli->hcliNext;
	LocalUnlock (hcliPrev);
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::SendRenameMsgs void return\n",
		  this));

}



INTERNAL_(BOOL)   CDefClient::SendDataMsg
(
WORD    		msg        // notification message
)
{

    HANDLE          hcliPrev = NULL;
    PCLILIST        pcli;
    HANDLE          *phandle;
    HANDLE          hcli;
    BOOL	    bSaved = FALSE;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::SendDataMsg(msg=%x)\n",
		  this,
		  msg));

    hcli = m_hcliInfo;
    while (hcli)
    {
	if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
	{
	    break;
	}
	phandle = (HANDLE *) (pcli->info);
	while (phandle < (HANDLE *)(pcli + 1)) {
	    if (*phandle++)
		bSaved = SendDataMsg1 (*phandle++, msg);
	    else
		phandle++;
	}

	hcliPrev = hcli;
	hcli = pcli->hcliNext;
	LocalUnlock (hcliPrev);
    }

    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::SendDataMsg() returns %x)\n",
		  this,bSaved));

    return bSaved;
}



//SendDataMsg: Send data to the clients, if the data change options
//match the data advise options.

INTERNAL_(BOOL)   CDefClient::SendDataMsg1
(
HANDLE  		hclinfo,    // handle of the client info
WORD    		msg         // notification message
)
{
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::SendDataMsg1(hclinfo=%x,msg=%x)\n",
		  this,
		  hclinfo,
		  msg));

    PCLINFO     pclinfo = NULL;
    HANDLE      hdde    = NULL;
    ATOM	aData   = NULL;
    HRESULT       retval;
    BOOL	bSaved = FALSE;


    ChkC (this);
    if (m_lpdataObj == NULL) goto errRtn;

    // LATER: Allow server to give us other tymed's beside HGLOBAL and do
    // the conversion ourselves, e.g., IStorageToHGlobal()

    FORMATETC formatetc;// = {0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;// = {TYMED_NULL, NULL, NULL};
    formatetc.ptd = m_ptd;
    formatetc.dwAspect = DVASPECT_CONTENT;
    formatetc.lindex = DEF_LINDEX;
    formatetc.tymed = TYMED_HGLOBAL;
    medium.tymed = TYMED_NULL;
    medium.hGlobal=0; // not really necessary
    medium.pUnkForRelease = NULL;

    if (!(pclinfo = (PCLINFO) LocalLock (hclinfo)))
    {
	goto errRtn;
    }

    // if the client dead, then no message
    if (!IsWindowValid(pclinfo->hwnd))
    {
	goto errRtn;
    }


    //
    // (KevinRo) UPDATE was not defined in the OLE 2.01 code base
    //
#ifdef UPDATE
	// OLE_SAVED is what 1.0 clients expect to get for embedded objects.
	if (msg==OLE_CHANGED && m_fEmbed)
		msg=OLE_SAVED;
#endif

    if (pclinfo->options & (0x0001 << msg))
    {
	bSaved = TRUE;  		
	SendDevInfo (pclinfo->hwnd);

	// send message if the client needs data for every change or
	// only for the selective ones he wants.

	// now look for the data option.
	if (pclinfo->bnative){
	    // prepare native data
	    if (pclinfo->bdata){

		// Wants the data with DDE_DATA message
		// Get native data from the server.
	
		// GetData
		formatetc.cfFormat = g_cfNative;
		wSetTymed (&formatetc);
		retval = GetData (&formatetc, &medium);

		if (retval != NOERROR)
		{
		    Assert(0);
		    goto errRtn;
		}
		Assert (medium.tymed==TYMED_HGLOBAL);
		Assert (medium.hGlobal);

		// Prepare the DDE data block.
		// REVIEW: MakeDDEData frees medium.hGlobal manually, but should
		// really call ReleaseStgMedium.
		if(!MakeDDEData (medium.hGlobal, (int)g_cfNative, (LPHANDLE)&hdde, FALSE))
		{
		    goto errRtn;
		}
	    }


	    // Make the item atom with the options.
	    aData =  MakeDataAtom (m_aItem, msg);

	    intrDebugOut((DEB_ITRACE,
		          "%x ::SendDataMsg1 send NativeData to hwnd=%x"
			  "format %x\n",
			  this,
			  pclinfo->hwnd,
			  pclinfo->format));

            LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_DATA,hdde,aData);
            if (!PostMessageToClient(pclinfo->hwnd,
				     WM_DDE_DATA,
				     (WPARAM) m_hwnd,
				     lp))


	    {
		DDEFREE(WM_DDE_DATA,lp);
		//
		// The two data items will be free'd on exit
		//
		goto errRtn;
	    }
	    hdde = NULL;
	    aData = NULL;
	}


	// Now post the data for the display format

	if (pclinfo->format)
	{
	    if (pclinfo->bdata)
	    {
		intrDebugOut((DEB_ITRACE,
	    		      "%x ::SendDataMsg1 GetData on cf = %x\n",
			      pclinfo->format));
		// Must reset because previous call to GetData set it.
		medium.tymed = TYMED_NULL;

		// GetData
		formatetc.cfFormat = (USHORT) pclinfo->format;
		wSetTymed (&formatetc);
		Assert (IsValidInterface (m_lpdataObj));
		retval = m_lpdataObj->GetData (&formatetc, &medium);

		if (retval != NOERROR)
		{
		    intrDebugOut((DEB_IERROR,
	    			  "m_lpdataObj->GetData returns %x\n",
				  retval));
		    goto errRtn;
		}


		if (pclinfo->format == CF_METAFILEPICT)
		    ChangeOwner (medium.hGlobal);
		
		if(!MakeDDEData (medium.hGlobal, pclinfo->format, (LPHANDLE)&hdde, FALSE))
		    goto errRtn;

	    }

	    // atom is deleted. So, we need to duplicate for every post
	    aData =  MakeDataAtom (m_aItem,  msg);
	    // now post the message to the client;
	    intrDebugOut((DEB_ITRACE,
		          "%x ::SendDataMsg1 send PresentationData to hwnd=%x"
			  " cf=%x\n",
			  this,
			  pclinfo->hwnd,
			  pclinfo->format));

            LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_DATA,hdde,aData);

            if (!PostMessageToClient(pclinfo->hwnd,
				     WM_DDE_DATA,
				     (WPARAM) m_hwnd,
				     lp))
	    {
		DDEFREE(WM_DDE_DATA,lp);
		goto errRtn;
	    }

	    hdde = NULL;
	    aData = NULL;
	}

    }


errRtn:
    if (pclinfo)
	LocalUnlock (hclinfo);

    if (hdde)
	GlobalFree (hdde);

    if (aData)
	GlobalDeleteAtom (aData);

    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::SendDataMsg1() returns %x\n",
		  this,bSaved));


    return bSaved;

}



// FixWriteBug
//
// `Write' gives a target device that is missing a NULL between
// the device name and the driver name.  This function creates
// a fixed 1.0 target device.
//
// REVIEW: There is another Write bug we should work around.
// Write does not send the "extra bytes" that are supposed to follow
// the DEVMODE.  It puts the Environment immediately after the DEVMODE.
// So the driver will read the Environment thinking it is the extra bytes.
// To fix this, FixWriteBug() should zero out the Environment bytes; the
// 2.0 target device does not use them anyway.
//
 INTERNAL FixWriteBug
    (HANDLE hTD,
    LPHANDLE ph)
{
    HRESULT hresult;
    LPBYTE pChunk2;
    LPBYTE pNewChunk2;
    HANDLE hNew = NULL;
    LPBYTE pNew = NULL;
    const LPCOLETARGETDEVICE ptd1 = (LPCOLETARGETDEVICE) GlobalLock (hTD);
    RetZS (ptd1, E_OUTOFMEMORY);

    hNew = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE,
				GlobalSize (hTD) + 1);
    RetZS (hNew, E_OUTOFMEMORY);
    pNew = (LPBYTE) GlobalLock (hNew);
    RetZS (pNew, E_OUTOFMEMORY);
    ULONG cbChunk1 = 7 * sizeof(UINT) + ptd1->otdDriverNameOffset;
    ULONG cbChunk2 = (ULONG)(GlobalSize (hTD) - cbChunk1);
    ErrZS (IsValidPtrOut (pNew, (UINT)cbChunk1), E_OUTOFMEMORY);
    memcpy (pNew, ptd1, cbChunk1);
    pNew[cbChunk1] = '\0';       // insert the missing NULL

    pNewChunk2 = pNew + cbChunk1 + 1;
    pChunk2 = (LPBYTE)ptd1 + cbChunk1;
    ErrZS (IsValidPtrOut (pNewChunk2, (UINT)cbChunk2), E_OUTOFMEMORY);
    Assert (IsValidReadPtrIn (pChunk2, (UINT)cbChunk2));
    memcpy (pNewChunk2, pChunk2, cbChunk2);

    // Fix up the offsets to accomodate the added NULL
    #define macro(x) if (ptd1->otd##x##Offset > ptd1->otdDeviceNameOffset)\
			((LPOLETARGETDEVICE)pNew)->otd##x##Offset++;
    macro (DriverName)
    macro (PortName)
    macro (ExtDevmode)
    macro (Environment)
    #undef macro

    GlobalUnlock (hNew);
    GlobalUnlock (hTD);
    *ph = hNew;
    return NOERROR;

  errRtn:
    if (pNew)
	GlobalUnlock (hNew);
    if (ptd1)
	GlobalUnlock (hTD);
    if (hNew)
	GlobalFree (hNew);
    return hresult;
}






// Convert10TargetDevice
//
INTERNAL Convert10TargetDevice
    (HANDLE     	     hTD,       // 1.0 Target Device
    DVTARGETDEVICE FAR* FAR* pptd2)     // Out parm, corresponding 2.0 TD
{
    intrDebugOut((DEB_ITRACE,
		  "0 _IN Convert10TargetDevice hTD=%x\n",hTD));

    ULONG cbData1, cbData2;

    if (NULL==hTD)
    {
	Assert(0);
	return ReportResult(0, E_INVALIDARG, 0, 0);
    }

    if (*pptd2)
    {
	// delete old target device
	PrivMemFree(*pptd2);
	*pptd2 = NULL;
    }

    LPOLETARGETDEVICE ptd1 = (LPOLETARGETDEVICE) GlobalLock (hTD);

    RetZS (ptd1, E_OUTOFMEMORY);

    if ((ptd1->otdDeviceNameOffset < ptd1->otdDriverNameOffset)
	&& (ptd1->otdDeviceNameOffset
	    + strlen (LPSTR(((BYTE *)ptd1->otdData) +
		ptd1->otdDeviceNameOffset)) + 1 > ptd1->otdDriverNameOffset))
    {
	// No NULL between device and driver name
	HANDLE hNew;
	GlobalUnlock (hTD);
	RetErr (FixWriteBug (hTD, &hNew));
	HRESULT hresult = Convert10TargetDevice (hNew, pptd2);
	Verify (0==GlobalFree (hNew));
	return hresult;
    }
	// Word Bug
	DEVMODEA UNALIGNED *pdevmode = (DEVMODEA UNALIGNED *)
	    (((BYTE *)ptd1->otdData)+ ptd1->otdExtDevmodeOffset);

	if (   HIBYTE(pdevmode->dmSpecVersion) < 3
		|| HIBYTE(pdevmode->dmSpecVersion) > 6
		|| pdevmode->dmDriverExtra > 0x1000)
	{
		if (0==ptd1->otdEnvironmentSize)
		{
			// Sometimes Word does not give an environment.
			ptd1->otdExtDevmodeOffset = 0;
			ptd1->otdExtDevmodeSize   = 0;
		}
		else
		{
			// DevMode is garbage, use environment instead.
			ptd1->otdExtDevmodeOffset = ptd1->otdEnvironmentOffset;
			ptd1->otdExtDevmodeSize   = ptd1->otdEnvironmentSize;
		}
	}

    // These next  assert does not HAVE to be true,
    // but it's a sanity check.
    Assert (ptd1->otdDeviceNameOffset
	    + strlen (LPSTR(((BYTE *)ptd1->otdData) +
		ptd1->otdDeviceNameOffset)) + 1
	    == ptd1->otdDriverNameOffset);


    // Excel has zeroes for DevMode and Environment offsets and sizes

    // Calculate size of Data block.  Many 1.0 clients don't make their
    // target device data block big enough for the DEVMODE.dmDriverExtra
    // bytes (and they don't copy those bytes either).  We can't reconstruct
    // the bytes out of thin air, but we can at least make sure there's not
    // a GP fault when the printer driver tries to access those bytes in
    // a call to CreateDC.  Any extra bytes are zeroed.
    cbData2 = ptd1->otdExtDevmodeOffset + ptd1->otdExtDevmodeSize;

    if (ptd1->otdExtDevmodeOffset != 0)
    {
	cbData2 += ((DEVMODEA UNALIGNED *)((LPBYTE)ptd1->otdData +
	    ptd1->otdExtDevmodeOffset))->dmDriverExtra;
    }

    cbData2 = max (cbData2,
		   ptd1->otdPortNameOffset + strlen (LPCSTR(
		    ((BYTE *)ptd1->otdData) + ptd1->otdPortNameOffset)) + 1);

    // Calculate size of OLE2 Target Device
    //
    // Its the size of the DVTARGETDEVICE header, plus the cbData2
    // The definition of DVTARGETDEVICE currently uses an unsized array
    // of bytes at the end, therefore we can not just do a sizeof().
    //

    ULONG cbTD2 = SIZEOF_DVTARGETDEVICE_HEADER + cbData2;

    // Allocate OLE2 Target Device
    *pptd2 = (DVTARGETDEVICE FAR*) PrivMemAlloc(cbTD2);
    if (!IsValidPtrOut (*pptd2, cbTD2)
	|| !IsValidPtrOut ((*pptd2)->tdData, cbData2))
    {
	AssertSz (0, "out of memory");
	GlobalUnlock (hTD);
	return ResultFromScode (E_OUTOFMEMORY);
    }
    _fmemset (*pptd2, '\0', cbTD2);

    // OLE2 offsets are from the beginning of the DVTARGETDEVICE
    const ULONG cbOffset = offsetof (DVTARGETDEVICE, tdData);

    // Fill in new Target Device

    (*pptd2)->tdSize = cbTD2;

    #define Convert(a) \
	((*pptd2)->td##a##Offset = (USHORT)(ptd1->otd##a##Offset + cbOffset))

    Convert (DeviceName);
    Convert (DriverName);
    Convert (PortName);
    if (ptd1->otdExtDevmodeOffset != 0)
	Convert (ExtDevmode);
    else				// Excel uses 0
       (*pptd2)->tdExtDevmodeOffset = 0;

    // Calculate size of 1.0 data block in case the 1.0 target
    // device is incorrectly not big enough.
    cbData1 = (size_t) GlobalSize(hTD) - offsetof (OLETARGETDEVICE, otdData);

    #undef Convert
    _fmemcpy ((*pptd2)->tdData, ptd1->otdData, min(cbData1, cbData2));

    GlobalUnlock (hTD);

    //
    // At this point, pptd2 holds an ANSI version of a DVTARGET device
    //
    // Now, we need to convert it to a UNICODE version. There are routines
    // for doing this in the UTILS.H file.
    //

    DVTDINFO dvtdInfo;
    DVTARGETDEVICE * pdvtd32 = NULL;
    HRESULT hr;

    hr = UtGetDvtd16Info(*pptd2, &dvtdInfo);
    if (hr != NOERROR)
    {
	goto errRtn;
    }

    pdvtd32 = (DVTARGETDEVICE *) PrivMemAlloc(dvtdInfo.cbConvertSize);

    if (pdvtd32 == NULL)
    {
	goto errRtn;
    }

    hr = UtConvertDvtd16toDvtd32(*pptd2, &dvtdInfo, pdvtd32);

    if (hr != NOERROR)
    {
	PrivMemFree(pdvtd32);
	pdvtd32=NULL;
    }

errRtn:

    PrivMemFree(*pptd2);
    *pptd2 = pdvtd32;

    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CDefClient::PokeStdItems
//
//  Synopsis:   Pokes the data for the standard items.
//
//  Effects:
//
// For StdHostnames, StdDocDimensions and SetColorScheme the data is
// sent immediately and for the the StdTargetDeviceinfo the
// data is set in each client block and the data is sent just
// before the GetData call for rendering the right data.
//
//  Arguments:  [hwndClient] --
//		[aItem] --
//		[hdata] --
//		[index] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    6-07-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CDefClient::PokeStdItems(HWND hwndClient,
				  ATOM aItem,
				  HANDLE hdata,
				  int index)
{
    DDEDATA FAR *   lpdata = NULL;
    HANDLE          hnew   = NULL;
    LPHOSTNAMES     lphostnames;
    HRESULT         retval = E_OUTOFMEMORY;
    WORD 	    format;
    BOOL	    fRelease;

    intrDebugOut((DEB_ITRACE,
		  "%p _IN CDefClient::PokeStdItems(hwndClient=%x,aItem=%x(%ws)hdata=%x,index=%x)\n",
		  this,
		  hwndClient,
		  aItem,
		  wAtomName(aItem),
		  hdata,
		  index));

    if (m_fGotEditNoPokeNativeYet)
    {
	// We got StdEdit, but instead of getting Poke for native data,
	// we got poke for some std items. So we want to generate InitNew()
	// call for the object.

	DoInitNew(); 	// the function clears the flag
    }

    if(!(hdata && (lpdata = (DDEDATA FAR *)GlobalLock (hdata))))
    {
	goto errRtn;
    }

    format   = lpdata->cfFormat;
    fRelease = lpdata->fRelease;

    AssertSz (format == (int)g_cfBinary, "Format is not binary");

    // we have extracted the data successfully.
    m_lpoleObj = m_lpoleObj;

    if (index == STDHOSTNAMES)
    {
	lphostnames = (LPHOSTNAMES)lpdata->Value;
	//
	// The client should have sent the HOSTNAMES in ANSI. This
	// means we need to convert them to UNICODE before we can
	// use them.
	//
	LPOLESTR lpstrClient = CreateUnicodeFromAnsi((LPSTR)(lphostnames->data) + lphostnames->clientNameOffset);
	LPOLESTR lpstrDoc = CreateUnicodeFromAnsi((LPSTR)(lphostnames->data) + lphostnames->documentNameOffset);

	intrDebugOut((DEB_ITRACE,
		      "%p ::PokeStdItems setting hostnames Client(%ws) Doc(%ws)  \n",
		      this,
		      lpstrClient,
		      lpstrDoc));

	retval = (HRESULT)m_lpoleObj->SetHostNames(lpstrClient,lpstrDoc);

	if (retval==NOERROR)
	{
	    m_fDidRealSetHostNames = TRUE;
	}

	PrivMemFree(lpstrClient);
	PrivMemFree(lpstrDoc);

	goto end;
    }


    if (index == STDDOCDIMENSIONS)
    {

	SIZEL size;
	size.cy = ((LPRECT16)(lpdata->Value))->top;
	size.cx = ((LPRECT16)(lpdata->Value))->left;
	intrDebugOut((DEB_ITRACE,
		      "%p ::PokeStdItems STDDOCDIMENSIONS cy=%x cx=%x\n",
		      this,
		      size.cy,
		      size.cx));
	retval = m_lpoleObj->SetExtent (DVASPECT_CONTENT, &size);

	goto end;

    }


    if (index == STDCOLORSCHEME) {
	intrDebugOut((DEB_ITRACE,
		      "%p ::PokeStdItems setting STDCOLORSCHEME\n",this));

	retval = m_lpoleObj->SetColorScheme((LPLOGPALETTE)(lpdata->Value));

	goto end;
    }

    // Target Device
    if (index == STDTARGETDEVICE)
    {
	intrDebugOut((DEB_ITRACE,
		      "%p ::PokeStdItems setting STDTARGETDEVICE\n",this));

	if (!(hnew = MakeItemData ((DDEPOKE FAR *)lpdata, hdata, format)))
	    goto errRtn;

	retval = Convert10TargetDevice (hnew, &m_ptd);
	goto end;

    }
    retval = E_UNEXPECTED;

    intrAssert(!"::PokeStdItems - Unknown index\n");

    //
    // (KevinRo) Found the following line already commented out.
    //
    //(HRESULT)SetStdInfo (hwndClient, (LPOLESTR) (MAKELONG(STDTARGETDEVICE,0)),hnew);

end:
errRtn:
    if (hnew)
	// can only be global memory block
	GlobalFree (hnew);

    if (lpdata) {
	GlobalUnlock (hdata);
	if (retval == NOERROR && fRelease)
	    GlobalFree (hdata);
    }

    intrDebugOut((DEB_ITRACE,
		  "%p _OUT CDefClient::PokeStdItems() hresult = %x\n",
		  this,
		  retval));

    return retval;
}






// SetStdInfo: Sets the targetdevice info. Creates a client
// for "StdTargetDevice". This item is created only within the
// lib and it is never visible in server app. When the change
// message comes from the server app, before we ask for
// the data, we send the targetdevice info if there is
// info for the client whom we are trying to send the data
// on advise.


INTERNAL_(HRESULT)    CDefClient::SetStdInfo
(
HWND        hwndClient,
LPOLESTR       lpitemname,
HANDLE      hdata
)
{
    HANDLE      hclinfo  = NULL;
    PCLINFO     pclinfo = NULL;
    LPCLIENT    lpclient;
    HRESULT   retval   = NOERROR;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::SetStdInfo(hwndClient=%x,ItemName=(%ws),hdata=%x)\n",
		  this,
		  hwndClient,
		  lpitemname,
		  hdata));
    //
    // first create/find the StdTargetDeviceItem.
    //

    if ((lpclient = SearchItem (lpitemname)) == NULL)
    {
	 retval = (HRESULT)RegisterItem (lpitemname,(LPCLIENT FAR *)&lpclient, FALSE);
	 if (retval != NOERROR)
	 {
	    goto errRtn;
	 }
    }

    if(hclinfo = FindClient (lpclient->m_hcliInfo, hwndClient, FALSE))
    {
	if (pclinfo = (PCLINFO) LocalLock (hclinfo))
	{
	    if (pclinfo->hdevInfo)
		GlobalFree (pclinfo->hdevInfo);
	    pclinfo->bnewDevInfo = TRUE;
	    if (hdata)
		pclinfo->hdevInfo = UtDupGlobal (hdata,GMEM_MOVEABLE);
	    else
		pclinfo->hdevInfo = NULL;
	    pclinfo->hwnd = hwndClient;
	    LocalUnlock (hclinfo);

	    // We do not have to reset the client because we did not
	    // change the handle it self.
	}
    }
    else
    {
	// Create the client structure to be attcahed to the object.
	hclinfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (CLINFO));
	if (hclinfo == NULL || (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL)
	    goto errRtn;

	pclinfo->bnewDevInfo = TRUE;
	if (hdata)
	    pclinfo->hdevInfo = UtDupGlobal (hdata,GMEM_MOVEABLE);
	else
	    pclinfo->hdevInfo = NULL;

	pclinfo->hwnd = hwndClient;
	LocalUnlock (hclinfo);


	// Now add this client to item client list
	// !!! This error recovery is not correct.
	if (!AddClient ((LPHANDLE)&lpclient->m_hcliInfo, hwndClient, hclinfo))
	    goto errRtn;
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::SetStdInfo() hresult=%x\n",
		  this,retval));

    return retval;
errRtn:
    Assert(0);
    if (pclinfo)
	LocalUnlock (hclinfo);

    if (hclinfo)
	LocalFree (hclinfo);

    retval = E_OUTOFMEMORY;
    goto exitRtn;
}


// SendDevInfo: Sends targetdevice info to the  the object.
// Caches the last targetdevice info sent to the object.
// If the targetdevice block is same as the one in the
// cache, then no targetdevice info is sent.
// (!!! There might be some problem here getting back
// the same global handle).

INTERNAL_(void)     CDefClient::SendDevInfo
(
HWND        hWndCli
)
{

    HANDLE      hclinfo  = NULL;
    PCLINFO     pclinfo = NULL;
    HANDLE      hdata;
    LPCLIENT    lpdocClient;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::SendDevInfo(hwndCli=%x)\n",
		  this,
		  hWndCli));
#if 0
    if (!m_bContainer)
	lpdocClient = (LPCLIENT)GetWindowLong (m_hwnd, 0);
    else
	lpdocClient = this;
#endif

    // find if any StdTargetDeviceInfo item is present at all
    AssertIsDoc(m_pdoc);
    lpdocClient = m_pdoc->SearchItem ((LPOLESTR) LongToPtr((MAKELONG(STDTARGETDEVICE, 0))));
    if (lpdocClient == NULL)
    {
	goto exitRtn;
    }

    hclinfo     = FindClient (lpdocClient->m_hcliInfo, hWndCli, FALSE);

    // This client has not set any target device info. no need to send
    // any stdtargetdevice info
    if (hclinfo != NULL) {
	if (!(pclinfo = (PCLINFO)LocalLock (hclinfo)))
	    goto end;

	// if we cached it, do not send it again.
	if ((!pclinfo->bnewDevInfo) && pclinfo->hdevInfo == m_hdevInfo)
	    goto end;

	pclinfo->bnewDevInfo = FALSE;
	if(!(hdata = UtDupGlobal (pclinfo->hdevInfo,GMEM_MOVEABLE)))
	    goto end;
    } else {

	// already screen
	if (!m_hdevInfo)
	    goto end;

	//for screen send NULL.
	hdata = NULL;
    }



    if (pclinfo)
    {
	m_hdevInfo = pclinfo->hdevInfo;
    }
    else
    {
	m_hdevInfo = NULL;
    }



    // !!! error case who frees the data?'

end:
    if (pclinfo)
	LocalUnlock (hclinfo);

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::SendDevInfo(hwndCli=%x)\n",
		  this,
		  hWndCli));
    return;
}




// Constructor
CDefClient::CDefClient (LPUNKNOWN pUnkOuter):   m_Unknown (this),
						m_OleClientSite (this),
						m_AdviseSink (this),
						m_pCallMgr (this)
{
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::CDefClient(pUnkOuter=%x)\n",
		  this,
		  pUnkOuter));

    m_pUnkOuter = pUnkOuter ? pUnkOuter : &m_Unknown;
    m_bContainer      = TRUE;
    m_lpoleObj        = NULL;
    m_lpdataObj       = NULL;
    m_bCreateInst     = FALSE;
    m_bTerminate      = FALSE;
    m_termNo          = 0;
    m_hcli            = NULL;
    m_lpNextItem      = NULL;
    m_cRef            = 0;
    m_hwnd            = (HWND)0;
    m_hdevInfo        = NULL;
    m_hcliInfo        = NULL;
    m_fDidRealSetHostNames= FALSE;
    m_fDidSetClientSite   = FALSE;
    m_fGotDdeAdvise   = FALSE;
    m_fCreatedNotConnected	  = FALSE;
    m_fInOnClose	  = FALSE;
    m_fInOleSave	  = FALSE;
    m_dwConnectionOleObj  = 0L;
    m_dwConnectionDataObj = 0L;
    m_fGotStdCloseDoc = FALSE;
    m_fEmbed          = FALSE;
    m_cClients        = 0;
    m_plkbytNative    = NULL;
    m_pstgNative      = NULL;
    m_fRunningInSDI   = FALSE;
    m_psrvrParent     = NULL;
    m_ptd             = NULL;
    m_pdoc            = NULL;
    m_chk             = chkDefClient;
    m_ExecuteAck.f    = FALSE;
    m_fGotEditNoPokeNativeYet = FALSE;
    m_fLocked = FALSE;
    m_fCallData	 = FALSE;
    // CDefClient::Create does all the real work.
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::CDefClient(pUnkOuter=%x)\n",
		  this,
		  pUnkOuter));

}


CDefClient::~CDefClient (void)
{
    // This should be more object-oriented.
    // But right now, this BOOL tells us what kind of obj
    // (doc or item) "this" is
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::~CDefClient\n",
		  this));

    Puts ("~CDefClient "); Puta(m_aItem); Putn();
    BOOL fDoc = (m_pdoc==this);

    Assert (m_chk==chkDefClient);

    ReleaseObjPtrs ();

    if (m_pdoc && !fDoc)
    {
	Assert (m_pdoc->m_chk==chkDefClient);
	m_pdoc->m_pUnkOuter->Release();
    }
    if (fDoc)
    {
	// delete all the items(objects) for this doc
	DeleteAllItems ();
	if (m_fRunningInSDI && m_psrvrParent
	    && m_psrvrParent->QueryRevokeClassFactory())
	{
	    m_psrvrParent->Revoke();
	}

    }

    if (ISATOM(m_aItem))
	GlobalDeleteAtom (m_aItem);
    if (m_plkbytNative)
    {
	m_plkbytNative->Release();
	Assert (m_pstgNative);
	// They always go together
    }
    if (m_pstgNative)
	m_pstgNative->Release();
    if (m_ptd)
	PrivMemFree(m_ptd);

    // Delete client advise info
    DeleteAdviseInfo ();
    if (fDoc && IsWindow(m_hwnd))
    {
        SSDestroyWindow (m_hwnd);
    }
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::~CDefClient\n",
		  this));

}


//
// Unknown Implementation
//

STDMETHODIMP NC(CDefClient,CUnknownImpl)::QueryInterface
    (REFIID     iid,
    LPVOID FAR* ppv)
{
    intrDebugOut((DEB_ITRACE,"%p CDefClient::QueryInterface()\n",this));

    if (iid == IID_IUnknown)
    {
	*ppv = (LPVOID) &m_pDefClient->m_Unknown;
	AddRef();
	return NOERROR;
    }
    else if (iid==IID_IAdviseSink)
	*ppv = (LPVOID) &m_pDefClient->m_AdviseSink;
    else if (iid==IID_IOleClientSite)
	*ppv = (LPVOID) &m_pDefClient->m_OleClientSite;
    else
    {
	*ppv = NULL;
	return ReportResult(0, E_NOINTERFACE, 0, 0);
    }
    m_pDefClient->m_pUnkOuter->AddRef();

    return NOERROR;
}


STDMETHODIMP_(ULONG) NC(CDefClient,CUnknownImpl)::AddRef()
{
    intrDebugOut((DEB_ITRACE,
		  "%p CDefClient::AddRef() returns %x\n",
		  this,
		  m_pDefClient->m_cRef+1));

    return ++m_pDefClient->m_cRef;
}


STDMETHODIMP_(ULONG) NC(CDefClient,CUnknownImpl)::Release()
{
    AssertSz (m_pDefClient->m_cRef, "Release is being called on ref count of zero");
    if (--m_pDefClient->m_cRef == 0)
    {
	delete m_pDefClient;
	intrDebugOut((DEB_ITRACE,
		      "%p CDefClient::Release() returns 0\n",
		      this));
	return 0;
    }
    intrDebugOut((DEB_ITRACE,
		  "%p CDefClient::Release() returns %x\n",
		  this,
		  m_pDefClient->m_cRef));

    return m_pDefClient->m_cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\ddeutils.cxx ===
/****************************** Module Header ******************************\
* Module Name: ddeutils.c
*
* Purpose: Conatains all the utility routines
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik (../../1990)    Designed and coded
*
\***************************************************************************/
#include "ole2int.h"
#include <dde.h>
#include "srvr.h"
#include "ddesrvr.h"
#include "ddedebug.h"
ASSERTDATA


#define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
#define WM_NCMOUSELAST WM_NCMBUTTONDBLCLK



#define KB_64   65536

extern ATOM    aTrue;
extern ATOM    aFalse;

extern ATOM    aStdCreateFromTemplate;
extern ATOM    aStdCreate;
extern ATOM    aStdOpen;
extern ATOM    aStdEdit;
extern ATOM    aStdShowItem;
extern ATOM    aStdClose;
extern ATOM    aStdExit;
extern ATOM    aStdDoVerbItem;


//ScanBoolArg: scans the argument which is not included in
//the quotes. These args could be only TRUE or FALSE for
//the time being. !!!The scanning routines should be
//merged and it should be generalized.

INTERNAL_(LPSTR)     ScanBoolArg
(
LPSTR   lpstr,
BOOL    FAR *lpflag
)
{


    LPSTR   lpbool;
    ATOM    aShow;
    char    ch;

    lpbool = lpstr;

    // !!! These routines does not take care of quoted quotes.

    while((ch = *lpstr) && (!(ch == ')' || ch == ',')))
	lpstr++;

    if(ch == NULL)
       return NULL;

    *lpstr++ = NULL;       // terminate the arg by null

    // if terminated by paren, then check for end of command
    // syntax.

    // Check for the end of the command string.
    if (ch == ')') {
	if (*lpstr++ != ']')
	    return NULL;

	if(*lpstr != NULL)
	    return NULL;	     //finally should be terminated by null.

    }

    aShow = GlobalFindAtomA (lpbool);
    if (aShow == aTrue)
	*lpflag = TRUE;

    else {
	if (aShow ==aFalse)
	    *lpflag = FALSE;
	else
	    return NULL;;
    }
    return lpstr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateUnicodeFromAnsi
//
//  Synopsis:   Creates a UNICODE string from an ANSI string
//
//  Effects:    Makes a new UNICODE string from the given ANSI string.
//		The new UNICODE string is returned. Memory is allocated
//		using PrivMemAlloc
//
//  Arguments:  [lpAnsi] -- Ansi version of string
//
//  Requires:
//
//  Returns:	NULL if cannot create new string.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-07-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
LPOLESTR CreateUnicodeFromAnsi( LPCSTR lpAnsi)
{
    WCHAR buf[MAX_PATH];
    ULONG ccbuf;
    LPOLESTR lpWideStr;

    if ((ccbuf=MultiByteToWideChar(CP_ACP,0,lpAnsi,-1,buf,MAX_PATH))
	 == FALSE)
    {
	intrAssert(!"Unable to convert characters");
	return NULL;
    }

    lpWideStr = (LPOLESTR) PrivMemAlloc(ccbuf * sizeof(WCHAR));

    if (lpWideStr != NULL)
    {
	memcpy(lpWideStr,buf,ccbuf*sizeof(WCHAR));
    }
    return(lpWideStr);
}
//+---------------------------------------------------------------------------
//
//  Function:   CreateAnsiFromUnicode
//
//  Synopsis:   Creates an Ansi string from a UNICODE string
//
//  Effects:    Makes a new ANSI string from the given UNICODE string.
//		The new string is returned. Memory is allocated
//		using PrivMemAlloc
//
//  Arguments:  [lpUnicode] -- Unicode version of string
//
//  Requires:
//
//  Returns:	NULL if cannot create new string.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-07-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR CreateAnsiFromUnicode( LPCOLESTR lpUnicode)
{
    char buf[MAX_PATH];
    ULONG ccbuf;
    LPSTR lpAnsiStr;

    ccbuf = WideCharToMultiByte(CP_ACP,
			    	0,
				lpUnicode,
				-1,
				buf,
				MAX_PATH,
				NULL,
				NULL);


    if (ccbuf == FALSE)
    {
	intrAssert(!"Unable to convert characters");
	return NULL;
    }

    lpAnsiStr = (LPSTR) PrivMemAlloc(ccbuf * sizeof(char));

    if (lpAnsiStr != NULL)
    {
	memcpy(lpAnsiStr,buf,ccbuf);
    }
    return(lpAnsiStr);
}

//ScannumArg: Checks for the syntax of num arg in Execute and if
//the arg is syntactically correct, returns the ptr to the
//beginning of the next arg and also, returns the number
//Does not take care of the last num arg in the list.

INTERNAL_(LPSTR)       ScanNumArg
(
LPSTR   lpstr,
LPINT   lpnum
)
{

    WORD    val = 0;
    char    ch;

    while((ch = *lpstr++) && (ch != ',')) {
	if (ch < '0' || ch >'9')
	    return NULL;
	val += val * 10 + (ch - '0');

    }

    if(!ch)
       return NULL;

    *lpnum = val;
    return lpstr;
}




//ScanArg: Checks for the syntax of arg in Execute and if
//the arg is syntactically correct, returns the ptr to the
//beginning of the next arg or to the end of the excute string.

INTERNAL_(LPSTR)      ScanArg
(
LPSTR   lpstr
)
{


    // !!! These routines does not take care of quoted quotes.

    // first char should be quote.

    if (*(lpstr-1) != '\"')
	return NULL;

    while(*lpstr && *lpstr != '\"')
	lpstr++;

    if(*lpstr == NULL)
       return NULL;

    *lpstr++ = NULL;       // terminate the arg by null

    if(!(*lpstr == ',' || *lpstr == ')'))
	return NULL;


    if(*lpstr++ == ','){

	if(*lpstr == '\"')
	    return ++lpstr;
	// If it is not quote, leave the ptr on the first char
	return lpstr;
    }

    // terminated by paren
    // already skiped right paren

    // Check for the end of the command string.
    if (*lpstr++ != ']')
	return NULL;

    if(*lpstr != NULL)
	return NULL;    	 //finally should be terminated by null.

    return lpstr;
}

// ScanCommand: scanns the command string for the syntax
// correctness. If syntactically correct, returns the ptr
// to the first arg or to the end of the string.

INTERNAL_(WORD)   ScanCommand
(
LPSTR       lpstr,
WORD        wType,
LPSTR FAR * lplpnextcmd,
ATOM FAR *  lpAtom
)
{
    // !!! These routines does not take care of quoted quotes.
    // and not taking care of blanks arround the operators

    // !!! We are not allowing blanks after operators.
    // Should be allright! since this is arestricted syntax.

    char    ch;
    LPSTR   lptemp = lpstr;


    while(*lpstr && (!(*lpstr == '(' || *lpstr == ']')))
	lpstr++;

    if(*lpstr == NULL)
       return NULL;

    ch = *lpstr;
    *lpstr++ = NULL;       // set the end of command

    *lpAtom = GlobalFindAtomA (lptemp);

    if (!IsOleCommand (*lpAtom, wType))
	return NON_OLE_COMMAND;

    if (ch == '(') {
	ch = *lpstr++;

	if (ch == ')') {
	     if (*lpstr++ != ']')
		return NULL;
	}
	else {
	    if (ch != '\"')
		return NULL;
	}

	*lplpnextcmd = lpstr;
	return OLE_COMMAND;
    }

    // terminated by ']'

    if (*(*lplpnextcmd = lpstr)) // if no nul termination, then it is error.
	return NULL;

    return OLE_COMMAND;
}


//MakeDataAtom: Creates a data atom from the item string
//and the item data otions.

INTERNAL_(ATOM)  MakeDataAtom
(
ATOM    aItem,
int     options
)
{
    WCHAR    buf[MAX_STR];

    if (options == OLE_CHANGED)
	return DuplicateAtom (aItem);

    if (!aItem)
	buf[0] = NULL;
    else
	GlobalGetAtomName (aItem, buf, MAX_STR);

    if (options == OLE_CLOSED)
	lstrcatW (buf, OLESTR("/Close"));
    else {
	if (options == OLE_SAVED)
	   lstrcatW (buf, OLESTR("/Save"));
	else
	    AssertSz (0, "Bad option\n");
    }

    Puts ("MakeDataAtom "); Puts(buf); Putn();
    if (buf[0])
	return wGlobalAddAtom (buf);
    else
	return NULL;
}

//DuplicateAtom: Duplicates an atom
INTERNAL_(ATOM)  DuplicateAtom
(
ATOM    atom
)
{
    WCHAR buf[MAX_STR];

    if (!atom)
	return NULL;

    GlobalGetAtomName (atom, buf, MAX_STR);
    return wGlobalAddAtom (buf);
}

// MakeGlobal: makes global out of strings.
// works only for << 64k

INTERNAL_(HANDLE)   MakeGlobal
(
LPSTR   lpstr
)
{

    int     len = 0;
    HANDLE  hdata  = NULL;
    LPSTR   lpdata = NULL;

    len = strlen (lpstr) + 1;

    hdata = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE, len);

    if (hdata == NULL || (lpdata = (LPSTR) GlobalLock (hdata)) == NULL)
	goto errRtn;


    memcpy(lpdata, lpstr, (DWORD)len);
    GlobalUnlock (hdata);
    return hdata;

errRtn:
    Assert (0);
    if (lpdata)
	GlobalUnlock (hdata);


    if (hdata)
	GlobalFree (hdata);

     return NULL;

}


INTERNAL_(BOOL) CLSIDFromAtom(ATOM aClass, LPCLSID lpclsid)
{
    WCHAR szProgID[MAX_STR];
    if (!ISATOM (aClass))
	return FALSE;
    WORD cb= (WORD) GlobalGetAtomName (aClass, szProgID, MAX_STR);
    Assert (cb>0 && cb < (MAX_STR - 1));

    return CLSIDFromProgID(szProgID, lpclsid) == S_OK;
}

// CLSIDFromAtomWithTreatAs
//
// Input: *paClass
// Output: *pclsid == corresponding CLSID, taking into account TreatAs and
//                     AutoConvert
//		   *paClass == atom correpsonding to *pclsid
//
#pragma SEG(CLSIDFromAtomWithTreatAs)
INTERNAL CLSIDFromAtomWithTreatAs
	(ATOM FAR* 	paClass,
	LPCLSID 	pclsid,
	CNVTYP FAR* pcnvtyp)
{
    HRESULT hr;


    intrDebugOut((DEB_ITRACE,
		  "%p _IN CLSIDFromAtomWithTreatAs(paClass=%x,"
		  "pclsid=%x,pcnvtyp=%x)\n",0,
		  paClass,pclsid,pcnvtyp));

    LPOLESTR szProgID = NULL;
    CLSID clsidNew;

    if (!CLSIDFromAtom (*paClass, pclsid))
    {
	hr = S_FALSE;
	goto exitRtn;
    }

    DEBUG_GUIDSTR(clsidStr,pclsid);

    intrDebugOut((DEB_ITRACE,"Guid %ws",clsidStr));
    if (CoGetTreatAsClass (*pclsid, &clsidNew) == NOERROR)
    {
	DEBUG_GUIDSTR(newStr,pclsid);

	intrDebugOut((DEB_ITRACE," cnvtypTreatAs %ws\n",newStr));
    	if (pcnvtyp)
    		*pcnvtyp = cnvtypTreatAs;
    }
    else if (OleGetAutoConvert (*pclsid, &clsidNew) == NOERROR)
    {
	DEBUG_GUIDSTR(newStr,pclsid);
	intrDebugOut((DEB_ITRACE," cnvtypConvertTo %ws\n",newStr));
    	if (pcnvtyp)
    		*pcnvtyp = cnvtypConvertTo;
    }
    else	
    {
	intrDebugOut((DEB_ITRACE," no conversion\n"));
    	if (pcnvtyp)
    		*pcnvtyp = cnvtypNone;
    	clsidNew = *pclsid; // no translation
    }

    hr = ProgIDFromCLSID(clsidNew, &szProgID);
    if (FAILED(hr))
    {
	intrDebugOut((DEB_ITRACE,"  ProgIDFromCLSID failed\n"));
	goto exitRtn;
    }

    intrDebugOut((DEB_ITRACE,"ProgIDFromCLSID returns %ws\n",szProgID));
    *paClass = GlobalAddAtom (szProgID);
    *pclsid  = clsidNew;
    CoTaskMemFree(szProgID);

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "%p OUT CLSIDFromAtomWithTreatAs returns %x\n",
		  0,hr));

    return hr;
}


INTERNAL_(BOOL)  PostMessageToClientWithReply
(
HWND    hWnd,
UINT    wMsg,
WPARAM  wParam,  // posting window
LPARAM  lParam,
UINT    wReplyMsg
)
{
    MSG 		msg;

    if (!IsWindowValid (hWnd))
    {
	AssertSz(FALSE, "Client's window is missing");
	return FALSE;
    }

    if (!IsWindowValid ((HWND)wParam))
    {
	AssertSz (0, "Posting window is invalid");
	return FALSE;
    }

    // Post message to client failed. Treat it as if we got the reply.
    if (!PostMessageToClient (hWnd, wMsg, wParam, lParam))
	return FALSE;

    return NOERROR == wTimedGetMessage (&msg, (HWND)wParam, WM_DDE_TERMINATE,
					WM_DDE_TERMINATE);
}



INTERNAL_(BOOL)  PostMessageToClient
(
    HWND    hWnd,
    UINT    wMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	UINT c=0;

	while (c < 10)
	{
	    if (!IsWindowValid (hWnd)) {
    	    Warn ("Client's window is missing");
        	return FALSE;
	    }
		Puts ("Posting"); Puth(wMsg); Puts("to"); Puth(hWnd); Putn();
    	if (PostMessage (hWnd, wMsg, wParam, lParam))
			return TRUE; // success
		else
		{
			Yield();
			c++; // try again
		}
	}
	return FALSE;
}


INTERNAL_(BOOL)     IsWindowValid
    (HWND    hwnd)
{
    HTASK   htask;

    if (!IsWindow (hwnd))
	return FALSE;

    htask  = GetWindowThreadProcessId(hwnd, NULL);

#ifndef WIN32
    if (IsTask(htask))
#endif
	return TRUE;

    return FALSE;
}



INTERNAL_(BOOL)  UtilQueryProtocol
(
ATOM    aClass,
LPOLESTR   lpprotocol
)
{
    HKEY    hKey;
    WCHAR    key[MAX_STR];
    WCHAR    cclass[MAX_STR];

    if (!aClass)
	return FALSE;

    if (!GlobalGetAtomName (aClass, cclass, MAX_STR))
	return FALSE;

    lstrcpyW (key, cclass);
    lstrcatW (key, OLESTR("\\protocol\\"));
    lstrcatW (key, lpprotocol);
    lstrcatW (key, OLESTR("\\server"));
    if (RegOpenKey (HKEY_CLASSES_ROOT, key, &hKey) != ERROR_SUCCESS)
	return FALSE;
    RegCloseKey (hKey);
    return TRUE;
}



INTERNAL_(BOOL)  IsOleCommand
(
ATOM    aCmd,
WORD    wType
)
{
    if (wType == WT_SRVR) {
	if ((aCmd == aStdCreateFromTemplate)
		|| (aCmd == aStdCreate)
		|| (aCmd == aStdOpen)
		|| (aCmd == aStdEdit)
		|| (aCmd == aStdShowItem)
		|| (aCmd == aStdClose)
		|| (aCmd == aStdExit))
	    return TRUE;
    }
    else {
	if ((aCmd == aStdClose)
		|| (aCmd == aStdDoVerbItem)
		|| (aCmd == aStdShowItem))
	    return TRUE;
    }

    return FALSE;
}
INTERNAL wFileBind
	(LPOLESTR szFile,
	LPUNKNOWN FAR* ppUnk)
{
	HRESULT hresult = NOERROR;
	LPBC pbc = NULL;
	LPMONIKER pmk = NULL;
	*ppUnk = NULL;
	ErrRtnH (CreateBindCtx (0, &pbc));
	ErrRtnH (CreateFileMoniker (szFile, &pmk));
	ErrRtnH (pmk->BindToObject (pbc, NULL, IID_IUnknown, (LPLPVOID) ppUnk));
  errRtn:
//	AssertOutPtrIface(hresult, *ppUnk);
	if (pbc)
		pbc->Release();
	if (pmk)
		pmk->Release();
	return hresult;
}

// SynchronousPostMessage
//
// Post a message and wait for the ack.
// (jasonful)
//
INTERNAL SynchronousPostMessage
    (HWND   hWndTo,  // also who you expect the reply from
    UINT    wMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
#ifdef _MAC
#else

    HRESULT hresult = NOERROR;

    static unsigned iCounter;


    HWND hWndFrom = (HWND) wParam;



    RetZ (IsWindowValid(hWndFrom));
    RetZ (IsWindowValid(hWndTo));

    Assert (wMsg != WM_DDE_INITIATE);  // can't check for positive ack.

    RetZS (PostMessage (hWndTo, wMsg, wParam, lParam), RPC_E_SERVER_DIED);

    MSG msg;
    RetErr (wTimedGetMessage (&msg, hWndFrom, WM_DDE_ACK, WM_DDE_ACK));
    Assert (msg.message == WM_DDE_ACK);
    if (!( GET_WM_DDE_ACK_STATUS(msg.wParam,msg.lParam) & POSITIVE_ACK))
	hresult = ResultFromScode (RPC_E_DDE_NACK);
    if (msg.hwnd != hWndFrom)
	hresult = ResultFromScode (RPC_E_DDE_UNEXP_MSG);



    return hresult;
#endif _MAC
}


INTERNAL wFileIsRunning
    (LPOLESTR szFile)
{
    LPMONIKER pmk = NULL;
    LPBINDCTX pbc=NULL;
    HRESULT hresult;

    RetErr (CreateBindCtx (0, &pbc));
    ErrRtnH (CreateFileMoniker (szFile, &pmk));
    hresult = pmk->IsRunning (pbc, NULL, NULL);
  errRtn:
    if (pbc)
	pbc->Release();
    if (pmk)
	pmk->Release();
    return hresult;
}




//+---------------------------------------------------------------------------
//
//  Function:   IsFile
//
//  Synopsis:   Given a handle to an atom, determine if it is a file
//
//  Effects:    Attempts to get the files attributes. If there are no
//		attributes, then the file doesn't exist.
//
//  Arguments:  [a] -- Atom for filename
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-03-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_ (BOOL) IsFile
    (ATOM a,	BOOL FAR* pfUnsavedDoc)
{
	LPMONIKER pmk = NULL;
	LPBC pbc = NULL;
	LPRUNNINGOBJECTTABLE pROT=NULL;

	WCHAR szFile [MAX_STR];
	if (0==GlobalGetAtomName (a, szFile, MAX_STR))
	    return FALSE;

	DWORD dwAttribs = GetFileAttributes(szFile);

	 /* flags prevent sharing violation*/
	if (dwAttribs != 0xFFFFFFFF)
	{
		if (pfUnsavedDoc)
			*pfUnsavedDoc = FALSE;
		return TRUE;
	}
	// This will deal with unsaved documents in the ROT.
	// We do NOT want to call pmk->IsRunning because if a 2.0 client called
	// DdeIsRunning, we do not want call it here, because then we get stuck
	// in an infinite loop.  We only care about true 2.0 running objects.


	BOOL f= NOERROR==CreateBindCtx (0, &pbc) &&
			NOERROR==CreateFileMoniker (szFile, &pmk) &&
			NOERROR==pbc->GetRunningObjectTable (&pROT) &&
			NOERROR==pROT->IsRunning (pmk) ;
	if (pROT)
		pROT->Release();
	if (pmk)
		pmk->Release();
	if (pbc)
		pbc->Release();
	if (pfUnsavedDoc)
		*pfUnsavedDoc = TRUE;
	return f;


}

// wCompatibleClasses
//
// Determine if class "aClient" is Auto-Converted to class "aSrvr" or
// Treated-As class "aSrvr".
// (Does not check if aClient==aSrvr)
//
#pragma SEG(wCompatibleClasses)
INTERNAL wCompatibleClasses
	(ATOM aClient,
	ATOM aSrvr)
{
	CLSID clsidClient, clsidSrvr, clsidTo;
	HRESULT hresult;
	RetZS (CLSIDFromAtom (aClient, &clsidClient), S_FALSE);
	RetZS (CLSIDFromAtom (aSrvr,   &clsidSrvr  ), S_FALSE);
	if (NOERROR==OleGetAutoConvert (clsidClient, &clsidTo)
		&& clsidTo == clsidSrvr)
	{
		// aClient is Auto-Converted to aSrvr
		return NOERROR;
	}
	hresult = CoGetTreatAsClass(clsidClient, &clsidTo);

    // Used to be:
    //   if (hresult != NOERROR)
    // But CoGetTreatAsClass return S_FALSE if you don't have
    // a TreatAs class....
	if (FAILED(hresult))
	{
	    intrDebugOut((DEB_IERROR,
	    		  "wCompatibleClasses CoGetTreatAs returns %x\n",
			  hresult));
	    return(hresult);
	}

	if (clsidTo == clsidSrvr)
	{
		// aClient is Treated-As aSrvr
		return NOERROR;
	}
	return ResultFromScode (S_FALSE); // not compatible
}



// wCreateStgAroundNative
//
// Build an OLE2 storage around 1.0 native data by putting it in
// stream "\1Ole10Native" and creating valid CompObj and OLE streams.
// Return the IStorage and the ILockBytes it is built on.
//
INTERNAL wCreateStgAroundNative
	(HANDLE hNative,
	ATOM	aClassOld,
	ATOM	aClassNew,
	CNVTYP	cnvtyp,
	ATOM	aItem,
	LPSTORAGE FAR* ppstg,
	LPLOCKBYTES FAR* pplkbyt)
{
	HRESULT   hresult;
	LPSTORAGE pstg = NULL;
	LPLOCKBYTES plkbyt = NULL;
	LPOLESTR szUserType = NULL;
	WCHAR szClassOld [256];
	CLSID     clsid;
	ATOM	aClass;
	*ppstg = NULL;

	intrDebugOut((DEB_ITRACE,
	    	      "%p wCreateStgAroundNative(hNative=%x,aClassOld=%x"
		      ",aClassNew=%x cnvtyp=%x,aItem=%x)\n",
		      0,hNative,aClassOld,aClassNew,cnvtyp,aItem));

	// Create temporary docfile on our ILockBytes
	ErrRtnH (CreateILockBytesOnHGlobal (NULL,/*fDeleteOnRelease*/TRUE,&plkbyt));

	Assert (plkbyt);

	ErrRtnH (StgCreateDocfileOnILockBytes (plkbyt, grfCreateStg, 0, &pstg));

	RetZ (pstg);
	Assert (NOERROR==StgIsStorageILockBytes(plkbyt));

	aClass = (cnvtyp == cnvtypConvertTo)?aClassNew:aClassOld;

	if (CLSIDFromAtom (aClass,(LPCLSID)&clsid) == FALSE)
	{
	    hresult = REGDB_E_CLASSNOTREG;
	    goto errRtn;
	}

	ErrRtnH (WriteClassStg (pstg, clsid));

	// The UserType always corresponds to the clsid.
	ErrRtnH (OleRegGetUserType (clsid, USERCLASSTYPE_FULL, &szUserType));

	// The format is always the 1.0 format (classname/progid)
	ErrZS (GlobalGetAtomName (aClassOld, szClassOld, 256), E_UNEXPECTED);

	ErrRtnH (WriteFmtUserTypeStg (pstg, (CLIPFORMAT) RegisterClipboardFormat(szClassOld),
						 			szUserType));


	if (cnvtyp == cnvtypConvertTo)
	{
		// SetConvertStg also writes a complete default Ole Stream
		ErrRtnH (SetConvertStg (pstg, TRUE));
	}
	else
	{
		ErrRtnH (WriteOleStg (pstg, NULL, (CLIPFORMAT)0, NULL));
	}
	ErrRtnH (StSave10NativeData (pstg, hNative, FALSE));
	if (aItem)
	{
		ErrRtnH (StSave10ItemName (pstg, wAtomNameA (aItem)));
	}
	*ppstg = pstg;
	*pplkbyt = plkbyt;
	return NOERROR;

  errRtn:
	if (pstg)
		pstg->Release();
	if (plkbyt)
		plkbyt->Release();
	CoTaskMemFree(szUserType);
	return hresult;
}


#ifdef _DEBUG


INTERNAL_ (BOOL) IsAtom (ATOM a)
{
    WCHAR sz[256]= {0};
    if (a < 0xc000)
	return FALSE;
    WORD cb= (WORD) GlobalGetAtomName (a, sz, 256);
    Assert (lstrlenW(sz) == (int) cb);
    return cb>0 && cb < MAX_STR;
}


#include <limits.h>
#undef GlobalFree




INTERNAL_(HANDLE) wGlobalFree (HANDLE h)
{
    LPVOID p;
    Assert ((GlobalFlags(h) & GMEM_LOCKCOUNT)==0);
    if (!(p=GlobalLock(h)))
    {
	Puts ("Cannot free handle");
	Puth (h);
	Putn();
	AssertSz(0, "Invalid Handle\r\n");
    }
    Assert (IsValidReadPtrIn (p, (UINT) min (UINT_MAX, GlobalSize(h))));
    Assert (GlobalUnlock(h)==0);
    Verify (!GlobalFree (h));
    Puts ("FREEING ");
    Puth (h);
    Putn ();
    return NULL; // success
}



#undef GlobalDeleteAtom

INTERNAL_(ATOM) wGlobalDeleteAtom (ATOM a)
{
    WCHAR sz[256];
    Assert (0 != GlobalGetAtomName (a, sz, 256));
    Assert (0==GlobalDeleteAtom (a));
    return (ATOM)0;
}

INTERNAL_(int) wCountChildren
    (HWND h)
{
    int c = 0;
    HWND hwndChild = GetWindow (h, GW_CHILD);
    while (hwndChild)
    {
	c++;
	hwndChild = GetWindow (hwndChild, GW_HWNDNEXT);
    }
    return c;
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   ddesvr
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES = ..\.;..\..\client;..\..\..\..\common\$(DEST_TREE);..\..\..\..\ih
INCLUDES = $(INCLUDES);..\..\..\dcomrem;..\..\..\inc
INCLUDES = $(INCLUDES);..\..\..\class;..\..\..\objact
INCLUDES = $(INCLUDES);..\..\..\..\ole232\inc
INCLUDES = $(INCLUDES);..\..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES = $(INCLUDES);..\..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES = $(INCLUDES);..\..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES = $(INCLUDES);$(BASE_INC_PATH)

C_DEFINES= -DOLE_DDE_NO_GLOBAL_TRACKING=1\
           $(C_DEFINES)


SOURCES=      \
    ..\ddeadv.cxx   \
    ..\ddesink.cxx  \
    ..\ddesite.cxx  \
    ..\ddesrvr.cxx  \
    ..\ddeutils.cxx \
    ..\doc.cxx      \
    ..\item.cxx     \
    ..\item2.cxx    \
    ..\itemutil.cxx \
    ..\srvr.cxx     \
    ..\srvrmain.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\srvr.cxx ===
/****************************** Module Header ******************************\
* Module Name: Srvr.c Server Main module
*
* Purpose: Includes All the server communication related routines.
*
* Created: Oct 1990.
*
* Copyright (c) 1985, 1986, 1987, 1988, 1989  Microsoft Corporation
*
* History:
*    Raor:   Wrote the original version.
*
*
\***************************************************************************/

#include "ole2int.h"
//#include <shellapi.h>
// #include "cmacs.h"
#include <dde.h>

// for RemDdeRevokeClassFactory and HDDESRVR
#include <olerem.h>

#include "srvr.h"
#include "ddedebug.h"
#include "ddesrvr.h"
ASSERTDATA

#define WM_DONOTDESTROY WM_USER+1

#ifdef FIREWALLS
BOOL    bShowed = FALSE;
void    ShowVersion (void);
#endif

#ifdef _CHICAGO_
#define DdeCHAR CHAR
#define Ddelstrcmp lstrcmpA
#define DdeGetClassName GetClassNameA
#define szCDDEServer "CDDEServer"
#else
#define DdeCHAR WCHAR
#define Ddelstrcmp lstrcmpW
#define DdeGetClassName GetClassName
#define szCDDEServer OLESTR("CDDEServer")
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CDDEServer::Create
//
//  Synopsis:   Create a server window to service a particular class
//
//  Effects:    Using lpclass, and the information in lpDdeInfo, create
//              a server window that is ready to respond to initiate
//              messages from this class.
//
//  Arguments:  [lpclass] --    Class name
//              [rclsid] -- Class ID
//              [lpDdeInfo] --  Class Object information
//              [phwnd] --      Out pointer for new window
//              [aOriginalClass] -- For TreatAs/Convert to case
//              [cnvtyp] --         Conversion type
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-28-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CDDEServer::Create
    (LPOLESTR          lpclass,
     REFCLSID          rclsid,
     LPDDECLASSINFO    lpDdeInfo,
     HWND FAR *        phwnd,
     ATOM              aOriginalClass,
     CNVTYP            cnvtyp)
{
    // REVIEW   what happens if we have two MDI servers register the
    //          same class factory?.

    LPSRVR  lpDDEsrvr   = NULL;
    ATOM    aExe        = NULL;

    intrDebugOut((DEB_DDE_INIT,
                  "0 _IN CDDEServer::Create(lpclass=%ws)\n",
                  lpclass));

    // add the app atom to global list
    if (!ValidateSrvrClass (lpclass, &aExe))
    {
        intrDebugOut((DEB_IWARN,
                      "CDDEServer::Create(%ws) Invalid Class\n",
                      lpclass));

        return OLE_E_CLSID;
    }

    lpDDEsrvr =  new CDDEServer;
    RetZS (lpDDEsrvr, E_OUTOFMEMORY);

    // set the signature handle and the app atom.
    lpDDEsrvr->m_chk         = chkDdeSrvr;
    lpDDEsrvr->m_aClass      = wGlobalAddAtom (lpclass);
    lpDDEsrvr->m_clsid       = rclsid; // Class ID (already TreatAs'd)
    lpDDEsrvr->m_aOriginalClass = wDupAtom (aOriginalClass);
    lpDDEsrvr->m_pClassFactory  = NULL;
    lpDDEsrvr->m_dwClassFactoryKey = lpDdeInfo->dwRegistrationKey;
    lpDDEsrvr->m_aExe        = aExe;
    lpDDEsrvr->m_cnvtyp      = cnvtyp;
    lpDDEsrvr->m_fcfFlags    = lpDdeInfo->dwFlags;

    lpDDEsrvr->m_bTerminate  = FALSE;        // Set if we are terminating.
    lpDDEsrvr->m_hcli        = NULL;         // handle to the first block of clients list
    lpDDEsrvr->m_termNo      = 0;            // termination count
    lpDDEsrvr->m_cSrvrClients= 0;            // no of clients;
    lpDDEsrvr->m_fDoNotDestroyWindow= 0;





#ifdef   FIREWALLS
    AssertSz(lpDdeInfo.dwFlags <= REGCLS_MULTI_SEPARATE, "invalid server options");
#endif

    // Create the server window and do not show it.
    //
    // We are explicitly calling CreateWindowA here.
    // The DDE tracking layer will attempt to convert hCommands to UNICODE
    // if the two windows in the conversation are both UNICODE.
    // This window is created as a child of the common server window for this
    // thread. When this thread dies, the common server window is destroyed if
    // it exists, which will cause all of the child windows to be destroyed also.
    //
    //
    if (!(lpDDEsrvr->m_hwnd = DdeCreateWindowEx (0, gOleDdeWindowClass,
                                            szCDDEServer,
                                            WS_OVERLAPPED | WS_CHILD,
                                            0,0,0,0,
                                            (HWND)TLSGetDdeServer(),
                                            NULL,
                                            g_hinst, NULL)))
    {
        goto errReturn;
    }

    // fix up the WindowProc entry point.
    SetWindowLongPtr(lpDDEsrvr->m_hwnd, GWLP_WNDPROC, (LONG_PTR)SrvrWndProc);

    //
    // The following will inform the class object in the class registration table
    // that this window should be notified when the class object is revoked. This
    // enables the window to shutdown properly.
    //
    // If there isn't a class factory, which happens for single instance servers
    // which were launched with a filename, then m_dwClassFactory will be 0,
    // in which case we don't make the set call.
    //
    if(lpDDEsrvr->m_dwClassFactoryKey != 0)
    {
        if(!CCSetDdeServerWindow(lpDDEsrvr->m_dwClassFactoryKey,lpDDEsrvr->m_hwnd))
        {
            intrDebugOut((DEB_IERROR,
                          "0 CDDEServer::Create unable to SetDdeServerWindow\n"));
            goto errReturn;
        }
    }

    intrDebugOut((DEB_DDE_INIT,
                  "DDE Server window for %ws created in task %x\n",
                  lpclass,GetCurrentThreadId()));

    // save the ptr to the server struct in the window.
    SetWindowLongPtr (lpDDEsrvr->m_hwnd, 0, (LONG_PTR)lpDDEsrvr);

    // Set the signature.
    SetWindowWord (lpDDEsrvr->m_hwnd, WW_LE, WC_LE);

    *phwnd = lpDDEsrvr->m_hwnd;


    intrDebugOut((DEB_DDE_INIT,
                  "0 _OUT CDDEServer::Create returns %x\n",
                  NOERROR));
    return NOERROR;

errReturn:
    AssertSz (0, "CDDEServer::Create errReturn");
    if (lpDDEsrvr)
    {
        if (lpDDEsrvr->m_hwnd)
            SSDestroyWindow (lpDDEsrvr->m_hwnd);

        if (lpDDEsrvr->m_aClass)
            GlobalDeleteAtom (lpDDEsrvr->m_aClass);

        if (lpDDEsrvr->m_aExe)
            GlobalDeleteAtom (lpDDEsrvr->m_aExe);
        delete lpDDEsrvr;
    }

    intrDebugOut((DEB_IERROR,
                  "0 _OUT CDDEServer::Create returns %x\n",
                  E_OUTOFMEMORY));

    return E_OUTOFMEMORY;
}



// ValidateSrvrClass checks whether the given server class is valid by
// looking in the registration database.

INTERNAL_(BOOL)    ValidateSrvrClass (
LPOLESTR       lpclass,
ATOM FAR *  lpAtom
)
{
    WCHAR    buf[MAX_STR];
    LONG    cb = MAX_STR;
    WCHAR    key[MAX_STR];
    LPOLESTR   lptmp;
    LPOLESTR   lpbuf;
    WCHAR    ch;
    CLSID    clsid;

    if (CLSIDFromProgID (lpclass, &clsid) != NOERROR)
    {
        // ProgId is not correctly registered in reg db
        return FALSE;
    }

    lstrcpyW (key, lpclass);
    lstrcatW (key, OLESTR("\\protocol\\StdFileEditing\\server"));

    if (RegQueryValue (HKEY_CLASSES_ROOT, key, buf, &cb))
        return TRUE;

    if (!buf[0])
    {
        AssertSz (0, "ValidateSrvrClass failed.");
        return FALSE;
    }

    // Get exe name without path and then get an atom for that
    lptmp = lpbuf = buf;
    while (ch = *lptmp)
    {
        lptmp++;
        if (ch == '\\' || ch == ':')
            lpbuf = lptmp;
    }
    *lpAtom =  wGlobalAddAtom (lpbuf);

    return TRUE;
}



INTERNAL RemDdeRevokeClassFactory
    (LPSRVR lpsrvr)
{
    HRESULT hr;
    intrDebugOut((DEB_ITRACE,
                  "0 _IN RemDdeRevokeClassFactory(%x)\n",
                  lpsrvr));

    ChkS(lpsrvr);
    hr = lpsrvr->Revoke();
    intrDebugOut((DEB_ITRACE,
                  "0 OUT RemDdeRevokeClassFactory(%x) %x\n",
                  lpsrvr,hr));
    return(hr);
}



INTERNAL CDDEServer::Revoke ()
{
    intrDebugOut((DEB_ITRACE,
                  "%x _IN CDDEServer::Revoke() m_cSrvrClients=%x\n",
                  this,
                  m_cSrvrClients));
    HRESULT hr;

    ChkS(this);

    //
    // Can't revoke if there are still clients. QueryRevokeCLassFactory
    // determines if there are still clients attached.
    //
    if (!QueryRevokeClassFactory ())
    {
        intrDebugOut((DEB_IERROR,
                      "QueryRevokeClassFactory failed!"));
        hr = RPC_E_DDE_REVOKE;
        goto exitRtn;
    }

    if (m_cSrvrClients)
    {
        m_bTerminate = TRUE;
        // if there are any clients connected to this classfactory,
        // send terminates.
        SendServerTerminateMsg ();
        m_bTerminate = FALSE;
    }

    hr = FreeSrvrMem ();

exitRtn:
    intrDebugOut((DEB_ITRACE,
                  "%x OUT CDDEServer::Revoke(%x) hr = %x\n",
                  this, hr));
    return hr;
}

INTERNAL_(void)  CDDEServer::SendServerTerminateMsg ()
{

    HANDLE          hcliPrev = NULL;
    PCLILIST        pcli;
    HANDLE          *phandle;
    HANDLE          hcli;

    intrDebugOut((DEB_ITRACE,
                  "%x _IN CDDEServer::SendServerTerminateMsg\n",
                  this));

    hcli = m_hcli;
    while (hcli) {
        if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
        {
            Assert(0);
            goto exitRtn;
        }

        phandle = (HANDLE *) (pcli->info);
        while (phandle < (HANDLE *)(pcli + 1)) {
            if (*phandle)
            {
                PostMessageToClientWithReply ((HWND)(*phandle), WM_DDE_TERMINATE,
                    (WPARAM) m_hwnd, NULL, WM_DDE_TERMINATE);
                Assert (m_cSrvrClients);
                m_cSrvrClients--;
            }
            phandle++;
            phandle++;
        }

        hcliPrev = hcli;
        hcli = pcli->hcliNext;
        LocalUnlock (hcliPrev);
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
                  "%x OUT CDDEServer::SendServerTerminateMsg\n",
                  this));

}

//+---------------------------------------------------------------------------
//
//  Method:     CDDEServer::FreeSrvrMem
//
//  Synopsis:   Free's up a CDDEServer.
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    6-26-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CDDEServer::FreeSrvrMem
    (void)
{
    HRESULT hr;
    // REVIEW: Not clear how this works in the synchronous mode
    // Release for class factory is called only when everything is
    // cleaned and srvr app can post WM_QUIT at this stage

    intrDebugOut((DEB_ITRACE,
                  "%x _IN CDDEServer::FreeSrvrMem\n",
                  this));

    PCLILIST pcliPrev;
    HANDLE hcli, hcliPrev;

    if (m_bTerminate)
    {
        AssertSz (0, "terminate flag is not FALSE");
    }


    if (m_aExe)
    {
        GlobalDeleteAtom (m_aExe);
    }


    // We deliberately do not call this->Lock (FALSE)
    // If the server has revoked his class object without
    // waiting for his Lock count to go to zero, then
    // presumably he doesn't need us to unlock him.  In fact,
    // doing such an unlock might confuse a server who then
    // tries to call CoRevokeClassObject recursively.
    if (m_pClassFactory)
    {
        m_pClassFactory->Release();
        m_pClassFactory = NULL;
    }

    hcli = m_hcli;
    while (hcli)
    {
        hcliPrev = hcli;
        if (pcliPrev = (PCLILIST) LocalLock (hcliPrev))
        {
            hcli = pcliPrev->hcliNext;
        }
        else
        {
            AssertSz (0, "Corrupt internal data structure or out-of-memory");
            hcli = NULL;
        }
        Verify (0==LocalUnlock (hcliPrev));
        Verify (NULL==LocalFree (hcliPrev));
    }

    hr = DestroyDdeSrvrWindow(m_hwnd,m_aClass);
    if (hr != NOERROR)
    {
        //
        // Well now, if DestroyWindow fails, there isn't a whole heck of
        // alot we can do about it. It could mean that the window was
        // destroyed previously, or the parent window was destroyed during
        // thread shutdown. We should still continue to cleanup
        //
        intrDebugOut((DEB_IERROR,
                      "%x CDDEServer::FreeSrvrMem DestroyDdeSrvrWindow failed %x\n",
                      this,
                      hr));
    }

    if (m_aClass)
    {
        GlobalDeleteAtom (m_aClass);
    }

    delete this;

    intrDebugOut((DEB_ITRACE,
                  "%x _OUT CDDEServer::FreeSrvrMem\n",
                  this));
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   SrvrHandleIncomingCall
//
//  Synopsis:   Setup and call the CallControl to dispatch a call to the server
//
//  Effects:    A call has been made from the client that requires us to call
//              into our server. This must be routed through the call control.
//              This routine sets up the appropriate data structures, and
//              calls into the CallControl. The CallControl will in turn
//              call SrvrDispatchIncomingCall to actuall process the call.
//
//              This routine should only be called by the SrvrWndProc
//
//
//  Arguments:  [lpsrvr] -- Points to the server
//              [hwnd] -- hwnd of server
//              [hdata] -- Handle to data
//              [wParam] -- hwnd of client
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-05-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL SrvrHandleIncomingCall(LPSRVR lpsrvr,
                                HWND hwnd,
                                HANDLE hdata,
                                HWND wParam)
{
    VDATEHEAP();
    HRESULT hresult = NOERROR;
    SRVRDISPATCHDATA srvrdispdata;
    DISPATCHDATA     dispatchdata;

    intrDebugOut((DEB_ITRACE,
                  "0 _IN SrvrHandleIncomingCall lpsrvr=%x hwnd=%x hdata=%x wParam=%x\n",
                  lpsrvr,
                  hwnd,
                  hdata,
                  wParam));

    srvrdispdata.wDispFunc = DDE_DISP_SRVRWNDPROC;
    srvrdispdata.hwnd = hwnd;
    srvrdispdata.hData = hdata;
    srvrdispdata.wParam = wParam;
    srvrdispdata.lpsrvr = lpsrvr;

    dispatchdata.pData = &srvrdispdata;

    RPCOLEMESSAGE        rpcMsg = {0};
    RPC_SERVER_INTERFACE RpcInterfaceInfo;
    DWORD                dwFault;

    rpcMsg.iMethod = 0;
    rpcMsg.Buffer  = &dispatchdata;
    rpcMsg.cbBuffer = sizeof(dispatchdata);
    rpcMsg.reserved2[1] = &RpcInterfaceInfo;
    *MSG_TO_IIDPTR(&rpcMsg) = GUID_NULL;


    IRpcStubBuffer * pStub = &(lpsrvr->m_pCallMgr);
    IInternalChannelBuffer * pChannel = &(lpsrvr->m_pCallMgr);
    hresult = STAInvoke(&rpcMsg, CALLCAT_SYNCHRONOUS, pStub, pChannel,
                        NULL, NULL, &dwFault);

    intrDebugOut((DEB_ITRACE,
                  "0 _OUT SrvrHandleIncomingCall hresult=%x\n",
                  hresult));

    return(hresult);
}

//+---------------------------------------------------------------------------
//
//  Function:   SrvrDispatchIncomingCall
//
//  Synopsis:   Dispatch a call into the server.
//
//  Effects:    At the moment, the only incoming call that requires handling
//              by the server window is Execute. This routine dispatchs to it,
//              and returns.
//
//  Arguments:  [psdd] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-05-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL SrvrDispatchIncomingCall(PSRVRDISPATCHDATA psdd)
{
    VDATEHEAP();
    HRESULT hr;
    intrDebugOut((DEB_ITRACE,
                  "0 _IN SrvrDispatchIncomingCall psdd(%x)\n",psdd));

    hr = psdd->lpsrvr->SrvrExecute (psdd->hwnd,
                                    psdd->hData,
                             (HWND)(psdd->wParam));

    intrDebugOut((DEB_ITRACE,
                  "0 _OUT SrvrDispatchIncomingCall psdd(%x) hr =%x\n",
                  psdd,
                  hr));

    return(hr);
}


// REVIEW: Revoking Class Factory will not be successful if
//         any clients are either connected to the classfactory
//         or to the object instances.



//+---------------------------------------------------------------------------
//
//  Function:   SrvrWndProc
//
//  Synopsis:   This is the server window procedure.
//
//  Effects:
//
//  Arguments:  [hwndIn] -- Window handle (may not be full. See note)
//              [msg] --
//              [wParam] --
//              [lParam] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    8-03-94   kevinro   Created
//
//  Notes:
//
//  When running in a VDM, it is possible that this window was dispatched
//  without having a full window handle. This happens when the getmessage
//  was dispatched from 16-bit. Therefore, we need to convert the hwnd to
//  a full hwnd before doing any comparision functions.
//
//----------------------------------------------------------------------------
STDAPI_(LRESULT) SrvrWndProc (
HWND            hwndIn,
UINT            msg,
WPARAM          wParam,
LPARAM          lParam
)
{
    BOOL        fRevoke=FALSE;
    LPSRVR      lpsrvr;
    WORD        status = NULL;
    HANDLE      hdata;
    ATOM        aItem;
    HRESULT   retval;

    //
    // The following hwnd variable is used to determine the full HWND, in the
    // event we were dispatched in a 16 bit process.
    //
    HWND        hwnd;

#ifdef  FIREWALLS
    HWND        hwndClient;
#endif


    switch (msg){

       case WM_DDE_INITIATE:
            VDATEHEAP();
#ifdef  FIREWALLS
    AssertSz (lpsrvr, "No server window handle in server window");
#endif
            hwnd = ConvertToFullHWND(hwndIn);

            lpsrvr = (LPSRVR)GetWindowLongPtr (hwnd, 0);
            if (lpsrvr->m_bTerminate){
                // we are terminating, no more connections
                break;
            }

            // class is not matching, so it is not definitely for us.
            // for apps sending the EXE for initiate, do not allow if the app
            // is mutiple instance (Bug fix for winworks).

            if (!(lpsrvr->m_aClass == (ATOM)(LOWORD(lParam)) ||
                 (NOERROR==wCompatibleClasses (LOWORD(lParam), lpsrvr->m_aClass)) ||
                 (lpsrvr->m_aExe == (ATOM)(LOWORD(lParam)) && IsSingleServerInstance() )))
            {
                break;
            }

            intrDebugOut((DEB_DDE_INIT,"::SrvrWndProc INITIATE\n"));


            if (!lpsrvr->HandleInitMsg (lParam))
            {
                if (!(aSysTopic == (ATOM)(HIWORD(lParam))))
                {
                    //
                    // If this isn't a sys topic, then it must be a request for
                    // a specific document. Send a message to the
                    // children windows, asking for the document. If one of them
                    // may send an ACK to the client.
                    //

                    // if the server window is not the right window for
                    // DDE conversation, then try with the doc windows.
                    BOOL fAckSent = SendInitMsgToChildren (hwnd, msg, wParam, lParam);

#ifdef KEVINRO_OLDCODE
 The following code was removed, because I don't belive it is required
 any longer. I am not 100% sure yet, so I have left it in. If you find it,
 you can probably remove it.
 It appears to be trying to claim the SINGLE_USE class factory from the class
 factory table. It does this when a child document window sends an ACK to the
 client, claiming to support the document being asked for. It really doesn't
 make too much sense here, since a single use server would have already removed
 its class factory if there was an open document.

 Anyway, the 16-bit version had a direct hack into the class factory table. We
 don't have that anymore, so this code wouldn't work anyway.

                    if (lpsrvr->m_fcfFlags==REGCLS_SINGLEUSE)
                    {
                        if (lpsrvr->m_pfAvail)
                        {
                            // Hide the entry in the class factory table so that no 2.0
                            // client can connect to the same server.
                            Assert (IsValidPtrOut (lpsrvr->m_pfAvail, sizeof(BOOL)));
                            *(lpsrvr->m_pfAvail) = FALSE;
                        }
                    }
#endif // KEVINRO_OLDCODE
                    intrDebugOut((DEB_DDE_INIT,"SrvrWndProc Child Init\n"));
                    return fAckSent;
                }
                break;
            }

            // We can enterain this client. Put him in our client list
            // and acknowledge the initiate.

            if (!AddClient ((LPHANDLE)&lpsrvr->m_hcli, (HWND)wParam,(HWND)/*fLocked*/FALSE))
            {
                break;
            }

            //
            // Now its time to grab up the class factory from the class
            // factory table. When this window was created, the class factory
            // was available. However, it is possible that it has already
            // been claimed by someone else. So, we try grabbing it (which
            // normally should succeed). If it fails, then delete the client
            // and don't acknowledge.
            //

            if (lpsrvr->m_pClassFactory == NULL)
            {
                DdeClassInfo ddeInfo;
                ddeInfo.dwContextMask = CLSCTX_LOCAL_SERVER |
                                        CLSCTX_INPROC_SERVER;
                intrDebugOut((DEB_DDE_INIT,"SrvrWndProc getting class factory\n"));
                //
                // The following asks for control of the class
                // factory in the case of a single use class
                //
                ddeInfo.fClaimFactory = TRUE;
                ddeInfo.dwRegistrationKey = lpsrvr->m_dwClassFactoryKey;

                if (CCGetClassInformationFromKey(&ddeInfo) == FALSE)
                {
                    intrDebugOut((DEB_IERROR,"SrvrWndProc failed to get class factory\n"));
                    //
                    // Whoops, we were not able to grab the class factory
                    // Cleanup and hop out
                    if (!FindClient ((LPHANDLE)lpsrvr->m_hcli,(HWND)wParam, TRUE))
                    {
                        intrAssert(!"FindClient failed\n");
                    }
                    return(0);
                }
                lpsrvr->m_pClassFactory = (IClassFactory *)ddeInfo.punk;
                lpsrvr->m_fcfFlags = ddeInfo.dwFlags;
            }

            intrAssert(lpsrvr->m_pClassFactory != NULL);

            lpsrvr->m_cSrvrClients++;

            lpsrvr->Lock (TRUE, (HWND)wParam);

            // Post acknowledge
            DuplicateAtom (LOWORD(lParam));
            DuplicateAtom (HIWORD(lParam));
            SSSendMessage ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lParam);


            return 1L; // fAckSent==TRUE
            VDATEHEAP();
            break;


    case WM_DDE_EXECUTE:
            VDATEHEAP();
            hwnd = ConvertToFullHWND(hwndIn);

            lpsrvr = (LPSRVR)GetWindowLongPtr (hwnd, 0);

            hdata = GET_WM_DDE_EXECUTE_HDATA(wParam,lParam);

#ifdef  FIREWALLS
            AssertSz (lpsrvr, "No server  handle in server window");
#endif

            intrDebugOut((DEB_ITRACE,"SrvrWndProc WM_DDE_EXECUTE\n"));

#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpsrvr->m_hcli, (HWND)wParam, FALSE);
            AssertSz (hwndClient, "Client is missing from the server")
#endif
            // Are we terminating
            if (lpsrvr->m_bTerminate) {
                intrDebugOut((DEB_ITRACE,
                              "SrvrWndProc WM_DDE_EXECUTE ignored for TERMINATE\n"));
                // !!! are we supposed to free the data
                GlobalFree (hdata);
                break;
            }

            retval = SrvrHandleIncomingCall(lpsrvr,hwnd,hdata,(HWND)wParam);

            if (NOERROR!=retval)
            {
                intrDebugOut((DEB_IERROR,
                              "SrvrWndProc SrvrHandleIncomingCall fail %x\n",
                              retval));
            }
            SET_MSG_STATUS (retval, status)

            if (!lpsrvr->m_bTerminate)
            {
                // REVIEW: We are making an assumption that, we will not be posting
                // any DDE messages because of calling the SrvrExecute.
                // If we post any messages, before we post the acknowledge
                // we will be in trouble.

                lParam = MAKE_DDE_LPARAM(WM_DDE_ACK,status, hdata);

                intrDebugOut((DEB_ITRACE,
                              "SrvrWndProc WM_DDE_EXECUTE sending %x for ack\n",status));

                // Post the acknowledge to the client
                if (!PostMessageToClient ((HWND) wParam,
                                          WM_DDE_ACK, (WPARAM) hwnd, lParam)) {
                    // if the window died or post failed, delete the atom.
                    GlobalFree (hdata);
                    DDEFREE(WM_DDE_ACK,lParam);
                }
            }
            VDATEHEAP();
            break;



    case WM_DDE_TERMINATE:
            intrDebugOut((DEB_ITRACE,
                          "SrvrWndProc WM_DDE_TERMINATE\n"));

            hwnd = ConvertToFullHWND(hwndIn);

            lpsrvr = (LPSRVR)GetWindowLongPtr (hwnd, 0);

#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpsrvr->m_hcli, (HWND)wParam, FALSE);
            AssertSz (hwndClient, "Client is missing from the server")
#endif
            Putsi (lpsrvr->m_bTerminate);
            if (lpsrvr->m_bTerminate)
            {
                AssertSz (0, "Unexpected code path");
            }
            else
            {
                // If client initiated the terminate. post matching terminate
                PostMessageToClient ((HWND)wParam,
                                      WM_DDE_TERMINATE,
                                      (WPARAM) hwnd,
                                      NULL);
                --lpsrvr->m_cSrvrClients;
                if (0==lpsrvr->m_cSrvrClients
                    && lpsrvr->QueryRevokeClassFactory())
                {
#ifdef KEVINRO_OLD_CODE
                    if (lpsrvr->m_phwndDde)
                    {
                        // Remove from class factory table
                        *(lpsrvr->m_phwndDde) = (HWND)0;
                    }
#endif // KEVINRO_OLD_CODE
                    fRevoke = TRUE;
                }

                lpsrvr->Lock (FALSE, (HWND)wParam); // Unlock server
                FindClient (lpsrvr->m_hcli, (HWND)wParam, /*fDelete*/TRUE);

                if (fRevoke)
                {
                    lpsrvr->Revoke();
                }
            }
            break;


       case WM_DDE_REQUEST:
            aItem = GET_WM_DDE_REQUEST_ITEM(wParam,lParam);

            hwnd = ConvertToFullHWND(hwndIn);

            lpsrvr = (LPSRVR)GetWindowLongPtr (hwnd, 0);

            intrDebugOut((DEB_ITRACE,
                          "SrvrWndProc WM_DDE_REQUEST(aItem=%x)\n",aItem));

            if (lpsrvr->m_bTerminate || !IsWindowValid ((HWND) wParam))
            {
                goto RequestErr;
            }

            if(RequestDataStd (aItem, (HANDLE FAR *)&hdata) != NOERROR)
            {

                lParam = MAKE_DDE_LPARAM(WM_DDE_ACK,0x8000,aItem);

                // if request failed, then acknowledge with error.
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK,
                                                        (WPARAM) hwnd, lParam))
                {
                    DDEFREE(WM_DDE_ACK,lParam);
RequestErr:
                    if (aItem)
                    {
                        GlobalDeleteAtom (aItem);
                    }

                }
            }
            else
            {
                lParam = MAKE_DDE_LPARAM(WM_DDE_REQUEST, hdata, aItem);

                // post the data message and we are not asking for any
                // acknowledge.

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_DATA,
                                                        (WPARAM) hwnd, lParam))
                {
                    GlobalFree (hdata);
                    DDEFREE(WM_DDE_REQUEST,lParam);
                    goto RequestErr;
                }
            }
            break;

    case WM_DONOTDESTROY:
            intrDebugOut((DEB_ITRACE,
                          "SrvrWndProc WM_DONOTDESTROY %x\n",
                          wParam));

            //
            // This message is only sent by 32-bit code that has been
            // given our full handle
            //

            lpsrvr = (LPSRVR)GetWindowLongPtr (hwndIn, 0);

            //
            // The WM_DONOTDESTROY message tells the server how to
            // handle the following WM_USER message. If wParam is set,
            // then the m_fDoNotDestroyWindow flag will be set, which
            // keeps us from destroying the server window. If cleared,
            // it will enable the destruction. This message is sent
            // from the MaybeCreateDocWindow routine
            //

            lpsrvr->m_fDoNotDestroyWindow = (BOOL) wParam;
            return 0;
            break;

    case WM_USER:
            intrDebugOut((DEB_ITRACE,
                          "SrvrWndProc WM_USER\n"));
            //
            // This message is only sent by 32-bit code that has been
            // given our full handle
            //

            lpsrvr = (LPSRVR)GetWindowLongPtr (hwndIn, 0);

            // cftable.cpp sends a WM_USER message to destory the DDE
            // server window when a 2.0 client has connected to a
            // SDI 2.0 server (and no 1.0 client should be allowed to also
            // connect.
            // cftable.cpp cannot call RemDdeRevokeClassFactory directly
            // becuase they may be in different processes.
            //
            // The m_fDoNotDestroyWindow flag is used by
            // MaybeCreateDocWindow in the case that the server is a
            // single use server, and revokes its class factory when
            // an object is created. MaybeCreateDocWindow will set this
            // flag, telling us to ignore the message.
            //
            // returning 0 means we did destroy, 1 means we did not.

            if (!lpsrvr->m_fDoNotDestroyWindow)
            {
                RemDdeRevokeClassFactory(lpsrvr);
                return(0);
            }
            return 1;
            break;

    default:
            return SSDefWindowProc (hwndIn, msg, wParam, lParam);
    }

    return 0L;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDDEServer::HandleInitMsg
//
//  Synopsis:   Determine if we are going to handle the INITIATE message.
//
//  Effects:
//
//  Arguments:  [lParam] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-28-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(BOOL) CDDEServer::HandleInitMsg(LPARAM    lParam)
{

    // If it is not system or Ole, this is not the server.
    if (!((aSysTopic == (ATOM)(HIWORD(lParam))) || (aOLE == (ATOM)(HIWORD(lParam)))))
    {
        return FALSE;
    }
    Assert (m_fcfFlags<=REGCLS_MULTI_SEPARATE);

    // single instance MDI accept
    if (m_fcfFlags != REGCLS_SINGLEUSE)
    {
        return TRUE;
    }

    // this server is multiple instance. So, check for any clients or docs.
    if (!GetWindow (m_hwnd, GW_CHILD) && 0==m_cSrvrClients)
        return TRUE;

    return FALSE;
}



// AddClient: Adds  a  client entry to the list.
// Each client entry is a pair of handles; key handle
// and data handle.  Ecah list entry contains space for
// MAX_LIST of pairs of handles.

INTERNAL_(BOOL)   AddClient
(
LPHANDLE    lphead,         // ptr to loc which contains the head handle
HANDLE      hkey,           // key
HANDLE      hdata           // hdata
)
{

    HANDLE          hcli = NULL;
    HANDLE          hcliPrev = NULL;
    PCLILIST        pcli;
    HANDLE          *phandle;


    hcli = *lphead;

    // if the entry is already present, return error.
    if (hcli && FindClient (hcli, hkey, FALSE))
        return FALSE;

    while (hcli) {
        if (hcliPrev)
            LocalUnlock (hcliPrev);

        if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
            return FALSE;

        phandle = (HANDLE *) pcli->info;
        while (phandle < (HANDLE *)(pcli + 1)) {
            if (*phandle == NULL) {
                *phandle++ = hkey;
                *phandle++ = hdata;
                LocalUnlock (hcli);
                return TRUE;
            }
            phandle++;
            phandle++;
        }
        hcliPrev = hcli;
        hcli = pcli->hcliNext;
        lphead = (LPHANDLE)&pcli->hcliNext;
    }

    // not in the list.
    hcli = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (CLILIST));
    if (hcli == NULL)
        goto  errRtn;

    if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
        goto errRtn;

    // set the link to this handle in the previous entry
    *lphead = hcli;
    if (hcliPrev)
        LocalUnlock (hcliPrev);

    phandle = (HANDLE *) pcli->info;
    *phandle++ = hkey;
    *phandle++ = hdata;
    LocalUnlock (hcli);
    return TRUE;

errRtn:

    if (hcliPrev)
        LocalUnlock (hcliPrev);

    if (hcli)
        LocalFree (hcli);

    return FALSE;

}


// FindClient: finds a client and deletes the client if necessary.
INTERNAL_(HANDLE) FindClient
(
HANDLE      hcli,
HANDLE      hkey,
BOOL        bDelete
)
{
    HANDLE        hcliPrev = NULL;
    PCLILIST      pcli;
    HANDLE        *phandle;
    HANDLE        hdata;

    while (hcli) {
        if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
            return FALSE;

        phandle = (HANDLE *) pcli->info;
        while (phandle < (HANDLE *)(pcli + 1)) {
            if (*phandle == hkey) {
                if (bDelete)
                    *phandle = NULL;

                hdata = *++phandle;
                LocalUnlock (hcli);
                return hdata;
            }
            phandle++;
            phandle++;
        }
        hcliPrev = hcli;
        hcli = pcli->hcliNext;
        LocalUnlock (hcliPrev);

    }
    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDDEServer::SrvrExecute
//
//  Synopsis:   takes care of the WM_DDE_EXECUTE for the server.
//
//  Effects:    Parses the EXECUTE string, and determines what it should be
//              done.
//
//  Arguments:  [hwnd] --   Server window
//              [hdata] --  Handle to EXECUTE string
//              [hwndClient] -- Client window
//
//  Requires:
//      hdata is an ANSI string. It was passed to us by a DDE client.
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    6-05-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CDDEServer::SrvrExecute
(
HWND        hwnd,
HANDLE      hdata,
HWND        hwndClient
)
{
    intrDebugOut((DEB_ITRACE,
                  "%x _IN CDDESrvr::SrvrExecute(hwnd=%x,hdata=%x,hwndClient=%x)\n",
                  this,
                  hwnd,
                  hdata,
                  hwndClient));

    ATOM            aCmd;
    BOOL            fActivate;

    LPSTR           lpdata = NULL;
    HANDLE          hdup   = NULL;
    HRESULT         hresult = E_UNEXPECTED;

    LPSTR           lpdocname;
    LPSTR           lptemplate;
    LPCLIENT        lpdocClient = NULL;
    LPSTR           lpnextarg;
    LPSTR           lpclassname;
    LPSTR           lpitemname;
    LPSTR           lpopt;
    CLSID           clsid;
    WORD            wCmdType;
    BOOL            bCreateInst = FALSE;
        LPUNKNOWN               pUnk = NULL;

    LPPERSISTSTORAGE pPersistStg=NULL;

    // REVIEW: if any methods called on the objects genarate DDE messages
    // before we return from Execute, we will be in trouble.


    // REVIEW: this code can be lot simplified if we do the argument scanning
    // seperately and return the ptrs to the args. Rewrite later on.

    ErrZS (hdup = UtDupGlobal (hdata,GMEM_MOVEABLE), E_OUTOFMEMORY);

    ErrZS (lpdata  = (LPSTR)GlobalLock (hdup), E_OUTOFMEMORY);

    intrDebugOut((DEB_ITRACE,
                  "CDDESrvr::SrvrExecute(lpdata = %s)\n",lpdata));

    if (*lpdata++ != '[') // commands start with the left sqaure bracket
    {
        hresult = ResultFromScode (RPC_E_DDE_SYNTAX_EXECUTE);
        goto  errRtn;
    }

    hresult = ReportResult(0, RPC_E_DDE_SYNTAX_EXECUTE, 0, 0);
    // scan upto the first arg
    if (!(wCmdType = ScanCommand (lpdata, WT_SRVR, &lpdocname, &aCmd)))
        goto  errRtn;

    if (wCmdType == NON_OLE_COMMAND)
    {
        if (!UtilQueryProtocol (m_aClass, PROTOCOL_EXECUTE))
            hresult = ReportResult(0, RPC_E_DDE_PROTOCOL, 0, 0);
        else {
            // REVIEW: StdExecute has to be mapped on to the StdCommandProtocol
            // What command do we map on to?

            AssertSz (0, "StdExecute is being called for server");
        }

        goto errRtn1;
    }

    if (aCmd == aStdExit)
    {
        if (*lpdocname)
            goto errRtn1;

        hresult = NOERROR;
        // REVIEW: Do we have to initiate any terminations from the
        // the servr side? Check how this works with excel.
        goto end2;
    }

    // scan the next argument.
    if (!(lpnextarg = ScanArg(lpdocname)))
        goto errRtn;

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdShowItem("docname", "itemname"[, "true"])]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdShowItem) {

        // first find the documnet. If the doc does not exist, then
        // blow it off.

        if (!(lpdocClient = FindDocObj (lpdocname)))
            goto errRtn1;

        lpitemname = lpnextarg;

        if( !(lpopt = ScanArg(lpitemname)))
            goto errRtn1;

        // scan for the optional parameter
        // Optional can be only TRUE or FALSE.

        fActivate = FALSE;
        if (*lpopt) {

            if( !(lpnextarg = ScanBoolArg (lpopt, (BOOL FAR *)&fActivate)))
                goto errRtn1;

            if (*lpnextarg)
                goto errRtn1;

        }


        // scan it. But, igonre the arg.
        hresult = lpdocClient->DocShowItem (lpitemname, !fActivate);
        goto end2;



    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdCloseDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdClose) {
        if (!(lpdocClient = FindDocObj (lpdocname)))
            goto errRtn1;

        if (*lpnextarg)
            goto errRtn1;

        // REVIEW: Do we have to do anything for shutting down the
        // the app? Is the client going to initiate the terminate?.
        // if we need to initiate the terminates, make sure we post
        // the ACK  first.

        lpdocClient->Revoke();
        goto end2;
    }


    if (aCmd == aStdOpen)
    {
        // find if any doc level object is already registerd.
        // if the object is registerd, then no need to call srvr app.
        if (FindDocObj (lpdocname))
        {
            // A client has already opened the document or user opened the
            // doc. We should do an addref to the docobj

#ifdef TRY
            if (m_cSrvrClients == 0)
                // Why are we doing this?
                hresult = lpdocClient->m_lpoleObj->AddRef();
            else
#endif
                hresult = NOERROR;
            goto end1;
        }
    }

    if (aCmd == aStdCreate || aCmd == aStdCreateFromTemplate) {
        lpclassname = lpdocname;
        lpdocname   = lpnextarg;
        if( !(lpnextarg = ScanArg(lpdocname)))
            goto errRtn1;

    }

    // check whether we can create/open more than one doc.

    if ((m_fcfFlags == REGCLS_SINGLEUSE) &&
            GetWindow (m_hwnd, GW_CHILD))
            goto errRtn;


    ErrZ (CLSIDFromAtom(m_aClass, &clsid));


    //
    // Generate a wide version of the name
    //

    WCHAR       awcWideDocName[MAX_STR];

    if (MultiByteToWideChar(CP_ACP,0,lpdocname,-1,awcWideDocName,MAX_STR) == FALSE)
    {
        Assert(!"Unable to convert characters");
        hresult = E_UNEXPECTED;
        goto errRtn;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdOpenDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    // Document does not exist.
    if (aCmd == aStdOpen)
    {
        ErrRtnH (wClassesMatch (clsid, awcWideDocName));
        ErrRtnH (wFileBind (awcWideDocName, &pUnk));
    }


    ErrRtnH (CreateInstance (clsid, awcWideDocName, lpdocname, pUnk, &lpdocClient, hwndClient));
    bCreateInst = TRUE;

    if (aCmd == aStdOpen)
    {
        // Temporary flag to indicate someone will INITIATE on this doc.
        // The flag is reset after the INITITATE.
        // This is Yet-Another-Excel-Hack.  See ::QueryRevokeClassFactory
        lpdocClient->m_fCreatedNotConnected = TRUE;
    }
    else
    {
        lpdocClient->m_fEmbed = TRUE;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdNewDocument ("classname", "docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdCreate)
    {
        hresult = lpdocClient->DoInitNew();
        lpdocClient->m_fCreatedNotConnected = TRUE;
        goto end;
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // [StdNewFormTemplate ("classname", "docname". "templatename)]
    //
    //////////////////////////////////////////////////////////////////////////
    if (aCmd == aStdCreateFromTemplate)
    {
        ErrRtnH (lpdocClient->DoInitNew());
        lpdocClient->m_fCreatedNotConnected = TRUE;
        IPersistFile FAR * lpPF;
        lptemplate = lpnextarg;

        if(!(lpnextarg = ScanArg(lpnextarg)))
        {
            goto errRtn;
        }


        hresult = lpdocClient->m_lpoleObj->QueryInterface(IID_IPersistFile,(LPLPVOID)&lpPF);
        if (hresult == NOERROR)
        {
            WCHAR awcWideTemplate[MAX_STR];

            if (MultiByteToWideChar(CP_ACP,0,lpdocname,-1,awcWideTemplate,MAX_STR) != FALSE)
            {
                hresult = lpPF->Load(awcWideTemplate, 0);
            }
            else
            {
                Assert(!"Unable to convert characters");
                lpPF->Release();
                hresult = E_UNEXPECTED;
                goto end;
            }

            lpPF->Release();
            lpdocClient->m_fEmbed = TRUE;
        }
        else
        {
            goto end;
        }
    }
    //////////////////////////////////////////////////////////////////////////
    //
    // [StdEditDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////
    // REVIEW: Do we have to call InitNew for editing an embedded object

    if (aCmd == aStdEdit)
    {
        lpdocClient->m_fEmbed = TRUE;
        lpdocClient->m_fGotEditNoPokeNativeYet = TRUE;
        lpdocClient->m_fCreatedNotConnected = TRUE;
        goto end;
    }

    intrDebugOut((DEB_IERROR,
                  "%x CDDESrvr::SrvrExecute Unknown command\n",
                  this));

end:

    if (hresult != NOERROR)
        goto errRtn;
end1:
    // make sure that the srg string is indeed terminated by
    // NULL.
    if (*lpnextarg)
    {
        hresult = RPC_E_DDE_SYNTAX_EXECUTE;
    }
errRtn:

   if ( hresult != NOERROR)
   {
        if (bCreateInst && lpdocClient)
        {
            lpdocClient->DestroyInstance ();
            lpdocClient = NULL;  //DestroyInstance invalidates the pointer
        }
   }

end2:
errRtn1:

   if (lpdata)
        GlobalUnlock (hdup);

   if (hdup)
        GlobalFree (hdup);
   if (pUnk)
                pUnk->Release();

   if (pPersistStg)
        pPersistStg->Release();

   Assert (GetScode(hresult) != E_UNEXPECTED);

   intrDebugOut((DEB_ITRACE,
                  "%x _OUT CDDESrvr::SrvrExecute hresult=%x\n",
                  this,
                  hresult));

   return hresult;
}




// Maybe CreateDocWindow
//
// Return NOERROR only if a doc window was created and it sent an ACK.
//


//+---------------------------------------------------------------------------
//
//  Function:   MaybeCreateDocWindow
//
//  Synopsis:   Determine if a DocWindow should be created
//
//  Effects:    Given a class, and a filename atom, determine if this thread
//              should be the server for this request.
//
//  Arguments:  [aClass] -- Class of object (PROGID)
//              [aFile] -- Filename (ATOM)
//              [hwndDdeServer] -- HWND of CDDEServer
//              [hwndSender] -- HWND of new requesting client
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-29-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
 INTERNAL MaybeCreateDocWindow
    (ATOM aClass,
    ATOM aFile,
    HWND hwndDdeServer,
    HWND hwndSender)
{
    CLSID       clsid       = CLSID_NULL;
    LPUNKNOWN   pUnk        = NULL;
    HWND        hwndClient  = NULL;
    ULONG       fAckSent    = FALSE;
    LPSRVR      pDdeSrvr    = NULL;
    WCHAR       szFile [MAX_STR];
    BOOL        fTrue       = TRUE;
    BOOL        fRunningInSDI   = FALSE;
    HRESULT     hresult = NOERROR;
    IClassFactory *pcf = NULL;
    IPersistFile *ppf = NULL;
    DdeClassInfo        ddeClassInfo;

    intrDebugOut((DEB_DDE_INIT,
                  "MaybeCreateDocWindow(aClass=%x(%ws),aFile=%x,"
                  "hwndDdeServer=%x,hwndSender=%x\n",
                  aClass,wAtomName(aClass),aFile,hwndDdeServer,hwndSender));

    //
    // If the window isn't valid, it would be very bad.
    //
    if (!IsWindowValid(hwndDdeServer))
    {
        intrDebugOut((DEB_DDE_INIT,
                      "MaybeCreateDocWindow: hwndDdeServer is invalid\n"));
        hresult = E_UNEXPECTED;
        goto exitRtn;
    }

    //
    // We need the filename, which is passed in an Atom
    //
    Assert (IsFile (aFile));
    if (GlobalGetAtomName(aFile,szFile,MAX_STR) == 0)
    {
        //
        // The filename was not valid
        //
        hresult = S_FALSE;
        intrDebugOut((DEB_IERROR,
                      "MaybeCreateDocWindow Invalid file atom\n"));
        goto exitRtn;
    }

    intrDebugOut((DEB_DDE_INIT,
                  "MaybeCreateDocWindow File=(%ws)\n",
                  WIDECHECK(szFile)));

    //
    // Get the class of the object. The class was passed as an atom
    // in the INITIATE message.
    //
    if (CLSIDFromAtomWithTreatAs (&aClass, &clsid, NULL))
    {
        intrDebugOut((DEB_IERROR,
                      "MaybeCreateDocWindow CLSIDFromAtom failed\n"));

        hresult = S_FALSE;
        goto exitRtn;
    }

    if (CoIsOle1Class(clsid))
    {
        // we shouldn't even be looking at this INIT message
        hresult = S_FALSE;
        intrDebugOut((DEB_DDE_INIT,
                      "MaybeCreateDocWindow Its an OLE 1.0 class\n"));
        goto exitRtn;
    }

    //
    // First of three cases is to see if the object is running in our
    // local apartment. If it is, then this is the object we need to create
    // a DDEServer for.
    //
    // Otherwise, We are going to try and load this file.
    // Therefore, we need the class factory from the CFT.
    //
    // GetClassInformationForDde won't find a match if the class factory was
    // single use, and is now hidden or invalid.
    //
    // If there was no class information available, then we are going to
    // check to see if the object is in the local ROT. If it is in the
    // local ROT, then we will use it, since it is registered and
    // available for use by others
    //

    ddeClassInfo.dwContextMask = CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER;
    ddeClassInfo.fClaimFactory = TRUE;

    if ( GetLocalRunningObjectForDde(szFile, &pUnk) == NOERROR)
    {
        intrDebugOut((DEB_DDE_INIT,
                      "Found %ws in ROT\n",WIDECHECK(szFile)));
        //
        // Elsewhere in the code, we need to know if this is an SDI server.
        // The old code determined this by detecting that there is a running
        // object, and there was no class factory registered.
        // This is sick, and obscene. Compatibilities says we need to get the
        // class info anyway. However, we don't want to claim it.
        //

        ddeClassInfo.fClaimFactory = FALSE;
        fRunningInSDI = !CCGetClassInformationForDde(clsid,&ddeClassInfo);
    }
    else if (!CCGetClassInformationForDde(clsid,&ddeClassInfo))
    {
        intrDebugOut((DEB_IERROR,
                      "No class registered for %ws\n",WIDECHECK(szFile)));

        hresult = S_FALSE;
        goto exitRtn;
    }
    else
    {
        //
        // Otherwise, we are registered as the server for this class. This
        // means we can create this object.
        //
        // A 1.0 client will have launched the server with a command line
        // like server.exe -Embedding filename The server ignored the filename
        // so now we must make it load the file by binding the moniker.
        //
        // KevinRo: The old code did a bind moniker here, on the filename,
        // which went through the ROT, didn't find the object, so went for
        // a server. This isn't terribly safe, since we could end up binding
        // out of process when we really didn't mean to. So, I have made this
        // routine just use the ClassFactory we retrieve from the
        // local class factory table.
        //

        intrDebugOut((DEB_DDE_INIT,
                      "Found classinfo: Loading %ws\n",WIDECHECK(szFile)));


        //
        // Need to insure that the server doesn't go away on us. The following
        // tells the server not to destroy itself.
        //
        SSSendMessage(hwndDdeServer,WM_DONOTDESTROY,TRUE,0);

        intrAssert(ddeClassInfo.punk != NULL);
        pcf = (IClassFactory *) ddeClassInfo.punk;

        hresult = pcf->CreateInstance(NULL,IID_IUnknown,(void **)&pUnk);

        if (hresult != NOERROR)
        {
            intrDebugOut((DEB_IERROR,
                      "MaybeCreateDocWindow CreateInstancefailed File=(%ws)\n",
                          WIDECHECK(szFile)));
            goto sndMsg;
        }

        //
        // Get the IPersistFile interface, and ask the object to load
        // itself.
        //
        hresult = pUnk->QueryInterface(IID_IPersistFile,(void **)&ppf);
        if (hresult != NOERROR)
        {
            intrDebugOut((DEB_IERROR,
                          "MaybeCreateDocWindow QI IPF failed File=(%ws)\n",
                          WIDECHECK(szFile)));
            goto sndMsg;
        }
        //
        // Attempt to load the object. The flags STGM_READWRITE are the
        // same default values used by a standard bind context.
        //
        hresult = ppf->Load(szFile,STGM_READWRITE);
        if (hresult != NOERROR)
        {
            intrDebugOut((DEB_IERROR,
                          "MaybeCreateDocWindow ppf->Load(%ws) failed %x\n",
                          WIDECHECK(szFile),
                          hresult));
            goto sndMsg;
        }
sndMsg:
        SSSendMessage(hwndDdeServer,WM_DONOTDESTROY,FALSE,0);
        if (hresult != NOERROR)
        {
            goto exitRtn;

        }
        intrDebugOut((DEB_DDE_INIT,
                      "Loading %ws complete\n",WIDECHECK(szFile)));

    }


    intrAssert(IsWindowValid(hwndDdeServer));
    intrAssert (pUnk);

    pDdeSrvr = (LPSRVR) GetWindowLongPtr (hwndDdeServer, 0);
    if (pDdeSrvr == NULL)
    {
        intrAssert(pDdeSrvr != NULL);
        hresult = E_UNEXPECTED;
        goto exitRtn;
    }

    // This actually creates the doc window as a child of the server window
    // Do not set the client site becuase this is a link.
    hresult = CDefClient::Create (pDdeSrvr,
                                  pUnk,
                                  szFile,
                                  /*fSetClientSite*/FALSE,
                                  /*fDoAdvise*/TRUE,
                                  fRunningInSDI,
                                  &hwndClient);

    if (hresult != NOERROR)
    {
        intrDebugOut((DEB_IERROR,
                      "MaybeCreateDocWindow CDefClient::Create failed %x\n",
                      hresult));
        goto exitRtn;
    }

    Assert (IsWindowValid (hwndClient));

    //
    // Pass along the original DDE_INIT to the newly created window.
    // That window should respond by sending an ACK to the 1.0 client.
    //
    fAckSent = (ULONG) SSSendMessage (hwndClient,
                            WM_DDE_INITIATE,
                            (WPARAM) hwndSender,
                            MAKELONG(aClass, aFile));
    if (!fAckSent)
    {
        intrDebugOut((DEB_IERROR,
                      "MaybeCreateDocWindow !fAckSent\n"));
        hresult = CO_E_APPDIDNTREG;
    }

exitRtn:

    if (ppf)
    {
        ppf->Release();
    }
    if (pUnk)
    {
        pUnk->Release();
    }
    if (pcf)
    {
        pcf->Release();
    }

    intrDebugOut((DEB_DDE_INIT,
                  "MaybeCreateDocWindow returns %x\n",
                  hresult));
    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Function:   SendMsgToChildren
//
//  Synopsis:   This routine sends the msg to all child windows.
//
//  Arguments:  [hwnd] -- Hwnd of parent window
//              [msg] --  Message and parameters to send
//              [wParam] --
//              [lParam] --
//
//  Notes: This routine will stop on the first non-zero return code.
//
//----------------------------------------------------------------------------
BOOL SendMsgToChildren (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    intrDebugOut((DEB_ITRACE,
                  "0 _IN SendMsgToChildren(hwnd=%x,msg=%x,wParam=%x,lParam=%x)\n",
                  hwnd,msg,wParam,lParam));

    BOOL fAckSent = FALSE;

    hwnd = GetWindow(hwnd, GW_CHILD);

    //
    // This routine is to be called only from one place, which is
    // in the handling of WM_DDE_INITIATE. Because of that, we will terminate
    // the loop on the first non-zero return code.
    //
    Assert (msg == WM_DDE_INITIATE);

    while (hwnd)
    {
        intrDebugOut((DEB_ITRACE,"   SendMsgToChildren send to hwnd=%x\n",hwnd));

        if (fAckSent = (1L==SSSendMessage (hwnd, msg, wParam, lParam)))
        {
            break;
        }

        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }

    intrDebugOut((DEB_ITRACE,"0 OUT SendMsgToChildren returns %x\n",fAckSent));
    return(fAckSent);
}


//+---------------------------------------------------------------------------
//
//  Function:   SendInitMsgToChildren
//
//  Synopsis:   Sends an init message to all child windows of the hwnd
//
//  Effects:    This routine will send an init message to all children
//              of the given window. It is assuming that the lParam is
//              the atom that contains the topic (ie filename) of the
//              object being looked for.
//
//  Arguments:  [hwnd] -- hwnd of server window
//              [msg] -- MSG to send
//              [wParam] -- hwnd of client window
//              [lParam] -- HIWORD(lParam) is atom of filename
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-28-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL SendInitMsgToChildren (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    intrDebugOut((DEB_DDE_INIT,
                  "0 _IN SendInitMsgToChildren(hwnd=%x,msg=%x,wParam=%x,lParam=%x)\n",
                  hwnd,msg,wParam,lParam));

    BOOL fAckSent = FALSE;

    fAckSent = SendMsgToChildren(hwnd,msg,wParam,lParam);

    //
    // If no windows acknowledged, then we might need to create a doc window
    //
    if (!fAckSent)
    {
        ATOM aTopic = HIWORD(lParam);
        Assert (IsAtom(aTopic));

        // if someone's trying to initiate on a filename, i.e., for a link
        // then create the doc window on demand because 2.0 servers do not
        // register doc windows.  They don't even accept "-Embedding filename"
        // on the command line
        if (aTopic != aOLE && aTopic != aSysTopic && IsFile (aTopic))
        {
            intrDebugOut((DEB_DDE_INIT,"   Initiate for link %ws\n",wAtomName(aTopic)));
            HRESULT hresult = MaybeCreateDocWindow (LOWORD(lParam), aTopic,
                                                    hwnd, (HWND)wParam);

            fAckSent = (NOERROR==hresult);
        }
    }
    intrDebugOut((DEB_DDE_INIT,
                  "0 _OUT SendInitMsgToChildren fAckSent=%x\n",fAckSent));
    return fAckSent;
}



INTERNAL_(HRESULT)   RequestDataStd
(
ATOM        aItem,
LPHANDLE    lphdde
)
{


    HANDLE  hnew = NULL;

    if (!aItem)
        goto errRtn;

    if (aItem == aEditItems){
        hnew = MakeGlobal ("StdHostNames\tStdDocDimensions\tStdTargetDevice");
        goto   PostData;

    }

    if (aItem == aProtocols) {
        hnew = MakeGlobal ("Embedding\tStdFileEditing");
        goto   PostData;
    }

    if (aItem == aTopics) {
        hnew = MakeGlobal ("Doc");
        goto   PostData;
    }

    if (aItem == aFormats) {
        hnew = MakeGlobal ("Picture\tBitmap");
        goto   PostData;
    }

    if (aItem == aStatus) {
        hnew = MakeGlobal ("Ready");
        goto   PostData;
    }

    // format we do not understand.
    goto errRtn;

PostData:

    // Duplicate the DDE data
    if (MakeDDEData (hnew, CF_TEXT, lphdde, TRUE)){
        // !!! why are we duplicating the atom.
        DuplicateAtom (aItem);
        return NOERROR;
    }
errRtn:
    return ReportResult(0, S_FALSE, 0, 0);
}


//IsSingleServerInstance: returns true if the app is single server app else
//false.

INTERNAL_(BOOL)  IsSingleServerInstance ()
{
    HWND    hwnd;
    WORD    cnt = 0;
    HTASK   hTask;
    DdeCHAR    buf[MAX_STR];

    hwnd  = GetWindow (GetDesktopWindow(), GW_CHILD);
    hTask = GetCurrentThreadId();

    while (hwnd) {
        if (hTask == ((HTASK) GetWindowThreadProcessId (hwnd,NULL))) {
            DdeGetClassName (hwnd, buf, MAX_STR);
            if (Ddelstrcmp (buf, SRVR_CLASS) == 0)
                cnt++;
        }
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
#ifdef  FIREWALLS
     AssertSz (cnt > 0, "srvr window instance count is zero");
#endif
    if (cnt == 1)
        return TRUE;
    else
        return FALSE;

}


// QueryRevokeClassFactory: returns FALSE if there are clients
// connected tothis class factory;
INTERNAL_(BOOL)        CDDEServer::QueryRevokeClassFactory ()
{

    HWND        hwnd;
    LPCLIENT    lpclient;

    Assert (IsWindow (m_hwnd));
    hwnd = GetWindow (m_hwnd, GW_CHILD);
    while (hwnd)
    {
        Assert (IsWindow (hwnd));
        lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);
        if (lpclient->m_cClients != 0 || lpclient->m_fCreatedNotConnected)
            return FALSE;
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  Method:     CDDEServer::CreateInstance
//
//  Synopsis:   Create an instance of a document
//
//  Effects:
//
//  Arguments:  [lpclassName] --
//              [lpWidedocName] --
//              [lpdocName] --
//              [pUnk] --
//              [lplpdocClient] --
//              [hwndClient] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-30-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CDDEServer::CreateInstance
(
REFCLSID        lpclassName,
LPOLESTR        lpWidedocName,
LPSTR           lpdocName,
LPUNKNOWN       pUnk,
LPCLIENT FAR*   lplpdocClient,
HWND            hwndClient)
{
    intrDebugOut((DEB_ITRACE,
                  "%p _IN CDDEServer::CreateInstance(lpWidedocName=%ws,hwndClient=%x)\n",
                  this,
                  WIDECHECK(lpWidedocName),
                  hwndClient));


    LPUNKNOWN           pUnk2=NULL;
    LPOLEOBJECT     lpoleObj= NULL;       // unknown object
    HRESULT         hresult;

    ChkS(this);

    if (NULL==pUnk)
    {
        Assert (m_pClassFactory);
        hresult = m_pClassFactory->CreateInstance (NULL, IID_IUnknown, (LPLPVOID)&pUnk2);

        if (hresult != NOERROR)
        {
            return hresult;
        }

        // Now that we have *used* the DDE server window, we can unlock
        // the server.
        // The OLE1 OleLockServer API opens a dummy DDE system channel
        // and just leaves it open until OleunlockServer is called.
        // Since we have now used this channel, we know it was not created
        // for the purpose of locking the server.
        this->Lock (FALSE, hwndClient);

        // if it is an SDI app, we must revoke the ClassFactory after using it
        // it is only good for "one-shot" createinstance call.
        if (m_fcfFlags == REGCLS_SINGLEUSE)
        {
            m_pClassFactory->Release();         // done with the ClassFactory
            Puts ("NULLing m_pCF\r\n");
            m_pClassFactory = NULL;
        }
    }
    else
    {
        pUnk2 = pUnk;
        pUnk->AddRef();
    }

    hresult = CDefClient::Create ((LPSRVR)this,
                                  pUnk2,
                                  lpWidedocName,
                                  /*fSetClientSite*/FALSE,
                                  /*fDoAdvise*/pUnk!=NULL);

    intrAssert (pUnk2 != NULL);
    if (pUnk2 != NULL)
    {
        pUnk2->Release();
    }

    pUnk2 = NULL;

    // REVIEW: error recovery
    if (!(*lplpdocClient = FindDocObj (lpdocName)))
    {
        intrAssert(!"Document created but not found");
    }
    else
    {
        // set the server instance flag so that WM_DDE_INITIATE will not icrement
        // the ref count. (EXCEL BUG)
        (*lplpdocClient)->m_bCreateInst = TRUE;
    }
    intrDebugOut((DEB_ITRACE,
                  "%p _OUT CDDEServer::CreateInstance hresult=%x\n",
                  this,hresult));
    return hresult;
}


INTERNAL_(void) CDDEServer::Lock
        (BOOL fLock,      // lock or unlock?
        HWND hwndClient)  // on behalf of which window?
{
    intrDebugOut((DEB_ITRACE,
                  "%p _IN CDDEServer::Lock(fLock=%x,hwndCient=%x)\n",
                  this,
                  fLock,
                  hwndClient));

    VDATEHEAP();
    BOOL fIsLocked = FindClient (m_hcli, hwndClient, /*fDelete*/FALSE) != NULL;

    if (fLock && !fIsLocked)
    {
        if (m_pClassFactory)
        {
            intrDebugOut((DEB_ITRACE,
                          "%p ::Locking %x\n",
                          this,
                          m_pClassFactory));

            m_pClassFactory->LockServer (TRUE);
            // Only way to change the data associated with a client window
            // is to delete it and re-add it with the new data.
            FindClient (m_hcli, hwndClient, /*fDelete*/ TRUE);
            AddClient (&m_hcli, hwndClient, (HANDLE) TRUE); // mark as locked
        }
    }
    else if (!fLock && fIsLocked)
    {
        if (m_pClassFactory)
        {
            intrDebugOut((DEB_ITRACE,
                          "%p ::UnLocking %x\n",
                          this,
                          m_pClassFactory));
            m_pClassFactory->LockServer (FALSE);
            FindClient (m_hcli, hwndClient, /*fDelete*/ TRUE);
            AddClient (&m_hcli, hwndClient, (HANDLE) FALSE); //mark as unlocked
        }
    }
    VDATEHEAP();
    intrDebugOut((DEB_ITRACE,
                  "%p _OUT CDDEServer::Lock(fLock=%x,hwndCient=%x)\n",
                  this,
                  fLock,
                  hwndClient));
}





INTERNAL CDefClient::DestroyInstance
    (void)
{
    Puts ("DestroyInstance\r\n");
    // We just created the instance. we ran into error.
    // just call Release.
    m_pUnkOuter->AddRef();
    ReleaseObjPtrs();
    Verify (0==m_pUnkOuter->Release());
    //  "this" should be deleted now
    return NOERROR;
}



INTERNAL CDefClient::SetClientSite
 (void)
{
    HRESULT hresult = m_lpoleObj->SetClientSite (&m_OleClientSite);
    if (hresult==NOERROR)
    {
        m_fDidSetClientSite = TRUE;
    }
    else
    {
        Warn ("SetClientSite failed");
    }
    return hresult;
}


// implementations of IRpcStubBuffer methods
STDMETHODIMP CDdeServerCallMgr::QueryInterface
    ( REFIID iid, LPVOID * ppvObj )
{
    return S_OK;
}

STDMETHODIMP_(ULONG)CDdeServerCallMgr::AddRef ()
{
    return 1;
}

STDMETHODIMP_(ULONG)CDdeServerCallMgr::Release ()
{
    return 1;
}


STDMETHODIMP CDdeServerCallMgr::Connect
    (IUnknown * pUnkServer )
{
    // do nothing
    return S_OK;
}

STDMETHODIMP_(void) CDdeServerCallMgr::Disconnect
    ()
{
    // do nothing
}

STDMETHODIMP_(IRpcStubBuffer*) CDdeServerCallMgr::IsIIDSupported
    (REFIID riid)
{
    // do nothing
    return NULL;
}


STDMETHODIMP_(ULONG) CDdeServerCallMgr::CountRefs
    ()
{
    // do nothing
    return 1;
}

STDMETHODIMP CDdeServerCallMgr::DebugServerQueryInterface
    (void ** ppv )
{
    // do nothing
    *ppv = NULL;
    return S_OK;
}


STDMETHODIMP_(void) CDdeServerCallMgr::DebugServerRelease
    (void * pv)
{
    // do nothing
}

STDMETHODIMP CDdeServerCallMgr::Invoke
    (RPCOLEMESSAGE *_prpcmsg, IRpcChannelBuffer *_pRpcChannelBuffer)
{
    DISPATCHDATA *pdispdata = (PDISPATCHDATA) _prpcmsg->Buffer;
    return DispatchCall( pdispdata );
}


// Provided IRpcChannelBuffer methods (for callback methods side)
STDMETHODIMP CDdeServerCallMgr::GetBuffer(
/* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
/* [in] */ REFIID riid)
{
    return S_OK;
}

STDMETHODIMP CDdeServerCallMgr::SendReceive(
/* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
/* [out] */ ULONG __RPC_FAR *pStatus)
{
    return S_OK;
}

STDMETHODIMP CDdeServerCallMgr::FreeBuffer(
/* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage)
{
    return S_OK;
}

STDMETHODIMP CDdeServerCallMgr::GetDestCtx(
/* [out] */ DWORD __RPC_FAR *pdwDestContext,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppvDestContext)
{
    return S_OK;
}

STDMETHODIMP CDdeServerCallMgr::IsConnected( void)
{
    return S_OK;
}

STDMETHODIMP CDdeServerCallMgr::GetProtocolVersion(
/* [out] */ DWORD __RPC_FAR *pdwVersion)
{
    return S_OK;
}

STDMETHODIMP CDdeServerCallMgr::SendReceive2(
/* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
/* [out] */ ULONG __RPC_FAR *pStatus)
{
    intrDebugOut((DEB_ITRACE,
                  "%p _IN CDdeServerCallMgr::SendReceive2(pMessage=%x,pStatus=%x)\n",
                  this,
                  pMessage,
                  pStatus));

    DDECALLDATA *pCD = ((DDECALLDATA *) pMessage->Buffer);

    if(!PostMessageToClient(pCD->hwndSvr,
                            pCD->wMsg,
                            pCD->wParam,
                            pCD->lParam))
    {
        intrDebugOut((DEB_ITRACE, "SendRecieve2(%x)PostMessageToClient failed", this));
        return RPC_E_SERVER_DIED;
    }


    CAptCallCtrl *pCallCtrl = GetAptCallCtrl();

    CCliModalLoop *pCML = pCallCtrl->GetTopCML();

    HRESULT hres = S_OK;
    BOOL fWait = !(m_pDefClient->m_CallState == SERVERCALLEX_ISHANDLED);

    while (fWait)
    {
        HRESULT hr = OleModalLoopBlockFn(NULL, pCML, NULL);

        if (m_pDefClient->m_CallState == SERVERCALLEX_ISHANDLED)
        {
            fWait = FALSE;
        }
        else if (hr != RPC_S_CALLPENDING)
        {
            fWait = FALSE;
            hres = hr;          // return result from OleModalLoopBlockFn()
        }
    }

    if (FAILED(hres))
    {
        intrDebugOut((DEB_ITRACE, "**** CDdeServerCallMgr::SendReceive2 OleModalLoopBlockFn returned %x ***\n", hres));
    }

    intrDebugOut((DEB_ITRACE,
                  "%p _OUT CDdeServerCallMgr::SendReceive2(pMessage=%x,pStatus=%x)\n",
                  this,
                  pMessage,
                  pStatus));

    return hres;
}


STDMETHODIMP CDdeServerCallMgr::ContextInvoke(
/* [out][in] */ RPCOLEMESSAGE *pMessage,
/* [in] */ IRpcStubBuffer *pStub,
/* [in] */ IPIDEntry *pIPIDEntry,
/* [out] */ DWORD *pdwFault)
{
    intrDebugOut((DEB_ITRACE,
                  "%p _IN CDdeServerCallMgr::ContextInvoke(pMessage=%x,pStub=%x,pdwFault=%x)\n",
                  this,
                  pMessage,
                  pStub,
                  pdwFault));

    HRESULT hr = StubInvoke(pMessage, NULL, pStub, (IRpcChannelBuffer3 *)this, pIPIDEntry, pdwFault);
    
    intrDebugOut((DEB_ITRACE,
                  "%p _OUT CDdeServerCallMgr::ContextInvoke returning hr=0x%x\n",
                  this,
                  hr));
    return(hr);
}


STDMETHODIMP CDdeServerCallMgr::GetBuffer2(
/* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
/* [in] */ REFIID riid)
{
    return GetBuffer(pMessage, riid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\debug\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   debug
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..;..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc
INCLUDES=     $(INCLUDES);..\..\..\..\inc
INCLUDES=     $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\obj
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\obj
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\obj

SOURCES=      \
              ..\assert.cxx   \
              ..\valid.cxx

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\srvr.h ===
/****************************** Module Header ******************************\
* Module Name: srvr.h
*
* PURPOSE: Private definitions file for server code
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*  Raor (../../90,91)  Original
*
\***************************************************************************/
//
// One of the oleint.h routines redefines GlobalAlloc and friends
// to perform some memory tracking functions.
//
// This doesn't work in these files, since the tracking functions
// add tail checking, and size to the data structures. GlobalSize
// is a common function to use to determine how much data to
// serialize, plus it turns out that the other side of a DDE
// connection will often be the caller to free the memory.
//
// Therefore, OLE_DDE_NO_GLOBAL_TRACKING is used to disable this in the
// global header file ih\memapi.hxx. Check to insure this
// flag is set on the compile line
//
#if !defined(OLE_DDE_NO_GLOBAL_TRACKING)
error OLE_DDE_OLE_DDE_NO_GLOBAL_TRACKING must be defined to build this directory
#endif

#include <dde.h>
#include <ddeerr.h>
#include "ddeatoms.h"
#include "ddepack.h"
#include <callctrl.hxx>
#include <ddeint.h>
#include <ddechc.hxx>
#include <longname.h>

//#define UPDATE
/*
 if UPDATE is defined it means:
 If a 1.0 client advises on save, also do a data advise.
 This way the client will always
 have an up-to-date picture (and native data) with respect to a
 2.0 server, like 2.0 clients do.
 If a 1.0 client is prepared to accept data at save time
 it should be able to handle data on each change: it is exactly
 as if the user chose File.Update after each change.
 In fact the item atom is appended with /Save, (see SendDataMsg1)
 which is sort of a lie, but is what a 1.0 client expects for an
 embedded object.
 This is a UI issue.
*/

#define DEFSTD_ITEM_INDEX   0
#define STDTARGETDEVICE     1
#define STDDOCDIMENSIONS    2
#define STDCOLORSCHEME      3
#define STDHOSTNAMES        4


#define PROTOCOL_EDIT       (OLESTR("StdFileEditing"))
#define PROTOCOL_EXECUTE    (OLESTR("StdExecute"))

#define   ISATOM(a)     ((a >= 0xC000) && (a <= 0xFFFF))

// same limit as in OLE 1.0
#define   MAX_STR       124

#define   WW_LPTR       0       // ptr tosrvr/doc/item
#define   WW_HANDLE     4       // instance handle
#define   WW_LE         8       // signature


#define   WC_LE         0x4c45  // LE chars


// Signatures for validity checking
typedef enum
{
        chkDdeSrvr   = 0x1234,
        chkDefClient = 0x5678
} CHK;


const DWORD grfCreateStg =      STGM_READWRITE | STGM_SHARE_EXCLUSIVE
                                                                        | STGM_DIRECT | STGM_CREATE ;


// If we running under WLO, the HIGHWORD of version number will be >= 0x0A00
#define VER_WLO     0x0A00

extern  "C" WORD CheckPointer (LPVOID, int);

#define READ_ACCESS     0
#define WRITE_ACCESS    1

#define PROBE_READ(lp){\
        if (!CheckPointer(lp, READ_ACCESS))\
            return ReportResult(0, E_INVALIDARG, 0, 0);  \
}

#define PROBE_WRITE(lp){\
        if (!CheckPointer(lp, WRITE_ACCESS))\
            return ReportResult(0, E_INVALIDARG, 0, 0);  \
}

#define   OLE_COMMAND       1
#define   NON_OLE_COMMAND   2


#define   WT_SRVR           0       // server window
#define   WT_DOC            1       // document window

#define   PROBE_BLOCK(lpsrvr) {             \
    if (lpsrvr->bBlock)                     \
        return ReportResult(0, S_SERVER_BLOCKED, 0, 0);    \
}


#define   SET_MSG_STATUS(retval, status) { \
    if (!FAILED (GetScode (retval)))     \
        status |= 0x8000;                  \
    if (GetScode(retval) == RPC_E_SERVERCALL_RETRYLATER)\
        status |= 0x4000;                  \
}


/* Codes for CallBack events */
typedef enum {
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
} OLE_NOTIFICATION;

typedef enum { cnvtypNone, cnvtypConvertTo, cnvtypTreatAs } CNVTYP;

typedef struct _QUE : public CPrivAlloc {   // nodes in Block/Unblock queue
    HWND        hwnd;       //***
    UINT                msg;        //      window
    WPARAM      wParam;     //      procedure parameters
    LPARAM      lParam;     //***
    HANDLE      hqNext;     // handle to next node
} QUE;

typedef QUE NEAR *  PQUE;
typedef QUE FAR *   LPQUE;

// structure for maintaining the client info.
#define         LIST_SIZE       10
typedef  struct _CLILIST : public CPrivAlloc {
    HANDLE                 hcliNext;
    HANDLE                 info[LIST_SIZE * 2];
}CLILIST;

typedef     CLILIST FAR *LPCLILIST;
typedef     CLILIST     *PCLILIST;


// this is an object to be embedded in both CDefClient and CDDEServer to glue
// to the new(est) call control interface
class CDdeServerCallMgr : public IRpcStubBuffer, public IInternalChannelBuffer
{
   private:
        CDefClient * m_pDefClient;      // our embeddor (either a CDefClient or a CDDEServer)
        CDDEServer * m_pDDEServer;      // one of these is NULL;

   public:
        CDdeServerCallMgr (CDefClient * pDefClient)
           { m_pDefClient       = pDefClient;
             m_pDDEServer       = NULL;}

        CDdeServerCallMgr (CDDEServer * pDefClient)
           { m_pDefClient       = NULL;
             m_pDDEServer       = pDefClient;}

        STDMETHOD(QueryInterface) ( REFIID iid, LPVOID * ppvObj);
        STDMETHOD_(ULONG,AddRef) ();
        STDMETHOD_(ULONG,Release) ();

        // IRpcStubBuffer methods
        STDMETHOD(Connect)(
            /* [in] */ IUnknown *pUnkServer);

        STDMETHOD_(void,Disconnect)( void);

        STDMETHOD(Invoke)(
            /* [in] */ RPCOLEMESSAGE *_prpcmsg,
            /* [in] */ IRpcChannelBuffer *_pRpcChannelBuffer);

        STDMETHOD_(IRpcStubBuffer *,IsIIDSupported)(
            /* [in] */ REFIID riid);

        STDMETHOD_(ULONG,CountRefs)( void);

        STDMETHOD(DebugServerQueryInterface)(
            void * *ppv);

        STDMETHOD_(void,DebugServerRelease)(
            void  *pv);



         // IRpcChannelBuffer methods
        STDMETHOD(GetBuffer) (
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [in] */ REFIID riid);

        STDMETHOD(SendReceive) (
            /* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [out] */ ULONG __RPC_FAR *pStatus);

        STDMETHOD(FreeBuffer) (
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage);

        STDMETHOD(GetDestCtx) (
            /* [out] */ DWORD __RPC_FAR *pdwDestContext,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvDestContext);

        STDMETHOD(IsConnected) ( void);

        // IRpcChannelBuffer2 methods
        STDMETHOD(GetProtocolVersion) (DWORD *pdwVersion);

        // IRpcChannelBuffer3 methods (not implemented)
        STDMETHOD(Send)     (RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
        {
            Win4Assert(FALSE);
            return E_NOTIMPL;
        }

        STDMETHOD(Receive)  (RPCOLEMESSAGE *pMsg, ULONG uSize, ULONG *pulStatus)
        {
            Win4Assert(FALSE);
            return E_NOTIMPL;
        }

        // IInternalChannelBuffer methods (not implemented
        STDMETHOD(Send2)     (RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
        {
            Win4Assert(FALSE);
            return E_NOTIMPL;
        }

        STDMETHOD(Receive2)(RPCOLEMESSAGE *pMsg, ULONG uSize, ULONG *pulStatus)
        {
            Win4Assert(FALSE);
            return E_NOTIMPL;
        }

        STDMETHOD(SendReceive2) (
            /* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [out] */ ULONG __RPC_FAR *pStatus);

        STDMETHODIMP Cancel        ( RPCOLEMESSAGE *pMsg )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP GetCallContext( RPCOLEMESSAGE *pMsg,
                                     REFIID riid,
                                     void **pInterface )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP GetDestCtxEx  ( RPCOLEMESSAGE *pMsg,
                                     DWORD *pdwDestContext,
                                     void **ppvDestContext )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP GetState      ( RPCOLEMESSAGE *pMsg,
                                     DWORD *pState )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP RegisterAsync ( RPCOLEMESSAGE *pMsg,
                                     IAsyncManager *pComplete )
                                                      { return E_NOTIMPL; }

        // Provided IAsyncRpcChannelBuffer methods (not implemented)
        STDMETHODIMP Send(RPCOLEMESSAGE *pMsg, ISynchronize*, ULONG *pulStatus)
        {
          Win4Assert(FALSE);
          return E_NOTIMPL;
        }
        STDMETHOD(Receive)  (RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
        {
            Win4Assert(FALSE);
            return E_NOTIMPL;
        }

        STDMETHOD(ContextInvoke)(
            /* [out][in] */ RPCOLEMESSAGE *pMessage,
            /* [in] */ IRpcStubBuffer *pStub,
            /* [in] */ IPIDEntry *pIPIDEntry,
            /* [out] */ DWORD *pdwFault);

        STDMETHOD(GetBuffer2) (
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [in] */ REFIID riid);
};


class FAR CDDEServer
{
  public:
    static HRESULT      Create (LPOLESTR lpclass,
                                REFCLSID rclsid,
                                LPDDECLASSINFO lpDdeInfo,
                                HWND FAR * phwnd,
                                ATOM aOriginalClass,
                                CNVTYP cnvtyp);

    INTERNAL_(BOOL)     HandleInitMsg (LPARAM);
    INTERNAL            SrvrExecute (HWND, HANDLE, HWND);
    INTERNAL            Revoke (void);
    INTERNAL_(BOOL)     QueryRevokeClassFactory (void);
    INTERNAL_(LPCLIENT) FindDocObj (LPSTR lpDoc);
    INTERNAL_(void)     Lock (BOOL fLock, HWND hwndClient);


    CLSID           m_clsid;              // Class ID
    DWORD           m_dwClassFactoryKey;  // Class factory reg key
    LPCLASSFACTORY  m_pClassFactory;      // class factory
    CDdeServerCallMgr m_pCallMgr;         // call management interfaces
    BOOL            m_bTerminate;         // Set if we are terminating.
    HWND            m_hwnd;               // corresponding window
    HANDLE          m_hcli;               // handle to the first block of clients list
    int             m_termNo;             // termination count
    int             m_cSrvrClients;       // no of clients;
    DWORD           m_fcfFlags;           // Class factory instance usage flags
    CNVTYP          m_cnvtyp;
    CHK             m_chk;

    ATOM            m_aClass;             // class atom
    ATOM            m_aOriginalClass;     // for TreatAs/ConvertTo case
    ATOM            m_aExe;

    BOOL            m_fDoNotDestroyWindow; // When set, server wnd ingores WM_USER

  private:
    INTERNAL_(void)     SendServerTerminateMsg (void);
    INTERNAL            RevokeAllDocObjs (void);
    INTERNAL            FreeSrvrMem (void);
    INTERNAL            CreateInstance (REFCLSID clsid, LPOLESTR lpWidedocName, LPSTR lpdocName,
                                        LPUNKNOWN pUnk, LPCLIENT FAR* lplpdocClient,
                                        HWND hwndClient);

public:
    //ctor
    CDDEServer()
                : m_pCallMgr( this )
        {
        }


};




BOOL              SendInitMsgToChildren (HWND, UINT msg, WPARAM wParam, LPARAM lParam);

INTERNAL          RequestDataStd (ATOM, HANDLE FAR *);
INTERNAL_(BOOL)   ValidateSrvrClass (LPOLESTR, ATOM FAR *);
INTERNAL_(ATOM)   GetExeAtom (LPOLESTR);
INTERNAL_(BOOL)   AddClient (LPHANDLE, HANDLE, HANDLE);
INTERNAL_(HANDLE) FindClient (HANDLE hCli, HANDLE hkey, BOOL fDelete);

INTERNAL_(BOOL)   IsSingleServerInstance (void);

INTERNAL_(void)   UtilMemCpy (LPSTR, LPSTR, DWORD);
INTERNAL_(HANDLE) DuplicateData (HANDLE);
INTERNAL_(LPSTR)  ScanBoolArg (LPSTR, BOOL FAR *);
INTERNAL_(LPSTR)  ScanNumArg (LPSTR, LPINT);
INTERNAL_(LPSTR)  ScanArg(LPSTR);
INTERNAL_(ATOM)   MakeDataAtom (ATOM, int);
INTERNAL_(ATOM)   DuplicateAtom (ATOM);
INTERNAL_(BOOL)   CLSIDFromAtom(ATOM aClass, LPCLSID lpclsid);
INTERNAL          CLSIDFromAtomWithTreatAs (ATOM FAR* paClass, LPCLSID lpclsid,
                                            CNVTYP FAR* pcnvtyp);
INTERNAL          wFileIsRunning (LPOLESTR szFile);
INTERNAL          wFileBind (LPOLESTR szFile, LPUNKNOWN FAR* ppUnk);
INTERNAL          wCreateStgAroundNative (HANDLE hNative,
                                        ATOM aClassOld,
                                        ATOM aClassNew,
                                        CNVTYP cnvtyp,
                                        ATOM aItem,
                                        LPSTORAGE FAR* ppstg,
                                        LPLOCKBYTES FAR* pplkbyt);
INTERNAL          wCompatibleClasses (ATOM aClient, ATOM aSrvr);




typedef struct FARSTRUCT : public CPrivAlloc {
        BOOL    f;          // do we need to send an ack?
                            // If this is FALSE, other fields don't matter
        HGLOBAL hdata;
        HWND    hwndFrom;   // who sent the execute?
        HWND    hwndTo;
} EXECUTEACK;


// client struct definitions.



class FAR CDefClient : public CPrivAlloc
{
  public:
        static INTERNAL Create
                               (LPSRVR      pDdeSrvr,
                                LPUNKNOWN   lpunkObj,
                                LPOLESTR    lpdocName,
                                const BOOL  fSetClientSite,
                                const BOOL  fDoAdvise,
                                const BOOL  fRunningInSDI = FALSE,
                                HWND FAR*   phwnd = NULL);

   INTERNAL         DocExecute (HANDLE);
   INTERNAL         DocDoVerbItem (LPSTR, WORD, BOOL, BOOL);
   INTERNAL         DocShowItem (LPSTR, BOOL);
   INTERNAL         DestroyInstance ();
   INTERNAL_(void)  DeleteFromItemsList (HWND h);
   INTERNAL_(void)  RemoveItemFromItemList (void);
   INTERNAL_(void)  ReleasePseudoItems (void);
   INTERNAL_(void)  ReleaseAllItems ();
   INTERNAL         PokeStdItems (HWND, ATOM, HANDLE,int);
   INTERNAL         PokeData (HWND, ATOM, HANDLE);
   INTERNAL         AdviseData (HWND, ATOM, HANDLE, BOOL FAR *);
   INTERNAL         AdviseStdItems (HWND, ATOM, HANDLE, BOOL FAR *);
   INTERNAL         UnAdviseData (HWND, ATOM);
   INTERNAL         RequestData (HWND, ATOM, USHORT, HANDLE FAR *);
   INTERNAL         Revoke (BOOL fRelease=TRUE);
   INTERNAL         ReleaseObjPtrs (void);
   INTERNAL_(void)  DeleteAdviseInfo ();
   INTERNAL         DoOle20Advise (OLE_NOTIFICATION, CLIPFORMAT);
   INTERNAL         DoOle20UnAdviseAll (void);
   INTERNAL         SetClientSite (void);
   INTERNAL         NoItemConnections (void);
   INTERNAL_(void)  SendExecuteAck (HRESULT hresult);
   INTERNAL         DoInitNew(void);
   INTERNAL         Terminate(HWND, HWND);
   INTERNAL_(void)  SetCallState (SERVERCALLEX State)
                    {
                        m_CallState = State;
                    }

        CHK               m_chk;       // signature
        CDdeServerCallMgr m_pCallMgr;  // call management interfaces
        SERVERCALLEX      m_CallState;

        IUnknown FAR*   m_pUnkOuter;
        LPOLEOBJECT     m_lpoleObj;    // corresponding oleobj
        LPDATAOBJECT    m_lpdataObj;   // corresponding dataobj
        BOOL            m_bCreateInst; // instance is just created.
        BOOL            m_bTerminate;  // REVIEW: The next two fields may not be necessary.
        int             m_termNo;
        ATOM            m_aItem;       // item atom or index for some std items
        HANDLE          m_hcli;        // handle to the first block of clients list (Document only)
        CDefClient FAR *m_lpNextItem;  // ptr to the next item.
        BOOL            m_bContainer;  // Is document?
        BOOL            m_cRef;
        HWND            m_hwnd;        // doc window (only needed in document)
        HANDLE          m_hdevInfo;    // latest printer dev info sent
        HANDLE          m_hcliInfo;    // advise info for each of the clients
        BOOL            m_fDidRealSetHostNames;
        BOOL            m_fDidSetClientSite;
        BOOL            m_fGotDdeAdvise;
        BOOL            m_fCreatedNotConnected;
        BOOL            m_fInOnClose;
        BOOL            m_fInOleSave;
        EXECUTEACK      m_ExecuteAck;
        DWORD           m_dwConnectionOleObj;
        DWORD           m_dwConnectionDataObj;
        LPLOCKBYTES     m_plkbytNative; // These two fields always refer to
        LPSTORAGE       m_pstgNative;   //   to the same bits:
                                        // The server's persistent storage is
                                        // used as its native data.
        BOOL            m_fRunningInSDI;// Link case: file was already open in
                                        // an SDI app which does not register a
                                        // class factory.
        LPSRVR          m_psrvrParent;  // (Document only)
        DVTARGETDEVICE FAR* m_ptd;
        BOOL            m_fGotStdCloseDoc;
        BOOL            m_fGotEditNoPokeNativeYet;
        BOOL            m_fLocked; // locked by CoLockObjectExternal ?

        // If not FALSE, then we are waiting for a matching TERMINATE

        BOOL            m_fCallData;





        // REVIEW: These fields might be necssary for doc (old) level object
        BOOL            m_fEmbed;       // embedded object (Document only)
        int             m_cClients;     // (Document only)
        LPCLIENT        m_pdoc;         // containing document (for items) or self (for docs)


implementations:

        STDUNKDECL (CDefClient,DefClient);

        /*** IOleClientSite ***/
        implement COleClientSiteImpl : IOleClientSite
        {
                public:
                // Constructor
                COleClientSiteImpl (CDefClient FAR* pDefClient)
                {       m_pDefClient = pDefClient;
                }
                STDMETHOD(QueryInterface) (REFIID, LPVOID FAR *);
                STDMETHOD_(ULONG,AddRef) (void);
                STDMETHOD_(ULONG,Release) (void);

                /*** IOleClientSite methods ***/
                STDMETHOD(SaveObject) (THIS);
                STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker,
                                        LPMONIKER FAR* ppmk);
                STDMETHOD(GetContainer) (THIS_ LPOLECONTAINER FAR* ppContainer);
                STDMETHOD(ShowObject) (THIS);
                STDMETHOD(OnShowWindow) (THIS_ BOOL fShow);
                STDMETHOD(RequestNewObjectLayout) (THIS);

                private:
                CDefClient FAR* m_pDefClient;
        };

        DECLARE_NC (CDefClient, COleClientSiteImpl)
        COleClientSiteImpl m_OleClientSite;



        /*** IAdviseSink ***/
        implement CAdviseSinkImpl : IAdviseSink
        {
                public:
                // Constructor
                CAdviseSinkImpl (CDefClient FAR* pDefClient)
                {       m_pDefClient = pDefClient;
                }

                STDMETHOD(QueryInterface) (REFIID, LPVOID FAR *);
                STDMETHOD_(ULONG,AddRef) (void);
                STDMETHOD_(ULONG,Release) (void);

                /**** IAdviseSink methods ****/
                STDMETHOD_(void,OnDataChange)(THIS_ FORMATETC FAR* pFormatetc,
                                                                                                STGMEDIUM FAR* pStgmed) ;
                STDMETHOD_(void,OnViewChange)(THIS_ DWORD aspects, LONG lindex) ;
                STDMETHOD_(void,OnExtentChange)(DWORD dwAspect, LPSIZEL lpsizel) {}
                STDMETHOD_(void,OnRename)(THIS_ LPMONIKER pmk) ;
                STDMETHOD_(void,OnSave)(THIS) ;
                STDMETHOD_(void,OnClose)(THIS) ;

                private:
                CDefClient FAR* m_pDefClient;
        };


        DECLARE_NC (CDefClient, CAdviseSinkImpl)

        CAdviseSinkImpl m_AdviseSink;
ctor_dtor:
        CDefClient (LPUNKNOWN pUnkOuter);
        ~CDefClient (void);

private:
        INTERNAL            ItemCallBack (int msg, LPOLESTR szNewName = NULL);
        INTERNAL_(void)     SendTerminateMsg ();
        INTERNAL_(BOOL)     SendDataMsg1 (HANDLE, WORD);
        INTERNAL_(BOOL)     SendDataMsg (WORD);
        INTERNAL_(void)     TerminateNonRenameClients (LPCLIENT);
        INTERNAL_(void)     SendRenameMsgs (HANDLE);
        INTERNAL            RegisterItem (LPOLESTR, LPCLIENT FAR *, BOOL);
        INTERNAL            FindItem (LPOLESTR, LPCLIENT FAR *);
        INTERNAL_(LPCLIENT) SearchItem (LPOLESTR);
        INTERNAL_(void)     DeleteAllItems ();
        INTERNAL            SetStdInfo (HWND, LPOLESTR, HANDLE);
        INTERNAL_(void)     SendDevInfo (HWND);
        INTERNAL_(BOOL)     IsFormatAvailable (CLIPFORMAT);
        INTERNAL            GetData (LPFORMATETC, LPSTGMEDIUM);
};




typedef struct _CLINFO : public CPrivAlloc { /*clInfo*/ // client transaction info
    HWND        hwnd;               // client window handle
    BOOL        bnative;            // doe sthis client require native
    int         format;             // dusplay format
    int         options;            // transaction advise time otipns
    BOOL        bdata;              // need wdat with advise?
    HANDLE      hdevInfo;           // device info handle
    BOOL        bnewDevInfo;        // new device info
} CLINFO;

typedef  CLINFO  *PCLINFO;



INTERNAL_(BOOL)   MakeDDEData (HANDLE, int, LPHANDLE, BOOL);
INTERNAL_(HANDLE) MakeGlobal (LPSTR);
INTERNAL          ScanItemOptions (LPOLESTR, int far *);
INTERNAL_(int)    GetStdItemIndex (ATOM);
INTERNAL_(BOOL)   IsAdviseStdItems (ATOM);
INTERNAL_(HANDLE) MakeItemData (DDEPOKE FAR *, HANDLE, CLIPFORMAT);
INTERNAL_(BOOL)   AddMessage (HWND, unsigned, WORD, LONG, int);



#define     ITEM_FIND          1      // find the item
#define     ITEM_DELETECLIENT  2      // delete the client from item clients
#define     ITEM_DELETE        3      // delete th item window itself
#define     ITEM_SAVED         4      // item saved

// host names data structcure
typedef struct _HOSTNAMES : public CPrivAlloc {
    WORD    clientNameOffset;
    WORD    documentNameOffset;
    BYTE    data[1];
} HOSTNAMES;

typedef HOSTNAMES FAR * LPHOSTNAMES;


// routines in UTILS.C
LPOLESTR CreateUnicodeFromAnsi( LPCSTR lpAnsi);
LPSTR CreateAnsiFromUnicode( LPCOLESTR lpAnsi);
INTERNAL_(HANDLE) DuplicateData (HANDLE);
INTERNAL_(LPSTR)  ScanLastBoolArg (LPSTR);
INTERNAL_(LPSTR)  ScanArg(LPSTR);
INTERNAL_(WORD)   ScanCommand(LPSTR, WORD, LPSTR FAR *, ATOM FAR *);
INTERNAL_(ATOM)   MakeDataAtom (ATOM, int);
INTERNAL_(ATOM)   DuplicateAtom (ATOM);
INTERNAL_(WORD)   StrToInt (LPOLESTR);
INTERNAL_(BOOL)   PostMessageToClientWithReply (HWND, UINT, WPARAM, LPARAM, UINT);
INTERNAL_(BOOL)   PostMessageToClient (HWND, UINT, WPARAM, LPARAM);
INTERNAL_(BOOL)   IsWindowValid (HWND);
INTERNAL_(BOOL)   IsOleCommand (ATOM, WORD);
INTERNAL_(BOOL)   UtilQueryProtocol (ATOM, LPOLESTR);
INTERNAL          SynchronousPostMessage (HWND, UINT, WPARAM, LPARAM);
INTERNAL_(BOOL)   IsAtom (ATOM);
INTERNAL_(BOOL)   IsFile (ATOM a, BOOL FAR* pfUnsavedDoc = NULL);


// routines for queueing messages and posting them
INTERNAL_(BOOL)        UnblockPostMsgs(HWND, BOOL);
INTERNAL_(BOOL)        BlockPostMsg (HWND, WORD, WORD, LONG);
INTERNAL_(BOOL)        IsBlockQueueEmpty (HWND);

// routine in GIVE2GDI.ASM
extern "C" HANDLE  FAR PASCAL  GiveToGDI (HANDLE);


// routine in item.c
INTERNAL_(HBITMAP)     DuplicateBitmap (HBITMAP);
INTERNAL_(HANDLE)      DuplicateMetaFile (HANDLE);
INTERNAL_(BOOL) AreNoClients (HANDLE hcli);
#ifdef _DEBUG
INTERNAL_(LPOLESTR) a2s (ATOM);
#endif

// routines in doc.c
INTERNAL_(void)        FreePokeData (HANDLE);
INTERNAL_(BOOL)        FreeGDIdata (HANDLE, CLIPFORMAT);
INTERNAL DdeHandleIncomingCall(HWND hwndCli, WORD wCallType);


// in ddeworkr.cpp
INTERNAL_(HANDLE) wNewHandle (LPSTR lpstr, DWORD cb);
INTERNAL wTimedGetMessage (LPMSG pmsg, HWND hwnd, WORD wFirst, WORD wLast);
INTERNAL_(ATOM) wGlobalAddAtom (LPCOLESTR sz);

//+---------------------------------------------------------------------------
//
//  Function:   TLSSetDdeServer
//
//  Synopsis:   Sets hwnd to CommonDdeServer window
//
//  Arguments:  [hwndDdeServer] --
//
//  History:    5-13-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline BOOL TLSSetDdeServer(HWND hwndDdeServer)
{
    HRESULT hr;
    COleTls tls(hr);

    if (SUCCEEDED(hr))
    {
        tls->hwndDdeServer = hwndDdeServer;
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   TLSGetDdeServer
//
//  Synopsis:   Returns a handle to the per thread DdeServer window
//
//  Returns:    hwndDdeServer for thread
//
//  History:    5-13-94   kevinro   Created
//
//  Notes:
//----------------------------------------------------------------------------
inline HWND TLSGetDdeServer()
{
    HRESULT hr;
    COleTls tls(hr);

    if (SUCCEEDED(hr))
    {
        return tls->hwndDdeServer;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\debug\assert.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       assert.cxx
//
//  Functions:  FnAssert
//              DbgDllSetSiftObject
//
//  History:     4-Jan-94   CraigWi     Created
//              16-Jun-94   t-ChriPi    Added DbgDllSetSiftObject
//
//----------------------------------------------------------------------------



#include <ole2int.h>

//+-------------------------------------------------------------------
//
//  Function:	FnAssert, public
//
//  Synopsis:	Prints a message and optionally stops the program
//
//  Effects:	Simply maps to Win4AssertEx for now.
//
//  History:	 4-Jan-94   CraigWi	Created for Win32 OLE2.
//
//--------------------------------------------------------------------

STDAPI FnAssert( LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine )
{
#if DBG == 1
    char szMessage[1024];

    if (lpstrMsg == NULL)
	lstrcpyA(szMessage, lpstrExpr);
    else
	wsprintfA(szMessage, "%s; %s", lpstrExpr, lpstrMsg);

    Win4AssertEx(lpstrFileName, iLine, szMessage);
#endif
    return NOERROR;
}

#if DBG==1

#include <osift.hxx>

ISift *g_psftSiftObject = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   DbgDllSetSiftObject
//
//  Arguments:  [psftSiftImpl] -- pointer to a new sift implementation
//
//  Synopsis:   Sets global sift object pointer to a new implementation
//
//  Returns:    S_OK if successful
//
//  History:    6-14-94   t-chripi   Created
//
//  Notes:      Passing NULL to this function will release the global
//              pointer's reference and then set it to NULL.
//
//----------------------------------------------------------------------------

STDAPI DbgDllSetSiftObject(ISift *psftSiftImpl)
{
    //  Passing a non-NULL invalid pointer will cause an error
    if ((NULL != psftSiftImpl) &&
            (!IsValidReadPtrIn(psftSiftImpl, sizeof(ISift*))))
    {
        CairoleDebugOut((DEB_ERROR,
            "DbgDllSetSiftObject was passed an invalid ptr.\n"));
        return(E_FAIL);
    }
    else
    {
        if (NULL != g_psftSiftObject)
        {
            g_psftSiftObject->Release();
        }
        g_psftSiftObject = psftSiftImpl;

        if (NULL != g_psftSiftObject)
        {
            g_psftSiftObject->AddRef();
        }
    }
    return(S_OK);
}

#endif  //  DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\dde\server\srvrmain.cxx ===
/****************************** Module Header ******************************\
* Module Name: Srvrmain.c Server Main module
*
* Purpose: Includes server intialization and termination code.
*
* Created: Oct 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*    Raor (03/../1992)    Modified for OLE 2.0
*
\***************************************************************************/

#include "ole2int.h"
#include <dde.h>
#include <ddesrvr.h>
// #include "cmacs.h"
#include "srvr.h"
#include "ddeatoms.h"
#include "ddedebug.h"
ASSERTDATA

ATOM    aStdExit = NULL;              // "StdExit"
ATOM    aStdCreate = NULL;            // "StdNewDicument"
ATOM    aStdOpen = NULL;              // "StdOpenDocument"
ATOM    aStdEdit = NULL;              // "StdOpenDocument"
ATOM    aStdCreateFromTemplate = NULL;// "StdNewFromTemplate"
ATOM    aStdClose = NULL;             // "StdCloseDocument"
ATOM    aStdShowItem = NULL;          // "StdShowItem"
ATOM    aStdDoVerbItem = NULL;        // "StddoVerbItem"
ATOM    aSysTopic = NULL;             // "System"
ATOM    aOLE = NULL;                  // "OLE"
ATOM    aProtocols = NULL;            // "Protocols"
ATOM    aTopics = NULL;               // "Topics"
ATOM    aFormats = NULL;              // "Formats"
ATOM    aStatus = NULL;               // "Status"
ATOM    aEditItems = NULL;            // "Edit items
ATOM    aTrue = NULL;                 // "True"
ATOM    aFalse = NULL;                // "False"


ATOM    aStdHostNames;
ATOM    aStdTargetDevice ;
ATOM    aStdDocDimensions;
ATOM    aStdColorScheme;
ATOM    aChange;
ATOM    aSave;
ATOM    aClose;
ATOM    aStdDocName;
ATOM    aMSDraw;

LPTSTR  gOleDdeWindowClass = NULL;         // class used to create DDE windows
BOOL    gfDdeInitialized   = FALSE;        // flag if process-wide DDE initialized

#ifdef _CHICAGO_

LPSTR ptszOleDdeWndClass = "OleDdeWndClass 0x######## ";

#else // !_CHICAGO_

const WCHAR *ptszOleDdeWndClass = L"OleDdeWndClass";

#endif // _CHICAGO_


INTERNAL CheckInitDde(BOOL fRegisteringServerObject)
{
    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
    {
        // can't get TLS
        return hr;
    }

    if (fRegisteringServerObject)
    {
        tls->cServeDdeObjects++;
    }

    if (tls->hwndDdeServer != NULL  ||
        tls->cOleInits == 0         ||
        tls->cServeDdeObjects == 0)
    {
        // A DdeServer window already exists, or Com has been initialized
        // but Ole has not, or there are currently no objects using Dde.
        // We dont create a window, we just return NOERROR.
        // This way, COM-only servers dont start serving OLE1 clients.
        return S_OK;
    }

    if (tls->dwFlags & OLETLS_DISABLE_OLE1DDE )
    {
        // DDE use is disabled.
        return CO_E_OLE1DDE_DISABLED;
    }

    {
        // ensure one thread does this at a time
        COleStaticLock lck(g_mxsSingleThreadOle);
        if (!gfDdeInitialized)
        {
            // register the DDE atoms and the Dde
            // window class in this process.
            if (!DDELibMain(NULL, 0, 0, NULL))
            {
                return E_OUTOFMEMORY;
            }

            gfDdeInitialized = TRUE;
        }
    }

    // create the common dde window for this thread
    return CreateCommonDdeWindow();
}

void CheckUninitDde(BOOL fLastUninit)
{
    DestroyCommonDdeWindow();

    if (fLastUninit)
    {
        COleStaticLock lck(g_mxsSingleThreadOle);
        if (gfDdeInitialized)
        {
            DDEWEP(WEP_FREE_DLL);
            gfDdeInitialized = FALSE;
        }
    }
}


INTERNAL_(BOOL) DDELibMain (
    HANDLE  hInst,
    WORD    wDataSeg,
    WORD    cbHeapSize,
    LPOLESTR   lpszCmdLine
)
{
    BOOLEAN fRetVal = TRUE;

    intrDebugOut((DEB_ITRACE,
                  "%p _IN DDELibMain hInst=%x\n",
                  0,
                  hInst));

    if( !aStdExit )
    {
#ifndef _CHICAGO_
        // On NT3.51, user preregisters all of these formats for us,
        // thus giving us a big speed improvement during startup (because
        // these atoms never change).
        // Chicago and Cairo do not yet have this functionality.

        aStdExit = GlobalFindAtom(OLESTR("StdExit"));

        aStdCreate = aStdExit + 1;
        Assert(aStdCreate  == GlobalFindAtom (OLESTR("StdNewDocument")));

        aStdOpen = aStdExit + 2;
        Assert(aStdOpen == GlobalFindAtom (OLESTR("StdOpenDocument")));

        aStdEdit = aStdExit + 3;
        Assert(aStdEdit == GlobalFindAtom (OLESTR("StdEditDocument")));

        aStdCreateFromTemplate = aStdExit + 4;
        Assert(aStdCreateFromTemplate ==
                GlobalFindAtom(OLESTR("StdNewfromTemplate")));

        aStdClose = aStdExit + 5;
        Assert(aStdClose == GlobalFindAtom (OLESTR("StdCloseDocument")));

        aStdShowItem = aStdExit + 6;
        Assert(aStdShowItem == GlobalFindAtom (OLESTR("StdShowItem")));

        aStdDoVerbItem = aStdExit + 7;
        Assert(aStdDoVerbItem == GlobalFindAtom (OLESTR("StdDoVerbItem")));

        aSysTopic = aStdExit + 8;
        Assert(aSysTopic == GlobalFindAtom (OLESTR("System")));

        aOLE = aStdExit + 9;
        Assert(aOLE == GlobalFindAtom (OLESTR("OLEsystem")));

        aStdDocName = aStdExit + 10;
        Assert(aStdDocName == GlobalFindAtom (OLESTR("StdDocumentName")));

        aProtocols = aStdExit + 11;
        Assert(aProtocols == GlobalFindAtom (OLESTR("Protocols")));

        aTopics = aStdExit + 12;
        Assert(aTopics == GlobalFindAtom (OLESTR("Topics")));

        aFormats = aStdExit + 13;
        Assert(aFormats == GlobalFindAtom (OLESTR("Formats")));

        aStatus = aStdExit + 14;
        Assert(aStatus == GlobalFindAtom (OLESTR("Status")));

        aEditItems = aStdExit + 15;
        Assert(aEditItems == GlobalFindAtom (OLESTR("EditEnvItems")));

        aTrue = aStdExit + 16;
        Assert(aTrue == GlobalFindAtom (OLESTR("True")));

        aFalse = aStdExit + 17;
        Assert(aFalse == GlobalFindAtom (OLESTR("False")));

        aChange = aStdExit + 18;
        Assert(aChange == GlobalFindAtom (OLESTR("Change")));

        aSave = aStdExit + 19;
        Assert(aSave == GlobalFindAtom (OLESTR("Save")));

        aClose = aStdExit + 20;
        Assert(aClose == GlobalFindAtom (OLESTR("Close")));

        aMSDraw = aStdExit + 21;
        Assert(aMSDraw == GlobalFindAtom (OLESTR("MSDraw")));

#else  // _CHICAGO_

        aStdExit        = GlobalAddAtomA("StdExit");

        aStdCreate      = GlobalAddAtomA("StdNewDocument");
        aStdOpen        = GlobalAddAtomA("StdOpenDocument");
        aStdEdit        = GlobalAddAtomA("StdEditDocument");
        aStdCreateFromTemplate  = GlobalAddAtomA("StdNewfromTemplate");

        aStdClose       = GlobalAddAtomA("StdCloseDocument");
        aStdShowItem    = GlobalAddAtomA("StdShowItem");
        aStdDoVerbItem  = GlobalAddAtomA("StdDoVerbItem");
        aSysTopic       = GlobalAddAtomA("System");
        aOLE            = GlobalAddAtomA("OLEsystem");
        aStdDocName     = GlobalAddAtomA("StdDocumentName");

        aProtocols      = GlobalAddAtomA("Protocols");
        aTopics         = GlobalAddAtomA("Topics");
        aFormats        = GlobalAddAtomA("Formats");
        aStatus         = GlobalAddAtomA("Status");
        aEditItems      = GlobalAddAtomA("EditEnvItems");

        aTrue           = GlobalAddAtomA("True");
        aFalse          = GlobalAddAtomA("False");

        aChange         = GlobalAddAtomA("Change");
        aSave           = GlobalAddAtomA("Save");
        aClose          = GlobalAddAtomA("Close");
        aMSDraw         = GlobalAddAtomA("MSDraw");
#endif // _CHICAGO_
    }

    // On Win95, we cannot use OleMainThreadWnd to receive DDE broadcasts (as USER
    // checks and will not forward DDE broadcasts to the OleMainThreadWnd class).  So
    // we need a different window class.  We do the same on NT for consistency.
    // Register DDE windows class.

    if (gOleDdeWindowClass == 0)
    {
#ifdef _CHICAGO_
        if (IsWOWThread())
        {
            // Nobody seems to be using this. Can we remove?
            wsprintfA(szOLE_CLASSA, "Ole2WndClass %08X", CoGetCurrentProcess());
            // we need to have a separate class per process for DDE (see comments below)
            wsprintfA(ptszOleDdeWndClass, "OleDdeWndClass %08x", CoGetCurrentProcess());
        }
#endif // _CHICAGO_

        WNDCLASST        xClass;

        xClass.style         = 0;
        xClass.lpfnWndProc   = DdeCommonWndProc;
        xClass.cbClsExtra    = 0;

        // DDE needs some extra space in the window
        xClass.cbWndExtra    = sizeof(LPVOID) + sizeof(ULONG) + sizeof(HANDLE);
        xClass.hInstance     = g_hinst;
        xClass.hIcon         = NULL;
        xClass.hCursor       = NULL;
        xClass.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
        xClass.lpszMenuName  = NULL;
        xClass.lpszClassName = ptszOleDdeWndClass;

        gOleDdeWindowClass = (LPTSTR) RegisterClassT( &xClass );
        if (gOleDdeWindowClass == 0)
        {
            // it is possible the dll got unloaded without us having called
            // unregister so we call it here and try again.

            UnregisterClassT(ptszOleDdeWndClass, g_hinst);
            gOleDdeWindowClass = (LPTSTR) RegisterClassT(&xClass);

            if (gOleDdeWindowClass == 0)
            {
                intrDebugOut((DEB_ERROR, "RegisterClass failed in DDELibMain\n"));
                fRetVal = FALSE;
            }
        }
    }

    return(fRetVal);
}


INTERNAL_(void) DDEWEP (
    BOOL fSystemExit
)
{
#if DBG==1
    Puts("DdeWep\r\n");

    if (fSystemExit != WEP_FREE_DLL)
    {
        AssertSz (0, "Bad parm to Wep");
        return;
    }
#endif  // DBG==1

    // free the global atoms.

    // on NT3.51, these atoms were pre-allocated for us by user, we do
    // not need to free them.
#ifdef _CHICAGO_

    if (aStdExit)
    GlobalDeleteAtom (aStdExit);
    if (aStdCreate)
    GlobalDeleteAtom (aStdCreate);
    if (aStdOpen)
    GlobalDeleteAtom (aStdOpen);
    if (aStdEdit)
    GlobalDeleteAtom (aStdEdit);
    if (aStdCreateFromTemplate)
    GlobalDeleteAtom (aStdCreateFromTemplate);
    if (aStdClose)
    GlobalDeleteAtom (aStdClose);
    if (aStdShowItem)
    GlobalDeleteAtom (aStdShowItem);
    if (aStdDoVerbItem)
    GlobalDeleteAtom (aStdDoVerbItem);
    if (aSysTopic)
    GlobalDeleteAtom (aSysTopic);
    if (aOLE)
    GlobalDeleteAtom (aOLE);
    if (aStdDocName)
    GlobalDeleteAtom (aStdDocName);

    if (aProtocols)
    GlobalDeleteAtom (aProtocols);
    if (aTopics)
    GlobalDeleteAtom (aTopics);
    if (aFormats)
    GlobalDeleteAtom (aFormats);
    if (aStatus)
    GlobalDeleteAtom (aStatus);
    if (aEditItems)
    GlobalDeleteAtom (aEditItems);

    if (aTrue)
    GlobalDeleteAtom (aTrue);
    if (aFalse)
    GlobalDeleteAtom (aFalse);

    if (aChange)
    GlobalDeleteAtom (aChange);
    if (aSave)
    GlobalDeleteAtom (aSave);
    if (aClose)
    GlobalDeleteAtom (aClose);

    if (aMSDraw)
    GlobalDeleteAtom (aMSDraw);

#endif // _CHICAGO_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\debug\valid.cxx ===
#include <ole2int.h>

#include "valid.h"

#if 1
// we cannot turn this off until we remove from the export list!
#undef IsValidPtrIn
#undef IsValidPtrOut

//////////////////////////////////////////////////////////////////
// This comment used to be marked with a blugblug; however
// we canot change this since these functions are exported from
// ole32.dll and at one point they were doc'd.   So, for 
// backward compatibility we must leave things as they are.
//
// The following two functions are MACRO's in 2.01 code
// but we need them for now because we only run with a storage
// that uses ole232.dll. When we get rid of this these may die.
//

#pragma SEG(IsValidPtrIn)
STDAPI_(BOOL) IsValidPtrIn( const void FAR* pv, UINT cb )
{												//	NULL is acceptable
	if (pv && ValidateInPointers() && IsBadReadPtr(pv,cb))
	{
//		AssertSz(FALSE, "Invalid in pointer");
		return FALSE;
	}
	return TRUE;
}



#pragma SEG(IsValidPtrOut)
STDAPI_(BOOL) IsValidPtrOut( void FAR* pv, UINT cb )
										//	NULL is not acceptable
{
	if ((cb > 0 && !pv) || (ValidateOutPointers() && IsBadWritePtr(pv,cb)))
	{
//		AssertSz(FALSE, "Invalid out pointer");
		return FALSE;
	}
	return TRUE;
}
#endif


#pragma SEG(IsValidInterface)
STDAPI_(BOOL) IsValidInterface( void FAR* pv )
{
	ULONG_PTR FAR*		pVtbl;
	BYTE      FAR*		pFcn;
	volatile BYTE	        bInstr;
	int			i;

    if (!pv)
        return FALSE;

	if (ValidateInterfaces())
	{
    	__try {
    		pVtbl = *(ULONG_PTR FAR* FAR*) pv;                 // pVtbl now points to beginning of vtable

#if DBG==1
    		for (i=0 ; i<3; ++i)                               // loop through qi,addref,rel
#else
    		i=1;                                               // in retail, just do AddRef
#endif
    		{
    			pFcn = *(BYTE FAR* FAR*) &pVtbl[i];        // pFcn now points to beginning of QI, Addref, or Release
#if DBG==1
    			if (IsBadCodePtr((FARPROC FAR)pFcn)) {
    				return FALSE;
    			}
#endif
    			bInstr = *(BYTE FAR*) pFcn;                // get 1st byte of 1st instruction
    		}

    	} 
    	__except(EXCEPTION_EXECUTE_HANDLER) 
    	{
    		return FALSE;
    	}
	}

	return TRUE;
}


// #if DBG==1
// we cannot remove IsValidIID fcn until we remove from export list!

// This function is NOT called in retail builds.
// Its former implementation always returned TRUE thus doing NO validation.
// It now validates in debug build and is not called in retail build

#if DBG==0
#ifdef IsValidIid
#undef IsValidIid
STDAPI_(BOOL) IsValidIid( REFIID iid );
#endif
#endif

STDAPI_(BOOL) IsValidIid( REFIID iid )
{
#if DBG==1
	if (ValidateIIDs() && !IsValidReadPtrIn((void*) &iid, 16)) {
		AssertSz(FALSE, "Invalid iid");
		return FALSE;
	}
#endif
	return TRUE;
}
// #endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\exts\dcomact.cxx ===
#include <ole2int.h>
#include <locks.hxx>
#include <hash.hxx>
#include <context.hxx>
#include <aprtmnt.hxx>
#include <actvator.hxx>
#include <pstable.hxx>
#include <crossctx.hxx>
#include <tlhelp32.h>
#include <wdbgexts.h>
#include <dllcache.hxx>
#include <channelb.hxx>
#include "dcomdbg.hxx"
#include "dcomctx.hxx"

void DisplayDCE(ULONG_PTR addrBCE, DWORD dwFlags);
size_t GetStrLen(ULONG_PTR addr);
void DisplayLCE(ULONG_PTR addrBCE, DWORD dwFlags);

void DisplayClassCache(ULONG_PTR addr);

void DisplayPathCache(ULONG_PTR addr);

VOID DoCC(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    LPSTR                   lpArgumentString
    )
{
    ULONG_PTR addr = 0;
    char szBuckets[]  = "ole32!CClassCache___CEBuckets";
    char szBuckets2[] = "ole32!CClassCache___DPEBuckets"; 
    dprintf("Class Cache\n");
    while (*lpArgumentString == ' ')
        lpArgumentString++;

    addr = GetExpression(szBuckets);
    if (!addr)
    {
	dprintf("Error: can't evaluate <%s>, pls check"
		" symbols or pass in argument\n", szBuckets);
	return;
    }

    dprintf("CClassCache::_CEBuckets: 0x%p\n", addr);
    DisplayClassCache(addr);


    addr = GetExpression(szBuckets2);
    if (!addr)
    {
	dprintf("Error: can't evaluate <%s>, pls check symbols\n", szBuckets2);
	return;
    }
    dprintf("CClassCache::_DPEBuckets: 0x%p\n", addr);
    DisplayPathCache(addr);
    
}

void DisplayClassCache(ULONG_PTR addr)
{
    SBcktWlkr BWClsid;
    InitBucketWalker(&BWClsid, NUM_HASH_BUCKETS, addr, offsetof(CClassCache::CClassEntry, _pNext));
    ULONG_PTR addrCE;
    CClassCache::CClassEntry *pCE = (CClassCache::CClassEntry *)_alloca(sizeof(CClassCache::CClassEntry));
    
    while (addrCE = NextNode(&BWClsid))
    {
        //addrCE = addrCE - offsetof(CClassCache::CClassEntry, _pNext);
        GetData(addrCE, pCE, sizeof(CClassCache::CClassEntry));
        dprintf("pCE:0x%x, _dwFlags:0x%x, _dwSig:%c%c%c%c, _clsid:%08.x %08.x %08.x %08.x\n",
                addrCE, pCE->_dwFlags, 
                ((char *) &(pCE->_dwSig))[0],
                ((char *) &(pCE->_dwSig))[1],
                ((char *) &(pCE->_dwSig))[2],                
                ((char *) &(pCE->_dwSig))[3],
                ((DWORD *) &(pCE->_clsid))[0],
                ((DWORD *) &(pCE->_clsid))[1],
                ((DWORD *) &(pCE->_clsid))[2],
                ((DWORD *) &(pCE->_clsid))[3]);
        SBcktWlkr BWBCE;
        ULONG_PTR addrBCE;
        InitBucketWalker(&BWBCE, 1, 
                         addrCE + offsetof(CClassCache::CClassEntry, _pBCEListFront), 
                         offsetof(CClassCache::CBaseClassEntry,_pNext));
        while (addrBCE = NextNode(&BWBCE))
        {
            ULONG_PTR addrType = addrBCE + offsetof(CClassCache::CBaseClassEntry, _dwSig);
            DWORD dwType;
            GetData(addrType, &dwType, sizeof(DWORD));
            
            if (dwType == *((DWORD *) "DLL"))
            {
                DisplayDCE(addrBCE, fONE_LINE);
            }
            else if (dwType == *((DWORD *) "LSV"))
            {
                DisplayLCE(addrBCE, fONE_LINE);
            }
            else
            {
                dprintf("error in base class entries!\n");
                break;
            }
        }
    }
    
}

void DisplayDCE(ULONG_PTR addrBCE, DWORD dwFlags)
{
    CClassCache::CDllClassEntry *pDCE = (CClassCache::CDllClassEntry *)
                                     _alloca(sizeof(CClassCache::CDllClassEntry));
    GetData(addrBCE, pDCE, sizeof(CClassCache::CDllClassEntry));
    
    ULONG_PTR addrpDllPath;
    ULONG_PTR addrDllPath;
    WCHAR DllPath[MAX_PATH+1];
    
    addrpDllPath = ((ULONG_PTR) pDCE->_pDllPathEntry) + offsetof(CClassCache::CDllPathEntry, _psPath);
    
    GetData(addrpDllPath, &addrDllPath, sizeof(ULONG_PTR));
    size_t pathLen = GetStrLen(addrDllPath);
    GetData(addrDllPath, DllPath, pathLen*sizeof(WCHAR));
    
    dprintf("\tpDCE:%#8.x, pDCE->_pDllPathEntry:%#x, dll:%ws \n", 
            addrBCE, 
            pDCE->_pDllPathEntry,
            DllPath);
    
}

void DisplayLCE(ULONG_PTR addrBCE, DWORD dwFlags)
{
    dprintf("\tpLCE:%#x\n", addrBCE);
}

void PrintPathFlags(DWORD flags)
{
    if (flags) {
	_checkflag (flags, CClassCache::CDllPathEntry::fSIXTEEN_BIT,    "fSIXTEEN_BIT");
	_checkflag (flags, CClassCache::CDllPathEntry::fWX86,           "fWX86");
	_checkflag (flags, CClassCache::CDllPathEntry::fIS_OLE32,       "fIS_OLE32");
	_checkflag (flags, CClassCache::CDllPathEntry::fDELAYED_UNLOAD, "fDELAYED_UNLOAD");
	if (flags)
	    dprintf ("Unknown Flags");
    }
}

void DisplayPathCache(ULONG_PTR addr)
{
    SBcktWlkr BWClsid;
    InitBucketWalker(&BWClsid, NUM_HASH_BUCKETS, addr, offsetof(CClassCache::CDllPathEntry, _pNext));
    ULONG_PTR addrCE;
    CClassCache::CDllPathEntry *pCE = (CClassCache::CDllPathEntry *)_alloca(sizeof(CClassCache::CDllPathEntry));
    
    while (addrCE = NextNode(&BWClsid))
    {
	ULONG_PTR addrpDllPath;
	ULONG_PTR addrDllPath;
	WCHAR     DllPath[MAX_PATH + 1];

        //addrCE = addrCE - offsetof(CClassCache::CClassEntry, _pNext);
        GetData(addrCE, pCE, sizeof(CClassCache::CDllPathEntry));
        dprintf("pDP:0x%x  __dwSig:%c%c%c%c\n", addrCE, 
                ((char *) &(pCE->_dwSig))[0],
                ((char *) &(pCE->_dwSig))[1],
                ((char *) &(pCE->_dwSig))[2],                
                ((char *) &(pCE->_dwSig))[3]);
	dprintf("          flags: ");
	PrintPathFlags (pCE->_dwFlags);
	dprintf (" (%x)\n", pCE->_dwFlags);

	dprintf("          _cUsing: %d  _hDll32: %p   _dwExpireTime: %d\n",
		pCE->_cUsing, pCE->_hDll32, pCE->_dwExpireTime);

	//This is a hack, but I can't get the wide char vers to work
	//and I have other things to do besides debug debuggers.
	size_t pathLen = GetStrLen((DWORD_PTR)(pCE->_psPath));
	GetData((DWORD_PTR)(pCE->_psPath), DllPath, pathLen*sizeof(WCHAR));
	dprintf("          _psPath: %S\n", DllPath);
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\exts\dcomdbg.cxx ===
//+----------------------------------------------------------------------------
//
//  File:       dcomdbg.cxx
//
//  Contents:   Debug extension.
//
//  History:    9-Nov-98   Johnstra      Created
//
//-----------------------------------------------------------------------------

#include <ole2int.h>
#include <locks.hxx>
#include <hash.hxx>
#include <context.hxx>
#include <aprtmnt.hxx>
#include <actvator.hxx>
#include <pstable.hxx>
#include <crossctx.hxx>
#include <tlhelp32.h>
#include <wdbgexts.h>

#include "dcomdbg.hxx"


ULONG                 gPIDDebuggee;
EXT_API_VERSION       ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };


VOID WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT                 MajorVersion,
    USHORT                 MinorVersion
    )
{
}


LPEXT_API_VERSION ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\exts\dcomlog.cxx ===
/*
 * Dump the log for ole32
 */
#include <ole2int.h>
#include <hash.hxx>
#include "dcomdbg.hxx"
#include <log.hxx>

void PrintEntry (DebugEvent ev)
{
    int           i;
    unsigned char sym[64];
    ULONG_PTR     addr;

    if (ev.Subject == SU_NOTHING)
        return; //Empty entry, ignore.

    //No interpretation for now....
    dprintf ("%d: thread %d s: %c (%p) v: %c %p (0x%08x)\n", ev.Time, 
             ev.ThreadID, ev.Subject, ev.SubjectPtr, ev.Verb, ev.ObjectPtr,
             ev.UserData);
    if (ev.Stack[0])
    {
        for (i=0; ev.Stack[i] && i < STACKTRACE_DEPTH; i++)
        {
            GetSymbol (ev.Stack[i], sym, &addr);
            dprintf ("       %s + %p\n", sym, addr);
        }
    }
}

void ScanLog (int Argc, char **Argv)
{
    try {
        int i;
        DWORD start, end;
        DEBUGVAR(gOleLogLen,  DWORD,     "ole32!gOleLogLen");
        DEBUGVAR(gOleLogPtr,  DWORD_PTR, "ole32!gOleLog");
        DEBUGVAR(gOleLogNext, long,      "ole32!gOleLogNext");

        if (gOleLogPtr == NULL) 
        {
            dprintf ("Log is empty.\n");
            return;
        }
        
        DEBUGARRAY(gOleLog, DebugEvent, gOleLogLen, "ole32!gOleLog");

        for (i=gOleLogNext; i < gOleLogNext + gOleLogLen; i++)
        {
            PrintEntry (gOleLog[i % gOleLogLen]);
        }

        free(gOleLog);
    } catch (char *msg) {
        dprintf ("ERROR: %s\n", msg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\exts\dcomtls.cxx ===
#include <ole2int.h>
#include <locks.hxx>
#include <hash.hxx>
#include <context.hxx>
#include <aprtmnt.hxx>
#include <actvator.hxx>
#include <pstable.hxx>
#include <crossctx.hxx>
#include <tlhelp32.h>
#include <wdbgexts.h>

#include "dcomdbg.hxx"


char *AptTypes[] = {
    "NONE",
    "STA",
    "MTA",
    "Implicit MTA",
    "NA",
    "DISPATCH"
};


VOID PrintThreadFlags(
    ULONG flags
    )
{
    dprintf("Flags            : %08X\n", flags);
    if (flags) 
    {
        if (flags & OLETLS_LOCALTID)
            dprintf("   OLETLS_LOCALTID\n");
        if (flags & OLETLS_UUIDINITIALIZED)
            dprintf("   OLETLS_UUIDINITIALIZED\n");
        if (flags & OLETLS_CHANNELTHREADINITIALZED)
            dprintf("   OLETLS_CHANNELTHREADINITIALZED\n");
        if (flags & OLETLS_WOWTHREAD)
            dprintf("   OLETLS_WOWTHREAD\n");
        if (flags & OLETLS_THREADUNINITIALIZING)
            dprintf("   OLETLS_THREADUNINITIALIZING\n");
        if (flags & OLETLS_DISABLE_OLE1DDE)
            dprintf("   OLETLS_DISABLE_OLE1DDE\n");
        if (flags & OLETLS_APARTMENTTHREADED)
            dprintf("   OLETLS_APARTMENTTHREADED\n");
        if (flags & OLETLS_MULTITHREADED)
            dprintf("   OLETLS_MULTITHREADED\n");
        if (flags & OLETLS_IMPERSONATING)
            dprintf("   OLETLS_IMPERSONATING\n");
        if (flags & OLETLS_DISABLE_EVENTLOGGER)
            dprintf("   OLETLS_DISABLE_EVENTLOGGER\n");
        if (flags & OLETLS_INNEUTRALAPT)
            dprintf("   OLETLS_INNEUTRALAPT\n");
        if (flags & OLETLS_DISPATCHTHREAD)
            dprintf("   OLETLS_DISPATCHTHREAD\n");
        if (flags & OLETLS_HOSTTHREAD)
            dprintf("   OLETLS_HOSTTHREAD\n");
        if (flags & OLETLS_ALLOWCOINIT)
            dprintf("   OLETLS_ALLOWCOINIT\n");
        if (flags & OLETLS_PENDINGUNINIT)
            dprintf("   OLETLS_PENDINGUNINIT\n");
        if (flags & OLETLS_FIRSTMTAINIT)
            dprintf("   OLETLS_FIRSTMTAINIT\n");
        if (flags & OLETLS_FIRSTNTAINIT)
            dprintf("   OLETLS_FIRSTNTAINIT\n");
    }
}


VOID PrintThread(
    SOleTlsData *pTls
    )
{
    PrintThreadFlags(pTls->dwFlags);
    dprintf("Apartment Id     : %d\n", pTls->dwApartmentID);
    dprintf("COM Inits        : %d\n", pTls->cComInits);
    dprintf("OLE Inits        : %d\n", pTls->cOleInits);
    dprintf("Calls            : %d\n", pTls->cCalls);
    dprintf("Call Info        : %p\n", pTls->pCallInfo);
//    dprintf("OXID Entry       : %p\n", pTls->pOXIDEntry);
//    dprintf("Remote Unk       : %p\n", pTls->pRemoteUnk);
    dprintf("Obj Server       : %p\n", pTls->pObjServer);
    dprintf("Caller TID       : %d\n", pTls->dwTIDCaller);
    dprintf("Current Ctx      : %p\n", pTls->pCurrentCtx);
    dprintf("Empty Ctx        : %p\n", pTls->pEmptyCtx);
    dprintf("Native Ctx       : %p\n", pTls->pNativeCtx);
    dprintf("Native Apt       : %p\n", pTls->pNativeApt);
    dprintf("Call Ctx         : %p\n", pTls->pCallContext);
    dprintf("Ctx Call Obj     : %p\n", pTls->pCtxCall);
    dprintf("Policy Set       : %p\n", pTls->pPS);
    dprintf("First Pending    : %p\n", pTls->pvPendingCallsFront);
    dprintf("Call Ctrl        : %p\n", pTls->pCallCtrl);
    dprintf("Call State       : %p\n", pTls->pTopSCS);
    dprintf("Msg Filter       : %p\n", pTls->pMsgFilter);
    dprintf("Svr HWND         : %p\n", pTls->hwndSTA);
    dprintf("Logical TID      : "); PrintGUID(&pTls->LogicalThreadId); dprintf("\n");
    dprintf("Cancel thrd hndl : %p\n", pTls->hThread);
    dprintf("Error IUnknown   : %p\n", pTls->punkError);
    dprintf("Max error size   : %x\n", pTls->cbErrorData);
}


VOID DisplaySpecificThread(
    DcomextThreadInfo *pFirst,
    ULONG              thread
    )
{
    DcomextThreadInfo *pThread = pFirst;
    while (pThread && pThread->index != thread)
        pThread = pThread->pNext;
        
    if (pThread)
    {
        if (pThread->pTls)
        {
            PrintThread(pThread->pTls);
        }
        else
        {
            dprintf("COM TLS not initialized for thread %d\n", thread);
        }
    }
}


VOID DisplayAllThreads(
    DcomextThreadInfo *pFirst
    )
{
    ULONG_PTR ComTlsBase;
    DcomextThreadInfo *pThread = pFirst;
    
    while (pThread)
    {
        dprintf("  %d  %x - ", pThread->index, 
		pThread->tbi.ClientId.UniqueThread);
        dprintf("%s", AptTypes[pThread->AptType]);
        if (pThread->pTls) {
	    if (pThread->pTls->dwFlags & OLETLS_INNEUTRALAPT) {
		dprintf(" (in neutral apt)");
	    }
	    if (pThread->pTls->cCalls > 0) {
		dprintf("\t\t\t*** in %s call***\n",
			(pThread->pTls->pCallInfo==NULL) ? 
			"outgoing" : "incoming");
	    }
	}   

	dprintf("\n");
        
        pThread = pThread->pNext;
    }
}


VOID DoThread(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    LPSTR                   lpArgumentString
    )
{
    ULONG ThreadNum = (ULONG_PTR)-1;
    
    while (*lpArgumentString == ' ')
        lpArgumentString++;
        
    if (*lpArgumentString == '0')
        ThreadNum = 0;
    else if (*lpArgumentString != '\0')
    {
        ThreadNum = strtoul(lpArgumentString, NULL, 10);
        if (!ThreadNum)
        {
            dprintf("Error: can't evaluate %s\n", lpArgumentString);
            return;
        }
    }

    ULONG cThreads;
    DcomextThreadInfo *pFirst = NULL;
    if (GetDebuggeeThreads(hCurrentThread, &pFirst, &cThreads))
    {
        if (ThreadNum == (ULONG_PTR)-1)
            DisplayAllThreads(pFirst);
        else
            DisplaySpecificThread(pFirst, ThreadNum);
        
        FreeDebuggeeThreads(pFirst);
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\exts\dcomapt.cxx ===
//+----------------------------------------------------------------------------
//
//  File:       dcomapt.cxx
//
//  Contents:   Apartment-related debugging functions
//
//  History:    2-Jul-99   Johndoty      Created
//
//-----------------------------------------------------------------------------
#include <ole2int.h>

//I LOVE this trick
#define protected  public
#define private    public

#include <hash.hxx>
#include <aprtmnt.hxx>
#include <wdbgexts.h>
#include "dcomdbg.hxx"

const char *_TransAptKind(APTKIND ak)
{
    switch (ak) {
    case APTKIND_NEUTRALTHREADED:   return "NA";
    case APTKIND_MULTITHREADED:     return "MTA";
    case APTKIND_APARTMENTTHREADED: return "STA";
    }

    return "UNK";
}

VOID DisplaySpecificApt(
    ULONG_PTR addr
    )
{
    CComApartment *apt = (CComApartment *)alloca(sizeof(CComApartment));
    int i;
    
    /* Grab the apartment information */
    GetData (addr, apt, sizeof(CComApartment));
    
    /* And print it out... */
    dprintf ("\n"
	     "CComApartment (0x%08X)\n", apt);
    dprintf ("Reference count     :  %d\n", apt->_cRefs);
    dprintf ("State               :  %d\n", apt->_dwState);
    dprintf ("Apartment Kind      :  %s (%d)\n", _TransAptKind(apt->_AptKind),
	     apt->_AptKind);
    dprintf ("Apartment Id        :  %d\n", apt->_AptId);
    dprintf ("OXID Entry          :  %p\n", apt->_pOXIDEntry);
    // This probably shouldn't be here 
    // DisplayOXIDEntry (apt._pOXIDEntry);
    dprintf ("RemUnknown          :  %p\n", apt->_pRemUnk);
    dprintf ("OID Waiters         :  %d\n", apt->_cWaiters);
    dprintf ("Waiter evt. handle  :  %p\n", apt->_hEventOID);
    dprintf ("Pre-registered OIDs :  %d\n", apt->_cPreRegOidsAvail);
    
    if (apt->_cPreRegOidsAvail > 0) {
	dprintf ("  (");
	for (i=0; i < apt->_cPreRegOidsAvail; i++) {
	    dprintf ("%d", apt->_arPreRegOids[i]);
	    if (i < apt->_cPreRegOidsAvail-1) {
		dprintf (", ");
	    }
	}
	dprintf (")\n");
    }

    dprintf ("Oids to return      :  %d\n", apt->_cOidsReturn);

    if (apt->_cOidsReturn > 0) {
	dprintf ("  (");
	for (i=0; i < apt->_cOidsReturn; i++) {
	    dprintf ("%d", apt->_arOidsReturn[i]);
	    if (i < apt->_cOidsReturn-1) {
		dprintf (", ");
	    }
	}
	dprintf (")\n");
    }
}


VOID DisplayAllApts(
    HANDLE hCurrentThread
    )
{
    ULONG cThreads;
    DcomextThreadInfo *pFirst;
    ULONG_PTR pMTA = NULL;
    
    if (GetDebuggeeThreads(hCurrentThread, &pFirst, &cThreads))
    {
        DcomextThreadInfo *pThread = pFirst;
        while (pThread)
        {
            if (pThread->pTls)
            {
                if (pThread->pTls->dwFlags & OLETLS_APARTMENTTHREADED || 
                    pThread->pTls->dwFlags & OLETLS_MULTITHREADED)
                {
                    if (pThread->pTls->dwFlags & OLETLS_APARTMENTTHREADED)
                    {
                        dprintf(" STA %d %p\n", pThread->index, pThread->pTls->pNativeApt);
                    }
                    else
                    {
                         if (!pMTA || pMTA != (ULONG_PTR)pThread->pTls->pNativeApt)
                         {
                            dprintf(" MTA %d %p\n", pThread->index, pThread->pTls->pNativeApt);
                            pMTA = (ULONG_PTR)pThread->pTls->pNativeApt;
                         }
                    }
                }
            }
            
            pThread = pThread->pNext;
        }
        
        FreeDebuggeeThreads(pFirst);
    }
}


VOID DoApt(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    LPSTR                   lpArgumentString
    )
{
    ULONG_PTR addr = (ULONG_PTR)-1;

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if (*lpArgumentString != '\0')
    {
        addr = GetExpression(lpArgumentString);
        if (!addr)
        {
            dprintf("Error: can't evaluate %s\n", lpArgumentString);
            return;
        }
    }

    if ((ULONG_PTR)-1 == addr)
        DisplayAllApts(hCurrentThread);
    else
        DisplaySpecificApt(addr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\exts\dcomctx.cxx ===
#include <ole2int.h>

//This is SUCH a cool trick.
#define private   public
#define protected public

#include <locks.hxx>
#include <hash.hxx>
#include <context.hxx>
#include <aprtmnt.hxx>
#include <actvator.hxx>
#include <pstable.hxx>
#include <crossctx.hxx>
#include <tlhelp32.h>
#include <wdbgexts.h>
#include <dllcache.hxx>
#include <channelb.hxx>
#include "dcomdbg.hxx"


VOID PrintContextFlags(
    ULONG flags
    )
{
    dprintf("Flags          : %08X", flags);    
    if (flags) {
        dprintf(" (");
        _checkflag(flags, CONTEXTFLAGS_FROZEN, 
		   "CONTEXTFLAGS_FROZEN");
	_checkflag(flags, CONTEXTFLAGS_ALLOWUNAUTH, 
		   "CONTEXTFLAGS_ALLOWUNAUTH");
	_checkflag(flags, CONTEXTFLAGS_ENVOYCONTEXT, 
		   "CONTEXTFLAGS_ENVOYCONTEXT");
	_checkflag(flags, CONTEXTFLAGS_DEFAULTCONTEXT,
		   "CONTEXTFLAGS_DEFAULTCONTEXT");
	_checkflag(flags, CONTEXTFLAGS_STATICCONTEXT,
		   "CONTEXTFLAGS_STATICCONTEXT");
	_checkflag(flags, CONTEXTFLAGS_INPROPTABLE,
		   "CONTEXTFLAGS_INPROPTABLE");
	_checkflag(flags, CONTEXTFLAGS_INDESTRUCTOR,
		   "CONTEXTFLAGS_INPROPTABLE");
        if (flags) {
            dprintf("UNKNOWN FLAGS SET");
        }        
        dprintf(")");
    }
    dprintf("\n");
}


VOID PrintContextPropFlags(
    ULONG flags
    )
{
    dprintf("   Flags    : %0X", flags);
    if (flags) {
        dprintf(" (");        
        if (flags & CPFLAG_PROPAGATE) {
            dprintf("CPFLAG_PROPAGATE");
            flags &= ~CPFLAG_PROPAGATE;
            if (flags)
                dprintf(" | ");
        }
        if (flags & CPFLAG_EXPOSE) {
            dprintf("CPFLAG_EXPOSE");
            flags &= ~CPFLAG_EXPOSE;
            if (flags)
                dprintf(" | ");
        }
        if (flags & CPFLAG_ENVOY) {
            dprintf("CPFLAG_ENVOY");
            flags &= ~CPFLAG_ENVOY;
            if (flags)
                dprintf(" | ");
        }
        if (flags & CPFLAG_MONITORSTUB) {
            dprintf("CPFLAG_MONITORSTUB");
            flags &= ~CPFLAG_MONITORSTUB;
            if (flags)
                dprintf(" | ");
        }
        if (flags & CPFLAG_MONITORPROXY) {
            dprintf("CPFLAG_MONITORPROXY");
            flags &= ~CPFLAG_MONITORPROXY;
            if (flags)
                dprintf(" | ");
        }
        if (flags) {
            dprintf("UNKNOWN FLAGS SET");
        }        
        dprintf(")");
    }
    dprintf("\n");
}


VOID ObjectContext(
    CObjectContext *pContext
    )
{
    dprintf("Context ID     : ");
    PrintGUID(&pContext->_contextId);
    dprintf("\n");
    PrintContextFlags(pContext->_dwFlags);    
    dprintf("Ref Count         : %d\n", pContext->_cRefs);
    dprintf("User Ref Count    : %d\n", pContext->_cUserRefs);
    dprintf("Internal Ref Count: %d\n", pContext->_cInternalRefs);
    dprintf("MarshalSizeMax    : %d\n", pContext->_MarshalSizeMax);
    dprintf("Hash of Ctx. ID   : %d\n", pContext->_dwHashOfId);
    dprintf("pifData           : %p\n", pContext->_pifData);
    dprintf("Apartment         : %p\n", pContext->_pApartment);
    dprintf("Marshaling Prop   : %p\n", pContext->_pMarshalProp);
    dprintf("Releasing threads : %d\n", pContext->_cReleaseThreads);
    dprintf("MTS Context       : %p\n", pContext->_pMtsContext);
}


VOID PrintContextProperty(
    ContextProperty *pProperty
    )
{
    dprintf("   Policy ID: ");
    PrintGUID(&pProperty->policyId);
    dprintf("\n");
    PrintContextPropFlags(pProperty->flags);
    dprintf("   pUnk     : %p\n", pProperty->pUnk);
}

VOID EnumerateContexts (void)
{
    char *szTableName = "ole32!CCtxTable__s_CtxUUIDBuckets";
    ULONG_PTR ulBucketAddr;
    ULONG_PTR currNode;
    SBcktWlkr sBW;
    ULONG count = 0;
    CObjectContext *soc = (CObjectContext *)alloca(sizeof(CObjectContext)); 


    //Step 1: Find the address of the global UUID hash table.
    ulBucketAddr = GetExpression (szTableName);

    //Step 2: For each bucket...
    //     2.1    Begin walking.  Set up the offset so that it puts the
    //            hash chain structure at the right place
    //     2.2    For each node in the chain spit out exec. summary of the
    //            context.
    InitBucketWalker (&sBW, NUM_HASH_BUCKETS, ulBucketAddr, 
		      offsetof(CObjectContext, _uuidChain));
    while (currNode = NextNode (&sBW)) {
	
	GetData (currNode, soc, sizeof(CObjectContext));
	dprintf ("%d  0x%08x  %d refs  %d properties\n",
		 count, currNode, soc->_cRefs, soc->_properties._Count);
	count++;
    }
    dprintf ("%d context%s\n", count, (count == 1) ? "" : "s");
}


VOID DoContext(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    LPSTR                   lpArgumentString
    )
{
    ULONG_PTR addr = GetExpression(lpArgumentString);
    
/*
  if (!addr)
  {
  dprintf("Error: can't evaluate %s\n", lpArgumentString);
  return;
  }
*/  
    if (addr == 0)
    {
        //dprintf("Coming soon - all contexts!\n");
        EnumerateContexts ();
    }
    else
    {
        CObjectContext  *Context;
	SCtxListIndex   *pIndex;
        ContextProperty *pProps;
	int              i;

	/* Yeah, yeah, no constructor.  Tough.  We read data right in anyway. */
	Context = (CObjectContext *)alloca(sizeof(CObjectContext));

        dprintf("\nCObjectContext (0x%08X)\n", addr);
        /* Display the actual context */
	GetData(addr, Context, sizeof(CObjectContext));
        ObjectContext(Context);
        
	/* Display the properties */
        dprintf("\n%d Properties\n", Context->_properties._Count);
	if (Context->_properties._Count != 0) {
	    /* Grab the Properties and Indices */
	    pIndex = new SCtxListIndex[Context->_properties._Count];
	    GetData((ULONG_PTR)Context->_properties._pIndex, pIndex, 
		    sizeof(SCtxListIndex) * Context->_properties._Count);
	    pProps = new ContextProperty[Context->_properties._Count];
	    GetData((ULONG_PTR)Context->_properties._pProps, pProps, 
		    sizeof(ContextProperty) * Context->_properties._Count);	
	    
	    /* Run through the array */
	    i = Context->_properties._iFirst;
	    do
	    {
		PrintContextProperty(&(pProps[pIndex[i].idx]));
		i = pIndex[i].next;
	    } while (i != Context->_properties._iFirst);
	}
    }
}


ULONG_PTR DisplayPolicySet(ULONG_PTR addr, DWORD dwFlags);
VOID DisplayPSTable(ULONG_PTR addr);
VOID DoPSTable(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    LPSTR                   lpArgumentString
    )
{
    ULONG_PTR addr = 0;
    char szBuckets[] = "ole32!CPSTable__s_PSBuckets";
    dprintf("Policy Set Table\n");
    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if (*lpArgumentString != '\0')
    {
        addr = GetExpression(lpArgumentString);
        if (!addr)
        {
            dprintf("Error: can't evaluate %s\n", lpArgumentString);
            return;
        }
    }
    else
    {
        addr = GetExpression(szBuckets);
        if (!addr)
        {
           dprintf("Error: can't evaluate <%s>, pls check"
                   " symbols or pass in argument\n", szBuckets);
           return;
        }
    }
    dprintf("CPSTable::s_PSBuckets 0x%x\n", addr);
    DisplayPSTable(addr);
    
}

VOID DisplayPSTable(ULONG_PTR addr)
{
    SHashChain *pBuckets = (SHashChain *) _alloca(sizeof(SHashChain) * NUM_HASH_BUCKETS);
    GetData(addr, pBuckets, (sizeof(SHashChain) * NUM_HASH_BUCKETS));
    int i;
    for (i=0; i<NUM_HASH_BUCKETS; i++)
    {
        ULONG_PTR pCurrentBucket = (ULONG_PTR) (((SHashChain *)addr) + i);
        
        ULONG_PTR pNext = (ULONG_PTR) pBuckets[i].pNext;
        while (pNext != pCurrentBucket)
        {
            // backup for vtbl ptr
            pNext = (ULONG_PTR) (((BYTE *) pNext) - sizeof(PVOID));
            pNext = DisplayPolicySet(pNext, fONE_LINE);
        }
    }
    
}

ULONG_PTR DisplayPolicySet(ULONG_PTR addr, DWORD dwFlags)
{
    CPolicySet *pPS = (CPolicySet *) _alloca(sizeof(CPolicySet));
    GetData(addr, pPS, sizeof(CPolicySet));
    switch (dwFlags)
    {
    case fONE_LINE:
        dprintf("CPolicySet:0x%x, _dwFlags:0x%x, _cPolicies:%d, _pClientCtx:0x%x, _pServerCtx:0x%x\n", 
                addr, pPS->_dwFlags, pPS->_cPolicies, pPS->_pClientCtx, pPS->_pServerCtx);
        break;
    }
    return (ULONG_PTR) pPS->_chain.pNext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\exts\dcomrem.cxx ===
#include <ole2int.h>

#define private   public
#define protected public

#include <locks.hxx>
#include <hash.hxx>
#include <context.hxx>
#include <aprtmnt.hxx>
#include <actvator.hxx>
#include <pstable.hxx>
#include <crossctx.hxx>
#include <tlhelp32.h>
#include <wdbgexts.h>
#include <dllcache.hxx>
#include <channelb.hxx>
#include <call.hxx>
#include <riftbl.hxx>
#include "dcomdbg.hxx"
#include "dcomctx.hxx"


void DisplayCallee(ULONG_PTR addr);

VOID DoGetCallee(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    LPSTR                   lpArgumentString
    )
{
    ULONG_PTR addr;
    while (*lpArgumentString == ' ')
        lpArgumentString++;
        
    if (*lpArgumentString != '\0')
    {
        addr = GetExpression(lpArgumentString);
        if (!addr)
        {
            dprintf("Error: can't evaluate %s\n", lpArgumentString);
            return;
        }
    }
    else
    {
        dprintf("usage:\n\t!getcallee <addr chnl>\n");
        return;
    }
    DisplayCallee(addr);
}

void DisplayCallee(ULONG_PTR addr)
{
    CRpcChannelBuffer *pChnl = (CRpcChannelBuffer*) _alloca(sizeof(CRpcChannelBuffer));
    GetData(addr, pChnl, sizeof(CRpcChannelBuffer));
    DisplayOXIDEntry((ULONG_PTR) pChnl->_pOXIDEntry);
}

void DisplayOXIDEntry(ULONG_PTR addr)
{
    OXIDEntry *pOXIDEntry = (OXIDEntry*) _alloca(sizeof(OXIDEntry));
    GetData(addr, pOXIDEntry, sizeof(OXIDEntry));
    dprintf("OXIDEntry: 0x%x\n", addr);
    dprintf("_dwPid ( process id of server): %d\n",pOXIDEntry->_dwPid);
    dprintf("_dwTid ( thread id of server): %d\n",pOXIDEntry->_dwTid);
    dprintf("_moxid ( object exporter identifier + machine id): ");
    PrintGUID(&(pOXIDEntry->_moxid)); dprintf ("\n");
    dprintf("_ipidRundown ( IPID of IRundown and Remote Unknown): ");
    PrintGUID(&(pOXIDEntry->_ipidRundown)); dprintf ("\n");
    dprintf("_dwFlags ( state flags): %0x%x\n",pOXIDEntry->_dwFlags);
    dprintf("_hServerSTA ( HWND of server): %0x%x\n",pOXIDEntry->_hServerSTA);
    dprintf("_pRpc ( Binding handle info for server): %0x%x\n",pOXIDEntry->_pRpc);
    dprintf("_pAuthId ( must be held till rpc handle is freed): %0x%x\n",pOXIDEntry->_pAuthId);
    dprintf("_pBinding ( protseq and security strings.): %0x%x\n",pOXIDEntry->_pBinding);
    dprintf("_dwAuthnHint ( authentication level hint.): %0x%x\n",pOXIDEntry->_dwAuthnHint);
    dprintf("_dwAuthnSvc ( index of default authentication service.): %0x%x\n",pOXIDEntry->_dwAuthnSvc);
    dprintf("_pMIDEntry ( MIDEntry for machine where server lives): %0x%x\n",pOXIDEntry->_pMIDEntry);
    dprintf("_pRUSTA ( proxy for Remote Unknown): %0x%x\n",pOXIDEntry->_pRUSTA);
    dprintf("_cRefs ( count of IPIDs using this OXIDEntry): %d\n",pOXIDEntry->_cRefs);
    dprintf("_hComplete ( set when last outstanding call completes): %0x%x\n",pOXIDEntry->_hComplete);
    dprintf("_cCalls ( number of calls dispatched): %d\n",pOXIDEntry->_cCalls);
    dprintf("_cResolverRef (References to resolver): %d\n",pOXIDEntry->_cResolverRef);
    dprintf("_dwExpiredTime (Time at which entry expired): %d\n",pOXIDEntry->_dwExpiredTime);
    dprintf("_version ( COM version of the machine): %0x%x\n",pOXIDEntry->_version);
}


void PrintEChannelState (DWORD flags)
{
    dprintf ("_iFlags:               ");
    if (flags) {
       
	CHECKFLAG (flags, client_cs);
	CHECKFLAG (flags, proxy_cs);
	CHECKFLAG (flags, server_cs);
        CHECKFLAG (flags, freethreaded_cs);
	CHECKFLAG (flags, process_local_cs);
	CHECKFLAG (flags, locked_cs);
	CHECKFLAG (flags, neutral_cs);
	CHECKFLAG (flags, fake_async_cs);
	CHECKFLAG (flags, app_security_cs);
	CHECKFLAG (flags, thread_local_cs);
        CHECKFLAG (flags, CALLFLAG_CALLDISPATCHED);
        CHECKFLAG (flags, CALLFLAG_WOWMSGARRIVED);
        CHECKFLAG (flags, CALLFLAG_CALLFINISHED);
        CHECKFLAG (flags, CALLFLAG_CANCELISSUED);
        CHECKFLAG (flags, CALLFLAG_CLIENTNOTWAITING);
        CHECKFLAG (flags, CALLFLAG_INDESTRUCTOR);
        CHECKFLAG (flags, CALLFLAG_STATHREAD);
        CHECKFLAG (flags, CALLFLAG_WOWTHREAD);
        CHECKFLAG (flags, CALLFLAG_CALLSENT);
        CHECKFLAG (flags, CALLFLAG_CLIENTASYNC);
        CHECKFLAG (flags, CALLFLAG_SERVERASYNC);
        CHECKFLAG (flags, CALLFLAG_SIGNALED);
        CHECKFLAG (flags, CALLFLAG_ONCALLSTACK);
        CHECKFLAG (flags, CALLFLAG_CANCELENABLED);

	if (flags) {
	    dprintf ("unknown flags");
	}
    }
    dprintf ("\n");
}

void PrintRPCOLEMESSAGE (RPCOLEMESSAGE rom)
{
    dprintf ("reserved1:           %p\n", rom.reserved1);
    dprintf ("dataRepresentation:  %d\n", rom.dataRepresentation);
    dprintf ("Buffer:              %p\n", rom.Buffer);
    dprintf ("cbBuffer:            %d\n", rom.cbBuffer);
    dprintf ("iMethod:             %d\n", rom.iMethod);
    dprintf ("rpcFlags:            %d\n", rom.rpcFlags);
}

void PrintSChannelHookCallInfo (SChannelHookCallInfo schci)
{
    dprintf ("iid:                 "); PrintGUID (&(schci.iid)); dprintf("\n");
    dprintf ("cbSize:              %d\n", schci.cbSize);
    dprintf ("uCausality:          "); PrintGUID (&(schci.uCausality)); dprintf("\n");
    dprintf ("dwServerPID:         %d\n", schci.dwServerPid);
    dprintf ("iMethod:             %d\n", schci.iMethod);
    dprintf ("pObject:             %p\n", schci.pObject);
}

VOID DoMessageCall(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    LPSTR                   pArgString
    )
{
    DWORD        addr = 0;
    CMessageCall *cmc = (CMessageCall *)alloca(sizeof(CMessageCall));

    APIPREAMBLE(mc);

    if ((Argc == 0) || ((addr = GetExpression(Argv[0])) == 0)) {
	dprintf ("Unable to evaluate %s\n", pArgString);
    }

    bStatus = GetData (addr, (void *)cmc, sizeof(CMessageCall));
    if (bStatus) {
	dprintf ("\n"
		 "CMessageCall (0x%08x)\n", addr);
	dprintf ("Call Category:         ");
	switch (cmc->_callcat) {
	case CALLCAT_NOCALL:             dprintf("CALLCAT_NOCALL"); break;
	case CALLCAT_SYNCHRONOUS:        dprintf("CALLCAT_SYNCHRONOUS"); break;
	case CALLCAT_ASYNC:              dprintf("CALLCAT_ASYNC"); break;
	case CALLCAT_INPUTSYNC:          dprintf("CALLCAT_INPUTSYNC"); break;
	case CALLCAT_INTERNALSYNC:       dprintf("CALLCAT_INTERNALSYNC"); break;
	case CALLCAT_INTERNALINPUTSYNC:  dprintf("CALLCAT_INTERNALINPUTSYNC"); break;
	case CALLCAT_SCMCALL:            dprintf("CALLCAT_SCMCALL"); break;
	}
	dprintf (" (%d)\n", cmc->_callcat);

	PrintEChannelState (cmc->_iFlags);
	dprintf ("_hResult:              0x%08x\n", cmc->_hResult);
	dprintf ("Caller Wait Event:     %p\n", cmc->_hEvent);
	dprintf ("Caller Apt. hWnd:      %p\n", cmc->_hWndCaller);
	dprintf ("_ipid:                 ");  PrintGUID (&(cmc->_ipid));  dprintf ("\n");
	dprintf ("_server_fault:         %d\n", cmc->_server_fault);
	dprintf ("\n"
		 "_destObj:\n");
	dprintf ("    COM Version     %d.%d\n", 
		 cmc->_destObj._comversion.MajorVersion,
		 cmc->_destObj._comversion.MinorVersion);
	dprintf ("    Dest. Ctx.         %d\n", cmc->_destObj._dwDestCtx);
	dprintf ("\n"
		 "_pHeader:              %p\n", cmc->_pHeader);
	dprintf ("Channel Handle:        %p\n", cmc->_pHandle);
	dprintf ("Call Handle:           %p\n", cmc->_hRpc);
	dprintf ("Context IUnknown:      %p\n", cmc->_pContext);
	
        //Is all of this necessary?
	dprintf ("\n"
		 "RPC OLE Message:\n");
	PrintRPCOLEMESSAGE (cmc->message);
	dprintf ("\n"
		 "Hook:\n");
	PrintSChannelHookCallInfo (cmc->hook);
	dprintf ("\n");

	dprintf ("Seconds before cancel: %d\n", cmc->m_ulCancelTimeout);
	dprintf ("Tick Count at call   : %d\n", cmc->m_dwStartCount);
	dprintf ("Client context call  : %p\n", cmc->m_pClientCtxCall);
	dprintf ("Server context call  : %p\n", cmc->m_pServerCtxCall);
    }
}

void PrintHandleState (DWORD state)
{
    if (state) {
	_checkflag (state, allow_hs,            "allow_hs");
	_checkflag (state, deny_hs,             "deny_hs");
	_checkflag (state, static_cloaking_hs,  "static_cloaking_hs");
	_checkflag (state, dynamic_cloaking_hs, "dynamic_cloaking_hs");
	_checkflag (state, any_cloaking_hs,     "any_cloaking_hs");
	_checkflag (state, process_local_hs,    "process_local_hs");
	_checkflag (state, machine_local_hs,    "machine_locak_hs");
	_checkflag (state, app_security_hs,     "app_security_hs");
	if (state) {
	    dprintf ("unknown state");
	}
    }
}

#define BTOSTR(x)        ((x) ? "TRUE" : "FALSE")

VOID DoChannelHandle(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    LPSTR                   pArgString
    )
{
    DWORD          addr = 0;
    CChannelHandle *cch = (CChannelHandle *)alloca(sizeof(CChannelHandle));

    APIPREAMBLE(ch);

    if ((Argc == 0) || ((addr = GetExpression(Argv[0])) == 0)) {
	dprintf ("Unable to evaluate %s\n", pArgString);
    }

    bStatus = GetData (addr, (void *)cch, sizeof(CChannelHandle));
    if (bStatus) {
	dprintf ("\n");
	dprintf ("CChannelHandle (0x%08x)\n", addr);
	dprintf ("RPC Handle:      %p\n", cch->_hRpc);
	dprintf ("_lAuthn:         %d\n", cch->_lAuthn);
	dprintf ("_lImp:           %d\n", cch->_lImp);
	dprintf ("_hToken:         %p\n", cch->_hToken);
	dprintf ("_eState:         ");
	PrintHandleState (cch->_eState);
	dprintf (" (%d)\n", cch->_eState);
	dprintf ("_fFirstCall:     %s\n", BTOSTR(cch->_fFirstCall));
	dprintf ("_cRef:           %d\n", cch->_cRef);
    }   
} 

void PrintOXIDList (DWORD_PTR head)
{
    DWORD_PTR addr;
    OXIDEntry ox;
    
    // First address is an empty OXIDEntry, used only for a head (pointers are valid, nothing else)
    GetData (head, (void *)&ox, sizeof(OXIDEntry));
    addr = (DWORD_PTR)ox._pNext;
    while (addr && (addr != head)) {
	GetData (addr, (void *)&ox, sizeof(OXIDEntry));
	
	dprintf ("   (0x%08x) pid %05d tid %05d moxid ", addr, 
		 ox._dwPid, ox._dwTid);
	PrintGUID (&(ox._moxid));
	dprintf ("\n");
	
	addr = (DWORD_PTR)ox._pNext;
    }
}


void DoOXIDTable(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    LPSTR                   pArgString
    )
{
    DWORD_PTR  inuse_addr, cleanup_addr, expire_addr, cexpired_addr;
    COXIDTable *cot = (COXIDTable *)alloca(sizeof(COXIDTable));
    OXIDEntry  ox;
    DWORD      _cExpired;
    
    APIPREAMBLE(ot);
    
    //The tables are static, so we don't take an address.  
    //(We wouldn't know what to do with it, anwyay.)
    
    cexpired_addr = GetExpression ("ole32!COXIDTable___cExpired");
    inuse_addr    = GetExpression ("ole32!COXIDTable___InUseHead");
    cleanup_addr  = GetExpression ("ole32!COXIDTable___CleanupHead");
    expire_addr   = GetExpression ("ole32!COXIDTable___ExpireHead");
    
    if (!(cexpired_addr && inuse_addr && cleanup_addr && expire_addr)) {
	dprintf ("Unable to resolve symbols.  Check to make sure they exist.\n");
	return;
    }
    
    bStatus = GetData (cexpired_addr, (void *)&(_cExpired), sizeof(_cExpired));
    dprintf ("_cExpired:         %d\n", _cExpired);
    
    dprintf ("OXIDs in use:\n");
    PrintOXIDList (inuse_addr);
    dprintf ("OXIDs expired:\n");
    PrintOXIDList (expire_addr);
    dprintf ("Cleanup list:\n");
    PrintOXIDList (cleanup_addr);
}

void PrintIPIDFlags (DWORD flags)
{
    if (flags) {
	_checkflag(flags, IPIDF_CONNECTING,     "IPIDF_CONNECTING");
	_checkflag(flags, IPIDF_DISCONNECTED,   "IPIDF_DISCONNECTED");
	_checkflag(flags, IPIDF_SERVERENTRY,    "IPIDF_SERVERENTRY");
	_checkflag(flags, IPIDF_NOPING,         "IPIDF_NOPING");
	_checkflag(flags, IPIDF_COPY,           "IPIDF_COPY");
	_checkflag(flags, IPIDF_VACANT,         "IPIDF_VACANT");
	_checkflag(flags, IPIDF_NONNDRSTUB,     "IPIDF_NONNDRSTUB");
	_checkflag(flags, IPIDF_NONNDRPROXY,    "IPIDF_NONNDRPROXY");
	_checkflag(flags, IPIDF_NOTIFYACT,      "IPIDF_NOTIFYACT");
	_checkflag(flags, IPIDF_TRIED_ASYNC,    "IPIDF_TRIED_ASYNC");
	_checkflag(flags, IPIDF_ASYNC_SERVER,   "IPIDF_ASYNC_SERVER");
	_checkflag(flags, IPIDF_DEACTIVATED,    "IPIDF_DEACTIVATED");
	_checkflag(flags, IPIDF_WEAKREFCACHE,   "IPIDF_WEAKREFCACHE");
	_checkflag(flags, IPIDF_STRONGREFCACHE, "IPIDF_STRONGREFCACHE");
	if (flags) {
	    dprintf ("Unknown flags");
	}
    }
}

void PrintIPIDEntry (DWORD_PTR addr)
{
    IPIDEntry ipid;

    dprintf ("IPIDEntry:  0x%08x\n", addr);
    
    if (!GetData (addr, (void *)&ipid, sizeof(ipid))) {
	dprintf ("Unable to read memory!\n");
	return;
    }

    dprintf ("Flags:\n\t"); PrintIPIDFlags (ipid.dwFlags); dprintf (" (%d)\n", ipid.dwFlags);
    dprintf ("Strong references:    %d\n", ipid.cStrongRefs);
    dprintf ("Weak references:      %d\n", ipid.cWeakRefs);
    dprintf ("Private references:   %d\n", ipid.cPrivateRefs);
    dprintf ("Real interface ptr:   %p\n", ipid.pv);
    dprintf ("Proxy or Stub ptr:    %p\n", ipid.pStub);
    dprintf ("Oxid Entry:           %p\n", ipid.pOXIDEntry);
    dprintf ("ipid:           "); PrintGUID(&(ipid.ipid)); dprintf("\n");
    dprintf ("iid:            "); PrintGUID(&(ipid.iid)); dprintf("\n");
    dprintf ("Channel Pointer:      %p\n", ipid.pChnl);
    dprintf ("Reference cache line: %p\n", ipid.pIRCEntry);
}

void DoIPIDTable(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    LPSTR                   pArgString
    )
{
    const char *palloc   = "ole32!CIPIDTable___palloc";
    const char *listhead = "ole32!CIPIDTable___oidListHead"; 
    IPIDEntry ipid;
    DWORD_PTR addr, head;
    

    addr = GetExpression (palloc);
    if (!addr) {
	dprintf ("Unable to resolve %s.  Make sure symbols are OK.\n", palloc);
	return;
    }
    dprintf ("(CPageAllocator is at 0x%08x)\n", addr);
    
    head = GetExpression (listhead);
    if (!head) {
	dprintf ("Unable to resolve %s.  Make sure symbols are OK.\n", listhead);
	return;
    }
    
    if (!GetData (head, (void *)&ipid, sizeof(ipid))) {
	dprintf ("Unable to read memory at 0x%08x.\n", head);
	return;
    }

    addr = (DWORD_PTR)ipid.pOIDFLink;
    while (addr != head) {
	if (!GetData (addr, (void *)&ipid, sizeof(ipid))) {
	    dprintf ("Unable to read IPID entry at 0x%08x.\n", addr);
	    return;
	}
	dprintf ("   (0x%08x)  ipid:       ", addr);
	PrintGUID (&(ipid.ipid));
	dprintf ("\n");
	/*
	dprintf ("\n"
		 "                 iid:        ");
	PrintGUID (&(ipid.iid));
	dprintf ("\n"
		 "                 oxid entry: 0x%08x\n", 
		 (DWORD_PTR)(ipid.pOXIDEntry));
	*/
	addr = (DWORD_PTR)ipid.pOIDFLink;
    }
}

void DoRpcChannelBuffer (
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    LPSTR                   pArgString
    )
{
    CRpcChannelBuffer *crcb = (CRpcChannelBuffer *)alloca(sizeof(CRpcChannelBuffer));
    DWORD_PTR addr;
    
    APIPREAMBLE(cb);

    if ((Argc == 0) || ((addr = GetExpression(Argv[0])) == 0)) {
	dprintf ("Unable to evaluate %s\n", pArgString);
    }

    bStatus = GetData (addr, (void *)crcb, sizeof(CRpcChannelBuffer));
    if (!bStatus) {
	dprintf ("Unable to read CRpcChannelBuffer at 0x%08x\n", addr);
	return;
    }

    dprintf ("CRpcChannelBuffer (0x%08x)\n", addr);
    dprintf ("Ref count:        %d\n",    crcb->_cRefs);
    dprintf ("Channel state:    "); 
    PrintEChannelState (crcb->state);  dprintf ("\n");
    dprintf ("Default channel:  %p\n",    crcb->_pRpcDefault);
    dprintf ("Custom channel:   %p\n",    crcb->_pRpcCustom);
    dprintf ("OXID Entry:       %p\n",    crcb->_pOXIDEntry);
    dprintf ("IPID Entry:       %p\n",    crcb->_pIPIDEntry);
    dprintf ("Interface info:   %p\n",    crcb->_pInterfaceInfo);
    dprintf ("_pStdId:          %p\n",    crcb->_pStdId);
    dprintf ("COM Version:      %d.%d\n", crcb->_destObj._comversion.MajorVersion,
	                                  crcb->_destObj._comversion.MinorVersion);
    dprintf ("Dest. Context:    %d\n",    crcb->_destObj._dwDestCtx);
}

void PrintMIDEntry (MIDEntry mid)
{
    dprintf ("   _mid: %I64d",    mid._mid);
    dprintf ("   _cRefs: %d",     mid._cRefs);
    dprintf ("   _dwFlags: %d\n", mid._dwFlags);
}

void DoMIDTable(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    LPSTR                   pArgString
    )
{    
    const char *szLocalAllocator = "ole32!CMIDTable___palloc";
    const char *szHashTbl        = "ole32!MIDBuckets";
    const char *szLocalMid       = "ole32!CMIDTable___pLocalMIDEntry"; 
    DWORD_PTR _palloc, _HashTbl, _pLocalMIDEntry; 
    SBcktWlkr bw;
    ULONG_PTR currnode;
    MIDEntry  me;
    DWORD     count = 0;

    _palloc  = GetExpression(szLocalAllocator);
    _HashTbl = GetExpression(szHashTbl);
    _pLocalMIDEntry = GetExpression(szLocalMid);

    if (!(_palloc && _HashTbl && _pLocalMIDEntry)) {
	dprintf ("Unable to resolve symbols.\n");
	return;
    }

    dprintf ("CPageAllocator at 0x%08x\n", _palloc);

    dprintf ("Local MIDEntry:\n");
    GetData (_pLocalMIDEntry, &currnode, sizeof(currnode));
    if (currnode) {
	if (!GetData (currnode, &me, sizeof(me))) {
	    dprintf ("Unable to read memory at 0x%08x\n", currnode);
	    return;
	}
	PrintMIDEntry (me);
    }

    dprintf ("Table:\n");
    if (!InitBucketWalker(&bw, NUM_HASH_BUCKETS, _HashTbl)) {
	dprintf ("Unable to start walking the hash buckets.\n");
	return;
    }
    
    while (currnode = NextNode(&bw)) {
	if (!GetData (currnode, &me, sizeof(me))) {
	    dprintf ("Unable to read memory at 0x%08x\n", currnode);
	    return;
	}
	PrintMIDEntry (me);
	count++;
    }
    dprintf ("%d MID%s\n", count, (count == 1) ? "" : "s");    
}

void PrintGIPType (DWORD type)
{
    CHECKFLAG(type, ORT_OBJREF);
    CHECKFLAG(type, ORT_LAZY_OBJREF);
    CHECKFLAG(type, ORT_AGILE);
    CHECKFLAG(type, ORT_LAZY_AGILE);
    CHECKFLAG(type, ORT_STREAM);
    CHECKFLAG(type, ORT_FREETM);
    if (type) {
	dprintf ("UNKNOWN TYPE");
    }
    dprintf ("\n");
}

void PrintMarshalParams (MarshalParams mp)
{
    dprintf ("   IID   : "); PrintGUID (&(mp.iid)); dprintf ("\n");
    dprintf ("   flags : 0x%08x\n", mp.mshlflags);
}

void DoGIPEntry (DWORD_PTR addr)
{
    try {
	DEBUGSTRUCT(gipent, GIPEntry, addr);

	dprintf ("GIPEntry (0x%08x)\n", addr);
	dprintf ("Type         :"); PrintGIPType (gipent->dwType); 
	dprintf("\n");
	dprintf ("Sequence No. :  %d\n", gipent->dwSeqNo);
	dprintf ("cUsage       :  %d\n", gipent->cUsage);
	dprintf ("Apartment ID :  %d\n", gipent->dwAptId);
	dprintf ("hWndApt      :  0x%08x\n", gipent->hWndApt);
	dprintf ("Context      :  0x%08x\n", gipent->pContext);
	dprintf ("Real IUnknown:  0x%08x\n", gipent->pUnk);
	dprintf ("Proxy        :  0x%08x\n", gipent->pUnkProxy);
	dprintf ("Marshal Params:\n");
	PrintMarshalParams (gipent->mp);
	dprintf ("InterfaceData:  0x%08x\n", gipent->u.pIFD);
	dprintf ("ObjRef       :  0x%08x\n", gipent->u.pobjref);

	free (gipent);

    } catch (char *except) {
	dprintf ("%s\n", except);
    }
}

void DoGIPTbl (void)
{
    try {
	DWORD_PTR working, start;
	DEBUGVAR (currseq, DWORD, "ole32!CGIPTable___dwCurrSeqNo");
	DEBUGVAR (inrevokeall, BOOL, "ole32!CGIPTable___fInRevokeall");
	DEBUGSTRUCT (gipent, GIPEntry, "ole32!CGIPTable___InUseHead");

	dprintf ("_dwCurrSeqNo:  %d\n", currseq);
	dprintf ("_fInRevokeAll: %s\n", (inrevokeall ? "TRUE" : "FALSE"));
	
	start = GetExpression("ole32!CGIPTable___InUseHead");
	working = (DWORD_PTR)gipent->pNext;
	while ((working) && (working != start)) {
	    if (!GetData(working, (void *)gipent, sizeof(GIPEntry))) {
		throw "Unable to read table entry.\n";
	    }
	    dprintf ("(0x%08x) seq: %d usage: %d type: ", working,
		     gipent->dwSeqNo, gipent->cUsage);
	    PrintGIPType (gipent->dwType);
	    dprintf ("\n");
	    working = (DWORD_PTR)gipent->pNext;
	}
	free (gipent);
    } catch (char *except) {
	dprintf ("%s\n", except);
	return;
    }
}

void PrintRIFEntryFlags (DWORD flags)
{
    if (flags) {
	CHECKFLAG(flags, RIFFLG_HASCOUNTERPART);
	CHECKFLAG(flags, RIFFLG_HASCLSID);
	if (flags) {
	    dprintf ("UNKNOWN FLAGS");
	}
	dprintf ("\n");
    }
}

void DoRIFEntry (DWORD_PTR addr)
{
    try {
	DEBUGSTRUCT(rifent, RIFEntry, addr);
	
	dprintf ("RIFEntry (0x%08x)\n", addr);
	dprintf ("Counterpart's IID: "); PrintGUID(&(rifent->iidCounterpart)); dprintf("\n");
	dprintf ("Proxy stub CLSID : "); PrintGUID(&(rifent->psclsid)); dprintf("\n");
	dprintf ("Flags            : %x\n", rifent->dwFlags);
	PrintRIFEntryFlags (rifent->dwFlags);
	dprintf ("Server interface : 0x%08x\n", rifent->pSrvInterface);
	dprintf ("Client interface : 0x%08x\n", rifent->pCliInterface);
    
	free (rifent);
    } catch (char *except) {
	dprintf ("%s\n", except);
	return;
    }
}

void DoRIFTable (void)
{
    try {
	DWORD_PTR node;
	DWORD_PTR buckets;
	SBcktWlkr bw;
	DEBUGVAR (prefilled, BOOL, "ole32!CRIFTable___fPreFilled");

	if (!(buckets = GetExpression("ole32!RIFBuckets"))) {
	    throw "Unable to resolve buckets.  Check yer symbols.";
	}
	
	dprintf ("_fPreFilled: %s\n", (prefilled ? "TRUE" : "FALSE"));

	if (!InitBucketWalker (&bw, NUM_HASH_BUCKETS, buckets, 
			       offsetof(CIDObject, _oidChain))) {
	    throw "Unable to init bucket walker.";
	}
	
	while (node = NextNode (&bw)) {
	    DEBUGSTRUCT (re, RIFEntry, node);
	 
	    dprintf ("(0x%08x) iid: ",
		     node);
	    PrintGUID (&(re->iidCounterpart));
	    dprintf ("\n");
	    
	    free (re);
	}
    } catch (char *except) {
	dprintf ("%s\n", except);
	return;
    }
}

void PrintStdMarshalFlags (DWORD flags)
{
    if (flags) {
	CHECKFLAG(flags, SMFLAGS_CLIENT_SIDE);
       	CHECKFLAG(flags, SMFLAGS_PENDINGDISCONNECT);
	CHECKFLAG(flags, SMFLAGS_REGISTEREDOID);
	CHECKFLAG(flags, SMFLAGS_DISCONNECTED);
	CHECKFLAG(flags, SMFLAGS_FIRSTMARSHAL);
	CHECKFLAG(flags, SMFLAGS_HANDLER);
	CHECKFLAG(flags, SMFLAGS_WEAKCLIENT);
	CHECKFLAG(flags, SMFLAGS_IGNORERUNDOWN);
	CHECKFLAG(flags, SMFLAGS_CLIENTMARSHALED);
	CHECKFLAG(flags, SMFLAGS_NOPING);
	CHECKFLAG(flags, SMFLAGS_TRIEDTOCONNECT);
	CHECKFLAG(flags, SMFLAGS_CSTATICMARSHAL);
	CHECKFLAG(flags, SMFLAGS_USEAGGSTDMARSHAL);
	CHECKFLAG(flags, SMFLAGS_SYSTEM);
	CHECKFLAG(flags, SMFLAGS_DEACTIVATED);
	CHECKFLAG(flags, SMFLAGS_FTM);
	CHECKFLAG(flags, SMFLAGS_CLIENTPOLICYSET);
	CHECKFLAG(flags, SMFLAGS_APPDISCONNECT);
	CHECKFLAG(flags, SMFLAGS_SYSDISCONNECT);
	CHECKFLAG(flags, SMFLAGS_RUNDOWNDISCONNECT);
	CHECKFLAG(flags, SMFLAGS_CLEANEDUP);
	if (flags) {
	    dprintf ("UNKNOWN FLAGS");
	}
	dprintf ("\n");
    }
}

void DoStdMarshal (DWORD_PTR addr)
{
    try {
	DEBUGSTRUCT (sm, CStdMarshal, addr);
	
	dprintf ("CStdMarshal (0x%08x)\n", addr);
	dprintf ("Flags                   : 0x%08x\n", sm->_dwFlags);
	PrintStdMarshalFlags (sm->_dwFlags);
	dprintf ("# of IPIDs              : %d\n", sm->_cIPIDs);
	dprintf ("First IPID              : 0x%08x\n", sm->_pFirstIPID);
	dprintf ("StdIdentity             : 0x%08x\n", sm->_pStdId);
	dprintf ("Channel Ptr             : 0x%08x\n", sm->_pChnl);
	dprintf ("CLSID of handler        : "); 
	PrintGUID (&(sm->_clsidHandler)); dprintf("\n");
	dprintf ("Nested calls            : %d\n", sm->_cNestedCalls);
	dprintf ("Table refs              : %d\n", sm->_cTableRefs);
	dprintf ("Marshal Time            : %d\n", sm->_dwMarshalTime);
	dprintf ("RemUnk with app security: 0x%08x\n", sm->_pSecureRemUnk);
	dprintf ("Async Release           : 0x%08x\n", sm->_pAsyncRelease);
	dprintf ("Context entry list      : 0x%08x\n", sm->_pCtxEntryHead);
	dprintf ("Free context entry list : 0x%08x\n", sm->_pCtxFreeList);
	dprintf ("Server policy set       : 0x%08x\n", sm->_pPS);
	dprintf ("Object Identity         : 0x%08x\n", sm->_pID);
	dprintf ("Client Reference Cache  : 0x%08x\n", sm->_pRefCache);
 
	free (sm);
    } catch (char *except) {
	dprintf ("%s\n", except);
	return;
    }
}

void PrintStdWrapperFlags (DWORD flags)
{
    if (flags) {
	CHECKFLAG(flags, WRAPPERFLAG_INDESTRUCTOR);
	CHECKFLAG(flags, WRAPPERFLAG_DISCONNECTED);
	CHECKFLAG(flags, WRAPPERFLAG_DEACTIVATED);
	CHECKFLAG(flags, WRAPPERFLAG_STATIC);
	CHECKFLAG(flags, WRAPPERFLAG_DESTROYID);
	CHECKFLAG(flags, WRAPPERFLAG_NOIEC);
	CHECKFLAG(flags, WRAPPERFLAG_NOPING);
	if (flags) {
	    dprintf ("UNKNOWN STATE");
	}
	dprintf ("\n");
    }
}

void DoStdWrapper (DWORD_PTR addr)
{
    try {
	DEBUGSTRUCT (sw, CStdWrapper, addr);

	dprintf ("CStdWrapper (0x%08x)\n", addr);
	dprintf ("State               : 0x%08x\n", sw->_dwState);
	PrintStdWrapperFlags (sw->_dwState);
	dprintf ("Ref count           : %d\n", sw->_cRefs);
	dprintf ("Calls               : %d\n", sw->_cCalls);
	dprintf ("Interfaces          : %d\n", sw->_cIFaces);
	dprintf ("Interface list      : 0x%08x\n", sw->_pIFaceHead);
	dprintf ("Context entries     : 0x%08x\n", sw->_pCtxEntryHead);
	dprintf ("Free context entries: 0x%08x\n", sw->_pCtxFreeList);
	dprintf ("Server object       : 0x%08x\n", sw->_pServer);
	dprintf ("ID tracking this obj: 0x%08x\n", sw->_pID);

	free (sw);
    } catch (char *except) {
	dprintf ("%s\n", except);
	return;
    }
}

//This is a private definition in chock.cxx
typedef struct SHookList
{
    struct SHookList *pNext;
    IChannelHook     *pHook;
    UUID              uExtension;
} SHookList;

void DoHookList (void)
{
    try {
	DWORD_PTR hlistaddr = GetExpression("ole32!gHookList");
	DEBUGSTRUCT (hookhead, SHookList, hlistaddr);
	DWORD_PTR addr;
	
	addr = (DWORD_PTR)hookhead->pNext;
	while (addr != hlistaddr) {
	    DEBUGSTRUCT (hent, SHookList, addr);
	    
	    dprintf ("Next: 0x%08x Hook: 0x%08x Ext: ", 
		     hent->pNext, hent->pHook);
	    PrintGUID (&(hent->uExtension));
	    dprintf ("\n");
	    addr = (DWORD_PTR)hent->pNext;
	}
    } catch (char *except) {
	dprintf ("%s\n", except);
	return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\exts\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Mark Lucovsky (markl) 18-Sep-1990

!ENDIF

DLLBASE=0x1000000

MAJORCOMP=ntsd
MINORCOMP=ntsdexts

TARGETNAME=dcomexts
TARGETPATH=$(BASEDIR)\public\sdk\lib
TARGETTYPE=DYNLINK

TARGETLIBS=$(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib

DLLDEF = ..\dcomdbg.def
MSC_WARNING_LEVEL=/WX

USE_CRTDLL = 1

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..;..\..\inc

INCLUDES=     $(INCLUDES);..\..\class;..\..\objact;..\..\dcomrem
INCLUDES=     $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\obj
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\obj
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\obj
INCLUDES=     $(INCLUDES);..\..\..\actprops
INCLUDES=     $(INCLUDES);$(BASEDIR)\private\inc

INCLUDES=     $(INCLUDES);..\..\..\dcomss\objex;

INCLUDES=     $(INCLUDES);..\..\..\dcomss;
INCLUDES=     $(INCLUDES);..\..\..;
INCLUDES=     $(INCLUDES);..\..\..\dcomss\olescm;

INCLUDES=     $(INCLUDES);..\..\rot;

C_DEFINES=    \
              $(C_DEFINES) -DMSWMSG

USE_NATIVE_EH = 1

SOURCES=..\dcomdbg.cxx     \
        ..\dcomctx.cxx     \
        ..\dcomtls.cxx     \
        ..\dcomutil.cxx    \
        ..\dcomact.cxx     \
        ..\dcomrem.cxx     \
        ..\dcomapt.cxx     \
	..\dcomvtb.cxx     \
	..\dcomsec.cxx     \
	..\dcomid.cxx      \
	..\dcomhelp.cxx    \
        ..\dcomlog.cxx     \
	\
	..\dbgutil.cxx     \
	\
	..\actdbg.cxx      \
	..\commands.cxx    \
	..\epts.c          \
	..\dcomdbg.rc

UMTYPE=console

# Precompiled header stuff...
#
#PRECOMPILED_CXX=1
#PRECOMPILED_INCLUDE=..\ole2int.h
#PRECOMPILED_TARGET=..\$(GPCH_BUILD)\$(_OBJ_DIR)\*\com2int.pch
#PRECOMPILED_OPTION=/Yuole2int.h /Fp..\$(GPCH_BUILD)\$(_OBJ_DIR)\*\com2int.pch
#PRECOMPILED_OBJ=..\$(GPCH_BUILD)\$(_OBJ_DIR)\*\com2int.obj
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\exts\dcomutil.cxx ===
//+----------------------------------------------------------------------------
//
//  File:       dcomutil.cxx
//
//  Contents:   Utility functions for debug extension.
//
//  History:    9-Nov-98   Johnstra      Created
//
//-----------------------------------------------------------------------------

#include <ole2int.h>
#include <locks.hxx>
#include <hash.hxx>
#include <context.hxx>
#include <aprtmnt.hxx>
#include <actvator.hxx>
#include <pstable.hxx>
#include <crossctx.hxx>
#include <tlhelp32.h>
#include <wdbgexts.h>

#include "dcomdbg.hxx"

//+--------------------------------------------------------------------------
//
//  Member:     InitDebuggeePID , private
//
//  Synopsis:   Using a handle to a thread in the debuggee process, gets
//              the debuggee's PID and initialized gPIDDebuggee.
//
//  Returns:    void
//
//  History:    9-Nov-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
VOID InitDebuggeePID(
    HANDLE hCurrentThread
    )
{
    THREAD_BASIC_INFORMATION ThreadBasicInfo;
    NTSTATUS status = NtQueryInformationThread(
                          hCurrentThread, 
                          ThreadBasicInformation, 
                          &ThreadBasicInfo, 
                          sizeof(ThreadBasicInfo), 
                          NULL);
    if (!NT_SUCCESS(status))
    {
        dprintf("Error: NtQueryInformationThread failed\n");
        return;
    }
    
    gPIDDebuggee = HandleToUlong(ThreadBasicInfo.ClientId.UniqueProcess);
}


//+--------------------------------------------------------------------------
//
//  Member:     SetThreadApartmentType , private
//
//  Synopsis:   Determines and sets the thread's apartment type.
//
//  Arguemnts:
//     pThread  pointer to thread info struct
//
//  Returns:    void
//
//  History:    9-Nov-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
VOID SetThreadApartmentType(
    DcomextThreadInfo *pThread
    )
{
    
    pThread->AptType = APT_NONE;    
    if (pThread->pTls)
    {
        if (pThread->pTls->dwFlags & OLETLS_APARTMENTTHREADED)
            pThread->AptType = APT_STA;
        else if (pThread->pTls->dwFlags & OLETLS_MULTITHREADED)
            pThread->AptType = APT_MTA;
        else
            pThread->AptType = APT_DISP;
    }
}


//+--------------------------------------------------------------------------
//
//  Member:     GetDebuggeeThreads , private
//
//  Synopsis:   Initializes a list of all the threads in the debuggee.
//
//  Arguments:
//     hCurrentThread  - open handle to the current thread
//     ppFirst         - ptr to ptr to first elem in list
//     pCount          - ptr to location to store # of threads
//                       returned.
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//  History:    9-Nov-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
BOOL GetDebuggeeThreads(
    HANDLE              hCurrentThread,
    DcomextThreadInfo **ppFirst,
    ULONG              *pCount    
    )
{
    NTSTATUS           status;
    HANDLE             hThreadSnap     = NULL;     
    BOOL               bRet            = FALSE; 
    THREADENTRY32      te32            = {0};
    DcomextThreadInfo *pFirst          = NULL;
    DcomextThreadInfo *pLast           = NULL;
    DcomextThreadInfo *pNewEntry;
    ULONG_PTR          TlsBase;
    BOOL               fFixup          = FALSE;
    BOOL               fMTAInitialized = FALSE;
    
    // Init count to zero.
    
    *pCount = 0;
    
    // Get the PID of the debuggee.
    
    ULONG dwOwnerPID = GetDebuggeePID(hCurrentThread);
    if (!dwOwnerPID)
        return FALSE;
        
    // Take a snapshot of all threads currently in the system. 
    
    hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);    
    if (hThreadSnap == (HANDLE)-1)
        return (FALSE);
        
    // Fill in the size of the structure before using it.
    
    te32.dwSize = sizeof(THREADENTRY32);
    
    // Walk the thread snapshot to find all threads of the process. 
    // If the thread belongs to the process, add its information 
    // to the display list.     
    
    if (Thread32First(hThreadSnap, &te32))     
    { 
        do         
        {             
            if (te32.th32OwnerProcessID == dwOwnerPID) 
            {
                // Alloc a new thread info object.
                
                pNewEntry = (DcomextThreadInfo*) 
                            GlobalAlloc(GPTR, sizeof(DcomextThreadInfo));
                if (!pNewEntry)
                {
                    dprintf("Error: could not allocate thread info\n");
                    goto end;
                }
                
                // We need a handle to the thread, so do OpenThread to get one
                
                pNewEntry->hThread = 
                    OpenThread(THREAD_QUERY_INFORMATION, 
                               FALSE, 
                               te32.th32ThreadID);                        
                if (!pNewEntry->hThread)
                {
                    dprintf("Error: could not OpenThread %X\n", te32.th32ThreadID);
                    GlobalFree(pNewEntry);
                    goto end;
                }
                
                // We need to get the TEB for the thread.  
                // NtQueryInformationThread can give us this.
                
                status = NtQueryInformationThread(pNewEntry->hThread,
                                                  ThreadBasicInformation, 
                                                  &pNewEntry->tbi,
                                                  sizeof(pNewEntry->tbi), 
                                                  NULL);
                if (!NT_SUCCESS(status))
                {
                    dprintf("Error: could not get thread info for %X\n", te32.th32ThreadID);
                    GlobalFree(pNewEntry);
                    goto end;
                }
                                
                // Try to get a snapshot of COM's tls info.
                
                pNewEntry->pTls = NULL;
                GetComTlsBase((LONG_PTR)pNewEntry->tbi.TebBaseAddress, &TlsBase);
                if (TlsBase)
                {
                    pNewEntry->pTls = (SOleTlsData *)GlobalAlloc(GPTR, sizeof(SOleTlsData));
                    GetComTlsInfo(TlsBase, pNewEntry->pTls);
                }
                
                // Initialize the thread's apartment type.
                
                SetThreadApartmentType(pNewEntry);
                if (pNewEntry->AptType == APT_MTA)
                    fMTAInitialized = TRUE;
                if (pNewEntry->AptType == APT_NONE)
                    fFixup = TRUE;
                                
                // Set the thread index.
                
                pNewEntry->index = (*pCount)++;
                
                // Link in the new node.
                
                if (!pFirst)
                    pFirst = pNewEntry;
                else
                    pLast->pNext = pNewEntry;
                pNewEntry->pNext = NULL;
                pLast = pNewEntry;                
            } 
        } while (Thread32Next(hThreadSnap, &te32));               
        
        // Here we do a fixup on any threads we could not qualify earlier.
        // If a thread has no COM TLS info, we marked it as NONE.  Here
        // we change those to 'Implicit MTA' if at least one of the threads
        // was init'd MTA.
        
        if (fMTAInitialized && fFixup)
        {
            DcomextThreadInfo *pThread = pFirst;
            while (pThread)
            {
                if (pThread->AptType == APT_NONE)
                    pThread->AptType = APT_IMTA;
                pThread = pThread->pNext;
            }
        }
        
        bRet = TRUE;
    }     
        
end:
    
    // Return the list to the caller.
    
    *ppFirst = pFirst;
    
    // Clean up the snapshot object.
    
    CloseHandle (hThreadSnap);
          
    return (bRet);     
}


//+--------------------------------------------------------------------------
//
//  Member:     FreeDebuggeeThreads , public
//
//  Synopsis:   Frees all the resources associated with the list of debuggee
//              threads.
//
//  Arguments:
//     pFirst   ptr to first element in list
//
//  Returns:    void
//
//  History:    9-Nov-98   Johnstra      Created.
//
//----------------------------------------------------------------------------
VOID FreeDebuggeeThreads(
    DcomextThreadInfo *pFirst
    )
{
    DcomextThreadInfo *pHold;
    while (pFirst)
    {
        pHold = pFirst->pNext;
        if (pFirst->pTls)
            GlobalFree(pFirst->pTls);
        GlobalFree(pFirst);
        pFirst = pHold;
    }   
}

BOOL InitBucketWalker(SBcktWlkr *pBW, ULONG cBuckets, ULONG_PTR addrBuckets, size_t offset)
{
    pBW->addrBuckets = addrBuckets;
    pBW->cBuckets = cBuckets;
    pBW->iCurrBucket = 0;
    pBW->pBuckets = (SHashChain *) malloc(sizeof(SHashChain) * pBW->cBuckets);
    pBW->offset = offset;
    GetData(addrBuckets, pBW->pBuckets, (sizeof(SHashChain) * pBW->cBuckets));
    pBW->pCurrNode = (ULONG_PTR) pBW->pBuckets[0].pNext;        
    return TRUE;
}

ULONG_PTR NextNode(SBcktWlkr *pBW)
{
    BOOL fReEntry = TRUE;
    
    ULONG_PTR pNext;
    ULONG_PTR pCurrentBucket = (ULONG_PTR) (((SHashChain *)pBW->addrBuckets) +
					    pBW->iCurrBucket);
    pNext = pBW->pCurrNode;
    while ((pNext == pCurrentBucket) && 
	   (pBW->iCurrBucket < pBW->cBuckets - 1))  {
	pBW->iCurrBucket++;
	pBW->pCurrNode = pNext = 
	    (ULONG_PTR) pBW->pBuckets[pBW->iCurrBucket].pNext;
	pCurrentBucket = 
	    (ULONG_PTR) (((SHashChain *)pBW->addrBuckets) + pBW->iCurrBucket);
    }

    if (pBW->iCurrBucket == pBW->cBuckets-1) {
	//Ran out of buckets
	return 0; 
    } else {
	//Read in the "next" pointer
	GetData (pNext, &(pBW->pCurrNode), sizeof(pBW->pCurrNode));
	return pNext - pBW->offset;
    }
}

size_t GetStrLen(ULONG_PTR addr)
{
    WCHAR c = 0;
    int count = -1;
    do
    {
        GetData(addr, &c, sizeof(WCHAR));
        addr += sizeof(WCHAR);
        count++;
    }
    while (c != 0);
    return count;
}

VOID DoBcktWalk(
    HANDLE                  hCurrentProcess,
    HANDLE                  hCurrentThread,
    DWORD                   dwCurrentPc,
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    LPSTR                   lpArgumentString
    )
{
    ULONG_PTR addrBuckets = 0;
    int cBuckets;
    
    while (*lpArgumentString == ' ')
        lpArgumentString++;

    LPSTR pFirst = lpArgumentString;
    while (*lpArgumentString != ' ' && *lpArgumentString != 0)
        lpArgumentString++;
    
    if (*lpArgumentString)
    {
        *lpArgumentString = 0;
        lpArgumentString++;
    }

    while (*lpArgumentString == ' ')
        lpArgumentString++;
        
    LPSTR pSecond = lpArgumentString;
    while (*lpArgumentString != ' ' && *lpArgumentString != 0)
        lpArgumentString++;
    
    if (*lpArgumentString)
    {
        *lpArgumentString = 0;
        lpArgumentString++;
    }


    if (*pFirst == 0)
    {
        dprintf("usage:\n\tbcktwalk <buckethead> [<numbuckets>]  -- if numbuckets is omitted, NUM_HASH_BUCKETS is used\n");
        return;
    }
    if (*pSecond != 0)
    {
        cBuckets = atoi(pSecond);
        if (cBuckets <= 0)
        {
            dprintf("bucket count parameter bad!\n");
            return;
        }
    }
    else
    {
        cBuckets = NUM_HASH_BUCKETS;
    }
            
    
    addrBuckets = GetExpression(pFirst);
    if (!addrBuckets)
    {
        dprintf("Error: can't evaluate %s\n", lpArgumentString);
            return;
    }

    SBcktWlkr BW;
    InitBucketWalker(&BW, cBuckets, addrBuckets);
    ULONG_PTR node;
    int count = 0;
    while (node = NextNode(&BW))
    {
        count++;
        dprintf("Node: 0x%x\n", node);
    }
    dprintf("\n%d node%s total\n", count, count == 1 ? "" : "s");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\allguid.cxx ===
#define INITGUID
#define INITGUID
#include "windows.h"

// Handle port problems easily

// PORT: HTASK no longer seems to be defined in Win32
#define HTASK DWORD
#define HINSTANCE_ERROR 32
#define __loadds
#define __segname
#define BASED_CODE
#define HUGE
#define __based(x)

#include "ole2.h"

// #include "privguid.h"

#ifndef CAIROLE_DOWNLEVEL
DEFINE_OLEGUID(CLSID_StdOleLink,		0x00000300, 0, 0);
DEFINE_OLEGUID(CLSID_StdMemStm,			0x00000301, 0, 0);
DEFINE_OLEGUID(CLSID_StdMemBytes,		0x00000302, 0, 0);
DEFINE_OLEGUID(CLSID_FileMoniker,		0x00000303, 0, 0);
DEFINE_OLEGUID(CLSID_ItemMoniker,		0x00000304, 0, 0);
DEFINE_OLEGUID(CLSID_AntiMoniker,		0x00000305, 0, 0);
DEFINE_OLEGUID(CLSID_PointerMoniker,	0x00000306, 0, 0);
// NOT TO BE USED						0x00000307, 0, 0);
DEFINE_OLEGUID(CLSID_PackagerMoniker,	0x00000308, 0, 0);
DEFINE_OLEGUID(CLSID_CompositeMoniker,	0x00000309, 0, 0);
#endif // !CAIROLE_DOWNLEVEL

DEFINE_OLEGUID(CLSID_RemoteHdlr,       0x00000200, 0, 8);
DEFINE_OLEGUID(CLSID_RpcChannelBuffer, 0x00000199, 0, 8);

// clsids for proxy/stub objects
// these are defined in \common\h\win40\cguid.h
//DEFINE_OLEGUID(CLSID_PSGenObject,		0x0000030c, 0, 0);
//DEFINE_OLEGUID(CLSID_PSClientSite,		0x0000030d, 0, 0);
//DEFINE_OLEGUID(CLSID_PSClassObject,		0x0000030e, 0, 0);
//DEFINE_OLEGUID(CLSID_PSInPlaceActive,	0x0000030f, 0, 0);
//DEFINE_OLEGUID(CLSID_PSInPlaceFrame,	0x00000310, 0, 0);
//DEFINE_OLEGUID(CLSID_PSDragDrop,		0x00000311, 0, 0);
//DEFINE_OLEGUID(CLSID_PSBindCtx,			0x00000312, 0, 0);
//DEFINE_OLEGUID(CLSID_PSEnumerators,		0x00000313, 0, 0);
//DEFINE_OLEGUID(CLSID_PSStore,			0x00000314, 0, 0);

// #include "ole1cls.h"

#ifndef DEFINE_OLE1GUID
#define DEFINE_OLE1GUID(a,b,c,d,e) DEFINE_OLEGUID (a,b,c,d)
#endif
   
#ifndef CAIROLE_DOWNLEVEL
DEFINE_OLE1GUID(CLSID_ExcelWorksheet,   0x00030000, 0, 0, "ExcelWorksheet");
DEFINE_OLE1GUID(CLSID_ExcelChart,       0x00030001, 0, 0, "ExcelChart");
DEFINE_OLE1GUID(CLSID_ExcelMacrosheet,  0x00030002, 0, 0, "ExcelMacrosheet");
DEFINE_OLE1GUID(CLSID_WordDocument,     0x00030003, 0, 0, "WordDocument");
#endif // !CAIROLE_DOWNLEVEL
DEFINE_OLE1GUID(CLSID_MSPowerPoint,     0x00030004, 0, 0, "MSPowerPoint");
DEFINE_OLE1GUID(CLSID_MSPowerPointSho,  0x00030005, 0, 0, "MSPowerPointSho");
DEFINE_OLE1GUID(CLSID_MSGraph,          0x00030006, 0, 0, "MSGraph");
#ifndef CAIROLE_DOWNLEVEL
DEFINE_OLE1GUID(CLSID_MSDraw,               0x00030007, 0, 0, "MSDraw");
#endif // !CAIROLE_DOWNLEVEL
DEFINE_OLE1GUID(CLSID_Note_It,          0x00030008, 0, 0, "Note-It");
DEFINE_OLE1GUID(CLSID_WordArt,          0x00030009, 0, 0, "WordArt");
#ifndef CAIROLE_DOWNLEVEL
DEFINE_OLE1GUID(CLSID_PBrush,               0x0003000a, 0, 0, "PBrush");
#endif // !CAIROLE_DOWNLEVEL
DEFINE_OLE1GUID(CLSID_Equation,         0x0003000b, 0, 0, "Equation");
#ifndef CAIROLE_DOWNLEVEL
DEFINE_OLE1GUID(CLSID_Package,          0x0003000c, 0, 0, "Package");
#endif // !CAIROLE_DOWNLEVEL
DEFINE_OLE1GUID(CLSID_SoundRec,         0x0003000d, 0, 0, "SoundRec");
DEFINE_OLE1GUID(CLSID_MPlayer,          0x0003000e, 0, 0, "MPlayer");

/* test apps */
DEFINE_OLE1GUID(CLSID_ServerDemo,       0x0003000f, 0, 0, "ServerDemo");
DEFINE_OLE1GUID(CLSID_Srtest,               0x00030010, 0, 0, "Srtest");
DEFINE_OLE1GUID(CLSID_SrtInv,               0x00030011, 0, 0, "SrtInv");
DEFINE_OLE1GUID(CLSID_OleDemo,          0x00030012, 0, 0, "OleDemo");

/* External ISVs */
// Coromandel / Dorai Swamy / 718-793-7963
DEFINE_OLE1GUID(CLSID_CoromandelIntegra,    0x00030013, 0, 0, "CoromandelIntegra");
DEFINE_OLE1GUID(CLSID_CoromandelObjServer,0x00030014, 0, 0, "CoromandelObjServer");

// 3-d Visions Corp / Peter Hirsch / 310-325-1339
DEFINE_OLE1GUID(CLSID_StanfordGraphics, 0x00030015, 0, 0, "StanfordGraphics");

// Deltapoint / Nigel Hearne / 408-648-4000
DEFINE_OLE1GUID(CLSID_DGraphCHART,          0x00030016, 0, 0, "DGraphCHART");
DEFINE_OLE1GUID(CLSID_DGraphDATA,           0x00030017, 0, 0, "DGraphDATA");

// Corel / Richard V. Woodend / 613-728-8200 x1153
DEFINE_OLE1GUID(CLSID_PhotoPaint,           0x00030018, 0, 0, "PhotoPaint");
DEFINE_OLE1GUID(CLSID_CShow,                    0x00030019, 0, 0, "CShow");
DEFINE_OLE1GUID(CLSID_CorelChart,           0x0003001a, 0, 0, "CorelChart");
DEFINE_OLE1GUID(CLSID_CDraw,                    0x0003001b, 0, 0, "CDraw");

// Inset Systems / Mark Skiba / 203-740-2400
DEFINE_OLE1GUID(CLSID_HJWIN1_0,             0x0003001c, 0, 0, "HJWIN1.0");

// Mark V Systems / Mark McGraw / 818-995-7671
DEFINE_OLE1GUID(CLSID_ObjMakerOLE,          0x0003001d, 0, 0, "ObjMakerOLE");

// IdentiTech / Mike Gilger / 407-951-9503
DEFINE_OLE1GUID(CLSID_FYI,                      0x0003001e, 0, 0, "FYI");
DEFINE_OLE1GUID(CLSID_FYIView,                  0x0003001f, 0, 0, "FYIView");

// Inventa Corporation / Balaji Varadarajan / 408-987-0220
DEFINE_OLE1GUID(CLSID_Stickynote,       0x00030020, 0, 0, "Stickynote");

// ShapeWare Corp. / Lori Pearce / 206-467-6723
DEFINE_OLE1GUID(CLSID_ShapewareVISIO10, 0x00030021, 0, 0, "ShapewareVISIO10");
DEFINE_OLE1GUID(CLSID_ImportServer,     0x00030022, 0, 0, "ImportServer");


// test app SrTest
DEFINE_OLE1GUID(CLSID_SrvrTest,          0x00030023, 0, 0, "SrvrTest");

// Special clsid for when a 1.0 client pastes an embedded object
// that is a link.
// **This CLSID is obsolete. Do not reuse number.
//DEFINE_OLE1GUID(CLSID_10EmbedObj,        0x00030024, 0, 0, "OLE2_Embedded_Link");

// test app ClTest.  Doesn't really work as a server but is in reg db
DEFINE_OLE1GUID(CLSID_ClTest,            0x00030025, 0, 0, "Cltest");

// Microsoft ClipArt Gallery   Sherry Larsen-Holmes
DEFINE_OLE1GUID(CLSID_MS_ClipArt_Gallery,0x00030026, 0, 0, "MS_ClipArt_Gallery");

// Microsoft Project  Cory Reina
DEFINE_OLE1GUID(CLSID_MSProject,         0x00030027, 0, 0, "MSProject");

// Microsoft Works Chart
DEFINE_OLE1GUID(CLSID_MSWorksChart,      0x00030028, 0, 0, "MSWorksChart");

// Microsoft Works Spreadsheet
DEFINE_OLE1GUID(CLSID_MSWorksSpreadsheet,0x00030029, 0, 0, "MSWorksSpreadsheet");

// AFX apps - Dean McCrory
DEFINE_OLE1GUID(CLSID_MinSvr,            0x0003002A, 0, 0, "MinSvr");
DEFINE_OLE1GUID(CLSID_HierarchyList,     0x0003002B, 0, 0, "HierarchyList");
DEFINE_OLE1GUID(CLSID_BibRef,            0x0003002C, 0, 0, "BibRef");
DEFINE_OLE1GUID(CLSID_MinSvrMI,          0x0003002D, 0, 0, "MinSvrMI");
DEFINE_OLE1GUID(CLSID_TestServ,          0x0003002E, 0, 0, "TestServ");

// Ami Pro
DEFINE_OLE1GUID(CLSID_AmiProDocument,    0x0003002F, 0, 0, "AmiProDocument");

// WordPerfect Presentations For Windows
DEFINE_OLE1GUID(CLSID_WPGraphics,       0x00030030, 0, 0, "WPGraphics");
DEFINE_OLE1GUID(CLSID_WPCharts,         0x00030031, 0, 0, "WPCharts");


// MicroGrafx Charisma
DEFINE_OLE1GUID(CLSID_Charisma,         0x00030032, 0, 0, "Charisma");
DEFINE_OLE1GUID(CLSID_Charisma_30,      0x00030033, 0, 0, "Charisma_30");
DEFINE_OLE1GUID(CLSID_CharPres_30,      0x00030034, 0, 0, "CharPres_30");

// MicroGrafx Draw
DEFINE_OLE1GUID(CLSID_Draw,             0x00030035, 0, 0, "Draw");

// MicroGrafx Designer
DEFINE_OLE1GUID(CLSID_Designer_40,      0x00030036, 0, 0, "Designer_40");


#undef DEFINE_OLE1GUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\array_fv.h ===
#ifndef __ARRAY_FV_H__
#define __ARRAY_FV_H__

////////////////////////////////////////////////////////////////////////////
// class CArrayFValue - an array containing fixed size elements,
//
////////////////////////////////////////////////////////////////////////////


class FAR CArrayFValue
{
public:

// Construction
        CArrayFValue(UINT cbValue);
        ~CArrayFValue();

// Attributes
        int     GetSize() const
                                { return m_nSize; }
        int     GetUpperBound() const
                                { return m_nSize-1; }
        BOOL    SetSize(int nNewSize, int nGrowBy = -1);
        int             GetSizeValue() const
                                { return m_cbValue; }

// Operations
        // Clean up
        void    FreeExtra();
        void    RemoveAll()
                                { SetSize(0); }

        // return pointer to element; index must be in range
#ifdef _DEBUG
        // with debug checks
        LPVOID   GetAt(int nIndex) const
                                { return _GetAt(nIndex); }
#else
        // no debug checks
        LPVOID   GetAt(int nIndex) const
                                { return &m_pData[nIndex * m_cbValue]; }
#endif
        LPVOID   _GetAt(int nIndex) const;

        // set element; index must be in range
        void    SetAt(int nIndex, LPVOID pValue);

        // find element given part of one; offset is offset into value; returns
        // -1 if element not found; use IndexOf(NULL, cb, offset) to find zeros;
        // will be optimized for appropriate value size and param combinations
        int             IndexOf(LPVOID pData, UINT cbData, UINT offset);

        // set/add element; Potentially growing the array; return FALSE/-1 if
        // not possible (due to OOM)
        BOOL    SetAtGrow(int nIndex, LPVOID pValue);

        // Operations that move elements around
        BOOL    InsertAt(int nIndex, LPVOID pValue, int nCount = 1);
        void    RemoveAt(int nIndex, int nCount = 1);

        void    AssertValid() const;

// Implementation
private:
        BYTE FAR*   m_pData;    // the actual array of data
        UINT    m_cbValue;              // size of each value (in bytes)
        int     m_nSize;        // current # of elements (m_cbValue bytes in length)
        int     m_nMaxSize;     // max # of elements (m_cbValue bytes in length)
        int     m_nGrowBy;      // grow amount (in # elements)
};


#endif // !__ARRAY_FV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\assrtdlg.h ===
#define AssertFail                  5100
#define Expr                        5101
#define Location                    5102
#define ASSRT_ID_BREAK                     5103
#define ASSRT_ID_EXIT                      5104
#define ASSRT_ID_IGNORE                    5105
#define ASSRT_ID_LOC                       5106
#define ASSRT_ID_EXPR                      5107
#define ASSRT_ID_MSG                5108
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\callinfo.h ===
#ifndef _CALLINFO_H
#define _CALLINFO_H

//
// Shared information between DDE and LRPC
//
typedef ULONG TIMERID;
typedef ULONG CALLID, FAR * LPCALLID;
//
// the call info holds all information for one particular outgoing call
//
typedef struct tagCallInfo CallInfo, CALLINFO, FAR* LPCALLINFO;

struct tagCallInfo {
	UINT	m_id;			// this is the callinfo id for the table lookup
	HWND 	m_hwndSvr;		// window of callee
	HWND 	m_hwndCli;		// window of caller
	BOOL 	m_fWait;       	// wait for acknowledge
	BOOL 	m_fRejected;   	// call was rejected
	DWORD 	m_dwServerCall; // set by HIC, passed to RetryRejectedCall (ack/busyack/nak/error)
	HRESULT m_hresult;		// the return value of this loop	
	
	// info to retry the call
	WORD  	m_wMsg;			
	WPARAM 	m_wParam;		
	LPARAM 	m_lParam;    	
	
	// timer status for this callinfo
	WORD 	m_wTimer;
	
	// Note: Call State
	// here we remember the current call state we are in
	// if the call was at the 'root' level the call state is 0
	// REVIEW: this is not ready yet and used to detect if we call
	// 	out on an external call.
	DWORD 	m_dwCallState;

	//
	// internaly used to manage multiple
 	LONG		m_lid;
	LPVOID		m_pData;
	LPCALLINFO	m_pCINext;
};

//
// The origin of RunModalLoop is needed for the priority of message.
// If call by LRPC, lrpc messages are peeked first.
//
typedef enum tagCALLORIGIN {
	CALLORIGIN_LRPC = 1,
	CALLORIGIN_DDE  = 2,
} CALLORIGIN;

// function used by DDE and LRPC
STDAPI CoRunModalLoop (LPCALLINFO pCI, WORD wOrigin);
STDAPI_(DWORD) CoHandleIncomingCall( HWND hwndCaller, WORD wCallType, LPINTERFACEINFO lpIfInfo = NULL);
STDAPI_(DWORD) CoSetAckState(LPCALLINFO pCI, BOOL fWait, BOOL fRejected = FALSE, DWORD dwServerCall = 0);

#endif // _CALLINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\cevent.cxx ===
//+-------------------------------------------------------------------
//
//  File:	cevent.cxx
//
//  Contents:	Implementation of classes handling win32 events
//
//  Functions:	CEvent::CEvent -- constructor for event object
//		CEvent::~CEvent -- destructor for event object
//		CEvent::Signal -- signals the event
//		CEvent::Wait -- waits for the event to be signaled
//		CEvent::GetName -- returns the name of the event
//
//  History:	27-Jul-92   Rickhi  Created
//              31-Dec-93   ErikGav Chicago port
//
//--------------------------------------------------------------------

#include    <ole2int.h>
#include    <secdes.hxx>
#include    <cevent.hxx>

//+-------------------------------------------------------------------------
//
//  Member:	CEvent::CEvent
//
//  Synopsis:	Constructor for event object.  This version of the ctor
//		creates an event of the given name.  The event will be
//		in the non-signaled state, ready to be blocked on via the
//		Wait() method.
//
//  Arguments:	[pwszService] -- name of executable to run
//		[cSerial] -- serial number for this event
//
//  Signals:	CException if the event creation failed
//
//  Returns:	nothing
//
//  History:	27-Jul-92 Rickhi    Created
//              07-Jan-94 AlexT     No security for Chicago
//		13-Jun-95 SusiA	    ANSI optimization for Chicago
//
//--------------------------------------------------------------------------

#ifdef _CHICAGO_
#undef CreateEvent
#define CreateEvent CreateEventA
#undef OpenEvent
#define OpenEvent OpenEventA
#endif //_CHICAGO_

CEvent::CEvent(LPTSTR   ptszEventName,
               HRESULT& hr,
               BOOL     fManualReset) : _hdl(NULL)

{
    // Assume this works
    hr = S_OK;

    // Just try to create the event - if it already exists the create
    // function still succeeds

#ifndef _CHICAGO_
    CWorldSecurityDescriptor secd;
#endif

    //  Security attributes needed by CreateEvent
    SECURITY_ATTRIBUTES secattr;

    secattr.nLength = sizeof(secattr);
#ifdef _CHICAGO_
    secattr.lpSecurityDescriptor = NULL;
#else
    secattr.lpSecurityDescriptor = (PSECURITY_DESCRIPTOR) secd;
#endif
    secattr.bInheritHandle = FALSE;

    _hdl = CreateEvent(&secattr,	    // all/anyone access
                       fManualReset,        // manual reset
                       FALSE,	            // initially not signaled
                       ptszEventName);      // name of the event

    if (_hdl == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
}




//+-------------------------------------------------------------------------
//
//  Member:	CEvent::Wait
//
//  Synopsis:	Waits for the event to be signalled.
//
//  Arguments:	[ulTimeOut] -- max time to wait for the event to be signaled
//			       A value of -1 means wait for ever.
//
//  Returns:	0 -- event was signalled
//		WAIT_TIMEOUT -- timed out waiting for the event
//		WAIT_INVALID_HANDLE -- the handle is invalid - should not
//				       be possible!
//
//  History:	27-Jul-92 Rickhi    Created
//
//--------------------------------------------------------------------------

int CEvent::Wait(ULONG	ulTimeOut)
{
    int rc = WaitForSingleObject(_hdl, ulTimeOut);

    // Note. The signal will be auto reset or not depending on the constructor
    // parameter fManualReset which is defaulted to auto reset

    switch (rc)
    {
	case 0:
	case WAIT_TIMEOUT:
	    break;

	default:
	    //	if the rc is not zero or WAIT_TIMEOUT, you have to call
	    //	GetLastError to figure out what it really is.
	    rc = GetLastError();
    }

    return  rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\dbgpopup.cxx ===
//+-------------------------------------------------------------------
//
//  File:	dbgpopup.cxx
//
//  Contents:	Component Object Model debug APIs that popup error msgs
//		on the screen.
//
//  Classes:	None
//
//  Functions:	PopupStringMsg
//		PopupDWORDMsg
//		PopupGUIDMsg
//
//  History:	23-Nov-92   Rickhi	Created
//              31-Dec-93   ErikGav Chicago port
//
//--------------------------------------------------------------------

#include    <ole2int.h>
#include    <dbgpopup.hxx>

#if DBG == 1

//--------------------------------------------------------------------
//
//  Function:	PopupStringMsg
//
//  synopsis:	formats and displays a popup error message. this is
//		used in non-retail builds to display error messages
//		on the screen, in the format of a popup.
//
//  Algorithm:
//
//  History:	23-Nov-92   Rickhi	Created
//
//  Notes:	this API takes a format string and a LPWSTR as parameters.
//
//--------------------------------------------------------------------

extern "C" void PopupStringMsg (char *pfmt, LPWSTR pwszParm)
{
    char szParm[MAX_PATH];
    char outmsg[MAX_PATH];

    //	convert incomming string to ascii
    WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, pwszParm, -1, szParm, MAX_PATH, NULL, NULL);
    wsprintfA (outmsg, pfmt, szParm);
    _Win4Assert( __FILE__, __LINE__, outmsg);
}

//--------------------------------------------------------------------
//
//  Function:	PopupDWORDMsg
//
//  synopsis:	formats and displays a popup error message. this is
//		used in non-retail builds to display error messages
//		on the screen, in the format of a popup.
//
//  Algorithm:
//
//  History:	23-Nov-92   Rickhi	Created
//
//  Notes:	this API takes a format string and a DWORD as parameters.
//
//--------------------------------------------------------------------

extern "C" void PopupDWORDMsg (char *pfmt, DWORD dwParm)
{
    char outmsg[256];

    wsprintfA (outmsg, pfmt, dwParm);
    _Win4Assert( __FILE__, __LINE__, outmsg);
}


//--------------------------------------------------------------------
//
//  Function:	PopupGUIDMsg
//
//  synopsis:	formats and displays a popup error message. this is
//		used in non-retail builds to display error messages
//		on the screen, in the format of a popup.
//
//  Algorithm:
//
//  History:	23-Nov-92   Rickhi	Created
//
//  Notes:	this API takes a mag and a GUID as parameters.
//
//--------------------------------------------------------------------

extern "C" void PopupGUIDMsg (char *msg, GUID guid)
{
    char outmsg[256];

    wsprintfA (outmsg, "%s %08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
	       msg, guid.Data1, guid.Data2, guid.Data3, (int) guid.Data4[0],
	       (int) guid.Data4[1], (int) guid.Data4[2], (int) guid.Data4[3],
	       (int) guid.Data4[4], (int) guid.Data4[5],
	       (int) guid.Data4[6], (int) guid.Data4[7]);

    _Win4Assert( __FILE__, __LINE__, outmsg);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\clskey.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	clskey.cxx
//
//  Contents:	Variable definitions used by class key search and
//		definitions used for exception handling for class key
//		classes.
//
//  History:	21-Apr-93 Ricksa    Created
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <clskey.hxx>

GUID guidCidMax =
  {0xFFFFFFFF,0xFFFF,0xFFFF,{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\longname.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	longname.h
//
//  Contents:	InternalGetLongPathName
//
//  History:	25-Aug-94	DrewB	Created
//
//----------------------------------------------------------------------------

#ifndef __LONGNAME_H__
#define __LONGNAME_H__

#ifdef __cplusplus
extern "C" {
#endif

DWORD 
APIENTRY
InternalGetLongPathNameW(
    IN  LPCWSTR lpszPath,
    IN  LPWSTR  lpszLongPath,
    IN  DWORD   cchBuffer
    );

#ifdef __cplusplus
}
#endif

#endif // #ifndef __LONGNAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\array_id.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CIDArray
{
public:

// Construction
	CIDArray() : m_afv(sizeof(IDENTRY)) { }
	~CIDArray() { }

// Attributes
	int     GetSize() const
				{ return m_afv.GetSize(); }
	int     GetUpperBound() const
				{ return m_afv.GetSize()-1; }
	BOOL    SetSize(int nNewSize, int nGrowBy = -1)
				{ return m_afv.SetSize(nNewSize, nGrowBy); }
	int		GetSizeValue() const
				{ return m_afv.GetSizeValue(); }

// Operations
	// Clean up
	void    FreeExtra()
				{ m_afv.FreeExtra(); }

	void    RemoveAll()
				{ m_afv.SetSize(0); }

	// return pointer to element; index must be in range
	IDENTRY	GetAt(int nIndex) const
				{ return *(IDENTRY FAR*)m_afv.GetAt(nIndex); }
	IDENTRY FAR&   ElementAt(int nIndex)
				{ return (IDENTRY FAR&)*(IDENTRY FAR*)m_afv.GetAt(nIndex); }

	// overloaded operator helpers
	IDENTRY    operator[](int nIndex) const
				{ return GetAt(nIndex); }
	IDENTRY FAR&   operator[](int nIndex)
				{ return ElementAt(nIndex); }

	// get address of first element efficiently
	operator IDENTRY *()	{ return (IDENTRY FAR*)m_afv.GetAt(0); }

	// set element; index must be in range
	void    SetAt(int nIndex, IDENTRY& value)
				{ m_afv.SetAt(nIndex, (LPVOID)&value); }

	// find element given part of one; offset is offset into value; returns
	// -1 if element not found; use IndexOf(NULL, cb, offset) to find zeros;
	// will be optimized for appropriate value size and param combinations
	int		IndexOf(LPVOID pData, UINT cbData, UINT offset)
				{ return m_afv.IndexOf(pData, cbData, offset); }

	// set/add element; Potentially growing the array; return FALSE/-1 if
	// not possible (due to OOM)
	BOOL    SetAtGrow(int nIndex, IDENTRY& value)
				{ return m_afv.SetAtGrow(nIndex, (LPVOID)&value); }
	int     Add(IDENTRY& value)
				{ int nIndex = GetSize();
				  return SetAtGrow(nIndex, value) ? nIndex : -1;
				}

	// Operations that move elements around
	BOOL    InsertAt(int nIndex, IDENTRY& value, int nCount = 1)
				{ return m_afv.InsertAt(nIndex, (LPVOID)&value, nCount); }
	void    RemoveAt(int nIndex, int nCount = 1)
				{ m_afv.RemoveAt(nIndex, nCount); }

	void    AssertValid() const
				{ m_afv.AssertValid(); }

// Implementation
private:
	CArrayFValue m_afv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\ole2int.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       ole2int.h
//
//  Contents:   internal ole2 header
//
//  Notes:      This is the internal ole2 header, which means it contains those
//              interfaces which might eventually be exposed to the outside
//              and which will be exposed to our implementations. We don't want
//              to expose these now, so I have put them in a separate file.
//
//  History:    12-27-93   ErikGav   Include uniwrap.h for Chicago builds
//
//----------------------------------------------------------------------------

#if !defined( _OLE2INT_H_ )
#define _OLE2INT_H_

// -----------------------------------------------------------------------
// System Includes
// -----------------------------------------------------------------------
//
//  Prevent lego errors under Chicago.
//
#if defined(_CHICAGO_)
#define _CTYPE_DISABLE_MACROS
#undef  ASSERT
#define ASSERT(x)  Win4Assert(x)
#endif

#ifndef _CHICAGO_
// For TLS on Nt we use a reserved DWORD in the TEB directly. We need these
// include files to get the macro NtCurrentTeb(). They must be included
// before windows.h
extern "C"
{
#include <nt.h>         // NT_PRODUCT_TYPE
#include <ntdef.h>      // NT_PRODUCT_TYPE
#include <ntrtl.h>      // NT_PRODUCT_TYPE
#include <nturtl.h>     // NT_PRODUCT_TYPE
#include <windef.h>     // NT_PRODUCT_TYPE
#include <winbase.h>    // NT_PRODUCT_TYPE
}
#endif  // _CHICAGO_

#include <wchar.h>
#include <StdLib.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>

// Cairo builds use DBG==1; old OLE2 code used _DEBUG
#if DBG == 1
#define _DEBUG
#endif


// Guarantee that WIN32 is defined.
#ifndef WIN32
#define WIN32 100
#endif


#ifdef WIN32
#include <pcrt32.h>
#endif // WIN32

#include <windows.h>
#include <olecom.h>
#include <malloc.h>
#include <shellapi.h>


// -----------------------------------------------------------------------
// Debug Aids
// -----------------------------------------------------------------------

#define ComDebOut   CairoleDebugOut

#if DBG==1

#include    <debnot.h>

//  recast the user mode debug flags to meaningfull names. These are
//  used in xDebugOut calls.
#define DEB_DLL         0x0008          // DLL Load/Unload
#define DEB_CHANNEL     DEB_USER1       // rpc channel
#define DEB_DDE         DEB_USER2       // dde
#define DEB_CALLCONT    DEB_USER3       // call control & msg filter
#define DEB_MARSHAL     DEB_USER4       // interface marshalling
#define DEB_SCM         DEB_USER5       // rpc calls to the SCM
#define DEB_ROT         DEB_USER6       // running object table
#define DEB_ACTIVATE    DEB_USER7       // object activation
#define DEB_OXID        DEB_USER8       // OXID stuff
#define DEB_REG         DEB_USER9       // registry calls
#define DEB_COMPOBJ     DEB_USER10      // misc compobj
#define DEB_MEMORY      DEB_USER11      // memory allocations
#define DEB_RPCSPY      DEB_USER12      // rpc spy to debug output
#define DEB_MFILTER     DEB_USER13      // message filter
#define DEB_ENDPNT      DEB_USER13      // endpoint stuff
#define DEB_PAGE        DEB_USER14      // page allocator
#define DEB_APT         DEB_USER15      // neutral apartment

#define ComDebErr(failed, msg)  if (failed) { ComDebOut((DEB_ERROR, msg)); }

#else   // DBG

#define ComDebErr(failed, msg)

#endif  // DBG


#ifdef DCOM
//-------------------------------------------------------------------
//
//  class:      CDbgGuidStr
//
//  Synopsis:   Class to convert guids to strings in debug builds for
//              debug outs
//
//--------------------------------------------------------------------
class CDbgGuidStr
{
public:
    ~CDbgGuidStr() {}
#if DBG==1
    CDbgGuidStr(REFGUID rguid) { StringFromGUID2(rguid, _wszGuid, 40); }
    WCHAR _wszGuid[40];
#else
    CDbgGuidStr(REFGUID rguid) {}
#endif
};
#endif


// -----------------------------------------------------------------------
// Public Includes
// -----------------------------------------------------------------------
#include <ole2.h>
#include <ole2sp.h>
#include <ole2com.h>


// -----------------------------------------------------------------------
// Apartment Activator Handle
// -----------------------------------------------------------------------

typedef DWORD HActivator;

// -----------------------------------------------------------------------
// Internal Includes
// -----------------------------------------------------------------------
#include <utils.h>
#include <olecoll.h>
#include <valid.h>
#include <array_fv.h>
#include <map_kv.h>
#include <privguid.h>
#include <tls.h>
#include <tracelog.hxx>
#include <memapi.hxx>
#include <ccapi.hxx>


// Macros for character string pointer manipulation

#ifdef _MAC
#define IncLpch IncLpch
#define DecLpch DecLpch
#else
// Beware of double evaluation
// Some components are not UNICODE enabled.
#define IncLpch(sz)          ((sz)=CharNextW ((sz)))
#define DecLpch(szStart, sz) ((sz)=CharPrevW ((szStart),(sz)))
#endif



//
// This function is shared between the DDE layer and the ROT
//

HRESULT GetLocalRunningObjectForDde(LPOLESTR    lpstrPath,
                                    LPUNKNOWN * ppunkObject);



// -----------------------------------------------------------------------
// Activation Externs
// -----------------------------------------------------------------------

#include <olerem.h>
#include <iface.h>

// Internal COM Init/Uninit routines
INTERNAL wCoInitializeEx(COleTls &Tls, DWORD flags);
INTERNAL InitializeNTA();
INTERNAL_(void) wCoUninitialize(COleTls &Tls, BOOL fHostThread);

// Main thread Init/Uninit routines
HRESULT InitMainThreadWnd(void);
void UninitMainThreadWnd(void);

// Process uninit routine
HRESULT RegisterOleWndClass(void);
void UnRegisterOleWndClass(void);

// Main thread window handle and TID
extern HWND  ghwndOleMainThread;
extern DWORD gdwMainThreadId;

// called by marshaling code on first marshal/last release of ICF interface
INTERNAL_(BOOL) NotifyActivation(BOOL fLock, IUnknown *pUnk);

// flag value used by the Activation ObjServer in ServerGetClassObject
const DWORD MSHLFLAGS_NOTIFYACTIVATION = 0x80000000;


// global count of per-process COM initializations
extern DWORD g_cProcessInits;


// Messages on OLE windows. RPC MSWMSG uses other values too.
// Messages Sent/Posted by OLE should have the magic value in WPARAM as this
// is used by USER32 to enable/diable SetForegroundWindow. The magic value is
// also in  ntuser\kernel\userk.h.
const DWORD WMSG_MAGIC_VALUE      = 0x0000babe;

const UINT WM_OLE_ORPC_POST      = (WM_USER + 0);
const UINT WM_OLE_ORPC_SEND      = (WM_USER + 1);
const UINT WM_OLE_ORPC_DONE      = (WM_USER + 2);
const UINT WM_OLE_ORPC_RELRIFREF = (WM_USER + 3);
const UINT WM_OLE_ORPC_NOTIFY    = (WM_USER + 4);
const UINT WM_OLE_GETCLASS       = (WM_USER + 5);
const UINT WM_OLE_GIP_REVOKE     = (WM_USER + 6);
const UINT WM_OLE_SIGNAL         = (WM_USER + 7);


LRESULT OleMainThreadWndProc(HWND hWnd, UINT message,
                             WPARAM wParam, LPARAM lParam);

extern DWORD gdwScmProcessID;

#ifdef _CHICAGO_
// Chicago presents this new interface for internal use
STDAPI CoCreateAlmostGuid(GUID *pGuid);

extern "C"
{
    WINBASEAPI BOOL WINAPI InitializeCriticalSectionAndSpinCount(
        IN OUT LPCRITICAL_SECTION lpCriticalSection,
        IN DWORD dwSpinCount
    );

    inline BOOL WINAPI IsProcessRestricted()    { return FALSE; }
}
#endif


// -----------------------------------------------------------------------
// ORPC Externs
// -----------------------------------------------------------------------

#include <sem.hxx>
#include <olesem.hxx>

// functions for thread-safe Release
const DWORD CINDESTRUCTOR = 0x80000000;
INTERNAL_(BOOL) InterlockedDecRefCnt(ULONG *pcRefs, ULONG *pcNewRefs);
INTERNAL_(BOOL) InterlockedRestoreRefCnt(ULONG *pcRefs, ULONG *pcNewRefs);


extern COleStaticMutexSem g_mxsSingleThreadOle;

STDAPI_(BOOL) ThreadNotification(HINSTANCE, DWORD, LPVOID);
STDAPI        ChannelRegisterProtseq(WCHAR *pwszProtseq);

STDAPI        ChannelProcessInitialize  ();
STDAPI        ChannelThreadInitialize   ();
STDAPI_(void) ChannelProcessUninitialize( void );
STDAPI_(void) ChannelThreadUninitialize ( void );
STDAPI_(BOOL) ThreadStop                ( BOOL fHostThread );

STDAPI_(void) ObjactThreadUninitialize(void);

INTERNAL_(void) CleanupThreadCallObjects(SOleTlsData *pTls);
INTERNAL_(void) IDTableThreadUninitialize(void);
INTERNAL_(void) IDTableProcessUninitialize(void);

#ifdef DCOM
extern BOOL gSpeedOverMem;
#else
STDAPI_(void) ChannelStopListening(void);
STDAPI        ChannelControlProcessInitialize(void);
STDAPI_(void) ChannelControlThreadUninitialize(void);
STDAPI_(void) ChannelControlProcessUninitialize(void);
#endif

HRESULT CacheCreateThread( LPTHREAD_START_ROUTINE fn, void *param );

#ifdef DCOM
// -----------------------------------------------------------------------
// Marshalling Externs
// -----------------------------------------------------------------------

// internal subroutines used by COXIDTable ResolveOXID and GetLocalEntry.
INTERNAL MarshalInternalObjRef  (OBJREF &objref, REFIID riid, void *pv,
                                 DWORD mshlflags, void **ppStdId);
INTERNAL MarshalObjRef          (OBJREF &objref, REFIID riid, LPVOID pv,
                                 DWORD mshlflags, DWORD dwDestCtx, void *pvDestCtx);
INTERNAL UnmarshalInternalObjRef(OBJREF &objref, void **ppv);
INTERNAL UnmarshalObjRef        (OBJREF &objref, void **ppv, BOOL fBypassActLock = FALSE);
INTERNAL ReleaseMarshalObjRef   (OBJREF &objref);

// internal routines used by Drag & Drop
INTERNAL_(void) FreeObjRef       (OBJREF &objref);
INTERNAL        CompleteObjRef   (OBJREF &objref, OXID_INFO &oxidInfo, REFIID riid, BOOL *pfLocal);
INTERNAL        FillLocalOXIDInfo(OBJREF &objref, OXID_INFO &oxidInfo);

// internal subroutine used by CRpcResolver
INTERNAL InitChannelIfNecessary();

// Internal routines used by objact
BOOL     CheckObjactAccess();
INTERNAL HandleIncomingCall(REFIID riid, WORD iMethod, DWORD CallCatIn, void *pv);
INTERNAL NTAChannelInitialize();

// Internal routines used by ComDllGetClassObject
INTERNAL GetGIPTblCF(REFIID riid, void **ppv);


#endif  // DCOM

// -----------------------------------------------------------------------
// Access Control Externs
// -----------------------------------------------------------------------

HRESULT ComDllGetClassObject     ( REFCLSID clsid, REFIID riid, void **ppv );
HRESULT InitializeAccessControl  ();
void    UninitializeAccessControl();

// -----------------------------------------------------------------------
// Neutral Apartment
// -----------------------------------------------------------------------
INTERNAL_(void) CleanUpApartmentObject();

// Cached exe file name and length
extern WCHAR gawszImagePath[];
extern DWORD gcImagePath;

//
// Definitions used in Win64 to fix up SECURITY_DESCRIPTOR problems
//
#ifdef _WIN64
#define OLE2INT_ROUND_UP( x, y )  ((size_t)(x) + ((y)-1) & ~((y)-1))
#endif


#endif  // _OLE2INT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\map_gp.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapGUIDToPtr
{
public:
	// Construction
	CMapGUIDToPtr(DWORD memctx = MEMCTX_SAME, UINT nBlockSize=10) 
		: m_mkv(memctx, sizeof(void FAR*), sizeof(GUID), nBlockSize) { }

	// Attributes
	// number of elements
	int     GetCount() const
				{ return m_mkv.GetCount(); }
	BOOL    IsEmpty() const
				{ return GetCount() == 0; }

	// Lookup
	BOOL    Lookup(REFGUID key, void FAR* FAR& value) const
				{ return m_mkv.Lookup((LPVOID)&key, sizeof(GUID), (LPVOID)&value); }

	BOOL    LookupHKey(HMAPKEY hKey, void FAR* FAR& value) const
				{ return m_mkv.LookupHKey(hKey, (LPVOID)&value); }

	BOOL    LookupAdd(REFGUID key, void FAR* FAR& value) const
				{ return m_mkv.LookupAdd((LPVOID)&key, sizeof(GUID), (LPVOID)&value); }

	// Add/Delete
	// add a new (key, value) pair
	BOOL    SetAt(REFGUID key, void FAR* value)
				{ return m_mkv.SetAt((LPVOID)&key, sizeof(GUID), (LPVOID)&value); }
	BOOL    SetAtHKey(HMAPKEY hKey, void FAR* value)
				{ return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

	// removing existing (key, ?) pair
	BOOL    RemoveKey(REFGUID key)
				{ return m_mkv.RemoveKey((LPVOID)&key, sizeof(GUID)); }

	BOOL    RemoveHKey(HMAPKEY hKey)
				{ return m_mkv.RemoveHKey(hKey); }

	void    RemoveAll()
				{ m_mkv.RemoveAll(); }


	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
				{ return m_mkv.GetStartPosition(); }

	void    GetNextAssoc(POSITION FAR& rNextPosition, GUID FAR& rKey, void FAR* FAR& rValue) const
				{ m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&rKey, NULL, (LPVOID)&rValue); }

	HMAPKEY GetHKey(REFGUID key) const
				{ return m_mkv.GetHKey((LPVOID)&key, sizeof(GUID)); }

#ifdef _DEBUG
	void    AssertValid() const
				{ m_mkv.AssertValid(); }
#endif

private:
	CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\map_sp.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapStringToPtr : public CPrivAlloc
{
public:
	// Construction
	CMapStringToPtr(UINT nBlockSize=10)
		: m_mkv(sizeof(void FAR*), 0, nBlockSize) { }

	// Attributes
	// number of elements
	int     GetCount() const
				{ return m_mkv.GetCount(); }
	BOOL    IsEmpty() const
				{ return GetCount() == 0; }

	// Lookup
	BOOL	Lookup(LPWSTR pKey, void FAR* FAR& value) const
				{ return m_mkv.Lookup(pKey, lstrlenW(pKey)*sizeof(WCHAR), &value); }

	BOOL    LookupHKey(HMAPKEY hKey, void FAR* FAR& value) const
				{ return m_mkv.LookupHKey(hKey, &value); }

	BOOL	LookupAdd(LPWSTR pKey, void FAR* FAR& value) const
				{ return m_mkv.LookupAdd(pKey, lstrlenW(pKey)*sizeof(WCHAR), &value); }


	// Add/Delete
	// add a new (key, value) pair
	BOOL	SetAt(LPWSTR pKey, void FAR* value)
				{ return m_mkv.SetAt(pKey, lstrlenW(pKey)*sizeof(WCHAR), (LPVOID)&value); }
	BOOL    SetAtHKey(HMAPKEY hKey, void FAR* value)
				{ return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

	// removing existing (key, ?) pair
	BOOL	RemoveKey(LPWSTR pKey)
				{ return m_mkv.RemoveKey(pKey, lstrlenW(pKey)*sizeof(WCHAR)); }

	BOOL    RemoveHKey(HMAPKEY hKey)
				{ return m_mkv.RemoveHKey(hKey); }

	void    RemoveAll()
				{ m_mkv.RemoveAll(); }


	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
				{ return m_mkv.GetStartPosition(); }

	void	GetNextAssoc(POSITION FAR& rNextPosition, LPWSTR FAR& pKey, void FAR* FAR& rValue) const
				{ m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&pKey, NULL, (LPVOID)&rValue); }

	HMAPKEY GetHKey(LPWSTR pKey) const
				{ return m_mkv.GetHKey(pKey, lstrlenW(pKey)*sizeof(WCHAR)); }

#ifdef _DEBUG
	void    AssertValid() const
				{ m_mkv.AssertValid(); }
#endif

private:
	CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\olecom.h ===
//+-------------------------------------------------------------------
//
//  File:	olecom.hxx
//
//  Contents:	General includes for common library in ole\src project
//
//  Classes:	None
//
//  Functions:	None.
//
//  History:	06-Jan-92   Rickhi	Created
//
//--------------------------------------------------------------------
#ifndef __OLECOM_H__
#define __OLECOM_H__

// Need for debugging headers
#include    <except.hxx>


#if DBG==1
extern "C" void brkpt(void);
#endif

#if DBG==1
DECLARE_DEBUG(ClsCache)

#define ClsCacheDebugOut(x) ClsCacheInlineDebugOut x
#define ClsCacheAssert(x) Win4Assert(x)
#define ClsCacheVerify(x) Win4Assert(x)

#else

#define ClsCacheDebugOut(x)
#define ClsCacheAssert(x)
#define ClsCacheVerify(x) (x)

#endif // DBG

#if DBG==1
DECLARE_DEBUG(RefCache)

#define RefCacheDebugOut(x) RefCacheInlineDebugOut x
#define RefCacheAssert(x) Win4Assert(x)
#define RefCacheVerify(x) Win4Assert(x)

#else

#define RefCacheDebugOut(x)
#define RefCacheAssert(x)
#define RefCacheVerify(x) (x)

#endif // DBG

#if DBG==1
DECLARE_DEBUG(Call)

#define CallDebugOut(x) CallInlineDebugOut x
#define CallAssert(x) Win4Assert(x)
#define CallVerify(x) Win4Assert(x)

#else

#define CallDebugOut(x)
#define CallAssert(x)
#define CallVerify(x) (x)

#endif // DBG

#if DBG==1
DECLARE_DEBUG(Cairole)

#define CairoleDebugOut(x) CairoleInlineDebugOut x
#define CairoleAssert(x) Win4Assert(x)
#define CairoleVerify(x) Win4Assert(x)

#else

#define CairoleDebugOut(x)  { }
#define CairoleAssert(x)
#define CairoleVerify(x) (x)

#endif // DBG

#if DBG==1
DECLARE_DEBUG(intr)

#define intrDebugOut(x) intrInlineDebugOut x
#define intrAssert(x) Win4Assert(x)
#define intrVerify(x) Win4Assert(x)

#else

#define intrDebugOut(x)
#define intrAssert(x)
#define intrVerify(x) (x)

#endif // DBG

#if DBG==1
DECLARE_DEBUG(Context)

#define ContextDebugOut(x) ContextInlineDebugOut x
#define ContextAssert(x) Win4Assert(x)
#define ContextVerify(x) Win4Assert(x)

extern "C" void brkpt(void);

#else

#define ContextDebugOut(x) { }
#define ContextAssert(x)
#define ContextVerify(x) (x)

#endif // DBG

#endif // __OLECOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\olereg.h ===
/*	olereg.h

	Registration database helper functions
   Jason Fuller (jasonful)  16-November-1992

   These functions are candidates for export

*/

FARINTERNAL OleRegGetUserType
	(REFCLSID 	clsid,
	DWORD		 	dwFormOfType,
	LPWSTR FAR*	pszUserType)
;


FARINTERNAL OleRegGetMiscStatus
	(REFCLSID	clsid,
	DWORD			dwAspect,
	DWORD FAR*	pdwStatus)
;

FARINTERNAL OleRegEnumFormatEtc
	(REFCLSID clsid,
	DWORD 	  dwDirection,
	LPENUMFORMATETC FAR* ppenum)
;

FARINTERNAL OleRegEnumVerbs
	(REFCLSID clsid,
	LPENUMOLEVERB FAR* ppenum)
;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\pathkey.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	pathkey.cxx
//
//  Contents:	static definitions used by string key class
//
//  History:	09-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    "pathkey.hxx"

//+-------------------------------------------------------------------------
//
//  Member:	CPathBaseKey::CPathBaseKey
//
//  Synopsis:	Construct key from path
//
//  Arguments:	[pwszPath] - path to use for the key
//
//  History:	09-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------

CPathBaseKey::CPathBaseKey(const WCHAR *pwszPath)
{
    _cPath = (lstrlenW(pwszPath) + 1) * sizeof(WCHAR);
    _pwszPath = (WCHAR *) PrivMemAlloc(_cPath);

    // Check for out of memory
    if (_pwszPath != NULL)
    {
        // Copy in path
        memcpy(_pwszPath, pwszPath, _cPath);
    }
    else
    {
	CairoleDebugOut((DEB_ERROR,
		     "CPathBaseKey::CPathBaseKey Alloc of path failed\n"));
	_cPath = 0;
    }
#if DBG==1
    _ulSig = PATHBASEKEYSIG;
#endif
}

//+-------------------------------------------------------------------------
//
//  Member:	CPathBaseKey::CPathBaseKey
//
//  Synopsis:	Construct key from another key
//
//  Arguments:	[pwszPath] - path to use for the key
//
//  History:	09-May-93 Ricksa    Created
//
//  Notes:	We must explicitly define the copy constructor
//		because of the current implementation of exception
//		handling.
//
//--------------------------------------------------------------------------

CPathBaseKey::CPathBaseKey(const CPathBaseKey& cpthbky)
{
    _cPath = cpthbky._cPath;
    _pwszPath = (WCHAR *) PrivMemAlloc(_cPath);

    // Check for out of memory
    if (_pwszPath != NULL)
    {
        memcpy(_pwszPath, cpthbky._pwszPath, cpthbky._cPath);
    }
    else
    {
	CairoleDebugOut((DEB_ERROR,
		    "CPathBaseKey::CPathBaseKey Alloc of path failed\n"));
	_cPath = 0;
    }
#if DBG==1
    _ulSig = PATHBASEKEYSIG;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\map_dwp.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapDwordPtr : public CPrivAlloc
{
public:
	// Construction
	CMapDwordPtr(UINT nBlockSize=10)
		: m_mkv(sizeof(void FAR*), sizeof(DWORD), nBlockSize) { }

	// Attributes
	// number of elements
	int     GetCount() const
				{ return m_mkv.GetCount(); }
	BOOL    IsEmpty() const
				{ return GetCount() == 0; }

	// Lookup
	BOOL    Lookup(DWORD key, void FAR* FAR& value) const
				{ return m_mkv.Lookup((LPVOID)&key, sizeof(DWORD), (LPVOID)&value); }

	BOOL    LookupHKey(HMAPKEY hKey, void FAR* FAR& value) const
				{ return m_mkv.LookupHKey(hKey, (LPVOID)&value); }

	BOOL    LookupAdd(DWORD key, void FAR* FAR& value) const
				{ return m_mkv.LookupAdd((LPVOID)&key, sizeof(DWORD), (LPVOID)&value); }

	// Add/Delete
	// add a new (key, value) pair
	BOOL    SetAt(DWORD key, void FAR* value)
				{ return m_mkv.SetAt((LPVOID)&key, sizeof(DWORD), (LPVOID)&value); }
	BOOL    SetAtHKey(HMAPKEY hKey, void FAR* value)
				{ return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

	// removing existing (key, ?) pair
	BOOL    RemoveKey(DWORD key)
				{ return m_mkv.RemoveKey((LPVOID)&key, sizeof(DWORD)); }

	BOOL    RemoveHKey(HMAPKEY hKey)
				{ return m_mkv.RemoveHKey(hKey); }

	void    RemoveAll()
				{ m_mkv.RemoveAll(); }


	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
				{ return m_mkv.GetStartPosition(); }

	void    GetNextAssoc(POSITION FAR& rNextPosition, DWORD FAR& rKey, void FAR* FAR& rValue) const
				{ m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&rKey, NULL, (LPVOID)&rValue); }

	HMAPKEY GetHKey(DWORD key) const
				{ return m_mkv.GetHKey((LPVOID)&key, sizeof(DWORD)); }

#ifdef _DEBUG
	void    AssertValid() const
				{ m_mkv.AssertValid(); }
#endif

private:
	CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\pattbl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:	pattbl.cxx
//
//  Contents:	File pattern to clsid table.
//
//  Classes:	CPatternTbl
//		CScmPatternTbl
//              CProcessPatternTbl
//
//  Functions:	none
//
//  History:	20-May-94   Rickhi	Created
//              12-Dec-94   BruceMa     Support pattern table on Chicago
//              20-Feb-95   BruceMa     Don't pick up file patterns for
//                                      invalid CLSID's
//		26-Sep-96   t-KevinH	Per process pattern table
//
//  CODEWORK:	Should add Docfile pattern in here and create a private
//		storage API that accepts a file handle and returns the
//		clsid so we minimize the Opens in all cases.
//
//----------------------------------------------------------------------------
#include    <ole2int.h>
#include    <pattbl.hxx>



//+-------------------------------------------------------------------------
//
//  function:	Matches
//
//  Synopsis:	checks if the bytes in the buffer match the given pattern
//
//  Arguments:	[pFileBuf] - buffer containing the file data
//		[pEntry]   -
//
//  Returns:	pEntry if found, NULL otherwise.
//
//--------------------------------------------------------------------------
static BOOL Matches(BYTE *pFileBuf, SPatternEntry *pEntry)
{
    //	the pattern bytes follow the mask bytes. they are the same size.
    BYTE *pbMask    = pEntry->abData;
    BYTE *pbPattern = pbMask + pEntry->ulCb;

    for (ULONG iCtr = 0; iCtr < pEntry->ulCb; iCtr++)
    {
	if ((BYTE)(*(pFileBuf + iCtr) & *pbMask) != *pbPattern)
	{
	    return FALSE;
	}

	//  update the mask & pattern bytes
	pbMask++;
	pbPattern++;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  function:	MatchOneEntry
//
//  Synopsis:	Try to match a pattern in a file.
//
//  Arguments:	[hFile] - handle to the file to look in
//		[pBuf] - file buffer
//		[pEntry] - the pattern to match
//		[pfLook] - a flag used by SearchForPattern
//		[plLastOffset] - keeps the last read offset
//		[pulLastCb] - keeps the last read byte count
//
//  Returns:	S_OK if successfull
//
//--------------------------------------------------------------------------
static BOOL MatchOneEntry(HANDLE hFile, BYTE *pBuf, SPatternEntry *pEntry,
			  BOOL *pfLook, LONG *plLastOffset, ULONG *pulLastCb)
{
    if (pEntry->lFileOffset != *plLastOffset ||
	pEntry->ulCb > *pulLastCb)
    {
	// must read part of the file

	DWORD   cbRead = 0;
	DWORD   dwMethod;
	LONG    cbMove;

	if (pEntry->lFileOffset < 0)
	{
	    cbMove = -1;
	    dwMethod = FILE_END;
	}
	else
	{
	    cbMove = 0;
	    dwMethod = FILE_BEGIN;
	}

	*pfLook = FALSE; // assume failure

	if (SetFilePointer(hFile, pEntry->lFileOffset, &cbMove, dwMethod)
	     != 0xffffffff)
	{
	    if (ReadFile(hFile, pBuf, pEntry->ulCb, &cbRead, NULL))
	    {
		//	remember the last read positions
		*plLastOffset = pEntry->lFileOffset;
		*pulLastCb = pEntry->ulCb;
		*pfLook = TRUE;
	    }
	}
    }

    //  compare the patterns
    return *pfLook && Matches(pBuf, pEntry);
}

//+-------------------------------------------------------------------------
//
//  function:	IsValidPattern
//
//  Synopsis:	determines if the pattern entry read from the registry is of
//		a valid format. See ParseEntry for the format.
//
//  Arguments:	[psz] - pattern buffer
//		[cb]  - size of buffer read
//
//  Returns:	TRUE if pattern is valid, FALSE otherwise
//
//--------------------------------------------------------------------------
static BOOL IsValidPattern(LPWSTR psz, LONG cb)
{
    // we must find exactly 3 commas before the end of the string
    // in order for the entry to be of a parseable format.

    ULONG  cCommas = 0;
    LPWSTR pszEnd = psz + (cb / sizeof(WCHAR));

    while (psz < pszEnd && *psz)
    {
	if (*psz == ',')
	    cCommas++;

	psz++;
    }

    return (cCommas == 3) ? TRUE : FALSE;
}

//+-------------------------------------------------------------------------
//
//  function:	SkipToNext
//
//  Synopsis:	skips missing entries in the list and whitespaces
//
//  Arguments:	[sz] - ptr to string
//
//  Returns:	ptr to next entry in the list
//
//--------------------------------------------------------------------------
static LPWSTR SkipToNext(LPWSTR sz)
{
    while (*sz && *sz != ',')
    {
	sz++;
    }

    Assert(*sz == ',');
    sz++;

    while (*sz)
    {
        USHORT CharType[1];

        GetStringTypeW (CT_CTYPE1, sz, 1, CharType);
        if ((CharType[0] & C1_SPACE) == 0) 
        {
            break;
        }
	sz++;
    }

    return sz;
}

//+-------------------------------------------------------------------------
//
//  function:	ToHex
//
//  Synopsis:	converts two characters to a hex byte
//
//  Arguments:	[psz] - ptr to string
//
//  Returns:	the value of the string in hex
//
//--------------------------------------------------------------------------
static BYTE ToHex(LPWSTR psz)
{
    BYTE bMask = 0xFF;
    USHORT CharTypes[2] = {0, 0}; // Init the variable

	//
	// GetStringTypeW can only return failure for invalid args.
	// The only variable argument here is the incoming psz, so
	// we should be OK.  Assert that this thing succeeded.
	//
    BOOL bStatus = GetStringTypeW (CT_CTYPE1, psz, 2, CharTypes);
	Win4Assert(bStatus && "GetStringTypeW failed in ToHex()");

    if (CharTypes[0] & C1_XDIGIT)
    {
		bMask = CharTypes[0] & C1_DIGIT ? *psz - '0' : (BYTE)CharUpperW((LPWSTR)*psz) - 'A' + 10;

		psz++;
		if (CharTypes[1] & C1_XDIGIT)
		{
			bMask *= 16;
			bMask += CharTypes[1] & C1_DIGIT ? *psz - '0' : (BYTE)CharUpperW((LPWSTR)*psz) - 'A' + 10;
			psz++;
		}
    }

    return bMask;
}

//+-------------------------------------------------------------------------
//
//  function:	ParseEntry
//
//  Synopsis:	takes the registry string and parses it into a table entry.
//
//  Arguments:	[psz] - ptr to string from registry
//		[cb]  - size of psz
//		[pEntry] - ptr to pattern table entry
//		[rclsid] - clsid the pattern maps to
//
//  Returns:	TRUE for sucessful parse, FALSE OTHERWISE - pEntry updated
//
//  Notes:	the format of the registry string is...
//		<offset>,<cb>,<mask>,<pattern>
//		where...
//		<offset> and <cb> are decimal unless preceeded by 0x
//		<mask> is optional (not there means use all 1's
//
//--------------------------------------------------------------------------
static BOOL ParseEntry(LPWSTR psz, LONG cb, SPatternEntry *pEntry, REFCLSID rclsid)
{
    // validate the pattern before we attempt to parse it, simplifies
    // error handling in the rest of the routine.
    if	(!IsValidPattern(psz, cb))
	return FALSE;

    //	copy in the clsid
    memcpy(&pEntry->clsid, &rclsid, sizeof(CLSID));

    //	get the file offset
    pEntry->lFileOffset = wcstol(psz, NULL, 0);
    psz = SkipToNext(psz);

    //	get the byte count
    pEntry->ulCb = wcstol(psz, NULL, 0);
    Assert(pEntry->ulCb > 0);

    //	get the mask ptrs
    LPWSTR pszMask = SkipToNext(psz);
    BYTE  *pbMask = pEntry->abData;

    //	get the pattern ptrs
    LPWSTR pszPattern = SkipToNext(pszMask);
    BYTE  *pbPattern = pbMask + pEntry->ulCb;

    //	convert and copy the mask & pattern bytes into the pEntry
    for (ULONG ulCb = pEntry->ulCb; ulCb > 0; ulCb--)
    {
	if (*pszMask == ',')
	{
	    // missing mask means use 0xff
	    *pbMask = 0xff;
	}
	else
	{
	    //	convert the mask string to a byte
	    *pbMask = ToHex(pszMask);
	    pszMask += 2;
	}
	pbMask++;

	//  convert the pattern string to a byte
	*pbPattern = ToHex(pszPattern);
	pbPattern++;
	pszPattern += 2;
    }

    //	compute this entry size, rounded to 8 byte alignment.
    //	Note: the struct has 4 bytes in abData, so the sizeof
    //	returns 4 more than we need.
    pEntry->ulEntryLen = ((sizeof(SPatternEntry) - 4 +
			  (2 * pEntry->ulCb)  + 7) & 0xfff8);

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  member:	CPatternTbl::FindPattern
//
//  Synopsis:	Finds a pattern in a file.
//
//  Arguments:	[hFile] - handle to the file to look in
//		[pclsid] - where to return the clsid
//
//  Returns:	S_OK if successfull
//
//--------------------------------------------------------------------------
HRESULT CPatternTbl::FindPattern(HANDLE hFile, CLSID *pClsid)
{
    if (!IsEmpty())
    {
	return SearchForPattern(hFile, pClsid);
    }
    else
    {
	//  no entry found, and the cache is not full, so return an error.
	return REGDB_E_CLASSNOTREG;
    }
}

//+-------------------------------------------------------------------------
//
//  member:	CPatternTbl::SearchForPattern
//
//  Synopsis:	searches in the file for a know pattern, and returns the
//		CLSID index if found.
//
//  Arguments:	[hFile] - handle to the file to look in
//		[pclsid] - where to return the clsid
//
//  Returns:	pEntry if found, NULL otherwise.
//
//--------------------------------------------------------------------------
HRESULT CPatternTbl::SearchForPattern(HANDLE hFile, CLSID *pClsid)
{
    HRESULT hr = REGDB_E_CLASSNOTREG;
    LONG    lLastOffset = 0;
    ULONG   ulLastCb = 0;
    BYTE    bStackBuf[256];
    BYTE   *pBuf = bStackBuf;

    if (_pTblHdr->cbLargest > sizeof(bStackBuf))
    {
	//  allocate a buffer big enough for largest pattern
	pBuf = (BYTE *) PrivMemAlloc(_pTblHdr->cbLargest);
    }

    //	now grovel through the file looking for a pattern match

    BYTE *pCurr = _pStart;
    BYTE *pEnd	= _pStart + (_pTblHdr->OffsEnd - _pTblHdr->OffsStart);

    while (pCurr < pEnd)
    {
	SPatternEntry *pEntry = (SPatternEntry *)pCurr;
	BOOL fLook = TRUE;

	if (MatchOneEntry(hFile, pBuf, pEntry, &fLook, &lLastOffset, &ulLastCb))
	{
	    //	found a match, return the index of the CLSID
	    memcpy(pClsid, &pEntry->clsid, sizeof(CLSID));
	    hr = S_OK;

	    break;
	}

	//  get the next entry
	pCurr = pCurr + pEntry->ulEntryLen;
    }

    //	free the buffer if we need to
    if (pBuf != bStackBuf)
    {
	PrivMemFree(pBuf);
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  member:	CScmPatternTbl::InitTbl
//
//  Synopsis:	reads the registry entries and converts them to a shared
//		memory table format
//
//  Returns:	S_OK if successfull.
//		E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
HRESULT CScmPatternTbl::InitTbl()
{
    //	allocate local memory in which to build the table
    _pLocTbl = (BYTE *) PrivMemAlloc(PATTBL_GROW_SIZE);
    if (!_pLocTbl)
    {
	return E_OUTOFMEMORY;
    }

    //	cast for simplicity
    STblHdr *pLocTbl = (STblHdr *) _pLocTbl;

    //	initialize the table header
    pLocTbl->ulSize = PATTBL_GROW_SIZE;
    pLocTbl->OffsStart = sizeof(STblHdr);
    pLocTbl->OffsEnd = sizeof(STblHdr);
    pLocTbl->cbLargest = 0;


    //	build the table from the data in the registry
    HKEY hkFileType;

    if (RegOpenKey(HKEY_CLASSES_ROOT, L"FileType",&hkFileType)== ERROR_SUCCESS)
    {
	//  enumerate the clsid's under this key
	WCHAR	szBuf[40];
	DWORD	iClsid = 0;

	while (RegEnumKey(hkFileType, iClsid, szBuf, sizeof(szBuf) / sizeof(WCHAR)) == ERROR_SUCCESS)
	{
	    // ensure this is a valid clsid
	    WCHAR szTemp[MAX_PATH];
	    LONG  cbTemp = sizeof(szTemp);

	    WCHAR szClsid[80];
	    lstrcpyW(szClsid, L"Clsid\\");
	    lstrcatW(szClsid, szBuf);

	    if (RegQueryValue(HKEY_CLASSES_ROOT, szClsid, szTemp, &cbTemp)
		    == ERROR_SUCCESS)
	    {
		// clsid exist, open the key and enumerate the entries.
		HKEY    hkClsid;
                CLSID	clsid;
                BOOL    fValid;

                // Fetch asociated file patterns only if CLSID is valid
		if (GUIDFromString(szBuf, &clsid)  &&
                    RegOpenKey(hkFileType, szBuf, &hkClsid) == ERROR_SUCCESS)
		{

		    //	enumerate the patterns under this clsid
		    WCHAR	szNum[10];
		    DWORD	iPattern = 0;

		    while (RegEnumKey(hkClsid, iPattern, szNum, sizeof(szNum) / sizeof(WCHAR))
                           == ERROR_SUCCESS)
		    {
			// read the registry value and parse the string to
			// create a table entry

			WCHAR szPattern[512];
			LONG cb = sizeof(szPattern);

			if (RegQueryValue(hkClsid, szNum, szPattern, &cb) ==
                            ERROR_SUCCESS)
			{
			    SPatternEntry *pEntry = (SPatternEntry *)
					((BYTE *)_pLocTbl + pLocTbl->OffsEnd);

			    if (ParseEntry(szPattern, cb, pEntry, clsid))
			    {
				// update the table header
				pLocTbl->cbLargest = MAX(pLocTbl->cbLargest,
						     pEntry->ulCb);

				pLocTbl->OffsEnd += pEntry->ulEntryLen;
			    }
			}

			++iPattern;
		    }

		    RegCloseKey(hkClsid);
		}
	    }

	    ++iClsid;
	}

	RegCloseKey(hkFileType);
    }

    //	update the table size to something reasonable. Use the combined size
    //	of all the entries we generated above, plus some padding for
    //	expansion.  We return this size to the caller.

    pLocTbl->ulSize = sizeof(STblHdr) + pLocTbl->OffsEnd;

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Member:	CProcessPatternTbl::CProcessPatternTbl
//
//  Synopsis:	Constructor
//
//  Arguments:	fOk     -       FALSE is initialization failed
//
//  Returns:	-
//
//--------------------------------------------------------------------------
CProcessPatternTbl::CProcessPatternTbl(HRESULT &hr)
{
    // Allocate internal structures
    m_pPatTbl = new CPatternTbl();
    m_pScmPatTbl = new CScmPatternTbl();
    if (m_pPatTbl == NULL  ||  m_pScmPatTbl == NULL)
    {
        hr = E_OUTOFMEMORY;
        return;
    }

    // Read the patterns from the registry
    if (FAILED(hr = m_pScmPatTbl->InitTbl()))
    {
        return;
    }

    // So CPatternTbl can use them
    m_pPatTbl->Initialize(m_pScmPatTbl->GetTbl());

    //Good return
    hr = S_OK;
    return;
}

//+-------------------------------------------------------------------------
//
//  Member:	CProcessPatternTbl::~CProcessPatternTbl
//
//  Synopsis:	Destructor
//
//  Arguments:	-
//
//  Returns:	-
//
//--------------------------------------------------------------------------
CProcessPatternTbl::~CProcessPatternTbl(void)
{
    delete m_pPatTbl;
    delete m_pScmPatTbl;
}

//+-------------------------------------------------------------------------
//
//  Member:	CProcessPatternTbl::IsEmpty
//
//  Synopsis:	Determines if the pattern table is empty
//
//  Arguments:	-
//
//  Returns:	TRUE if table is empty; FALSE otherwise
//
//--------------------------------------------------------------------------
BOOL CProcessPatternTbl::IsEmpty(void)
{
    return m_pPatTbl->IsEmpty();;
}

//+-------------------------------------------------------------------------
//
//  Member:	CProcessPatternTbl::FindPattern
//
//  Synopsis:	Search for byte patterns in the specified file
//
//  Arguments:	hFile   -       Handle of file to search
//              pClsid  -       Where to store the returned CLSID
//
//  Returns:	HRESULT
//
//--------------------------------------------------------------------------
HRESULT CProcessPatternTbl::FindPattern(HANDLE hFile, CLSID *pClsid)
{
    return m_pPatTbl->FindPattern(hFile, pClsid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\rothelp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	rothelp.cxx
//
//  Contents:   Implementation of helpers used by SCM and OLE32
//
//  Functions:  CreateFileMonikerComparisonBuffer
//
//  History:	30-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <rothint.hxx>
#include    <rothelp.hxx>



//+-------------------------------------------------------------------------
//
//  Function:   ScmRotHash
//
//  Synopsis:   Calculate hash value of comparison buffer in the SCM.
//
//  Arguments:  [pbKey] - pointer to buffer
//              [cdwKey] - size of buffer
//              [dwInitHash] - Initial hash value
//
//  Returns:    Hash value for SCM ROT entry.
//
//  History:	30-Jan-95 Ricksa    Created
//              30-Nov-95 BruceMa   Don't let the hash value overflow
//
//  Note:       The 3rd parameter is used only by RunningMoniker which
//              needs to compute partial hashes by path components
//
//--------------------------------------------------------------------------
DWORD ScmRotHash(BYTE *pbKey, DWORD cdwKey, DWORD dwInitHash)
{
    CairoleDebugOut((DEB_ROT, "%p _IN ScmRotHash"
       "( %p , %lx )\n", NULL, pbKey, cdwKey));

    DWORD   dwResult = dwInitHash;

    for (DWORD i = 0; i < cdwKey; i++)
    {
        dwResult *= 3;
        dwResult ^= *pbKey;
        dwResult %= SCM_HASH_SIZE;
        pbKey++;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT ScmRotHash"
       "( %lx )\n", NULL, dwResult % SCM_HASH_SIZE));

    return dwResult;
}







//+-------------------------------------------------------------------------
//
//  Function:   CreateFileMonikerComparisonBuffer
//
//  Synopsis:   Convert a file path to a moniker comparison buffer
//
//  Arguments:  [pwszPath] - path
//              [pbBuffer] - comparison buffer
//              [cdwMaxSize] - maximum size of the comparison buffer
//              [cdwUsed] - number of bytes used in the comparison buffer
//
//  Returns:    NOERROR - comparison buffer successfully created
//              E_OUTOFMEMORY - The buffer was not big enough to hold the data.
//
//  History:	30-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CreateFileMonikerComparisonBuffer(
    WCHAR *pwszPath,
    BYTE *pbBuffer,
    DWORD cdwMaxSize,
    DWORD *pcdwUsed)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CreateFileMonikerComparisonBuffer"
       "( %p , %p , %lx , %p )\n", NULL, pwszPath, pbBuffer, cdwMaxSize,
           pcdwUsed));

    // Assume there will be an error
    HRESULT hr = E_OUTOFMEMORY;
    *pcdwUsed = 0;

    // Cache size needed for path locally. Of course, the "+1" is required
    // for the terminating NUL in the string.
    DWORD cdwPath = (lstrlenW(pwszPath) + 1) * sizeof(WCHAR);

    // Figure out if the buffer is being enough to hold the data.
    DWORD cdwSizeNeeded = sizeof(CLSID) + cdwPath;

    if (cdwSizeNeeded <= cdwMaxSize)
    {
        // Copy in the CLSID for a file moniker
        memcpy(pbBuffer, &CLSID_FileMoniker, sizeof(CLSID_FileMoniker));

        // Copy in the path
        memcpy(pbBuffer + sizeof(CLSID_FileMoniker), pwszPath, cdwPath);

        // Uppercase the path in the comparison buffer
        CharUpperW((WCHAR *) (pbBuffer + sizeof(CLSID_FileMoniker)));

        *pcdwUsed = cdwSizeNeeded;

        hr = NOERROR;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CreateFileMonikerComparisonBuffer"
       "( %lx ) [ %lx ]\n", NULL, hr, *pcdwUsed));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\rotdata.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       rotdata.cxx
//
//  Contents:   Functions supporting building ROT data comparison buffers
//
//  Functions:
//
//  History:    03-Feb-95   Ricksa  Created
//
//----------------------------------------------------------------------------
#include    <ole2int.h>
#include    <rotdata.hxx>




//+---------------------------------------------------------------------------
//
//  Function:   BuildRotDataFromDisplayName
//
//  Synopsis:   Build ROT comparison data from display name
//
//  Arguments:  [pbc] - bind context (optional)
//              [pmk] - moniker to use for display name
//              [pbData] - buffer to put the data in.
//              [cbMax] - size of the buffer
//              [pcbData] - count of bytes used in the buffer
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//  Algorithm:  Build the bind context if necessary. Get the display name.
//              See if there is enough room in the buffer for the display
//              name and the clsid. If there is copy it in.
//
//  History:    03-Feb-95   ricksa  Created
//
// Note:
//
//----------------------------------------------------------------------------
HRESULT BuildRotDataFromDisplayName(
    LPBC pbc,
    IMoniker *pmk,
    BYTE *pbData,
    DWORD cbData,
    DWORD *pcbUsed)
{
    CairoleDebugOut((DEB_ROT, "%p _IN BuildRotDataFromDisplayName"
       "( %p , %p , %p , %lx , %p )\n", NULL, pbc, pmk, pbData, cbData,
           pcbUsed));

    HRESULT hr;
    BOOL fCreatedBindCtx = FALSE;
    WCHAR *pwszDisplayName = NULL;

    do {

        // Do we have a bind context to work with?
        if (pbc == NULL)
        {
            // Get the display name
            if ((hr = CreateBindCtx(0, &pbc)) != NOERROR)
            {
	        CairoleDebugOut((DEB_ERROR,
                    "BuildRotDataFromDisplayName CreateBindCtx Failed %lx\n",
                        hr));

                break;
            }

            fCreatedBindCtx = TRUE;
        }

        if ((hr = pmk->GetDisplayName(pbc, NULL, &pwszDisplayName)) != NOERROR)
        {
            CairoleDebugOut((DEB_ERROR,
                "BuildRotDataFromDisplayName IMoniker::GetDisplayName "
                    "failed %lx\n", hr));
            break;
        }

        DWORD dwLen = (lstrlenW(pwszDisplayName) + 1) * sizeof(WCHAR)
            + sizeof(CLSID);

        CLSID clsid;

        // Get the class id if we can
        if ((hr = pmk->GetClassID(&clsid)) == NOERROR)
        {
            // Assume that it is too big
            hr = E_OUTOFMEMORY;

            // Can the buffer hold all the data?
            if (dwLen <= cbData)
            {
                // Yes, so copy it in

                // First the CLSID
                memcpy(pbData, &clsid, sizeof(CLSID));

                // Uppercase the display name
                CharUpperW(pwszDisplayName);

                // Then the string for the display name
                lstrcpyW((WCHAR *) (pbData + sizeof(CLSID)), pwszDisplayName);

                *pcbUsed = dwLen;

                hr = S_OK;
            }
#if DBG == 1
            else
            {
                CairoleDebugOut((DEB_ERROR,
                    "BuildRotDataFromDisplayName Comparison buffer too bing\n"));
            }
#endif // DBG == 1
        }
#if DBG == 1
        else
        {
            CairoleDebugOut((DEB_ERROR,
                "BuildRotDataFromDisplayName IMoniker::GetClassID failed %lX\n",
                    hr));
        }
#endif // DBG == 1


    } while(FALSE);

    if (pwszDisplayName != NULL)
    {
        CoTaskMemFree(pwszDisplayName);
    }

    if (fCreatedBindCtx)
    {
        pbc->Release();
    }

    CairoleDebugOut((DEB_ROT, "%p OUT BuildRotDataFromDisplayName"
       "( %lx ) [ %lx ]\n", NULL, hr, *pcbUsed));

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildRotData
//
//  Synopsis:   Build ROT comparison data from a moniker
//
//  Arguments:  [pmk] - moniker to use for display name
//              [pbData] - buffer to put the data in.
//              [cbMax] - size of the buffer
//              [pcbData] - count of bytes used in the buffer
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//  Algorithm:  See if the moniker supports IROT data. If it does, then
//              use the result from that otherwise call through to
//              BuildRotDataFromDisplayName to build the data from the
//              display name if possible.
//
//  History:    03-Feb-95   ricksa  Created
//
// Note:
//
//----------------------------------------------------------------------------
HRESULT BuildRotData(
    LPBC pbc,
    IMoniker *pmk,
    BYTE *pbData,
    DWORD cbData,
    DWORD *pcbUsed)
{
    CairoleDebugOut((DEB_ROT, "%p _IN BuildRotData"
       "( %p , %p , %p , %lx , %p )\n", NULL, pbc, pmk, pbData, cbData,
           pcbUsed));

    HRESULT hr;
    IROTData *protdata = NULL;

    do {

        // Does the moniker support the new interface for registering
        // in the ROT?
        if (pmk->QueryInterface(IID_IROTData, (void **) &protdata)
            == NOERROR)
        {
            hr = protdata->GetComparisonData(
                pbData,
                cbData,
                pcbUsed);

#if DBG == 1
            if (FAILED(hr))
            {
                CairoleDebugOut((DEB_ERROR,
                    "BuildRotData IROTData::GetComparisonData failed %lX\n",
                        hr));
            }
#endif // DBG == 1

            if (SUCCEEDED(hr) && (hr != NOERROR))
            {
                // We got a success code that was not NOERROR. This makes
                // no sense since the only thing that can happen is the
                // buffer is filled with data. Therefore, we remap this to
                // an error.
                CairoleDebugOut((DEB_ERROR,
                    "BuildRotData IROTData::GetComparisonData return bad"
                        " success %lX\n", hr));

                hr = E_UNEXPECTED;
            }

            break;
        }

        hr = BuildRotDataFromDisplayName(NULL, pmk, pbData, cbData, pcbUsed);

    } while(FALSE);

    if (protdata != NULL)
    {
        protdata->Release();
    }

    CairoleDebugOut((DEB_ROT, "%p OUT BuildRotData"
       "( %lx ) [ %lx ]\n", NULL, hr, *pcbUsed));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\refcnt.cxx ===
//+-----------------------------------------------------------------------
//
//  File:       refcnt.cxx
//
//  Contents:   Helper functions for thread-safe destruction of objects
//              placed in global tables that may hand out references.
//
//  Functions:  InterlockedDecRefCnt, InterlockedRestoreRefCnt
//
//  History:    14-Dec-98   GopalK/RickHi   Created
//
//  Notes:      These functions are to be used if you place a refcnt'd object
//              in a global table, but do not want to take a lock around all
//              Release calls. This is used, for example, in the CStdIdentity
//              objects which are placed in the OID tables. Note that if the
//              objects are page-table allocated (see pgalloc.cxx) then there
//              is a simpler mechanism that can be used.
//
//              Use InterlockedIncrement in the AddRef method.
//              Use these functions in the Release method as follows:
//
//
//      ULONG CSomeClass::Release()
//      {
//          ULONG cNewRefs;
//          BOOL fTryToDelete = InterlockedDecRefCnt(&_cRefs, &cNewRefs);
//
//          while (fTryToDelete)
//          {
//              // refcnt went to zero, try to delete this entry
//              BOOL fActuallyDeleted = FALSE;
//
//              // acquire the same lock that the table uses when it
//              // gives out references.
//              ASSERT_LOCK_NOT_HELD(gTableLock);
//              LOCK(gTableLock);
//
//              if (_cRefs == CINDESTRUCTOR)
//              {
//                  // the refcnt did not change while we acquired the lock.
//                  // OK to delete.
//                  delete this;
//                  fActuallyDeleted = TRUE;
//              }
//
//              UNLOCK(gTableLock);
//              ASSERT_LOCK_NOT_HELD(gTableLock);
//
//              if (fActuallyDeleted == TRUE)
//                  break;  // all done. the entry has been deleted.
//
//              // the entry was not deleted because some other thread changed
//              // the refcnt while we acquired the lock. Try to restore the refcnt
//              // to turn off the CINDESTRUCTOR bit. Note that this may race with
//              // another thread changing the refcnt, in which case we may decide to
//              // try to loop around and delete the object once again.
//              fTryToDelete = InterlockedRestoreRefCnt(&_cRefs, &cNewRefs);
//          }
//
//          return (cNewRefs & ~CINDESTRUCTOR);
//      }
//
//-------------------------------------------------------------------------
#include    <ole2int.h>

//+------------------------------------------------------------------------
//
//  Function:   InterlockedDecRefCnt, public
//
//  Synopsis:   Decement the number of references. Returnes TRUE if the object
//              is a candidate for deletion.
//
//  History:    14-Dec-98   GopalK/RickHi   Created
//
//-------------------------------------------------------------------------
INTERNAL_(BOOL) InterlockedDecRefCnt(ULONG *pcRefs, ULONG *pcNewRefs)
{
    BOOL fDelete;

    ULONG cKnownRefs, cCurrentRefs = *pcRefs;
    do
    {
        cKnownRefs = cCurrentRefs;

        if (cKnownRefs == 1)
        {
            // last reference, try to delete
            *pcNewRefs = CINDESTRUCTOR;
            fDelete = TRUE;
        }
        else
        {
            // not last reference, do not delete
            *pcNewRefs = (cKnownRefs & CINDESTRUCTOR) |
                         ((cKnownRefs & ~CINDESTRUCTOR)- 1);
            fDelete = FALSE;
        }

        // Attempt to set the new value
        cCurrentRefs = InterlockedCompareExchange((long *) pcRefs,
                                                  *pcNewRefs, cKnownRefs);
    } while (cCurrentRefs != cKnownRefs);

    return fDelete;
}

//+------------------------------------------------------------------------
//
//  Function:   InterlockedRestoreRefCnt, public
//
//  Synopsis:   If an object was not deleted after InterlockedDecRefCnt
//              returned TRUE, then this function is called to restore the
//              the refcnt.
//
//  History:    14-Dec-98   GopalK/RickHi   Created
//
//-------------------------------------------------------------------------
INTERNAL_(BOOL) InterlockedRestoreRefCnt(ULONG *pcRefs, ULONG *pcNewRefs)
{
    DWORD cKnownRefs, cCurrentRefs = *pcRefs;

    do
    {
        cKnownRefs = cCurrentRefs;
        Win4Assert(cKnownRefs & CINDESTRUCTOR);
        *pcNewRefs = cKnownRefs & ~CINDESTRUCTOR;   // turn off the bit

        if (cKnownRefs == CINDESTRUCTOR)
        {
            // refcount went back to zero, try once again to delete
            // the object.
            return TRUE;
        }

        cCurrentRefs = InterlockedCompareExchange((long *) pcRefs,
                                                  *pcNewRefs, cKnownRefs);
    } while (cCurrentRefs != cKnownRefs);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\smblock.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	smblock.cxx
//
//  Contents:	Shared memory block code
//
//  Classes:	
//
//  Functions:	
//
//  History:	24-Mar-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include <ole2int.h>
#include <smblock.hxx>
#include <smcreate.hxx>

#if DBG == 1
DECLARE_INFOLEVEL(mem);
#endif


//+---------------------------------------------------------------------------
//
//  Member:	CSharedMemoryBlock::~CSharedMemoryBlock, public
//
//  Synopsis:	Destructor
//
//  Returns:	Appropriate status code
//
//  History:	25-Apr-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

CSharedMemoryBlock::~CSharedMemoryBlock()
{
    CloseSharedFileMapping(_hMem, _pbBase);
}

//+-------------------------------------------------------------------------
//
//  Member:	CSharedMemoryBlock::Init
//
//  Synopsis:	Create/get address of shared memory block.
//
//  Arguments:	[pszName] - name of block to allocate
//		[culSize] - size of block to allocate
//
//  Algorithm:	Attempts to open the block first. If this fails then
//		this creates the block of memory. It then puts the
//		address of the block as the first bytes of the block.
//		If the block already exists, the memory is mapped
//		and then the address is read. The memory is then mapped
//		to the address.
//
//  History:	03-Nov-93 Ricksa    Created
//              07-Jan-94 AlexT     No security for CHICAGO
//
//  Notes:	Counts on some outside synchronization to prevent
//		a race in the creation of the memory.
//
//--------------------------------------------------------------------------
SCODE CSharedMemoryBlock::Init(
        LPWSTR pszName,
	ULONG  culSize,
	ULONG  culCommitSize,
	void   *pvBase,
	PSECURITY_DESCRIPTOR lpSecDes,
	BOOL   fOKToCreate)
{
    SCODE sc = S_OK;

    memAssert((_hMem == NULL) &&
                  "Attempt to Init CSharedMemoryBlock twice.");

    //We store a header on the shared memory - this should be
    //    transparent to clients.
    culSize = culSize + sizeof(CSharedMemHeader);


    if (fOKToCreate)
    {
	//  try to create the shared file mapping
	//  creates or opens it for Read/Write access.

	_fReadWrite = TRUE;

	_hMem = CreateSharedFileMapping(pszName,
				    culSize,	    // size of shared mem
				    0,		    // map size
				    pvBase,	    // base addr
				    lpSecDes,	    // security desc
				    PAGE_READWRITE | SEC_RESERVE,
				    (void **)&_pbBase,	// returned base ptr
				    &_fCreated);    // created or not
    }
    else
    {
	//  try to open the shared file mapping.
	//  opens it for read only access, base address unspecified.

	_fReadWrite = FALSE;
	_fCreated = FALSE;

	_hMem = OpenSharedFileMapping(pszName,
			      0,		    // map size
			      (void **)&_pbBase);   // returned base ptr
    }

    if (_hMem == NULL)
    {
	return HRESULT_FROM_WIN32(GetLastError());
    }


#if DBG == 1
    MEMORY_BASIC_INFORMATION meminf;
    SIZE_T cbReal;

    cbReal = VirtualQuery(_pbBase, &meminf, sizeof(MEMORY_BASIC_INFORMATION));

    memDebugOut((DEB_ITRACE, "cbReal == %lu, Mem Info:  Base Address %p, Allocation Base %p, AllocationProtect %lx, Region Size %lu, State %lx, Protect %lx, Type %lx\n",
		 cbReal, meminf.BaseAddress, meminf.AllocationBase, meminf.AllocationProtect,
		 meminf.RegionSize, meminf.State, meminf.Protect, meminf.Type));
#endif

    // Commit the first page
    void *pvResult;
    pvResult = VirtualAlloc(_pbBase, culCommitSize, MEM_COMMIT,
                            (_fReadWrite) ? PAGE_READWRITE : PAGE_READONLY);
    if (pvResult == NULL)
    {
        sc = GetScode(HRESULT_FROM_WIN32(GetLastError()));
        memDebugOut((DEB_ERROR, "CSharedMemoryBlock::Commit of %lu bytes"
            " failed with %lx\n", culCommitSize, sc));
        CloseHandle(_hMem);
        _hMem = NULL;
        return sc;
    }

#if DBG == 1
    cbReal = VirtualQuery(_pbBase, &meminf, sizeof(MEMORY_BASIC_INFORMATION));

    memDebugOut((DEB_ITRACE, "cbReal == %lu, Mem Info:  Base Address %p, Allocation Base %p, AllocationProtect %lx, Region Size %lu, State %lx, Protect %lx, Type %lx\n",
		cbReal, meminf.BaseAddress, meminf.AllocationBase, meminf.AllocationProtect,
		meminf.RegionSize, meminf.State, meminf.Protect, meminf.Type));
#endif

    _culCommitSize = culCommitSize;
    _culInitCommitSize = culCommitSize;

    //If we created the block, mark the size in the header.
    if (_fCreated)
    {
        ((CSharedMemHeader *)_pbBase)->SetSize(_culCommitSize);
    }
    else
    {
        sc = Sync();
    }

    return sc;
}

#ifdef RESETOK
//+---------------------------------------------------------------------------
//
//  Member:	CSharedMemoryBlock::Reset, public
//
//  Synopsis:	Reset the shared memory block to its original empty state
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//  History:	04-Apr-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CSharedMemoryBlock::Reset(void)
{
#if DBG == 1
    BOOL b;
#endif
    void *pv;

    memDebugOut((DEB_ITRACE, "In  CSharedMemoryBlock::Reset:%p()\n", this));

#if DBG == 1
    b =
#endif
        VirtualFree(_pbBase, _culCommitSize, MEM_DECOMMIT);
    memAssert(b && "VirtualFree failed.");

#if DBG == 1
    if (b == NULL)
    {
        memDebugOut((DEB_ERROR, "VirtualFree failed with %lx\n", GetLastError()));
    }
#endif

    pv = VirtualAlloc(_pbBase, , _culInitCommitSize, MEM_COMMIT,
		     (_fReadWrite) ? PAGE_READWRITE : PAGE_READONLY);
    if (pv == NULL)
    {
        SCODE sc = GetScode(HRESULT_FROM_WIN32(GetLastError()));
        memDebugOut((DEB_ERROR, "CSharedMemoryBlock::Commit of %lu bytes"
            " failed with %lx\n", _culInitCommitSize, sc));
        return sc;
    }

    _culCommitSize = _culInitCommitSize;
    ((CSharedMemHeader *)_pbBase)->SetSize(_culCommitSize);

    memDebugOut((DEB_ITRACE, "Out CSharedMemoryBlock::Reset\n"));
    return S_OK;
}
#endif //RESETOK

//+---------------------------------------------------------------------------
//
//  Member:	CSharedMemoryBlock::Commit, public
//
//  Synopsis:	Commit the given number of bytes within the block
//
//  Arguments:	[culNewSize] -- Number of bytes to commit
//
//  Returns:	Appropriate status code
//
//  History:	29-Mar-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CSharedMemoryBlock::Commit(ULONG culNewSize)
{
    SCODE sc = S_OK;
    culNewSize = culNewSize + sizeof(CSharedMemHeader);

    memAssert((culNewSize >= _culCommitSize) &&
               "Attempted to shrink shared memory heap.");

    if (culNewSize == _culCommitSize)
    {
        return sc;
    }

    void *pb;

    pb = VirtualAlloc(_pbBase,
                      culNewSize,
                      MEM_COMMIT,
		      (_fReadWrite) ? PAGE_READWRITE : PAGE_READONLY);

    if (pb == NULL)
    {
        sc = GetScode(HRESULT_FROM_WIN32(GetLastError()));
        memDebugOut((DEB_ERROR,
                     "CSharedMemoryBlock::Commit of %lu bytes failed with %lx\n", culNewSize, sc));
    }
    else
    {
        _culCommitSize = culNewSize;

        //If the new size is greater than the maximum committed size,
        //   update the maximum committed size.
        CSharedMemHeader *psmh = (CSharedMemHeader *)_pbBase;
        if (_culCommitSize > psmh->GetSize())
        {
            psmh->SetSize(_culCommitSize);
        }
    }

#if DBG == 1
    MEMORY_BASIC_INFORMATION meminf;
    SIZE_T cbReal;

    cbReal = VirtualQuery(_pbBase, &meminf, sizeof(MEMORY_BASIC_INFORMATION));

    memDebugOut((DEB_ITRACE, "Commit size == %lu, cbReal == %lu, Mem Info:  Base Address %p, Allocation Base %p, AllocationProtect %lx, Region Size %lu, State %lx, Protect %lx, Type %lx\n",
		 _culCommitSize, cbReal, meminf.BaseAddress, meminf.AllocationBase, meminf.AllocationProtect,
		 meminf.RegionSize, meminf.State, meminf.Protect, meminf.Type));

    if (cbReal != sizeof(MEMORY_BASIC_INFORMATION))
    {
        memDebugOut((DEB_ERROR, "Virtual Query error: %lx\n", GetLastError()));
    }

#endif

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CSharedMemoryBlock::Sync, public
//
//  Synopsis:	Match committed view to largest committed view
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//  History:	29-Mar-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CSharedMemoryBlock::Sync(void)
{
    CSharedMemHeader *psmh = (CSharedMemHeader *)_pbBase;

    ULONG culSize = psmh->GetSize();

    if (culSize != _culCommitSize)
    {
        return Commit(culSize - sizeof(CSharedMemHeader));
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\skiplist.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:	sklist.cxx
//
//  Contents:	Level generator functions required by skip lists
//
//  Functions:	RandomBit - generate a random on or off bit
//		GetSkLevel - return a skip list forward pointer array size
//
//  History:	30-Apr-92 Ricksa    Created
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <time.h>
#include    "skiplist.hxx"

static ULONG ulLSFR;

//+-------------------------------------------------------------------------
//
//  Function:	RandomBit
//
//  Synopsis:	Uses various shifts to generate random bit
//
//  Returns:	0 or 1
//
//  History:	30-Apr-92 Ricksa    Created
//
//--------------------------------------------------------------------------

static inline ULONG RandomBit(void)
{
    ulLSFR = (((ulLSFR >> 31)
	    ^ (ulLSFR >> 6)
	    ^ (ulLSFR >> 4)
	    ^ (ulLSFR >> 2)
	    ^ (ulLSFR >> 1)
	    ^ ulLSFR
	    & 0x00000001)
	    << 31)
	    | (ulLSFR >> 1);

    return ulLSFR & 0x00000001;
}



//+-------------------------------------------------------------------------
//
//  Function:	GetSkLevel
//
//  Synopsis:	Set the level for an entry in a skip list
//
//  Arguments:	[cMax] - maximum level to return
//
//  Returns:	a number between 1 and cMax
//
//  History:	30-Apr-92 Ricksa    Created
//
//--------------------------------------------------------------------------

int GetSkLevel(int cMax)
{
    // There should always be at least one entry returned
    int cRetLevel = 1;

    // Loop while the level is less than the maximum level
    // to return and a 1 is returned from RandomBit. Note
    // that this is equivalent to p = 1/2. If you don't
    // know what p = 1/2 means see Communications of the ACM
    // June 1990 on Skip Lists.
    while (cRetLevel < cMax && RandomBit())
    {
	cRetLevel++;
    }

    return cRetLevel;
}

//+-------------------------------------------------------------------
//
//  Member:     CSkipList::CSkipList
//
//  Synopsis:   Skip list constructor.
//
//  Arguments:  [lpfnCompare] -- Pointer to client-supplied comparison
//                  function.  Client supplied routine should cast
//                  the pointer parameters to the class that is the
//                  key and then perform the comparison.  The [pvMaxKey]
//                  parameter may at times be passed unchanged to the
//                  comparison function in the second parameter.
//                  The first parameter of the comparison function will
//                  receive a pointer to the key part (base part) of
//                  the entries inserted using CSkipList::Insert ; the
//                  pointer to the key part is calculated by adding
//                  [EntryToKeyOffset] to the address of the entry passed
//                  to CSkipList::Insert.
//
//              [lpfnDelete] -- Pointer to client-supplied routine that
//                  takes a single pointer parameter and is only ever
//                  called by CSkipList::~CSkipList to perform any
//                  necessary deallocation of entries within
//                  the skip list.
//
//              [EntryToKeyOffset] -- Added to entry pointers to
//                  convert an "entry*" to "key*".  See description
//                  of [lpfnCompare] and header in skiplist.hxx.
//                  Units are sizeof(char)
//
//              [fSharedAlloc] -- If TRUE, the skip list allocates its
//                  internal objects in shared memory, otherwise the
//                  skip list uses private memory.  (Of course, the
//                  CSkipList object itself is allocated by the client
//                  which must ensure that this flag and where the
//                  CSkipList is allocated are consistent.)
//
//              [pvMaxKey] -- Parameter which is passed unchanged to
//                  the user-supplied comparison routine specified by
//                  [lpfnCompare] during insertions/deletions/searches.
//
//              [cMaxLevel] -- The max level the skip list should use.
//
//              [hr] -- Reference to an HRESULT which is only set in
//                  the error cases.  This will be set to E_OUTOFMEMORY
//                  if the construction failed because of low memory.
//
//--------------------------------------------------------------------

CSkipList::CSkipList(						
    LPFNCOMPARE         lpfnCompare,
    LPFNDELETE          lpfnDelete,
    const int           EntryToKeyOffset,
    BOOL                fSharedAlloc,
    Base *              pvMaxKey,
    const int           cMaxLevel,
    HRESULT &           hr)			
 :
        _cCurrentMaxLevel(0),
        _lpfnCompare(lpfnCompare),
        _lpfnDelete(lpfnDelete),
        _EntryToKeyOffset(EntryToKeyOffset),
        _fSharedAlloc(fSharedAlloc),
        _cMaxLevel(cMaxLevel)
{

    //
    // NOTE! 2nd param of CSkipListEntry is usually an entry, but for head is key.
    //

    _pEntryHead = (CSkipListEntry*)Allocate(CSkipListEntry::GetSize(_cMaxLevel));

    if (_pEntryHead)
    {
        _pEntryHead->Initialize(pvMaxKey, _cMaxLevel, TRUE /* fHead */ );

        for (int i = 0; i < _cMaxLevel; i++) 				
        {									
            _pEntryHead->SetForward(i, _pEntryHead);		
        }									
    }
    else
        hr = E_OUTOFMEMORY;
}									

//+-------------------------------------------------------------------
//
//  Member:     CSkipList::~CSkipList
//
//  Synopsis:   Skip list destructor.
//
//  Effects:    For every entry that has been inserted into the skip
//              list (using CSkipList::Insert), but not removed
//              (using CSkipList::Remove), the destructor calls
//              the user-supplied routine (lpfnDelete parameter of
//              CSkipList constructor) with a pointer to each entry.
//
//              The user-supplied routine should cast the passed
//              pointer parameter to the class of the entry and
//              deallocate it (only if the skip list "owns" the
//              object of course.)
//
//--------------------------------------------------------------------

CSkipList::~CSkipList()
{
    if (_pEntryHead)
    {
        if (_pEntryHead->GetBase())
        {
            while (_pEntryHead->GetForward(0) != _pEntryHead)		
            {
                Base  * pvKey   = _pEntryHead->GetForward(0)->GetKey(_EntryToKeyOffset);
                Entry * pvEntry = Remove(pvKey);
                _lpfnDelete(pvEntry);
            }									
        }
        Deallocate(_pEntryHead);
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CSkipList::_Search, private
//
//  Synopsis:   Search the skip list for an entry matching the supplied
//              key.
//
//  Effects:    Search calls the user-supplied comparison function
//              with two pointers.  The first is the address of the key
//              part of entries in the skip list that were inserted
//              by CSkipList::Insert (see description of constructor
//              for how the key address is found.)
//              The second parameter of the user-supplied function
//              is the [BaseKey] parameter of this function.
//
//  Arguments:  [BaseKey] -- passed to user-supplied comparison function.
//                           Pointer to key that should match the key part
//                           of an entry that was inserted into the skip
//                           list using CSkipList::Insert.
//              [ppPrivEntry -- returns pointer to CSkipListEntry that
//                           contains user entry pointer.
//                           Will contain null if not found.
//
//  Returns:    Pointer to the entry part (not key part) of the found
//              object.  This will be the same as the respective parameter
//              to Insert.
//              NULL if not found.
//
//--------------------------------------------------------------------

Entry *CSkipList::_Search(const Base * BaseKey, CSkipListEntry **ppPrivEntry) 		
{									
    CSkipListEntry *pEntrySearch = _pEntryHead;				
									
    register int CmpResult = -1;					
    *ppPrivEntry = NULL;
    									
    for (int i = _cCurrentMaxLevel - 1; i >= 0; i--)			
    {									
	while ((CmpResult =						
	    _lpfnCompare(pEntrySearch->GetForward(i)->GetKey(_EntryToKeyOffset), (Base*)BaseKey)) < 0)
	{								
	    pEntrySearch = pEntrySearch->GetForward(i); 	
	}								
									
	if (CmpResult == 0)						
	{								
            *ppPrivEntry = pEntrySearch->GetForward(i);
	    break;							
	}								
    }									
									
    return (CmpResult == 0) ? (*ppPrivEntry)->GetEntry() : NULL;		
}									

//+-------------------------------------------------------------------
//
//  Member:     CSkipList::Search
//
//  Synopsis:   Search the skip list for an entry matching the supplied
//              key.
//
//  Effects:    Search calls the user-supplied comparison function
//              with two pointers.  The first is the address of the key
//              part of entries in the skip list that were inserted
//              by CSkipList::Insert (see description of constructor
//              for how the key address is found.)
//              The second parameter of the user-supplied function
//              is the [BaseKey] parameter of this function.
//
//  Arguments:  [BaseKey] -- passed to user-supplied comparison function.
//                           Pointer to key that should match the key part
//                           of an entry that was inserted into the skip
//                           list using CSkipList::Insert.
//
//  Returns:    Pointer to the entry part (not key part) of the found
//              object.  This will be the same as the respective parameter
//              to Insert.
//              NULL if not found.
//
//--------------------------------------------------------------------

Entry *CSkipList::Search(const Base * BaseKey)
{
    CSkipListEntry *pPrivEntry;
    return _Search(BaseKey, &pPrivEntry);
}

//+-------------------------------------------------------------------
//
//  Member:     CSkipList::FillUpdateArray
//
//  Synopsis:   Private member which fills the array with pointers
//              to entries that only compare >=
//
//  Arguments:  [BaseKey] -- Pointer to key part of an entry.
//              [ppEntryUpdate] -- The array to fill.
//
//  Returns:    Pointer to most closely matching entry or NULL if head not
//              allocated (shouldn't happen)
//
//--------------------------------------------------------------------

CSkipListEntry *CSkipList::FillUpdateArray(				
    const Base *BaseKey,						
    CSkipListEntry **ppEntryUpdate)						
{									
    CSkipListEntry *pEntrySearch = _pEntryHead;
    if (pEntrySearch)
    {
        for (int i = _cCurrentMaxLevel - 1; i >= 0; i--)		
        {									
			while (_lpfnCompare(pEntrySearch->GetForward(i)->GetKey(_EntryToKeyOffset),
								(Base*)BaseKey) < 0)
			{								
				pEntrySearch = pEntrySearch->GetForward(i); 	
			}								
									
			ppEntryUpdate[i] = pEntrySearch;			
        }									
        return pEntrySearch->GetForward(0);				
    }
    else
    {
        return NULL;
    }
}									

//+-------------------------------------------------------------------
//
//  Member:     CSkipList::Insert
//
//  Synopsis:   Inserts the supplied entry into the skip list.
//
//  Arguments:  [pEntry] -- The pointer to the entry to insert.
//                          When searching, this pointer will
//                          have the "EntryToKeyOffset" parameter
//                          to CSkipList constructor added before
//                          being passed to the user-supplied
//                          comparison function.  The offset is
//                          in sizeof(char) units.
//
//                          Upon destruction of the skip list,
//                          ~CSkipList will call the user-supplied
//                          deletion routine with the stored [pEntry]
//                          unless it is removed using CSkipList::Remove
//                          prior to the destruction of CSkipList.
//
//                          Should never be NULL.
//
//  Returns:    If successful, returns the input parameter, otherwise
//              returns NULL which is indicative of E_OUTOFMEMORY.
//
//--------------------------------------------------------------------

Entry * CSkipList::Insert(Entry *pEntry)			
{									
    CSkipListEntry *apEntryUpdate[SKIP_LIST_MAX];

    if (pEntry == NULL)
        return(NULL);

    Win4Assert(_pEntryHead != NULL);

    int level = GetSkLevel((_cCurrentMaxLevel != _cMaxLevel) ?
                    _cCurrentMaxLevel + 1 : _cMaxLevel);

    CSkipListEntry *pEntryNew = (CSkipListEntry*)Allocate(CSkipListEntry::GetSize(level));

    if (pEntryNew != NULL)
    {
        pEntryNew->Initialize(pEntry, level, FALSE /* fHead */ );

        FillUpdateArray( (((char*)pEntry)+_EntryToKeyOffset), apEntryUpdate);			
									
        int iNewLevel = pEntryNew->cLevel();				
									
        if (iNewLevel > _cCurrentMaxLevel)					
        {									
	    for (int i = _cCurrentMaxLevel; i < iNewLevel; i++)		
	    {								
	        apEntryUpdate[i] = _pEntryHead;			
	    }								
									
	    _cCurrentMaxLevel = iNewLevel;					
        }									
									
        for (int i = 0; i < iNewLevel ; i++)				
        {									
	    pEntryNew->SetForward(i, apEntryUpdate[i]->GetForward(i));
	    apEntryUpdate[i]->SetForward(i, pEntryNew);		
        }
        return(pEntry);
    }
    return(NULL);
}									

//+-------------------------------------------------------------------
//
//  Member:     CSkipList::Remove
//
//  Synopsis:   Searches the skip list for an entry that matches
//              [BaseKey] and removes the pointer to it from the skip
//              list (if found.)
//
//  Effects:    Calls the user-supplied comparison routine as part of
//              the search (see documentation of CSkipList::CSkipList,
//              CSkipList::Insert, and skiplist.hxx header for more
//              information about how the search occurs.)
//
//  Arguments:  [BaseKey] -- pointer to key that should match a key of
//                  an entry in the list.
//
//  Returns:    NULL if not found, otherwise a pointer to the entry
//              part of the entry that was matched.
//
//--------------------------------------------------------------------

Entry * CSkipList::Remove(Base * BaseKey)				
{									
    CSkipListEntry *apEntryUpdate[SKIP_LIST_MAX] = {NULL};
    Entry *         pEntry;
    CSkipListEntry *pEntryDelete = FillUpdateArray(BaseKey, apEntryUpdate);		

	// If _pEntryHead is NULL, we can't remove anything.
	// Thus, what we've asked for must not have been found.
	// FillUpdateArray was supposed to return NULL in this case.
	if (_pEntryHead == NULL)
	{
		Win4Assert(pEntryDelete == NULL);
		return NULL;
	}

	for (int i = 0; i < _cCurrentMaxLevel; i++)
	{									
		if (apEntryUpdate[i]->GetForward(i) != pEntryDelete)
		{
			break;
		}
		
		apEntryUpdate[i]->SetForward(i, pEntryDelete->GetForward(i));
	}

    if (pEntryDelete)
        pEntry = pEntryDelete->GetEntry();
	else
        pEntry = NULL;

	Deallocate(pEntryDelete);
		
    while (_cCurrentMaxLevel > 1 &&					
		   _pEntryHead->GetForward(_cCurrentMaxLevel - 1) == _pEntryHead)
    {									
		_cCurrentMaxLevel--;						
    }

    return pEntry;
}									

//+-------------------------------------------------------------------
//
//  Member:     CSkipList::Replace
//
//  Synopsis:   Searches the skip list for an entry that matches
//              [BaseKey] and returns the pointer to the entry.
//              The entry pointer is replaced by [pEntryNew]
//
//  Effects:    Calls the user-supplied comparison routine as part of
//              the search (see documentation of CSkipList::CSkipList,
//              CSkipList::Insert, and skiplist.hxx header for more
//              information about how the search occurs.)
//
//  Arguments:  [BaseKey] -- pointer to key that should match a key of
//                  an entry in the list.
//              [pEntryNew] -- pointer to entry that has same key value
//                  as [BaseKey] that is to replace the pointer
//                  currently associated with the that key value.
//
//  Returns:    The old pointer.  If this is used to own the data, then
//              it must be deleted.
//
//--------------------------------------------------------------------

Entry * CSkipList::Replace(Base * BaseKey, Entry * pEntryNew)
{
    Win4Assert(_lpfnCompare(BaseKey, ((char*)pEntryNew)+_EntryToKeyOffset)==0);

    CSkipListEntry *pPrivEntry;
    Entry * pOldEntry = _Search(BaseKey, &pPrivEntry);
    if (pPrivEntry != NULL)
    {
        Win4Assert(pOldEntry);
        pPrivEntry->_pvEntry = pEntryNew;
    }
    else
    {
        Win4Assert(pOldEntry == NULL);
    }
    return pOldEntry;
}

//+-------------------------------------------------------------------
//
//  Member:     CSkipList::First
//
//  Synopsis:   Initializes the "skip list enumerator" to point
//              to the first CSkipListEntry in the skip list and return a
//              pointer to the user-supplied entry.
//
//  Arguments:  [psle] -- Pointer to a CSkipListEnum which is initialized.
//
//  Returns:    A pointer previously passed into CSkipList::Insert.
//              The first entry in this skip list.
//
//--------------------------------------------------------------------
									
Entry *CSkipList::First(CSkipListEnum *psle) 					
{
    *psle = _pEntryHead;
    return Next(psle);									
}									

//+-------------------------------------------------------------------
//
//  Member:     CSkipList::Next
//
//  Synopsis:   Using the state of the passed enumerator, return the
//              next entry and update the enumerator for the next
//              call to Next.
//
//  Arguments:  [psle] -- Pointer to CSkipListEnum previously
//                        initialized by CSkipList::First or
//                        updated by CSkipList::Next.
//
//  Returns:    NULL if no more to enumerate, otherwise a pointer to
//              the user-supplied entry (i.e. the returned pointer
//              was previously passed to CSkipList::Insert (but not
//              then removed.)
//
//--------------------------------------------------------------------

Entry *CSkipList::Next(CSkipListEnum *psle) 			
{
    if (*psle == NULL)
    {
        return(NULL);
    }

    CSkipListEntry *pEntryTo = (*psle)->GetForward(0);		
    Entry * pvRet;

    if (pEntryTo != _pEntryHead)
    {
        pvRet = pEntryTo->GetEntry();
        *psle = pEntryTo;
    }
    else
    {
        *psle = NULL;
        pvRet = NULL;
    }
    return pvRet;
}									

//+-------------------------------------------------------------------
//
//  Member:     CSkipList::GetList
//
//  Synopsis:   BUGBUG: BillMo. Old code hangover.  This function is
//              used to test the success of allocation of
//              _pEntryHead in the constructor because of the
//              removal of exception code.
//              All uses of this should now be redundant and should
//              be removed since the constructor now returns an error
//              code should a failure occur.
//
//--------------------------------------------------------------------

CSkipListEntry *CSkipList::GetList(void) 			
{									
    Win4Assert(_pEntryHead != NULL);
    return _pEntryHead;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\sklist.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:	sklist.cxx
//
//  Contents:	Level generator functions required by skip lists
//
//  Functions:	RandomBit - generate a random on or off bit
//		GetSkLevel - return a skip list forward pointer array size
//
//  History:	30-Apr-92 Ricksa    Created
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <time.h>
#include    <sklist.hxx>

static ULONG ulLSFR;

//+-------------------------------------------------------------------------
//
//  Function:	RandomBit
//
//  Synopsis:	Uses various shifts to generate random bit
//
//  Returns:	0 or 1
//
//  History:	30-Apr-92 Ricksa    Created
//
//--------------------------------------------------------------------------
static inline ULONG RandomBit(void)
{
    ulLSFR = (((ulLSFR >> 31)
	    ^ (ulLSFR >> 6)
	    ^ (ulLSFR >> 4)
	    ^ (ulLSFR >> 2)
	    ^ (ulLSFR >> 1)
	    ^ ulLSFR
	    & 0x00000001)
	    << 31)
	    | (ulLSFR >> 1);

    return ulLSFR & 0x00000001;
}


//+-------------------------------------------------------------------------
//
//  Function:	GetSkLevel
//
//  Synopsis:	Set the level for an entry in a skip list
//
//  Arguments:	[cMax] - maximum level to return
//
//  Returns:	a number between 1 and cMax
//
//  History:	30-Apr-92 Ricksa    Created
//
//--------------------------------------------------------------------------
// Get a level from the generator
int GetSkLevel(int cMax)
{
    // There should always be at least one entry returned
    int cRetLevel = 1;

    // Loop while the level is less than the maximum level
    // to return and a 1 is returned from RandomBit. Note
    // that this is equivalent to p = 1/2. If you don't
    // know what p = 1/2 means see Communications of the ACM
    // June 1990 on Skip Lists.
    while (cRetLevel < cMax && RandomBit())
    {
	cRetLevel++;
    }

    return cRetLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\psctbl2.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:       psctbl2.cxx
//
//  Contents:   Trie-based IID to CLSID map
//
//  Classes:    CMapGuidToGuidBase
//              CPSClsidTbl (DLL)
//              CScmPSClsidTbl (SCM/EXE)
//
//  Functions:  bmemcmp
//              bmemcpy
//              CMapGuidToGuidBase::Initialize
//              CMapGuidToGuidBase::CGUIDBlock -> internal functions
//              CMapGuidToGuidBase::TrieNode -> internal functions
//              CPSClsidTbl::Initialize
//              CPSClsidTbl::Find
//              CScmPSClsidTbl::Initialize
//              CScmPSClsidTbl::InitTbl
//              CScmPSClsidTbl::AddLocal
//              CScmPSClsidTbl::CopyToSharedMem
//
//  History:    06-Jun-95 t-stevan    Created
//
//--------------------------------------------------------------------------
#include <ole2int.h>
#pragma hdrstop
#include <psctbl2.hxx>


// *** Defines and Constants ***
// The number of bits used to store the number of key bytes in a TrieNode
const int KEYBYTE_BITS = 5;

// # of bits used to store # of links
const int LINKS_BITS = 9;

// The mask for number of key bytes stored in a TrieNode
const WORD KEYBYTE_MASK = 0x1f;

// The mask for the number of links stored in a TrieNode
const WORD LINKS_MASK = (0x1ff<<KEYBYTE_BITS);

// Mask for leaf bit in TrieNode
const WORD ISLEAF_MASK  = 0x4000;

// Mask for deleted flag bit in TrieNode
const WORD DELETED_MASK = 0x8000;

// *** These definitions control the amount of memory that the cache uses/can use ***
// The default number of links per TrieNode
const int NODE_LINKS = 4;

// The initial amount to grow by
const int NODE_INIT_GROWBY =4;

// The amount to growby afterwards
// Note: must be a factor of 256, so therefore must be power of 2
//     also, NODE_LINKS+NODE_INIT_GROWBY = multiple of NODE_GROWBY
const int NODE_GROWBY = 8;

// Mod mask for NODE_GROWBY so we can just and it instead of using %
const int NODE_GROWBY_MOD_MASK = NODE_GROWBY-1;

// Constants for our initial/maximum map size
const ULONG MAP_INITIAL_SIZE = 4096; // initial size of map = 4K
const ULONG MAP_MAX_SIZE = 65536; // maximum size of map = 64K

// Key text of registry
TCHAR tszInterface[]      = TEXT("Interface");

// the following string is used in compapi.cxx
WCHAR wszProxyStubClsid[] = L"\\ProxyStubClsid32";
WCHAR wszProxyStubClsid16[] = L"\\ProxyStubClsid";

// macros for setting up a pointer to base off of in member funcs
#ifdef SETUP_BASE_POINTER
#undef SETUP_BASE_POINTER
#endif

#define SETUP_BASE_POINTER() void *pBase = m_pMemBase

#ifdef SYNC_BASE_POINTER
#undef SYNC_BASE_POINTER
#endif

#define SYNC_BASE_POINTER() pBase = m_pMemBase

// a based pointer for TrieNode, using passed bases
#define PASSBASED __based(pBase)
#define OLDBASED  __based(pOldBase)
#define NEWBASED  __based(pNewBase)

//+-------------------------------------------------------------------------
//
//  Function:   bmemcmp
//
//  Synopsis:   compares two memory strings, the first of which runs forward in memory
//              the second of which runs backwards in memory
//
//  Arguments:  [pFBuf]     - the forward-running string in memory
//              [pBBuf]        - the backward-running string in memory
//              [count]        - the number of bytes to compare
//
//  Returns:    0 if the two memory strings are equal. Example: pFBuf = "abcd", pBBuf-3 = "dcba" would be equal
//               else it returns the number of bytes left to compare.
//
//--------------------------------------------------------------------------
inline int bmemcmp(const BYTE *pFBuf, const BYTE *pBBuf, size_t count)
{
    // pFBuf goes forward, pBBuf goes backward
    while((count > 0) && (*pFBuf++ == *pBBuf--))
    {
        count--;
    }

    return count;
}

//+-------------------------------------------------------------------------
//
//  Function:   bmemcpy
//
//  Synopsis:   copies a backward-running memory string into a forward running one,
//
//  Arguments:  [pFDest]     - the forward-running destination
//              [pBSrc]        - the backward-running string in memory
//              [count]        - the number of bytes to copy
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------
inline void bmemcpy(BYTE *pFDest, const BYTE *pBSrc, size_t count)
{
    while(count-- > 0)
    {
        *pFDest++ = *pBSrc--;
    }
}

// *** CMapGuidToGuidBase ***
//+-------------------------------------------------------------------------
//
//  Function:   CMapGuidToGuidBase::Initialize
//
//  Synopsis:   Initializes base (client or server) guid -> guid map
//
//  Arguments:  [pBase] - the base address of our shared memory region
//
//  Returns:    appropriate status code
//
//--------------------------------------------------------------------------
HRESULT CMapGuidToGuidBase::Initialize(void *pBase)
{
    CairoleDebugOut((DEB_ITRACE, "CMapGuidToGuidBase::Initialize(pBase = %p)\n", pBase));

    m_pMemBase = pBase;

    return S_OK;
}

// *** CMapGuidToGuidBase::CGUIDBlock ***
//+-------------------------------------------------------------------------
//
//  Function:   CMapGuidToGuidBase::CGUIDBlock::Initialize, public
//
//  Synopsis:   Initializes the GUID list, we store the mapped-to GUIDs in this
//                list because there aren't that many different ones, so storing one per
//                leaf would be wasteful
//
//  Arguments:  none
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------
inline void CMapGuidToGuidBase::CGUIDBlock::Initialize()
{
    m_nGuids = 0;
    m_bpNext = NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   CMapGuidToGuidBase::CGUIDBlock::GetGuid, public
//
//  Synopsis:   Returns a GUID associated with a given GUIDIndex
//
//  Arguments:  [pBase]     - the base address of the memory region
//              [guidIndex] - the index of the GUID to retreive
//              [guidOut]   - a reference to a GUID to store the retreive guid in
//
//  Returns:    TRUE if found, FALSE if didn't
//
//--------------------------------------------------------------------------
inline BOOL CMapGuidToGuidBase::CGUIDBlock::GetGuid(void *pBase, GUIDIndex guidIndex, GUID &guidOut) const
{
    const CGUIDBlock * pBlock = this;

    if(guidIndex == INVALID_GUID_INDEX)
    {
        return FALSE;
    }

    while(guidIndex > cGuids)
    {
        guidIndex -= cGuids;
        pBlock = BP_TO_P(CGUIDBlock *, (CGUIDBlock PASSBASED *) pBlock->m_bpNext);
        if(pBlock == NULL)
        {
            return FALSE;
        }
    }

    guidOut = pBlock->m_guidArray[guidIndex];

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   CMapGuidToGuidBase::CGUIDBlock::AddGuid, public
//
//  Synopsis:   Adds a GUID to the list, or if the GUID is already there, just returns the proper
//                reference to it.
//
//  Arguments:  [pBase] - base address of memory region (NULL if using local memory)
//              [guid]    - the guid to insert into the list
//              [alloc] - the functor to use to allocate memory
//
//  Returns:    a based pointer to the GUID in the table
//
//--------------------------------------------------------------------------
GUIDIndex CMapGuidToGuidBase::CGUIDBlock::AddGuid(void *pBase, REFGUID guid, CAllocFunctor &alloc)
{
    CGUIDBlock *pBlock;
    int iRetVal; // use an int so we can detect if our table of GUIDs is full

    // First check to see if this GUID is already in the table
    iRetVal = GuidInTable(pBase, this, guid);

    if(iRetVal == INVALID_GUID_INDEX)
    {
        // Nope, add it
        // avoid recursion
        pBlock = this;
        iRetVal = 0;

        while(pBlock != NULL && (iRetVal < INVALID_GUID_INDEX))
        {
            Win4Assert(pBlock->m_nGuids <= cGuids && "More than cGuids in CGUIDBlock");

            if(pBlock->m_nGuids == cGuids)
            {
                // we've outgrown this table, add a new block to the end
                if(BP_TO_P(CGUIDBlock *, (CGUIDBlock PASSBASED *) pBlock->m_bpNext) == NULL)
                {
                    CGUIDBlock *pNewBlock;

                    // allocate a new one
                    pNewBlock = (CGUIDBlock *) alloc.Alloc(sizeof(CGUIDBlock));

                    if(pNewBlock == NULL)
                    {
                        // we're out of memory
                        return INVALID_GUID_INDEX;
                    }

                    // initialize it
                    pNewBlock->Initialize();

                    // add the guid    to it
                    pNewBlock->m_guidArray[0] = guid;
                    pNewBlock->m_nGuids++;

                    // chain it on the list
                    pBlock->m_bpNext = (CGUIDBlockBasedPtr) P_TO_BP(CGUIDBlock PASSBASED *, pNewBlock);

                    // set the return value
                    iRetVal += cGuids; // we're the first guid on this link in the chain
                    break;
                }
                 else
                {
                    // keep on looking for empty space
                    pBlock = BP_TO_P(CGUIDBlock *, (CGUIDBlock PASSBASED *) pBlock->m_bpNext);
                    iRetVal += cGuids;
                }
            }
            else
            {
                // insert this GUID (in no particular order) into the block's array
                pBlock->m_guidArray[pBlock->m_nGuids] = guid;
                iRetVal += pBlock->m_nGuids;
                pBlock->m_nGuids++;
                break;
            }
        }
    }

    if(iRetVal >= INVALID_GUID_INDEX)
    {
        iRetVal = INVALID_GUID_INDEX;
    }

    return (GUIDIndex) iRetVal;
}


//+-------------------------------------------------------------------------
//
//  Function:   CMapGuidToGuidBase::CGUIDBlock::GuidInTable, private (implementation)
//
//  Synopsis:   Looks down the chained block list for a particular GUID, if it finds it return a
//              reference to it.
//
//  Arguments:  [pBase]    - pointer to the base of the shared memory region
//              [pBlock] - the block to start at
//              [guid]    - the guid to find
//
//  Returns:    a based pointer to the GUID in the table, NULL if it was not found
//
//--------------------------------------------------------------------------
GUIDIndex CMapGuidToGuidBase::CGUIDBlock::GuidInTable(void *pBase, CGUIDBlock *pBlock, REFGUID guid)
{
    GUIDIndex iRet = 0;
    GUID *pIndex;
    BOOL fFound = FALSE;
    int i;

    // avoid recursion!
    while(pBlock != NULL)
    {
        // Check this block
        for(i =0, pIndex = &(pBlock->m_guidArray[0]); i < pBlock->m_nGuids; i++, pIndex++)
        {
            if(*pIndex == guid)
            {
                // found it, break outta here
                iRet += i;
                fFound = TRUE;
                break;
            }
        }

        if(!fFound)
        {
            // not in this block ,try next one
            pBlock = BP_TO_P(CGUIDBlock *, (CGUIDBlock PASSBASED *) pBlock->m_bpNext);
            iRet += cGuids;
        }
        else
        {
            // we found it, break outta here
            break;
        }
    }

    if(!fFound)
    {
        return INVALID_GUID_INDEX;
    }

    return iRet;
}


//+-------------------------------------------------------------------------
//
//  Function:   CMapGuidToGuidBase::CGUIDBlock::CopyToSharedMem
//
//  Synopsis:   Copies an entire list of CGUIDBlocks allocated in local memory
//              to shared memory, making sure the original blocks now have
//              based pointers to where the new (copied) data lies
//
//  Arguments:  [pNewBase]  - the base pointer of the destination shared memory block
//              [pOldBase]  - the base pointer of the source memory block (usually NULL)
//              [pCopyBlock]    - the block to copy the first CGUIDBlock to
//              [alloc] - the allocator to use to allocate shared memory
//
//  Returns:    appropriate status code
//
//--------------------------------------------------------------------------
HRESULT CMapGuidToGuidBase::CGUIDBlock::CopyToSharedMem(void *pNewBase, void *pOldBase, CGUIDBlock *pCopyBlock, CAllocFunctor &alloc)
{
    CGUIDBlock *pBlock = this;
    int i;

    while(pBlock != NULL)
    {
        pCopyBlock->m_nGuids = pBlock->m_nGuids;

        for(i = 0; i < m_nGuids; i++)
        {
            pCopyBlock->m_guidArray[i] = pBlock->m_guidArray[i];
        }

        pBlock = BP_TO_P(CGUIDBlock *, (CGUIDBlock OLDBASED *) pBlock->m_bpNext);

        if(pBlock != NULL)
        {
            CGUIDBlock *pNewBlock;

            pNewBlock = (CGUIDBlock *) alloc.Alloc(sizeof(CGUIDBlock));

            if(pNewBlock == NULL)
            {
                return E_OUTOFMEMORY;
            }

            pCopyBlock->m_bpNext = (CGUIDBlockBasedPtr) P_TO_BP(CGUIDBlock NEWBASED *, pNewBlock);
            pCopyBlock = pNewBlock;
        }
        else
        {
            pCopyBlock->m_bpNext = (CGUIDBlockBasedPtr) P_TO_BP(CGUIDBlock NEWBASED *, NULL);
        }
    }

    return S_OK;
}

// *** CMapGuidToGuidBase::TrieNode ***
//+-------------------------------------------------------------------------
//
//  Member:     CMapGuidToGuidBase::TrieNode::NumLinks
//
//  Synopsis:   Return the number of links used in a node
//
//  Arguments:  (none)
//
//  Returns:    see synopsis
//
//--------------------------------------------------------------------------
inline int CMapGuidToGuidBase::TrieNode::NumLinks() const
{
    return (m_wInfo & LINKS_MASK)>>KEYBYTE_BITS;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapGuidToGuidBase::TrieNode::NumKeyBytes
//
//  Synopsis:   Return the number of bytes of the key stored in this node
//
//  Arguments:  (none)
//
//  Returns:    see synopsis
//
//--------------------------------------------------------------------------
inline int CMapGuidToGuidBase::TrieNode::NumKeyBytes() const
{
    return (m_wInfo & KEYBYTE_MASK);
}

//+-------------------------------------------------------------------------
//
//  Member:     CPSClsidTbl::TrieNode::IsLeaf
//
//  Synopsis:   Return whether a node is a Node or a Leaf
//
//  Arguments:  (none)
//
//  Returns:    TRUE if the node is a Leaf (is has no links)
//              FALSE if it is a Node (it has links)
//--------------------------------------------------------------------------
inline BOOL CMapGuidToGuidBase::TrieNode::IsLeaf() const
{
    if(m_wInfo & ISLEAF_MASK)
    {
        return TRUE;
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CPSClsidTbl::TrieNode::IsDeleted
//
//  Synopsis:   Return whether a given node is deleted
//
//  Arguments:  (none)
//
//  Returns:    TRUE if the node is marked as deleted
//              FALSE otherwise
//
//--------------------------------------------------------------------------
inline BOOL CMapGuidToGuidBase::TrieNode::IsDeleted() const
{
    if(m_wInfo & DELETED_MASK)
    {
        return TRUE;
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapGuidToGuidBase::TrieNode::SetLeaf
//
//  Synopsis:   sets the leaf bit of a node
//
//  Arguments:  [fLeaf] -    should be TRUE to set this node to a Leaf
//                           FALSE if this node should be a Node
//  Returns:    nothing
//
//--------------------------------------------------------------------------
inline void CMapGuidToGuidBase::TrieNode::SetLeaf(BOOL fLeaf)
{
    if(fLeaf)
    {
        m_wInfo = m_wInfo | ISLEAF_MASK;
    }
    else
    {
        m_wInfo = m_wInfo & (~ISLEAF_MASK);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapGuidToGuidBase::TrieNode::SetDeleted
//
//  Synopsis:   sets the deleted bit of a node
//
//  Arguments:  [fDeleted] -    should be TRUE to mark this node as deleted
//                              FALSE to not mark it (equivalent to un-marking it)
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------
inline void CMapGuidToGuidBase::TrieNode::SetDeleted(BOOL fDeleted)
{
    Win4Assert(IsLeaf() && "Tried to delete a non-Leaf TrieNode!");

    if (fDeleted)
    {
        m_wInfo = m_wInfo | DELETED_MASK;
    }
    else
    {
        m_wInfo = m_wInfo & (~DELETED_MASK);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapGuidToGuidBase::TrieNode::SetKeyBytes
//
//  Synopsis:   Sets the number of bytes of a key stored in this node
//
//  Arguments:  [nKeyBytes] -     the number of bytes
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------
inline void CMapGuidToGuidBase::TrieNode::SetKeyBytes(int nKeyBytes)
{
    Win4Assert(nKeyBytes <= GUID_BYTES && "Tried to add more than GUID_BYTES to a TrieNode!");

    m_wInfo = (m_wInfo & (~KEYBYTE_MASK)) |
              (nKeyBytes&KEYBYTE_MASK);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapGuidToGuidBase::TrieNode::SetLinks
//
//  Synopsis:   Sets the number of links used in a node
//
//  Arguments:  [nLinks] - the number of links used
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------
inline void CMapGuidToGuidBase::TrieNode::SetLinks(int nLinks)
{
    Win4Assert(nLinks <= 256 && "Tried to have more than 256 links in a node");

    m_wInfo = (m_wInfo & (~LINKS_MASK)) |
          ((nLinks<<KEYBYTE_BITS)&LINKS_MASK);
}

//+-------------------------------------------------------------------------
//
//  Member:     CPSClsidTbl::TrieNode::IncrementLinks
//
//  Synopsis:   Increments the number of links used in a node by 1
//
//  Arguments:  (none)
//
//  Returns:    (nothing)
//
//--------------------------------------------------------------------------
inline void CMapGuidToGuidBase::TrieNode::IncrementLinks()
{
    Win4Assert(((m_wInfo & LINKS_MASK)>>KEYBYTE_BITS) <= 255
                    && "Tried to insert past 256 links in a node");

    m_wInfo += (1<<KEYBYTE_BITS);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapGuidToGuidBase::TrieNode::GetKey
//
//  Synopsis:   Return a pointer to a node's key data
//
//  Arguments:  (none)
//
//  Returns:    see synopsis
//
//--------------------------------------------------------------------------
inline BYTE *CMapGuidToGuidBase::TrieNode::GetKey()
{
#if !defined(_M_IX86)
    // we need to worry about alignment
    // so we put the 2-byte GUIDIndex before the n-byte key
    if(IsLeaf())
    {
        return m_bData + sizeof(GUIDIndex);
    }
    else
    {
        return m_bData;
    }
#else
    // On the x86, we don't need to worry about alignment
    return m_bData; // remember, this pointer not based!!
#endif // !defined(_M_IX86)
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapGuidToGuidBase::TrieNode::GetData
//
//  Synopsis:   Return a pointer to a Leaf's data (the data mapped to the key)
//
//  Arguments:  (none)
//
//  Returns:    pointer to a Leaf's data
//
//--------------------------------------------------------------------------
inline GUIDIndex *CMapGuidToGuidBase::TrieNode::GetData()
{
    Win4Assert(IsLeaf() && "Tried to get data from a non-Leaf node!");

#if !defined(_M_IX86)
    // we need to worry about alignment
    // so we put the 2-byte GUIDIndex before the n-byte key
    return (GUIDIndex *) m_bData;
#else
    // On the x86, we don't need to worry about alignment
    return (GUIDIndex *) &m_bData[NumKeyBytes()];
#endif // !defined(_M_IX86)
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapGuidToGuidBase::TrieNode::GetNodeSize
//
//  Synopsis:   Calculates the amount of bytes a node will take with the given parameters
//
//  Arguments:  [bKeyBytes] -    the number of bytes of the key stored in this node
//              [fLeaf]        -    TRUE = Leaf node, FALSE = Node node
//              [bLinks]     -   the number of links to *allocate* (not the number of links used!!!!!)
//
//  Returns:    the computed size of the node
//
//--------------------------------------------------------------------------
inline DWORD CMapGuidToGuidBase::TrieNode::GetNodeSize(BYTE bKeyBytes, BOOL fLeaf, int bLinks)
{
    return sizeof(WORD)+bKeyBytes+sizeof(GUIDIndex)*(fLeaf?1:0)+bLinks*sizeof(TrieNodeBasedPtr);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapGuidToGuidBase::TrieNode::GetLinkStart
//
//  Synopsis:   Return the beginning of the link array of a node
//
//  Arguments:  (none)
//
//  Returns:    a pointer to the beginning of the link array
//
//--------------------------------------------------------------------------
inline TrieNodeBasedPtr UNALIGNED *CMapGuidToGuidBase::TrieNode::GetLinkStart() const
{
    return (TrieNodeBasedPtr UNALIGNED *) &m_bData[NumKeyBytes()];
}

//+-------------------------------------------------------------------------
//
//  Function:   TrieNode::InsertIntoLinkArray (static)
//
//  Synopsis:   insert a based pointer into the array of links to other nodes
//
//  Arguments:  [pArray] - pointer to the place in the array we wish to insert
//              [pInsert] - based pointer to insert
//              [nAfter] - number of nodes we need to "tumble" down the rest of the array
//
//  Returns:    void
//
//--------------------------------------------------------------------------
inline void CMapGuidToGuidBase::TrieNode::InsertIntoLinkArray(TrieNodeBasedPtr UNALIGNED *pbpArray, TrieNodeBasedPtr bpInsert,int nAfter)
{
    Win4Assert(pbpArray != NULL && "Tried to insert into a NULL link array");
    Win4Assert(bpInsert != 0 && "Tried to insert a NULL based pointer into link array");

    // must use memmove, because memory regions overlap
    memmove((pbpArray+1), pbpArray, nAfter*sizeof(TrieNodeBasedPtr));
    *pbpArray = bpInsert;
}

//+-------------------------------------------------------------------------
//
//  Function:   CMapGuidToGuidBase::TrieNode::FindLinkSize, static
//
//  Synopsis:   Finds the number of allocated links to hold a given number of used links
//
//  Arguments:  [num] number of used links
//
//  Returns:    number of allocated links
//
//--------------------------------------------------------------------------
inline int CMapGuidToGuidBase::TrieNode::FindLinkSize(int nLinks)
{
    if(nLinks <= NODE_LINKS)
    {
        return NODE_LINKS;
    }

    if(nLinks <= (NODE_LINKS+NODE_INIT_GROWBY))
    {
        return NODE_LINKS+NODE_INIT_GROWBY;
    }

    return NODE_GROWBY*((nLinks+(NODE_GROWBY-1))/NODE_GROWBY);
}

//+-------------------------------------------------------------------------
//
//  Function:   TrieNode::GetLink
//
//  Synopsis:   Given the next byte of a key, return the link to the next node in the trie
//
//  Arguments:  [pBase] - pointer to base of shared memory
//              [bComp] - the next byte of the key to look for a link on
//              [pbpLink]- a reference to a TrieNodeBasedPtr *, which on exit will hold
//                         the address of the link pointer so it can be changed
//                         in the future.
//  Returns:    the pointer to the node correspoding to bComp, or NULL if no such
//                  node exists
//
//--------------------------------------------------------------------------
CMapGuidToGuidBase::TrieNode *CMapGuidToGuidBase::TrieNode::GetLink(void *pBase, BYTE bComp, TrieNodeBasedPtr UNALIGNED *&pbpLink)
{
    TrieNodeBasedPtr UNALIGNED *pbpLower;
    TrieNodeBasedPtr UNALIGNED *pbpUpper;
    TrieNodeBasedPtr UNALIGNED *pbpIndex;
    BYTE bIndex;

    Win4Assert(!IsLeaf() && "Tried to get a link from a leaf!\n");

    pbpLower = GetLinkStart();
    pbpUpper = pbpLower+(NumLinks() - 1);

    // Use binary search
    while(pbpLower < pbpUpper)
    {
        pbpIndex = pbpLower + ((pbpUpper - pbpLower)>>1);
        bIndex =  *(((TrieNode PASSBASED *) (*pbpIndex))->GetKey());
        if(bComp < bIndex)
        {
            pbpUpper = pbpIndex - 1;
        }
        else
            if(bComp > bIndex)
            {
                pbpLower = pbpIndex + 1;
            }
            else
            {
                // found it
                pbpLink = pbpIndex;
                return BP_TO_P(TrieNode *, (TrieNode PASSBASED *)(*pbpIndex));
            }
    }

    if((pbpLower != pbpUpper) ||
        (bComp != *(((TrieNode PASSBASED *) (*pbpLower))->GetKey())))
    {
        return NULL; // didn't find anything
    }

    pbpLink = pbpLower;
    return BP_TO_P(TrieNode *, (TrieNode PASSBASED *) (*pbpLower));
}

//+-------------------------------------------------------------------------
//
//  Function:   TrieNode::AddLink (static)
//
//  Synopsis:   Adds a link to a node to the link array
//
//  Arguments:  [pBase]     - pointer to the base of the block of memory the trie is in
//              [pRoot]     - pointer of node to add to
//                             pretty much an explicit "this" pointer so we can
//                             avoid a recursive step if we need to allocated more
//                             links (and therefore a new node)
//              [pNode]     - pointer of node to add
//              [pbpNewNode]- handle to stick a new node in if we need to increase
//                             the number of links allocated to this node. If this is
//                             done, the original node will be deleted, so we need to
//                             change references to it.
//              [alloc]     - The allocator to use to allocate new memory
//
//  Returns:    S_OK if link was added without allocating more links,
//               S_FALSE if more links were allocated, and there for *pbpNewNode is the
//               pointer of the node that should be used to replace this one.
//               Otherwise appropriate status code
//
//--------------------------------------------------------------------------
HRESULT CMapGuidToGuidBase::TrieNode::AddLink(void *pBase, TrieNode *pRoot, TrieNode *pNode,
    TrieNodeBasedPtr UNALIGNED*pbpNewNode,  CAllocFunctor &alloc)
{
    Win4Assert(pNode != NULL && "Tried to add link to NULL TrieNode");
    Win4Assert(!pRoot->IsLeaf() && "Tried to add link to leaf TrieNode"); // can't add links to leafs!
    HRESULT retVal = S_OK;
    int newLinks = NODE_LINKS;

    if(pRoot->NumLinks() == NODE_LINKS) // Check to see if we need more links
    {
        newLinks += NODE_INIT_GROWBY;     // we need to grow by NODE_INIT_GROWBY
    }
    else if (((pRoot->NumLinks()&NODE_GROWBY_MOD_MASK) == 0) && (pRoot->NumLinks() != 0))
    {
        // we need to grow by NODE_GROWBY
        // this computes the size of the node
        newLinks = pRoot->NumLinks()+NODE_GROWBY;
    }
    else
    {
        newLinks = 0;                     // we don't need to grow
    }

    if((newLinks != 0) && (newLinks <= 256)) // we don't grow over 256
    {
        TrieNode *pTemp;

        // we have to allocate another TrieNode, we've used all our links
        Win4Assert(pRoot->NumLinks() <= 255);

        // Create new trienode with more links
        pTemp = (TrieNode *) alloc.Alloc(GetNodeSize(pRoot->NumKeyBytes(), FALSE, newLinks));

        if(pTemp == NULL)
        {
            return E_OUTOFMEMORY;
        }

        *pbpNewNode = (TrieNodeBasedPtr) P_TO_BP(TrieNode PASSBASED *, pTemp);

        // Copy over current data
        memcpy(pTemp, pRoot, GetNodeSize(pRoot->NumKeyBytes(), FALSE, pRoot->NumLinks()));

        // we don't delete the current node
        alloc.Free(pRoot, GetNodeSize(pRoot->NumKeyBytes(), FALSE, pRoot->NumLinks()));

        pRoot = pTemp;

        retVal = S_FALSE;
    }

    if(pRoot->NumLinks() == 0) // Now that that's taken care of, let's add the link
    {
        // just pluck it right in the beginning
        *(pRoot->GetLinkStart()) = (TrieNodeBasedPtr) P_TO_BP(TrieNode PASSBASED *, pNode);
    }
    else
    {
        // Insert using binary insertion
        // This gives us an array in sorted order
        TrieNodeBasedPtr UNALIGNED *pbpLower;
        TrieNodeBasedPtr UNALIGNED *pbpUpper;
        TrieNodeBasedPtr UNALIGNED *pbpIndex;
        BYTE bIndex;

        pbpLower = pRoot->GetLinkStart();
        pbpUpper = pbpLower + (pRoot->NumLinks() - 1);

        while(pbpLower < pbpUpper)
        {
            pbpIndex = pbpLower + (pbpUpper - pbpLower)/2;
            bIndex =  *(((TrieNode PASSBASED *) (*pbpIndex))->GetKey());
            if(*(pNode->GetKey())  < bIndex)
            {
                pbpUpper = pbpIndex - 1;
            }
            else
                if(*(pNode->GetKey()) > bIndex)
                {
                    pbpLower = pbpIndex + 1;
                }
                else
                {
                    // we shouldn't have duplicates in the table
                    Win4Assert(0 && "Duplicate Entries in IID->CLSID table!\n");
                }
        }
        TrieNodeBasedPtr UNALIGNED *pStart = pRoot->GetLinkStart();
        int iNumLinks = pRoot->NumLinks();

        if(*(((TrieNode PASSBASED *) (*pbpLower))->GetKey()) > *(pNode->GetKey()))
        {
            // insert before
            InsertIntoLinkArray(pbpLower,
                                (TrieNodeBasedPtr) P_TO_BP(TrieNode PASSBASED *, pNode),
                                iNumLinks - (pbpLower - pStart));
        }
        else
        {
            // insert after
            InsertIntoLinkArray(pbpLower+1,
                                (TrieNodeBasedPtr) P_TO_BP(TrieNode PASSBASED *, pNode),
                                iNumLinks - (pbpLower+ 1 - pStart));
        }

    }


    // Keep track of how many links
    pRoot->IncrementLinks();

    return retVal;
}

//+-------------------------------------------------------------------------
//
//  Function:   TrieNode::CreateSuffixNode
//
//  Synopsis:   Creates a suffix node from the current node. A suffix node is
//               the same node except with the bytes that are the same chopped off the beginning
//               of the key
//
//  Arguments:  [bBytesDifferent] - the number of bytes which make up the suffix
//              [alloc]        - a memory allocator to use
//
//  Returns:    pointer to a TrieNode, which is the suffix node
//
//--------------------------------------------------------------------------
CMapGuidToGuidBase::TrieNode *CMapGuidToGuidBase::TrieNode::CreateSuffixNode(BYTE bBytesDifferent,
        CAllocFunctor &alloc)
{
    TrieNode *pNewNode;

    if(IsLeaf())
    {
        // Create a Suffix leaf
        pNewNode = (TrieNode *) alloc.Alloc(GetNodeSize(bBytesDifferent, TRUE, 0));

        if(pNewNode == NULL)
        {
            return NULL;
        }

        pNewNode->SetLeaf(TRUE);
        pNewNode->SetKeyBytes(bBytesDifferent);
        pNewNode->SetLinks(0);
        memcpy(pNewNode->GetKey(), GetKey()+(NumKeyBytes() - bBytesDifferent), bBytesDifferent);
        *(pNewNode->GetData()) = *(GetData());
    }
    else
    {
        // Create a Suffix Node
        pNewNode = (TrieNode *) alloc.Alloc(GetNodeSize(bBytesDifferent, FALSE, FindLinkSize(NumLinks())));

        if(pNewNode == NULL)
        {
            return NULL;
        }

        pNewNode->SetKeyBytes(bBytesDifferent);
        pNewNode->SetLeaf(FALSE);
        pNewNode->SetLinks(NumLinks());
        memcpy(pNewNode->GetKey(), GetKey()+(NumKeyBytes() - bBytesDifferent), bBytesDifferent);
        memcpy(pNewNode->GetLinkStart(), GetLinkStart(), NumLinks()*sizeof(TrieNodeBasedPtr));

    }

    return pNewNode;
}

//+-------------------------------------------------------------------------
//
//  Function:   TrieNode::CreateTrieNode (static)
//
//  Synopsis:   creates a trie Node with the passed data
//
//  Arguments:  [pbKey] - a pointer to key data (goes forward)
//              [bKeyBytes] - how many bytes are in the key
//              [bLinks] - how many links to allocated (must be power of 2)
//              [alloc] - a memory allocator to use
//
//  Returns:    a pointer to a TrieNode filled with the above data
//
//--------------------------------------------------------------------------
CMapGuidToGuidBase::TrieNode *CMapGuidToGuidBase::TrieNode::CreateTrieNode(const BYTE *pbKey,
                                                                         BYTE bKeyBytes,
                                                                         BYTE bLinks,
                                                                          CAllocFunctor &alloc)
{
    TrieNode *pNode;

    // if pbKey == NULL, bKeyBytes must = 0
    Win4Assert(pbKey != NULL || (bKeyBytes == 0));
    Win4Assert(bKeyBytes >= 0);

    pNode = (TrieNode *) alloc.Alloc(GetNodeSize(bKeyBytes, FALSE, bLinks));

    if(pNode == NULL)
    {
        return NULL;
    }

    pNode->SetLeaf(FALSE);
    pNode->SetKeyBytes(bKeyBytes);
    pNode->SetLinks(0);
    memcpy(pNode->GetKey(), pbKey, bKeyBytes);

    return pNode;
}

//+-------------------------------------------------------------------------
//
//  Function:   TrieNode::CreateTrieLeaf (static)
//
//  Synopsis:   creates a Leaf node with the passed data
//
//  Arguments:  [pbKey] - a pointer to the key data    (goes backwards)
//              [bKeyBytes] - how many bytes are in the key
//              [data] - a GUIDIndex this key maps to.
//              [alloc] - a memory allocator to use
//
//  Returns:    a pointer to a TrieNode structure filled with above data
//
//--------------------------------------------------------------------------
CMapGuidToGuidBase::TrieNode *CMapGuidToGuidBase::TrieNode::CreateTrieLeaf(const BYTE *pbKey,
                                                                         BYTE bKeyBytes,
                                                                         GUIDIndex data,
                                                                          CAllocFunctor &alloc)
{
    Win4Assert(pbKey != NULL);
    Win4Assert(bKeyBytes > 0);

    TrieNode *pNode;

    pNode = (TrieNode *) alloc.Alloc(GetNodeSize(bKeyBytes, TRUE, 0));

    if(pNode == NULL)
    {
        return NULL;
    }

    pNode->SetLeaf(TRUE);
    pNode->SetKeyBytes(bKeyBytes);
    pNode->SetLinks(0);
    bmemcpy(pNode->GetKey(), pbKey, bKeyBytes);
    *(pNode->GetData()) = data;

    return pNode;
}


//+-------------------------------------------------------------------------
//
//  Function:   TrieNode::AddKey (static)
//
//  Synopsis:   This function adds a key/GUIDBasedPtr pair to the passed trie.
//
//  Arguments:  [pBase] - the base of our shared memory block
//              [pRoot] - the root node of the trie (explicit "this" pointer)
//              [pbpPrev] - a handle to the previous reference to the root node,
//                          so that if AddLink requires us to update it, we can.
//              [pbKey] - a pointer to the END of the key data, we add the key reversed!!!
//              [data]  - the GUIDIndex to map this key to
//              [fReplace] - whether or not we should replace an existing entry
//              [alloc] - a memory allocator to use
//
//  Returns:    S_OK if successful, S_FALSE if the key was already in the trie and fReplace == FALSE,
//               appropriate error code otherwise
//
//--------------------------------------------------------------------------
HRESULT CMapGuidToGuidBase::TrieNode::AddKey(void *pBase, TrieNode *pRoot, TrieNodeBasedPtr UNALIGNED *pbpPrev,
                                                const BYTE *pbKey, GUIDIndex data, BOOL fReplace,
                                                 CAllocFunctor &alloc)
{
    Win4Assert(pRoot != NULL && "Tried to add key to NULL trie");
    Win4Assert(pbpPrev != NULL && "Backlink to Trie NULL");
    Win4Assert(pbKey != NULL && "Pointer to key data NULL");

    int numDifferent, nNodeKeyBytes, nKeyBytes;
    BYTE *pbNodeKey;
    TrieNode *pNextLevel, *pNewNode, *pPrefixNode, *pSuffixNode;
    TrieNodeBasedPtr UNALIGNED *pbpLinkPointer;
    TrieNodeBasedPtr bpDummy;

    nKeyBytes = GUID_BYTES;                    // Every Key is a full GUID
    pbNodeKey = pRoot->GetKey();
    nNodeKeyBytes = pRoot->NumKeyBytes();

    // while both keys are the same, traverse the trie
    while((numDifferent = bmemcmp(pbNodeKey, pbKey, nNodeKeyBytes)) == 0)
    {
        Win4Assert(nKeyBytes >= nNodeKeyBytes);

        // Key prefix is the same
        if(nKeyBytes == nNodeKeyBytes)         // that means these keys are *exactly* the same!!!
        {                                    // so we might have to replace the key/data mapping
            if(pRoot->IsDeleted() || fReplace)
            {
                Win4Assert(pRoot->IsLeaf());
                // the leaf node is deleted, or the replace flag is set, we can write over the data map
                *(pRoot->GetData()) = data;
                pRoot->SetDeleted(FALSE);     // this doesn't hurt if the node wasn't deleted in the first place

                return S_OK;
            }

            return S_FALSE;                 // else we don't do anything
        }

        pbKey-= nNodeKeyBytes;                // Chop off this part of the key, continue down the trie
        nKeyBytes -= nNodeKeyBytes;
        pNextLevel = BP_TO_P(TrieNode *, (TrieNode PASSBASED *) pRoot->GetLink(pBase, *pbKey, pbpLinkPointer));

        if(pNextLevel == NULL) // no next level, create new leaf here
        {
            HRESULT hr;

            pNewNode = CreateTrieLeaf(pbKey, nKeyBytes, data, alloc);

            if(pNewNode == NULL)
            {
                return E_OUTOFMEMORY;
            }

            hr = AddLink(pBase, pRoot, pNewNode, &bpDummy, alloc);

            if(FAILED(hr))
            {
                return hr;
            }

            if(hr == S_FALSE)
            {
                // had to allocate a new node (ran out of links), reattatch to previous link
                *pbpPrev = bpDummy;
            }

            return S_OK;
        }

        pRoot = pNextLevel;
        pbpPrev = pbpLinkPointer;
        pbNodeKey = pRoot->GetKey();
        nNodeKeyBytes = pRoot->NumKeyBytes();
    }

    // we have to split the tree up
    Win4Assert(*pbNodeKey == *pbKey && "Took wrong path in Trie"); // if this isn't true, something's really messed up

    // We create three nodes : a prefix node, containing the part of the key similar both to the existing
    // GUIDs in the trie and the new GUID we are adding
    // a new node, containing the part of the new GUID that's DIFFERENT from the rest
    // a suffix node, containg the part of the old GUID subtrie that's different from the new GUID
    pSuffixNode = pRoot->CreateSuffixNode(numDifferent, alloc);

    if(pSuffixNode == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pNewNode = CreateTrieLeaf(pbKey-(nNodeKeyBytes - numDifferent), nKeyBytes - (nNodeKeyBytes - numDifferent),
                                data, alloc);

    if(pNewNode == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pPrefixNode = CreateTrieNode(pbNodeKey, (nNodeKeyBytes - numDifferent), NODE_LINKS, alloc);

    if(pPrefixNode == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Delete original node
    alloc.Free(pRoot, GetNodeSize(pRoot->NumKeyBytes(), pRoot->IsLeaf(), FindLinkSize(pRoot->NumLinks())));

    *pbpPrev = (TrieNodeBasedPtr) P_TO_BP(TrieNode PASSBASED *, pPrefixNode);

    // This is the assumption we make, that each new node has at least 2 links pre-allocated
    Win4Assert(NODE_LINKS >= 2);

    // We add the link here without calling AddLink because we know that our newly created node
    // has no existing links, and we can just stick the two in order
    if(*(pSuffixNode->GetKey()) < *(pNewNode->GetKey()))
    {
        // suffix node goes before new node
        *(pPrefixNode->GetLinkStart()) = (TrieNodeBasedPtr) P_TO_BP(TrieNode PASSBASED *, pSuffixNode);
        pPrefixNode->IncrementLinks();

        *(pPrefixNode->GetLinkStart()+1) = (TrieNodeBasedPtr) P_TO_BP(TrieNode PASSBASED *, pNewNode);
        pPrefixNode->IncrementLinks();
    }
    else
    {
        // new node goes before suffix node
        *(pPrefixNode->GetLinkStart()+1) = (TrieNodeBasedPtr) P_TO_BP(TrieNode PASSBASED *, pNewNode);
        pPrefixNode->IncrementLinks();

        *(pPrefixNode->GetLinkStart()) = (TrieNodeBasedPtr) P_TO_BP(TrieNode PASSBASED *, pSuffixNode);
        pPrefixNode->IncrementLinks();
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   TrieNode::RemoveKey (static)
//
//  Synopsis:   Given a key and a trie, removes the key from the trie
//
//
//  Arguments:  [pRoot] - the trie (explicit "this" pointer)
//              [ppPrev] - a handle to the previous reference to the root node,
//                         so that if we need to update it, we can.
//              [pbKey] - the key
//
//  Returns:    TRUE if we succeeded
//               FALSE if we failed to find the key
//--------------------------------------------------------------------------
/*BOOL CMapGuidToGuidBase::TrieNode::RemoveKey(void *pBase, TrieNode *pRoot, const BYTE *pbKey)
{
    int nKeyBytes = GUID_BYTES;
    TrieNodeBasedPtr *ppDummy;
    Win4Assert(pRoot != NULL);
    Win4Assert(pbKey != NULL);

    while(pRoot != NULL)
    {
        if(bmemcmp(pRoot->GetKey(), pbKey, pRoot->NumKeyBytes()))
        {
            return FALSE; // if the prefix of this node ain't the same as the prefix of the key
                          // then the key is not in the table
        }

        pbKey -= pRoot->NumKeyBytes();
        nKeyBytes -= pRoot->NumKeyBytes();

        Win4Assert(nKeyBytes >= 0);

        if(nKeyBytes == 0) // then this should be a leaf node
        {
            Win4Assert(pRoot->IsLeaf());

            if(!pRoot->IsDeleted())
            {
                pRoot->SetDeleted(TRUE); // set the flag on the node to deleted

                return TRUE;
            }

            return FALSE; // node is already deleted
        }

        pRoot = pRoot->GetLink(pBase, *pbKey, ppDummy);
    }

    return FALSE;
}
*/

//+-------------------------------------------------------------------------
//
//  Function:   TrieNode::TraverseKey (static)
//
//  Synopsis:   Given a key, a trie, and a place to store data, find the data mapped to the key
//
//  Arguments:  [pBase] - the base pointer of our memory block
//              [pRoot] - the trie to traverse (explicit "this" pointer)
//              [pbKey] - a pointer to the key data
//              [data]  - a GUIDIndex ref to stick the data in if we succeed
//
//  Returns:    TRUE if we succeeded, then dwData has the GUIDIndex mapped to the passed key
//               FALSE if we failed to find the key
//--------------------------------------------------------------------------
BOOL CMapGuidToGuidBase::TrieNode::TraverseKey(void *pBase, TrieNode *pRoot, const BYTE *pbKey,
                                                 GUIDIndex  &data)
{
    Win4Assert(pRoot != NULL && "Tried to traverse a NULL Trie");
    Win4Assert(pbKey != NULL && "Pointer to key data is NULL");
    int bKeyBytes = GUID_BYTES;
    TrieNodeBasedPtr UNALIGNED *pbpDummy;

    while(pRoot != NULL)
    {
        if(bmemcmp(pRoot->GetKey(), pbKey, pRoot->NumKeyBytes()))
        {
            return FALSE; // if the prefix of this node ain't the same as the prefix of the key
                          // then the key is not in the table
        }

        pbKey -= pRoot->NumKeyBytes();
        bKeyBytes -= pRoot->NumKeyBytes();

        Win4Assert(bKeyBytes >= 0 && "Too many key bytes in this Trie path");

        if(bKeyBytes == 0) // then this should be a leaf node
        {
            Win4Assert(pRoot->IsLeaf() && "Ran out of key bytes before got to leaf");

            if(pRoot->IsDeleted()) // is this node deleted
            {
                return FALSE; // if so, this map is not valid
            }

            data = *(pRoot->GetData());

            return TRUE;
        }

        pRoot = pRoot->GetLink(pBase, *pbKey, pbpDummy);
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   TrieNode::CopyToSharedMem
//
//  Synopsis:   Copy a given trie from one memory block to another
//
//  Arguments:  [pNewBase] - the base of the destination memory block
//              [pOldBase] - the base of the source memory block
//              [pRoot]       - the trie to copy
//              [alloc]    - the allocation functor to use to allocate memory
//
//  Returns:    a based pointer (off of pNewBase) to the newly copied trie
//               NULL if we failed to copy the trie
//--------------------------------------------------------------------------

TrieNodeBasedPtr CMapGuidToGuidBase::TrieNode::CopyToSharedMem(void *pNewBase, void *pOldBase, TrieNode *pRoot,
                                                                CAllocFunctor &alloc)
{
    // we use recursion here because it is more complex than simple tail recursion
    // and a non-recursive implementation would be very confusing
    // considering that there is a recursive depth of at most 16, this means this function
    // could take a maximum of 7*4*16=448 bytes on the stack
    TrieNode *pCopy;

    Win4Assert(pRoot != NULL && "Tried to copy a NULL Trie to shared memory");

    if(pRoot->IsLeaf())
    {
        // allocate shared memory
        pCopy = (TrieNode *) alloc.Alloc(GetNodeSize(pRoot->NumKeyBytes(), TRUE, 0));

        if(pCopy == NULL)
        {
            return (TrieNodeBasedPtr) BP_TO_P(TrieNode NEWBASED *, NULL);
        }

        // copy over data
        memcpy(pCopy, pRoot, GetNodeSize(pRoot->NumKeyBytes(), TRUE, 0));

        return (TrieNodeBasedPtr) P_TO_BP(TrieNode NEWBASED *, pCopy);
    }
    else
    {
        // allocate shared memory
        pCopy = (TrieNode *) alloc.Alloc(GetNodeSize(pRoot->NumKeyBytes(), FALSE,
                                            FindLinkSize(pRoot->NumLinks())));

        if(pCopy == NULL)
        {
            return (TrieNodeBasedPtr) BP_TO_P(TrieNode NEWBASED *, NULL);
        }

        // copy over data
        memcpy(pCopy, pRoot, sizeof(WORD)+pRoot->NumKeyBytes());

        // recursively set links
        for(int i = 0; i < pRoot->NumLinks(); i++)
        {
            (pCopy->GetLinkStart())[i] = CopyToSharedMem(pNewBase, pOldBase, BP_TO_P(TrieNode *,
                                            (TrieNode OLDBASED *)(pRoot->GetLinkStart()[i])),
                                                alloc);
            if(BP_TO_P(TrieNode *, (TrieNode NEWBASED *) (pCopy->GetLinkStart())[i]) == NULL)
            {
                return (TrieNodeBasedPtr) BP_TO_P(TrieNode NEWBASED *, NULL);
            }
        }

        return (TrieNodeBasedPtr) P_TO_BP(TrieNode NEWBASED *, pCopy);
    }
}


// *** CPSClsidTbl *** (DLL)
//+-------------------------------------------------------------------------
//
//  Function:   CPSClsidTbl::Initialize
//
//  Synopsis:   Initializes the client side of the guid->guid map
//
//  Arguments:  [pscMapName] - name of this stack, used to create a shared stack
//
//  Returns:    appropriate status code
//
//--------------------------------------------------------------------------
HRESULT CPSClsidTbl::Initialize(void *pBase)
{
    HRESULT hr;

    CairoleDebugOut((DEB_ITRACE, "CPSClsidTbl::Initialize(pBase = %p)\n", pBase));

    hr = CMapGuidToGuidBase::Initialize(pBase);

    if(SUCCEEDED(hr))
    {
        // Get a pointer to our shared memory header
        m_pHeader = (SharedMemHeader *) m_pMemBase;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CPSClsidTbl::Find
//
//  Synopsis:   Given a GUID key, looks for the data mapped to it
//
//  Arguments:  [refguid] - a C++ reference to a GUID structure
//              [pGuidOut] - a GUID * to store the data in
//
//  Returns:    a pointer to the data (really pGuidOut)
//               NULL if guid was not found
//
//--------------------------------------------------------------------------
HRESULT CPSClsidTbl::Find(REFGUID srcguid, GUID *pGuidOut) const
{
    GUIDIndex iGuid;
    HRESULT hr;

    SETUP_BASE_POINTER();

    if(IsFull()) // initialize hr to error value
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = REGDB_E_IIDNOTREG;
    }

    if(TrieNode::TraverseKey(m_pMemBase, BP_TO_P(TrieNode *, (TrieNode PASSBASED *)m_pHeader->m_bpTrie),
                            ((const BYTE *)&srcguid)+GUID_BYTES-1, iGuid))
    {
        if(m_pHeader->m_GUIDs.GetGuid(m_pMemBase, iGuid, *pGuidOut))
        {
            hr = S_OK; // set hr to OK
        }
        else
        {
            CairoleDebugOut((DEB_IWARN, "CPSClsidTbl: Found GUID %I in table, but couldn't find CLSID at %d\n",
                              srcguid, iGuid));
        }
    }
    else
    {
        CairoleDebugOut((DEB_IWARN, "CPSClsidTbl: Couldn't find GUID - %I\n", &srcguid));
    }

    return hr;
}


// *** CScmPSClsidTbl *** (SCM)
//+-------------------------------------------------------------------------
//
//  Function:   CScmPSClsidTbl::Initialize
//
//  Synopsis:   Initializes the server side of the guid->guid map
//
//  Arguments:  [pscMapName] - name of this stack, used to create a shared stack
//
//  Returns:    appropriate status code
//
//--------------------------------------------------------------------------
HRESULT CScmPSClsidTbl::Initialize()
{
    HRESULT hr;

    CairoleDebugOut((DEB_ITRACE, "CScmPSClsidTbl::Initialize()\n"));

    hr = CMapGuidToGuidBase::Initialize(NULL);

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CScmPSClsidTbl::AddLocal
//
//  Synopsis:   Adds a key/data (GUID/GUIDBasedPtr) pair to internal dictionary
//
//  Arguments:  [guid] - a C++ reference to a GUID structure
//              [dataGuid] - a GUID to map the GUID to
//              [fReplace] - if TRUE, if the guid is already a key
//                             replace what it is mapped to with dataGuid
//
//  Returns:    TRUE if key/data pair was added to the dictionary
//               FALSE if key was already in dictionary
//
//--------------------------------------------------------------------------
HRESULT CScmPSClsidTbl::AddLocal(REFGUID keyGuid, REFGUID dataGuid, BOOL fReplace)
{
    GUIDIndex iGuid;
    CHeapAlloc heap(m_hHeap); // create allocation functor
    void *pBase = NULL;     // the base of our locally-created table
                         // we use this so we can support adding GUIDs to the table later, when it is in shared memory

    CairoleDebugOut((DEB_ITRACE, "CScmPSClsidTbl::AddLocal called with keyGuid = %I, dataGuid = %I, fReplace =%d.\n"
                        , &keyGuid, &dataGuid, (DWORD) fReplace));

    // Add guid to array of GUIDs
    iGuid = m_pLocalHeader->m_GUIDs.AddGuid(pBase, dataGuid, heap);

    if(iGuid == INVALID_GUID_INDEX)
    {
        m_pLocalHeader->m_fFull = TRUE;     // we are out of memory

        return E_OUTOFMEMORY;
    }

    return TrieNode::AddKey(pBase, BP_TO_P(TrieNode *, (TrieNode PASSBASED *) m_pLocalHeader->m_bpTrie),
                            &m_pLocalHeader->m_bpTrie, ((const BYTE *)&keyGuid)+GUID_BYTES - 1,
                            iGuid, fReplace, heap);
}

//+-------------------------------------------------------------------------
//
//  Function:   CScmPSClsidTbl::Delete
//
//  Synopsis:   Given a GUID key, removes it from the trie
//
//  Arguments:  [guid] - a C++ reference to a GUID structure
//
//  Returns:    TRUE if key/data pair was found and deleted
//               FALSE if key was not found
//
//--------------------------------------------------------------------------
/*BOOL CScmPSClsidTbl::Delete(REFGUID srcguid)
{
    TrieNode *pRoot;
    BYTE index;

    SETUP_BASE_POINTER();

    index = *(((const BYTE *)&srcguid)+GUID_BYTES - 1);

    pRoot = BP_TO_P(TrieNode *, (TrieNode PASSBASED *) m_pHeader->m_pTries[index]);

    if(pRoot == NULL)
    {
        return FALSE;
    }

    return TrieNode::RemoveKey(m_pMemBase, pRoot, ((const BYTE *)&srcguid)+GUID_BYTES-1);
}
*/

//+-------------------------------------------------------------------------
//
//  Member:     CScmPSClsidTbl::CopytoSharedMem
//
//  Synopsis:   Copies a locally created GUID->GUID map into shared memory
//
//  Arguments:  [pBase] - base pointer of shared memory
//              [alloc] - stack-based allocator of shared memory
//
//  Returns:    appropriate status code
//
//--------------------------------------------------------------------------
HRESULT CScmPSClsidTbl::CopyToSharedMem(void *pBase, CSmStackAllocator &alloc)
{
    HRESULT hr = S_OK;
    Win4Assert(m_hHeap != NULL);
    CStackAlloc stack(alloc);
    void *pOldBase = NULL;

    // Allocate our shared memory header
    m_pHeader = (SharedMemHeader *) alloc.Alloc(sizeof(SharedMemHeader));

    if(m_pHeader == NULL)
    {
        return E_OUTOFMEMORY;
    }

    m_pMemBase = pBase;
    m_pHeader->m_fFull = m_pLocalHeader->m_fFull;

    // first copy over guids
    hr = m_pLocalHeader->m_GUIDs.CopyToSharedMem(m_pMemBase, pOldBase, &(m_pHeader->m_GUIDs), stack);

    if(SUCCEEDED(hr))
    {
        // now copy over our trie
        if( BP_TO_P(TrieNode *, (TrieNode OLDBASED *) m_pLocalHeader->m_bpTrie) != NULL)
        {
            m_pHeader->m_bpTrie = TrieNode::CopyToSharedMem(m_pMemBase, pOldBase,
                        BP_TO_P(TrieNode *, (TrieNode OLDBASED *) m_pLocalHeader->m_bpTrie), stack);

            if(BP_TO_P(TrieNode *, (TrieNode PASSBASED *) m_pHeader->m_bpTrie) == NULL)
            {
                m_pHeader->m_fFull = TRUE;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            m_pHeader->m_fFull = TRUE;
            hr = E_OUTOFMEMORY;
        }
    }

    // we are done
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScmPSClsidTbl::InitTbl
//
//  Synopsis:   intializes the table
//
//  Arguments:  none
//
//  Returns :   appropriate status code
//
//--------------------------------------------------------------------------
HRESULT CScmPSClsidTbl::InitTbl()
{
    HKEY     hKey;
    FILETIME ftLastWrite;
    WCHAR   awName[MAX_PATH], awcsPSClsid[80];
    WCHAR     *pwcEndOfName;
    GUID     guidIID, guidCLSID;
    DWORD   cName = sizeof(awName);
    DWORD   iSubKey = 0;
    LONG      cbPSClsid = sizeof(awcsPSClsid);
    void *pOldBase = NULL;

    // Create a local heap to build the trie in
    m_hHeap = HeapCreate(0, MAP_INITIAL_SIZE, MAP_MAX_SIZE);

    if(m_hHeap == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // allocate our local header
    m_pLocalHeader = (LocalMemHeader *) HeapAlloc(m_hHeap, 0, sizeof(LocalMemHeader));

    if(m_pLocalHeader == NULL)
    {
        return E_OUTOFMEMORY;
    }

    m_pLocalHeader->m_fFull = FALSE;

    m_pLocalHeader->m_GUIDs.Initialize();
    TrieNode *pNode = TrieNode::CreateTrieNode(NULL, 0, NODE_LINKS, CHeapAlloc(m_hHeap));
    m_pLocalHeader->m_bpTrie = (TrieNodeBasedPtr) P_TO_BP(TrieNode OLDBASED *, pNode);

    if(BP_TO_P(TrieNode *, (TrieNode OLDBASED *) m_pLocalHeader->m_bpTrie) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //    enumerate the interface keys in the registry and create a table
    //    entry for each interface that has a ProxyStubClsid32 entry.

    #ifdef _CHICAGO_
    if (RegOpenKeyExA(HKEY_CLASSES_ROOT, tszInterface, NULL, KEY_READ, &hKey)
    == ERROR_SUCCESS)
    #else //_CHICAGO_
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, tszInterface, NULL, KEY_READ, &hKey)
    == ERROR_SUCCESS)
    #endif //_CHICAGO_

    {
        while (RegEnumKeyEx(hKey, iSubKey, awName, &cName,
                    NULL, NULL, NULL, &ftLastWrite) == ERROR_SUCCESS)
        {
            // Get data from registry for this interface

            // This variable is used below to overwrite the ProxyStubClsid32
            pwcEndOfName = awName + lstrlenW(awName);

            lstrcatW(awName, wszProxyStubClsid);

            if (RegQueryValue(hKey, awName, awcsPSClsid, &cbPSClsid)
                       == ERROR_SUCCESS)
            {
                // Convert registry string formats to GUID formats
                *pwcEndOfName = 0;

                if (GUIDFromString(awName, &guidIID))
                {
                    if (GUIDFromString(awcsPSClsid, &guidCLSID))
                    {

                        if (FAILED(AddLocal(guidIID, guidCLSID, TRUE)))
                        {
                            // we ran out of space in the cache table, exit
                            // now to avoid doing anymore work
                            break;
                        }
                    }
                }
            }
            else
            {
                //
                // There wasn't a ProxyStubClsid32 for this interface.
                // Because many applications install with interfaces
                // that are variations on IDispatch, we are going to check
                // to see if there is a ProxyStubClsid. If there is, and its
                // class is that of IDispatch, then the OLE Automation DLL is
                // the correct one to use. In that particular case, we will
                // pretend that ProxyStubClsid32 existed, and that it is
                // for IDispatch.
                //

                // Copy over ProxyStubClsid

                lstrcpyW(pwcEndOfName,wszProxyStubClsid16);

                if (RegQueryValue(hKey, awName, awcsPSClsid, &cbPSClsid)
                               == ERROR_SUCCESS)
                {
                    // Convert registry string formats to GUID formats
                    if (GUIDFromString(awcsPSClsid, &guidCLSID))
                    {
                        //
                        // If the clsid for the proxy stub is that of
                        // IDispatch, then register it.
                        //
                        *pwcEndOfName = 0;
                        if (!memcmp(&guidCLSID,&CLSID_PSDispatch, sizeof(GUID)) &&
                            GUIDFromString(awName, &guidIID))
                        {

                        if (FAILED(AddLocal(guidIID, guidCLSID, TRUE)))
                        {
                            // we ran out of space in the cache table, exit
                            // now to avoid doing anymore work
                            break;
                        }
                        }
                    }
                }
            }

            iSubKey++;
            cName = sizeof(awName);
        }

        RegCloseKey(hKey);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\smcreate.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	smcreate.cxx
//
//  Contents:	Routines for Creating or Opening memory mapped files.
//
//  Functions:	CreateSharedFileMapping
//		OpenSharedFileMapping
//		CloseSharedFileMapping
//
//  History:	03-Nov-93 Ricksa    Created
//		07-Apr-94 Rickhi    Seperated into APIs
//
//  Notes:	These APIs are used by dirrot.cxx, dirrot2.cxx, smblock.cxx,
//		(both ole32.dll and scm.exe), that is why they are in the
//		the directory.
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <secdes.hxx>
#include    <smcreate.hxx>

//+-------------------------------------------------------------------------
//
//  Function:	CreateSharedFileMapping
//
//  Synopsis:	Creates or gets access to memory mapped file.
//
//  Arguments:	[pszName]   - name of file
//		[ulSize]    - size of shared memory
//		[ulMapSize] - size of shared memory to map right now
//		[pvBase]    - base address to request
//		[lpSecDes]  - security descriptor
//		[dwAccess]  - access wanted
//		[ppv]	    - return address for memory ptr
//		[pfCreated] - returns TRUE if memory was created
//
//  Algorithm:	Creates a file mapping of the requested name and size
//		and maps it into memory with READ and WRITE access.
//
//  Returns:	HANDLE of file or NULL if failed.
//		[ppv]	    - base address of shared memory
//		[fCreated]  - TRUE if the file was created.
//
//  Notes:
//
//--------------------------------------------------------------------------

HANDLE CreateSharedFileMapping(WCHAR *pszName,
	  ULONG ulSize,
	  ULONG ulMapSize,
	  void *pvBase,
	  PSECURITY_DESCRIPTOR lpSecDes,
	  DWORD dwAccess,
	  void **ppv,
	  BOOL *pfCreated)
{
    CairoleDebugOut((DEB_MEMORY,
		    "CreateSharedFileMapping name:%ws size:%x base:%x\n",
		    pszName, ulSize, pvBase));

    BOOL fCreated = TRUE;

#if defined(_CHICAGO_)
    //	no security on Chicago
    lpSecDes = NULL;
#else
    CWorldSecurityDescriptor wsd;
    if (lpSecDes == NULL)
    {
	lpSecDes = &wsd;
    }
#endif

    // Holder for attributes to pass in on create.
    SECURITY_ATTRIBUTES secattr;

    secattr.nLength = sizeof(SECURITY_ATTRIBUTES);
    secattr.lpSecurityDescriptor = lpSecDes;
    secattr.bInheritHandle = FALSE;

    // Create the shared memory object
    HANDLE hMem = CreateFileMappingW(INVALID_HANDLE_VALUE, &secattr,
				    dwAccess, 0, ulSize, pszName);

#if DBG==1
    if (hMem == NULL)
    {
        CairoleDebugOut((DEB_ERROR,
            "CreateSharedFileMapping create of memory failed %d\n",
                GetLastError()));
    }

#endif

    void *pvAddr = NULL;

    if (hMem != NULL)
    {
	if (GetLastError() != ERROR_SUCCESS)
        {
            // If memory existed before our call then GetLastError returns
	    // ERROR_ALREADY_EXISTS, so we can tell whether we were the first
	    // one in or not.

#if DBG==1
            if (GetLastError() != ERROR_ALREADY_EXISTS)
            {
                CairoleDebugOut((DEB_WARN,
               "CreateFileMapping - expected ERROR_ALREADY_EXISTS, got %lx\n",
                                GetLastError()));
            }
#endif  //  DBG==1

	    CairoleDebugOut((DEB_MEMORY ,"SharedMem File Existed\n"));
	    fCreated = FALSE;
        }

	// Map the shared memory we have created into our process space
	pvAddr = MapViewOfFileEx(hMem, FILE_MAP_WRITE,
				 0, 0, ulMapSize, pvBase);

#if DBG==1
        if (pvAddr == NULL)
        {
            CairoleDebugOut((DEB_ERROR, "MapViewOfFile failed!! with %d\n",
                             GetLastError()));
        }
#endif // DBG==1

	if (pvAddr == NULL)
	{
	    DWORD err = GetLastError(); // successful CloseHandle sets last err to 0
	    CloseHandle(hMem); //ignore error
	    SetLastError(err);
	    hMem = NULL;
	}
    }

    if (pfCreated)
    {
	*pfCreated = fCreated;
    }

    *ppv = pvAddr;
    return hMem;
}



//+-------------------------------------------------------------------------
//
//  Function:	OpenSharedFileMapping
//
//  Synopsis:	opens a memory mapped file.
//
//  Arguments:	[pszName]   - name of file
//		[ulMapSize] - size of shared memory to map right now
//		[ppv]	    - return address for memory ptr
//
//  Algorithm:	Does an OpenFileMapping on the requested filename,
//		then a MapViewOfFile.  ReadOnly access is granted.
//
//  Returns:	HANDLE of the file or NULL if failed.
//		[ppv]	    - base address of the shared memory.
//
//  Notes:
//
//--------------------------------------------------------------------------

HANDLE OpenSharedFileMapping(WCHAR *pszName,
			     ULONG ulMapSize,
			     void **ppv)
{
    CairoleDebugOut((DEB_MEMORY, "OpenSharedFileMapping name:%ws size:%x\n",
		    pszName, ulMapSize));

    // Create the shared memory object
    HANDLE hMem = OpenFileMappingW(FILE_MAP_READ, FALSE, pszName);

    void *pvAddr = NULL;

    if (hMem != NULL)
    {
	// Map the shared memory we have created into our process space
	pvAddr = MapViewOfFile(hMem, FILE_MAP_READ, 0, 0, ulMapSize);

	Win4Assert(pvAddr && "MapViewOfFile failed!!");

	if (pvAddr == NULL)
	{
	    DWORD err = GetLastError(); // successful CloseHandle sets last err to 0
	    CloseHandle(hMem); //ignore error
	    SetLastError(err);
	    hMem = NULL;
	}
    }
    else
    {
	CairoleDebugOut((DEB_MEMORY, "OpenFileMapping failed.\n"));
    }

    *ppv = pvAddr;
    return hMem;
}



//+-------------------------------------------------------------------------
//
//  Function:	CloseSharedFileMapping
//
//  Synopsis:	closes a memory mapped file.
//
//  Arguments:	[hMem]	- shared memory handle
//		[pv]	- base address of shared memory pointer
//
//  Algorithm:	Unmaps the view of the file and closes the file handle.
//
//  Notes:
//
//--------------------------------------------------------------------------

void CloseSharedFileMapping(HANDLE hMem, void *pv)
{
    if (pv != NULL)
    {
	// release the shared memory. carefull not to release NULL.
	UnmapViewOfFile(pv);
    }
    if (hMem != NULL)
    {
	CloseHandle(hMem);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\smstack.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       smstack.cxx
//
//  Contents:   Shared mem stack-based allocator implementation
//
//  Classes:    CSmStackAllocator
//
//  History:    19-Jun-95    t-stevan    Created
//
//----------------------------------------------------------------------------
#include <ole2int.h>
#include <secdes.hxx>
#pragma hdrstop
#include <smstack.hxx>

// *** Macros ***
// quick macro to set up a pointer to base off of
#define SETUP_BASE_POINTER()  void *pbBase = m_pbBase

// quick macro to make sure our base pointer is in sync
#define SYNC_BASE_POINTER() pbBase = m_pbBase

// quick macro to tell that a pointer is based off of the shared stack
#define STACKBASED __based(pbBase)

#define SHAREDMEMBASE NULL

//+---------------------------------------------------------------------------
//
//  Member:     CSmStackAllocator::Init, public
//
//  Synopsis:   Initialize stack for use
//
//  Arguments:  [pszName] -- Name of shared memory block to use
//
//  Returns:    Appropriate hresult
//
//  History:    19-Jun-95    t-stevan    Created
//
//  Remarks:    Review the class destructor if you change this code.
//
//----------------------------------------------------------------------------
HRESULT CSmStackAllocator::Init(LPWSTR pszName, ULONG cbMaxSize, ULONG cbInitSize)
{
    HRESULT hresult = S_OK;
    
    SETUP_BASE_POINTER();
    
    CairoleDebugOut((DEB_ITRACE, "CSmStackAllocator::Init(pszName = %ws,cbMaxSize = %d, cbInitSize = %d)\n",
                      pszName, cbMaxSize, cbInitSize));

    //    the SMB needs a few bytes for its own header. If we request
    //    a page sized allocation, those few header bytes will cause an
    //    extra page to be allocated, so to prevent that we subtract off
    //    the header space from our requests.
    hresult = m_smb.Init(pszName, cbMaxSize - m_smb.GetHdrSize(), // reserve size
                                  cbInitSize - m_smb.GetHdrSize(), // commit size
                                  SHAREDMEMBASE, // base address
                                  NULL, // security descriptor
                                  TRUE); // create if doesn't exist  

    if(SUCCEEDED(hresult))
    {
        m_cbSize = m_smb.GetSize();
        m_pbBase = (BYTE *) m_smb.GetBase();
        
        if(m_smb.Created())
        {
            // we're the first stack, initialize shared memory
            m_pHeader = (CSmStackHeader *) m_pbBase;
            m_pbBase += sizeof(CSmStackHeader);
    
            SYNC_BASE_POINTER();

            m_pHeader->m_ulStack = 4; // start at 4 so that we still can have NULL pointers
            
#if DBG == 1
            m_pHeader->m_cbLostBytes = 0; 
#endif
        }
        else
        {
            // just sync up with the global stack
            m_pHeader = (CSmStackHeader *) m_pbBase;
            m_pbBase += sizeof(CSmStackHeader);
            
            SYNC_BASE_POINTER();
        }

    }
    
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmStackAllocator::Alloc, public
//
//  Synopsis:   Allocate a block of memory from the stack
//
//  Arguments:  [cbSize] - the size of the block to allocate
//
//  Returns:    a pointer to the block allocated
//                NULL if failed to allocate
//
//  History:    19-Jun-95    t-stevan    Created
//
//  Remarks:    The pointer returned is not a based pointer, it is absolute.
//               Use the macro P_TO_BP() to convert if you want a based pointer
//
//----------------------------------------------------------------------------
void *CSmStackAllocator::Alloc(ULONG cbSize)
{
    void *pResult = NULL;

    SETUP_BASE_POINTER();
    
    Win4Assert((m_pHeader != NULL) && (m_pbBase != NULL)
                  && "Stack memory block not initialized.");

    if(cbSize > 0)                     // cbSize <= 0 means noop
    {
        if(!m_smb.IsSynced())        // First make sure we are synced up
        {
            m_smb.Sync();
        }

#if !defined(_M_IX86)
        // we worry about alignment on non-x86 machines
        // we align allocations on DWORD boundaries
        // round to nearest multiple of 4
        cbSize += 3;
        cbSize &= 0xfffffffc;
#endif

        if(m_cbSize <= (m_pHeader->m_ulStack+sizeof(CSmStackHeader)+cbSize))
        {
            ULONG ulCommit;            // We need to commit more memory
            SYSTEM_INFO sysInfo;

            GetSystemInfo(&sysInfo);

            // Compute the total committed amount
            ulCommit = m_cbSize+m_smb.GetHdrSize()+cbSize+sysInfo.dwPageSize-1;

            // Round to the page size
            ulCommit -= ulCommit%sysInfo.dwPageSize;

            // account for smb header
            ulCommit -= m_smb.GetHdrSize();

            if(FAILED(m_smb.Commit(ulCommit))) // commit memory
            {
                return NULL;
            }

            if(FAILED(Sync()))                 // sync up again
            {
                return NULL;
            }
        }

        // Get return address
        pResult = BP_TO_P(BYTE *, (BYTE STACKBASED *)(m_pHeader->m_ulStack));

        m_pHeader->m_ulStack += cbSize;    // increment stack pointer
    }

    return pResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\smmutex.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	smmutex.cxx
//
//  Contents:	Cleanup routine for exception handler
//
//  Functions:	CSmMutex::CSmMutex
//
//  History:	03-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    "secdes.hxx"
#include    "smmutex.hxx"





//+-------------------------------------------------------------------------
//
//  Member:	CSmMutex::Init
//
//  Synopsis:	Creates/or gets access to inter-process mutex
//
//  Arguments:	[pszName] - name of mutex
//		[fGet] - whether to return with mutex owned.
//
//  Algorithm:
//
//  History:	03-Nov-93 Author    Comment
//              07-Jan-94 AlexT     No security for Chicago
//
//  Notes:
//
//--------------------------------------------------------------------------
SCODE CSmMutex::Init(LPTSTR pszName, BOOL fGet)
{
    SCODE sc = S_OK;
    
    //If _hMutex is not NULL, we've already been initalized - make
    //   this a no-op.
    if (_hMutex == NULL)
    {
#ifndef _CHICAGO_
        // build all allowed security descriptor
        CWorldSecurityDescriptor wsd;
#endif
        
        // Holder for attributes to pass in on create.
        SECURITY_ATTRIBUTES secattr;
        
        secattr.nLength = sizeof(SECURITY_ATTRIBUTES);
#ifdef _CHICAGO_
        secattr.lpSecurityDescriptor = NULL;
#else
        secattr.lpSecurityDescriptor = &wsd;
#endif
        secattr.bInheritHandle = FALSE;
        
        // This class is designed based on the idea that any process
        // can be the creator of the mutex and therefore when
        // no processes are using the mutex it disappears.

    //  The Win32 SDK Help recommends passing FALSE in fInitialOwner
    //  when creating a named mutex.  This eliminates the ambiguity
    //  when this thread does not create, but rather opens the mutex.

        _hMutex = CreateMutex(&secattr, FALSE, pszName);

        if (_hMutex == NULL && GetLastError() == ERROR_ACCESS_DENIED)
            _hMutex = OpenMutex(SYNCHRONIZE, FALSE, pszName);
        
        if (_hMutex != NULL)
        {
            if (GetLastError() == ERROR_ALREADY_EXISTS)
            {
                // We know that after a handle is returned that if GetLastError
                // returns non-zero (actually ERROR_ALREADY_EXISTS), the current
                // process is not the one to create this object. So we set our
                // creation flag accordingly. The owner parameter is ignored by
                // CreateMutex if this isn't the first creator, so we want to
                // get the mutex as well so we can be sure that whoever created
                // it is done with it for the moment.
                    
                _fCreated = FALSE;
            }
        }
        else
        {
            sc = HRESULT_FROM_WIN32(GetLastError());
        }
    }
                
    if (SUCCEEDED(sc) && (fGet))
    {
        Get();
    }

    // Note: we leave here with the mutex owned by this process iff the
    //	     caller specified TRUE on the fGet parameter.
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker\cmonimp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       cmonimp.h
//
//  Contents:   Defines of classes used in the implementation of monikers.
//
//  Classes:
//      CBaseMoniker    base moniker implementation. Other derive from base.
//      CFileMoniker    file moniker implementation.
//      CItemMoniker    item moniker
//      CCompositeMoniker generic composite moniker
//      CAntiMoniker
//
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              22-Mar-93 Randyd    Modified for Cairole
//
//--------------------------------------------------------------------------


#if !defined( _CMONIMP_H_ )
#define _CMONIMP_H_

// Define NEW_ENUMERATOR to get enumerations that don't include delimiters.
// (e.g. c:\d1\d2\f1.ext => c: \ d1 d2 f1.ext)
// Old enumerations include delimiters.
// (e.g. c:\d1\d2\f1.ext => c: \ d1\ d2\ f1.ext)
#define NEW_ENUMERATOR


#include "map_sp.h"
#include <filemon.hxx>
#include <dfspath.hxx>


#ifdef _DEBUG
#define CONSTR_DEBUG : m_Debug(this)
#else
#define CONSTR_DEBUG
#endif


#define PATH_DELIMITER L"\\"
#define WCHAR_BACKSLASH L'\\'
#define WCHAR_FWDSLASH  L'/'
#define IS_PATH_SEPARATOR_OLE(ch) ((ch == WCHAR_BACKSLASH) || (ch == WCHAR_FWDSLASH) || (ch == UNICODE_NULL))
#define IS_PATH_SEPARATOR_STRICT(ch) ((ch == WCHAR_BACKSLASH) || (ch == WCHAR_FWDSLASH))




STDAPI CreateOle1FileMoniker( LPTSTR, REFCLSID, LPMONIKER FAR*);


/*
 *	An implementation of the IMarshal interface that uses the
 *	IPersistStream interface to copy the object.  Any object that
 *	supports IPersistStream may use this to implement marshalling
 *	by copying, rather than by reference.
 */

class FAR CMarshalImplPStream :  public IMarshal
{
	LPPERSISTSTREAM m_pPS;
	SET_A5;
public:
	CMarshalImplPStream( LPPERSISTSTREAM pPS );

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IMarshal methods ***
    STDMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv,
						DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags, LPCLSID pCid);
    STDMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv,
						DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags, LPDWORD pSize);
    STDMETHOD(MarshalInterface)(THIS_ IStream FAR* pStm, REFIID riid,
						LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags);
    STDMETHOD(UnmarshalInterface)(THIS_ IStream FAR* pStm, REFIID riid,
                        LPVOID FAR* ppv);
    STDMETHOD(ReleaseMarshalData)(THIS_ IStream FAR* pStm);
    STDMETHOD(DisconnectObject)(THIS_ DWORD dwReserved);
};



class FAR CBaseMoniker :  public IMoniker
/*
 *	CBaseMoniker is a base implementation class that does the
 *	following:
 *	
 *	1.	It implements QueryInterface, AddRef, and Release, and IsDirty,
 *		since these all have the same implementation for all the moniker
 *		classes defined here.
 *	
 *	2.	It returns error messages for other methods.  Normally
 *		these will be replaced by real implementations in the
 *		derived classes, but in some cases, AntiMonikers, for
 *		instance, it allows us to declare and write only those
 *		methods with meaningful implementations.  Methods such as
 *		BindToObject for antimonikers will inherit the error code
 *		form the base implementation.
 */

{
protected:
	CBaseMoniker(void) : m_marshal(this)
	{ //SETPVTBL(CBaseMoniker);
	  GET_A5();
	  m_refs = 0;
	}

public:

		// *** IUnknown methods ***
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
	STDMETHOD_(ULONG,AddRef) (THIS);
	STDMETHOD_(ULONG,Release) (THIS);

	// *** IPersist methods ***
	STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID);

	// *** IPersistStream methods ***
	STDMETHOD(IsDirty) (THIS);
	STDMETHOD(Load) (THIS_ LPSTREAM pStm);
	STDMETHOD(Save) (THIS_ LPSTREAM pStm,
					BOOL fClearDirty);
	STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize);

	// *** IMoniker methods ***
	STDMETHOD(BindToObject) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		REFIID riidResult, LPVOID FAR* ppvResult);
	STDMETHOD(BindToStorage) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		REFIID riid, LPVOID FAR* ppvObj);
	STDMETHOD(Reduce) (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER FAR*
		ppmkToLeft, LPMONIKER FAR * ppmkReduced);
	STDMETHOD(ComposeWith) (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
		LPMONIKER FAR* ppmkComposite);
	STDMETHOD(Enum) (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker);
	STDMETHOD(IsEqual) (THIS_ LPMONIKER pmkOtherMoniker);
	STDMETHOD(Hash) (THIS_ LPDWORD pdwHash);
	STDMETHOD(IsRunning) (THIS_ LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER
		pmkNewlyRunning);
	STDMETHOD(GetTimeOfLastChange) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		FILETIME FAR* pfiletime);
	STDMETHOD(Inverse) (THIS_ LPMONIKER FAR* ppmk);
	STDMETHOD(CommonPrefixWith) (LPMONIKER pmkOther, LPMONIKER FAR*
		ppmkPrefix);
	STDMETHOD(RelativePathTo) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
		ppmkRelPath);
	STDMETHOD(GetDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		LPTSTR FAR* lplpszDisplayName);
	STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		LPTSTR lpszDisplayName, ULONG FAR* pchEaten,
		LPMONIKER FAR* ppmkOut);
	STDMETHOD(IsSystemMoniker) (THIS_ LPDWORD pdwMksys);
	//	REVIEW:  we need the following method on monikers but it is not in
	//	the spec.
	STDMETHOD(Clone) (THIS_ LPMONIKER FAR* ppmkDest, MemoryPlacement memPlace);
	//	"IInternalMoniker method"

#if DBG == 1
    // Debugging methods.
    // Dump dumps the state of the moniker.
    STDMETHOD_(void, Dump) (THIS_);
#endif  // DBG == 1

	ULONG	m_refs;

	CMarshalImplPStream m_marshal;
};




//+-------------------------------------------------------------------------
//
//  Class:      CFileMoniker
//
//  Purpose:    The standard Cairole implementation of a file moniker.
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
//              26-Mar-93 randyd    Converted to use DFS normalized paths
//
//  Notes:
//
//--------------------------------------------------------------------------

class FAR CFileMoniker : public CBaseMoniker
{
public:
      static CFileMoniker FAR* Create(
         LPTSTR szPathName,
         MemoryPlacement memLoc = TASK,
         FILEMONIKERTYPE fmtType = defaultType,
         DFS_ROOT dfsRoot = DFS_ROOT_ORG,
         UINT cAnti = 0 );

   private:

      CFileMoniker( void );
      ~CFileMoniker( void );
      INTERNAL_(BOOL) Initialize(
         UINT cAnti,
         LPTSTR szPathName,
         FILEMONIKERTYPE fmtType = defaultType,
         DFS_ROOT dfsRoot = DFS_ROOT_ORG);

      INTERNAL_(BOOL) IsOle1Class( LPCLSID pclsid );

      STDDEBDECL(CFileMoniker, FileMoniker)
   implementations:

      // *** IUnknown methods inherited from CBaseMoniker***
      STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
      STDMETHOD_(ULONG,Release) (THIS);
      // *** IPersist methods ***
      STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID);
      // *** IPersistStream methods ***
      STDMETHOD(Load) (THIS_ LPSTREAM pStm);
      STDMETHOD(Save) (THIS_ LPSTREAM pStm,
         BOOL fClearDirty);
      STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize);

      // *** IMoniker methods ***
      STDMETHOD(BindToObject) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
         REFIID riidResult, LPVOID FAR* ppvResult);
      STDMETHOD(BindToStorage) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
         REFIID riid, LPVOID FAR* ppvObj);
      STDMETHOD(ComposeWith) (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
         LPMONIKER FAR* ppmkComposite);
      STDMETHOD(Enum) (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker);
      STDMETHOD(IsEqual) (THIS_ LPMONIKER pmkOtherMoniker);
      STDMETHOD(Hash) (THIS_ LPDWORD pdwHash);
      STDMETHOD(IsRunning) (THIS_ LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER
         pmkNewlyRunning);
      STDMETHOD(GetTimeOfLastChange) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
         FILETIME FAR* pfiletime);
      STDMETHOD(Inverse) (THIS_ LPMONIKER FAR* ppmk);
      STDMETHOD(CommonPrefixWith) (LPMONIKER pmkOther, LPMONIKER FAR*
         ppmkPrefix);
      STDMETHOD(RelativePathTo) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
         ppmkRelPath);
      STDMETHOD(GetDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
         LPTSTR FAR* lplpszDisplayName);
      STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
         LPTSTR lpszDisplayName, ULONG FAR* pchEaten,
         LPMONIKER FAR* ppmkOut);
      STDMETHOD(IsSystemMoniker) (THIS_ LPDWORD pdwMksys);
      // REVIEW:  we need the following method on monikers but it is not in
      // the spec.
    /*
     *	Since IMoniker::Clone is not in the spec, this is the
     *	documentation for it.  It clones a moniker; it is needed since
     *	the tables (RunningObjectTable, e.g.) need a pointer to moniker
     *	that is valid in shared memory, which means monikers must be
     *	copied to shared memory.
     *	
     *	If *ppmkDest == NULL, an allocation is made using memLoc = TASK to
     *	decide whether it is allocated in shared memory or task memory.
     *	If *ppmkDest is not NULL, the moniker is copied into the same
     *	type of space as *ppmkDest.  The pointer to the moniker is
     *	returned in *ppmkDest, and we guarantee that *ppmkDest does not
     *	change unless it started out as NULL.
     */
      STDMETHOD(Clone) (THIS_ LPMONIKER FAR* ppmkDest, MemoryPlacement memPlace);
      // "IInternalMoniker method"

#if DBG == 1
      // Debugging methods.
      STDMETHOD_(void, Dump) ();
#endif  // DBG == 1


private:

    // Comare m_cAnti counts of two monikers: return prefix.
    HRESULT CompareAntiCount(CFileMoniker* pcfmOther,
        IMoniker** ppmkPrefix);


    shared_state:
    // From cfilemon.cxx:
    /*
     *	Storage of paths in file monikers:
     *	
     *	A separate unsigned integer holds the count of .. at the
     *	beginning of the path, so the canononical form of a file
     *	moniker contains this count and the "path" described above,
     *	which will not contain "..\" or ".\".
     *	
     *	It is considered an error for a path to contain ..\ anywhere
     *	but at the beginning.  I assume that these will be taken out by
     *	ParseUserName.
     */

        // m_dfsPath is a DFS normalized path. It is the core of the
        // activated state of a file moniker.
        CDfsPath*       m_CDfsPath;

        // m_cAnti is a count: the number of leading ".."'s at the beginning
        // of supplied path.
        UINT	m_cAnti;
        CLSID       m_clsid;        // used only if OLE 1.0
        enum        olever { undetermined, ole1, ole2 };
        olever      m_ole1;
        DWORD       m_cbMacAlias;
        TCHAR FAR *	m_pchMacAlias;
        BOOL        m_fClassVerified;

        friend class CFileMonikerEnum;
        friend class CDfsMoniker;
        friend class CDfsMonikerEnum;
        friend class CCompositeMoniker;
        friend BOOL RunningMoniker(LPBINDCTX,LPTSTR,ULONG FAR&,LPMONIKER FAR*);
    	friend
    		HRESULT STDAPICALLTYPE	CreateOle1FileMoniker(LPTSTR, REFCLSID, LPMONIKER FAR*);
};



class FAR CItemMoniker :  public CBaseMoniker
{

public:
	static CItemMoniker FAR* Create( LPTSTR szDelim, LPTSTR szItemName,
		MemoryPlacement memLoc = TASK );

private:

	CItemMoniker( void ) CONSTR_DEBUG
	{ //SETPVTBL(CItemMoniker); GET_A5();
         m_lpszItem = NULL; m_lpszDelimiter = NULL; };
	~CItemMoniker( void );
	INTERNAL_(BOOL) Initialize( LPTSTR szDelim, LPTSTR szItemName );
	STDDEBDECL(CItemMoniker, ItemMoniker)

public:
	// *** IUnknown methods inherited from CBaseMoniker ***

	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
	STDMETHOD_(ULONG,Release) (THIS);
	// *** IPersist methods ***
	STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID);

	// *** IPersistStream methods ***
	STDMETHOD(Load) (THIS_ LPSTREAM pStm);
	STDMETHOD(Save) (THIS_ LPSTREAM pStm,
					BOOL fClearDirty);
	STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize);

	// *** IMoniker methods ***
	STDMETHOD(BindToObject) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		REFIID riidResult, LPVOID FAR* ppvResult);
	STDMETHOD(BindToStorage) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		REFIID riid, LPVOID FAR* ppvObj);
	STDMETHOD(ComposeWith) (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNOtGeneric,
		LPMONIKER FAR* ppmkComposite);
	STDMETHOD(Enum) (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker);
	STDMETHOD(IsEqual) (THIS_ LPMONIKER pmkOtherMoniker);
	STDMETHOD(Hash) (THIS_ LPDWORD pdwHash);
	STDMETHOD(IsRunning) (THIS_ LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER
		pmkNewlyRunning);
	STDMETHOD(GetTimeOfLastChange) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		FILETIME FAR* pfiletime);
	STDMETHOD(Inverse) (THIS_ LPMONIKER FAR* ppmk);
	STDMETHOD(CommonPrefixWith) (LPMONIKER pmkOther, LPMONIKER FAR*
		ppmkPrefix);
	STDMETHOD(RelativePathTo) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
		ppmkRelPath);
	STDMETHOD(GetDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		LPTSTR FAR* lplpszDisplayName);
	STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		LPTSTR lpszDisplayName, ULONG FAR* pchEaten,
		LPMONIKER FAR* ppmkOut);
	STDMETHOD(IsSystemMoniker) (THIS_ LPDWORD pdwMksys);
	//	REVIEW:  we need the following method on monikers but it is not in
	//	the spec.
	STDMETHOD(Clone) (THIS_ LPMONIKER FAR* ppmkDest, MemoryPlacement memPlace);
	//	"IInternalMoniker method"

	TCHAR FAR* m_lpszItem;
shared_state:
	TCHAR FAR* m_lpszDelimiter;
	SET_A5;
};



class FAR CCompositeMoniker : public CBaseMoniker
{

public:
	static CCompositeMoniker FAR* Create( LPMONIKER pmkFirst, LPMONIKER pmkRest,
		MemoryPlacement memLoc = TASK );


	CCompositeMoniker( void )  CONSTR_DEBUG
	{ // SETPVTBL(CCompositeMoniker); GET_A5();
          m_pmkLeft = NULL; m_pmkRight = NULL; m_fReduced = FALSE;}
	~CCompositeMoniker( void );
	INTERNAL_(BOOL) Initialize( LPMONIKER pmkFirst, LPMONIKER pmkRest );
	INTERNAL_(LPMONIKER) AllButLast( void );
	INTERNAL_(LPMONIKER) AllButFirst( void );
	INTERNAL_(LPMONIKER) Last( void );
	INTERNAL_(LPMONIKER) First( void );
	INTERNAL_(ULONG) Count( void );
	HRESULT CloneHelper(
	    IMoniker *pmk,
	    IMoniker **pmkCloned,
	    MemoryPlacement memPlace);

	STDDEBDECL(CCompositeMoniker, CompositeMoniker)

implementations:

	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
	STDMETHOD_(ULONG,Release) (THIS);
	// *** IPersist methods ***
	STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID);

	// *** IPersistStream methods ***
	STDMETHOD(Load) (THIS_ LPSTREAM pStm);
	STDMETHOD(Save) (THIS_ LPSTREAM pStm,
					BOOL fClearDirty);
	STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize);

	// *** IMoniker methods ***
	STDMETHOD(BindToObject) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		REFIID riidResult, LPVOID FAR* ppvResult);
	STDMETHOD(BindToStorage) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		REFIID riid, LPVOID FAR* ppvObj);
	STDMETHOD(Reduce) (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER FAR*
		ppmkToLeft, LPMONIKER FAR * ppmkReduced);
	STDMETHOD(ComposeWith) (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNOtGeneric,
		LPMONIKER FAR* ppmkComposite);
	STDMETHOD(Enum) (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker);
	STDMETHOD(IsEqual) (THIS_ LPMONIKER pmkOtherMoniker);
	STDMETHOD(Hash) (THIS_ LPDWORD pdwHash);
	STDMETHOD(IsRunning) (THIS_ LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER
		pmkNewlyRunning);
	STDMETHOD(GetTimeOfLastChange) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		FILETIME FAR* pfiletime);
	STDMETHOD(Inverse) (THIS_ LPMONIKER FAR* ppmk);
	STDMETHOD(CommonPrefixWith) (LPMONIKER pmkOther, LPMONIKER FAR*
		ppmkPrefix);
	STDMETHOD(RelativePathTo) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
		ppmkRelPath);
	STDMETHOD(GetDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		LPTSTR FAR* lplpszDisplayName);
	STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		LPTSTR lpszDisplayName, ULONG FAR* pchEaten,
		LPMONIKER FAR* ppmkOut);
	STDMETHOD(IsSystemMoniker) (THIS_ LPDWORD pdwMksys);
	//	REVIEW:  we need the following method on monikers but it is not in
	//	the spec.
	STDMETHOD(Clone) (THIS_ LPMONIKER FAR* ppmkDest, MemoryPlacement memPlace);
	//	"IInternalMoniker method"

	friend
		HRESULT STDAPICALLTYPE	CreateGenericComposite( LPMONIKER, LPMONIKER,
			LPMONIKER FAR*);

		friend class CCompositeMonikerEnum;
		friend BOOL IsReduced( LPMONIKER pmk );
shared_state:

	LPMONIKER	m_pmkLeft;
	LPMONIKER	m_pmkRight;
	BOOL		m_fReduced;
	SET_A5;
};


class FAR CCompositeMonikerEnum :  IEnumMoniker
{
	CCompositeMonikerEnum( BOOL fForward, CCompositeMoniker FAR*);
	~CCompositeMonikerEnum( void );

public:
	static LPENUMMONIKER Create( BOOL fForward, CCompositeMoniker FAR*);
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IEnumMoniker methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPMONIKER FAR* reelt, ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (THIS_ ULONG celt);
    STDMETHOD(Reset) (THIS);
    STDMETHOD(Clone) (THIS_ LPENUMMONIKER FAR* ppenm);
private:
	struct FAR se		//	stackelement
	{
		CCompositeMoniker FAR* m_pCM;
		se FAR* m_pseNext;
		se FAR* m_psePrev;

		se( CCompositeMoniker FAR* pCM ) { m_pCM = pCM; m_pseNext = NULL;
				m_psePrev = NULL; }
	};

	void Push( CCompositeMoniker FAR* pCM );
	LPMONIKER GetNext( LPMONIKER pmk );
	LPMONIKER Pop( void );


	ULONG m_refs;
	CCompositeMoniker FAR* m_pCM;		//	the moniker being enumerated
	BOOL	m_fForward;
	se FAR* m_pBase;
	se FAR* m_pTop;
	LPMONIKER m_pNext;
	SET_A5;
};


class FAR CBindCtx
{

public:
	static IUnknown FAR* Create( IUnknown FAR * pUnkOuter, DWORD reserved, MemoryPlacement memLoc = TASK );

private:

	CBindCtx( IUnknown FAR * pUnkOuter );
	~CBindCtx( void );
						
	class FAR CObjList
	{
	public:

		LPUNKNOWN 		m_punk;
		CObjList FAR*	m_pNext;

		CObjList( IUnknown FAR * punk )
		{	m_punk = punk; m_pNext = NULL; }

		~CObjList( void );
	};
	DECLARE_NC(CBindCtx, CObjList)

	INTERNAL_(void)	AddToList( CObjList FAR* pCObjList )
	{ M_PROLOG(this); pCObjList->m_pNext = m_pFirstObj;  m_pFirstObj = pCObjList; }
	


implementations:

	STDUNKDECL(CBindCtx,BindCtx)
	STDDEBDECL(CBindCtx,BindCtx)

	implement CBindCtxImpl : IBindCtx
	{
	public:
		CBindCtxImpl( CBindCtx FAR * pBindCtx )
			{ m_pBindCtx = pBindCtx; }
		STDMETHOD(QueryInterface) (THIS_ REFIID iid, LPVOID FAR* ppvObj);
		STDMETHOD_(ULONG,AddRef) (THIS);
		STDMETHOD_(ULONG,Release) (THIS);

		STDMETHOD(RegisterObjectBound) (THIS_ LPUNKNOWN punk);
		STDMETHOD(RevokeObjectBound) (THIS_ LPUNKNOWN punk);
		STDMETHOD(ReleaseBoundObjects) (THIS);
		
		STDMETHOD(SetBindOptions) (THIS_ LPBIND_OPTS pbindopts);
		STDMETHOD(GetBindOptions) (THIS_ LPBIND_OPTS pbindopts);
		STDMETHOD(GetRunningObjectTable) (THIS_ LPRUNNINGOBJECTTABLE  FAR*
			pprot);
		STDMETHOD(RegisterObjectParam) (THIS_ LPTSTR lpszKey, LPUNKNOWN punk);
		STDMETHOD(GetObjectParam) (THIS_ LPTSTR lpszKey, LPUNKNOWN FAR* ppunk);
		STDMETHOD(EnumObjectParam) (THIS_ LPENUMSTRING FAR* ppenum);
		STDMETHOD(RevokeObjectParam) (THIS_ LPTSTR lpszKey);

		CBindCtx FAR * m_pBindCtx;
	};
	DECLARE_NC(CBindCtx, CBindCtxImpl)
	
	CBindCtxImpl m_BindCtx;


shared_state:
	SET_A5;
	IUnknown FAR*	m_pUnkOuter;
	ULONG			m_refs;

	LPBIND_OPTS		m_pBindOpts;
	CObjList FAR*	m_pFirstObj;
	CMapStringToPtr FAR* m_pMap;
	DWORD			m_reserved;
};




class FAR CAntiMoniker	:	public CBaseMoniker
{

public:
	static CAntiMoniker FAR* Create( ULONG count,
		MemoryPlacement memLoc = TASK );

private:

	CAntiMoniker( ULONG count ) CONSTR_DEBUG
	{ //SETPVTBL(CAntiMoniker); GET_A5();
	m_count = count; }

implementations:

	STDDEBDECL(CAntiMoniker, AntiMoniker)

		// *** IUnknown methods inherited from CBaseMoniker***
	STDMETHOD(QueryInterface) (THIS_ REFIID iid, LPVOID FAR* ppvObj);
	STDMETHOD_(ULONG,Release) (THIS);
	// *** IPersist methods ***
	STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID);
	// *** IPersistStream methods ***
	STDMETHOD(Load) (THIS_ LPSTREAM pStm);
	STDMETHOD(Save) (THIS_ LPSTREAM pStm,
					BOOL fClearDirty);
	STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize);

	// *** IMoniker methods which get reimplemented ***

	STDMETHOD(ComposeWith) (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
		LPMONIKER FAR* ppmkComposite);
	STDMETHOD(Enum) (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker);
	STDMETHOD(IsEqual) (THIS_ LPMONIKER pmkOtherMoniker);
	STDMETHOD(Hash) (THIS_ LPDWORD pdwHash);
	STDMETHOD(CommonPrefixWith) (LPMONIKER pmkOther, LPMONIKER FAR*
		ppmkPrefix);
	STDMETHOD(RelativePathTo) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
		ppmkRelPath);
	STDMETHOD(GetDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		LPTSTR FAR* lplpszDisplayName);
	STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		LPTSTR lpszDisplayName, ULONG FAR* pchEaten,
		LPMONIKER FAR* ppmkOut);
	STDMETHOD(IsSystemMoniker) (THIS_ LPDWORD pdwMksys);
	//	REVIEW:  we need the following method on monikers but it is not in
	//	the spec.
	STDMETHOD(Clone) (THIS_ LPMONIKER FAR* ppmkDest, MemoryPlacement memPlace);
	//	"IInternalMoniker method"

public:
	void	EatOne( LPMONIKER FAR* ppmk );

shared_state:
	ULONG		m_count;
	SET_A5;
};



class FAR CPointerMoniker : public CBaseMoniker
{

public:
	static CPointerMoniker FAR* Create( LPUNKNOWN pUnk, MemoryPlacement memLoc );

private:

	CPointerMoniker( LPUNKNOWN pUnk );
	~CPointerMoniker( void );

	STDDEBDECL(CPointerMoniker, PointerMoniker)

	STDMETHOD(QueryInterface) (THIS_ REFIID iid, LPVOID FAR* ppvObj);
	STDMETHOD_(ULONG,Release) (THIS);
	STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassId);

	// *** IMoniker methods ***
	STDMETHOD(BindToObject) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		REFIID riidResult, LPVOID FAR* ppvResult);
	STDMETHOD(BindToStorage) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		REFIID riid, LPVOID FAR* ppvObj);
	STDMETHOD(ComposeWith) (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNOtGeneric,
		LPMONIKER FAR* ppmkPointer);
	STDMETHOD(IsEqual) (THIS_ LPMONIKER pmkOtherMoniker);
	STDMETHOD(Hash) (THIS_ LPDWORD pdwHash);
//	STDMETHOD(IsRunning) (THIS_ LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER
//		pmkNewlyRunning);
	STDMETHOD(GetTimeOfLastChange) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		FILETIME FAR* pfiletime);
	STDMETHOD(Inverse) (THIS_ LPMONIKER FAR* ppmk);
	STDMETHOD(CommonPrefixWith) (LPMONIKER pmkOther, LPMONIKER FAR*
		ppmkPrefix);
	STDMETHOD(RelativePathTo) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
		ppmkRelPath);
	STDMETHOD(GetDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		LPTSTR FAR* lplpszDisplayName);
	STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
		LPTSTR lpszDisplayName, ULONG FAR* pchEaten,
		LPMONIKER FAR* ppmkOut);
	STDMETHOD(IsSystemMoniker) (THIS_ LPDWORD pdwMksys);
	STDMETHOD(Clone) (THIS_ LPMONIKER FAR* ppmkDest, MemoryPlacement memPlace);
shared_state:

	LPUNKNOWN				m_pUnk;
	SET_A5;
};

INTERNAL_(DWORD) GetMonikerType( LPMONIKER pmk );
INTERNAL_(BOOL) IsCompositeMoniker( LPMONIKER pmk );
INTERNAL_(BOOL) IsAntiMoniker( LPMONIKER pmk );
INTERNAL_(BOOL) IsFileMoniker( LPMONIKER pmk );
INTERNAL_(BOOL) IsItemMoniker( LPMONIKER pmk );
STDAPI 	Concatenate( LPMONIKER pmkFirst, LPMONIKER pmkRest,
	LPMONIKER FAR* ppmkComposite );


BOOL FAR PASCAL FIsCDROMDrive(WORD wDrive);
INTERNAL SzFixNet( LPBINDCTX pbc, LPTSTR szUNCName, LPTSTR FAR * lplpszReturn );

#endif // _CMONIMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\xmit.cxx ===
//+-------------------------------------------------------------------
//
//  File:       xmit.cxx
//
//  Contents:   code for converting interfaces to Rpc'able constructs.
//
//  Classes:    CXmitRpcStream
//
//  Functions:  None.
//
//  Macros:     DEFINE_INTERFACE_XMIT_ROUTINES
//
//  History:    30-Jan-93   Ricksa      Created
//
//  Notes:      Since cairo interfaces cant be Rpc'd, they get converted
//              into an InterfaceReferenceData structure via the Rpc
//              [transmit_as] attribute.  The <IFace>_to_xmit function
//              and <IFace>_from_xmit function call CoMarshalInterface
//              and CoUnmarshalInterface respectively.  These APIs expect
//              a stream interface as input.  The CXmitRpcStream is a
//              stream wrapper for the InterfaceReferenceData structure.
//
//  CODEWORK:	since this is used only internally, we want it to be
//		screaming fast.  check parameters only in DBG builds.
//		and ignore thread safety on AddRef/Release.
//
//--------------------------------------------------------------------

#include    <ole2int.h>
#include    <xmit.hxx>




STDMETHODIMP CXmitRpcStream::QueryInterface(
    REFIID iidInterface,
    void FAR* FAR* ppvObj)
{
    HRESULT hresult = S_OK;

    // We only support IUnknown and IStream
    if (IsEqualIID(iidInterface, IID_IUnknown) ||
	IsEqualIID(iidInterface, IID_IStream))
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
	*ppvObj = NULL;
	hresult = E_NOINTERFACE;
    }

    return hresult;
}

STDMETHODIMP_(ULONG) CXmitRpcStream::AddRef(void)
{
    Win4Assert((_clRefs != 0) && "CXmitRpcStream::AddRef");
    InterlockedIncrement(&_clRefs);
    return _clRefs;
}

STDMETHODIMP_(ULONG) CXmitRpcStream::Release(void)
{
    Win4Assert((_clRefs != 0) && "CXmitRpcStream::Release");

    if (InterlockedDecrement(&_clRefs) == 0)
    {
	delete this;
	return 0;
    }

    return _clRefs;
}

STDMETHODIMP CXmitRpcStream::Read(
    VOID HUGEP* pv,
    ULONG cb,
    ULONG FAR* pcbRead)
{
    HRESULT hresult = S_OK;

    if (pcbRead)
    {
        *pcbRead = 0L;
    }

    if (cb + _lOffset > _cbData)
    {
	cb = _cbData - _lOffset;
	CairoleDebugOut((DEB_ERROR, "CXmitRpcStream read past end of stream %x\n", cb+_lOffset));
        hresult = STG_E_READFAULT;
    }

    memcpy(pv,_pifData->abData + _lOffset, (size_t) cb);
    _lOffset += cb;

    if (pcbRead != NULL)
    {
        *pcbRead = cb;
    }

    return hresult;
}

STDMETHODIMP CXmitRpcStream::Write(
    VOID  const HUGEP* pv,
    ULONG cbToWrite,
    ULONG FAR* pcbWritten)
{
    HRESULT hresult = S_OK;

    if (pcbWritten)
    {
        *pcbWritten = 0L;
    }

    if (cbToWrite + _lOffset > _cbData)
    {
	// the current stream is too small, try to grow it.

	if (!_fFree)
	{
	    // The stream doesn't own the buffer so it can't reallocate it
	    CairoleDebugOut((DEB_ERROR, "CXmitRpcStream write past end of stream %x\n",
		cbToWrite + _lOffset));
	    return STG_E_WRITEFAULT;
	}

	// Reallocate the size of the buffer
	// Review: The constant added to the size allocated is a number
	// designed simply to try and decrease the number of follow on
	// allocations. In other words it needs to be tuned (or dropped!).

	BYTE *pbNewBuf = (BYTE *) MIDL_user_allocate(sizeof(DWORD) +
						     cbToWrite +
                                                     _lOffset + 64);

	if (pbNewBuf == NULL)
	{
	    CairoleDebugOut((DEB_ERROR, "CXmitRpcStream cant grow stream\n"));
	    return E_OUTOFMEMORY;
	}

	if (_pifData)
	{
	    // we had a buffer from before, copy that in, and free the old one.
	    memcpy(pbNewBuf, _pifData, sizeof(DWORD) + _cbData);
	    MIDL_user_free(_pifData);
	}

	_cbData = cbToWrite + _lOffset + 64;
	_pifData = (InterfaceData *)pbNewBuf;
    }


    // copy in the new data
    memcpy(_pifData->abData + _lOffset, pv, (size_t) cbToWrite);
    _lOffset += cbToWrite;

    if (pcbWritten != NULL)
    {
	*pcbWritten = cbToWrite;
    }

    // We assume maxium size of buffer is the size to send on the network.
    if (_cSize < _lOffset)
    {
	_cSize = _lOffset;
    }

    return hresult;
}

STDMETHODIMP CXmitRpcStream::Seek(
    LARGE_INTEGER dlibMoveIN,
    DWORD dwOrigin,
    ULARGE_INTEGER FAR* plibNewPosition)
{
    HRESULT hresult = S_OK;

    LONG dlibMove = dlibMoveIN.LowPart;
    ULONG cbNewPos = dlibMove;

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:

        if (dlibMove >= 0)
        {
            _lOffset = dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:

        if (!(dlibMove < 0 && (-dlibMove > _lOffset)))
        {
            _lOffset += (ULONG) dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_END:

	if (!(dlibMove < 0 && ((ULONG) -dlibMove) > _cbData))
        {
	    _lOffset = _cbData + dlibMove;
        }
	else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    default:

        hresult = STG_E_SEEKERROR;
    }

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, _lOffset);
    }

    return hresult;
}

STDMETHODIMP CXmitRpcStream::SetSize(ULARGE_INTEGER cb)
{
    return E_NOTIMPL;
}

STDMETHODIMP CXmitRpcStream::CopyTo(
    IStream FAR* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER FAR* pcbRead,
    ULARGE_INTEGER FAR* pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CXmitRpcStream::Commit(DWORD grfCommitFlags)
{
    return NOERROR;
}

STDMETHODIMP CXmitRpcStream::Revert(void)
{
    return NOERROR;
}

STDMETHODIMP CXmitRpcStream::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CXmitRpcStream::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CXmitRpcStream::Stat(
    STATSTG FAR* pstatstg,
    DWORD statflag)
{
    memset(pstatstg, 0, sizeof(STATSTG));
    return E_NOTIMPL;
}

STDMETHODIMP CXmitRpcStream::Clone(IStream FAR * FAR *ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   inc
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES =    ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc
INCLUDES =    $(INCLUDES);..\..\objact;..\..\dcomrem;..\..\..\dcomss\olescm
INCLUDES =    $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)

SOURCES=      \
              ..\cevent.cxx   \
              ..\clskey.cxx   \
              ..\dbgpopup.cxx \
              ..\pathkey.cxx  \
              ..\pattbl.cxx   \
              ..\refcnt.cxx   \
              ..\rotdata.cxx  \
              ..\rothelp.cxx  \
              ..\smblock.cxx  \
              ..\smcreate.cxx \
              ..\smmutex.cxx  \
              ..\xmit.cxx


UMTYPE=       windows

!include ..\..\precomp2.inc

SYNCHRONIZE_BLOCK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\cantimon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       cantimon.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-27-93   ErikGav   Did not write this code
//		02-04-94   KevinRo   Gag'd on it, then rewrote it
//		06-14-94   Rickhi    Fix type casting
//
//  An Anti moniker is intended to be the inverse of any moniker, such as
//  an Item Moniker. When another moniker composes itself with an Anti moniker
//  on the right, it is supposed to remove itself from the result.
//
//  The original implementation of Anti monikers attempted to be optimal by
//  collapsing itself when composed with another Anti moniker. This was an
//  unfortunate decision, since other monikers decide to eliminate themselves
//  (and the Anti moniker) based on whether the moniker type to the right is
//  an Anti moniker.
//
//  For example, File moniker (F) composed with an Anti moniker (A) should
//  result in nothing. F o A == (). The previous implementation was in error
//  because a composite of two anti-monikers was treated as a single anti
//  moniker with a count of two, denoted A(2).
//  Therefore, when the file moniker looked at the anti moniker using the
//  interface, it saw only one Anti moniker, instead of a composite.
//  ( F o A(2)) == (). It should have been ( F o (A o A) ) == ( A )
//
//  To fix this, when we compose Anti monikers, we will always use a
//  composite. We need to be careful when loading old serialized Anti
//  monikers, and convert them as we see them.
//
//  This actually makes this a problem, since old monikers have a
//  funny behaviour if loaded from stream. The way the Load() interface
//  works, the client has a pointer to the Anti moniker before it is loaded.
//  Therefore, we can't just magically make this work.
//
//  However, we can fix this up as soon as we can during the first Reduce or
//  Compose with that is called. You will find this code in the Compose
//  with methods, plus in the Create(count) methods.
//
//  Save() is also a problem, since the caller has already written out our
//  class ID. Therefore, we can't just sneak in a composite, since it will
//  break the old fellows.
//
//
//  History
//  ??/??/??    unknown     Created
//  03/21/97    ronans      Changed creation code to use initial ref count of 1
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "cantimon.hxx"
#include "mnk.h"



INTERNAL_(CAntiMoniker *) IsAntiMoniker( LPMONIKER pmk )
{
    CAntiMoniker *pCAM;

    if ((pmk->QueryInterface(CLSID_AntiMoniker, (void **)&pCAM)) == S_OK)
    {
	// we release the AddRef from QI but stll return the pointer.
	pCAM->Release();
	return pCAM;
    }

    // dont rely on user implementations to return NULL on failed QI
    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Method:     CAntiMoniker::Create
//
//  Synopsis:   Create a single AntiMoniker
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-04-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CAntiMoniker FAR *CAntiMoniker::Create()
{
    CAntiMoniker FAR * pCAM = new CAntiMoniker();
    return pCAM;
}


//+---------------------------------------------------------------------------
//
//  Method:     CAntiMoniker::Create
//
//  Synopsis:   Create a composite anti moniker.
//
//  Effects:    This function supports the 'old' way of creating Anti
//		monikers, by creating [count] Anti monikers, and composing
//		them together.
//
//  Arguments:  [count] -- Number of Anti monikers
//
//  Requires:
//
//  Returns:
//	if count == 1, this routine will return an CAntiMoniker.
// 	if count > 1, this routine will create a composite moniker made up
//	of Anti monikers.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-04-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

IMoniker * CAntiMoniker::Create(ULONG count)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::Create(0x%x))\n",
		 count));


    HRESULT hr;
    IMoniker *pmkComposite = NULL;

    while(count--)
    {
	IMoniker *pmkNew;

	CAntiMoniker FAR * pCAM = new CAntiMoniker();

	//
	// If there was failure, then releasing the old composite is
	// required.
	//

	if (pCAM == NULL)
	{
	    if (pmkComposite != NULL)
	    {
		pmkComposite->Release();
	    }
	    return(NULL);
	}

	//
	// Create a generic composite using the existing and new
	// monikers. If this succeededs, then pmkNew will increment
	// both reference counts.
	//
	//
	// If there was a failure, then calling Release() on the new and
	// old sections of the composite will cause both of them to be
	// released, thus releasing the entire tree of monikers.
	//
	// If it succeeds, pmkNew will hold references to both of the
	// old monikers, and life will be good.
	//
	// Note: First time around, pmkComposite == NULL, and
	// CreateGenericComposite() will just return pCAM. It works.
	//

	hr = CreateGenericComposite(pmkComposite,pCAM,&pmkNew);

	pCAM->Release();

	//
	// Watch out for the first time around the loop. This will
	// cause pmkComposite to be NULL
	//
	if (pmkComposite != NULL)
	{
	    pmkComposite->Release();
	}

	//
	// If failed, then the last two releases cleaned up for us.
	//
	if (FAILED(hr))
	{
	    return(NULL);
	}

	pmkComposite = pmkNew;
    }

    return pmkComposite;
}


STDMETHODIMP CAntiMoniker::QueryInterface(THIS_ REFIID riid,
	LPVOID FAR* ppvObj)
{
	M_PROLOG(this);
	VDATEIID (riid);
	VDATEPTROUT(ppvObj, LPVOID);

#ifdef _DEBUG
	if (riid == IID_IDebug)
	{
	    *ppvObj = &(m_Debug);
	    return NOERROR;
	}
#endif

	if (IsEqualIID(riid, CLSID_AntiMoniker))
	{
	    //	called by IsAntiMoniker.
	    AddRef();
	    *ppvObj = this;
	    return S_OK;
	}

	return CBaseMoniker::QueryInterface(riid, ppvObj);
}

STDMETHODIMP CAntiMoniker::GetClassID(LPCLSID lpClassId)
{
	M_PROLOG(this);
	VDATEPTROUT(lpClassId, CLSID);

	*lpClassId = CLSID_AntiMoniker;
	return NOERROR;
}


STDMETHODIMP CAntiMoniker::Load(LPSTREAM pStm)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::Load(%x)\n",
		 this));

    M_PROLOG(this);
    VDATEIFACE(pStm);

    HRESULT hresult;
    ULONG count;

    hresult = StRead(pStm, &count, sizeof(ULONG));

    if (SUCCEEDED(hresult))
    {
        m_count = count;
    }
    return hresult;
}


STDMETHODIMP CAntiMoniker::Save(LPSTREAM pStm, BOOL fClearDirty)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::Save(%x)\n",
		 this));

	M_PROLOG(this);
	VDATEIFACE(pStm);

	UNREFERENCED(fClearDirty);
	ULONG cbWritten;

	return pStm->Write(&m_count, sizeof(ULONG), &cbWritten);
	//	REVIEW:  what is proper error handling?  Should we restore the seek
	//	pointer?
}


STDMETHODIMP CAntiMoniker::GetSizeMax(ULARGE_INTEGER FAR* pcbSize)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::GetSizeMax(%x)\n",
		 this));

	M_PROLOG(this);
	VDATEPTROUT(pcbSize, ULONG);

 	ULISet32(*pcbSize, sizeof(CLSID) + sizeof(ULONG));
	noError;
}




//+---------------------------------------------------------------------------
//
//  Method:     CAntiMoniker::ComposeWith
//
//  Synopsis:   Compose this moniker with another moniker.
//
//  Effects:
//
//  Arguments:  [pmkRight] --
//		[fOnlyIfNotGeneric] --
//		[ppmkComposite] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-04-94   kevinro   Created
//
//  Notes:
//
//  In the event that m_count > 1, we can use this opportunity to fixup the
//  anti moniker into a composite of single anti monikers. This will help make
//  the monikers work correctly.
//
//----------------------------------------------------------------------------
STDMETHODIMP CAntiMoniker::ComposeWith( LPMONIKER pmkRight,
	BOOL fOnlyIfNotGeneric, LPMONIKER FAR* ppmkComposite)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::ComposeWith(%x,pmkRight(%x))\n",
		 this,
		 pmkRight));

	VDATEPTROUT(ppmkComposite,LPMONIKER);
	*ppmkComposite = NULL;
	VDATEIFACE(pmkRight);

	HRESULT hresult = NOERROR;
	IMoniker *pmkThis = NULL;
	IMoniker *pmkRightComposite = NULL;


	//
	// The only way CAntiMonikers can compose is generically
	//
	if (fOnlyIfNotGeneric)
	{
	    hresult = MK_E_NEEDGENERIC;
	    *ppmkComposite = NULL;
	    return hresult;
	}

	//
	// Now, we are going to make a generic composite. This is a
	// good time to determine if we need to convert this
	// anti moniker into a composite
	//
	// If m_count > 1, create an equivalent composite moniker
	//

	if (m_count > 1)
	{
	    pmkThis = Create(m_count);
	}

	//
	// Regardless of the outcome, be sure pmkThis == a moniker to
	// compose with.
	//

	if (pmkThis == NULL)
	{
	    pmkThis = this;
	}

	//
	// If the right side is an anti moniker also, then we need to
	// concatenate the two Anti monikers into a composite.
	//

	CAntiMoniker *pmkRightAnti = IsAntiMoniker(pmkRight);
	if (pmkRightAnti)
	{
	    mnkDebugOut((DEB_ITRACE,
			 "::ComposeWith(%x) CAntiMoniker(%x)\n",
			 this,
			 pmkRight));

	    //
	    // The right side is also an Anti moniker. Does it need fixing
	    // as well? If so, then fix it up, and assign it to pmkRight
	    //

	    if (pmkRightAnti->m_count > 1 )
	    {
		pmkRightComposite = CAntiMoniker::Create(m_count);

		if (pmkRightComposite != NULL)
		{
		    pmkRight = pmkRightComposite;
		}
	    }

	    hresult = Concatenate(pmkThis,pmkRight,ppmkComposite);
	}
	else
        {
	    //
	    // Anti monikers can only be composed using generic composites
	    // when they are on the left.
	    //

	    hresult = CreateGenericComposite( pmkThis,
					      pmkRight,
					      ppmkComposite );
	}

	//
	// Clean up after possible conversions
	//

	if (pmkThis != this)
	{
	    pmkThis->Release();
	}

	if (pmkRightComposite != NULL)
	{
	    pmkRightComposite->Release();
	}

	return hresult;
}

STDMETHODIMP CAntiMoniker::Enum (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
	VDATEPTROUT(ppenumMoniker,LPENUMMONIKER);
	*ppenumMoniker = NULL;
	noError;
}

//+---------------------------------------------------------------------------
//
//  Method:     CAntiMoniker::GetComparisonData
//
//  Synopsis:   Get comparison data for registration in the ROT
//
//  Arguments:  [pbData] - buffer to put the data in.
//              [cbMax] - size of the buffer
//              [pcbData] - count of bytes used in the buffer
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//  Algorithm:  Build ROT data for anti moniker.
//
//  History:    03-Feb-95   kevinro  Created
//
// Note:        Validating the arguments is skipped intentionally because this
//              will typically be called internally by OLE with valid buffers.
//
//----------------------------------------------------------------------------
STDMETHODIMP CAntiMoniker::GetComparisonData(
    byte *pbData,
    ULONG cbMax,
    DWORD *pcbData)
{
    ULONG ulLength = sizeof(CLSID_AntiMoniker) + sizeof(m_count);

    Assert(pcbData != NULL);
    Assert(pbData != NULL);

    if (cbMax < ulLength)
    {
	return(E_OUTOFMEMORY);
    }

    memcpy(pbData,&CLSID_AntiMoniker,sizeof(CLSID_AntiMoniker));
    memcpy(pbData+sizeof(CLSID_AntiMoniker),&m_count,sizeof(m_count));

    *pcbData = ulLength;

    return NOERROR;
}

STDMETHODIMP CAntiMoniker::IsEqual (THIS_ LPMONIKER pmkOtherMoniker)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::IsEqual(%x,pmkOther(%x))\n",
		 this,
		 pmkOtherMoniker));

	VDATEIFACE(pmkOtherMoniker);

	CAntiMoniker *pCAM = IsAntiMoniker(pmkOtherMoniker);

	if (pCAM)
	{
	    //	the other moniker is an anti moniker.
	    if (m_count == pCAM->m_count)
	    {
		return NOERROR;	
	    }
	}

	return ResultFromScode(S_FALSE);
}



STDMETHODIMP CAntiMoniker::Hash (THIS_ LPDWORD pdwHash)
{
	VDATEPTROUT(pdwHash, DWORD);
	*pdwHash = 0x80000000 + m_count;
	noError;
}



STDMETHODIMP CAntiMoniker::CommonPrefixWith (LPMONIKER pmkOther, LPMONIKER FAR*
	ppmkPrefix)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::CommonPrefixWith(%x,pmkOther(%x))\n",
		 this,
		 pmkOther));

	M_PROLOG(this);
	VDATEPTROUT(ppmkPrefix,LPMONIKER);
	*ppmkPrefix = NULL;
	VDATEIFACE(pmkOther);

	CAntiMoniker *pAntiMoniker = IsAntiMoniker(pmkOther);
	if (pAntiMoniker)
	{
		if (m_count <= pAntiMoniker->m_count)
		{
			*ppmkPrefix = this;
			AddRef();
			if (m_count == pAntiMoniker->m_count)
			    return ResultFromScode(MK_S_US);
			return ResultFromScode(MK_S_ME);
		}
		*ppmkPrefix = pmkOther;
		pmkOther->AddRef();
		return ResultFromScode(MK_S_HIM);
	}
	return MonikerCommonPrefixWith(this, pmkOther, ppmkPrefix);
    //  this handles the case where pmkOther is composite, as well as
    //  all other cases.
}



STDMETHODIMP CAntiMoniker::RelativePathTo (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
	ppmkRelPath)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::RelativePathTo(%x,pmkOther(%x))\n",
		 this,
		 pmkOther));

	VDATEPTROUT(ppmkRelPath,LPMONIKER);
	VDATEIFACE(pmkOther);

	*ppmkRelPath = NULL;

	*ppmkRelPath = pmkOther;
	pmkOther->AddRef();

	return MK_S_HIM;
}



STDMETHODIMP CAntiMoniker::GetDisplayName( LPBC pbc, LPMONIKER
	pmkToLeft, LPWSTR FAR * lplpszDisplayName )
	//	return "\..\..\.. "
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::GetDisplayName(%x,pmkLeft(%x))\n",
		 this,
		 pmkToLeft));

	M_PROLOG(this);

	VDATEPTROUT(lplpszDisplayName, LPWSTR);

	*lplpszDisplayName = NULL;

	VDATEIFACE(pbc);

	if (pmkToLeft) VDATEIFACE(pmkToLeft);

	WCHAR FAR * lpch;
	ULONG i;
	ULONG ccDisplayName;

	//
	// ccDisplayName is the number of characters to allocate
	//
	// For each anti moniker, return one instance of '\..', which
	// is 3 characters long. Also, add 1 for the terminating NULL
	//

	ccDisplayName = 1 + ( 3 * m_count );

	*lplpszDisplayName = (WCHAR *)
	    CoTaskMemAlloc(sizeof(WCHAR) * ccDisplayName);

	lpch = *lplpszDisplayName;

	if (lpch == NULL)
	{
	    return E_OUTOFMEMORY;
	}

	//
	// Concat a whole bunch of strings forming the display name for
	// the anti moniker
	//
	for (i = m_count; i > 0; i-- , lpch += 3)
	{
	    memcpy(lpch, L"\\..", 3 * sizeof(WCHAR));	
	}

	*lpch = '\0';

	return NOERROR;
}



STDMETHODIMP CAntiMoniker::ParseDisplayName( LPBC pbc,
	LPMONIKER pmkToLeft, LPWSTR lpszDisplayName, ULONG FAR* pchEaten,
	LPMONIKER FAR* ppmkOut)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::ParseDisplayName(%x,pmkLeft(%x)lpszName(%ws))\n",
		 this,
		 pmkToLeft,
		 WIDECHECK(lpszDisplayName)));

	M_PROLOG(this);
	VDATEPTROUT(ppmkOut,LPMONIKER);
	*ppmkOut = NULL;
	VDATEIFACE(pbc);
	if (pmkToLeft) VDATEIFACE(pmkToLeft);
	VDATEPTRIN(lpszDisplayName, WCHAR);
	VDATEPTROUT(pchEaten,ULONG);

	return ResultFromScode(E_NOTIMPL);	//	ParseDisplayName not implemented for AntiMonikers
}



STDMETHODIMP CAntiMoniker::IsSystemMoniker (THIS_ LPDWORD pdwType)
{
	M_PROLOG(this);
	*pdwType = MKSYS_ANTIMONIKER;
	return NOERROR;		
}

//+---------------------------------------------------------------------------
//
//  Method:     CAntiMoniker::EatOne
//
//  Synopsis:   This function creates an appropriate Anti moniker
//
//  Effects:
//
//  Arguments:  [ppmk] --
//
//  Requires:
//
//  Returns:
//	if m_count == 1, returns NULL
//	if m_count == 2, returns a CAntiMoniker
//	if m_count > 2, returns a composite made up of anti monikers.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-04-94   kevinro   Created
//
//  Notes:
//
//  Back in the days when monikers collapsed themselves, this routine was
//  called in order to eat one of the counts. Now, it is used as a good place
//  to throw in a conversion for composite anti-monikers.
//
//----------------------------------------------------------------------------
void CAntiMoniker::EatOne(LPMONIKER *ppmk)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::EatOne(%x)\n",
		 this));

    *ppmk = CAntiMoniker::Create(m_count - 1);
}


#ifdef _DEBUG

STDMETHODIMP_(void) NC(CAntiMoniker,CDebug)::Dump( IDebugStream FAR * pdbstm)
{
	VOID_VDATEIFACE(pdbstm);
	
	*pdbstm << "CAntiMoniker @" << (VOID FAR *)m_pAntiMoniker;
	*pdbstm << '\n';
	pdbstm->Indent();
	*pdbstm << "Refcount is " << (int)(m_pAntiMoniker->m_refs) << '\n';
	*pdbstm << "Anti count is " << (int)(m_pAntiMoniker->m_count) << '\n';
	pdbstm->UnIndent();
}

STDMETHODIMP_(BOOL) NC(CAntiMoniker,CDebug)::IsValid( BOOL fSuspicious )
{
	return ((LONG)(m_pAntiMoniker->m_refs) > 0);
	//	add more later, maybe
}			

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\inc\xstring.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       xstring.cxx
//
//  Contents:   Member functions for XString class
//
//  Classes:    XString
//
//  History:	01-Dec-92 MikeSe	Created
//		13-Oct-92 Ricksa	Ported to cairole & deleted exceptions
//
//--------------------------------------------------------------------------

#include <xstring.hxx>

static WCHAR awszEmpty[] = L"";


//+-------------------------------------------------------------------------
//
//  Member:     XString::XString, public
//
//  Synopsis:   Constructor, no arguments
//
//  History:    1-Dec-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
XString::XString ( ) :_pwsz(NULL)
{
}

//+-------------------------------------------------------------------------
//
//  Member:     XString::XString, public
//
//  Synopsis:   Constructor, taking a length argument
//
//  Arguments:  [cNewStr]       -- size to allocate
//
//  Signals:    Exception from heap allocation failure
//
//  History:    1-Dec-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
XString::XString ( ULONG cNewStr ) :_pwsz(NULL)
{
    _pwsz = new WCHAR [cNewStr];
}

//+-------------------------------------------------------------------------
//
//  Member:     XString::XString, public
//
//  Synopsis:   Constructor, taking a single string argument
//
//  Arguments:  [pwsz]          -- string to store
//
//  Signals:    Exception from heap allocation failure
//
//  History:    1-Dec-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
XString::XString ( WCHAR const * pwsz ) :_pwsz(NULL)
{
    if ( pwsz != NULL )
    {
        _pwsz = new WCHAR [lstrlenW(pwsz) + 1];
        lstrcpyW ( _pwsz, pwsz );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     XString::XString, public
//
//  Synopsis:   Constructor, taking two string arguments
//
//  Arguments:  [pwsz1]         -- first string to store
//              [pwsz2]         -- second string, to be concatenated with first
//
//  Signals:    Exception from heap allocation failure
//
//  History:    1-Dec-92 MikeSe         Created
//
//  Notes:      This function converts NULL pointers to a null string.
//              This saves having to check for NULL elsewhere.
//
//--------------------------------------------------------------------------

EXPORTIMP
XString::XString ( WCHAR const * pwsz1, WCHAR const * pwsz2 )
{
    if ( pwsz1 == NULL )
        pwsz1 = awszEmpty;

    if ( pwsz2 == NULL )
        pwsz2 = awszEmpty;

    ULONG len = lstrlenW ( pwsz1 ) + lstrlenW ( pwsz2 ) + 1;
    _pwsz = new WCHAR [len];
    lstrcpyW ( _pwsz, pwsz1 );
    lstrcatW ( _pwsz, pwsz2 );
}

//+-------------------------------------------------------------------------
//
//  Member:     XString::XString, public
//
//  Synopsis:   Constructor, taking a single DBCS string argument,
//              incorporating conversion to wide char using current locale.
//
//  Arguments:  [psz]           -- string to store
//
//  Signals:    Exception from heap allocation failure
//
//  History:    1-Dec-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
XString::XString ( CHAR const * psz ) :_pwsz(NULL)
{
    if ( psz != NULL )
    {
        ULONG len = strlen ( psz ) + 1;
        _pwsz = new WCHAR [len];
        MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, psz, -1, _pwsz, len);
    }
}

EXPORTIMP XString&
XString::operator= ( WCHAR const *pwsz )
{
    delete _pwsz;

    if ( pwsz == NULL )
    {
        _pwsz = NULL;
    }
    else
    {
        _pwsz = new WCHAR [lstrlenW(pwsz)+1];
        lstrcpyW ( _pwsz, pwsz );
    }

    return *this;
}

//-----------------------------------------------------------------------------
//
// Member:     XString::operator&
//
// Synopsis:   Returns the address of the _pwsz member so that a WCHAR * can be
//             transferred to the XString
//
// History:    31-Mar-1993     KirtD           Created
//
// Notes:      PLEASE USE WITH CARE, see declaration in xstring.hxx
//
//-----------------------------------------------------------------------------
EXPORTIMP WCHAR **
XString::operator& ()
{
     delete _pwsz;
     _pwsz = NULL;

     return(&_pwsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\cdialog.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cdialog.h
//
//  Contents:   definition for common dialog functionality
//
//  Classes:    CHlprDialog (pure virtual class)
//
//  Functions:  DialogProc
//
//  History:    4-12-94   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef __CDIALOG_H__
#define __CDIALOG_H__

#ifdef __cplusplus
extern "C" {
#endif

BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}

//+---------------------------------------------------------------------------
//
//  Class:      CHlprDialog
//
//  Purpose:    virtual base class for wrapping Windows' dialog functionality
//
//  Interface:  ShowDialog -- analagous to the Windows DialogBox function
//              DialogProc -- pure virtual DialogProc for the dialog box
//              ~CHlprDialog   -- destructor
//
//  History:    4-12-94   stevebl   Created
//              7-02-1997   stevebl   added CreateDlg
//
//  Notes:      This class allows a dialog box to be cleanly wrapped in
//              a c++ class.  Specifically, it provides a way for a c++ class
//              to use one of its methods as a DialogProc, giving it a "this"
//              pointer and allowing it to have direct access to all of its
//              private members.
//
//----------------------------------------------------------------------------

class CHlprDialog
{
public:
    virtual INT_PTR ShowDialog(HINSTANCE hinst, LPCTSTR lpszTemplate, HWND hwndOwner);
    virtual HWND    CreateDlg(HINSTANCE hinst, LPCTSTR lpszTemplate, HWND hwndOwner);
    virtual BOOL    DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) = 0;
    virtual ~CHlprDialog(){};
protected:
    HINSTANCE m_hInstance;
};

#endif //__cplusplus

#endif //__CDIALOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\cfactory.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:	cfactory.cxx
//
//  Contents:	The class factory implementations for the monikers.
//
//  Classes:	CMonikerFactory
//             CClassMonikerFactory
//             CFileMonikerFactory
//             CObjrefMonikerFactory
//
//  Functions:	MonikerDllGetClassObject
//
//  History:    22-Feb-96 ShannonC  Created
//              24-Apr-97 Ronans        Support for Objref Monikers
//
//--------------------------------------------------------------------------
#include <ole2int.h>
#include "cfactory.hxx"
#include "cbasemon.hxx"
#include "cfilemon.hxx"
#include "classmon.hxx"
#include "cptrmon.hxx"
#include "mnk.h"
#include "cobjrmon.hxx"
#include <dllhost.hxx>


//Static class factory objects.
static CClassMonikerFactory g_ClassMonikerFactory;
static CFileMonikerFactory  g_FileMonikerFactory;
static CObjrefMonikerFactory g_ObjrefMonikerFactory;

//+-------------------------------------------------------------------------
//
//  Function: 	GetApartmentClass
//
//  Synopsis:   Returns a pointer to the class factory.
//
//  Arguments:  [clsid]	-- the class id desired
//		[iid]	-- the requested interface
//		[ppv]	-- where to put the pointer to the new object
//
//  Returns:    S_OK
//              CLASS_E_CLASSNOTAVAILABLE
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
#pragma SEG(DllGetClassObject)
HRESULT GetApartmentClass(REFCLSID clsid, REFIID iid, void **ppv)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "GetApartmentClass(%I,%I,%x)\n",
                &clsid, &iid, ppv));

    *ppv = 0;

    if(IsEqualCLSID(clsid, CLSID_UrlMonWrapper))
    {
        IUnknown *punk;

        punk = new CUrlMonWrapper();
        if(punk != 0)
        {
            hr = punk->QueryInterface(iid, ppv);
            punk->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function: 	ApartmentDllGetClassObject
//
//  Synopsis:   Returns a pointer to the moniker class factory.
//              This function provides access to the class factories for
//              apartment model objects.
//
//  Arguments:  [clsid]	-- the class id desired
//		[iid]	-- the requested interface
//		[ppv]	-- where to put the pointer to the new object
//
//  Returns:    S_OK
//              CLASS_E_CLASSNOTAVAILABLE
//              E_INVALIDARG
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//
//  Notes:      This is an internal function called by DllGetClassObject.
//
//--------------------------------------------------------------------------
#pragma SEG(DllGetClassObject)
HRESULT ApartmentDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "ApartmentDllGetClassObject(%I,%I,%x)\n",
                &clsid, &iid, ppv));

    if(IsEqualCLSID(clsid, CLSID_UrlMonWrapper))
    {
        COleTls tls;

        if (IsThreadInNTA() || !(tls->dwFlags & OLETLS_APARTMENTTHREADED))
        {
            //We need to switch to a single-threaded apartment.
            hr = DoATClassCreate(GetApartmentClass, clsid, iid, (IUnknown **)ppv);
        }
        else
        {
            //This thread is in a single-threaded apartment.
            hr = GetApartmentClass(clsid, iid, ppv);
        }
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function: 	MonikerDllGetClassObject
//
//  Synopsis:   Returns a pointer to the moniker class factory.
//              This function provides access to the class factories for
//              the file moniker and the class moniker.
//
//  Arguments:  [clsid]	-- the class id desired
//		[iid]	-- the requested interface
//		[ppv]	-- where to put the pointer to the new object
//
//  Returns:    S_OK
//              CLASS_E_CLASSNOTAVAILABLE
//              E_INVALIDARG
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//
//  Notes:      This is an internal function called by DllGetClassObject.
//
//--------------------------------------------------------------------------
#pragma SEG(DllGetClassObject)
HRESULT MonikerDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "MonikerDllGetClassObject(%I,%I,%x)\n",
                &clsid, &iid, ppv));

    if(IsEqualCLSID(clsid, CLSID_FileMoniker))
    {
        hr = g_FileMonikerFactory.QueryInterface(iid, ppv);
    }
    else if(IsEqualCLSID(clsid, CLSID_ClassMoniker))
    {
        hr = g_ClassMonikerFactory.QueryInterface(iid, ppv);
    }
    else if(IsEqualCLSID(clsid, CLSID_ObjrefMoniker))
    {
        hr = g_ObjrefMonikerFactory.QueryInterface(iid, ppv);
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMonikerFactory::QueryInterface
//
//  Synopsis:   The moniker factory support IUnknown, IClassFactory,
//              and IParseDisplayName
//
//  Arguments:  [iid]           -- the requested interface
//              [ppvObj]        -- where to put the interface pointer
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_NOINTERFACE
//
//  Notes:      Bad parameters will raise an exception.  The exception
//              handler catches exceptions and returns E_INVALIDARG.
//
//--------------------------------------------------------------------------
STDMETHODIMP CMonikerFactory::QueryInterface (REFIID iid, void ** ppvObj)
{
    HRESULT hr;

    __try
    {
        mnkDebugOut((DEB_TRACE, 
                    "CMonikerFactory::QueryInterface(%x,%I,%x)\n",
                     this, &iid, ppvObj));

        *ppvObj = NULL;

        if(IsEqualIID(iid,IID_IClassFactory) ||
           IsEqualIID(iid,IID_IUnknown))           
        {
            AddRef();
            *ppvObj = (IClassFactory *) this;
            hr = S_OK;
        }
        else if(IsEqualIID(iid,IID_IParseDisplayName))
        {
            AddRef();
            *ppvObj = (IParseDisplayName *) this;
            hr = S_OK;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }           

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMonikerFactory::AddRef
//
//  Synopsis:   Increment the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the new reference count
//
//  Notes:      This is a static object.  The reference count is always 1.
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMonikerFactory::AddRef(void)
{
    mnkDebugOut((DEB_TRACE, 
                 "CMonikerFactory::AddRef(%x)\n",
                 this));

    return 1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMonikerFactory::Release
//
//  Synopsis:   Decrements the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the remaining reference count
//
//  Notes:      This is a static object.  The reference count is always 1.
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMonikerFactory::Release(void)
{
    mnkDebugOut((DEB_TRACE, 
                 "CMonikerFactory::Release(%x)\n",
                 this));
    return 1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMonikerFactory::LockServer
//
//  Synopsis:   Lock the server. Does nothing.
//
//  Arguments:  fLock
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP CMonikerFactory::LockServer(BOOL fLock)
{
    mnkDebugOut((DEB_TRACE, 
                 "CMonikerFactory::LockServer(%x,%x)\n",
                 this, fLock));
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassMonikerFactory::CreateInstance
//
//  Synopsis:   Creates a class moniker.
//
//  Arguments:  [pUnkOuter] - The controlling unknown (for aggregation)
//              [iid]       - The requested interface ID.
//              [ppv]       - Returns the pointer to the new object
//
//  Returns:    S_OK
//              CLASS_E_NOAGGREGATION
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP CClassMonikerFactory::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID     riid, 
    void **    ppv)
{
    HRESULT hr;
    IID     iid;

    __try
    {
        mnkDebugOut((DEB_TRACE, 
                     "CClassMonikerFactory::CreateInstance(%x,%x,%I,%x)\n",
                     this, pUnkOuter, &iid, ppv));

        //Parameter validation.
        *ppv = NULL;
        iid = riid;

        if(NULL == pUnkOuter)
        {
            CClassMoniker *pmk = new CClassMoniker(CLSID_NULL);
            if(pmk != NULL)
            {
                hr = pmk->QueryInterface(iid, ppv);
                pmk->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            //Class moniker does not support aggregation.
            hr = CLASS_E_NOAGGREGATION;            
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   ParseClassID
//
//  Synopsis:   Parses a display name containing a class ID.
//
//  Arguments:  pszDisplayName - Supplies display name to be parsed.
//              pchEaten       - Returns the number of characters parsed.
//              pClassID       - Returns the class ID.
//
//  Returns:    S_OK
//              MK_E_SYNTAX
//
//  Notes:      The class ID can have one of the following formats:
//              00000000-0000-0000-0000-000000000000
//              {00000000-0000-0000-0000-000000000000}
//
//--------------------------------------------------------------------------
HRESULT ParseClassID(
    LPCWSTR pszDisplayName,
    ULONG * pchEaten,
    CLSID * pClassID)
{
    HRESULT hr = MK_E_SYNTAX;

    *pchEaten = 0;

    //Parse xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
    if(wUUIDFromString(pszDisplayName, pClassID) == TRUE)
    {
        //There are 36 characters in xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
        *pchEaten = 36;
        hr = S_OK;
    }
    //Parse {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    else if((L'{' == pszDisplayName[0]) &&
            (wUUIDFromString(&pszDisplayName[1], pClassID) == TRUE) &&
            (L'}' == pszDisplayName[37]))
    {
        //There are 38 characters in {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
        *pchEaten = 38;
        hr = S_OK;

    }

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CClassMonikerFactory::ParseDisplayName
//
//  Synopsis:   Parse a class moniker display name.
//
//  Arguments:  pbc - Supplies bind context.
//              pszDisplayName - Supplies display name to be parsed.
//              pchEaten - Returns the number of characters parsed.
//              ppmkOut - Returns the pointer to the resulting moniker.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------
STDMETHODIMP CClassMonikerFactory::ParseDisplayName( 
    IBindCtx  * pbc,
    LPOLESTR    pszDisplayName,
    ULONG     * pchEaten,
    IMoniker ** ppmkOut)
{
    HRESULT   hr;
    BIND_OPTS bindopts;
    ULONG     chName;
    ULONG     cbName;
    LPWSTR    pName;
    CClassMoniker *pmkClass = NULL;
    ULONG     cEaten = 0;
    CLSID     classID;
    LPCWSTR   pszParameters = NULL;
    LPOLESTR  pch = pszDisplayName;

    __try
    {

        mnkDebugOut((DEB_TRACE, 
                     "CClassMonikerFactory::ParseDisplayName(%x,%x,%ws,%x,%x)\n",
                     this, pbc, pszDisplayName, pchEaten, ppmkOut));

        //Validate parameters.
        *pchEaten = 0;
        *ppmkOut = NULL;
        bindopts.cbStruct = sizeof(BIND_OPTS);
        pbc->GetBindOptions(&bindopts);

        // Eat the prefix.
        while (*pch != '\0' && *pch != ':')
        {
            pch++;
        }

        if(':' == *pch)
        {
            pch++;
        }
        else
        {
            return MK_E_SYNTAX;
        }

        //Copy the display name.
        //Note that we allocate memory from the stack so we don't have to free it.
        chName = lstrlenW(pch);
        cbName = chName * sizeof(WCHAR) + sizeof(WCHAR);
        pName = (LPWSTR) alloca(cbName);

        if(pName != NULL)
        {
            memcpy(pName, pch, cbName);
            hr = ParseClassID(pName, &cEaten, &classID);
              
            if(SUCCEEDED(hr))
            {
                //Parse the parameters.
                if(L';' == pName[cEaten])
                {
                    pszParameters = &pName[cEaten];
                    cEaten++;
                }

                //Parse the name up to the :.
                while(cEaten < chName && 
                      pName[cEaten] != L':')
                {
                    cEaten++;
                }

                if(L':' == pName[cEaten])
                {
                    pName[cEaten] = L'\0';

                   //Eat the :
                   cEaten++;
                }

               //Create the class moniker.
               pmkClass = new CClassMoniker(classID);

               if(pmkClass != NULL)
               {
                   //Set the parameters.
                   if(pszParameters != NULL)
                   {
                       hr = pmkClass->SetParameters(pszParameters);
                       if(FAILED(hr))
                       {
                           pmkClass->Release();
                           pmkClass = NULL;
                       }
                   }
                   else
                   {
                       hr = S_OK;
                   }
               }
               else
               {
                   hr = E_OUTOFMEMORY;
               }               
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {            
            cEaten += (ULONG) (pch - pszDisplayName);
            *pchEaten = cEaten;
            *ppmkOut = pmkClass;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileMonikerFactory::CreateInstance
//
//  Synopsis:   Creates a file moniker.
//
//  Arguments:  [pUnkOuter]     -- the controlling unknown (for aggregation)
//              [iid]           -- the requested interface ID
//              [ppv]           -- where to put the pointer to the new object
//
//  Returns:    S_OK
//              CLASS_E_NOAGGREGATION
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP CFileMonikerFactory::CreateInstance(
    IUnknown * pUnkOuter, 
    REFIID     riid, 
    void    ** ppv)
{
    HRESULT hr;
    IID     iid;

    __try
    {
        mnkDebugOut((DEB_TRACE, 
                     "CFileMonikerFactory::CreateInstance(%x,%x,%I,%x)\n",
                     this, pUnkOuter, &iid, ppv));

        //Parameter validation.
        *ppv = NULL;
        iid = riid;

        if(NULL == pUnkOuter)
        {
            IMoniker *pmk;

            pmk = CFileMoniker::Create(OLESTR(""), 0, DEF_ENDSERVER);

            if(pmk != NULL)
            {
                hr = pmk->QueryInterface(iid, ppv);
                pmk->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;                
            }
        }
        else
        {
            //File moniker does not support aggregation.
            hr = CLASS_E_NOAGGREGATION;            
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    
        return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFileMonikerFactory::ParseDisplayName
//
//  Synopsis:   Parse a file moniker display name.
//
//  Arguments:  pbc - Supplies bind context.
//              pszDisplayName - Supplies display name to be parsed.
//              pchEaten - Returns the number of characters parsed.
//              ppmkOut - Returns the pointer to the resulting moniker.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------
STDMETHODIMP CFileMonikerFactory::ParseDisplayName( 
    IBindCtx  * pbc,
    LPOLESTR    pszDisplayName,
    ULONG     * pchEaten,
    IMoniker ** ppmkOut)
{
    HRESULT   hr;
    BIND_OPTS bindopts;
    IMoniker *pmkFile;
    ULONG     cEaten;

    __try
    {
        LPOLESTR  pch = pszDisplayName;

        mnkDebugOut((DEB_TRACE, 
                     "CFileMonikerFactory::ParseDisplayName(%x,%x,%ws,%x,%x)\n",
                     this, pbc, pszDisplayName, pchEaten, ppmkOut));

        //Validate parameters.
        *ppmkOut = NULL;
        *pchEaten = 0;
        bindopts.cbStruct = sizeof(BIND_OPTS);
        pbc->GetBindOptions(&bindopts);

        // Eat the prefix.
        while (*pch != '\0' && *pch != ':')
        {
            pch++;
        }

        if(':' == *pch)
        {
            pch++;
        }
        else
        {
            return MK_E_SYNTAX;
        }

        hr = FindFileMoniker(pbc, pch, &cEaten, &pmkFile);
        if(SUCCEEDED(hr))
        {
            cEaten += (ULONG) (pch - pszDisplayName);           
            *pchEaten = cEaten;
            *ppmkOut = pmkFile;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CObjrefMonikerFactory::CreateInstance
//
//  Synopsis:   Creates a objref moniker.
//
//  Arguments:  [pUnkOuter]     -- the controlling unknown (for aggregation)
//              [iid]           -- the requested interface ID
//              [ppv]           -- where to put the pointer to the new object
//
//  Returns:    S_OK
//              CLASS_E_NOAGGREGATION
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP CObjrefMonikerFactory::CreateInstance(
    IUnknown * pUnkOuter, 
    REFIID     riid, 
    void    ** ppv)
{
    HRESULT hr;
    IID     iid;

    __try
    {
        mnkDebugOut((DEB_TRACE, 
                     "CObjrefMonikerFactory::CreateInstance(%x,%x,%I,%x)\n",
                     this, pUnkOuter, &iid, ppv));

        //Parameter validation.
        *ppv = NULL;
        iid = riid;

        if(NULL == pUnkOuter)
        {
            IMoniker *pmk;

            pmk = CObjrefMoniker::Create(NULL);

            if(pmk != NULL)
            {
                hr = pmk->QueryInterface(iid, ppv);
                pmk->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;                
            }
        }
        else
        {
            //Objref moniker does not support aggregation.
            hr = CLASS_E_NOAGGREGATION;            
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
        return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CObjrefMonikerFactory::ParseDisplayName
//
//  Synopsis:   Parse a objref moniker display name.
//
//  Arguments:  pbc - Supplies bind context.
//              pszDisplayName - Supplies display name to be parsed.
//              pchEaten - Returns the number of characters parsed.
//              ppmkOut - Returns the pointer to the resulting moniker.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
// Notes:               Display name is base64 representation of marshal data for moment
//
//--------------------------------------------------------------------------
STDMETHODIMP CObjrefMonikerFactory::ParseDisplayName( 
    IBindCtx  * pbc,
    LPOLESTR    pszDisplayName,
    ULONG     * pchEaten,
    IMoniker ** ppmkOut)
{
    HRESULT   hr;
    BIND_OPTS bindopts;
    ULONG     chName = 0;
    ULONG     cbName;
    LPWSTR    pName;
    CObjrefMoniker *pmkObjref = NULL;
    LPOLESTR  pch = pszDisplayName, pch2 = NULL;

    __try
    {

        mnkDebugOut((DEB_TRACE, 
                     "CObjrefMonikerFactory::ParseDisplayName(%x,%x,%ws,%x,%x)\n",
                     this, pbc, pszDisplayName, pchEaten, ppmkOut));

        //Validate parameters.
        *pchEaten = 0;
        *ppmkOut = NULL;
        bindopts.cbStruct = sizeof(BIND_OPTS);
        pbc->GetBindOptions(&bindopts);

        // Eat the prefix.
        while (*pch != '\0' && *pch != ':')
        {
            pch++;
        }


        if(':' == *pch)
            pch++;
        else
            return MK_E_SYNTAX;

        // at this point we are at the start of the base64 data for the objref moniker
        pch2 = pch;
        
        // calculate length of base64 data 
        while (*pch2 != '\0' && *pch2 != ':')
        {
            chName++;
            pch2++;
        }
        
        // verify we have a terminating ':'
        if(':' == *pch2)
            pch2++;
        else
            return MK_E_SYNTAX;


        //Copy the display name.
        //Note that we allocate memory from the stack so we don't have to free it.
        cbName = chName * sizeof(WCHAR) ;
        pName = (LPWSTR) alloca(cbName + sizeof(WCHAR));
        
        if(pName != NULL)
        {
            memcpy(pName, pch, cbName );
            pName[chName] = L'\0';
            
            
            IStream *pIStream = utBase64ToIStream(pName);
              
            if(pIStream)
            {
                //Create the objref moniker.
                pmkObjref = new CObjrefMoniker(NULL);
                
                if(pmkObjref != NULL)
                {
                    hr = pmkObjref -> Load(pIStream);
                    
                    if(FAILED(hr))
                    {
                        pmkObjref->Release();
                        pmkObjref = NULL;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }               
                pIStream -> Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {            
            *pchEaten = (ULONG) (pch2 - pszDisplayName);
            *ppmkOut = pmkObjref;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\cbindctx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       cbindctx.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//		12-27-93   ErikGav   Created
//              10-05-95   MikeHill  Added 'dwRestricted' field to BIND_OPTS.
//              11-14-95   MikeHill  Removed previous change (to BIND_OPTS).
//              12-06-95   MikeHill  Fixed Get/SetBindOptions so they don't corrupt
//                                   the cbStruct field.
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbindctx.hxx"
#include "mnk.h"


/*
 *	Implementation of CBindCtx
 *	
 *	
 *	
 *	
 */


NAME_SEG(CBindCtx)

#ifdef NOTYET
//	IEnumString implementation for EnumObjectParam call

class CEnumStringImpl :  public IEnumString
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj)
	{
		if (riid == IID_IEnumString || riid == IID_IUnknown)
		{
			*ppvObj = this;
			AddRef();
			return NOERROR;
		}
		return ResultFromScode(E_NOINTERFACE);
	}

    STDMETHOD_(ULONG,AddRef) (THIS)
	{
		return ++m_refs;
	}

    STDMETHOD_(ULONG,Release) (THIS)
	{
		if (--m_refs == 0)
		{
			delete this;
			return 0;
		}
		return m_refs;
	}

    // *** IEnumString methods ***
    STDMETHOD(Next) (THIS_ ULONG celt,
		       LPWSTR FAR* reelt,
                       ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (THIS_ ULONG celt);
    STDMETHOD(Reset) (THIS);
    STDMETHOD(Clone) (THIS_ LPENUMSTRING FAR* ppenm);

	//constructor/destructor
	CEnumStringImpl( CMapStringToPtr FAR * pMap );
	~CEnumStringImpl( void );

private:
	class LI
	{
	public:
		LI FAR * pliNext;
		LPWSTR lpszKey;

		LI( LPWSTR lpsz ) {
			lpszKey = lpsz;
		}
	};
	friend class LI;

	LI FAR * pliHead;
	LI FAR * pliCurrent;
	ULONG 	 m_refs;
};
#endif // NOTYET



CBindCtx::CBindCtx()
#ifdef _DEBUG
	: m_Debug(this)
#endif
{
    GET_A5();
    m_refs = 1;
    m_pFirstObj = NULL;

    m_bindopts.cbStruct = sizeof(m_bindopts);
    m_bindopts.grfFlags = 0;
    m_bindopts.grfMode =  STGM_READWRITE;
    m_bindopts.dwTickCountDeadline = 0;
    m_bindopts.dwTrackFlags = 0;

    m_bindopts.dwClassContext = CLSCTX_SERVER;

    m_bindopts.locale = GetThreadLocale();
    m_bindopts.pServerInfo = 0;

    m_pMap = NULL;
}


CBindCtx::~CBindCtx( void )
{
	LPWSTR lpszKey;
	LPVOID lpvoid;
	M_PROLOG(this);

	ReleaseBoundObjects();

    if (m_pMap)
    {
    	POSITION pos = m_pMap->GetStartPosition();
    	while (pos != NULL)
    	{
    		m_pMap->GetNextAssoc(pos, lpszKey, lpvoid);
            if (lpvoid) ((LPUNKNOWN)lpvoid)->Release();
    	}
        delete m_pMap;
    }
}



NC(CBindCtx,CObjList)::~CObjList(void)
{
	if (m_punk) m_punk->Release();
}


IBindCtx FAR *CBindCtx::Create()
{
	return new FAR CBindCtx();
}


STDMETHODIMP CBindCtx::QueryInterface(REFIID iidInterface, void FAR* FAR* ppv)
{
    HRESULT hr;

    __try
    {
        //Parameter validation.
        //An invalid parameter will throw an exception.
        *ppv = 0;

        if (IsEqualIID(iidInterface, IID_IUnknown)
            || IsEqualIID(iidInterface, IID_IBindCtx))
        {
            AddRef();
            *ppv = this;
            hr = S_OK;
        }
#ifdef _DEBUG
        else if(IsEqualIID(iidInterface,IID_IDebug))
        {
            *ppv = (void FAR *)&m_Debug;
            hr = S_OK;
	}
#endif
        else
        {
            hr = E_NOINTERFACE;
	}
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //An exception occurred, probably because of a bad parameter.
        hr = E_INVALIDARG;
    }
    return hr;
}



STDMETHODIMP_(ULONG) CBindCtx::AddRef( void )
{
    InterlockedIncrement((long *)&m_refs);
    return m_refs;
}


STDMETHODIMP_(ULONG) CBindCtx::Release( void )
{
    ULONG count = m_refs - 1;

    if(InterlockedDecrement((long *)&m_refs) == 0)
    {
        delete this;
        count = 0;
    }

    return count;
}


STDMETHODIMP	CBindCtx::RegisterObjectBound( LPUNKNOWN punk )
{
	M_PROLOG(this);
	if (punk == NULL) noError;
	VDATEIFACE(punk);
	CObjList FAR* pCOL = new CObjList( punk );
	if (pCOL)
	{
		punk->AddRef();
		AddToList(pCOL);
		noError;
	}
	return ResultFromScode(S_OOM);
}



STDMETHODIMP	CBindCtx::RevokeObjectBound
	( LPUNKNOWN punk )
{
	M_PROLOG(this);
	VDATEIFACE(punk);
	CObjList FAR * pCOL = m_pFirstObj;
	CObjList FAR * pCOLPrev = NULL;

	// look for entry which matches punk given
	for (; pCOL && (pCOL->m_punk != punk);
	    pCOLPrev = pCOL, pCOL = pCOL->m_pNext)
	{
	    // empty
	}

	//	pCOL is null or pCOL->m_punk = punk
	if (pCOL != NULL)
	{
		if (pCOLPrev == NULL) m_pFirstObj = pCOL->m_pNext;
		else pCOLPrev->m_pNext = pCOL->m_pNext;
		delete pCOL;
		noError;
	}
	return ResultFromScode(MK_E_NOTBOUND);
}




STDMETHODIMP CBindCtx::ReleaseBoundObjects(THIS)
{
	M_PROLOG(this);
	CObjList FAR * pCOL = m_pFirstObj;
	CObjList FAR * pCOLNext = NULL;
	m_pFirstObj = NULL;
	while (pCOL != NULL)
	{
		pCOLNext = pCOL->m_pNext;
		delete pCOL;		//	calls Release on the object
		pCOL = pCOLNext;
	}
	noError;
}

STDMETHODIMP CBindCtx::SetBindOptions (LPBIND_OPTS pbindopts)
{
    HRESULT hr;

    __try
    {
	if (pbindopts->cbStruct <= sizeof(m_bindopts))
	{
            //Set the bind options.
	    memcpy(&m_bindopts, pbindopts, (size_t)(pbindopts->cbStruct));
            hr = S_OK;
        }
        else
        {
            //pbindopts is too large.
            hr = E_INVALIDARG;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //An exception occurred, probably because of a bad parameter.
        hr = E_INVALIDARG;
    }

    Assert(m_bindopts.cbStruct <= sizeof(m_bindopts));
    return hr;
}


STDMETHODIMP CBindCtx::GetBindOptions (LPBIND_OPTS pbindopts)
{
    HRESULT hr;
    ULONG cbDest;

    Assert(m_bindopts.cbStruct <= sizeof(m_bindopts));

    __try
    {
        cbDest = pbindopts->cbStruct;
	if(m_bindopts.cbStruct <= cbDest)
        {
            memcpy(pbindopts, &m_bindopts, m_bindopts.cbStruct);
        }
        else
        {
            BIND_OPTS2 bindopts = m_bindopts;
            bindopts.cbStruct = cbDest;
            memcpy(pbindopts, &bindopts, cbDest);
        }
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //An exception occurred, probably because of a bad parameter.
        hr = E_INVALIDARG;
    }

    return hr;
}



STDMETHODIMP CBindCtx::GetRunningObjectTable (THIS_ LPRUNNINGOBJECTTABLE  FAR*
	pprot)
{
	M_PROLOG(this);
	VDATEPTROUT(pprot, LPRUNNINGOBJECTTABLE);
	return ::GetRunningObjectTable(0, pprot);
}

//+-------------------------------------------------------------------------
//
//  Member:     CBindCtx::RegisterObjectParam
//
//  Synopsis:   Registers object with key
//
//  Effects:    Adds object to bind context
//
//  Arguments:  [lpszKey] -- registration key
//              [punk]    -- object
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  Derivation: IBindContext
//
//  Algorithm:
//
//  History:    03-Jun-94 AlexT     Added header block;  release previous
//                                  object (if it exists)
//
//  Notes:      This function is not multithread safe!
//
//--------------------------------------------------------------------------

STDMETHODIMP CBindCtx::RegisterObjectParam (THIS_ LPWSTR lpszKey, LPUNKNOWN punk)
{
    M_PROLOG(this);
    VDATEPTRIN(lpszKey, WCHAR);
    VDATEIFACE(punk);

    if (m_pMap == NULL)
    {
        //  We don't have a map yet;  allocate one
        m_pMap = new CMapStringToPtr();
        if (NULL == m_pMap)
        {
            return ResultFromScode(E_OUTOFMEMORY);
        }
    }
    else
    {
        LPVOID pv = NULL;

        //  We already have a map;  if we have an existing entry for this
        //  key we release it here (we don't remove the key because we're
        //  about to assign a new value with the same key below

        if (m_pMap->Lookup(lpszKey, pv))
        {
    		if(pv)
    		    ((LPUNKNOWN)pv)->Release();
        }
    }

    //  SetAt is guaranteed not to fail if lpszKey is already in the map

    if (m_pMap->SetAt(lpszKey, (LPVOID&)punk))
    {
        punk->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_OUTOFMEMORY);
}


STDMETHODIMP CBindCtx::GetObjectParam (THIS_ LPWSTR lpszKey, LPUNKNOWN FAR* ppunk)
{
	M_PROLOG(this);
	VDATEPTROUT(ppunk, LPUNKNOWN);
	*ppunk = NULL;
	VDATEPTRIN(lpszKey, WCHAR);

	LPVOID pNewValue = (LPVOID)(*ppunk);
	
	if (m_pMap != NULL && m_pMap->Lookup(lpszKey, pNewValue))
	{
		*ppunk = (LPUNKNOWN)pNewValue;
        (*ppunk)->AddRef();
		return NOERROR;
	}

	return ResultFromScode(E_FAIL);
}


STDMETHODIMP CBindCtx::EnumObjectParam
(THIS_ LPENUMSTRING FAR* ppenum)
{
	M_PROLOG(this);
	VDATEPTROUT(ppenum, LPENUMSTRING);

#ifdef NOTYET
	*ppenum = new CEnumStringImpl( m_pMap );
	if (*ppenum == NULL) return ResultFromScode(E_OUTOFMEMORY);
		return NOERROR;
#else
	*ppenum = NULL;
	return ResultFromScode(E_NOTIMPL);
#endif
}


STDMETHODIMP CBindCtx::RevokeObjectParam
(THIS_ LPWSTR lpszKey)
{
	M_PROLOG(this);
	VDATEPTRIN(lpszKey, WCHAR);
    LPVOID lpvoid = NULL;

	if (m_pMap != NULL
        && (m_pMap->Lookup(lpszKey, lpvoid))
        && m_pMap->RemoveKey(lpszKey))
        {
    		if(lpvoid)
                ((LPUNKNOWN)lpvoid)->Release();
    		return NOERROR;
        }

	return ResultFromScode(E_FAIL);
}





#ifdef _DEBUG
STDMETHODIMP_(void) NC(CBindCtx,CDebug)::Dump( IDebugStream FAR * pdbstm)
{
	VOID_VDATEIFACE(pdbstm);
	
	NC(CBindCtx,CObjList) FAR * pCOL;

	*pdbstm << "CBindCtx @" << (VOID FAR *)m_pBindCtx <<'\n';
	pdbstm->Indent();
	*pdbstm << "m_BindCtx is " << (VOID FAR *)&(m_pBindCtx)<<'\n';
	*pdbstm << "Refcount is " << (int)(m_pBindCtx->m_refs) << '\n';
	*pdbstm << "Registered objects: \n";
	pdbstm->Indent();
	for (pCOL = m_pBindCtx->m_pFirstObj; pCOL; pCOL = pCOL->m_pNext )
		*pdbstm << (pCOL->m_punk);

	pdbstm->UnIndent();
	*pdbstm<<"End of registered objects \n";
	pdbstm->UnIndent();
}


STDMETHODIMP_(BOOL) NC(CBindCtx,CDebug)::IsValid( BOOL fSuspicious )
{
	return ((LONG)(m_pBindCtx->m_refs) > 0);
	//	add more later, maybe
}
#endif // _DEBUG


#ifdef NOTYET

NOTE: this code has to be fixed before used again: the ctor should
really fail if not enough memory is available and the next function
should copy the strings.  An alternative implementation might be wise.

#pragma SEG(CEnumStringImpl_ctor)
CEnumStringImpl::CEnumStringImpl( CMapStringToPtr FAR * pMap )
{
	LPWSTR lpsz;
	LPWSTR lpszKey;
	LPVOID lpvoid;
	size_t n;
	LI FAR * pli;

	POSITION pos = pMap->GetStartPosition();
	pliHead = NULL;
	while (pos != NULL)
	{
		pMap->GetNextAssoc(pos, lpszKey, lpvoid );
		lpsz = new FAR WCHAR[n = (1+_fstrlen(lpszKey))];
		if (lpsz == NULL)
			continue;

		memcpy(lpsz, lpszKey, n * sizeof(WCHAR));
		pli = new LI( lpsz );
		if (pli)
		{
			pli->pliNext = pliHead;
			pliHead = pli;
		}
	}
	pliCurrent = pliHead;
    m_refs = 1;
}



#pragma SEG(CEnumStringImpl_dtor)
CEnumStringImpl::~CEnumStringImpl( void )
{
	LI FAR * pli = pliHead;
	while (pli)
	{
		pliHead = pli->pliNext;
		delete pli->lpszKey;
		delete pli;
		pli = pliHead;
	}
}

#pragma SEG(CEnumStringImpl_Next)
STDMETHODIMP CEnumStringImpl::Next (ULONG celt,
		       LPWSTR FAR* reelt,
                       ULONG FAR* pceltFetched)
{
	ULONG celtTemp = 0;
	while (celtTemp < celt && pliCurrent)
	{
		reelt[celtTemp++] = pliCurrent->lpszKey;
		pliCurrent = pliCurrent->pliNext;
	}
	if (pceltFetched) *pceltFetched = celtTemp;
	return celtTemp == celt ? NOERROR : ResultFromScode(S_FALSE);
}


#pragma SEG(CEnumStringImpl_Skip)
STDMETHODIMP CEnumStringImpl::Skip (ULONG celt)
{
	ULONG celtTemp = 0;
	while (celtTemp < celt && pliCurrent)
		pliCurrent = pliCurrent->pliNext;
	return celtTemp == celt ? NOERROR : ResultFromScode(S_FALSE);
}


#pragma SEG(CEnumStringImpl_Reset)
STDMETHODIMP CEnumStringImpl::Reset (void)
{
	pliCurrent = pliHead;
	return NOERROR;
}


#pragma SEG(CEnumStringImpl_Clone)
STDMETHODIMP CEnumStringImpl::Clone (LPENUMSTRING FAR* ppenm)
{
	//	REVIEW :  to be implemented
	VDATEPTROUT(ppenm, LPENUMSTRING);
	*ppenm = NULL;
	return ResultFromScode(E_NOTIMPL);
}
#endif // NOTYET
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\cfilemon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       cfilemon.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-27-93   ErikGav   Commented
//                      01-04-94   KevinRo   Serious modifications
//                                                   UNC paths are used directly
//                                                   Added UNICODE extents
//              03-18-94   BruceMa   #5345 Fixed Matches to parse
//                                    offset correctly
//              03-18-94   BruceMa   #5346 Fixed error return on invalid CLSID
//                                    string
//              05-10-94   KevinRo   Added Long Filename/8.3 support so
//                                                   downlevel guys can see new files
//                      06-14-94   Rickhi    Fix type casting
//              22-Feb-95  BruceMa   Account for OEM vs. ANSI code pages
//              01-15-95   BillMo    Add tracking on x86 Windows.
//              19-Sep-95  BruceMa   Change ::ParseDisplayName to try the
//                                    object first and then the class
//              10-13-95   stevebl   threadsafety
//              10-20-95   MikeHill  Updated to support new CreateFileMonikerEx API.
//              11-15-95   MikeHill  Use BIND_OPTS2 when Resolving a ShellLink object.
//              11-22-95   MikeHill  - In ResolveShellLink, always check for a null path
//                                     returned from IShellLink::Resolve.
//                                   - Also changed m_fPathSetInShellLink to
//                                     m_fShellLinkInitialized.
//                                   - In RestoreShellLink & SetPathShellLink,
//                                     only early-exit if m_fShellLinkInitialized.
//              12-01-95   MikeHill  - Validate bind_opts2.dwTrackFlags before using it.
//                                   - For Cairo, do an unconditional ResolveShellLink
//                                     for BindToObject/Storage
//                                   - Don't do a Resolve in GetTimeOfLastChange.
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "extents.hxx"
#include "cfilemon.hxx"
#include "ccompmon.hxx"
#include "cantimon.hxx"
#include "mnk.h"
#include <olepfn.hxx>
#include <rotdata.hxx>

#ifdef _TRACKLINK_
#include <itrkmnk.hxx>
#endif

#define LPSTGSECURITY LPSECURITY_ATTRIBUTES
#include "..\..\..\stg\h\dfentry.hxx"


DECLARE_INFOLEVEL(mnk)

//
// The following value is used to determine the average string size for use
// in optimizations, such as copying strings to the stack.
//

#define AVERAGE_STR_SIZE (MAX_PATH)

//
// Determine an upper limit on the length of a path. This is a sanity check
// so that we don't end up reading in megabyte long paths. The 16 bit code
// used to use INT_MAX, which is 32767. That is reasonable, plus old code
// will still work.
//

#define MAX_MBS_PATH (32767)

// function prototype

// Special function from ROT
HRESULT GetObjectFromLocalRot(
    IMoniker *pmk,
    IUnknown **ppvUnk);

//+---------------------------------------------------------------------------
//
//  Function:   ReadAnsiStringStream
//
//  Synopsis:   Reads a counted ANSI string from the stream.
//
//  Effects:    Old monikers store paths in ANSI characters. This routine
//              reads ANSI strings.
//
//
//  Arguments:  [pStm] --    Stream to read from
//              [pszAnsiPath] -- Reference to the path variable.
//              [cbAnsiPath] -- Reference to number of bytes read
//
//  Requires:
//
//  Returns:
//              pszAnsiPath was allocated using PrivMemAlloc. May return NULL
//              if there were zero bytes written.
//
//              cbAnsiPath is the total size of the buffer allocated
//
//              This routine treats the string as a blob. There may be more
//              than one NULL character (ItemMonikers, for example, append
//              UNICODE strings to the end of existing strings.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT ReadAnsiStringStream( IStream *pStm,
                              LPSTR & pszAnsiPath,
                              USHORT &cbAnsiPath)
{
    HRESULT hresult;

    pszAnsiPath = NULL;
    ULONG cbAnsiPathTmp;

    cbAnsiPath = 0;

    hresult = StRead(pStm, &cbAnsiPathTmp, sizeof(ULONG));

    if (FAILED(hresult))
    {
        return hresult;
    }

    //
    // If no bytes exist in the stream, thats OK.
    //
    if (cbAnsiPathTmp == 0)
    {
        return NOERROR;
    }

    //
    // Quick sanity check against the size of the string
    //
    if (cbAnsiPathTmp > MAX_MBS_PATH)
    {
        //
        // String length didn't make sense.
        //
        return E_UNSPEC;
    }

    cbAnsiPath = (USHORT) cbAnsiPathTmp;

    //
    // This string is read in as char's.
    //
    // NOTE: cb includes the null terminator. Therefore, we don't add
    // extra room. Also, the read in string is complete. No additional
    // work needed.
    //

    pszAnsiPath = (char *)PrivMemAlloc(cbAnsiPath);

    if (pszAnsiPath == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    hresult = StRead(pStm, pszAnsiPath, cbAnsiPath);

    if (FAILED(hresult))
    {
        goto errRtn;
    }

    return NOERROR;

errRtn:
    if (pszAnsiPath != NULL)
    {
        PrivMemFree( pszAnsiPath);
        pszAnsiPath = NULL;
    }
    cbAnsiPath = 0;

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteAnsiStringStream
//
//  Synopsis:   Writes a counted ANSI string to the stream.
//
//  Effects:    Old monikers store paths in ANSI characters. This routine
//              writes ANSI strings.
//
//  Arguments:  [pStm] --       Stream to serialize to
//              [pszAnsiPath] --        AnsiPath to serialize
//              [cbAnsiPath] -- Count of bytes in ANSI path
//
//  Requires:
//
//      cbAnsiPath is the length of the cbAnsiPath buffer, INCLUDING the
//      terminating NULL.
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT WriteAnsiStringStream( IStream *pStm, LPSTR pszAnsiPath ,ULONG cbAnsiPath)
{
    HRESULT hr;
    ULONG cb = 0;

    // The >= is because there may be an appended unicode string
    Assert( (pszAnsiPath == NULL) || (cbAnsiPath >= strlen(pszAnsiPath)+1) );

    if (pszAnsiPath != NULL)
    {
        cb = cbAnsiPath;

        //
        // We don't allow the write of arbitrary length strings, since
        // we won't be able to read them back in.
        //

        if (cb > MAX_MBS_PATH)
        {
            Assert(!"Attempt to write cbAnsiPath > MAX_MBS_PATH" );
            return(E_UNSPEC);
        }

        //
        // Optimization for the write
        // if possible, do a single write instead of two by using a temp
        // buffer.

        if (cb <= AVERAGE_STR_SIZE-4)
        {
            char szBuf[AVERAGE_STR_SIZE];

            *((ULONG FAR*) szBuf) = cb;

            //
            // cb is the string length including the NULL. A memcpy is
            // used instead of a strcpy
            //

            memcpy(szBuf+sizeof(ULONG), pszAnsiPath, cb);

            hr = pStm->Write((VOID FAR *)szBuf, cb+sizeof(ULONG), NULL);

            return hr;
        }
    }

    if (hr = pStm->Write((VOID FAR *)&cb, sizeof(ULONG), NULL))
    {
        return hr;
    }

    if (pszAnsiPath == NULL)
    {
        hr =  NOERROR;
    }
    else
    {
        hr = pStm->Write((VOID FAR *)pszAnsiPath, cb, NULL);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CopyPathFromUnicodeExtent
//
//  Synopsis:   Given a path to a UNICODE moniker extent, return the path and
//              its length.
//
//  Effects:
//
//  Arguments:  [pExtent] --
//              [ppPath] --
//              [cbPath] --
//
//  Requires:
//
//  Returns:    ppPath is a copy of the string (NULL terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//  m_szPath should be freed using PrivMemFree();
//
//----------------------------------------------------------------------------
HRESULT
CopyPathFromUnicodeExtent(MONIKEREXTENT UNALIGNED *pExtent,
                          LPWSTR & pwcsPath,
                          USHORT & ccPath)
{

    //
    // The path isn't NULL terminated in the serialized format. Add enough
    // to have NULL termination.
    //

    pwcsPath =(WCHAR *)PrivMemAlloc(pExtent->cbExtentBytes + sizeof(WCHAR));

    if (pwcsPath == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    memcpy(pwcsPath,pExtent->achExtentBytes,pExtent->cbExtentBytes);

    //
    // The length divided by the size of the character yields the count
    // of characters.
    //

    ccPath = ((USHORT)(pExtent->cbExtentBytes)) / sizeof(WCHAR);

    //
    // NULL terminate the string.
    //

    pwcsPath[ccPath] = 0;

    return(NOERROR);

}

//+---------------------------------------------------------------------------
//
//  Function:   CopyPathToUnicodeExtent
//
//  Synopsis:   Given a UNICODE path and a length, return a MONIKEREXTENT
//
//  Effects:
//
//  Arguments:  [pwcsPath] --   UNICODE string to put in extent
//              [ccPath] --     Count of unicode characters
//              [pExtent] --    Pointer reference to recieve buffer
//
//  Requires:
//
//  Returns:
//              pExtent allocated using PrivMemAlloc
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-09-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CopyPathToUnicodeExtent(LPWSTR pwcsPath,ULONG ccPath,LPMONIKEREXTENT &pExtent)
{
    pExtent = (LPMONIKEREXTENT)PrivMemAlloc(MONIKEREXTENT_HEADERSIZE +
                                            (ccPath * sizeof(WCHAR)));

    if (pExtent == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    pExtent->cbExtentBytes = ccPath * sizeof(WCHAR);
    pExtent->usKeyValue = mnk_UNICODE;
    memcpy(pExtent->achExtentBytes,pwcsPath,ccPath*sizeof(WCHAR));

    return(NOERROR);
}


INTERNAL_(DWORD) GetMonikerType ( LPMONIKER pmk )
{
    GEN_VDATEIFACE (pmk, 0);

    DWORD dw;

    CBaseMoniker FAR* pbasemk;

    if (NOERROR == pmk->QueryInterface(IID_IInternalMoniker,(LPVOID FAR*)&pbasemk))
    {
        pbasemk->IsSystemMoniker(&dw);
        ((IMoniker *) pbasemk)->Release();
        return dw;
    }

    return 0;
}


INTERNAL_(BOOL) IsReduced ( LPMONIKER pmk )
{
    DWORD dw = GetMonikerType(pmk);
    if (dw != 0)
    {
        CCompositeMoniker *pCMk;
        if ((pCMk = IsCompositeMoniker(pmk)) != NULL)
        {
            return pCMk->m_fReduced;
        }
        else
        {
            return TRUE;
        }
    }
    return FALSE;
}


INTERNAL_(CFileMoniker *) IsFileMoniker ( LPMONIKER pmk )
{
    CFileMoniker *pCFM;

    if ((pmk->QueryInterface(CLSID_FileMoniker, (void **)&pCFM)) == S_OK)
    {
        // we release the AddRef done by QI, but still return the ptr.
        pCFM->Release();
        return pCFM;
    }

    //  dont rely on user implementations to set pCFM NULL on failed QI
    return NULL;
}

/*
 *  Implementation of CFileMoniker
 *
 *
 *
 *
 */



//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::CFileMoniker
//
//  Synopsis:   Constructor for CFileMoniker
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-09-94   kevinro   Modified
//
//  Notes:
//
//----------------------------------------------------------------------------
CFileMoniker::CFileMoniker( void ) CONSTR_DEBUG
{
#ifdef _TRACKLINK_
    _tfm.SetParent(this);
#endif

    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::CFileMoniker(%x)\n",this));

    m_szPath = NULL;
    m_ccPath = 0;
    m_pszAnsiPath = NULL;
    m_cbAnsiPath = 0;
    m_cAnti = 0;

    m_ole1 = undetermined;
    m_clsid = CLSID_NULL;

    m_fClassVerified = FALSE;
    m_fUnicodeExtent = FALSE;
    m_fHashValueValid = FALSE;
    m_dwHashValue = 0x12345678;

    m_endServer = DEF_ENDSERVER;

#ifdef _TRACKLINK_
    m_pShellLink = NULL;
    m_fTrackingEnabled = FALSE;
    m_fSaveShellLink = FALSE;
    m_fReduceEnabled = FALSE;
    m_fDirty = FALSE;
    m_fShellLinkInitialized = FALSE;  // Has IShellLink->SetPath been called?
#ifdef _CAIRO_
    m_pShellLinkTracker = NULL;
#endif // _CAIRO_
#endif // _TRACKLINK_

    //
    // CoQueryReleaseObject needs to have the address of the this objects
    // query interface routine.
    //
    if (adwQueryInterfaceTable[QI_TABLE_CFileMoniker] == 0)
    {
        adwQueryInterfaceTable[QI_TABLE_CFileMoniker] =
            **(DWORD **)((IMoniker *)this);
    }

    wValidateMoniker();
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::ValidateMoniker
//
//  Synopsis:   As a debugging routine, this will validate the contents
//              as VALID
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-12-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#if DBG == 1

void 
CFileMoniker::ValidateMoniker()
{
    CLock2 lck(m_mxs);   // protect all internal state
    wValidateMoniker();
}

void
CFileMoniker::wValidateMoniker()
{
    //
    // A valid moniker should have character counts set correctly
    // m_ccPath holds the number of characters in m_szPath
    //
    if (m_szPath != NULL)
    {
        Assert(m_ccPath == lstrlenW(m_szPath));

        Assert((m_endServer == DEF_ENDSERVER) || (m_endServer <= m_ccPath));
    }
    else
    {
        Assert(m_ccPath == 0);
        Assert(m_endServer == DEF_ENDSERVER);
    }

    //
    // If the ANSI version of the path already exists, then validate that
    // its buffer length is the same as its strlen
    //
    if (m_pszAnsiPath != NULL)
    {
        Assert(m_cbAnsiPath == strlen(m_pszAnsiPath) + 1);
    }
    else
    {
        Assert(m_cbAnsiPath == 0);
    }

    //
    // There is a very very remote chance that this might fail when it
    // shouldn't. If it happens, congratulations, you win!
    //
    if (!m_fHashValueValid)
    {
        Assert(m_dwHashValue == 0x12345678);
    }

    //
    // If there is an extent, then we would be very surprised to see it
    // have a zero size.
    //
    if (m_fUnicodeExtent)
    {
        Assert(m_ExtentList.GetSize() >= sizeof(ULONG));
    }

}

#endif




//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::~CFileMoniker
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-09-94   kevinro   Modified
//
//  Notes:
//
//----------------------------------------------------------------------------
CFileMoniker::~CFileMoniker( void )
{
    // no locking needed here, since we are going away, and nobody should
    // have any references to us.
    wValidateMoniker();

    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::~CFileMoniker(%x) m_szPath(%ws)\n",
                 this,
                 m_szPath?m_szPath:L"<No Path>"));

    if( m_szPath != NULL)
    {
        PrivMemFree(m_szPath);
    }
    if (m_pszAnsiPath != NULL)
    {
        PrivMemFree(m_pszAnsiPath);
    }
#ifdef _TRACKLINK_
    if (m_pShellLink != NULL)
    {
        m_pShellLink->Release();
    }
#ifdef _CAIRO_
    if (m_pShellLinkTracker != NULL)
    {
        m_pShellLinkTracker->Release();
    }
#endif // _CAIRO_
#endif // _TRACKLINK_
}


void UpdateClsid (LPCLSID pclsid)
{

        CLSID clsidNew = CLSID_NULL;

        // If a class has been upgraded, we want to use
        // the new class as the server for the link.
        // The old class's server may no longer exist on
        // the machine.  See Bug 4147.

        if (NOERROR == OleGetAutoConvert (*pclsid, &clsidNew))
        {
                *pclsid = clsidNew;
        }
        else if (NOERROR == CoGetTreatAsClass (*pclsid, &clsidNew))
        {
                *pclsid = clsidNew;
        }
}

/*
When IsOle1Class determines that the moniker should now be an OLE2 moniker
and sets m_ole1 = ole2, it does NOT set m_clsid to CLSID_NULL.
This is intentional.  This ensures that when GetClassFileEx is called, it
will be called with this CLSID.  This allows BindToObject, after calling
GetClassFileEx,  to map the 1.0 CLSID, via UpdateClsid(), to the correct
2.0 CLSID.  If m_clsid was NULLed, GetClassFileEx would have no
way to determine the 1.0 CLSID (unless pattern matching worked).

Note that this means that the moniker may have m_ole1==ole2 and
m_clsid!=CLSID_NULL.  This may seem a little strange but is intentional.
The moniker is persistently saved this way, which is also intentional.
*/


INTERNAL_(BOOL) CFileMoniker::IsOle1Class ( LPCLSID pclsid )
{
    wValidateMoniker();
    {
        if (m_fClassVerified)
        {
            if (m_ole1 == ole1)
            {
                *pclsid = m_clsid;
                return TRUE;
            }
            if (m_ole1 == ole2)
            {
                return FALSE;
            }
        }
        //
        // If GetClassFileEx fails, then we have not really
        // verified the class. m_ole1 remains 'undetermined'
        //

        m_fClassVerified = TRUE;

        HRESULT hr = GetClassFileEx (m_szPath, pclsid, m_clsid);

        if (NOERROR== hr)
        {
                UpdateClsid (pclsid);
                if (CoIsOle1Class(*pclsid))
                {
                    m_clsid = *pclsid;
                    m_ole1 = ole1;
                    return TRUE;
                }
                else
                {
                    m_ole1 = ole2;
                    // Do not set m_clsid to CLSID_NULL.  See note above.
                }
        }
        return m_ole1==ole1;
    }

}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::GetShellLink, private
//
//  Synopsis:   Ensure that m_pShellLink is valid, or return error.
//
//  Arguments:  [void]
//
//  Algorithm:  if m_pShellLink is already valid return S_OK, else
//              sort of CoCreateInstance a shell link using the routine
//              OleGetShellLink in com\util\dynload.cxx.
//
//  Notes:
//
//----------------------------------------------------------------------------

#ifdef _TRACKLINK_
extern VOID * OleGetShellLink();

INTERNAL CFileMoniker::GetShellLink()
{
    if (m_pShellLink == NULL)
        m_pShellLink = (IShellLink*) OleGetShellLink();

    return(m_pShellLink != NULL ? S_OK : E_FAIL);
}
#endif




//+-------------------------------------------------------------------
//
//  Member:     CFileMoniker::EnableTracking
//
//  Synopsis:   Creates/destroys the information neccessary to
//              track objects on BindToObject calls.
//
//  Arguments:  [pmkToLeft] -- moniker to left.
//
//              [ulFlags] -- flags to control behaviour of tracking
//                           extensions.
//
//              Combination of:
//                  OT_READTRACKINGINFO -- get id from source
//                  OT_ENABLESAVE -- enable tracker to be saved in
//                                   extents.
//                  OT_DISABLESAVE -- disable tracker to be saved.
//                  OT_DISABLETRACKING -- destroy any tracking info
//                                    and prevent tracking and save of
//                                    tracking info.
//
//                  OT_DISABLESAVE takes priority of OT_ENABLESAVE
//                  OT_READTRACKINGINFO takes priority over
//                          OT_DISABLETRACKING
//
//                  OT_ENABLEREDUCE -- enable new reduce functionality
//                  OT_DISABLEREDUCE -- disable new reduce functionality
//
//                  OT_MAKETRACKING -- make the moniker inherently tracking;
//                          then tracking need not be enabled, and cannot be disabled.
//
//  Returns:    HResult
//              Success is SUCCEEDED(hr)
//
//  Modifies:
//
//--------------------------------------------------------------------

#ifdef _TRACKLINK_
STDMETHODIMP CFileMoniker::EnableTracking(IMoniker *pmkToLeft, ULONG ulFlags)
{

    //
    // - if the shellink does not exist, and shellink creation has not
    //   been disabled by the OLELINK (using private i/f ITrackingMoniker)
    //   then create one and save in extent list.  (The EnabledTracking(FALSE)
    //   call prevents the file moniker from creating the shellink on save.)
    // - if the shellink exists, update the ShellLink in the extent list
    //

    CLock2 lck(m_mxs);   // protect all internal state

    //
    // create an in memory shell link object if needed.
    //

    HRESULT hr = S_OK;


    if (ulFlags & OT_ENABLESAVE)
    {
        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::EnableTracking() -- enable save\n",
                     this));

        m_fSaveShellLink = TRUE;
    }

    if (ulFlags & OT_DISABLESAVE)
    {
        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::EnableTracking() -- disable save\n",
                     this));

        m_fSaveShellLink = FALSE;
    }

    if (ulFlags & OT_ENABLEREDUCE)
    {
        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::EnableTracking() -- enable reduce\n",
                     this));

        m_fReduceEnabled = TRUE;
    }

    if (ulFlags & OT_DISABLEREDUCE)
    {
        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::EnableTracking() -- disable reduce\n",
                     this));

        m_fReduceEnabled = FALSE;
    }


    if (ulFlags & OT_READTRACKINGINFO)
    {
        BOOL fExtentNotFound = FALSE;

        // Load the shell link, if it's not already.

        hr = RestoreShellLink( &fExtentNotFound );

        if( SUCCEEDED(hr) || fExtentNotFound )
        {
            // Either the shell link was successfully restored, or
            // it failed because we didn't have it saved away in the
            // extent.  In either case we can create/update the shell link.
            // 
            // If we've ever gotten the shell link set up in the past, do
            // a refresh-type resolve on it.  Otherwise, do a SetPath.

            if( m_fShellLinkInitialized )
                hr = ResolveShellLink( TRUE ); // fRefreshOnly
            else
                hr = SetPathShellLink();
        }

        if( FAILED( hr ))
        {
            if( m_pShellLink )
            {
                m_pShellLink->Release();
                m_pShellLink = NULL;
                m_fShellLinkInitialized = FALSE;
            }

            mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::EnableTracking(%ls) -- m_pShellLink->SetPath failed %08X.\n",
                     this,
                     m_szPath,
                     hr));

        }   // ShellLink->SetPath ... if (FAILED(hr))
        else
        {
            m_fTrackingEnabled = TRUE;
            hr = S_OK;
        }
    }   // if (ulFlags & OT_READTRACKINGINFO)

    else
    if (ulFlags & OT_DISABLETRACKING)
    {
        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::EnableTracking() -- disabletracking\n",
                     this));

        // If this is a tracking moniker, the Shell Link cannot
        // be deleted.

        if (m_pShellLink != NULL)
            m_pShellLink->Release();
        m_pShellLink = NULL;
        m_fShellLinkInitialized = FALSE;
        
        m_ExtentList.DeleteExtent(mnk_ShellLink);

        m_fSaveShellLink = FALSE;
        m_fTrackingEnabled = FALSE;
    }   // else if (ulFlags & OT_DISABLETRACKING)


    return(hr);
}

#endif

/*
 *  Storage of paths in file monikers:
 *
 *  A separate unsigned integer holds the count of .. at the
 *  beginning of the path, so the canononical form of a file
 *  moniker contains this count and the "path" described above,
 *  which will not contain "..\" or ".\".
 *
 *  It is considered an error for a path to contain ..\ anywhere
 *  but at the beginning.  I assume that these will be taken out by
 *  ParseUserName.
 */



inline BOOL IsSeparator( WCHAR ch )
{
    return (ch == L'\\' || ch == L'/' || ch == L':');
}

#ifdef MAC_REVIEW
Needs to be mac'ifyed
#endif


//+---------------------------------------------------------------------------
//
//  Function:   EatDotDDots
//
//  Synopsis:   Remove directory prefixes
//
//  Effects:
//      Removes and counts the number of 'dot dots' on a path. It also
//      removes the case where the leading characters are '.\', which
//      is the 'current' directory.
//
//  Arguments:  [pch] --
//              [cDoubleDots] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-02-94   kevinro   Commented
//              3-21-95   kevinro   Fixed case where path is ..foo
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL EatDotDots ( LPCWSTR *ppch, USHORT FAR *pcDoubleDots )
{
    //  passes over ..'s (or ..\'s at the beginning of paths, and returns
    //  an integer counting the ..

    LPWSTR pch = (LPWSTR) *ppch;

    if (pch == NULL)
    {
        //
        // NULL paths are alright
        //
        return(TRUE);
    }

    while (pch[0] == L'.')
    {
        //
        // If the next character is a dot, the consume both, plus any
        // seperator
        //

        if (pch[1] == L'.')
        {

            //
            // If the next character is a seperator, then remove it also
            // This handles the '..\' case.
            //

            if (IsSeparator(pch[2]))
            {
                pch += 3;
                (*pcDoubleDots)++;
            }
            //
            // If the next char is a NULL, then eat it and count a dotdot.
            // This handles the '..' case where we want the parent directory
            //
            else if(pch[2] == 0)
            {
                pch += 2;
                (*pcDoubleDots)++;
            }
            //
            // Otherwise, we just found a '..foobar', which is a valid name.
            // We can stop processing the string all together and be done.
            //
            else
            {
                break;
            }

        }
        else if (IsSeparator(pch[1]))
        {
            //
            // Found a .\ construct, eat the dot and the seperator
            //
            pch += 2;
        }
        else
        {
            //
            // There is a dot at the start of the name. This is valid,
            // since many file systems allow names to start with dots
            //
            break;
        }
    }

    *ppch = pch;
    return TRUE;
}



int CountSegments ( LPWSTR pch )
{
    //  counts the number of pieces in a path, after the first colon, if
    //  there is one

    int n = 0;
    LPWSTR pch1;
    pch1 = pch;
    while (*pch1 != L'\0' && *pch1 != L':') IncLpch(pch1);
    if (*pch1 == ':') pch = ++pch1;
    while (*pch != '\0')
    {
        while (*pch && IsSeparator(*pch)) pch++;
        if (*pch) n++;
        while (*pch && (!IsSeparator(*pch))) IncLpch(pch);
    }
    return n;
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::Initialize
//
//  Synopsis:  Initializes data members.
//
//  Effects:    This one stores the path, its length, and the AntiMoniker
//              count.
//
//  Arguments:  [cAnti] --
//              [pszAnsiPath] -- Ansi version of path. May be NULL
//              [cbAnsiPath] --  Number of bytes in pszAnsiPath buffer
//              [szPathName] --  Path. Takes control of memory
//              [ccPathName] --  Number of characters in Wide Path
//              [usEndServer] -- Offset to end of server section
//
//  Requires:
//      szPathName must be allocated by PrivMemAlloc();
//      This routine doesn't call EatDotDots. Therefore, the path should
//      not include any leading DotDots.
//
//  Returns:
//              TRUE    success
//              FALSE   failure
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Modified
//
//  Notes:
//
//      There is at least one case where Initialize is called with a pre
//      allocated string. This routine is called rather than the other.
//      Removes an extra memory allocation, and the extra string scan
//
//----------------------------------------------------------------------------
INTERNAL_(BOOL)
CFileMoniker::Initialize ( USHORT cAnti,
                           LPSTR  pszAnsiPath,
                           USHORT cbAnsiPath,
                           LPWSTR szPathName,
                           USHORT ccPathName,
                           USHORT usEndServer )


{
    wValidateMoniker();          // Be sure we started with something
                                // we expected

    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::Initialize(%x) szPathName(%ws)cAnti(%u) ccPathName(0x%x)\n",
                 this,
                 szPathName?szPathName:L"<NULL>",
                 cAnti,
                 ccPathName));

    mnkDebugOut((DEB_ITRACE,
                 "\tpszAnsiPath(%s) cbAnsiPath(0x%x) usEndServer(0x%x)\n",
                 pszAnsiPath?pszAnsiPath:"<NULL>",
                 cbAnsiPath,
                 usEndServer));

    Assert( (szPathName == NULL) || ccPathName == lstrlenW(szPathName) );
    Assert( (pszAnsiPath == NULL) || cbAnsiPath == strlen(pszAnsiPath) + 1);

    Assert( (usEndServer <= ccPathName) || (usEndServer == DEF_ENDSERVER) );


    if (m_mxs.FInit() == FALSE)
    	{
    	return FALSE;
    	}

    //
    // It is possible to get Initialized twice.
    // Be careful not to leak
    //

    if (m_szPath != NULL)
    {
        PrivMemFree(m_szPath); // OleLoadFromStream causes two inits
    }

    if (m_pszAnsiPath != NULL)
    {
        PrivMemFree(m_pszAnsiPath);
    }

    m_cAnti = cAnti;
    m_pszAnsiPath = pszAnsiPath;
    m_cbAnsiPath = cbAnsiPath;

    m_szPath = szPathName;
    m_ccPath = (USHORT)ccPathName;
    m_endServer = usEndServer;

    //
    // m_ole1 and m_clsid where loaded in 'Load'. Really should get moved
    // into here.
    //

    m_fClassVerified = FALSE;

    // m_fUnicodeExtent gets set in DetermineUnicodePath() routine, so
    // leave it alone here.

    //
    // We just loaded new strings. Hash value is no longer valid.
    //

    m_fHashValueValid = FALSE;
    m_dwHashValue = 0x12345678;

    //
    // Notice that the extents are not initialized.
    //
    // The two cases are:
    //  1) This is called as result of CreateFileMoniker, in which case
    //     no extents are created. The default constructor suffices.
    //
    //  2) This is called as result of ::Load(), in which case the extents
    //     have already been loaded.
    //

    wValidateMoniker();

    return(TRUE);

}
//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::Initialize
//
//  Synopsis:   This version of Initialize is called by CreateFileMoniker
//
//  Effects:
//
//  Arguments:  [cAnti] -- Anti moniker count
//              [szPathName] -- Unicode path name
//              [usEndServer] -- End of server section of UNC path
//
//  Requires:
//
//  Returns:
//              TRUE    success
//              FALSE   failure
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Modified
//
//  Notes:
//
//      Preprocesses the path, makes a copy of it, then calls the other
//      version of Initialize.
//
//----------------------------------------------------------------------------
INTERNAL_(BOOL)
CFileMoniker::Initialize ( USHORT cAnti,
                           LPCWSTR szPathName,
                           USHORT usEndServer )
{

    WCHAR const *pchSrc = szPathName;
    WCHAR *pwcsPath = NULL;
    USHORT ccPath;

    
    if (m_mxs.FInit() == FALSE) // If we can't init the critsec, bail
    	{
    	return FALSE;
    	}

    //
    // Adjust for leading '..'s
    //
    if (EatDotDots(&pchSrc, &cAnti) == FALSE)
    {
        return FALSE;
    }

    if (FAILED(DupWCHARString(pchSrc,pwcsPath,ccPath)))
    {
        return(FALSE);
    }

    //
    // Be sure we are creating a valid Win32 path. ccPath is the count of
    // characters. It needs to fit into a MAX_PATH buffer
    //

    if (ccPath >= MAX_PATH)
    {
        goto errRet;
    }

    if (Initialize(cAnti, NULL, 0, pwcsPath, ccPath, usEndServer) == FALSE)
    {
        goto errRet;
    }

    return(TRUE);

errRet:
    if (pwcsPath != NULL)
    {
        PrivMemFree(pwcsPath);
    }
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::Create
//
//  Synopsis:   Create function for file moniker
//
//  Effects:
//
//  Arguments:  [szPathName] -- Path to create with
//              [cbPathName] -- Count of characters in path
//              [memLoc] -- Memory context
//              [usEndServer] -- Offset to end of server name in path
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-11-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CFileMoniker FAR *
CFileMoniker::Create ( LPCWSTR          szPathName,
                       USHORT           cAnti ,
                       USHORT           usEndServer)

{

    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::Create szPath(%ws)\n",
                 szPathName?szPathName:L"<NULL PATH>"));

    CFileMoniker FAR * pCFM = new CFileMoniker();

    if (pCFM != NULL)
    {
        if (pCFM->Initialize( cAnti,
                              szPathName,
                              usEndServer))
        {
            return pCFM;
        }

        delete pCFM;
    }
    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Function:   FindExt
//
//  Synopsis:
//
//  Effects:
//      returns a pointer into szPath which points to the period (.) of the
//      extension; returns NULL if no such point exists.
//
//  Arguments:  [szPath] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPCWSTR FindExt ( LPCWSTR szPath )
{
    LPCWSTR sz = szPath;

    if (!sz)
    {
        return NULL;
    }

    sz += lstrlenW(szPath); // sz now points to the null at the end

    Assert(*sz == '\0');

    DecLpch(szPath, sz);

    while (*sz != '.' && *sz != '\\' && *sz != '/' && sz > szPath )
    {
        DecLpch(szPath, sz);
    }
    if (*sz != '.') return NULL;

    return sz;
}





STDMETHODIMP CFileMoniker::QueryInterface (THIS_ REFIID riid,
    LPVOID FAR* ppvObj)
{
    VDATEIID (riid);
    VDATEPTROUT(ppvObj, LPVOID);

#ifdef _DEBUG
    if (riid == IID_IDebug)
    {
        *ppvObj = &(m_Debug);
        return NOERROR;
    }
#endif

#ifdef _TRACKLINK_
    if (IsEqualIID(riid, IID_ITrackingMoniker))
    {
        AddRef();
        *ppvObj = (ITrackingMoniker *) &_tfm;
        return(S_OK);
    }
#endif
    if (IsEqualIID(riid, CLSID_FileMoniker))
    {
        //  called by IsFileMoniker.
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    return CBaseMoniker::QueryInterface(riid, ppvObj);
}


STDMETHODIMP CFileMoniker::GetClassID (LPCLSID lpClassId)
{
    VDATEPTROUT (lpClassId, CLSID);

    *lpClassId = CLSID_FileMoniker;

    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::Load
//
//  Synopsis:   Loads a moniker from a stream
//
//  Effects:
//
//  Arguments:  [pStm] -- Stream to load from
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-07-94   kevinro   Modified
//
//  Notes:
//
//  We have some unfortunate legacy code to deal with here. Previous monikers
//  saved their paths in ANSI instead of UNICODE. This was a very unfortunate
//  decision, since we now are forced to pull some tricks to support UNICODE
//  paths.
//
//  Specifically, there isn't always a translation between UNICODE and ANSI
//  characters. This means we may need to save a seperate copy of the UNCODE
//  string, if the mapping to ASCII fails.
//
//  The basic idea is the following:
//
//  The in memory representation is always UNICODE. The serialized form
//  will always attempt to be ANSI. If, while seralizing, the UNICODE path
//  to ANSI path conversion fails, then we will create an extent to save the
//  UNICODE version of the path. We will use whatever the ANSI path conversion
//  ended up with to store in the ANSI part of the stream, though it will not
//  be a good value. We will replace the non-converted characters with the
//  systems 'default' mapping character, as defined by WideCharToMultiByte()
//
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::Load (LPSTREAM pStm)
{
    CLock2 lck(m_mxs);   // protect all internal state during load operation

    wValidateMoniker();

    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::Load(%x)\n",
                 this));

    VDATEIFACE (pStm);

    HRESULT hresult;
    LPSTR szAnsiPath = NULL;
    USHORT cAnti;
    USHORT usEndServer;

    WCHAR *pwcsWidePath = NULL;
    USHORT ccWidePath = 0;      // Number of characters in UNICODE path

    ULONG cbExtents = 0;
    USHORT cbAnsiPath = 0;      // Number of bytes in path including NULL

#ifdef _CAIRO_

    //
    // If we're about to load from a stream, then our existing
    // state is now invalid.  There's no need to explicitely
    // re-initialize our persistent state, except for the
    // Shell Link object.  An existing ShellLink should be
    // deleted.
    //

    if( m_pShellLink )
        m_pShellLink->Release();
    m_pShellLink = NULL;
    m_fShellLinkInitialized = FALSE;

#endif // _CAIRO_


    //
    // The cAnti field was written out as a UINT in the original 16-bit code.
    // This has been changed to a USHORT, to preserve its 16 bit size.
    //

    hresult = StRead(pStm, &cAnti, sizeof(USHORT));

    if (hresult != NOERROR)
    {
        goto errRet;
    }

    //
    // The path string is stored in ANSI format.
    //

    hresult = ReadAnsiStringStream( pStm, szAnsiPath , cbAnsiPath );

    if (hresult != NOERROR)
    {
        goto errRet;
    }

    //
    // The first version of the moniker code only had a MAC alias field.
    // The second version used a cookie in m_cbMacAlias field to determine
    // if the moniker is a newer version.
    //

    hresult = StRead(pStm, &cbExtents, sizeof(DWORD));

    if (hresult != NOERROR)
    {
        goto errRet;
    }

    usEndServer = LOWORD(cbExtents);

    if (usEndServer== 0xBEEF) usEndServer = DEF_ENDSERVER;

    if (HIWORD(cbExtents) == 0xDEAD)
    {
        MonikerReadStruct ioStruct;

        hresult = StRead(pStm, &ioStruct, sizeof(ioStruct));

        if (hresult != NOERROR)
        {
            goto errRet;
        }

        m_clsid = ioStruct.m_clsid;
        m_ole1 = (enum CFileMoniker::olever) ioStruct.m_ole1;
        cbExtents = ioStruct.m_cbExtents;
    }
    //
    // If cbExtents is != 0, then there are extents to be read. Call
    // the member function of CExtentList to load them from stream.
    //
    // Having to pass cbExtents from this routine is ugly. But, we have
    // to since it is read in as part of the cookie check above.
    //
    if (cbExtents != 0)
    {
        hresult = m_ExtentList.Load(pStm,cbExtents);

#ifdef _TRACKLINK_

        if (hresult == S_OK)
        {
                m_fTrackingEnabled =
                    NULL != m_ExtentList.FindExtent(mnk_ShellLink);
                mnkDebugOut((DEB_TRACK,
                         "CFileMoniker(%x)::Load did%s find mnk_ShellLink extent, m_fTrackingEnabled=%d.\n",
                     this,
                     m_fTrackingEnabled ? "" : " not",
                     m_fTrackingEnabled));

#ifdef _CAIRO_
            }   // if( ... FindExtent( mnk_TrackingInformation )) ... else
#endif
        }   // hresult = m_ExtentList.Load(pStm,cbExtents) ... if (hresult == S_OK)

#endif  // _TRACKLINK_
    }   // if (cbExtents != 0)

    //
    // DetermineUnicodePath will handle the mbs to UNICODE conversions, and
    // will also check the Extents to determine if there is a
    // stored UNICODE path.
    //

    hresult = DetermineUnicodePath(szAnsiPath,pwcsWidePath,ccWidePath);

    if (FAILED(hresult))
    {
        goto errRet;
    }

    //
    // Initialize will take control of all path memory
    //

    if (Initialize( cAnti,
                    szAnsiPath,
                    cbAnsiPath,
                    pwcsWidePath,
                    ccWidePath,
                    usEndServer) == FALSE)
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRet;
    }

errRet:

    if (FAILED(hresult))
    {
        mnkDebugOut((DEB_ITRACE,
                     "::Load(%x) failed hr(%x)\n",
                     this,
                     hresult));

    }
    else
    {
        mnkDebugOut((DEB_ITRACE,
                     "::Load(%x) cAnti(%x) m_szPath(%ws) m_pszAnsiPath(%s)\n",
                     this,
                     cAnti,
                     m_szPath,
                     m_pszAnsiPath));
    }

    wValidateMoniker();

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::Save
//
//  Synopsis:   Save this moniker to stream.
//
//  Effects:
//
//  Arguments:  [pStm] -- Stream to save to
//              [fClearDirty] -- Dirty flag
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-07-94   kevinro   Modified
//
//  Notes:
//
//  It is unfortunate, but we may need to save two sets of paths in the
//  moniker. The shipped version of monikers saved paths as ASCII strings.
//
//  See the notes found in ::Load for more details
//
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::Save (LPSTREAM pStm, BOOL fClearDirty)
{
    CLock2 lck(m_mxs);   // protect all internal state during save operation

    wValidateMoniker();
    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::Save(%x)m_szPath(%ws)\n",
                 this,
                 m_szPath?m_szPath:L"<Null Path>"));

    M_PROLOG(this);

    VDATEIFACE (pStm);

    HRESULT hresult;
    UNREFERENCED(fClearDirty);
    ULONG cbWritten;

    //
    // We currently have a UNICODE string. Need to write out an
    // Ansi version.
    //

    hresult = ValidateAnsiPath();

    if (hresult != NOERROR) goto errRet;

    hresult = pStm->Write(&m_cAnti, sizeof(USHORT), &cbWritten);
    if (hresult != NOERROR) goto errRet;

    //
    // Write the ANSI version of the path.
    //

    hresult = WriteAnsiStringStream( pStm, m_pszAnsiPath, m_cbAnsiPath );
    if (hresult != NOERROR) goto errRet;

    //
    // Here we write out everything in a single blob
    //

    MonikerWriteStruct ioStruct;

    ioStruct.m_endServer = m_endServer;
    ioStruct.m_w = 0xDEAD;
    ioStruct.m_clsid = m_clsid;
    ioStruct.m_ole1 = m_ole1;


    hresult = pStm->Write(&ioStruct, sizeof(ioStruct), &cbWritten);

    if (hresult != NOERROR) goto errRet;

    Assert(cbWritten == sizeof(ioStruct));


#ifdef _TRACKLINK_

    mnkDebugOut((DEB_TRACK,
             "CFileMoniker(%x)::Save m_fSaveShellLink = %s, m_pShellLink=%08X.\n",
         this,
         m_fSaveShellLink ? "TRUE" : "FALSE",
         m_pShellLink));


    // If we have a ShellLink object, and either this is a tracking moniker
    // or we've been asked to save the ShellLink, then save it in a
    // Moniker Extent.

    if ( m_fSaveShellLink && m_pShellLink != NULL )
    {
        //
        // Here we are saving the shell link to a MONIKEREXTENT.
        // The basic idea here is to save the shell link to an in memory
        // stream (using CreateStreamOnHGlobal).  The format of the stream
        // is the same as a MONIKEREXTENT (i.e. has a MONIKEREXTENT at the
        // front of the stream.)
        //

        IPersistStream *pps = NULL;
        IStream * pstm = NULL;
        BOOL fOk;
        HRESULT hr;

        Verify(S_OK == m_pShellLink->QueryInterface(IID_IPersistStream, (void **) & pps));

        hr = CreateStreamOnHGlobal(NULL, // auto alloc
                TRUE, // delete on release
                &pstm);

        if (hr != S_OK)
        {
            mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::Save CreateStreamOnHGlobal failed %08X",
                 this,
                 hr));
            goto ExitShellLink;
        }

        //
        // We write out the MONIKEREXTENT header to the stream ...
        //

        MONIKEREXTENT me;
        MONIKEREXTENT *pExtent;

        me.cbExtentBytes = 0;
        me.usKeyValue = mnk_ShellLink;

        hr = pstm->Write(&me, MONIKEREXTENT_HEADERSIZE, NULL);
        if (hr != S_OK)
            goto ExitShellLink;

        // ... and then save the shell link
        hr = pps->Save(pstm, FALSE);

        if (hr != S_OK)
            goto ExitShellLink;

        // We then seek back and write the cbExtentList value.
        LARGE_INTEGER li0;
        ULARGE_INTEGER uli;

        memset(&li0, 0, sizeof(li0));

        Verify(S_OK == pstm->Seek(li0, STREAM_SEEK_END, &uli));

        me.cbExtentBytes = uli.LowPart - MONIKEREXTENT_HEADERSIZE;
        Verify(S_OK == pstm->Seek(li0, STREAM_SEEK_SET, &uli));
        Assert(uli.LowPart == 0 && uli.HighPart == 0);

        Verify(S_OK == pstm->Write(&me.cbExtentBytes, sizeof(me.cbExtentBytes), NULL));


        // Finally, we get access to the memory of the stream and
        // cast it to a MONIKEREXTENT to pass to PutExtent.

        HGLOBAL hGlobal;

        Verify(S_OK == GetHGlobalFromStream(pstm, &hGlobal));

        pExtent = (MONIKEREXTENT *) GlobalLock(hGlobal);
        Assert(pExtent != NULL);

        // this overwrites the existing mnk_ShellLink extent if any.
        hr = m_ExtentList.PutExtent(pExtent);

        fOk = GlobalUnlock(hGlobal);

        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::Save serialized shell link to extent=%08X\n",
                 this,
                 hr));

        // If this is a Tracking Moniker, then we additionally write
        // out the fShellLinkInitialized flag.  Not only does this make the
        // flag persistent, but the existence of this Extent indicates
        // that this is a Tracking Moniker (put another way, it makes the
        // fIsTracking member persistent).


ExitShellLink:

        if (pstm != NULL)
            pstm->Release(); // releases the hGlobal.

        if (pps != NULL)
            pps->Release();

    }   // if ( ( m_fSaveShellLink ...
#endif // _TRACKLINK_

    //
    // A UNICODE version may exist in the ExtentList. Write that out.
    //

    hresult = m_ExtentList.Save(pStm);

errRet:

#ifdef _TRACKLINK_
    if (SUCCEEDED(hresult) && fClearDirty)
    {
        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::Save clearing dirty flag\n",
                 this));
        m_fDirty = FALSE;
    }
#endif

    wValidateMoniker();

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::IsDirty
//
//  Synopsis:   Return the dirty flag
//
//  Notes:
//
//----------------------------------------------------------------------------
#ifdef _TRACKLINK_
STDMETHODIMP CFileMoniker::IsDirty (VOID)
{
    mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::IsDirty returning%s dirty\n",
                 this,
                 m_fDirty ? "" : " not"));
    return(m_fDirty ? S_OK : S_FALSE);
}
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::GetSizeMax
//
//  Synopsis:   Return the current max size for a serialized moniker
//
//  Effects:
//
//  Arguments:  [pcbSize] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-09-94   kevinro   Modified
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::GetSizeMax (ULARGE_INTEGER FAR* pcbSize)
{
    CLock2 lck(m_mxs);   // protect all internal state during this call
    wValidateMoniker();

    M_PROLOG(this);
    VDATEPTROUT (pcbSize, ULONG);

    //
    // Total the string lengths. If the Ansi string doesn't exist yet, then
    // assume the maximum length will be 2 bytes times the number of
    // characters. 2 bytes is the maximum length of a DBCS character.
    //


    ULONG ulStringLengths = (m_cbAnsiPath?m_cbAnsiPath:m_ccPath*2);


    //
    // Now add in the size of the UNICODE string, if we haven't seen
    // a UNICODE extent yet.
    //

    if (!m_fUnicodeExtent )
    {
        ulStringLengths += (m_ccPath * sizeof(WCHAR));
    }

    //
    // The original code had added 10 bytes to the size, apparently just
    // for kicks. I have left it here, since it doesn't actually hurt
    //

    ULONG cbSize;

    cbSize = ulStringLengths +
             sizeof(CLSID) +            // The monikers class ID
             sizeof(CLSID) +            // OLE 1 classID
             sizeof(ULONG) +
             sizeof(USHORT) +
             sizeof(DWORD) +
             m_ExtentList.GetSize()
             + 10;

    ULISet32(*pcbSize,cbSize);

    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::GetSizeMax(%x)m_szPath(%ws) Size(0x%x)\n",
                 this,
                 m_szPath?m_szPath:L"<Null Path>",
                 cbSize));

    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetClassFileEx
//
//  Synopsis:   returns the classid associated with a file
//
//  Arguments:  [lpszFileName] -- name of the file
//              [pcid]         -- where to return the clsid
//              [clsidOle1]    -- ole1 clsid to use (or CLSID_NULL)
//
//  Returns:    S_OK if clisd determined
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:  On Cairo, STGFMT_FILE will try to read the clsid from a file,
//          then do pattern matching, and then do extension matching.
//          For all other storage formats, pattern matching is skipped.
//          If at any point along the way we find a clsid, exit
//
//----------------------------------------------------------------------------
STDAPI GetClassFileEx( LPCWSTR lpszFileName, CLSID FAR *pcid,
                                             REFCLSID clsidOle1)
{
    VDATEPTRIN (lpszFileName, WCHAR);
    VDATEPTROUT (pcid, CLSID);


    LPCWSTR   szExt = NULL;
    HRESULT   hresult;
    HANDLE    hFile = INVALID_HANDLE_VALUE;
    BOOL      fRWFile = TRUE;
    DWORD     dwFileAttributes;
    DWORD     dwFlagsAndAttributes;

    //
    //  Don't crash when provided a bogus file path.
    //
    if (lpszFileName == NULL)
    {
        hresult =  MK_E_CANTOPENFILE;
        goto errRet;
    }

#ifdef _CAIRO_

    hresult = StgGetClassFile (NULL, lpszFileName, pcid, &hFile);

    if (hresult == NOERROR && !IsEqualIID(*pcid, CLSID_NULL))
    {
        //  we have a class id from the file
        goto errRet;
    }

    // In certain cases, StgGetClassFile (NtCreateFile) will fail
    // but CreateFile will successfully open a docfile or OFS storage.
    // In the docfile case, DfGetClass returns lock violation
    //    but Daytona ignores it, and checks the pattern & extensions
    // In the OFS case, GetNtHandle returns share violation
    //    but CreateFile will work, skip the pattern & check extensions
    // This is intended to emulate this odd behavior

    if (hresult != STG_E_LOCKVIOLATION &&
        hresult != STG_E_SHAREVIOLATION &&
        !SUCCEEDED(hresult))               // emulate CreateFile error
    {
            hresult = MK_E_CANTOPENFILE;
        goto errRet;
    }
#endif  // _CAIRO_

#ifndef _CAIRO_

    // open the file once, then pass the file handle to the various
    // subsystems (storage, pattern matching) to do the work.


    dwFlagsAndAttributes = 0;
    dwFileAttributes = GetFileAttributes(lpszFileName);
    if (dwFileAttributes != 0xFFFFFFFF) 
    {
        if (dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
            dwFlagsAndAttributes |= FILE_FLAG_OPEN_NO_RECALL;
    }

    hFile = CreateFile(lpszFileName,    // file name
                      GENERIC_READ | FILE_WRITE_ATTRIBUTES,  // read/write access
                      FILE_SHARE_READ | FILE_SHARE_WRITE, // allow any other access
                      NULL,             // no sec descriptor
                      OPEN_EXISTING,    // fail if file doesn't exist
                      dwFlagsAndAttributes, // flags & attributes
                      NULL);            // no template

    if (INVALID_HANDLE_VALUE == hFile)
    {
        fRWFile = FALSE;
        hFile = CreateFile(lpszFileName,    // file name
                           GENERIC_READ,     // read only access
                           FILE_SHARE_READ | FILE_SHARE_WRITE, // allow any other access
                           NULL,             // no sec descriptor
                           OPEN_EXISTING,    // fail if file doesn't exist
                           dwFlagsAndAttributes,  // flags & attributes
                           NULL);            // no template

        if (INVALID_HANDLE_VALUE == hFile)
        {
            hresult = MK_E_CANTOPENFILE;
            goto errRet;
        }
    }

#ifndef _CHICAGO_
    if (fRWFile)
    {
        // Prevent modification of file times
        // NT System Call - set file information

        FILE_BASIC_INFORMATION basicInformation;
        basicInformation.CreationTime.QuadPart   = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart  = -1;
        basicInformation.ChangeTime.QuadPart     = -1;
        basicInformation.FileAttributes          = 0;

        IO_STATUS_BLOCK IoStatusBlock;
        NTSTATUS Status = NtSetInformationFile(hFile, &IoStatusBlock,
                                               (PVOID)&basicInformation,
                                               sizeof(basicInformation),
                                               FileBasicInformation);
    }
#endif

    // First, check with storage to see if this a docfile. if it is,
    // storage will return us the clsid.

    hresult = DfGetClass(hFile, pcid);

    if (hresult == NOERROR && !IsEqualIID(*pcid, CLSID_NULL))
    {
        goto errRet;
    }

#endif // _CAIRO_

    // If this is an OLE1 file moniker, then use the CLSID given
    // to the moniker at creation time instead of using the
    // file extension.  Bug 3948.

    if (!IsEqualCLSID(clsidOle1,CLSID_NULL))
    {
        *pcid = clsidOle1;

        hresult = NOERROR;
        goto errRet;
    }

#ifdef _CAIRO_
    if (hFile != INVALID_HANDLE_VALUE)
    {
#endif

    // Attempt to find the class by matching byte patterns in
    // the file with patterns stored in the registry.

    hresult = wCoGetClassPattern(hFile, pcid);

    if (hresult != REGDB_E_CLASSNOTREG)
    {
        // either a match was found, or the file does not exist.
        goto errRet;
    }
#ifdef _CAIRO_
    }       // end if (hFile != INVALID_HANDLE_VALUE)
#endif


    //  The file is not a storage, there was no pattern matching, and
    //  the file exists. Look up the class for this extension.
    //  Find the extension by scanning backward from the end for ".\/!"
    //  There is an extension only if we find "."

    hresult = NOERROR;
    szExt = FindExt(lpszFileName);

    if (!szExt)
    {
        //  no file extension
        hresult = ResultFromScode(MK_E_INVALIDEXTENSION);
        goto errRet;
    }

    if (wCoGetClassExt(szExt, pcid) != 0)
    {
        hresult = ResultFromScode(MK_E_INVALIDEXTENSION);
    }


errRet:

    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }

    if (hresult != NOERROR)
    {
        *pcid = CLSID_NULL;
    }

    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetClassFile
//
//  Synopsis:   returns the classid associated with a file
//
//  Arguments:  [lpszFileName] -- name of the file
//              [pcid]         -- where to return the clsid
//
//  Returns:    S_OK if clisd determined
//
//  Algorithm:  just calls GetClassFileEx
//
//  History:    1-16-94   kevinro   Created
//
//----------------------------------------------------------------------------
STDAPI GetClassFile( LPCWSTR lpszFileName, CLSID FAR *pcid )
{
    OLETRACEIN((API_GetClassFile, PARAMFMT("lpszFileName= %ws, pcid= %p"),
                                lpszFileName, pcid));

    HRESULT hr;

    hr = GetClassFileEx (lpszFileName, pcid, CLSID_NULL);

    OLETRACEOUT((API_GetClassFile, hr));

    return hr;
}


#ifdef _TRACKLINK_
STDMETHODIMP CFileMoniker::Reduce (LPBC pbc,
        DWORD dwReduceHowFar,
        LPMONIKER FAR* ppmkToLeft,
        LPMONIKER FAR * ppmkReduced)
{
        mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::Reduce(%x)\n",this));

        M_PROLOG(this);


        CLock2 lck(m_mxs);   // protect all internal state


        VDATEPTROUT(ppmkReduced,LPMONIKER);

        VDATEIFACE(pbc);
        if (ppmkToLeft)
        {
                VDATEPTROUT(ppmkToLeft,LPMONIKER);
                if (*ppmkToLeft) VDATEIFACE(*ppmkToLeft);
        }

        HRESULT hr=E_FAIL;
        IMoniker *pmkNew=NULL;
        BOOL fReduceToSelf = TRUE;

        *ppmkReduced = NULL;

        //
        // search for the file
        //

        if ( m_fTrackingEnabled && m_fReduceEnabled )
        {
            // Resolve the ShellLink object.

            hr = ResolveShellLink( FALSE  ); // fRefreshOnly
            if( S_OK == hr )
            {
                Assert(m_szPath != NULL);

                // Use the path that we now know is up-to-date, to create
                // a default (i.e., non-tracking) File Moniker.

                hr = CreateFileMoniker(m_szPath, ppmkReduced); // expensive

                if (hr == S_OK)
                    fReduceToSelf = FALSE;

            }   // if( SUCCEEDED( ResolveShellLink( FALSE )))
        }   // if ( m_fTrackingEnabled && m_fReduceEnabled )


        if (fReduceToSelf)
        {
            *ppmkReduced = this;
            AddRef();
            hr = MK_S_REDUCED_TO_SELF;
        }

        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::Reduce exit with hr=%08X.\n",
                     this,
                     hr));
        return(hr);
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   FileBindToObject
//
//  Synopsis:   Given a filename, and some other information, bind to the
//              file and load it.
//
//  Effects:    This routine is used to load an object when the caller to
//              CFileMoniker::BindToObject had provided its own bind context.

                //If pmkToLeft != 0, then we have a moniker on the left of the
                //file moniker. The file moniker will use pmkToLeft to bind to
                //either the IClassFactory or the IClassActivator interface.
                //
                //If protSystem != prot, then the bind context has supplied a
                //non-standard ROT.  CoGetInstanceFromFile and CoGetPersistentInstance
                //only search the standard ROT.  Therefore we cannot call
                //CoGetInstanceFromFile or CoGetPersistentInstance in this case.

//
//  Arguments:  [pmkThis] -- Moniker being bound
//              [pwzPath] -- Path to bind
//              [clsid] -- CLSID for path
//              [pbc] -- The bind context - Not ours! Make no assumptions
//              [pmkToLeft] -- Moniker to left
//              [riidResult] -- IID being requested
//              [ppvResult] -- punk for result
//
//----------------------------------------------------------------------------
INTERNAL FileBindToObject
    (LPMONIKER pmkThis,
    LPWSTR pwzPath,
    REFCLSID clsid,
    LPBC pbc,
    BIND_OPTS2 *pBindOptions,
    LPMONIKER pmkToLeft,
    REFIID riidResult,
    LPVOID FAR* ppvResult)
{
    HRESULT hr;
    LPPERSISTFILE pPF = NULL;

    *ppvResult = NULL;

    //Get an IPersistFile interface pointer.
    if(0 == pmkToLeft)
    {
        if ( pBindOptions->pServerInfo )
        {
            MULTI_QI    MultiQi;

            MultiQi.pIID = &IID_IPersistFile;
            MultiQi.pItf = 0;

            hr = CoCreateInstanceEx(clsid, NULL,
                                    pBindOptions->dwClassContext | CLSCTX_NO_CODE_DOWNLOAD,
                                    pBindOptions->pServerInfo,
                                    1, &MultiQi );

            pPF = (IPersistFile *) MultiQi.pItf;
        }
        else
        {
            hr = CoCreateInstance(clsid, NULL,
                                    pBindOptions->dwClassContext | CLSCTX_NO_CODE_DOWNLOAD,
                                    IID_IPersistFile,
                                    (void **) &pPF);
        }
    }
    else
    {
        IClassActivator *pActivator;
        IClassFactory *pFactory = 0;

        //Bind to IClassActivator interface.
        hr = pmkToLeft->BindToObject(pbc,
                                     0,
                                     IID_IClassActivator,
                                     (void **) &pActivator);

        if(SUCCEEDED(hr))
        {
            hr = pActivator->GetClassObject(clsid,
                                            pBindOptions->dwClassContext,
                                            pBindOptions->locale,
                                            IID_IClassFactory,
                                            (void **) &pFactory);
            pActivator->Release();
        }
        else
        {
            //Bind to the IClassFactory interface.
            hr = pmkToLeft->BindToObject(pbc,
                                         0,
                                         IID_IClassFactory,
                                         (void **) &pFactory);
        }

        if(SUCCEEDED(hr) && pFactory != 0)
        {
            //Create an instance and get the IPersistFile interface.
            hr = pFactory->CreateInstance(0,
                                          IID_IPersistFile,
                                          (void **) &pPF);
            pFactory->Release();
        }
    }

    //Load the instance from the file.
    if(SUCCEEDED(hr))
    {
        hr = pPF->Load(pwzPath, pBindOptions->grfMode);
        if (SUCCEEDED(hr))
        {
            hr = pPF->QueryInterface(riidResult, ppvResult);
        }
        pPF->Release();
    }
    else if(E_NOINTERFACE == hr)
    {
        hr = MK_E_INTERMEDIATEINTERFACENOTSUPPORTED;
    }

    return hr;
}


/*
BindToObject takes into account AutoConvert and TreatAs keys when
determining which class to use to bind.  It does not blindly use the
CLSID returned by GetClassFileEx.  This is to allow a new OLE2
server to service links (files) created with its previous OLE1 or OLE2
version.

This can produce some strange behavior in the follwoing (rare) case.
Suppose you have both an OLE1 version (App1) and an OLE2 version
(App2) of a server app on your machine, and the AutoConvert key is
present.  Paste link from App1 to an OLE2 container. The link will
not be connected because BindToObject will try to bind
using 2.0 behavior (because the class has been upgraded) rather than 1.0
behavior (DDE).  Ideally, we would call DdeIsRunning before doing 2.0
binding.  If you shut down App1, then you will be able to bind to
App2 correctly.
*/

STDMETHODIMP CFileMoniker::BindToObject ( LPBC pbc,
    LPMONIKER pmkToLeft, REFIID riidResult, LPVOID FAR* ppvResult)
{
    mnkDebugOut((DEB_ITRACE,"CFileMoniker(%x)::BindToObject\n",this));

    m_mxs.Request();
    BOOL    bGotLock = TRUE;

    wValidateMoniker();


    A5_PROLOG(this);
    VDATEPTROUT (ppvResult, LPVOID);
    *ppvResult = NULL;
    VDATEIFACE (pbc);
    if (pmkToLeft)
    {
        VDATEIFACE (pmkToLeft);
    }
    VDATEIID (riidResult);
    HRESULT hr;
    CLSID clsid;
    LPRUNNINGOBJECTTABLE prot = NULL;
    LPRUNNINGOBJECTTABLE protSystem = NULL;
    LPUNKNOWN pUnk = NULL;
    BIND_OPTS2 bindopts;
    BOOL fOle1Loaded;

    //Get the bind options from the bind context.
    bindopts.cbStruct = sizeof(bindopts);
    hr = pbc->GetBindOptions(&bindopts);

    if(FAILED(hr))
    {
        //Try the smaller BIND_OPTS size.
        bindopts.cbStruct = sizeof(BIND_OPTS);
        hr = pbc->GetBindOptions(&bindopts);
        if(FAILED(hr))
        {
            goto exitRtn;
        }
    }

    if(bindopts.cbStruct < sizeof(BIND_OPTS2))
    {
       //Initialize the new BIND_OPTS2 fields
       bindopts.dwTrackFlags = 0;
       bindopts.locale = GetThreadLocale();
       bindopts.pServerInfo = 0;

       bindopts.dwClassContext = CLSCTX_SERVER;
    }


    hr = GetRunningObjectTable(0,&protSystem);
    if(SUCCEEDED(hr))
    {
        // Get the Bind Contexts version of the ROT
        hr = pbc->GetRunningObjectTable( &prot );
        if(SUCCEEDED(hr))
        {

            // first snapshot some member data and unlock
            CLSID   TempClsid = m_clsid;
            LPWSTR  TempPath = (LPWSTR) alloca((m_ccPath + 1) * sizeof(WCHAR));
            olever  NewOleVer = m_ole1;
            BOOL    fUpdated = FALSE;


            lstrcpyW(TempPath, m_szPath);
            bGotLock = FALSE;
            m_mxs.Release();


            if((prot == protSystem)  && (0 == pmkToLeft))
            {
                //This is the normal case.
                //Bind to the object.
#ifdef DCOM
               MULTI_QI   QI_Block;
               QI_Block.pItf = NULL;
               QI_Block.pIID = &riidResult;
               CLSID * pClsid = &TempClsid;

               if ( IsEqualGUID( GUID_NULL, m_clsid ) )
                   pClsid = NULL;

               hr = CoGetInstanceFromFile(bindopts.pServerInfo,
                                         pClsid,
                                         NULL,
                                         bindopts.dwClassContext | CLSCTX_NO_CODE_DOWNLOAD,
                                         bindopts.grfMode,
                                         TempPath,
                                         1,
                                         &QI_Block);
               *ppvResult = (LPVOID) QI_Block.pItf;
#else // !DCOM
               hr = CoGetPersistentInstance(riidResult,
                                            bindopts.dwClassContext,
                                            bindopts.grfMode,
                                            TempPath,
                                            NULL,
                                            TempClsid,
                                            &fOle1Loaded,
                                            ppvResult);
#endif // !DCOM
            }
            else  // prot != protSystem or pmkToLeft exists
            {

                mnkDebugOut((DEB_ITRACE,"::BindToObject using non-standard ROT\n"));

                //Search the ROT for the object.
                hr = prot->GetObject(this, &pUnk);
                if (SUCCEEDED(hr))
                {
                    // Found in the ROT. Try and get the interface and return
                    mnkDebugOut((DEB_ITRACE,"::BindToObject Found object in ROT\n"));
                    hr = pUnk->QueryInterface(riidResult, ppvResult);
                    pUnk->Release();
                }
                else
                {
                    //Object was not found in the ROT.  Get the class ID,
                    //then load the object from the file.
                    mnkDebugOut((DEB_ITRACE,"::BindToObject doing old style bind\n"));

                    hr = GetClassFileEx (TempPath, &clsid,TempClsid);

                    if (hr == NOERROR)
                    {
                        UpdateClsid (&clsid); // See note above                        
                        if (CoIsOle1Class (clsid))
                        {
                            mnkDebugOut((DEB_ITRACE,
                                 "::BindToObject found OLE1.0 class\n"));

                            COleTls Tls;
                            if( Tls->dwFlags & OLETLS_DISABLE_OLE1DDE )
                            {
                                // If this app doesn't want or can tolerate having a DDE
                                // window then currently it can't use OLE1 classes because
                                // they are implemented using DDE windows.
                                //
                                hr = CO_E_OLE1DDE_DISABLED;
                            }
                            else  // DDE not disabled
                            {
                                hr = DdeBindToObject (TempPath,
                                                      clsid,
                                                      FALSE,
                                                      riidResult,
                                                      ppvResult);
                                {
                                    NewOleVer = ole1;
                                    TempClsid = clsid;
                                    m_fClassVerified = TRUE;
                                    fUpdated = TRUE;
                                }
                            }

                        }
                        else  // Not OLE 1 class
                        {
                            mnkDebugOut((DEB_ITRACE,
                                 "::BindToObject found OLE2.0 class\n"));
                            hr = FileBindToObject (this,
                                                TempPath,
                                                clsid,
                                                pbc,
                                                &bindopts,
                                                pmkToLeft,
                                                riidResult,
                                                ppvResult);
                            {
                                NewOleVer = ole2;
                                TempClsid = clsid;
                                m_fClassVerified = TRUE;
                                fUpdated = TRUE;
                            }
                        }
                    }
                    else
                    {
                        mnkDebugOut((DEB_ITRACE,
                                    "::BindToObject failed GetClassFileEx %x\n",
                                    hr));
                    }
                }
            }
            prot->Release();
            if (fUpdated)
            {
                // note that the lock is never held at this point...
                CLock2 lck(m_mxs);
                m_ole1 = NewOleVer;
                m_clsid = TempClsid;
            }
        }
        else
        {
            mnkDebugOut((DEB_ITRACE,
                         "::BindToObject failed pbc->GetRunningObjectTable() %x\n",
                         hr));
        }
        protSystem->Release();
    }
    else
    {
        mnkDebugOut((DEB_ITRACE,
                     "::BindToObject failed GetRunningObjectTable() %x\n",
                     hr));
    }


exitRtn:
    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker(%x)::BindToObject returns %x\n",
                 this,
                 hr));

    // make sure we exit with the lock clear in case of errors.
    if ( bGotLock )
        m_mxs.Release();

    return hr;
}


BOOL Peel( LPWSTR lpszPath, USHORT endServer, LPWSTR FAR * lplpszNewPath, ULONG n )
//  peels off the last n components of the path, leaving a delimiter at the
//  end.  Returns the address of the new path via *lplpszNewPath.  Returns
//  false if an error occurred -- e.g., n too large, trying to peel off a
//  volume name, etc.
{
WCHAR FAR* lpch;
ULONG i = 0;
ULONG j;
WCHAR FAR* lpszRemainingPath; // ptr to beginning of path name minus the share name

    if (*lpszPath == '\0') return FALSE;

    //
    // Find the end of the string and determine the string length.
    //

    for (lpch=lpszPath; *lpch; lpch++);

    DecLpch (lpszPath, lpch);   // lpch now points to the last real character

//  if n == 0, we dup the string, possibly adding a delimiter at the end.

    if (n == 0)
    {
        i = lstrlenW(lpszPath);

        if (!IsSeparator(*lpch))
        {
            j = 1;
        }
        else
        {
            j = 0;
        }

        *lplpszNewPath = (WCHAR *) PrivMemAlloc((i + j + 1) * sizeof(WCHAR));

        if (*lplpszNewPath == NULL)
        {
            return FALSE;
        }

        memcpy(*lplpszNewPath, lpszPath, i * sizeof(WCHAR));

        if (j == 1)
        {
            *(*lplpszNewPath + i) = '\\';
        }

        *(*lplpszNewPath + i + j)  = '\0';

        return TRUE;
    }


        if (DEF_ENDSERVER == endServer)
                        endServer = 0;

        lpszRemainingPath = lpszPath + endServer; // if endServer > 0 the remaining path will be in the form of \dir\file


#ifdef _DEBUG
        if (endServer)
        {
                Assert(lpszRemainingPath[0] == '\\');
        }
#endif // _DEBUG

        if (lpch < lpszRemainingPath)
        {
                AssertSz(0,"endServer Value is larger than Path");
                return FALSE;
        }

        for (i = 0; i < n; i++)
    {
        if (IsSeparator(*lpch))
        {
            DecLpch(lpszPath, lpch);
        }
        if ((lpch < lpszRemainingPath) || (*lpch == ':') || (IsSeparator(*lpch)))
        {
            return FALSE;
        }

        //  n is too large, or we hit two delimiters in a row, or a volume name.

        while( !IsSeparator(*lpch) && (lpch > lpszRemainingPath) )
        {
            DecLpch(lpszPath, lpch);
        }
    }

    //  lpch points to the last delimiter we will leave or lpch == lpszPath
    //  REVIEW:  make sure we haven't eaten into the volume name

    if (lpch == lpszPath)
    {
        *lplpszNewPath = (WCHAR *) PrivMemAlloc(1 * sizeof(WCHAR));

        if (*lplpszNewPath == NULL)
        {
            return FALSE;
        }

        **lplpszNewPath = '\0';
    }
    else
    {
        *lplpszNewPath = (WCHAR *) PrivMemAlloc(
            (ULONG) (lpch - lpszPath + 2) * sizeof(WCHAR));

        if (*lplpszNewPath == NULL) return FALSE;

        memcpy(*lplpszNewPath,lpszPath,(ULONG) (lpch - lpszPath + 1) * sizeof(WCHAR));
        *(*lplpszNewPath + (lpch - lpszPath) + 1) = '\0';
    }


    return TRUE;
}



STDMETHODIMP CFileMoniker::BindToStorage (LPBC pbc, LPMONIKER
    pmkToLeft, REFIID riid, LPVOID FAR* ppvObj)
{
    M_PROLOG(this);

    CLock2 lck(m_mxs);   // protect all internal state
    wValidateMoniker();

    VDATEPTROUT (ppvObj, LPVOID);
    *ppvObj = NULL;
    VDATEIFACE (pbc);

    if (pmkToLeft)
    {
        VDATEIFACE (pmkToLeft);
    }
    VDATEIID (riid);

    *ppvObj = NULL;
    HRESULT hresult = NOERROR;

    BIND_OPTS bindopts;
    bindopts.cbStruct = sizeof(BIND_OPTS);


    hresult = pbc->GetBindOptions(&bindopts);
    if FAILED(hresult)
        goto errRet;


    // Bind to the storage.

    if (IsEqualIID(riid, IID_IStorage))
    {
        hresult = StgOpenStorage( m_szPath, NULL, bindopts.grfMode, NULL, 0, (LPSTORAGE FAR*)ppvObj );
    }
    else if (IsEqualIID(riid, IID_IStream))
    {
        hresult = ResultFromScode(E_UNSPEC);  // unimplemented until CreateStreamOnFile is implemented

    }
    else if (IsEqualIID(riid, IID_ILockBytes))
    {
        hresult = ResultFromScode(E_UNSPEC);    //  unimplemented until CreateILockBytesOnFile is implemented
    }
    else
    {
        //  CFileMoniker:BindToStorage called for unsupported interface
        hresult = ResultFromScode(E_NOINTERFACE);
    }


    //  REVIEW:  CFileMoniker:BindToStorage being called for unsupported interface

errRet:
    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::ComposeWith
//
//  Synopsis:   Compose another moniker to the end of this
//
//  Effects:    Given another moniker, create a composite between this
//              moniker and the other. If the other is also a CFileMoniker,
//              then collapse the two monikers into a single one by doing a
//              concatenate on the two paths.
//
//  Arguments:  [pmkRight] --
//              [fOnlyIfNotGeneric] --
//              [ppmkComposite] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    3-03-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::ComposeWith ( LPMONIKER pmkRight,
    BOOL fOnlyIfNotGeneric, LPMONIKER FAR* ppmkComposite)
{
    CLock2 lck(m_mxs);   // protect all internal state

    wValidateMoniker();
    M_PROLOG(this);
    VDATEPTROUT (ppmkComposite, LPMONIKER);
    *ppmkComposite = NULL;
    VDATEIFACE (pmkRight);

    HRESULT hresult = NOERROR;
    CFileMoniker FAR* pcfmRight;
    LPWSTR lpszLeft = NULL;
    LPWSTR lpszRight;
    LPWSTR lpszComposite;
    CFileMoniker FAR* pcfmComposite;
    int n1;
    int n2;

    *ppmkComposite = NULL;

    //
    // If we are being composed with an Anti-Moniker, then return
    // the resulting composition. The EatOne routine will take care
    // of returning the correct composite of Anti monikers (or NULL)
    //

    CAntiMoniker *pCAM = IsAntiMoniker(pmkRight);
    if(pCAM)
    {
        pCAM->EatOne(ppmkComposite);
        return(NOERROR);
    }

    //
    // If the moniker is a CFileMoniker, then collapse the two monikers
    // into one by doing a concate of the two strings.
    //

    if ((pcfmRight = IsFileMoniker(pmkRight)) != NULL)
    {
        lpszRight = pcfmRight->m_szPath;

        //  lpszRight may be NULL

        if (NULL == lpszRight)
            lpszRight = L"";

        if (( *lpszRight == 0) &&
            pcfmRight->m_cAnti == 0)
        {
            //  Second moniker is "".  Simply return the first.
            *ppmkComposite = this;
            AddRef();
            return NOERROR;
        }

        //
        // If the path on the right is absolute, then there is a
        // syntax error. The path is invalid, since you can't
        // concat d:\foo and d:\bar to get d:\foo\d:\bar and
        // expect it to work.
        //
        if (IsAbsolutePath(lpszRight))
        {
            return(MK_E_SYNTAX);
        }

        //
        // If the right moniker has m_cAnti != 0, then peel back
        // the path
        //

        if (Peel(m_szPath,m_endServer, &lpszLeft, pcfmRight->m_cAnti))
        {
            //  REVIEW:  check that there is no volume name at the start
            //  skip over separator

            while (IsSeparator(*lpszRight)) lpszRight++;

            n1 = lstrlenW(lpszLeft);

            n2 = lstrlenW(lpszRight);

            lpszComposite = (WCHAR *) PrivMemAlloc((n1 + n2 + 1)*sizeof(WCHAR));

            if (!lpszComposite)
            {
                hresult = E_OUTOFMEMORY;
            }
            else
            {
                memcpy(lpszComposite, lpszLeft, n1 * sizeof(WCHAR));
                memcpy(lpszComposite + n1, lpszRight, n2 * sizeof(WCHAR));

                lpszComposite[n1 + n2] = '\0';

                pcfmComposite = CFileMoniker::Create(lpszComposite,
                                         m_cAnti,m_endServer);

                if (pcfmComposite == NULL)
                {
                    hresult = E_OUTOFMEMORY;
                }

                else
                {
                    // Is tracking moniker?

                    {
                        *ppmkComposite = pcfmComposite;
                        pcfmComposite = NULL;
                    }

                }   // if (pcfmComposite == NULL) ... else


                PrivMemFree(lpszComposite);
            }   // if (!lpszComposite) ... else

            if ( lpszLeft != NULL)
            {
                PrivMemFree(lpszLeft);
            }
        }   // if (Peel(m_szPath, &lpszLeft, pcfmRight->m_cAnti))
        else
        {
            //  Peel failed, which means the caller attempted an
            //  invalid composition of file paths. There is apparently
            //  a syntax error in the names.
            //
            hresult = MK_E_SYNTAX;
        }   // if (Peel(m_szPath, &lpszLeft, pcfmRight->m_cAnti)) ... else
    }   // if ((pcfmRight = IsFileMoniker(pmkRight)) != NULL)
    else
    {
        if (!fOnlyIfNotGeneric)
        {
            hresult = CreateGenericComposite( this, pmkRight, ppmkComposite );
        }
        else
        {
            hresult = MK_E_NEEDGENERIC;
            *ppmkComposite = NULL;
        }
    }   // if ((pcfmRight = IsFileMoniker(pmkRight)) != NULL) ... else

    return hresult;
}


STDMETHODIMP CFileMoniker::Enum (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
    M_PROLOG(this);
    VDATEPTROUT (ppenumMoniker, LPENUMMONIKER);
    *ppenumMoniker = NULL;
    //  REVIEW:  this says files monikers are not enumerable.
    return NOERROR;
}



STDMETHODIMP CFileMoniker::IsEqual (THIS_ LPMONIKER pmkOtherMoniker)
{
    HRESULT  hr = S_FALSE;

    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::IsEqual(%x) m_szPath(%ws)\n",
                 this,
                 WIDECHECK(m_szPath)));

    ValidateMoniker();
    
    M_PROLOG(this);
    VDATEIFACE (pmkOtherMoniker);

    CFileMoniker FAR* pCFM = IsFileMoniker(pmkOtherMoniker);
    if (!pCFM)
    {
        return S_FALSE;
    }

    //Protect the internal state of both monikers.
    //To prevent deadlock, we must take the locks in a consistent order.
    if(this == pCFM)
    {
        return S_OK;
    }
    else if(this < pCFM)
    {
        m_mxs.Request();
        pCFM->m_mxs.Request();
    }
    else
    {
        pCFM->m_mxs.Request();
        m_mxs.Request();
    }

    if (pCFM->m_cAnti == m_cAnti)
    {
        mnkDebugOut((DEB_ITRACE,
                     "::IsEqual(%x) m_szPath(%ws) pOther(%ws)\n",
                     this,
                     WIDECHECK(m_szPath),
                     WIDECHECK(pCFM->m_szPath)));

        //  for the paths, we just do a case-insensitive compare.
        if (lstrcmpiW(pCFM->m_szPath, m_szPath) == 0)
        {
            hr = S_OK;
        }
    }

    m_mxs.Release();
    pCFM->m_mxs.Release();

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   CalcFileMonikerHash
//
//  Synopsis:   Given a LPWSTR, calculate the hash value for the string.
//
//  Effects:
//
//  Arguments:  [lp] -- String to compute has value for
//
//  Returns:
//      DWORD hash value for string.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-15-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CalcFileMonikerHash(LPWSTR lp, ULONG cch)
{
    DWORD   dwTemp = 0;
    WCHAR   ch;
    ULONG   cbTempPath = (cch + 1) * sizeof(WCHAR);
    LPWSTR  pszTempPath = (LPWSTR) alloca(cbTempPath);


    if (lp == NULL || pszTempPath == NULL)
    {
        return 0;
    }

    //
    // toupper turns out to be expensive, since it takes a
    // critical section each and every time. It turns out to be
    // much cheaper to make a local copy of the string, then upper the
    // whole thing.
    //

    if (!cbTempPath)
        return 0;

    memcpy(pszTempPath, lp, cbTempPath);

    CharUpperW(pszTempPath);

    while (*pszTempPath)
    {
        dwTemp *= 3;
        ch = *pszTempPath;
        dwTemp ^= ch;
        pszTempPath++;
    }

    return dwTemp;
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::Hash
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pdwHash] -- Output pointer for hash value
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-09-94   kevinro   Modified
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::Hash (THIS_ LPDWORD pdwHash)
{
    CLock2 lck(m_mxs);   // protect m_fHashValueValid and m_dwHashValue
    wValidateMoniker();

    M_PROLOG(this);
    VDATEPTROUT (pdwHash, DWORD);

    //
    // Calculating the hash value is expensive. Cache it.
    //
    if (!m_fHashValueValid)
    {
        m_dwHashValue = m_cAnti + CalcFileMonikerHash(m_szPath, m_ccPath);

        m_fHashValueValid = TRUE;
    }

    *pdwHash = m_dwHashValue;

    wValidateMoniker();

    return(NOERROR);
}


//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::IsRunning
//
//  Synopsis:   Determine if the object pointed to by the moniker is listed
//              as currently running.
//
//  Effects:
//
//  Arguments:  [pbc] --
//              [pmkToLeft] --
//              [pmkNewlyRunning] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    3-03-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::IsRunning  (THIS_ LPBC pbc,
    LPMONIKER pmkToLeft,
    LPMONIKER pmkNewlyRunning)
{
    M_PROLOG(this);

    CLock2 lck(m_mxs);   // protect all internal state

    VDATEIFACE (pbc);
    LPRUNNINGOBJECTTABLE pROT;
    HRESULT hresult;

    //
    // According to the spec, CFileMoniker ignores the
    // moniker to the left.
    //
    if (pmkToLeft)
    {
        VDATEIFACE (pmkToLeft);
    }

    if (pmkNewlyRunning)
    {
        VDATEIFACE (pmkNewlyRunning);
    }


    CLSID clsid;

    if (IsOle1Class(&clsid))
    {
        return DdeIsRunning (clsid, m_szPath, pbc, pmkToLeft, pmkNewlyRunning);
    }



    if (pmkNewlyRunning != NULL)
    {
        return pmkNewlyRunning->IsEqual (this);
    }
    hresult = pbc->GetRunningObjectTable (&pROT);
    if (hresult == NOERROR)
    {
        hresult = pROT->IsRunning (this);
        pROT->Release ();
    }
    return hresult;
}



STDMETHODIMP CFileMoniker::GetTimeOfLastChange (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    FILETIME FAR* pfiletime)
{
    M_PROLOG(this);

    CLock2 lck(m_mxs);   // protect all internal state

    VDATEIFACE (pbc);
    if (pmkToLeft) VDATEIFACE (pmkToLeft);
    VDATEPTROUT (pfiletime, FILETIME);

    HRESULT hresult;

    LPMONIKER pmkTemp = NULL;
    LPRUNNINGOBJECTTABLE prot = NULL;
    LPWSTR lpszName = NULL;

    if (pmkToLeft == NULL)
    {
        pmkTemp = this;
        AddRef();
    }
    else
    {
        hresult = CreateGenericComposite(pmkToLeft, this, &pmkTemp );
        if (hresult != NOERROR)
        {
             goto errRet;
        }
    }

    hresult = pbc->GetRunningObjectTable(&prot);

    if (hresult != NOERROR)
    {
         goto errRet;
    }

    // Attempt to get the time-of-last-change from the ROT.  Note that
    // if there is a File Moniker in 'pmkTemp', the ROT will Reduce it.
    // Thus, if it is a *Tracking* File Moniker, it will be updated to reflect
    // any changes to the file (such as location, timestamp, etc.)

    hresult = prot->GetTimeOfLastChange(pmkTemp, pfiletime);

    if (hresult != MK_E_UNAVAILABLE)
    {
        goto errRet;
    }

    //
    // Why aren't we just looking in the file moniker to the left.
    // Is it possible to have another MKSYS_FILEMONIKER implementation?
    // [Just a suggestion; not a bug]
    //

    if (IsFileMoniker(pmkTemp))
    {
        hresult = pmkTemp->GetDisplayName(pbc, NULL, &lpszName);

        if (hresult != NOERROR)
        {
            goto errRet;
        }

        // Attempt to get the file's attributes.  If the file exists,
        // give the modify time to the caller.

#ifdef _CHICAGO_

        HANDLE hdl;

        WIN32_FIND_DATA fid;

        if ((hdl = FindFirstFile(lpszName, &fid)) != INVALID_HANDLE_VALUE)
        {
            memcpy(pfiletime, &fid.ftLastWriteTime, sizeof(FILETIME));
            FindClose(hdl);
            hresult = S_OK;
        }

#else // _CHICAGO_

        WIN32_FILE_ATTRIBUTE_DATA fad;

        if( GetFileAttributesEx( lpszName, GetFileExInfoStandard, &fad ))
        {
            memcpy(pfiletime, &fad.ftLastWriteTime, sizeof(FILETIME));
            hresult = S_OK;
        }

#endif // _CHICAGO_

        else
        {
            hresult = ResultFromScode(MK_E_NOOBJECT);
        }
    }
    else
    {
        hresult = ResultFromScode(E_UNSPEC);
    }


errRet:

    if (prot != NULL)
    {
        prot->Release();
    }

    if (pmkTemp != NULL)
    {
        pmkTemp->Release();
    }

    if (lpszName != NULL)
    {
        CoTaskMemFree(lpszName);
    }

    return hresult;
}



STDMETHODIMP CFileMoniker::Inverse (THIS_ LPMONIKER FAR* ppmk)
{
    CLock2 lck(m_mxs);   // protect all internal state

    wValidateMoniker();

    M_PROLOG(this);
    VDATEPTROUT (ppmk, LPMONIKER);
    return CreateAntiMoniker(ppmk);
}



//+---------------------------------------------------------------------------
//
//  Function:   CompareNCharacters
//
//  Synopsis:   Compare N characters, ignoring case and sort order
//
//  Effects:    We are interested only in whether the strings are the same.
//              Unlike wcscmp, which determines the sort order of the strings.
//              This routine should save us some cycles
//
//  Arguments:  [pwcThis] --
//              [pwcOther] --
//              [n] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-14-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CompareNCharacters( LPWSTR pwcThis, LPWSTR pwcOther, ULONG n)
{
    while(n--)
    {
        if (CharUpperW((LPWSTR)*pwcThis) != CharUpperW((LPWSTR)*pwcOther))
        {
            return(FALSE);
        }
        pwcThis++;
        pwcOther++;
    }
    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   CopyNCharacters
//
//  Synopsis:   Copy N characters from lpSrc to lpDest
//
//  Effects:
//
//  Arguments:  [lpDest] -- Reference to lpDest
//              [lpSrc] -- Pointer to source characters
//              [n] --
//
//  Requires:
//
//  Returns:
//
//  Returns with lpDest pointing to the end of the string. The string will
//  be NULL terminated
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-14-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline
void CopyNCharacters( LPWSTR &lpDest, LPWSTR lpSrc, ULONG n)
{
    memcpy(lpDest,lpSrc,sizeof(WCHAR)*n);
    lpDest += n;
    *lpDest = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   DetermineLongestString
//
//  Synopsis:   Used by CommonPrefixWith to handle case where one string may
//              be longer than the other.
//  Effects:
//
//  Arguments:  [pwcBase] --
//              [pwcPrefix] --
//              [pwcLonger] --
//
//  Requires:
//
//  Returns:    TRUE if all of pwcBase is a prefix of what pwcLonger is the
//              end of, or if tail of pwcBase is a separator.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-14-94   kevinro   Created
//             03-27-94   darryla   Added special case where pwcPrefix is
//                                  pointing at terminator and previous char
//                                  is a separator.
//
//  Notes:
//
//  See CommonPrefixWith. This code isn't a general purpose routine, and is
//  fairly intimate with CommonPrefixWith.
//
//
//----------------------------------------------------------------------------
BOOL DetermineLongestString(    LPWSTR pwcBase,
                                LPWSTR &pwcPrefix,
                                LPWSTR pwcLonger)

{
    //
    // pwcPrefix is the end of the string that so far matches pwcLonger
    // as a prefix.
    //
    // If the next character in pwcLonger is a seperator, then pwcPrefix
    // is a complete prefix. Otherwise, we need to back pwcPrefix to the
    // next prevous seperator character
    //
    if (IsSeparator(*pwcLonger))
    {
        //
        // pwcPrefix is a true prefix
        //
        return TRUE;
    }

    // One more special case. If pwcPrefix is pointing at a terminator and
    // the previous char is a separator, then this, too, is a valid prefix.
    // It is easier to catch this here than to try to walk back to the
    // separator and then determine if it was at the end.
    if (*pwcPrefix == '\0' && IsSeparator(*(pwcPrefix - 1)))
    {
        //
        // pwcPrefix is a true prefix ending with a separator
        //
        return TRUE;
    }

    //
    // We now have a situtation where pwcPrefix holds a string that is
    // might not be a prefix of pwcLonger. We need to start backing up
    // until we find a seperator character.
    //

    LPWSTR pStart = pwcPrefix;

    while (pwcPrefix > pwcBase)
    {
        if (IsSeparator(*pwcPrefix))
        {
            break;
        }
        pwcPrefix--;
    }

    //
    // NULL terminate the output string.
    //

    *pwcPrefix = 0;

    //
    // If pStart == pwcPrefix, then we didn't actually back up anything, or
    // we just removed a trailing backslash. If so, return TRUE, since the
    // pwcPrefix is a prefix of pwcLonger
    //
    if (pStart == pwcPrefix)
    {
        return(TRUE);
    }

    return(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   IsEmptyString
//
//  Synopsis:   Determine if a string is 'Empty', which means either NULL
//              or zero length
//
//  Effects:
//
//  Arguments:  [lpStr] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-25-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline
BOOL IsEmptyString(LPWSTR lpStr)
{
    if ((lpStr == NULL) || (*lpStr == 0))
    {
        return(TRUE);
    }
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::CommonPrefixWith
//
//  Synopsis:   Given two file monikers, determine the common prefix for
//              the two monikers.
//
//  Effects:    Computes a path that is the common prefix between the two
//              paths. It does this by string comparision, taking into
//              account the m_cAnti member, which counts the number of
//              preceeding dot dots constructs for each moniker.
//
//  Arguments:  [pmkOther] --
//              [ppmkPrefix] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-10-94   kevinro   Created
//
//  Notes:
//
// Welcome to some rather hairy code. Actually, it isn't all that bad,
// there are just quite a few boundary cases that you will have to
// contend with. I am sure if I thought about it long enough, there is
// a better way to implement this routine. However, it really isn't
// worth the effort, given the frequency at which this API is called.
//
// I have approached this in a very straightforward way. There is
// room for optimization, but it currently isn't high enough on
// the priority list.
//
// File monikers need to treat the end server with care. We actually
// consider the \\server\share as a single component. Therefore, if
// the two monikers are \\savik\win40\foo and \\savik\cairo\foo,
// then \\savik is NOT a common prefix.
//
// Same holds true with the <drive>: case, where we need to treat
// the drive as a unit
//
// To determine if two monikers have a common prefix, we look
// down both paths watching for the first non-matching
// character. When we find it, we need determine the correct
// action to take.
//
// \\foo\bar and foo\bar shouldn't match
// c:\foo\bar and c:\foo should return c:\foo
// c:\foo\bar and c:\foobar should return c:\                               .
//
// Be careful to handle the server case.
//
// \\savik\win40 and
// \\savik\win40\src\foo\bar should return \\savik\win40
// while \\savik\cairo should return MK_E_NOPREFIX
//
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::CommonPrefixWith (LPMONIKER pmkOther, LPMONIKER FAR*
    ppmkPrefix)
{
    CLock2 lck(m_mxs);   // protect all internal state
    return wCommonPrefixWith( pmkOther, ppmkPrefix );
}

STDMETHODIMP CFileMoniker::wCommonPrefixWith (LPMONIKER pmkOther, LPMONIKER FAR*
    ppmkPrefix)
{
    wValidateMoniker();

    VDATEPTROUT (ppmkPrefix, LPMONIKER);
    *ppmkPrefix = NULL;
    VDATEIFACE (pmkOther);

    CFileMoniker FAR* pcfmOther = NULL;
    CFileMoniker FAR* pcfmPrefix = NULL;

    HRESULT hresult = NOERROR;
    USHORT cAnti;

    //
    // The following buffer will contain the matching prefix. We should
    // be safe in MAX_PATH, since neither path can be longer than that.
    // This was verified when the moniker was created, so no explicit
    // checking is done in this routine
    //

    WCHAR awcMatchingPrefix[MAX_PATH + 1];
    WCHAR *pwcPrefix = awcMatchingPrefix;

    //
    // Each subsection of the path will be parsed into the following
    // buffer. This allows us to match each section of the path
    // independently
    //

    WCHAR awcComponent[MAX_PATH + 1];
    WCHAR *pwcComponent = awcComponent;


    *pwcPrefix = 0;     // Null terminate the empty string
    *pwcComponent = 0;  // Null terminate the empty string

    //
    // A couple temporaries to walk the paths.
    //

    LPWSTR pwcThis = NULL;
    LPWSTR pwcOther = NULL;

    HRESULT hrPrefixType = S_OK;

    //
    // If the other moniker isn't 'one of us', then get the generic system
    // provided routine to handle the rest of this call.
    //

    if ((pcfmOther = IsFileMoniker(pmkOther)) == NULL)
    {
        return MonikerCommonPrefixWith(this, pmkOther, ppmkPrefix);
    }

    //
    // If the m_cAnti fields are different, then match the minimum number of
    // dotdots.
    //
    //
    if (pcfmOther->m_cAnti != m_cAnti)
    {
        //  differing numbers of ..\ at the beginning
        cAnti = (m_cAnti > pcfmOther->m_cAnti ? pcfmOther->m_cAnti :m_cAnti );

        if (cAnti == 0)
        {
            hresult = ResultFromScode(MK_E_NOPREFIX);
        }
        //  pcfmPrefix is NULL
        else
        {
            pcfmPrefix = CFileMoniker::Create(L"",
                                      cAnti);
            if (pcfmPrefix == NULL)
            {
                hresult = E_OUTOFMEMORY;
                goto exitRoutine;

            }

            //  we must check to see if the final result is that same as
            //  this or pmkOther

            hresult = NOERROR;

            if (cAnti == m_cAnti)
            {
                if ((m_szPath==NULL)||(*m_szPath == '\0'))
                {
                    hresult = MK_S_ME;
                }
            }
            else
            {
                if ((pcfmOther->m_szPath == NULL ) ||
                        (*(pcfmOther->m_szPath) == '\0') )
                {
                    hresult = MK_S_HIM;
                }
            }
        }

        goto exitRoutine;
    }

    //
    // The number of leading dot-dots match. Therefore, we need to
    // compare the paths also. If no path exists, then the common prefix
    // is going to be the 'dot-dots'
    //
    cAnti = m_cAnti;

    pwcThis = m_szPath;
    pwcOther = pcfmOther->m_szPath;


    //
    // If either pointer is empty, then only the dotdots make for a prefix
    //
    if (IsEmptyString(pwcThis) || IsEmptyString(pwcOther))
    {
        //
        // At least one of the strings was empty, therefore the common
        // prefix is only the dotdots. Determine if its US, ME, or HIM
        //

        if (IsEmptyString(pwcThis) && IsEmptyString(pwcOther))
        {
            hrPrefixType = MK_S_US;
        }
        else if (IsEmptyString(pwcThis))
        {
            hrPrefixType = MK_S_ME;
        }
        else
        {
            hrPrefixType = MK_S_HIM;
        }
        goto onlyDotDots;
    }

    //
    // The strings may be prefaced by either a UNC name, or a 'drive:'
    // We treat both of these as a unit, and will only match prefixes
    // on paths that match UNC servers, or match drives.
    //
    // If it is a UNC name, then m_endServer will be set to point at
    // the end of the UNC name.
    //
    // First part of the match is to determine if the end servers are even
    // close. If the offsets are different, the answer is no.
    //

    //
    // The assertion at this point is that neither string is 'empty'
    //
    Assert( !IsEmptyString(pwcThis));
    Assert( !IsEmptyString(pwcOther));

    if (m_endServer != pcfmOther->m_endServer)
    {
        //
        // End servers are different, match only the dotdots. Neither
        // string is a complete
        //

        hrPrefixType = S_OK;

        goto onlyDotDots;
    }

    //
    // If the end servers are the default value, then look to see if
    // this is an absolute path. Otherwise, copy over the server section
    //

    if (m_endServer == DEF_ENDSERVER)
    {
        BOOL fThisAbsolute = IsAbsoluteNonUNCPath(pwcThis);
        BOOL fOtherAbsolute = IsAbsoluteNonUNCPath(pwcOther);
        //
        // If both paths are absolute, check for matching characters.
        // If only one is absolute, then match the dot dots.
        //
        if (fThisAbsolute && fOtherAbsolute)
        {
            //
            // Both absolute paths (ie 'c:' at the front)
            // If not the same, only dotdots
            //
            if (CharUpperW((LPWSTR)*pwcThis) != CharUpperW((LPWSTR)*pwcOther))
            {
                //
                // The paths don't match
                //
                hrPrefixType = S_OK;
                goto onlyDotDots;
            }

            //
            // The <drive>: matched. Copy it over
            //
            CopyNCharacters(pwcPrefix,pwcThis,2);
            pwcThis += 2;
            pwcOther += 2;
        }
        else if (fThisAbsolute || fOtherAbsolute)
        {
            //
            // One path is absolute, the other isn't.
            // Match only the dots
            //
            hrPrefixType = S_OK;
            goto onlyDotDots;
        }

        //
        // The fall through case does more path processing
        //
    }
    else
    {
        //
        // m_endServer is a non default value. Check to see if the
        // first N characters match. If they don't, then only match
        // the dotdots. If they do, copy them to the prefix buffer
        //

        if (!CompareNCharacters(pwcThis,pwcOther,m_endServer))
        {
            //
            // The servers didn't match.
            //
            hrPrefixType = S_OK;
            goto onlyDotDots;
        }

        //
        // The UNC paths matched, copy them over
        //

        CopyNCharacters(pwcPrefix,pwcThis,m_endServer);

        pwcThis += m_endServer;
        pwcOther += m_endServer;
    }

    //
    // Handle the root directory case. If BOTH monikers start
    // with a backslash, then copy this to the prefix section.
    // This allows for having '\foo' and '\bar' have the common
    // prefix of '\'. The code below this section will remove
    // any trailing backslashes.
    //
    // This also takes care of the case where you have a
    // drive: or \\server\share, followed by a root dir.
    // In either of these cases, we should return
    // drive:\ or \\server\share\ respectively
    //

    if ((*pwcThis == '\\') && (*pwcOther == '\\'))
    {
        *pwcPrefix = '\\';
        pwcThis++;
        pwcOther++;
        pwcPrefix++;
        *pwcPrefix = 0;
    }



    //
    // At this point, we have either matched the drive/server section,
    // or have an empty string. Time to start copying over the rest
    // of the data.
    //

    //
    // Walk down the strings, looking for the first non-matching
    // character
    //

    while (1)
    {
        if ((*pwcThis == 0) || (*pwcOther == 0))
        {
            //
            // We have hit the end of one or both strings.
            // awcComponent holds all of the matching
            // characters so far. Break out of the loop
            //
            break;
        }
        if (CharUpperW((LPWSTR)*pwcThis) != CharUpperW((LPWSTR)*pwcOther))
        {
            //
            // This is the first non-matching character.
            // We should break out here.
            //
            break;
        }

        //
        // At this point, the characters match, and are part
        // of the common prefix. Copy it to the string, and move on
        //

        *pwcComponent = *pwcThis;
        pwcThis++;
        pwcOther++;
        pwcComponent++;

        //
        // NULL terminate the current version of the component string
        //
        *pwcComponent = '\0';
    }

    //
    // If both strings are at the end, then we have a
    // complete match.
    //

    if ((*pwcThis == 0) && (*pwcOther == 0))
    {
        //
        // Ah, this feels good. The strings ended up being
        // the same length, with all matching characters.
        //
        // Therefore, we can just return one of us as the
        // result.
        //
        pcfmPrefix = this;
        AddRef();
        hresult = MK_S_US;
        goto exitRoutine;
    }

    //
    // If one of the strings is longer than the other...
    //
    if ((*pwcThis == 0) || (*pwcOther == 0))
    {
        //
        // Test to see if the next character in the longer string is a
        // seperator character. If it isn't, then back up the string to
        // the character before the previous seperator character.
        //
        // If TRUE then the shorter of the strings ends up being the
        // entire prefix.
        //
        //
        if( DetermineLongestString( awcComponent,
                                    pwcComponent,
                                    (*pwcThis == 0)?pwcOther:pwcThis) == TRUE)
        {
            if (*pwcThis == 0)
            {
                //
                // This is the entire prefix
                //
                pcfmPrefix = this;
                hresult = MK_S_ME;
            }
            else
            {
                //
                // The other guy is the entire prefix
                //
                pcfmPrefix = pcfmOther;
                hresult = MK_S_HIM;
            }
            pcfmPrefix->AddRef();
            goto exitRoutine;
        }
    }
    else
    {
        //
        // Right now, pwcThis and pwcOther point at non-matching characters.
        // Given the above tests, we know that neither character is
        // == 0.
        //
        // Backup the string to the previous seperator. To do this, we
        // will use DetermineLongestString, and pass it the string that
        // doesn't have a seperator
        //

        DetermineLongestString( awcComponent,
                                pwcComponent,
                                IsSeparator(*pwcThis)?pwcOther:pwcThis);
    }


    //
    // At this point, awcsComponent holds the second part of the string,
    // while awcsPrefix holds the server or UNC prefix. Either of these
    // may be NULL. Append awcComponent to the end of awcPrefix.
    //

    CopyNCharacters( pwcPrefix, awcComponent, (ULONG) (pwcComponent - awcComponent));


    //
    // Check to see if anything matched.
    //

    if (pwcPrefix == awcMatchingPrefix)
    {
        //
        // The only matching part is the dotdot count.
        // This is easy, since we can just create a new
        // moniker consisting only of dotdots.
        //
        // However, if there are no preceeding dotdots,
        // then there was absolutely no prefix, which means
        // we return MK_E_NOPREFIX
        //
        if (cAnti == 0)
        {
            hresult = MK_E_NOPREFIX;
            goto exitRoutine;

        }

        //
        // Nothing special about the moniker, so just return S_OK
        //

        hrPrefixType = S_OK;
        goto onlyDotDots;

    }

    //
    // Create a new file moniker using the awcMatchingPrefix
    //

    pcfmPrefix = CFileMoniker::Create(awcMatchingPrefix,0,cAnti);

    if (pcfmPrefix == NULL)
    {
        hresult = E_OUTOFMEMORY;
        goto exitRoutine;
    }
    hresult = S_OK;

exitRoutine:
    *ppmkPrefix = pcfmPrefix;   //  null, or a file moniker
    return hresult;


onlyDotDots:
    //
    // We have determined that only the dotdot's match, so create a
    // new moniker with the appropriate number of them.
    //
    // If there are no dotdots, then return NULL
    //

    if (cAnti == 0)
    {
        hresult = MK_E_NOPREFIX;
        goto exitRoutine;
    }

    pcfmPrefix = CFileMoniker::Create(L"",0,cAnti);

    if (pcfmPrefix == NULL)
    {
        hresult = E_OUTOFMEMORY;
    }
    else
    {
        hresult = hrPrefixType;
    }

    goto exitRoutine;
}



//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::RelativePathTo
//
//  Synopsis:   Compute a relative path to the other moniker
//
//  Effects:
//
//  Arguments:  [pmkOther] --
//              [ppmkRelPath] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-24-94   kevinro   Created
//
//  Notes:
//
//  (KevinRo)
//  This routine was really bad, and didn't generate correct results (aside
//  from the fact that it faulted). I replaced it with a slightly less
//  effiecient, but correct implementation.
//
//  This can be improved on, but I currently have time restraints, so I am
//  not spending the needed amount of time. What really needs to happen is
//  the code that determines the common path prefix string from
//  CommonPrefixWith() should be broken out so this routine can share it.
//
//  Thats more work that I can do right now, so we will just call CPW,
//  and use its result to compute the relative path. This results in an
//  extra moniker creation (allocate and construct only), but will work
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::RelativePathTo (THIS_ LPMONIKER pmkOther,
                                           LPMONIKER FAR*
                                           ppmkRelPath)
{
    CLock2 lck(m_mxs);   // protect all internal state

    wValidateMoniker();

    M_PROLOG(this);
    VDATEPTROUT (ppmkRelPath, LPMONIKER);
    *ppmkRelPath = NULL;
    VDATEIFACE (pmkOther);

    HRESULT hr;
    CFileMoniker FAR* pcfmPrefix;
    LPWSTR lpszSuffix;
    LPWSTR lpszOther;

    CFileMoniker FAR* pcfmRelPath = NULL;
    CFileMoniker FAR* pcfmOther = IsFileMoniker(pmkOther);

    if (!pcfmOther)
    {
        return MonikerRelativePathTo(this, pmkOther, ppmkRelPath, TRUE);
    }

    //
    // Determine the common prefix between the two monikers. This generates
    // a moniker which has a path that is the prefix between the two
    // monikers
    //

    hr = CommonPrefixWith(pmkOther,(IMoniker **)&pcfmPrefix);

    //
    // If there was no common prefix, then the relative path is 'him'
    //
    if (hr == MK_E_NOPREFIX)
    {
        *ppmkRelPath = pmkOther;
        pmkOther->AddRef();

        return MK_S_HIM;
    }

    if (FAILED(hr))
    {
        *ppmkRelPath = NULL;
        return(hr);
    }

    //
    // At this point, the common prefix to the two monikers is in pcfmPrefix
    // Since pcfmPrefix is a file moniker, we know that m_ccPath is the
    // number of characters that matched in both moniker paths. To
    // compute the relative part, we use the path from pmkOther, minus the
    // first pcfmPrefix->m_ccPath characters.
    //
    // We don't want to start with a seperator. Therefore, skip over the
    // first set of seperator characters. (Most likely, there aren't any).
    //

    lpszOther = pcfmOther->m_szPath + pcfmPrefix->m_ccPath;
    lpszSuffix = m_szPath + pcfmPrefix->m_ccPath;

    while ((*lpszSuffix != 0) && IsSeparator(*lpszSuffix))
    {
         lpszSuffix++;
    }

    //
    // Create new file moniker that holds the prefix.
    //

    pcfmRelPath = CFileMoniker::Create(lpszOther,
                                       (USHORT) CountSegments(lpszSuffix));

    //
    // At this point, we are all done with the prefix
    //

    pcfmPrefix->Release();

    if (pcfmRelPath == NULL)
    {
        *ppmkRelPath = NULL;
        return ResultFromScode(S_OOM);
    }

    *ppmkRelPath = pcfmRelPath;
    return NOERROR;

}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::GetDisplayNameLength
//
//  Synopsis:   Returns the length of the display name if GenerateDisplayName
//              was called
//
//  Effects:
//
//  Returns:    Length of display name in bytes
//
//  Algorithm:
//
//  History:    3-16-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG
CFileMoniker::GetDisplayNameLength()
{
    CLock2 lck(m_mxs);   // protect all internal state

    // Number of characters in path plus number of anti components plus NULL
    // All times the size of WCHAR
    //
    // Anti components look like '..\' in the string. 3 characters
    ULONG ulLength = (m_ccPath + (3 * m_cAnti) + 1) * sizeof(WCHAR);

    return(ulLength);
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::GenerateDisplayName, private
//
//  Synopsis:   Generates a display name for this moniker.
//
//  Effects:
//
//  Arguments:  [pwcDisplayName] -- A buffer that is at least as long as
//                                  GetDisplayNameLength
//
//  Returns:    void
//
//  Algorithm:
//
//  History:    3-16-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
CFileMoniker::GenerateDisplayName(LPWSTR pwcDisplayName)
{
    Assert(pwcDisplayName != NULL);

    //
    // The display name may need 'dotdots' at the front
    //
    for (USHORT i = 0; i < m_cAnti; i++)
    {
        memcpy(pwcDisplayName, L"..\\", 3 * sizeof(WCHAR));
        pwcDisplayName += 3;
    }

    //
    //  don't duplicate '\' since the anti monikers may
    //  have already appended one. Copy rest of string
    //  over, including the NULL
    //

    if (m_cAnti > 0 && *m_szPath == '\\')
    {
        memcpy(pwcDisplayName, m_szPath + 1, m_ccPath * sizeof(WCHAR));
    }
    else
    {
        memcpy(pwcDisplayName, m_szPath, (m_ccPath + 1) * sizeof(WCHAR));
    }
}

STDMETHODIMP CFileMoniker::GetDisplayName ( LPBC pbc, LPMONIKER
    pmkToLeft, LPWSTR FAR * lplpszDisplayName )
{

    HRESULT         hr  = E_FAIL;

    CLock2 lck(m_mxs);   // protect all internal state

    wValidateMoniker();
    M_PROLOG(this);
    VDATEPTROUT (lplpszDisplayName, LPWSTR);
    *lplpszDisplayName = NULL;
    VDATEIFACE (pbc);
    if (pmkToLeft)
    {
        VDATEIFACE (pmkToLeft);
    }

    int n;
    LPWSTR pch;
    LPWSTR pchSrc;
    DWORD cchSrc;
    DWORD ulLen;


    ulLen = GetDisplayNameLength();

    //
    // cchSrc is the number of characters including the NULL. This will
    // always be half the number of bytes.
    //

    cchSrc = ulLen >> 1;

    (*lplpszDisplayName) = (WCHAR *) CoTaskMemAlloc(ulLen);

    pch = *lplpszDisplayName;

    if (!pch)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //
    // Call a common routine to generate the initial display name
    //
    GenerateDisplayName(pch);

    // If we're in WOW, return short path names so that 16-bit apps
    // don't see names they're not equipped to handle.  This also
    // affects 32-bit inproc DLLs in WOW; they'll need to be written
    // to handle it
    if (IsWOWProcess())
    {
        DWORD cchShort, cchDone;
        LPOLESTR posCur;

        posCur = *lplpszDisplayName;

        // GetShortPathName only works on files that exist.  Monikers
        // don't have to refer to files that exist, so if GetShortPathName
        // fails we just return whatever the moniker has as a path

        // Special case zero-length paths since the length returns from
        // GetShortPathName become ambiguous when zero characters are processed
        cchShort = lstrlenW(posCur);
        if (cchShort > 0)
        {
            cchShort = GetShortPathName(posCur, NULL, 0);
        }

        if (cchShort != 0)
        {
            LPOLESTR posShort;

            // GetShortPathName can convert in place so if our source
            // string is long enough, don't allocate a new string
            if (cchShort <= cchSrc)
            {
                posShort = posCur;
                cchShort = cchSrc;
            }
            else
            {
                posShort = (LPOLESTR)CoTaskMemAlloc(cchShort*sizeof(WCHAR));
                if (posShort == NULL)
                {
                    CoTaskMemFree(posCur);
                    *lplpszDisplayName = NULL;
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }
            }
            cchDone = GetShortPathName(posCur, posShort, cchShort);

            // For both success and failure cases we're done with posCur,
            // so get rid of it (unless we've reused it for the short name)
            if (posShort != posCur)
            {
                CoTaskMemFree(posCur);
            }

            if (cchDone == 0 || cchDone > cchShort)
            {
                CoTaskMemFree(posShort);
                *lplpszDisplayName = NULL;
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            *lplpszDisplayName = posShort;
        }
    }

    hr = NOERROR;

Exit:

    return( hr );

}



//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::ParseDisplayName
//
//  Synopsis:   Bind to object, and ask it to parse the display name given.
//
//  Effects:
//
//  Arguments:  [pbc] --        Bind context
//              [pmkToLeft] --  Moniker to the left
//              [lpszDisplayName] -- Display name to be parsed
//              [pchEaten] --   Outputs the number of characters parsed
//              [ppmkOut] --    Output moniker
//
//  Requires:
//      File-monikers never have monikers to their left
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-02-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::ParseDisplayName ( LPBC pbc,
                                              LPMONIKER pmkToLeft,
                                              LPWSTR lpszDisplayName,
                                              ULONG FAR* pchEaten,
                                              LPMONIKER FAR* ppmkOut)
{

    HRESULT hresult;
    IParseDisplayName * pPDN = NULL;
    CLSID cid;

    VDATEPTROUT (ppmkOut, LPMONIKER);

    *ppmkOut = NULL;

    VDATEIFACE (pbc);

    if (pmkToLeft)
    {
        VDATEIFACE (pmkToLeft);
    }

    VDATEPTRIN (lpszDisplayName, WCHAR);
    VDATEPTROUT (pchEaten, ULONG);

    //
    // Since this is the most frequent case, try binding to the object
    // itself first
    //

    hresult = BindToObject( pbc,
                            pmkToLeft,
                            IID_IParseDisplayName,
                            (VOID FAR * FAR *)&pPDN );

    // we deferred doing this lock until after the BindToObject, in case the
    // BindToObject is very slow.  It manages locking internally to itself.
    CLock2 lck(m_mxs);   // protect all internal state


    // If binding to the object failed, then try binding to the class object
    // asking for the IParseDisplayName interface
    if (FAILED(hresult))
    {
        hresult = GetClassFile(m_szPath, &cid);

        if (SUCCEEDED(hresult))
        {
            hresult = CoGetClassObject(cid,
                                       CLSCTX_INPROC | CLSCTX_NO_CODE_DOWNLOAD,
                                       NULL,
                                       IID_IParseDisplayName,
                                       (LPVOID FAR*)&pPDN);
        }
        if (FAILED(hresult))
        {
            goto errRet;
        }
    }

    //
    // Now that we have bound this object, we register it with the bind
    // context. It will be released with the bind context release.
    //

    hresult = pbc->RegisterObjectBound(pPDN);

    if (FAILED(hresult))
    {
        goto errRet;
    }

    //
    // As the class code to parse the rest of the display name for us.
    //

    hresult = pPDN->ParseDisplayName(pbc,
                                     lpszDisplayName,
                                     pchEaten,
                                     ppmkOut);
errRet:
    if (pPDN) pPDN->Release();
    return hresult;
}


STDMETHODIMP CFileMoniker::IsSystemMoniker (THIS_ LPDWORD pdwType)
{
    M_PROLOG(this);
    VDATEPTROUT (pdwType, DWORD);
    *pdwType = MKSYS_FILEMONIKER;
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::ValidateAnsiPath
//
//  Synopsis:   This function validates the ANSI version of the path. Intended
//              to be used to get the serialized Ansi version of the path.
//
//              This function also detects when a Long File Name exists, and
//              must be dealt with.
//
//  Effects:
//
//      This routine will set the Ansi path suitable for serializing
//      into the stream. This path may just use the stored ANSI path,
//      or may be a path that was created from the UNICODE version.
//
//      If the ANSI version of the path doesn't exist, then the UNICODE
//      version of the path is converted to ANSI. There are several possible
//      conversions.
//
//      First, if the path uses a format that is > 8.3, then the path to
//      be serialized needs to be the alternate name. This allows the
//      downlevel systems to access the file using the short name. This step
//
//      If the UNICODE path is all ANSI characters already (no DBCSLeadBytes),
//      then the path is converted by doing a simple truncation algorithm.
//
//      If the UNICODE path contains large characters, or DBCSLeadBytes,
//      then the routine will create a UNICODE extent, then try to convert
//      the UNICODE string into a ANSI path. If some of the characters
//      won't convert, then those characters are represented by an ANSI
//      character constant defined in the registry.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//              m_pszAnsiPath
//              m_cbAnsiPath
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-09-94   kevinro   Created
//              05-24-94    AlexT   Use GetShortPathNameW
//
//  Notes:
//
//      The path created may not actually be useful. It is quite possible
//      for there to be a path that will not convert correctly from UNICODE
//      to Ansi. In these cases, this routine will create a UNICODE extent.
//
//----------------------------------------------------------------------------

HRESULT CFileMoniker::ValidateAnsiPath(void)
{
    HRESULT hr = NOERROR;
    CLock2 lck(m_mxs);   // protect m_pszAnsiPath, and m_cbAnsiPath
                       // also AddExtent (needed since mutext was removed from CExtentList).

    wValidateMoniker();

    mnkDebugOut((DEB_ITRACE,
                 "GetAnsiPath(%x) m_szPath(%ws)\n",
                 this,
                 m_szPath?m_szPath:L"<NULL>"));



    BOOL  fFastConvert = FALSE;

    //
    // If there is no path, return NULL
    //
    if (m_szPath == NULL)
    {
        goto NoError;
    }

    //
    // If there is already an ANSI path, return, we are OK.
    //

    if (m_pszAnsiPath != NULL)
    {
        goto NoError;
    }

    //  We can't call GetShortPathName with a NULL string.  m_szPath can
    //  be "" as the result of CoCreateInstance of a file moniker or as
    //  the result of RelativePathTo being called on an identical file moniker
    if ('\0' != *m_szPath)
    {
        OLECHAR szShortPath[MAX_PATH];
        DWORD dwBytesCopied;

        dwBytesCopied = GetShortPathName(m_szPath, szShortPath, MAX_PATH);

        if (dwBytesCopied > 0 && dwBytesCopied <= MAX_PATH)
        {
            hr = MnkUnicodeToMulti(szShortPath,
                                   (USHORT) lstrlenW(szShortPath),
                                   m_pszAnsiPath,
                                   m_cbAnsiPath,
                                   fFastConvert);
            if (FAILED(hr))
            {
                mnkDebugOut((DEB_ITRACE,
                            "MnkUnicodeToMulti failed (%x) on %ws\n",
                            WIDECHECK(szShortPath)));
                goto ErrRet;
            }
        }

#if DBG==1
        if (0 == dwBytesCopied)
        {
            mnkDebugOut((DEB_ITRACE,
                        "GetShortPathName failed (%x) on %ws\n",
                         GetLastError(),
                         WIDECHECK(szShortPath)));

            //  let code below handle the path
        }
        else if (dwBytesCopied > MAX_PATH)
        {
            mnkDebugOut((DEB_ITRACE,
                        "GetShortPathName buffer not large enough (%ld, %ld)\n",
                         MAX_PATH, dwBytesCopied,
                         WIDECHECK(szShortPath)));

            //  let code below handle the path
        }
#endif  //  DBG==1
    }

    //
    // If there is no m_pszAnsiPath yet, then just convert
    // the UNICODE path to the ANSI path
    //
    if (m_pszAnsiPath == NULL)
    {
        //
        // There was no alternate file name
        //
        hr = MnkUnicodeToMulti(  m_szPath,
                                 m_ccPath,
                                 m_pszAnsiPath,
                                 m_cbAnsiPath,
                                 fFastConvert);
        if (FAILED(hr))
        {
            goto ErrRet;
        }
    }
    else
    {
        //
        // We have an alternate name. By setting
        // fFastConvert to be FALSE, we force the
        // following code to add a UNICODE extent
        // if one doesn't exist.
        //
        fFastConvert = FALSE;
    }

    //
    // If an extent doesn't already exist, and it wasn't a fast
    // conversion, create a UNICODE extent.
    //
    if ( !m_fUnicodeExtent && !fFastConvert)
    {
        LPMONIKEREXTENT pExtent = NULL;

        hr = CopyPathToUnicodeExtent(m_szPath,m_ccPath,pExtent);

        if (FAILED(hr))
        {
            goto ErrRet;
        }

        hr = m_ExtentList.AddExtent(pExtent);

        PrivMemFree(pExtent);

        if (FAILED(hr))
        {
            goto ErrRet;
        }
    }

NoError:

    mnkDebugOut((DEB_ITRACE,
                 "GetAnsiPath(%x) m_pszAnsiPath(%s) m_cbAnsiPath(0x%x)\n",
                 this,
                 m_pszAnsiPath?m_pszAnsiPath:"<NULL>",
                 m_cbAnsiPath));
    return(NOERROR);

ErrRet:
        mnkDebugOut((DEB_IERROR,
                 "GetAnsiPath(%x) Returning error hr(%x)\n",
                 this,
                 hr));

        if (m_pszAnsiPath != NULL)
        {
        PrivMemFree(m_pszAnsiPath);

        m_pszAnsiPath = NULL;
        m_cbAnsiPath = 0;

    }
    wValidateMoniker();

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   MnkUnicodeToMulti
//
//  Synopsis:   Convert a Unicode path to an Ansi path.
//
//  Effects:
//
//  Arguments:  [pwcsWidePath] --  Unicode path
//              [ccWidePath] --    Wide character count
//              [pszAnsiPath] --   Reference
//              [cbAnsiPath] --    ref number of bytes in ANSI path incl NULL
//              [fFastConvert] --  Returns TRUE if fast conversion
//
//  Requires:
//
//  Returns:
//
//      pszAnsiPath was allocated using PrivMemAlloc
//
//      fFastConvert means that the ANSI and UNICODE paths were converted
//      by WCHAR->CHAR truncation.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
MnkUnicodeToMulti(LPWSTR        pwcsWidePath,
                  USHORT        ccWidePath,
                  LPSTR &       pszAnsiPath,
                  USHORT &      cbAnsiPath,
                  BOOL &        fFastConvert)
{

    HRESULT hr = NOERROR;
    ULONG cb;
    BOOL  fUsedDefaultChar = FALSE;

    WCHAR *lp = pwcsWidePath;

    fFastConvert = TRUE;

    if (pwcsWidePath == NULL)
    {
        cbAnsiPath = 0;
        pszAnsiPath = 0;
        return(NOERROR);
    }

    //
    // Lets hope for the best. If we can run the length of the
    // unicode string, and all the characters are 1 byte long, and
    // there are no conflicts with DBCSLeadBytes, then we
    // can cheat and just do a truncation copy
    //


    while ( (*lp != 0) && (*lp == (*lp & 0xff)) && !IsDBCSLeadByte(*lp & 0xff))
    {
        lp++;
    }
    if (*lp == 0)
    {
        //
        // We are at the end of the string, and we are safe to do our
        // simple copy. We will assume the ANSI version of the path is
        // going to have the same number of characters as the wide path
        //
        pszAnsiPath = (char *)PrivMemAlloc(ccWidePath + 1);

        if (pszAnsiPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto ErrRet;
        }

        USHORT i;

        //
        // By doing i <= m_ccPath, we pick up the NULL
        //

        for (i = 0 ; i <= ccWidePath ; i++ )
        {
            pszAnsiPath[i] = pwcsWidePath[i] & 0xff;
        }

        //
        // We just converted to a single byte path. The cb is the
        // count of WideChar + 1 for the NULL
        //
        cbAnsiPath = ccWidePath + 1;

        goto NoError;
    }

    //
    // At this point, all of the easy out options have expired. We
    // must convert the path the hard way.
    //

    fFastConvert = FALSE;

    mnkDebugOut((DEB_ITRACE,
                 "MnkUnicodeToMulti(%ws) doing path conversions\n",
                 pwcsWidePath?pwcsWidePath:L"<NULL>"));

    //
    // We haven't a clue how large this path may be in bytes, other
    // than some really large number. So, we need to call and find
    // out the correct size to allocate for the path.
    //
    cb = WideCharToMultiByte(AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                             WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                             pwcsWidePath,
                             ccWidePath + 1,    // Convert the NULL
                             NULL,
                             0,
                             NULL,
                             &fUsedDefaultChar);

    if (cb == 0)
    {
        //
        // Hmmm... Can't convert anything. Sounds like the downlevel
        // guys are flat out of luck. This really isn't a hard error, its
        // just an unfortunate fact of life. This is going to be a very
        // rare situation, but one we need to handle gracefully
        //

        pszAnsiPath = NULL;
        cbAnsiPath = 0;
    }
    else
    {
        //
        // cb holds the number of bytes required for the output path
        //
        pszAnsiPath = (char *)PrivMemAlloc(cb + 1);

        if (pszAnsiPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto ErrRet;
        }
        cbAnsiPath = (USHORT)cb;

        cb = WideCharToMultiByte(AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                 WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                                 pwcsWidePath,
                                 ccWidePath + 1, // Convert the NULL
                                 pszAnsiPath,
                                 cbAnsiPath,
                                 NULL,
                                 &fUsedDefaultChar);
        //
        // Again, if there was an error, its just unfortunate
        //
        if (cb == 0)
        {
            PrivMemFree(pszAnsiPath);
            pszAnsiPath = NULL;
            cbAnsiPath = 0;
        }
    }

NoError:

    return(NOERROR);

ErrRet:

    if (pszAnsiPath != NULL)
    {
        PrivMemFree(pszAnsiPath);

        pszAnsiPath = NULL;

        cbAnsiPath = 0;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   MnkMultiToUnicode
//
//  Synopsis:   Converts a MultiByte string to a Unicode string
//
//  Effects:
//
//  Arguments:  [pszAnsiPath] --        Path to convert
//              [pWidePath] --          Output path
//              [ccWidePath] --         Size of output path
//              [ccNewString] --        Reference characters in new path
//                                      including the NULL
//              [nCodePage] --          Must be CP_ACP || CP_OEMCP.  This is
//                                      the first code page to be used in
//                                      the attempted conversion.  If the
//                                      conversion fails, the other CP is
//                                      tried.
//
//  Requires:
//
//      if pWidePath != NULL, then this routine uses pWidePath as the return
//      buffer, which should be ccWidePath in length.
//
//      Otherwise, it will allocate a buffer on your behalf.
//
//  Returns:
//
//      pWidePath != NULL
//              ccNewString == number of characters in new path include NULL
//
//      pWidePath == NULL (NULL string)
//
//      if ccNewString returns 0, then pWidePath may not be valid. In this
//      case, there are no valid characters in pWidePath.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//              2-3-95    scottsk   Added nCodePage param
//
//  Notes:
//
//  Why so complex you ask? In the file moniker case, we want know that the
//  buffer can be MAX_PATH in length, so we pass a stack buffer in to handle
//  it. In the CItemMoniker case, the limit jumps to 32767 bytes, which is
//  too big to declare on the stack. I wanted to use the same routine for
//  both, since we may end up changing this later.
//
//  Passing in your own buffer is best for this routine.
//
//----------------------------------------------------------------------------
HRESULT MnkMultiToUnicode(LPSTR         pszAnsiPath,
                          LPWSTR &      pWidePath,
                          ULONG         ccWidePath,
                          USHORT &      ccNewString,
                          UINT          nCodePage)
{
        LPWSTR  pwcsTempPath = NULL;
        HRESULT hr;

        Assert(nCodePage == CP_ACP || nCodePage == CP_OEMCP);

        //
        // If the pszAnsiPath is NULL, then so should be the UNICODE one
        //
        if (pszAnsiPath == NULL)
        {
            ccNewString = 0;
            return(NOERROR);
        }

        Assert( (pWidePath == NULL) || (ccWidePath > 0));

        //
        // If the buffer is NULL, be sure that ccWide is zero
        //
        if (pWidePath == NULL)
        {
            ccWidePath = 0;
        }


ConvertAfterAllocate:
        ccNewString = (USHORT) MultiByteToWideChar(nCodePage,
                                         MB_PRECOMPOSED,
                                         pszAnsiPath,
                                         -1,
                                         pWidePath,
                                         ccWidePath);
        if (ccNewString == FALSE)
        {
            mnkDebugOut((DEB_IERROR,
                         "::MnkMultiToUnicode failed on (%s) err (%x)\n",
                         pszAnsiPath,
                         GetLastError()));
            //
            // We were not able to convert to UNICODE.
            //
                hr = E_UNEXPECTED;
                goto errRet;
        }


        //
        // ccNewString holds the total string length, including the terminating
        // NULL.
        //

        if (pWidePath == NULL)
        {
            //
            // The first time through did no allocations. Allocate the
            // correct buffer, and actually do the conversion
            //

            pWidePath = (WCHAR *)PrivMemAlloc(sizeof(WCHAR)*ccNewString);

            if (pWidePath == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto errRet;
            }

            pwcsTempPath = pWidePath;
            ccWidePath = ccNewString;
            goto ConvertAfterAllocate;
        }

        //
        // ccNewString holds the total number of characters converted,
        // including the NULL. We really want it to have the count of
        // characeters
        //

        Assert (ccNewString != 0);

        ccNewString--;

        hr = NOERROR;
        return(hr);

errRet:
        mnkDebugOut((DEB_IERROR,
                 "::MnkMultiToUnicode failed on (%s) err (%x)\n",
                 pszAnsiPath,
                 GetLastError()));

        PrivMemFree(pwcsTempPath);
        return(hr);

}
//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::DetermineUnicodePath
//
//  Synopsis:   Given the input path, determine the path to store and use
//              as the initialized path.
//
//  Effects:
//
//      When loading or creating a CFileMoniker, its possible that the 'path'
//      that was serialized is not valid. This occurs when the original
//      UNICODE path could not be translated into ANSI. In this case, there
//      will be a MONIKEREXTENT that holds the original UNICODE based path.
//
//      If a UNICODE extent exists, then the path will be ignored, and the
//      path in the extent will be used.
//
//      If a UNICODE extent doesn't exist, then the path will be translated
//      into UNICODE. In theory, this will not fail, since there is supposed
//      to always be a mapping from ANSI to UNICODE (but not the inverse).
//      However, it is possible that the conversion will fail because the
//      codepage needed to translate the ANSI path to UNICODE may not be
//      loaded.
//
//      In either case, the CFileMoniker::m_szPath should return set
//      with some UNICODE path set. If not, then an error is returned
//
//  Arguments:  [pszPath] --    The ANSI version of the path.
//              [pWidePath] --  Reference to pointer recieving new path
//              [cbWidePath]--  Length of new path
//
//  Requires:
//
//  Returns:
//              pWidePath is returned, as allocated from PrivMemAlloc
//              cbWidePath holds length of new path
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CFileMoniker::DetermineUnicodePath(LPSTR pszAnsiPath,
                                   LPWSTR & pWidePath,
                                   USHORT &ccWidePath)
{

    wValidateMoniker();

    mnkDebugOut((DEB_ITRACE,
                 "DetermineUnicodePath(%x) pszAnsiPath(%s)\n",
                 this,
                 pszAnsiPath));

    HRESULT hr = NOERROR;

    //
    // Check to see if a MONIKEREXTENT exists with mnk_UNICODE
    //

    MONIKEREXTENT UNALIGNED *pExtent = m_ExtentList.FindExtent(mnk_UNICODE);

    //
    // Normal fall through case is no UNICODE path, which means that there
    // was a conversion between mbs and unicode in the original save.
    //
    if (pExtent == NULL)
    {
        m_fUnicodeExtent = FALSE;

        //
        // If the pszAnsiPath is NULL, then so should be the UNICODE one
        //
        if (pszAnsiPath == NULL)
        {
            pWidePath = NULL;
            ccWidePath = 0;
            return(NOERROR);
        }

        //
        // It turns out to be cheaper to just assume a MAX_PATH size
        // buffer, and to copy the resulting string. We use MAX_PATH + 1
        // so we always have room for the terminating NULL
        //

        WCHAR awcTempPath[MAX_PATH+1];
        WCHAR *pwcsTempPath = awcTempPath;

        hr = MnkMultiToUnicode( pszAnsiPath,
                                pwcsTempPath,
                                MAX_PATH+1,
                                ccWidePath,
                                AreFileApisANSI() ? CP_ACP : CP_OEMCP);


        if (FAILED(hr))
        {
            goto errRet;
        }

        pWidePath = (WCHAR *)PrivMemAlloc(sizeof(WCHAR)*(ccWidePath+1));

        if (pWidePath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto errRet;
        }

        memcpy(pWidePath,pwcsTempPath,(ccWidePath+1)*sizeof(WCHAR));

        hr = NOERROR;

    }
    else
    {
        //
        // Get the UNICODE path from the extent.
        //

        mnkDebugOut((DEB_ITRACE,
                     "DeterminePath(%x) Found UNICODE extent\n",
                     this));

        m_fUnicodeExtent = TRUE;

        hr = CopyPathFromUnicodeExtent(pExtent,pWidePath,ccWidePath);
    }


errRet:


    if (FAILED(hr))
    {
        if (pWidePath != NULL)
        {
            PrivMemFree(pWidePath);
        }

        mnkDebugOut((DEB_IERROR,
                     "DeterminePath(%x) ERROR: Returning %x\n",
                     this,
                     hr));
    }
    else
    {
        mnkDebugOut((DEB_ITRACE,
                     "DeterminePath(%x) pWidePath(%ws) ccWidePath(0x%x)\n",
                     this,
                     pWidePath?pWidePath:L"<NULL PATH>",
                     ccWidePath));

    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::GetComparisonData
//
//  Synopsis:   Get comparison data for registration in the ROT
//
//  Arguments:  [pbData] - buffer to put the data in.
//              [cbMax] - size of the buffer
//              [pcbData] - count of bytes used in the buffer
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//  Algorithm:  Build ROT data for file moniker. This puts the classid
//              followed by the display name.
//
//  History:    03-Feb-95   ricksa  Created
//
// Note:        Validating the arguments is skipped intentionally because this
//              will typically be called internally by OLE with valid buffers.
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::GetComparisonData(
    byte *pbData,
    ULONG cbMax,
    DWORD *pcbData)
{
    mnkDebugOut((DEB_ITRACE,
                 "_IN GetComparisionData(%x,%x,%x) for CFileMoniker(%ws)\n",
                 pbData,
                 cbMax,
                 *pcbData,
                 m_szPath));

    CLock2 lck(m_mxs);   // protect all internal state

    ULONG ulLength = sizeof(CLSID_FileMoniker) + GetDisplayNameLength();

    Assert(pcbData != NULL);
    Assert(pbData != NULL);

    if (cbMax < ulLength)
    {
        mnkDebugOut((DEB_ITRACE,
                     "OUT GetComparisionData() Buffer Too Small!\n"));

        return(E_OUTOFMEMORY);
    }

    memcpy(pbData,&CLSID_FileMoniker,sizeof(CLSID_FileMoniker));

    GenerateDisplayName((WCHAR *)(pbData+sizeof(CLSID_FileMoniker)));

    //
    // Insure this is an upper case string.
    //
    CharUpperW((WCHAR *)(pbData+sizeof(CLSID_FileMoniker)));

    *pcbData = ulLength;

    mnkDebugOut((DEB_ITRACE,
                 "OUT GetComparisionData() *pcbData == 0x%x\n",
                 *pcbData));

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTrackingFileMoniker::*
//
//  Synopsis:   These members implement ITrackingMoniker on behalf of
//              the file moniker.
//
//  Algorithm:  The CTrackingFileMoniker object has a pointer to
//              the CFileMoniker object and forwards any QI's (other than
//              ITrackingMoniker) and AddRefs/Releases to the CFileMoniker.
//
//----------------------------------------------------------------------------

#ifdef _TRACKLINK_
VOID
CTrackingFileMoniker::SetParent(CFileMoniker *pCFM)
{
    _pCFM = pCFM;
}

STDMETHODIMP CTrackingFileMoniker::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(IID_ITrackingMoniker, riid))
    {
        *ppv = (ITrackingMoniker*) this;
        _pCFM->AddRef();
        return(S_OK);
    }
    else
        return(_pCFM->QueryInterface(riid, ppv));
}

STDMETHODIMP_(ULONG) CTrackingFileMoniker::AddRef()
{
    return(_pCFM->AddRef());
}

STDMETHODIMP_(ULONG) CTrackingFileMoniker::Release()
{
    return(_pCFM->Release());
}

STDMETHODIMP CTrackingFileMoniker::EnableTracking( IMoniker *pmkToLeft, ULONG ulFlags )
{
    return(_pCFM->EnableTracking(pmkToLeft, ulFlags));
}
#endif

#ifdef _DEBUG
STDMETHODIMP_(void) NC(CFileMoniker,CDebug)::Dump ( IDebugStream FAR * pdbstm)
{
    VOID_VDATEIFACE(pdbstm);

    *pdbstm << "CFileMoniker @" << (VOID FAR *)m_pFileMoniker;
    *pdbstm << '\n';
    pdbstm->Indent();
    *pdbstm << "Refcount is " << (int)(m_pFileMoniker->m_refs) << '\n';
    *pdbstm << "Path is " << m_pFileMoniker->m_szPath << '\n';
    *pdbstm << "Anti count is " << (int)(m_pFileMoniker->m_cAnti) << '\n';
    pdbstm->UnIndent();
}



STDMETHODIMP_(BOOL) NC(CFileMoniker,CDebug)::IsValid ( BOOL fSuspicious )
{
    return ((LONG)(m_pFileMoniker->m_refs) > 0);
    //  add more later, maybe
}
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::RestoreShellLink, private
//
//  Synopsis:   Restore a ShellLink object by creating it, and
//              loading the object's persistent state from the Extent
//              of this Moniker (where the state was saved by an earlier
//              instantiation).
//
//  Arguments:  pfExtentNotFound (optional)
//                  When this method fails, this argument can be checked
//                  to see if the failure was because the extent
//                  didn't exist.
//
//  Returns:    [HRESULT]
//                  -   S_FALSE:  the shell link had already been restored.
//
//  Algorithm:  If ShellLink object doesn't already exist
//                  GetShellLink()
//                  Load ShellLink object from moniker Extent.
//                  On Error,
//                      Release ShellLink
//
//  Notes:      -   This routine does not restore the information
//                  in mnk_TrackingInformation.  This is restored
//                  in Load().
//
//----------------------------------------------------------------------------

INTERNAL CFileMoniker::RestoreShellLink( BOOL *pfExtentNotFound )
{

    MONIKEREXTENT UNALIGNED *   pExtent;
    LARGE_INTEGER               li0;
    ULARGE_INTEGER              uli;
    HRESULT                     hr = E_FAIL;
    IStream *                   pstm = NULL;
    IPersistStream *            pps = NULL;

    if( NULL != pfExtentNotFound )
        *pfExtentNotFound = FALSE;

    // If we've already, successfully, initialized the shell link object,
    // then we're done.

    if( m_fShellLinkInitialized )
    {
        hr = S_FALSE;
        goto Exit;
    }

    // Create the ShellLink object.

    if( FAILED( hr = GetShellLink() ))
        goto Exit;
    Assert( m_pShellLink != NULL );

    //
    // Load ShellLink from Extent list by
    // writing the MONIKEREXTENT to an in memory stream and then doing
    // IPersistStream::Load.
    //

    pExtent = m_ExtentList.FindExtent(mnk_ShellLink);
    if (pExtent == NULL)    // no extent, exit.
    {
        // Let the caller know that we failed because the extent doesn't exist.
        if( NULL != pfExtentNotFound )
            *pfExtentNotFound = TRUE;

        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::RestoreShellLink no shell link in extent.\n",
                     this));
        hr = E_FAIL;
        goto Exit;
    }

    if (S_OK != (hr=CreateStreamOnHGlobal(NULL, TRUE, &pstm)))
    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::RestoreShellLink CreateStreamOnHGlobal failed %08X.\n",
                     this,
                     hr));
        goto Exit;
    }

    if (S_OK != (hr=pstm->Write(((char*)pExtent)+MONIKEREXTENT_HEADERSIZE,
        pExtent->cbExtentBytes,
        NULL)))
    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::RestoreShellLink pstm->Write failed %08X.\n",
                     this,
                     hr));
        goto Exit;
    }

    // Get the Shell Link's IPersistStream interface, and
    // load it with the data from the Extent.

    Verify(S_OK == m_pShellLink->QueryInterface(IID_IPersistStream,
        (void**)&pps));

    memset(&li0, 0, sizeof(li0));
    Verify(S_OK == pstm->Seek(li0, STREAM_SEEK_SET, &uli));
    Assert(uli.LowPart == 0 && uli.HighPart == 0);

    if (S_OK != (hr=pps->Load(pstm)))
    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::RestoreShellLink pps->Load failed %08X.\n",
                     this,
                     hr));
        goto Exit;
    }

    m_fShellLinkInitialized = TRUE;

    mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::RestoreShellLink successfully loaded shell link (%08X) from extent.\n",
                 this,
                 m_pShellLink));

    //  ----
    //  Exit
    //  ----

Exit:

    if( FAILED( hr ))
    {
        if( m_pShellLink )
        {
            m_pShellLink->Release();
            m_pShellLink = NULL;
        }
    }

    return( hr );

}   // RestoreShellLink()




//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::SetPathShellLink, private
//
//  Synopsis:   Set the path in the ShellLink object.
//
//  Arguments:  [void]
//
//  Returns:    [HRESULT]
//                  -   S_OK:  The path is set successfully.
//                  -   S_FALSE:  The path was not set.
//
//  Algorithm:  If a SetPath isn't necessary/valid, exit (S_OK).
//              Get the ShellLink object (create if necessary)
//              Perform IShellLink->SetPath()
//              If this succeeds, set the m_fShellLinkInitialized
//
//  Notes:      Setting the path in the ShellLink object causes it to
//              read data (attributes) from the file.  This data makes that
//              file trackable later on if the file is moved.  This routine
//              can be called any number of times, since it exits early if
//              it has executed sucessfully before.  Success is indicated by
//              the m_fShellLinkInitialized flag.
//
//----------------------------------------------------------------------------


INTERNAL CFileMoniker::SetPathShellLink()
{

    HRESULT          hr = S_FALSE;
    IPersistStream*  pps = NULL;
    LPCTSTR          ptszPath = NULL;

    WIN32_FILE_ATTRIBUTE_DATA fadLinkSource;

    //  ----------
    //  Initialize
    //  ----------

    // If the path has already been set, then we needn't do anything.

    if( m_fShellLinkInitialized )
    {
        hr = S_OK;
        goto Exit;
    }


    // If necessary, create the ShellLink object.

    if( FAILED( hr = GetShellLink() ))
        goto Exit;
    Assert( m_pShellLink != NULL );

    //  ----------------------------------
    //  Get the correct path into ptszPath
    //  ----------------------------------

#ifdef _CHICAGO_

    char *pszAnsiPath;
    USHORT cbAnsiPath;
    BOOL fFastConvert;

    hr = MnkUnicodeToMulti(m_szPath,
        lstrlenW(m_szPath),
        pszAnsiPath,
        cbAnsiPath,
        fFastConvert);

    if( FAILED( hr ))
    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::SetPathShellLink(%ls) -- Could not convert Unicode to Ansi\n",
                 this,
                 m_szPath));
        goto Exit;
    }
    ptszPath = pszAnsiPath;

#else // !_CHICAGO_

    ptszPath = m_szPath;

#endif // !_CHICAGO_

    //  ------------------------------
    //  Set the path of the shell link
    //  ------------------------------

    hr = m_pShellLink->SetPath( (char *) ptszPath );

#ifdef _CHICAGO_
    PrivMemFree( (void *) ptszPath);
#endif

    // Was the link source missing?

    if (S_FALSE == hr)
    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::SetPathShellLink(%ls) -- readtrackinginfo -- NOT FOUND\n",
                 this,
                 m_szPath));
    }

    else if (SUCCEEDED(hr))
    {

        // Remember that we've done this so we won't have to again.

        m_fShellLinkInitialized = TRUE;

        // Set the moniker's dirty bit according to the ShellLink's
        // dirty bit.  (It should be dirty.)

        Verify (S_OK == m_pShellLink->
            QueryInterface(IID_IPersistStream, (void**)&pps));
        if (pps->IsDirty() == S_OK)
        {
            m_fDirty = TRUE;
        }
        else
        {
            mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::SetPathShellLink(%ls) -- IsDirty not dirty\n",
                     this,
                     m_szPath));

        }

    }   // ShellLink->SetPath ... if (SUCCEEDED(hr))
    else
    {
        mnkDebugOut((DEB_TRACK,
             "CFileMoniker(%x)::SetPathShellLink(%ls) -- m_pShellLink->SetPath failed %08X.\n",
                 this,
                 m_szPath,
                 hr));

    }   // ShellLink->SetPath ... if (SUCCEEDED(hr)) ... else


    //  ----
    //  Exit
    //  ----

Exit:

    if( pps )
        pps->Release();

    return( hr );

}   // CFileMoniker::SetPathShellLink()


//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::ResolveShellLink, private
//
//  Synopsis:   Perform an IShellLink->Resolve, and updates the data
//              in this moniker accordingly.
//
//  Arguments:  [IBindCtx*] pbc
//                  -   The caller's bind context.
//
//  Outputs:    [HRESULT]
//                  S_OK if the link is successfully resolved.
//                  S_FALSE if the link is not resolved, but there were no errors.
//
//  Algorithm:  Get the caller's Bind_Opts
//              Get IShellLinkTracker from the ShellLink object.
//              Perform IShellLinkTracker->Resolve
//              Set the dirty flag if necessary.
//              If we found a new path
//                  ReInitialize this moniker with the new path.
//
//  Notes:      This routine does not restore the information in
//              mnk_TrackingInformation.  The information is restored
//              Load().
//
//----------------------------------------------------------------------------

INTERNAL CFileMoniker::ResolveShellLink( BOOL fRefreshOnly )
{

    HRESULT             hr = E_FAIL;
    IPersistStream*     pps = NULL;

    WCHAR *             pwszWidePath = NULL;   // Path in Unicode format
    char *              ptszPath = NULL;       // Path in either ANSI or Unicode

    USHORT              ccNewString = 0;
    DWORD               dwTrackFlags = 0L;
    DWORD               dwTickCountDeadline = 0L;
    USHORT              ccPathBufferSize = 0;
    DWORD               dwResolveFlags = 0;


    // Restore the shell link, if it hasn't been already.

    if( FAILED( hr = RestoreShellLink(NULL) ))
        goto Exit;

    Assert( m_pShellLink != NULL );

    // Figure out the resolve flags.  The 0xFFFF0000
    // is a test hook to indicate that the timeout should
    // be read from the registry.

    dwResolveFlags = 0xFFFF0000 | SLR_ANY_MATCH | SLR_NO_UI;

    if( fRefreshOnly )
    {
        // If the file exists, update the shortcut's cached
        // information (object ID, create date, file size, etc.).
        // If it doesn't exist, don't go looking for it.

        dwResolveFlags |= SLR_NOTRACK | SLR_NOSEARCH | SLR_NOLINKINFO;
    }

    // Finally, resolve the link.


    if (S_OK != (hr = m_pShellLink->Resolve( GetDesktopWindow(), dwResolveFlags )))
    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::ResolveShellLink IShellLink->Resolve failed %08X.\n",
                     this,
                     hr));
        goto Exit;
    }


    //
    // The above Resolve may have made the Shell Link object dirty,
    // in which case this FileMoniker should be dirty as well.
    //

    Verify(S_OK == m_pShellLink->QueryInterface(IID_IPersistStream,
                                                (void**)&pps));

    if (pps->IsDirty() == S_OK)
    {
        m_fDirty = TRUE;
    }


    //
    // We appear to have found a matching file.  We will
    // check that we can activate it properly before updating
    // the file moniker's internal path.
    // Before we can attempt activation we might have to get the
    // path into unicode.
    //

#ifdef _CHICAGO_
    ccPathBufferSize = MAX_PATH + sizeof( '\0' );
#else
    ccPathBufferSize = sizeof( WCHAR ) * MAX_PATH + sizeof( L'\0' );
#endif

    ptszPath = (char*)PrivMemAlloc( ccPathBufferSize );
    if (ptszPath == NULL)
    {
        hr = E_OUTOFMEMORY;
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::ResolveShellLink PrivMemAlloc failed.\n",
                     this));
        goto Exit;
    }

    WIN32_FIND_DATA fd;
    if (S_OK != (hr=m_pShellLink->GetPath(ptszPath,
                MAX_PATH, &fd, IsWOWProcess() ? SLGP_SHORTPATH : 0)))

    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::ResolveShellLink m_pShellLink->GetPath failed %08X.\n",
                     this,
                     hr));
        goto Exit;
    }

#ifdef _CHICAGO_

    // Convert the path to Unicode.

    hr = MnkMultiToUnicode(ptszPath,
            pwszWidePath /*OUT*/,
            0,
            ccNewString, /*OUT*/
            CP_OEMCP );
    if (hr != S_OK)
    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::ResolveShellLink MnkUnicodeToMulti failed %08X.\n",
                     this,
                     hr));
        goto Exit;
    }


#else // !_CHICAGO_

    // The path is already in Unicode.  Transfer responsibility
    // from 'ptszPath' to 'pwszWidePath'.

    pwszWidePath = (WCHAR *) ptszPath;
    ptszPath = NULL;
    ccNewString = (USHORT) -1;

#endif // !_CHICAGO_


    // Verify that we received an actual path from IShellLink::GetPath.

    if (*pwszWidePath == L'\0' || ccNewString == 0)
    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::ResolveShellLink MnkUnicodeToMulti failed 2 %08X.\n",
                     this,
                     hr));
        hr = E_FAIL;
        goto Exit;
    }

    //
    // If the path to the linked file has changed, update the internal
    // state of this File Moniker.
    //

    if( lstrcmpW( pwszWidePath, m_szPath )) // Cmp wide path; Ansi may not exist.
    {

        // Re-initialize this moniker with the new
        // path.  We will save and restore the fClassVerified, because
        // if it is set we might avoid a redundant verification.

        BOOL fClassVerified = m_fClassVerified;

        if( !Initialize(m_cAnti,
                        ptszPath,   // Either the ANSI path or NULL
                        ptszPath ? strlen( ptszPath ) + 1 : 0,
                        pwszWidePath,
                        (USHORT) lstrlenW( pwszWidePath ),
                        m_endServer )
          )
        {
            mnkDebugOut((DEB_TRACK,
                         "CFileMoniker(%x)::ResolveShellLink Initialize (with new path) failed.\n",
                         this));
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        // Restore the previous fClassVerified.

        if( !m_fClassVerified )
            m_fClassVerified = fClassVerified;

        // The paths are now the responsibility of the CFileMoniker.

        ptszPath = NULL;
        pwszWidePath = NULL;

    }   // if( !strcmp( pszAnsiPath, m_szPath )

    //  ----
    //  Exit
    //  ----

Exit:

    if( pps )
        pps->Release();

    if (ptszPath)
        PrivMemFree(ptszPath);

    if (pwszWidePath)
        PrivMemFree(pwszWidePath);

    return( hr );

}   // CFileMoniker::ResolveShellLink()



#ifdef _CAIRO_

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::GetTrackFlags, private
//
//  Synopsis:   Get the TrackFlags from the Shell Link object.
//
//  Arguments:  [DWORD *] pdwTrackFlags
//                  -   On return holds the Track Flags.
//
//  Returns:    [HRESULT]
//                  -   E_FAIL is returned if there is no Shell Link object.
//
//  Algorithm:  Use the Tracker interface to get the Track Flags
//
//----------------------------------------------------------------------------

INTERNAL CFileMoniker::GetTrackFlags( DWORD * pdwTrackFlags )
{
    HRESULT hr = E_FAIL;

    *pdwTrackFlags = 0L;

    if (m_pShellLink)
    {
        // Get the Shell Link's Tracker interface.

        hr = GetShellLinkTracker();
        if( FAILED(hr) )
        {
            mnkDebugOut((DEB_TRACK,
                "CFileMoniker(%x)::GetTrackFlags(%ls) -- Could not get ShellLinkTracker (%08X).\n",
                this,
                m_szPath,
                hr));
        }
        else
        {
            Assert( m_pShellLinkTracker != NULL );

            // Ask the SLTracker for the Track Flags.

            hr = m_pShellLinkTracker->GetTrackFlags( pdwTrackFlags );
            if( FAILED(hr) )
            {
                *pdwTrackFlags = 0L;

                mnkDebugOut((DEB_TRACK,
                    "CFileMoniker(%x)::GetTrackFlags(%ls) -- Could not get TrackFlags %08X.\n",
                    this,
                    m_szPath,
                    hr));
            }


        }   // if( FAILED(hr) )
    }   // if (m_pShellLink)


    //  ----
    //  Exit
    //  ----

    return( hr );

}   // CFileMoniker::GetTrackFlags

#endif // _CAIRO_

#ifdef _CAIRO_

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::GetShellLinkTracker, private
//
//  Synopsis:   Ensure that m_pShellLinkTracker is valid, or return error.
//
//  Arguments:  [void]
//
//  Returns:    [HRESULT]
//
//  Algorithm:  if m_pShellLinkTracker is already valid return S_OK, else
//              query the ShellLink object for one.
//
//  Notes:
//
//----------------------------------------------------------------------------


INTERNAL CFileMoniker::GetShellLinkTracker()
{
    HRESULT hr = S_OK;

    if (m_pShellLinkTracker == NULL)
    {
        if( FAILED( hr = GetShellLink()))
            goto Exit;
        Assert( m_pShellLink != NULL );

        hr = m_pShellLink->QueryInterface(IID_IShellLinkTracker,
                                 (void**) &m_pShellLinkTracker );
        if( FAILED(hr) )
        {
            mnkDebugOut((DEB_TRACK,
                "CFileMoniker(%x)::GetShellLinkTracker -- Could not QI(IShellLinkTracker) %08X.\n",
                this,
                hr));
        }
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return( hr );

}   // CFileMoniker::GetShellLinkTracker()

#endif  // _CAIRO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\ccompmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       ccompmon.cxx
//
//  Contents:   Generic Composite Monikers
//
//  Classes:
//
//  Functions:
//
//  History:    12-27-93   ErikGav   Commented
//              02-01-94   KevinRo      Gagged on it, then tried to explain
//              06-14-94   Rickhi    Fix type casting
//              08-08-94   BruceMa   Memory sift fix
//              10-Jan-95  BruceMa   Conform MonikerRelativePathTo to spec
//              03-Apr-96  BruceMa   Fix ::IsEqual
//              22-May-96  BruceMa   Re fix ::IsEqual
//
//
//  Composite monikers are implemented here. A composite moniker is created
//  as a binary tree of monikers, with the leaf nodes of the tree being
//  non-composite monikers.
//
//  Every composite moniker has a left and a right part (otherwise it
//  wouldn't be a composite moniker).  The composition of two monikers
//  involves creating a new composite, and pointing left and right at
//  the two parts of the composite. This is how the binary tree is
//  built.
//
//  (Note: This may not be the most efficient way of implementing this,
//   but it is legacy code we are going to adopt. Sorry!)
//
//  The ordering in the tree is left most. Therefore, there are many
//  possible tree configurations, as long as the leaf nodes evaluate
//  to the same order when done left to right. This is an important point
//  to keep in mind when you are looking at some of the functions, such
//  as AllButFirst, which creates a new composite tree. At first, it doesn't
//  appear to do the correct thing, until you draw it out on paper, and
//  realize that the nodes are still visited in the same order.
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "ccompmon.hxx"
#include "cfilemon.hxx"
#include "mnk.h"
#include <rotdata.hxx>

#include <olepfn.hxx>

INTERNAL_(CCompositeMoniker *) IsCompositeMoniker ( LPMONIKER pmk )
{
    CCompositeMoniker *pCMk;

    if ((pmk->QueryInterface(CLSID_CompositeMoniker, (void **)&pCMk)) == S_OK)
    {
        //  the Release the AddRef done by QI, but still return the ptr
        pCMk->Release();
        return pCMk;
    }

    //  dont rely on user implementations to set pCMk to NULL on failed QI
    return NULL;
}

CCompositeMoniker::CCompositeMoniker( void ) CONSTR_DEBUG
{
    m_pmkLeft = NULL;
    m_pmkRight = NULL;
    m_fReduced = FALSE;

#ifdef _TRACKLINK_
    _tcm.SetParent(this);
    m_fReduceForced = FALSE;
#endif

    //
    // CoQueryReleaseObject needs to have the address of the this objects
    // query interface routine.
    //
    if (adwQueryInterfaceTable[QI_TABLE_CCompositeMoniker] == 0)
    {
        adwQueryInterfaceTable[QI_TABLE_CCompositeMoniker] =
            **(DWORD **)((IMoniker *)this);
    }

}

/*
 *      Implementation of CCompositeMoniker
 */

CCompositeMoniker::~CCompositeMoniker( void )
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::~CCompositeMoniker(%x)\n",
                 this));

        //      REVIEW: this is recursive deletion of what is essentially a linked
        //      list.  A rewrite could save stack space.
        if (m_pmkLeft)
        {
             m_pmkLeft->Release();
        }

        if (m_pmkRight)
        {
            m_pmkRight->Release();
        }
}

//
// Turns out that the classfactory for this moniker will create an empty
// instance by called ::Create(NULL,NULL). The create function has been
// changed to special case this condition, and NOT call initialize.
//

INTERNAL_(BOOL) CCompositeMoniker::Initialize( LPMONIKER pmkFirst,
        LPMONIKER pmkRest)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Initialize(%x)\n",
                 this));
    //
    // Neither moniker can be NULL
    //
    if ((pmkFirst == NULL) || (pmkRest == NULL))
    {
        return(FALSE);
    }

    GEN_VDATEIFACE(pmkFirst, FALSE);
    GEN_VDATEIFACE(pmkRest, FALSE);

    m_pmkLeft = pmkFirst;

    pmkFirst->AddRef(); 

    m_pmkRight = pmkRest;

    pmkRest->AddRef();  

    m_fReduced = IsReduced(pmkFirst) && IsReduced(pmkRest);     

    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::Create
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pmkFirst] --
//              [pmkRest] --
//              [memLoc] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//      We assume that *pmkFirst is not capable of collapsing with *pmkRest;
//      otherwise, this would not have been called.
//
//----------------------------------------------------------------------------
CCompositeMoniker FAR *
CCompositeMoniker::Create( LPMONIKER pmkFirst, LPMONIKER pmkRest)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Create()\n"));

    //
    // Create can be called with both pointers being NULL, in which
    // case the Initialize function need not be called. This is the
    // case when a CompositeMoniker is being loaded from stream.
    //
    // Either both are NULL, or neither is NULL
    //

    if ((pmkFirst == NULL) || (pmkRest == NULL))
    {
        //
        // One of them is NULL. If the other isn't NULL, return an error
        //

        if (pmkFirst != pmkRest)
        {
            return NULL;
        }
    }

    //
    // Both pointers are not NULL, initialize the moniker
    //

    CCompositeMoniker FAR * pCM = new CCompositeMoniker();

    if (pCM != NULL)
    {
            if (pmkFirst != NULL || pmkRest != NULL)
            {
                if (!pCM->Initialize( pmkFirst, pmkRest ))
                {
                    delete pCM;
                    return NULL;
                }
            }
    }

    CALLHOOKOBJECTCREATE(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pCM);
    return pCM;
}


STDMETHODIMP CCompositeMoniker::QueryInterface(THIS_ REFIID riid,
        LPVOID FAR* ppvObj)
{
    VDATEIID (riid);
    VDATEPTROUT(ppvObj, LPVOID);

#ifdef _DEBUG
    if (riid == IID_IDebug)
    {
        *ppvObj = &(m_Debug);
        return NOERROR;
    }
#endif
#ifdef _TRACKLINK_
    if (IsEqualIID(riid, IID_ITrackingMoniker))
    {
        AddRef();
        *ppvObj = (ITrackingMoniker *) & _tcm;
        return(S_OK);
    }
#endif
    if (IsEqualIID(riid, CLSID_CompositeMoniker))
    {
        //  called by IsCompositeMoniker.
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    return CBaseMoniker::QueryInterface(riid, ppvObj);
}


STDMETHODIMP CCompositeMoniker::GetClassID (THIS_ LPCLSID lpClassID)
{
        VDATEPTROUT(lpClassID, CLSID);
        *lpClassID = CLSID_CompositeMoniker;
        return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::Load
//
//  Synopsis:   Loads a composite moniker from stream
//
//  Effects:
//
//  Arguments:  [pStm] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//      The serialized form of a composite moniker is a ULONG count of
//      monikers, followed by each non-composite moniker written
//      left to right.
//
//  WARNING: Be very careful with the refernce counting in this routine.
//
//----------------------------------------------------------------------------
STDMETHODIMP CCompositeMoniker::Load (THIS_ LPSTREAM pStm)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Load(%x)\n",this));

        VDATEIFACE(pStm);

        ULONG cMonikers = 0;
        ULONG n;
        LPMONIKER pmk     = NULL;
        LPMONIKER pmkPrev = NULL;
        HRESULT hresult;

        //
        //      Monikers are immutable, so this is called only when creating a
        //      moniker, and so we assert if this moniker is not newly created.
        //

        Assert(m_pmkLeft == NULL && m_pmkRight == NULL);

        if ((m_pmkLeft != NULL) || (m_pmkRight != NULL ))
        {
            return(E_UNEXPECTED);
        }


        //      There is no collapsing of successive pieces of the moniker, since
        //      this was once written to disk, and the collapsing would have happened
        //      before that.

        hresult = StRead(pStm, (LPVOID)&cMonikers, sizeof(ULONG));

        if (FAILED(hresult))
        {
            goto errRet;
        }

        //      some plausibility checking on cMonikers might be appropriate
        //      if there is only one, we shouldn't have had a composite moniker

        Assert( cMonikers >= 2 );


        if (cMonikers < 2)
        {
            hresult = E_UNEXPECTED;
            goto errRet;
        }

        //
        // Note: n is used 1 based, since this loop does something special on the
        // last moniker.
        //

        for (n = 1; n <= cMonikers; n++ )
        {

            //
            // After loading the reference count for the new moniker will == 1
            //
            hresult = OleLoadFromStream(pStm, IID_IMoniker, (LPVOID FAR*)&pmk);

            if (FAILED(hresult))
            {
                goto errRet;            
            }

            //
            // If this is the last moniker, then it will be the right moniker
            // to 'this' composite moniker.
            //
            if (n == cMonikers)         //      this is the last moniker read
            {
                //
                // Save away the pointer into the right moniker for this instance
                // of the composite.
                // The reference count is OK, since it was set to 1 on creation,
                // and we are saving it
                //
                m_pmkRight = pmk;

                //
                // AddRef not needed, its already 1, and we are supposed to
                // exit the loop
                //

                m_pmkLeft = pmkPrev;

                Assert( pmkPrev != NULL );

            }
            else if (pmkPrev == NULL)
            {
                pmkPrev = pmk;
            }
            else
            {
                LPMONIKER pmkTemp;

                //
                // Warning: Here is some tricky stuff. pmkPrev has a reference
                // of 1 at the moment, because thats how we created it.
                //
                // pmk also has a refcount == 1
                //
                // We are going to create another composite, of which they will
                // become members. The Create function is going to increment
                // both (making them 2).
                //

                pmkTemp = CCompositeMoniker::Create(pmkPrev,
                                                    pmk);

                if (pmkTemp == NULL)
                {
                    hresult = E_OUTOFMEMORY;
                    goto errRet;
                }

                //
                // The new moniker is holding refcounts to both monikers that
                // are not needed. Releasing these two sets the refcounts
                // back to 1 like they should be.
                //

                pmkPrev->Release();
                pmk->Release();

                //
                // Now, pmkPrev gets the new composite.
                //

                pmkPrev = pmkTemp;
            }

            //
            // pmk has been given to another pointer. NULL it out in case
            // there is an error later, so we don't try to release it too
            // many times.
            //

            pmk = NULL;
        }

        //
        // Exiting at this point leaves the moniker pointed to by pmkPrev
        //

        return(NOERROR);

errRet:
        if (pmkPrev != NULL)
        {
            pmkPrev->Release(); 
        }
        if (pmk != NULL)
        {
            pmk->Release();
        }

        return hresult;
}

INTERNAL_(ULONG) CCompositeMoniker::Count(void)
{
        M_PROLOG(this);

        CCompositeMoniker *pCMk = IsCompositeMoniker(m_pmkLeft);
        ULONG cMk = (pCMk) ? pCMk->Count() : 1;

        Assert(m_pmkLeft != NULL);

        pCMk = IsCompositeMoniker(m_pmkRight);
        cMk += (pCMk) ? pCMk->Count() : 1;

        Assert(cMk >= 2);
        return cMk;
}




//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::Save
//
//  Synopsis:   Save the composite to a stream
//
//  Effects:
//
//  Arguments:  [pStm] --
//              [fClearDirty] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//      The serialized form of a composite moniker is a ULONG count of
//      monikers, followed by each non-composite moniker written
//      left to right.
//
//----------------------------------------------------------------------------
STDMETHODIMP CCompositeMoniker::Save (THIS_ LPSTREAM pStm, BOOL fClearDirty)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Save(%x)\n",this));

    VDATEIFACE(pStm);
    ULONG cMonikers;            //      count of monikers in this composite.
    HRESULT hresult;
    LPENUMMONIKER pEnum;
    LPMONIKER pmk;
    ULONG i;

    cMonikers = Count();

    hresult = pStm->Write(&cMonikers, sizeof(ULONG), NULL);

    if (FAILED(hresult))
    {
        goto errRet;
    }

    //
    //  Write out left to right using enumerator.
    //

    hresult = Enum(TRUE, &pEnum);

    if (hresult != NOERROR)
    {
        goto errRet;    
    }

    if (pEnum != NULL)
    {
        for( i = 0; i < cMonikers; i++)
        {
            hresult = pEnum->Next(1, &pmk, NULL);

            if (hresult != NOERROR)
            {
                if (S_FALSE == hresult)
                {
                    //
                    // If the enumerator returns S_FALSE, then it has no more
                    // monikers to hand out. This is bad, since we haven't
                    // written out the number of monikers we were supposed to.
                    // Therefore, it is an E_UNEXPECTED error
                    //
                    hresult = E_UNEXPECTED;
                
                }
                goto errRet;
            }

            //
            // If pmk is NULL, something seriously wrong happened.
            //

            if (pmk == NULL)
            {
                hresult = E_UNEXPECTED;
                goto errRet;
            }

            hresult = OleSaveToStream( pmk, pStm );

            pmk->Release();

            if (hresult != NOERROR)
            {
                goto errRet;
            }
        }

        pEnum->Release();
    }
    else
    {
        //
        // If we get here, and cMonikers isn't 0, something else happened
        //
        if (cMonikers != 0)
        {
            hresult = E_UNEXPECTED;
        }
    }

errRet:
        return hresult;
}



//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::GetSizeMax
//
//  Synopsis:   Return the maximum size required to marshal this composite
//
//  Effects:
//
//  Arguments:  [pcbSize] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CCompositeMoniker::GetSizeMax (ULARGE_INTEGER FAR * pcbSize)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::GetSizeMax(%x)\n",this));

        VDATEPTROUT(pcbSize, ULARGE_INTEGER);

        LPENUMMONIKER pEnum = NULL;
        LPMONIKER pmk = NULL;
        HRESULT hresult;
        ULARGE_INTEGER cbSize2;


        //
        // The composite itself writes out a CLSID and a count of monikers
        //
        ULONG cbSize = sizeof(CLSID) + sizeof(ULONG);

        //
        // Use an enumerator to walk the list of monikers
        //
        hresult = Enum(TRUE, &pEnum);

        if (hresult != NOERROR)
        {
            goto errRet;        
        }

        Assert(pEnum != NULL);

        while (TRUE)
        {
            hresult = pEnum->Next(1, &pmk, NULL);
            if (hresult != NOERROR)
            {
                if (hresult == S_FALSE)
                {
                    //
                    // S_FALSE is the 'done' code
                    //

                    hresult = NOERROR;                  
                }

                goto errRet;
            }
            Assert(pmk != NULL);

            cbSize2.LowPart = cbSize2.HighPart = 0;

            hresult = pmk->GetSizeMax(&cbSize2);

            pmk->Release();

            if (hresult)
            {
                goto errRet;            
            }

            //
            // The sub-GetSizeMax's don't account for the GUID
            // that OleSaveToStream writes on the monikers behalf.
            // Therefore, we will add it in on our own.
            //

            cbSize += cbSize2.LowPart + sizeof(GUID);
        }
errRet:
        if (pEnum)
        {
            pEnum->Release();   
        }

        ULISet32(*pcbSize,cbSize);
        RESTORE_A5();
        return hresult;
}



//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::AllButLast
//
//  Synopsis:
//              
//      returns a moniker that consists of all but the last moniker of this
//      composite.  Since a composite must have at least two pieces, this will
//      never be zero, but it may not be a composite.
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//              17-May-94 AlexT     Plug memory leak, check for error
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(LPMONIKER)
CCompositeMoniker::AllButLast(void)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::AllButLast(%x)\n",this));

    LPMONIKER pmk;

    Assert(m_pmkRight != NULL );

    //
    // Recurse down the right branch of the tree until a non composite moniker
    // is found. When a non-composite right most moniker is found, return the
    // left part of the tree. As the recurse unwinds, a new composite is
    // formed from each intermediate node.
    //
    // Yeah, I know, its seems expensive. However, composite monikers are
    // fairly cheap to allocate (no strings or stuff). The average
    // composite moniker only has one or two nodes, so this isn't as bad
    // as you might think. In theory, there are only LOG2(n) nodes created,
    // where n == number of parts in the composite.
    //

    CCompositeMoniker *pCMk = IsCompositeMoniker(m_pmkRight);
    if (pCMk)
    {
        LPMONIKER pmkRight;

        pmkRight = pCMk->AllButLast();
        if (NULL == pmkRight)
        {
            //  We didn't get back a moniker from AllButLast, even though
            //  pmkRight is a composite moniker.  Probably out of memory...
            mnkDebugOut((DEB_WARN,
                         "CCompositeMoniker::AllButLast recursive call "
                         "returned NULL\n"));

            pmk = NULL;
        }
        else
        {
            pmk = CCompositeMoniker::Create(m_pmkLeft, pmkRight);
            pmkRight->Release();
        }
    }
    else
    {
        Assert(m_pmkLeft != NULL && "Bad composite moniker");
        pmk = m_pmkLeft;
        pmk->AddRef();
    }
    return pmk;
}



//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::Last
//
//  Synopsis:
//      return the last moniker in the composite list.  It is guaranteed to be
//      non-null and non-composite
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(LPMONIKER)
CCompositeMoniker::Last(void)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Last(%x)\n",this));

    CCompositeMoniker FAR * pCM = this;
    CCompositeMoniker FAR * pCMNext;

    //
    // Run down the right side of the tree, looking for a non-composite
    // right moniker (the leaf node).
    //

    while ((pCMNext = IsCompositeMoniker(pCM->m_pmkRight)) != NULL)
    {
        pCM = pCMNext;
    }

    IMoniker *pmk = pCM->m_pmkRight;

    Assert(pmk != NULL && (!IsCompositeMoniker(pmk)));

    pmk->AddRef();

    return pmk;
}



//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::AllButFirst
//
//  Synopsis:
//      returns a moniker that consists of all but the first moniker of this
//      composite.  Since a composite must have at least two pieces, this will
//      never be zero, but it may not be a composite.
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(LPMONIKER)
CCompositeMoniker::AllButFirst(void)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::AllButFirst(%x)\n",this));

    LPMONIKER pmk;

    //
    // Run down the left side of the tree, creating a composite moniker with
    // everything but the first moniker. See AllButLast for a pithy quote
    // about the efficiency
    //

    CCompositeMoniker *pCM = IsCompositeMoniker(m_pmkLeft);
    if (pCM)
    {
        LPMONIKER pmkABF = pCM->AllButFirst();

        pmk = CCompositeMoniker::Create(pmkABF, m_pmkRight);

        pmkABF->Release();
    }
    else
    {
        pmk = m_pmkRight;
        pmk->AddRef();
    }
    return pmk;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::First
//
//  Synopsis:
//      return the first moniker in the composite list.  It is guaranteed to be
//      non-null and non-composite
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(LPMONIKER)
CCompositeMoniker::First(void)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::First(%x)\n",this));

    CCompositeMoniker *pCM = this;
    CCompositeMoniker *pCMNext;

    while ((pCMNext = IsCompositeMoniker(pCM->m_pmkLeft)) != NULL)
    {
        pCM = pCMNext;
    }

    IMoniker *pmk = pCM->m_pmkLeft;

    Assert(pmk != NULL && (!IsCompositeMoniker(pmk)));

    pmk->AddRef();

    return pmk;
}


STDMETHODIMP CCompositeMoniker::BindToObject (LPBC pbc,
        LPMONIKER pmkToLeft, REFIID riidResult, LPVOID FAR* ppvResult)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::BindToObject(%x)\n",this));

        VDATEPTROUT(ppvResult, LPVOID);
        VDATEIFACE(pbc);
        VDATEIID(riidResult);

        *ppvResult = NULL;

        if (pmkToLeft)
        {
            VDATEIFACE(pmkToLeft);      
        }

        HRESULT hresult = NOERROR;
        LPRUNNINGOBJECTTABLE prot;
        *ppvResult = NULL;

        LPMONIKER pmkAllButLast = NULL;
        LPMONIKER pmkLast = NULL;
        LPMONIKER pmkNewLeft = NULL;

        //      Look for moniker in running objects table if there is nothing to the
        //      left

        if (pmkToLeft == NULL)
        {
                hresult = pbc->GetRunningObjectTable( &prot );
                if (hresult == NOERROR)
                {
                        LPUNKNOWN pUnk;
                        hresult = prot->GetObject(this, &pUnk);
                        prot->Release();
                        if ((hresult == NOERROR) && (pUnk != NULL))
                        {
                                hresult = pUnk->QueryInterface(riidResult, ppvResult);
                                pUnk->Release();
                                goto errRet;
                        }
                }
                else
                {
                        goto errRet;            
                }
        }


        pmkAllButLast = AllButLast();

        if (pmkAllButLast == NULL)
        {
            // The creation must have failed. The only reason we could think of was
            // out of memory.
            hresult = E_OUTOFMEMORY;
            goto errRet;
        }

        pmkLast = Last();
        if (pmkLast == NULL)
        {
            // The creation must have failed. The only reason we could think of was
            // out of memory.
            hresult = E_OUTOFMEMORY;
            goto errRet1;
        }

        Assert((pmkLast != NULL) && (pmkAllButLast != NULL));

        if (pmkToLeft != NULL)
        {
        //      REVIEW: check for error from ComposeWith
            hresult = pmkToLeft->ComposeWith(pmkAllButLast, FALSE, &pmkNewLeft);
            if (FAILED(hresult))
            {
                goto errRet2;
            }
        }
        else
        {
            pmkNewLeft = pmkAllButLast;
            pmkNewLeft->AddRef();
        }

        hresult = pmkLast->BindToObject(pbc, pmkNewLeft, riidResult, ppvResult);

errRet2:
        pmkLast->Release();
errRet1:
        pmkAllButLast->Release();

        if (pmkNewLeft != NULL)
        {
             pmkNewLeft->Release();     
        }

errRet:

        return hresult;
}


STDMETHODIMP CCompositeMoniker::BindToStorage (LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riid, LPVOID FAR* ppvObj)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::BindToStorage(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(ppvObj,LPVOID);
        *ppvObj = NULL;
        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);
        VDATEIID(riid);

        HRESULT hresult = NOERROR;

        LPMONIKER pmkAllButLast = AllButLast();
        LPMONIKER pmkLast = Last();
        LPMONIKER pmkNewLeft = NULL ;

        if (pmkToLeft)
        {
                hresult = pmkToLeft->ComposeWith(pmkAllButLast, FALSE, &pmkNewLeft);
                if (hresult) goto errRet;
        }
        else
        {
                pmkNewLeft = pmkAllButLast;
                pmkNewLeft->AddRef();
        }

        hresult = pmkLast->BindToStorage(pbc, pmkNewLeft, riid, ppvObj);

errRet:
        if (pmkAllButLast) pmkAllButLast->Release();
        if (pmkLast) pmkLast->Release();
        if (pmkNewLeft) pmkNewLeft->Release();

        return hresult;
}




STDMETHODIMP CCompositeMoniker::Reduce (LPBC pbc,
        DWORD dwReduceHowFar,
        LPMONIKER FAR* ppmkToLeft,
        LPMONIKER FAR * ppmkReduced)
{
        mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Reduce(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(ppmkReduced,LPMONIKER);
        *ppmkReduced = NULL;
        VDATEIFACE(pbc);
        if (ppmkToLeft)
        {
                VDATEPTROUT(ppmkToLeft,LPMONIKER);
                if (*ppmkToLeft) VDATEIFACE(*ppmkToLeft);
        }

        LPMONIKER pmkLeftReduced = NULL;
        LPMONIKER pmkRightReduced = NULL;
        CCompositeMoniker FAR * pmkCompositeReduced;
        SCODE scode1 = S_OK;
        SCODE scode2 = S_OK;

#ifdef _TRACKLINK_
        if (!m_fReduceForced && m_fReduced)     //      already reduced maximally
#else
        if (m_fReduced) //      already reduced maximally
#endif
        {
                AddRef();
                *ppmkReduced = this;
                return ResultFromScode(MK_S_REDUCED_TO_SELF);
        }

        if (m_pmkLeft)
        {
                scode1 = GetScode( m_pmkLeft->Reduce(pbc,
                    dwReduceHowFar,
                    NULL,
                    &pmkLeftReduced));
                // AssertOutPtrIface(scode1, pmkLeftReduced);
                if (scode1 != S_OK && scode1 != MK_S_REDUCED_TO_SELF)
                        return ResultFromScode(scode1);
        }
        
        if (m_pmkRight)
        {
                // SPEC:

                /*

                ppmkToLeft

                [out] On entry, ppmkToLeft points to the moniker that 
                prefixes this one within the composite, that is, the 
                moniker to the left of the current moniker.  On exit, the 
                pointer will be NULL or non-NULL.  Non-NULL indicates that 
                the previous prefix should be disregarded and the moniker 
                returned through ppmkToLeft should be used as the prefix 
                in its place (this is not usual).  NULL indicates that the 
                prefix should not be replaced.  Most monikers will NULL 
                out this parameter before returning.  The ppmkToLeft 
                parameter is an [in,out] parameter and it must be released 
                before NULLing out.  If an error is returned, this 
                parameter must be set to NULL.  For more information on 
                [in,out] parameters, see the discussion of parameter types 
                in the section on Memory Management.  

                */ 

                IMoniker *pmkLeftReducedTmp = pmkLeftReduced;
                pmkLeftReducedTmp->AddRef();

                scode2 = GetScode( m_pmkRight->Reduce(pbc,
                    dwReduceHowFar,
                    &pmkLeftReducedTmp,
                    &pmkRightReduced));
                // AssertOutPtrIface(scode2, pmkRightReduced);

                if (pmkLeftReducedTmp == NULL)
                {
                    // prefix should not be replaced
                    // we still have original ref
                }
                else
                {
                    // use pmkLeftReducedTmp as the new left piece
                    pmkLeftReduced->Release(); // the original ref
                    pmkLeftReduced = pmkLeftReducedTmp;
                }

                if (scode2 != S_OK && scode2 != MK_S_REDUCED_TO_SELF)
                {
                        if (pmkLeftReduced)
                            pmkLeftReduced->Release();
                        return ResultFromScode(scode2);
                }
        }
        if (scode1 == MK_S_REDUCED_TO_SELF && scode2 == MK_S_REDUCED_TO_SELF)
        {
                pmkLeftReduced->Release();
                pmkRightReduced->Release();
                AddRef();
                m_fReduced = TRUE;
                *ppmkReduced = this;
                return ResultFromScode(MK_S_REDUCED_TO_SELF);
        }
        //      No error, and one of the two pieces actually reduced.
        pmkCompositeReduced = CCompositeMoniker::Create(pmkLeftReduced,
                pmkRightReduced );
        pmkLeftReduced->Release();
        pmkRightReduced->Release();
        if (pmkCompositeReduced != NULL)
            pmkCompositeReduced->m_fReduced = TRUE;
        *ppmkReduced = pmkCompositeReduced;
        return pmkCompositeReduced == NULL ? E_OUTOFMEMORY : NOERROR;   
}




STDMETHODIMP CCompositeMoniker::ComposeWith (LPMONIKER pmkRight,
        BOOL fOnlyIfNotGeneric, LPMONIKER FAR* ppmkComposite)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::ComposeWith(%x)\n",this));

    M_PROLOG(this);

    if (fOnlyIfNotGeneric)
    {
        return(MK_E_NEEDGENERIC);
    }

    return CreateGenericComposite( this, pmkRight, ppmkComposite );
}


STDMETHODIMP CCompositeMoniker::Enum (BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Enum(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(ppenumMoniker,LPENUMMONIKER);
        *ppenumMoniker = NULL;
        *ppenumMoniker = CCompositeMonikerEnum::Create(fForward, this);
        if (*ppenumMoniker) return NOERROR;
        return ResultFromScode(E_OUTOFMEMORY);
}


STDMETHODIMP CCompositeMoniker::IsEqual (LPMONIKER pmkOtherMoniker)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::IsEqual(%x)\n",this));
    
    M_PROLOG(this);
    VDATEIFACE(pmkOtherMoniker);
    
    HRESULT       hr = S_FALSE;
    HRESULT       hr2;
    LPENUMMONIKER pEnumMe;
    LPENUMMONIKER pEnumOther;
    LPMONIKER     pMkMe;
    LPMONIKER     pMkOther;
    
    // REVIEW:  do we call Reduce first?  No: spec isssue 330
    
    CCompositeMoniker *pCMk = IsCompositeMoniker(pmkOtherMoniker);
    if (pCMk)
    {
        hr = Enum(TRUE, &pEnumMe);
        if (SUCCEEDED(hr))
        {
            hr = pmkOtherMoniker->Enum(TRUE, &pEnumOther);
            if (SUCCEEDED(hr))
            {
                // Initialize
                pEnumMe->Reset();
                pEnumOther->Reset();
                
                // Compare successive elements
                for (;;)
                {
                    // Fetch the next two elements
                    hr = pEnumMe->Next(1, &pMkMe, NULL);
                    hr2 = pEnumOther->Next(1, &pMkOther, NULL);

                    // Compare them
                    if (hr == S_OK  &&  hr2 == S_OK)
                    {
                        if (pMkMe->IsEqual(pMkOther) == S_FALSE)
                        {
                            pMkMe->Release();
                            pMkOther->Release();
                            hr = S_FALSE;
                            break;
                        }
                    }

                    // Release the individual monikers
                    if (hr == S_OK)
                    {
                        pMkMe->Release();
                    }
                    if (hr2 == S_OK)
                    {
                        pMkOther->Release();
                    }

                    // All elements exhausted
                    if (hr == S_FALSE  &&  hr2 == S_FALSE)
                    {
                        hr = S_OK;
                        break;
                    }

                    // One contained fewer elements than the other
                    else if (hr == S_FALSE  ||  hr2 == S_FALSE)
                    {
                        hr = S_FALSE;
                        break;
                    }
                }
                pEnumOther->Release();
            }
            pEnumMe->Release();
        }
    }
    
    return hr;
}

//      the following is non-recursive version using enumerators.
#ifdef NONRECURSIVE_ISEQUAL
        LPENUMMONIKER penumOther = NULL;
        LPENUMMONIKER penumThis = NULL;
        LPMONIKER pmkThis = NULL;
        LPMONIKER pmkOther = NULL;

        HRESULT hresult;
        SCODE scode1;
        SCODE scode2;

        if (!IsCompositeMoniker(pmkOtherMoniker))
            return ResultFromScode(S_FALSE);
        hresult = Enum(TRUE, &penumThis);
        if (hresult != NOERROR) goto errRet;
        hresult = pmkOtherMoniker->Enum(TRUE, &penumOther);
        if (hresult != NOERROR) goto errRet;
        //      now go through the enumeration, checking IsEqual on the individual
        //      pieces.

        while (TRUE)
        {
                hresult = penumThis->Next( 1, &pmkThis, NULL );
                scode1 = GetScode(hresult);
                if ((hresult != NOERROR) && (S_FALSE != scode1))
                {
                        goto errRet;
                }
                hresult = penumOther->Next( 1, &pmkOther, NULL );
                scode2 = GetScode(hresult);
                if ((hresult != NOERROR) && (S_FALSE != scode2))
                {
                        goto errRet;
                }
                if (scode1 != scode2)
                {
                        hresult = ResultFromScode(S_FALSE);
                        goto errRet;
                }
                if (S_FALSE == scode1)
                {
                        hresult = NOERROR;
                        goto errRet;
                }
                hresult = pmkThis->IsEqual(pmkOther);
                pmkThis->Release();
                pmkOther->Release();
                pmkThis = NULL;
                pmkOther = NULL;
                if (hresult != NOERROR) goto errRet;
        }
errRet:
        if (pmkThis) pmkThis->Release();
        if (pmkOther) pmkOther->Release();
        if (penumOther) penunOther->Release();
        if (penumThis) penumThis->Release();
        return hresult;
}
#endif          //      NONRECURSIVE_ISEQUAL


STDMETHODIMP CCompositeMoniker::Hash (LPDWORD pdwHash)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Hash(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(pdwHash, DWORD);

        DWORD dwHashLeft;
        DWORD dwHashRight;
        m_pmkLeft->Hash(&dwHashLeft);
        //      check for errors
        m_pmkRight->Hash(&dwHashRight);
        *pdwHash = dwHashLeft^dwHashRight;
        return NOERROR;
}



STDMETHODIMP CCompositeMoniker::IsRunning
        (LPBC pbc,
        LPMONIKER pmkToLeft,
        LPMONIKER pmkNewlyRunning)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::IsRunning(%x)\n",this));

        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);
        if (pmkNewlyRunning) VDATEIFACE(pmkNewlyRunning);

        LPMONIKER pmkFirst = First();
        HRESULT hresult;
        LPMONIKER pmk = NULL;
        LPMONIKER pmkLast = NULL;
        LPRUNNINGOBJECTTABLE prot = NULL;

        CFileMoniker FAR * pCFM = IsFileMoniker(pmkFirst);
        if (pCFM)
        {
                CLSID clsid;
                if (pCFM->IsOle1Class(&clsid))
                {

                    hresult = DdeIsRunning(clsid, pCFM->m_szPath, pbc,
                                           pmkToLeft, pmkNewlyRunning);
                    goto errRet;
                }
        }

        if (pmkToLeft != NULL)
        {
                hresult = pmkToLeft->ComposeWith(this, FALSE, &pmk);
                if (hresult)
                    goto errRet;
                hresult = pmk->IsRunning(pbc, NULL, pmkNewlyRunning);
        }
        else if (pmkNewlyRunning != NULL)
        {
                hresult = pmkNewlyRunning->IsEqual(this);
        }
        else
        {
                hresult = pbc->GetRunningObjectTable(&prot);
                if (hresult != NOERROR)
                    goto errRet;
                hresult = prot->IsRunning(this);
                if (hresult == NOERROR)
                    goto errRet;
                pmk = AllButLast();
                pmkLast = Last();
                hresult = pmkLast->IsRunning(pbc, pmk, pmkNewlyRunning);
        }
errRet:
    if (pmk) pmk->Release();
    if (pmkLast) pmkLast->Release();
    if (prot) prot->Release();
    if (pmkFirst) pmkFirst->Release();

    return hresult;
}


STDMETHODIMP CCompositeMoniker::GetTimeOfLastChange (LPBC pbc, LPMONIKER pmkToLeft, FILETIME FAR* pfiletime)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::GetTimeOfLastChange(%x)\n",this));

        M_PROLOG(this);
        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);
        VDATEPTROUT(pfiletime, FILETIME);

        HRESULT hresult;
        LPMONIKER pmkTemp = NULL;
        LPMONIKER pmkABL = NULL;
        LPMONIKER pmkL = NULL;
        LPRUNNINGOBJECTTABLE prot = NULL;

        if (pmkToLeft == NULL)
        {
                pmkTemp = this;
                AddRef();
        }
        else
        {
                hresult = CreateGenericComposite( pmkToLeft, this, &pmkTemp );
                if (hresult != NOERROR) goto errRet;
        }
        hresult = pbc->GetRunningObjectTable(& prot);
        if (hresult != NOERROR) goto errRet;
        hresult = prot->GetTimeOfLastChange( pmkTemp, pfiletime);
        if (hresult != MK_E_UNAVAILABLE) goto errRet;

        pmkTemp->Release(); pmkTemp = NULL;

        pmkABL = AllButLast();
        pmkL = Last();
        Assert(pmkABL != NULL);
        if (pmkToLeft == NULL)
        {
                pmkTemp = pmkABL;
                pmkABL->AddRef();
        }
        else
        {
                hresult = CreateGenericComposite(pmkToLeft, pmkABL, &pmkTemp);
                if (hresult != NOERROR) goto errRet;
        }
        hresult = pmkL->GetTimeOfLastChange(pbc, pmkTemp, pfiletime);
errRet:
        if (pmkTemp) pmkTemp->Release();
        if (pmkABL) pmkABL->Release();
        if (pmkL) pmkL->Release();
        if (prot) prot->Release();
        return hresult;
}


STDMETHODIMP CCompositeMoniker::Inverse (LPMONIKER FAR* ppmk)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Inverse(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(ppmk, LPMONIKER);
        *ppmk = NULL;

        HRESULT hresult;
        LPMONIKER pmkLeftInverse;
        LPMONIKER pmkRightInverse;

        hresult = m_pmkLeft->Inverse(&pmkLeftInverse);
        // AssertOutPtrIface(hresult, pmkLeftInverse);
        if (hresult != NOERROR) return hresult;
        hresult = m_pmkRight->Inverse(&pmkRightInverse);
        // AssertOutPtrIface(hresult, pmkRightInverse);
        if (hresult != NOERROR)
        {
                pmkLeftInverse->Release();
                return hresult;
        }
        hresult = CreateGenericComposite( pmkRightInverse, pmkLeftInverse, ppmk);
        pmkRightInverse->Release();
        pmkLeftInverse->Release();
        return hresult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::CommonPrefixWith
//
//  Synopsis:   This method determines the common prefix between this moniker
//              and the provided moniker
//
//  Effects:
//
//  Arguments:  [pmkOther] --   Moniker to determine common prefix with
//              [ppmkPrefix] -- Outputs moniker with common prefix
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CCompositeMoniker::CommonPrefixWith (LPMONIKER pmkOther,
        LPMONIKER FAR* ppmkPrefix)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::CommonPrefixWith(%x)\n",this));

    VDATEPTROUT(ppmkPrefix,LPMONIKER);
    VDATEIFACE(pmkOther);

    CCompositeMoniker FAR * pCCMOther;
    LPMONIKER pmkFirst = NULL;
    LPMONIKER pmkRest = NULL;
    LPMONIKER pmkOtherFirst = NULL;
    LPMONIKER pmkOtherRest = NULL;
    LPMONIKER pmkResult = NULL;
    LPMONIKER pmkResult2 = NULL;
    HRESULT hresult = E_UNEXPECTED;
    HRESULT hresult2;

    *ppmkPrefix = NULL;

    pmkFirst = First();

    if (pmkFirst == NULL)
    {
        goto errRet;
    }

    //
    // If the other moniker is also a composite, then we need to recurse
    // down both lists to find the common prefix
    //

    pCCMOther = IsCompositeMoniker(pmkOther);

    if (pCCMOther)
    {
        mnkDebugOut((DEB_ITRACE,
                     "::CommonPrefixWith C(%x) and C(%x)\n",
                     this,
                     pmkOther));

        //
        // For each element of the composite, get the common prefix
        //

        pmkOtherFirst = pCCMOther->First();

        if(pmkOtherFirst == NULL)
        {
            goto errRet;
        }

        //
        // We have both 'first' monikers from the composite.
        //
        hresult = pmkFirst->CommonPrefixWith(pmkOtherFirst, &pmkResult);

        if (FAILED(hresult))
        {
            goto errRet;
        }

        //
        // If the monikers are the same, then recurse to get the common
        // prefix of the rest.
        // It is possible that the rest won't be common, in which case we need
        // to return just pmkResult.
        //

        if (MK_S_US == hresult)
        {
            pmkOtherRest = pCCMOther->AllButFirst();

            if (pmkOtherRest == NULL)
            {
                goto errRet;
            }

            pmkRest = AllButFirst();

            if (pmkRest == NULL)
            {
                goto errRet;
            }

            hresult = pmkRest->CommonPrefixWith(pmkOtherRest, &pmkResult2);

            //
            // If hresult == MK_E_NOPREFIX, then pmkResult holds the entire
            // prefix. In this case, we need to convert the hresult into
            // another error code.
            //
            // If hresult == MK_S_US, MK_S_HIM, or MK_S_ME, then composing
            // to the end of pmkResult and returning hresult will do the
            // correct thing.
            //

            if (hresult == MK_E_NOPREFIX)
            {
                //
                // There was no additional prefix match, return the
                // current result
                //

                *ppmkPrefix = pmkResult;
                pmkResult->AddRef();

                hresult = NOERROR;

                goto errRet;

            } else if (FAILED(hresult))
            {
                goto errRet;
            }


            //
            // Since MK_E_NOPREFIX was not the return error, and
            // the call didn't fail, then the other moniker must have returned
            // a prefix. Compose it with the existing result
            //
            // If the compose succeeds, then return the existing hresult.
            // We are either going to return MK_S_HIM, MK_S_US, MK_S_ME, or
            // NOERROR (or some other error we don't know.
            //

            hresult2 = pmkResult->ComposeWith(pmkResult2, FALSE, ppmkPrefix);

            if (FAILED(hresult2))
            {
                //
                // Compose with failed. Convert hresult, which is the return
                // value, into hresult2
                //

                hresult = hresult2;
            }

            goto errRet;
        }
        else if ((hresult == MK_S_HIM) || (hresult == MK_S_ME))
        {
            //
            // The common prefix was either him or me, therefore the
            // proper thing to do is to return the result. However, we
            // need to change the hresult, since the result is a prefix
            // of one of the composites. (Try that 3 times fast)
            //
            *ppmkPrefix = pmkResult;

            pmkResult->AddRef();

            hresult = NOERROR;
        }
        goto errRet;
    }
    else
    {
        hresult = pmkFirst->CommonPrefixWith(pmkOther, ppmkPrefix);

        // if the first part of me is the common prefix, then the prefix
        // is a subpart of me since I am composite. The actual prefix is
        // NOT me, since only the first moniker was prefix

        if (MK_S_ME == hresult)
        {
            hresult = NOERROR;  
        }
        else if (hresult == MK_S_US)
        {
            //
            // If the First moniker returned MK_S_US, then the actual
            // return should be MK_S_HIM, since this composite has additional
            // parts that weren't considered by the call.
            //
            hresult = MK_S_HIM; 
        }
    }
errRet:
    if (pmkFirst) pmkFirst->Release();
    if (pmkRest) pmkRest->Release();
    if (pmkOtherFirst) pmkOtherFirst->Release();
    if (pmkOtherRest) pmkOtherRest->Release();
    if (pmkResult) pmkResult->Release();
    if (pmkResult2) pmkResult2->Release();
    return hresult;
}



HRESULT ComposeWithEnum( LPMONIKER pmkLeft, LPENUMMONIKER penum,
        LPMONIKER FAR * ppmkComposite )
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::ComposeWithEnum(pmkLeft=%x,penum=%x)\n",
                 pmkLeft,
                 penum));

        LPMONIKER pmk = NULL;
        LPMONIKER pmkTempLeft = pmkLeft;
        LPMONIKER pmkTempComp = NULL;
        HRESULT hresult;

        *ppmkComposite = NULL;
        pmkTempLeft->AddRef();
        while ((hresult = penum->Next(1, &pmk, NULL)) == NOERROR)
        {
                hresult = pmkTempLeft->ComposeWith(pmk, FALSE, &pmkTempComp);
                pmk->Release();
                pmkTempLeft->Release();
                pmkTempLeft=pmkTempComp;                // no need to release pmkTempComp
                if (hresult != NOERROR)  goto errRet;
        }
errRet:
        if (GetScode(hresult) == S_FALSE) hresult = NOERROR;
        if (hresult == NOERROR) *ppmkComposite = pmkTempLeft;
        else pmkTempLeft->Release();
        return hresult;
}



HRESULT InverseFromEnum( LPENUMMONIKER penum, LPMONIKER FAR * ppmkInverse)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::InverseFromEnum(%x)\n",penum));

        LPMONIKER pmk = NULL;
        LPMONIKER pmkInverse = NULL;
        LPMONIKER pmkTailInverse = NULL;
        HRESULT hresult;

        *ppmkInverse = NULL;

        hresult = penum->Next(1, &pmk, NULL );
        if (hresult == NOERROR)
        {
                hresult = InverseFromEnum( penum, &pmkTailInverse);
                if (hresult != NOERROR)
                        goto errRet;
                hresult = pmk->Inverse(&pmkInverse);
                // AssertOutPtrIface(hresult, pmkInverse);
                if (hresult != NOERROR) goto errRet;
                if (pmkTailInverse)
                        hresult = pmkTailInverse->ComposeWith( pmkInverse, FALSE, ppmkInverse );
                else
                        *ppmkInverse = pmkInverse;
        }
errRet:
        if (GetScode(hresult) == S_FALSE) hresult = NOERROR;
        if (pmk) pmk->Release();
        if (pmkTailInverse) pmkTailInverse->Release();
        return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::RelativePathTo
//
//  Synopsis:   Determines the relative path to pmkOther
//
//  Effects:
//
//  Arguments:  [pmkOther]    -- moniker to which to find relative path
//              [ppmkRelPath] -- placeholder for returned moniker
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Derivation: IMoniker
//
//  Algorithm:  There are two major cases - B is or is not a composite moniker.
//
//              * * *
//
//              If both monikers are composite monikers, we compare their
//              component monikers.  Using the following notation for the
//              monikers A and B:
//
//              (a[0], a[1], a[2], ... a[m]) and (b[0], b[1], b[2], ... b[n])
//
//              We find the first pair (a[i], b[i]) such that a[i] != b[i].
//
//              Case 1:
//              If i == 0, then no component monikers match.
//                  Case 1A:
//                  If we can form a relative path between a[0] and b[0], we
//                   can construct a correct relative path between A and B by
//                   combining (in order):
//
//                   !(a[1], ... a[m]) - inverse of the remaining elements of A
//                                       (can be NULL)
//                   (!a[0], b[0])     - relative path between a[0] and b[0]
//                   (b[1], ... b[n])  - remaining elements of B
//
//                  Case 1B:
//                  Else there is no relative path and we just return B as the
//                   relative path and MK_S_HIM as the HRESULT
//
//              Case 2:
//              Else if (a[i] != NULL) && (b[i] != NULL) then both monikers
//               have leftover pieces.  We can construct a correct relative
//               path by combining (in order):
//
//                !(a[i+1], ... a[m]) - inverse of remaining elements of A
//                !a[i]
//                b[i]
//                (b[i+1], ... b[n])  - remaining elements of B
//
//              Case 3:
//              Else if (a[i] != NULL) && (b[i] == NULL) then B is a prefix
//               of A.  We can construct a correct relative path by combining:
//
//                !(a[i+1], ... a[m]) - inverse of remaining elements of A
//                !a[i]
//
//                Note that this is just the first two steps of the previous
//                case.
//
//              Case 4:
//              Else if (a[i] == NULL) && (b[i] != NULL) then A is a prefix
//               of B.  We can construct a correct relative path by combining:
//
//                b[i]
//                (b[i+1], ... b[n])  - remaining elements of B
//
//              Case 5:
//              Else if (a[i] == NULL) && (b[i] == NULL) then A == B.  We
//               return B as the relative moniker and MK_S_HIM as the HRESULT.
//
//              * * *
//
//              If B is not a composite moniker, we compare the first
//              component of A to B.  Using the following notation:
//
//              (a[0], a[1], a[2], ... a[m]) and B (not a composite)
//
//              Case 6:
//              If a[0] == B, then B is a prefix of A.  We can construct the
//               correct relative path as:
//
//                !(a[1], ... a[m]) - inverse of remaining elements of A
//
//              Case 7:
//              Else if we can form a relative path between a[0] and B, we
//               can construct a relative path between A and B by combining
//               (in order):
//
//                !(a[1], ... a[m]) - inverse of remaining elements of A
//                (!a[0], B)     - relative path between a[0] and B
//
//              Case 8:
//              Else there is no relative path between a[0] and B so we just
//               return B as the relative moniker and MK_S_HIM as the HRESULT
//
//  History:    2-03-94   kevinro   Commented
//              07/10/94  AlexT     Handle pmkOther == this case
//              10/21/94  AlexT     Rewrite, plug leaks, add Algorithm
//
//  Notes:      InverseFromEnum can return S_OK with an out moniker of NULL
//              (if there are no more elements to enumerate)
//
//----------------------------------------------------------------------------

STDMETHODIMP CCompositeMoniker::RelativePathTo (LPMONIKER pmkOther,
                                                LPMONIKER FAR* ppmkRelPath)
{
    mnkDebugOut((DEB_TRACE,
                 "%p _IN CCompositeMoniker::RelativePathTo (%p, %p)\n",
                 this, pmkOther, ppmkRelPath));
    VDATEPTROUT(ppmkRelPath,LPMONIKER);
    VDATEIFACE(pmkOther);

    *ppmkRelPath = NULL;

    LPENUMMONIKER pEnumThis;    //  Enumerator for this moniker's components
    HRESULT hr;
    hr = Enum(TRUE, &pEnumThis);

    if (NOERROR == hr)
    {
        LPMONIKER pmkThisElement;   //  Next element of this moniker

        hr = pEnumThis->Next(1, &pmkThisElement, NULL);
        Assert(NOERROR == hr && "Moniker enumeration failure");

        if (IsCompositeMoniker(pmkOther))
        {
            LPENUMMONIKER pEnumOther;   //  Enumerator for other moniker's
                                        //  components
            hr = pmkOther->Enum(TRUE, &pEnumOther);
            if (NOERROR == hr)
            {
                LPMONIKER pmkOtherElement;  //  Next element of other moniker
                BOOL fMatch = FALSE;        //  Did any components match?

                //  we now have enumerators for both this and pmkOther
                Assert(pEnumThis && pEnumOther && "Bad return values");

                hr = pEnumOther->Next(1, &pmkOtherElement, NULL);
                Assert(NOERROR == hr && "Moniker enumeration failure");

                //  find the first element pair that aren't equal
                do
                {
                    if (pmkThisElement->IsEqual(pmkOtherElement) != NOERROR)
                    {
                        //  moniker elements aren't equal
                        break;
                    }

                    fMatch = TRUE;  //  at least one element pair matched
                    pmkThisElement->Release();
                    pmkOtherElement->Release();

                    pEnumThis->Next(1, &pmkThisElement, NULL);
                    pEnumOther->Next(1, &pmkOtherElement, NULL);
                } while (pmkThisElement != NULL && pmkOtherElement != NULL);

                if (!fMatch)
                {
                    //  Case 1:  No component monikers matched
                    LPMONIKER pmkBetween;  // Relative path between this
                                           // element and other element

                    hr = pmkThisElement->RelativePathTo(pmkOtherElement,
                                                        &pmkBetween);
                    if (NOERROR == hr)
                    {
                        //  Case 1A:  There is a relative path from first
                        //  element of this to first element of pmkOther
                        LPMONIKER pmkInverse;  // Inverse of remaining elements
                                               // of this moniker
                        hr = InverseFromEnum(pEnumThis, &pmkInverse);

                        if (SUCCEEDED(hr))
                        {
                            if (NULL == pmkInverse)
                            {
                                //  There were no remaining elements
                                hr = ComposeWithEnum(pmkBetween, pEnumOther,
                                                     ppmkRelPath);
                            }
                            else
                            {
                                LPMONIKER pmkTemp;  //  Inverse + Between

                                //  + relative path from this element to
                                //  Other element
                                hr = pmkInverse->ComposeWith(pmkBetween,
                                                             FALSE,
                                                             &pmkTemp);
                                if (SUCCEEDED(hr))
                                {
                                    //  + remaining elements of Other
                                    hr = ComposeWithEnum(pmkTemp,
                                                         pEnumOther,
                                                         ppmkRelPath);
                                    pmkTemp->Release();
                                }
                                pmkInverse->Release();
                            }
                        }
                        pmkBetween->Release();
                    }
                    else if (MK_S_HIM == hr)
                    {
                        //  Case 1B:  There is no relative path between the
                        //  elements - return pmkOther and MK_S_HIM
                        pmkBetween->Release();

                        pmkOther->AddRef();
                        *ppmkRelPath = pmkOther;
                        Assert(MK_S_HIM == hr && "Bad logic");
                    }
                    else
                    {
                        //  error case;  nothing to do
                        Assert(FAILED(hr) && "Unexpected success!");
                    }
                }
                else if (pmkThisElement != NULL)
                {
                    //  Case 2 and 3:  Both monikers have remaining pieces or
                    //  pmkOther is a prefix of this
                    LPMONIKER pmkInverse;   //  Inverse of remaining elements
                                            //  of this moniker
                    hr = InverseFromEnum(pEnumThis, &pmkInverse);

                    if (SUCCEEDED(hr))
                    {
                        LPMONIKER pmkElementInverse;  // Inverse of current
                                                      // element of this
                        hr = pmkThisElement->Inverse(&pmkElementInverse);
                        if (SUCCEEDED(hr))
                        {
                            LPMONIKER pmkTemp;  // partial result

                            if (NULL == pmkInverse)
                            {
                                //  There were no remaining elements of this
                                //  moniker - we begin with the element inverse
                                pmkTemp = pmkElementInverse;
                            }
                            else
                            {
                                hr = pmkInverse->ComposeWith(
                                                        pmkElementInverse,
                                                        FALSE, &pmkTemp);
                                pmkElementInverse->Release();
                            }

                            if (NULL == pmkOtherElement)
                            {
                                //  Case 3:  pmkOther is a prefix of this
                                *ppmkRelPath = pmkTemp;
                            }
                            else if (SUCCEEDED(hr))
                            {
                                //  Case 2:  both monikers had remaining pieces
                                LPMONIKER pmkTemp2;  // partial result

                                //  + other element
                                hr = pmkTemp->ComposeWith(pmkOtherElement,
                                                          FALSE,
                                                          &pmkTemp2);
                                if (SUCCEEDED(hr))
                                {
                                    //  + remaining other elements
                                    hr = ComposeWithEnum(pmkTemp2, pEnumOther,
                                                         ppmkRelPath);

                                    pmkTemp2->Release();
                                }
                                pmkTemp->Release();
                            }
                        }

                        if (NULL != pmkInverse)
                        {
                            pmkInverse->Release();
                        }
                    }
                }
                else if (pmkOtherElement != NULL)
                {
                    //  Case 4:  this is a prefix of pmkOther
                    hr = ComposeWithEnum(pmkOtherElement, pEnumOther,
                                         ppmkRelPath);
                }
                else
                {
                    //  Case 5:  this and pmkOther are equal
                    pmkOther->AddRef();
                    *ppmkRelPath = pmkOther;
                    hr = MK_S_HIM;
                }

                if (NULL != pmkOtherElement)
                {
                    pmkOtherElement->Release();
                }
                pEnumOther->Release();
            }
        }
        else
        {
            //  pmkrOther is not a composite moniker
            hr = pmkThisElement->IsEqual(pmkOther);
            if (NOERROR == hr)
            {
                //  Case 6:  first element of this equals pmkOther;  pmkOther
                //  is a prefix of this

                hr = InverseFromEnum(pEnumThis, ppmkRelPath);
                if (SUCCEEDED(hr) && (NULL == *ppmkRelPath))
                {
                    //  There were no more elements to enumerate;  return
                    //  pmkOther as the relative path
                    pmkOther->AddRef();
                    *ppmkRelPath = pmkOther;
                    hr = MK_S_HIM;
                }
            }
            else
            {
                LPMONIKER pmkBetween;
                hr = pmkThisElement->RelativePathTo(pmkOther, &pmkBetween);
                if (NOERROR == hr)
                {
                    //  Case 7:  There is a relative path between first element
                    //  of this and pmkOther
                    LPMONIKER pmkInverse;   //  Inverse of remaining elements
                                            //  of this moniker
                    hr = InverseFromEnum(pEnumThis, &pmkInverse);
                    if (SUCCEEDED(hr))
                    {
                        if (NULL == pmkInverse)
                        {
                            *ppmkRelPath = pmkBetween;
                            pmkBetween = NULL;
                        }
                        else
                        {
                            hr = pmkInverse->ComposeWith(pmkBetween, FALSE,
                                                        ppmkRelPath);
                            pmkInverse->Release();
                        }
                    }
                }
                else if (MK_S_HIM == hr)
                {
                    //  Case 8:  There is no relative path between first
                    //  element of this and pmkOther (which is pmkBetween),
                    //  return pmkOther and MK_S_HIM
                    *ppmkRelPath = pmkBetween;
                    pmkBetween = NULL;
                    Assert(NOERROR == pmkOther->IsEqual(*ppmkRelPath) &&
                           "Bad logic");
                    Assert(MK_S_HIM == hr && "Bad logic");
                }
                else
                {
                    //  error case;  nothing to do
                    Assert(FAILED(hr) && "Unexpected success!");
                }

                if (NULL != pmkBetween)
                {
                    pmkBetween->Release();
                }
            }
        }

        if (NULL != pmkThisElement)
        {
            pmkThisElement->Release();
        }

        pEnumThis->Release();
    }

    mnkDebugOut((DEB_TRACE,
                 "%p OUT CCompositeMoniker::RelativePathTo(%lx) [%p]\n",
                 this, hr, *ppmkRelPath));
    return(hr);
}

STDMETHODIMP CCompositeMoniker::GetDisplayName (LPBC pbc,
        LPMONIKER pmkToLeft, LPWSTR FAR* lplpszDisplayName)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::GetDisplayName(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(lplpszDisplayName, LPWSTR);
        *lplpszDisplayName = NULL;
        //REVIEW MM3 Find out who is calling this with pbc  == NULL and get them
        //      to stop it.
        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);

        LPWSTR lpszToLeft = NULL;
        LPWSTR lpszLeft = NULL;
        LPWSTR lpszRight = NULL;
        LPWSTR lpsz;
        HRESULT hresult;

        int n1, n2, n3;

        //      No error checking yet

        if (pmkToLeft)
        {
                hresult = pmkToLeft->GetDisplayName( pbc, NULL, &lpszToLeft );
                // AssertOutPtrParam(hresult, lpszToLeft);
                if (hresult != NOERROR)
                        goto errRtn;
        }
        hresult = m_pmkLeft->GetDisplayName(pbc, NULL, &lpszLeft);
        // AssertOutPtrParam(hresult, lpszLeft);
        if (hresult != NOERROR)
                goto errRtn;
        hresult = m_pmkRight->GetDisplayName(pbc, NULL, &lpszRight);
        // AssertOutPtrParam(hresult, lpszRight);
        if (hresult != NOERROR)
                goto errRtn;

        if (lpszToLeft) n1 = lstrlenW(lpszToLeft);
        else n1 = 0;
        n2 = lstrlenW(lpszLeft);
        n3 = lstrlenW(lpszRight);

        lpsz = (WCHAR *)
            CoTaskMemAlloc(sizeof(WCHAR) * (n1 + n2 + n3 + 1));

        if (lpsz == NULL)
        {
            hresult = E_OUTOFMEMORY;
            goto errRtn;
        }
        *lplpszDisplayName = lpsz;

        if (n1) _fmemmove( lpsz, lpszToLeft, n1 * sizeof(WCHAR));

        lpsz += n1;

        _fmemmove( lpsz, lpszLeft, n2 * sizeof(WCHAR));

        lpsz += n2;

        _fmemmove( lpsz, lpszRight, (n3 + 1)  * sizeof(WCHAR));

errRtn:

        CoTaskMemFree(lpszToLeft);
        CoTaskMemFree(lpszLeft);
        CoTaskMemFree(lpszRight);
        return hresult;
}


STDMETHODIMP CCompositeMoniker::ParseDisplayName (LPBC pbc, LPMONIKER pmkToLeft,
        LPWSTR lpszDisplayName, ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::ParseDisplayName(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(ppmkOut,LPMONIKER);
        *ppmkOut = NULL;
        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);
        VDATEPTRIN(lpszDisplayName, WCHAR);
        VDATEPTROUT(pchEaten,ULONG);

        HRESULT hresult = NOERROR;

        LPMONIKER pmkAllButLast = AllButLast();
        LPMONIKER pmkLast = Last();
        LPMONIKER pmkNewLeft = NULL ;

        Assert((pmkLast != NULL) && (pmkAllButLast != NULL));
        if (pmkToLeft) pmkToLeft->ComposeWith(pmkAllButLast, FALSE, &pmkNewLeft);
        //      REVIEW: check for error from ComposeWith
        else
        {
                pmkNewLeft = pmkAllButLast;
                pmkNewLeft->AddRef();
        }

        hresult = pmkLast->ParseDisplayName(pbc, pmkNewLeft, lpszDisplayName,
                pchEaten, ppmkOut);
        // AssertOutPtrIface(hresult, *ppmkOut);

        pmkAllButLast->Release();
        pmkLast->Release();
        if (pmkNewLeft) pmkNewLeft->Release();

        return hresult;
}


STDMETHODIMP CCompositeMoniker::IsSystemMoniker (THIS_ LPDWORD pdwType)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::IsSystemMoniker(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(pdwType,DWORD);

        *pdwType = MKSYS_GENERICCOMPOSITE;
        return NOERROR;
}




//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::GetComparisonData
//
//  Synopsis:   Get comparison data for registration in the ROT
//
//  Arguments:  [pbData] - buffer to put the data in.
//              [cbMax] - size of the buffer
//              [pcbData] - count of bytes used in the buffer
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//  Algorithm:  First verify buffer is big enough for the composite moniker
//              class id. Put that into the buffer. Then put the left part
//              into the buffer. Finally put the right part into the buffer.
//
//  History:    03-Feb-95   ricksa  Created
//
// Note:        Validating the arguments is skipped intentionally because this
//              will typically be called internally by OLE with valid buffers.
//
//----------------------------------------------------------------------------
STDMETHODIMP CCompositeMoniker::GetComparisonData(
    byte *pbData,
    ULONG cbMax,
    ULONG *pcbData)
{
    HRESULT hr = E_OUTOFMEMORY;
    ULONG cOrigMax = cbMax;
    ULONG cSizeHolder;

    do {

        // Can buffer hold the clsid?
        if (cbMax < sizeof(CLSID))
        {
            // No - so we are out of here;
            mnkDebugOut((DEB_ERROR,
                "CCompositeMoniker::GetComparisonData buffer not big enough"
                    " for CLSID\n"));
            break;
        }

        cbMax -= sizeof(CLSID);

        memcpy(pbData, &CLSID_CompositeMoniker, sizeof(CLSID));

        pbData += sizeof(CLSID);

        hr = BuildRotData(NULL, m_pmkLeft, pbData, cbMax, &cSizeHolder);

        if (FAILED(hr))
        {
            // No - so we are out of here;
            mnkDebugOut((DEB_ERROR,
                "CCompositeMoniker::GetComparisonData BuildRotData of left"
                    " failed %lx\n", hr));
            break;
        }

        cbMax -= cSizeHolder;
        pbData += cSizeHolder;

        hr = BuildRotData(NULL, m_pmkRight, pbData, cbMax, &cSizeHolder);

#if DBG == 1
        if (FAILED(hr))
        {
            mnkDebugOut((DEB_ERROR,
                "CCompositeMoniker::GetComparisonData BuildRotData of right"
                    " failed %lx\n", hr));
        }
#endif // DBG == 1

        cbMax -= cSizeHolder;

    } while(FALSE);

    *pcbData = (SUCCEEDED(hr)) ? cOrigMax - cbMax : 0;

    return hr;
}




/*
 *      Concatenate makes a composite moniker without ever calling
 *      ComposeWith on the individual pieces.
 */

STDAPI  Concatenate( LPMONIKER pmkFirst, LPMONIKER pmkRest,
        LPMONIKER FAR* ppmkComposite )
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Concatentate(pmkFirst=%x,pmkRest%x)\n",
                 pmkFirst,
                 pmkRest));

        LPMONIKER pmkConcat = CCompositeMoniker::Create( pmkFirst, pmkRest);
        *ppmkComposite = pmkConcat;

        if (pmkConcat == NULL)
        {
            return ResultFromScode(S_OOM);      
        }
        //      Create did the AddRef

        return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CCompositeMonierCF_CreateInstance
//
//  Synopsis:   Creates a generic composite.
//
//+---------------------------------------------------------------------------
HRESULT CCompositeMonikerCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    Win4Assert(pUnkOuter == NULL);
    Win4Assert(*ppv == NULL);
    return Concatenate(NULL, NULL, (IMoniker **)ppv);
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateGenericComposite
//
//  Synopsis:   Creates a generic composite from two other monikers
//
//  Effects:
//
//  Arguments:  [pmkFirst] --
//              [pmkRest] --
//              [ppmkComposite] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  CreateGenericComposite( LPMONIKER pmkFirst, LPMONIKER pmkRest,
        LPMONIKER FAR * ppmkComposite )
{
    OLETRACEIN((API_CreateGenericComposite, PARAMFMT("pmkFirst = %p, pmkRest= %p, ppmkComposite= %p"),
                        pmkFirst, pmkRest, ppmkComposite));
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::CreateGenericComposite(First=%x,Rest=%x)\n",
                 pmkFirst,
                 pmkRest));

    LPMONIKER pmkAllButFirstOfRest = NULL;
    LPMONIKER pmkFirstOfRest = NULL;
    LPMONIKER pmkAllButLastOfFirst = NULL;
    LPMONIKER pmkLastOfFirst = NULL;
    LPMONIKER pmk = NULL;
    LPMONIKER pmk2 = NULL;

    CCompositeMoniker *pCMk = NULL;
    CCompositeMoniker *pCMkRest = NULL;

    HRESULT hresult;

    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pmkFirst);
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pmkRest);

    //
    // Initialize ppmkComposite. Might return in the middle of this
    // routine, so be sure its NULL in the error case
    //

    *ppmkComposite = NULL;


    //
    // If both pointers are NULL, return a NULL composite
    //
    if ((pmkFirst == NULL) && (pmkRest == NULL))
    {
        hresult = NOERROR;
        goto errRtn;
    }

    //
    // Otherwise, if one pointer is NULL, return the other as the
    // composite.
    //
    if (pmkFirst == NULL)
    {
        *ppmkComposite = pmkRest;
        pmkRest->AddRef();
        hresult = NOERROR;
        goto errRtn;
    }

    if (pmkRest == NULL)
    {
        *ppmkComposite = pmkFirst;
        pmkFirst->AddRef();
        hresult = NOERROR;
        goto errRtn;
    }


    //
    // Handle the two cases where pmkFirst is NOT a composite
    //

    pCMk = IsCompositeMoniker( pmkFirst );
    if (!pCMk)
    {
        //
        // If pmkRest is not a composite, then we have two
        // monikers that are considered 'simple' monikers.
        //

        pCMk = IsCompositeMoniker( pmkRest );
        if (!pCMk)
        {
            mnkDebugOut((DEB_ITRACE,
                         "::CreateGenericComposite( S(%x) o S(%x) )\n",
                         pmkFirst,
                         pmkRest));

            //  Case 1:  two simple monikers
        
            hresult = pmkFirst->ComposeWith(pmkRest, TRUE, ppmkComposite);
        
            if (hresult == MK_E_NEEDGENERIC)
            {
                Assert(*ppmkComposite == NULL);
                hresult = Concatenate(pmkFirst, pmkRest, ppmkComposite);
                goto errRtn;
            }
        }
        else
        {

            //
            //  Case 2:  S o C(b1, b2, b3).
            //
            //  Compose S with b1,
            //  then
            //  Compose ( S o b1 ) with C( b2, b3, ...)
            //
            //


            mnkDebugOut((DEB_ITRACE,
                         "::CreateGenericComposite( S(%x) o C(%x) )\n",
                         pmkFirst,
                         pmkRest));

            //
            // Since the right side is a composite, the following should
            // always exist. It would be a severe suprise if it didn't.
            //

            pmkFirstOfRest = pCMk->First();

            //
            // However, the AllButFirst function needs to allocate memory,
            // which might fail.
            //

            pmkAllButFirstOfRest = pCMk->AllButFirst();

            if (pmkAllButFirstOfRest == NULL)
            {
                hresult = E_OUTOFMEMORY;
                goto exitRet;
            }

            hresult = pmkFirst->ComposeWith(pmkFirstOfRest, TRUE, &pmk);                

            if ( hresult == MK_E_NEEDGENERIC)
            {
                Assert(pmk == NULL);
                hresult = Concatenate(pmkFirst, pmkRest, ppmkComposite);
            }
            else if (SUCCEEDED(hresult))
            {
                //
                // pmkFirst->ComposeWith can succeed, but return NULL.
                // If it doesn't return NULL, then ( a o b1 ) is a
                // moniker of some ilk. Create a generic composite with
                // this result, and the rest of the moniker
                //
                if (pmk != NULL)
                {
                    hresult = CreateGenericComposite(pmk,
                                                     pmkAllButFirstOfRest,
                                                     ppmkComposite);
                }
                else
                {
                    //
                    //  pmkFirst and pmkFirstOfRest annihilated each other.
                    //  This is indicated by a success code, and a pmk == NULL,
                    //  which is how we got here.
                    //

                    *ppmkComposite = pmkAllButFirstOfRest;

                    //
                    // pmkAllButFirstOfRest is the moniker we want to
                    // return.
                    //

                    pmkAllButFirstOfRest->AddRef();

                    hresult = NOERROR;
                }
            }
        }

        //
        // We are done, goto exit routine
        //
        goto exitRet;

    }

    //
    // We have determined that pmkFirst is a Composite Moniker
    //

    pmkAllButLastOfFirst = pCMk->AllButLast();

    if (pmkAllButLastOfFirst == NULL)
    {
        hresult = E_OUTOFMEMORY;
        goto exitRet;
    }

    pmkLastOfFirst = pCMk->Last();

    if (pmkLastOfFirst == NULL)
    {
        hresult = E_OUTOFMEMORY;
        goto exitRet;
    }

    //
    // Determine if pmkRest is a composite. If not, then just
    // compose the last of pmkFirst with pmkRest
    //

    pCMkRest = IsCompositeMoniker(pmkRest);
    if (!pCMkRest)
    {
        //      case 3:  (a1 a2 a3...) o b

        mnkDebugOut((DEB_ITRACE,
                    "::CreateGenericComposite( C(%x) o S(%x) )\n",
                    pmkFirst,
                    pmkRest));

        hresult = pmkLastOfFirst->ComposeWith(pmkRest, TRUE, &pmk);

        if (MK_E_NEEDGENERIC == GetScode(hresult))
        {
            Assert(pmk==NULL);
            hresult = Concatenate(pmkFirst, pmkRest, ppmkComposite);
        }
        else if (SUCCEEDED(hresult))
        {
            //
            // If pmk != NULL, create a generic composite out of
            // of the results
            if (pmk != NULL)
            {
                hresult = CreateGenericComposite(pmkAllButLastOfFirst,
                                                 pmk,
                                                 ppmkComposite);                
            }
            else
            {
                //
                // a3 o b resulted in NULL. Therefore, the result
                // of the composition is pmkAllButLastOfFirst
                //
                *ppmkComposite = pmkAllButLastOfFirst;
                pmkAllButLastOfFirst->AddRef();
                hresult = NOERROR;
            }
        }

        goto exitRet;
    }

    //
    //  case 4:  (a1 a2 ... aN) o (b1 b2 .. bN )
    //
    //  Compose two composite monikers. In order to compose them, we need
    //  to compose ( A ) with b1, then recurse to do ( A b1 ) with b2, etc
    //
    //
    mnkDebugOut((DEB_ITRACE,
                 "::CreateGenericComposite( C(%x) o C(%x) )\n",
                 pmkFirst,
                 pmkRest));

    pmkFirstOfRest = pCMkRest->First();

    if (pmkFirstOfRest == NULL)
    {
        hresult = E_OUTOFMEMORY;
        goto exitRet;
        
    }

    pmkAllButFirstOfRest = pCMkRest->AllButFirst();

    if (pmkAllButFirstOfRest == NULL)
    {
        hresult = E_OUTOFMEMORY;
        goto exitRet;
    }

    hresult = pmkLastOfFirst->ComposeWith(pmkFirstOfRest, TRUE, &pmk);

    if (hresult == MK_E_NEEDGENERIC)
    {
        //
        // In this case, aN didn't know how to compose with b1, other than
        // to do it generically. The best we can do is to generically
        // compose the two halves.
        //

        Assert(pmk == NULL);

        hresult = Concatenate(pmkFirst, pmkRest, ppmkComposite);
    }
    else if (SUCCEEDED(hresult))
    {
        //
        // If pmk is not NULL, then there was a result of the composition.
        // Create a new composite with the first part, then compose it with
        // whats left of the second part.
        //
        if (pmk != NULL)
        {
            hresult = CreateGenericComposite(pmkAllButLastOfFirst, pmk, &pmk2);

            if (FAILED(hresult))
            {
                goto exitRet;
            }

            hresult = CreateGenericComposite(pmk2, pmkAllButFirstOfRest, ppmkComposite);
        }
        else
        {
            //
            //  pmkLastOfFirst annihilated pmkFirstOfRest
            //
            //  Thats OK. Compose the remaining parts.
            //
            hresult = CreateGenericComposite(pmkAllButLastOfFirst,
                                             pmkAllButFirstOfRest,
                                             ppmkComposite);
        }
    }

exitRet:

    if (pmkFirstOfRest) pmkFirstOfRest->Release();
    if (pmkAllButFirstOfRest) pmkAllButFirstOfRest->Release();
    if (pmkAllButLastOfFirst) pmkAllButLastOfFirst->Release();
    if (pmkLastOfFirst) pmkLastOfFirst->Release();
    if (pmk) pmk->Release();
    if (pmk2) pmk2->Release();

    CALLHOOKOBJECTCREATE(hresult, CLSID_CompositeMoniker, IID_IMoniker, (IUnknown **)ppmkComposite);

errRtn:
    OLETRACEOUT((API_CreateGenericComposite, hresult));

    return hresult;
}



//------------------------------------------------


//      Implementation of CCompositeMonikerEnum

CCompositeMonikerEnum::CCompositeMonikerEnum( BOOL fForward,
        CCompositeMoniker FAR* pCM)
{
        GET_A5();
        Assert(pCM != NULL);
        m_refs = 0;
        m_pCM = pCM;
        pCM -> AddRef();
        m_fForward = fForward;
        m_pBase = NULL;
        m_pTop = NULL;
        m_pNext = GetNext(pCM); //      m_pNext points to the next moniker to return
}



CCompositeMonikerEnum::~CCompositeMonikerEnum(void)
{
        M_PROLOG(this);
        se FAR* pse;
        se FAR* pse2;
        if (m_pCM)
                m_pCM->Release();
        for (pse = m_pBase; pse != NULL; pse = pse2)
        {
                pse2 = pse->m_pseNext;
                pse->m_pseNext = NULL; // workaround for compiler optimization bug
                delete pse;
        }
}


BOOL CCompositeMonikerEnum::Push( CCompositeMoniker FAR* pCM)
//      push the composite moniker onto our stack
{
    M_PROLOG(this);
    se FAR * pse;

    pse = new se(pCM);
    if (pse == NULL)
    {
        return FALSE;
    }
    pse->m_psePrev = m_pTop;
    if (m_pTop) m_pTop->m_pseNext = pse;
    m_pTop = pse;
    if (m_pBase == NULL) m_pBase = pse;
    return TRUE;
}


LPMONIKER CCompositeMonikerEnum::GetNext( LPMONIKER pmk )
{
    M_PROLOG(this);
    LPMONIKER pmkRover = pmk;
    Assert(pmk != NULL);
    if (pmk == NULL) return NULL;

    CCompositeMoniker *pCMk; ;
    while ((pCMk = IsCompositeMoniker(pmkRover)) != NULL)
    {
        if (!Push(pCMk))
        {
            return NULL;
        }
        pmkRover = (m_fForward ? pCMk->m_pmkLeft : pCMk->m_pmkRight);
    }
    return pmkRover;
}


LPMONIKER CCompositeMonikerEnum::Pop( void )
{
        M_PROLOG(this);
        CCompositeMoniker FAR* pCM;
        se FAR * pse;

        if (m_pTop == NULL) return NULL;
        pCM = m_pTop->m_pCM;
        if ((pse = m_pTop->m_psePrev) != NULL)
        {
                pse->m_pseNext = NULL;
        }
        else m_pBase = NULL;
        delete m_pTop;
        m_pTop = pse;
        Assert(pCM->m_pmkRight != NULL);
        Assert(pCM->m_pmkLeft != NULL);
        return GetNext(m_fForward ? pCM->m_pmkRight : pCM->m_pmkLeft);
}


STDMETHODIMP CCompositeMonikerEnum::QueryInterface (THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
        M_PROLOG(this);
        VDATEPTROUT(ppvObj, LPVOID);
        *ppvObj = NULL;
        VDATEIID(riid);

        if (IsEqualIID(riid, IID_IEnumMoniker)
            || IsEqualIID(riid, IID_IUnknown))
        {
                *ppvObj = this;
                AddRef();
                return NOERROR;
        }
        *ppvObj = NULL;
        return ResultFromScode(E_NOINTERFACE);
}




STDMETHODIMP_(ULONG) CCompositeMonikerEnum::AddRef (THIS)
{
        M_PROLOG(this);
        InterlockedIncrement((long *)&m_refs);
        return m_refs;
}



STDMETHODIMP_(ULONG) CCompositeMonikerEnum::Release (THIS)
{
    M_PROLOG(this);
    Assert(m_refs != 0);

    ULONG ul = m_refs;

    if (InterlockedDecrement((long *)&m_refs) == 0)
    {
        delete this;
        return 0;
    }
    return ul - 1;
}



STDMETHODIMP CCompositeMonikerEnum::Next (THIS_ ULONG celt, LPMONIKER FAR* reelt, ULONG FAR* pceltFetched)
{
        A5_PROLOG(this);
        VDATEPTROUT(reelt, LPMONIKER);
        *reelt = NULL;
        if (pceltFetched) VDATEPTROUT(pceltFetched, ULONG);

        ULONG count = 0;
        while (count < celt)
        {
                if (m_pNext)
                {
                        *reelt = m_pNext;
                        m_pNext->AddRef();
                        count++;
                        reelt++;
                        m_pNext = Pop();
                }
                else goto ret;
        }
ret:
        if (pceltFetched) *pceltFetched = count;
        if (count == celt){
                RESTORE_A5();
                return NOERROR;
        }
        RESTORE_A5();
        return ResultFromScode(S_FALSE);
}



STDMETHODIMP CCompositeMonikerEnum::Skip (THIS_ ULONG celt)
{
        M_PROLOG(this);
        ULONG count = 0;
        while (count < celt)
        {
                if (m_pNext)
                {
                        count++;
                        m_pNext = Pop();
                }
                else return ResultFromScode(S_FALSE);
        }
        return NOERROR;
}



STDMETHODIMP CCompositeMonikerEnum::Reset (THIS)
{
        M_PROLOG(this);
        se FAR* pse;
        se FAR* pse2;
        for (pse=m_pBase; pse != NULL; pse = pse2)
        {
                pse2 = pse->m_pseNext;
                pse->m_pseNext = NULL; // workaround for compiler optimization bug
                delete pse;
        }
        m_pBase = NULL;
        m_pTop = NULL;
        m_pNext = GetNext(m_pCM);
        if (m_pNext) return NOERROR;
        return ResultFromScode(S_FALSE);
}



STDMETHODIMP CCompositeMonikerEnum::Clone (THIS_ LPENUMMONIKER FAR* ppenm)
{
        M_PROLOG(this);
        VDATEPTROUT(ppenm, LPENUMMONIKER);
        *ppenm = NULL;

        CairoleAssert(FALSE && "Clone not implemented for composite moniker enums");
        return ResultFromScode(E_NOTIMPL);      //      Clone not implemented for composite moniker enums
}


LPENUMMONIKER CCompositeMonikerEnum::Create
        (BOOL fForward, CCompositeMoniker FAR* pCM)
{
    CCompositeMonikerEnum FAR* pCME =
        new CCompositeMonikerEnum(fForward, pCM);
    if (pCME  &&  pCME->m_pNext)
    {
        pCME->AddRef();
        return pCME;
    }
    else
    {
        delete pCME;
        return NULL;
    }
}



STDAPI  MonikerCommonPrefixWith( LPMONIKER pmkThis, LPMONIKER pmkOther,
    LPMONIKER FAR * ppmkPrefix)
{
    OLETRACEIN((API_MonikerCommonPrefixWith, PARAMFMT("pmkThis= %p, pmkOther= %p, ppmkPrefix= %p"),
                pmkThis, pmkOther, ppmkPrefix));

    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::CommonPrefixWith(pmkThis=%x,pmkOther=%x)\n",
                 pmkThis,
                 pmkOther));

    HRESULT hresult;

    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pmkThis);
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pmkOther);

    if (IsCompositeMoniker(pmkThis))
    {
        hresult = pmkThis->CommonPrefixWith(pmkOther, ppmkPrefix);
                // AssertOutPtrIface(hresult, *ppmkPrefix);
        goto errRtn;
    }

    if (IsCompositeMoniker(pmkOther))
    {
        hresult = pmkOther->CommonPrefixWith(pmkThis, ppmkPrefix);
                // AssertOutPtrIface(hresult, *ppmkPrefix);
        if (MK_S_HIM == GetScode(hresult))
            hresult = ResultFromScode(MK_S_ME);
        else if (MK_S_ME == GetScode(hresult))
            hresult = ResultFromScode(MK_S_HIM);
        goto errRtn;
    }
    //  This doesn't get called unless the monikers are atomic and unrelated
    *ppmkPrefix = NULL;

    hresult = ResultFromScode(MK_E_NOPREFIX);

errRtn:    
   OLETRACEOUT((API_MonikerCommonPrefixWith, hresult));

   return hresult;
}



STDAPI  MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER
                                FAR* ppmkRelPath, BOOL dwReserved)
{
    //  An implementation of RelativePathTo should check to see if the
    //  other moniker is a type that it recognizes and handles specially.
    //  If not, it should call MonikerRelativePathTo, which will handle
    //  the generic composite cases correctly.  Note that this cannot be
    //  done entirely in the CCompositeMoniker implementation because if the
    //  first moniker is not a generic composite and the second is, then
    //  this code is required.

    //  CODEWORK:  This comment is obsolete.  fCalledFromMethod has changed
    //  to dwReserved wich must always be TRUE
    //
    //  If fCalledFromMethod is false, and if neither moniker is a generic
    //  composite, then this function will call pmkSrc->RelativePathTo.  If
    //  fCalledFromMethod is true, it will not call pmkSrc->RelativePathTo,
    //  since the assumption is that pmkSrc->RelativePathTo has called
    //  MonikerRelativePathTo after determining that pmkDest is not of a type
    //  that it recognizes.
    
    OLETRACEIN((API_MonikerRelativePathTo, 
                PARAMFMT("pmkSrc= %p, pmkDest= %p, ppmkRelPath= %p, dwReserved= %B"),
                pmkSrc, pmkDest, ppmkRelPath, dwReserved));

    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::MonikerRelativePathTo(pmkSrc=%x,pmkDest=%x)\n",
                 pmkSrc,
                 pmkDest));
    
    HRESULT hresult;
    int caseId = 0;
    LPMONIKER pmkFirst = NULL;
    LPMONIKER pmkRest = NULL;
    LPMONIKER pmkPartialRelPath = NULL;
    CCompositeMoniker FAR* pccmDest;

    //  Check the reserved parameter, which must be TRUE
    if (dwReserved != TRUE)
    {
        *ppmkRelPath = NULL;
        hresult = E_INVALIDARG;
        goto errRtn;
    }
    
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pmkSrc);
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pmkDest);
    
    VDATEPTROUT_LABEL(ppmkRelPath,LPMONIKER, errRtn, hresult);
    *ppmkRelPath = NULL;
    VDATEIFACE_LABEL(pmkSrc, errRtn, hresult);
    VDATEIFACE_LABEL(pmkDest, errRtn, hresult);
    
    
    
    pccmDest = IsCompositeMoniker(pmkDest);
    
    if (IsCompositeMoniker(pmkSrc)) caseId++;
    if (pccmDest) caseId += 2;
    
    switch (caseId)
    {
    case 0:     //      neither moniker is composite
        if (dwReserved)
        {
            *ppmkRelPath = pmkDest;
            pmkDest->AddRef();
            hresult = ResultFromScode(MK_S_HIM);
            goto errRtn;
        }
        // fall-through to the next case if !dwReserved is
        // deliberate
    case 3:
    case 1:     // Src is composite, other might be.  Let CCompositeMoniker
        // implementation handle it.
        hresult = pmkSrc->RelativePathTo(pmkDest, ppmkRelPath);
        // AssertOutPtrIface(hresult, *ppmkRelPath);
        goto errRtn;
        
    case 2:     // Src is not composite, Dest is.
        pmkFirst = pccmDest->First();
        pmkRest = pccmDest->AllButFirst();
        if (NOERROR == pmkSrc->IsEqual(pmkFirst))
        {
            *ppmkRelPath = pmkRest;
            pmkRest->AddRef();
            hresult = NOERROR;
        }
        else
        {
            hresult = pmkSrc->RelativePathTo(pmkFirst, &pmkPartialRelPath);
            // AssertOutPtrIface(hresult, pmkPartialRelPath);
            if (NOERROR == hresult)
            {
                hresult = CreateGenericComposite(pmkPartialRelPath, pmkRest,
                                                 ppmkRelPath);
            }
            else
            {
                *ppmkRelPath = pmkDest;
                pmkDest->AddRef();
                hresult = ResultFromScode(MK_S_HIM);
            }
        }
        
        if (pmkFirst) pmkFirst->Release();
        if (pmkRest) pmkRest->Release();
        if (pmkPartialRelPath) pmkPartialRelPath->Release();
    }
    
errRtn:
    OLETRACEOUT((API_MonikerRelativePathTo, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Class:      CTrackingCompositeMoniker
//
//  Purpose:    Provide implementation of ITrackingMoniker for composite
//              monikers.
//
//  Notes:      This object responds to ITrackingMoniker and forwards other
//              QI's to the composite moniker.
//
//              EnableTracking currently only enables tracking on the moniker to
//              left.  When we expose this functionality, we will need to
//              try QI to ITrackingMoniker on the right moniker and pass the
//              moniker to left (as all other moniker fns do.)
//
//--------------------------------------------------------------------------


#ifdef _TRACKLINK_
VOID
CTrackingCompositeMoniker::SetParent(CCompositeMoniker *pCCM)
{
    _pCCM = pCCM;
}

STDMETHODIMP CTrackingCompositeMoniker::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(IID_ITrackingMoniker, riid))
    {
        *ppv = (ITrackingMoniker*) this;
        _pCCM->AddRef();
        return(S_OK);
    }
    else
        return(_pCCM->QueryInterface(riid, ppv));
}

STDMETHODIMP_(ULONG) CTrackingCompositeMoniker::AddRef()
{
    return(_pCCM->AddRef());
}

STDMETHODIMP_(ULONG) CTrackingCompositeMoniker::Release()
{
    return(_pCCM->Release());
}

STDMETHODIMP CTrackingCompositeMoniker::EnableTracking( IMoniker *pmkToLeft, ULONG ulFlags )
{
    ITrackingMoniker *ptm=NULL;
    HRESULT hr;

    hr = _pCCM->m_pmkLeft->QueryInterface(IID_ITrackingMoniker, (void**) &ptm);
    if (hr == S_OK)
    {
        hr = ptm->EnableTracking(NULL, ulFlags);

        if (hr == S_OK)
        {
            if (ulFlags & OT_ENABLEREDUCE)
            {
                _pCCM->m_fReduceForced = TRUE;
            }
    
            if (ulFlags & OT_DISABLEREDUCE)
            {
                _pCCM->m_fReduceForced = FALSE;
            }
        }

        ptm->Release();
    }
    return(hr);
}
#endif





#ifdef _DEBUG

STDMETHODIMP_(void) NC(CCompositeMoniker,CDebug)::Dump( IDebugStream FAR * pdbstm)
{
        VOID_VDATEIFACE(pdbstm);

        *pdbstm << "CCompositeMoniker @" << (VOID FAR *)m_pCompositeMoniker;
        *pdbstm << '\n';
        pdbstm->Indent();
        *pdbstm << "Refcount is " << (int)(m_pCompositeMoniker->m_refs) << '\n';
        pdbstm->Indent();

        *pdbstm << m_pCompositeMoniker->m_pmkLeft;
        *pdbstm << m_pCompositeMoniker->m_pmkRight;

        pdbstm->UnIndent();
        pdbstm->UnIndent();
}

STDMETHODIMP_(BOOL) NC(CCompositeMoniker,CDebug)::IsValid( BOOL fSuspicious )
{
        return ((LONG)(m_pCompositeMoniker->m_refs) > 0);
        //      add more later, maybe
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\cdialog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       dialog.cxx
//
//  Contents:
//
//  Classes:    CHlprDialog
//
//  Functions:  DialogProc
//
//  History:    4-12-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include <ole2int.h>
#include "cdialog.h"

//+---------------------------------------------------------------------------
//
//  Member:     CHlprDialog::ShowDialog
//
//  Synopsis:   Creates a MODAL dialog so that its DialogProc member
//              function can be invoked.
//
//  Arguments:  [hinst]        - handle of the application instance
//              [lpszTemplate] - identifies the dialog box template
//              [hwndOwner]    - handle of the owner window
//
//  Returns:    return value from the dialog box
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      The dialog box object exists until deleted by the caller.
//              It can be shown any number of times.
//
//              This function is analgous to Windows' DialogBox function.  The
//              main difference being that you don't specify a DialogProc;
//              you override the pure virtal function CHlprDialog::DialogProc.
//
//----------------------------------------------------------------------------

INT_PTR CHlprDialog::ShowDialog(HINSTANCE hinst, LPCTSTR lpszTemplate, HWND hwndOwner)
{
    m_hInstance = hinst;
    return(DialogBoxParam(hinst, lpszTemplate, hwndOwner, (DLGPROC)::DialogProc, (LPARAM)this));
}

//+--------------------------------------------------------------------------
//
//  Member:     CHlprDialog::CreateDlg
//
//  Synopsis:   Creates the dialog so that its DialogProc member function
//              can be invoked.
//
//  Arguments:  [hinst]        - handle of the application instance
//              [lpszTemplate] - identifies the dialog box template
//              [hwndOwner]    - handle of the owner window
//
//  Returns:    handle to the dialog box
//
//  History:    7-02-1997   stevebl   Created
//
//  Notes:      The dialog box object exists until deleted by the caller.
//              It can be shown any number of times.
//
//              This function is analgous to Windows' CreateDialog function.
//              The main difference being that you don't specify a
//              DialogProc; you override the pure virtal function
//              CHlprDialog::DialogProc.
//
//              This is an alternate method of initializing the dialog box
//              and should not be used if ShowDialog is used.
//
//---------------------------------------------------------------------------

HWND CHlprDialog::CreateDlg(HINSTANCE hinst, LPCTSTR lpszTemplate, HWND hwndOwner)
{
    m_hInstance = hinst;
    return(CreateDialogParam(hinst, lpszTemplate, hwndOwner, (DLGPROC)::DialogProc, (LPARAM)this));
}

//+---------------------------------------------------------------------------
//
//  Function:   DialogProc
//
//  Synopsis:   Common DialogProc used by all CHlprDialog class objects.
//
//  Arguments:  [hwndDlg] - handle of dialog box
//              [uMsg]    - message
//              [wParam]  - first message parameter
//              [lParam]  - second message parameter
//
//  Returns:    response from the CHlprDialog::DialogProc method
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      This procedure is the DialogProc registered for all dialogs
//              created with the CHlprDialog class.  It uses the parameter
//              passed with the WM_INITDIALOG message to identify the dialog
//              classes' "this" pointer which it then stores in the window
//              structure's GWL_USERDATA field.  All subsequent messages
//              can then be forwarded on to the correct dialog class's
//              DialogProc method by using the pointer stored in the
//              GWL_USERDATA field.
//
//----------------------------------------------------------------------------

BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHlprDialog * pdlg;
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // This message is how we identify the dialog object.

        // get a pointer to the window class object
        pdlg = (CHlprDialog *) lParam;
        // set its USERDATA word to point to the class object
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdlg);
        break;
    default:
        // get a pointer to the window class object
        pdlg = (CHlprDialog *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        break;
    }
    // and call its message proc method
    if (pdlg != (CHlprDialog *) 0)
    {
        return(pdlg->DialogProc(hwndDlg, uMsg, wParam, lParam));
    }
    else
    {
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\cbasemon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       cbasemon.cxx
//
//  Contents:   Implementation of CBaseMoniker
//
//  Classes:
//
//  Functions:
//
//  History:    12-27-93    ErikGav     Commented
//
//              03-??-97    Ronans      Changes for Objref moniker support
//              06-25-97    Ronans      Enum should return S_OK by default;
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "mnk.h"

inline  HRESULT DerivedMustImplement( void )
{
    return ResultFromScode(E_NOTIMPL);  //  The derived class must implement this method
}
inline
HRESULT InappropriateMemberFunction( void )
{
    return ResultFromScode(E_NOTIMPL);  //  Member function inappropriate for moniker class
}

CBaseMoniker::~CBaseMoniker()
{
    // do nothing at present - just a place holder for virtual destructor if
    // needed
}


STDMETHODIMP CBaseMoniker::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    M_PROLOG(this);

    // Do not validate input as it has already been validated
    // by derived classes.

    if (IsEqualIID(riid, IID_IROTData))
    {
        *ppvObj = (IROTData *) this;
    }
    else if (IsEqualIID(riid, IID_IMoniker)
	|| IsEqualIID(riid, IID_IUnknown)
	|| IsEqualIID(riid, IID_IPersistStream)
	|| IsEqualIID(riid, IID_IInternalMoniker))
    {
	*ppvObj = this;
    }
    else if (IsEqualIID(riid, IID_IMarshal))
    {
	*ppvObj = &m_marshal;
    }
    else
    {
	*ppvObj = NULL;
	return E_NOINTERFACE;
    }

    InterlockedIncrement((long *)&m_refs);
    return NOERROR;
}


STDMETHODIMP_(ULONG) CBaseMoniker::AddRef ()
{
    mnkDebugOut((DEB_TRACE, "%p CBaseMoniker::AddRef(%ld)\n",
                 this, m_refs + 1));

    return InterlockedIncrement((long *)&m_refs);
}

STDMETHODIMP_(ULONG) CBaseMoniker::Release(void)
{
    mnkDebugOut((DEB_TRACE, "%p CBaseMoniker::Release(%ld)\n",
                 this, m_refs - 1));

    ULONG ul = m_refs;

    if (InterlockedDecrement((long *)&m_refs) == 0)
    {
    	delete this;
    	return 0;
    }
    return ul - 1;
}


STDMETHODIMP CBaseMoniker::IsDirty (THIS)
{
    M_PROLOG(this);
    return ResultFromScode(S_FALSE);
    //  monikers are immutable so they are either always dirty or never dirty.
    //
}

STDMETHODIMP CBaseMoniker::Load (THIS_ LPSTREAM pStm)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}


STDMETHODIMP CBaseMoniker::Save (THIS_ LPSTREAM pStm,
	    BOOL fClearDirty)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}


STDMETHODIMP CBaseMoniker::GetSizeMax (THIS_ ULARGE_INTEGER FAR * pcbSize)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

    // *** IMoniker methods ***
STDMETHODIMP CBaseMoniker::BindToObject (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    REFIID riidResult, LPVOID FAR* ppvResult)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

STDMETHODIMP CBaseMoniker::BindToStorage (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    REFIID riid, LPVOID FAR* ppvObj)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

STDMETHODIMP CBaseMoniker::Reduce (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER FAR*
    ppmkToLeft, LPMONIKER FAR * ppmkReduced)
{
    M_PROLOG(this);
    *ppmkReduced = this;
    AddRef();
    return ResultFromScode(MK_S_REDUCED_TO_SELF);
}

STDMETHODIMP CBaseMoniker::ComposeWith (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
    LPMONIKER FAR* ppmkComposite)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

STDMETHODIMP CBaseMoniker::Enum (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
    M_PROLOG(this);
 	VDATEPTROUT(ppenumMoniker,LPENUMMONIKER);
    if (ppenumMoniker)
    {
    	*ppenumMoniker = NULL;
    	return S_OK;
    }

    return E_INVALIDARG;
}

STDMETHODIMP CBaseMoniker::IsEqual (THIS_ LPMONIKER pmkOtherMoniker)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

STDMETHODIMP CBaseMoniker::Hash (THIS_ LPDWORD pdwHash)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

STDMETHODIMP CBaseMoniker::GetTimeOfLastChange (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    FILETIME FAR* pfiletime)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

STDMETHODIMP CBaseMoniker::Inverse (THIS_ LPMONIKER FAR* ppmk)
{
    M_PROLOG(this);
    *ppmk = NULL;
    return ResultFromScode(MK_E_NOINVERSE);
}

STDMETHODIMP CBaseMoniker::CommonPrefixWith (LPMONIKER pmkOther, LPMONIKER FAR*
    ppmkPrefix)
{
    // use default behavior for most cases
    return MonikerCommonPrefixWith(this, pmkOther, ppmkPrefix);
}

STDMETHODIMP CBaseMoniker::RelativePathTo (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
    ppmkRelPath)
{
    // use default behavior for most cases
    return MonikerRelativePathTo(this, pmkOther, ppmkRelPath, TRUE);
}

STDMETHODIMP CBaseMoniker::GetDisplayName (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    LPWSTR FAR* lplpszDisplayName)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

STDMETHODIMP CBaseMoniker::ParseDisplayName (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    LPWSTR lpszDisplayName, ULONG FAR* pchEaten,
    LPMONIKER FAR* ppmkOut)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}


STDMETHODIMP CBaseMoniker::IsSystemMoniker (THIS_ LPDWORD pdwMksys)
{
    M_PROLOG(this);
  VDATEPTROUT (pdwMksys, DWORD);

  *pdwMksys = 0;
  return NOERROR;
}


STDMETHODIMP CBaseMoniker::IsRunning (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
	      LPMONIKER pmkNewlyRunning)
{
    M_PROLOG(this);
  VDATEIFACE (pbc);
  LPRUNNINGOBJECTTABLE pROT;
  HRESULT hresult;


  if (pmkToLeft)
    VDATEIFACE (pmkToLeft);
  if (pmkNewlyRunning)
    VDATEIFACE (pmkNewlyRunning);

  if (pmkToLeft == NULL)
  {
      if (pmkNewlyRunning != NULL)
      {
      return pmkNewlyRunning->IsEqual (this);
      }
      else
      {
      hresult = pbc->GetRunningObjectTable (&pROT);
      if (hresult == NOERROR)
      {
	  hresult = pROT->IsRunning (this);
	  pROT->Release ();
      }
      return hresult;
      }
  }
  else
  {
      return ResultFromScode(S_FALSE);
  }

}


STDMETHODIMP CBaseMoniker::GetComparisonData(
    byte *pbData,
    ULONG cbMax,
    ULONG *pcbData)
{
    return InappropriateMemberFunction();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\citemmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       citemmon.cxx
//
//  Contents:   Implementation of CItemMoniker
//
//  Classes:
//
//  Functions:
//
//  History:    12-27-93   ErikGav   Created
//		        01-14-94   KevinRo   Updated so it actually works
//		        06-14-94   Rickhi    Fix type casting
//              10-13-95   stevebl   threadsafty
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "citemmon.hxx"
#include "cantimon.hxx"
#include "mnk.h"

#include <olepfn.hxx>
#include <rotdata.hxx>


INTERNAL RegisterContainerBound(LPBC pbc, LPOLEITEMCONTAINER pOleCont);


INTERNAL_(CItemMoniker *) IsItemMoniker( LPMONIKER pmk )
{
    CItemMoniker *pIMk;

    if ((pmk->QueryInterface(CLSID_ItemMoniker, (void **)&pIMk)) == S_OK)
    {
        // we release the AddRef done by QI, but still return the pointer
        pIMk->Release();
        return pIMk;
    }

    // dont rely on user implementations to set pIMk to NULL on failed QI.
    return pIMk;
}


//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::CItemMoniker
//
//  Synopsis:   Constructor
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-17-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CItemMoniker::CItemMoniker() CONSTR_DEBUG
{
    mnkDebugOut((DEB_ITRACE,
                 "CItemMoniker::CItemMoniker(%x)\n",
                 this));

    m_lpszItem = NULL;
    m_lpszDelimiter = NULL;
    m_pszAnsiItem = NULL;
    m_pszAnsiDelimiter = NULL;
    m_fHashValueValid = FALSE;
    m_ccItem = 0;
    m_cbAnsiItem = 0;
    m_cbAnsiDelimiter = 0;
    m_ccDelimiter = 0;

    m_dwHashValue = 0x12345678;
    //
    // CoQueryReleaseObject needs to have the address of the this objects
    // query interface routine.
    //
    if (adwQueryInterfaceTable[QI_TABLE_CItemMoniker] == 0)
    {
        adwQueryInterfaceTable[QI_TABLE_CItemMoniker] =
            **(DWORD **)((IMoniker *)this);
    }

}


//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::ValidateMoniker
//
//  Synopsis:   Check the consistency of this moniker
//
//  Effects:    In a DBG build, check to see if the member variables are
//              sane values.
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-17-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#if DBG == 1
void CItemMoniker::ValidateMoniker()
{
    Assert( (m_lpszItem == NULL && m_ccItem == 0) ||
            (m_ccItem == lstrlenW(m_lpszItem)));


    Assert( (m_lpszDelimiter == NULL && m_ccDelimiter == 0) ||
            (m_ccDelimiter == lstrlenW(m_lpszDelimiter)));

    //
    // cbAnsi* fields are NOT string lengths. However, the size of the
    // buffer should be at least equal or bigger to the length of the
    // Ansi part.
    //

    Assert( (m_pszAnsiItem == NULL && m_cbAnsiItem == 0) ||
            (m_cbAnsiItem >= strlen(m_pszAnsiItem)+1));


    Assert( (m_pszAnsiDelimiter == NULL && m_cbAnsiDelimiter == 0) ||
            (m_cbAnsiDelimiter >= strlen(m_pszAnsiDelimiter)+1));

    Assert( !m_fHashValueValid || (m_dwHashValue != 0x12345678) );
}
#endif


//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::~CItemMoniker
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-17-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CItemMoniker::~CItemMoniker( void )
{
    mnkDebugOut((DEB_ITRACE,
                 "CItemMoniker::~CItemMoniker(%x)\n",
                 this));
    UnInit();
}

//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::UnInit
//
//  Synopsis:   Uninitialize the Item moniker
//
//  Effects:    Free's path memory stored in Item Moniker.
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
CItemMoniker::UnInit()
{
    mnkDebugOut((DEB_ITRACE,
                 "CItemMoniker::UnInit(%x)\n",
                 this));

    ValidateMoniker();

    if (m_lpszDelimiter != NULL)
    {
        PrivMemFree(m_lpszDelimiter);
        m_lpszDelimiter = NULL;
        m_ccDelimiter = 0;
    }

    if (m_pszAnsiDelimiter != NULL)
    {
        PrivMemFree(m_pszAnsiDelimiter);
        m_pszAnsiDelimiter = NULL;
        m_cbAnsiDelimiter = 0;
    }

    if (m_lpszItem != NULL)
    {
        PrivMemFree(m_lpszItem);
        m_lpszItem = NULL;
        m_ccItem = 0;
    }

    if (m_pszAnsiItem != NULL)
    {
        PrivMemFree(m_pszAnsiItem);
        m_pszAnsiItem = NULL;
        m_cbAnsiItem = 0;
    }

    m_fHashValueValid = FALSE;
    m_dwHashValue = 0x12345678;

    ValidateMoniker();
}

//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::Initialize
//
//  Synopsis:   Initilaize an Item Moniker
//
//  Effects:    Clears the current state, then sets new state
//
//  Arguments:  [lpwcsDelimiter] --     Delimiter string
//              [ccDelimiter] --        char count of delimiter
//              [lpszAnsiDelimiter] --  Ansi version of delimiter
//              [cbAnsiDelimiter] --    Count of bytes in AnsiDelimiter
//              [lpwcsItem] --          Item string
//              [ccItem] --             Count of characters in item string
//              [lpszAnsiItem] --       Ansi version of item string
//              [cbAnsiItem] --         Count of bytes in Ansi version
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
CItemMoniker::Initialize ( LPWSTR lpwcsDelimiter,
                           USHORT  ccDelimiter,
                           LPSTR  lpszAnsiDelimiter,
                           USHORT  cbAnsiDelimiter,
                           LPWSTR lpwcsItem,
                           USHORT  ccItem,
                           LPSTR  lpszAnsiItem,
                           USHORT  cbAnsiItem )
{
    //
    // OleLoadFromStream causes two inits; the member vars may already be set
    // UnInit() will free existing resources
    //

    UnInit();

    ValidateMoniker();

    m_lpszItem = lpwcsItem;
    m_ccItem = ccItem;

    m_pszAnsiItem = lpszAnsiItem;
    m_cbAnsiItem = cbAnsiItem;

    m_lpszDelimiter = lpwcsDelimiter;
    m_ccDelimiter = ccDelimiter;

    m_pszAnsiDelimiter = lpszAnsiDelimiter;
    m_cbAnsiDelimiter = cbAnsiDelimiter;

    ValidateMoniker();
}


//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::Initialize
//
//  Synopsis:   Initialize the contents of this moniker
//
//  Effects:
//      Copies the input parameters using PrivMemAlloc(), then passes them
//      to the other version of Initialize, which takes control of the
//      pointers.
//
//  Arguments:  [lpszDelimiter] --
//              [lpszItemName] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-17-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(BOOL)
CItemMoniker::Initialize ( LPCWSTR lpszDelimiter,
                           LPCWSTR lpszItemName )
{
    ValidateMoniker();

    USHORT ccItem;
    USHORT ccDelimiter;

    LPWSTR pwcsDelimiter = NULL;
    LPWSTR pwcsItem = NULL;

    if (m_mxs.FInit() == FALSE)
    {
    	goto errRet;
    }
    
    //VDATEPTRIN rejects NULL
    if( lpszDelimiter )
    {
        GEN_VDATEPTRIN(lpszDelimiter,WCHAR, FALSE);
    }

    if( lpszItemName )
    {
        GEN_VDATEPTRIN(lpszItemName,WCHAR, FALSE);
    }

    if (FAILED(DupWCHARString(lpszDelimiter,
                              pwcsDelimiter,
                              ccDelimiter)))
    {
        goto errRet;
    }

    if (FAILED(DupWCHARString(lpszItemName,pwcsItem,ccItem)))
    {
        goto errRet;
    }
    Initialize(pwcsDelimiter,
               ccDelimiter,
               NULL,
               0,
               pwcsItem,
               ccItem,
               NULL,
               0);

    return TRUE;

errRet:

    if (pwcsDelimiter != NULL)
    {
        PrivMemFree(pwcsDelimiter);
    }
    return(FALSE);
}


CItemMoniker FAR *CItemMoniker::Create (
        LPCWSTR lpszDelimiter, LPCWSTR lpszItemName)
{
    mnkDebugOut((DEB_ITRACE,
                 "CItemMoniker::Create() item(%ws) delim(%ws)\n",
                 lpszItemName,
                 lpszDelimiter));
    //
    // Parameter validation is handled in Initialize
    //
    CItemMoniker FAR * pCIM = new CItemMoniker();

    if (pCIM)
    {
	    if (pCIM->Initialize( lpszDelimiter, lpszItemName ))
	        return pCIM;
	
	    delete pCIM;
    }
    return NULL;
}



STDMETHODIMP CItemMoniker::QueryInterface (THIS_ REFIID riid,
        LPVOID FAR* ppvObj)
{
    VDATEIID (riid);
    VDATEPTROUT(ppvObj, LPVOID);

#ifdef _DEBUG
    if (riid == IID_IDebug)
    {
        *ppvObj = &(m_Debug);
        return NOERROR;
    }
#endif

    if (IsEqualIID(riid, CLSID_ItemMoniker))
    {
        // called by IsItemMoniker.
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    return CBaseMoniker::QueryInterface(riid, ppvObj);
}



STDMETHODIMP CItemMoniker::GetClassID (LPCLSID lpClassId)
{

    VDATEPTROUT(lpClassId, CLSID);

    *lpClassId = CLSID_ItemMoniker;
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteDoubleString
//
//  Synopsis:   Writes a double string to stream. See ExtractUnicodeString
//
//  Effects:
//
//  Arguments:  [pStm] --
//              [pwcsWide] --
//              [ccWide] --
//              [pszAnsi] --
//              [cbAnsi] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
WriteDoubleString( LPSTREAM     pStm,
                   LPWSTR       pwcsWide,
                   USHORT       ccWide,
                   LPSTR        pszAnsi,
                   USHORT       cbAnsi)
{
    mnkDebugOut((DEB_ITRACE,
                 "WriteDoubleString pwcsWide(%ws) cbWide(0x%x) psz(%s) cb(0x%x)\n",
                  pwcsWide?pwcsWide:L"<NULL>",
                  ccWide,
                  pszAnsi?pszAnsi:"<NULL>",
                  cbAnsi));
    HRESULT hr;

    //
    // The string size is always written, but not including the size of the
    // preceding DWORD so we conform to the way WriteAnsiString does it
    //

    ULONG ulTotalSize = 0;

    //
    // The entire reason we are supposed to be in this routine is that the
    // pwcsWide could not be converted to ANSI. Therefore, it had better
    // be valid.
    //

    Assert( (pwcsWide != NULL) && (ccWide == lstrlenW(pwcsWide)));
    Assert( (pszAnsi == NULL) || (cbAnsi == (strlen(pszAnsi) + 1)));

    ulTotalSize += ccWide * sizeof(WCHAR);

    // Lets assume most ItemStrings will fit in this buffer

    BYTE  achQuickBuffer[256];
    BYTE *pcbQuickBuffer = achQuickBuffer;

    //
    // Since we are going to cheat, and write something to the back of the
    // ANSI string, the ANSI string must contain at least a NULL character.
    // If it doesn't, we are going to cheat one in.
    //
    if (pszAnsi == NULL)
    {
        ulTotalSize += sizeof(char);
    }
    else
    {
        ulTotalSize += cbAnsi;
    }

    //
    // If we don't fit in the QuickBuffer, allocate some memory
    //
    // 1996.4.24 v-hidekk
    if ((ulTotalSize + sizeof(ULONG)) > sizeof(achQuickBuffer))
    {
        pcbQuickBuffer = (BYTE *)PrivMemAlloc((ulTotalSize + sizeof(ULONG)));

        if (pcbQuickBuffer == NULL)
        {
            return(E_OUTOFMEMORY);
        }
    }

    //
    // First DWORD in the buffer is the total size of the string. This
    // value includes strlen's of both strings, plus the size of the NULL
    // on the Ansi string.
    //
    // Intrinsics will make this into a move of the correct alignment.
    // Casting pcbQuickBuffer to a ULONG pointer is dangerous, since
    // the alignment may be incorrect. Let the compiler figure out the
    // correct thing to do.
    //

    memcpy(pcbQuickBuffer,&ulTotalSize,sizeof(ulTotalSize));

    //
    // Here, we make sure that pszAnsi ends up writing at least the NULL
    // character
    //

    ULONG ulAnsiWritten;

    memcpy(pcbQuickBuffer + sizeof(ulTotalSize),
           pszAnsi?pszAnsi:"",
           ulAnsiWritten = pszAnsi?cbAnsi:1);

    //
    // At this point, there should be a ULONG followed by at least 1
    // character. The pointer arithmetic below puts us just past the
    // null terminator of the Ansi string
    //

    memcpy(pcbQuickBuffer + sizeof(ulTotalSize) + ulAnsiWritten,
           pwcsWide,
           ccWide * sizeof(WCHAR));

    mnkDebugOut((DEB_ITRACE,
                 "WriteDoubleString ulTotalSize(0x%x)\n",
                 ulTotalSize));

    hr = pStm->Write(pcbQuickBuffer, ulTotalSize + sizeof(ULONG) ,NULL);

    if (pcbQuickBuffer != achQuickBuffer)
    {
        PrivMemFree(pcbQuickBuffer);
    }

    return(hr);

}

//+---------------------------------------------------------------------------
//
//  Function:   ExtractUnicodeString
//
//  Synopsis:   Given an ANSI string buffer, return a UNICODE path
//
//  Effects:
//      If it exists, this routine will extract the UNICODE section
//      of a string written out in the following format:
//
//      <ANSI string><0><UNICODESTRING>
//      ^       cbAnsiString          ^
//
//
//      If the UNICODE string doesn't exist, then the Ansi string is converted
//      to UNICODE and returned
//
//  Arguments:  [pszAnsiString] --      Ansi string with potential UNICODE end
//              [cbAnsiString] --       Total number of bytes in pszAnsiString
//              [pwcsWideString] --     Reference to output string pointer
//              [ccWideString] --       Reference to output cound of characters
//
//  Requires:
//
//  Returns:
//      pwcsWideString will be a PrivMemAlloc()'d UNICODE string
//      ccWideString will be the character count (excluding the NULL)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT ExtractUnicodeString(LPSTR pszAnsiString,
                             USHORT cbAnsiString,
                             LPWSTR & pwcsString,
                             USHORT  & ccString)
{
    mnkDebugOut((DEB_ITRACE,
                 "ExtractUnicodeString pszAnsi(%s) cbAnsi(0x%x)\n",
                 ANSICHECK(pszAnsiString),
                 cbAnsiString));


    USHORT cbAnsiStrLen;
    HRESULT hr;


    //
    // If the Ansi string is NULL, then the Wide char will be also
    //

    if (pszAnsiString == NULL)
    {
        pwcsString = NULL;
        ccString = 0;

        return(NOERROR);
    }

    Assert( pwcsString == NULL);

    //
    // If strlen(pszAnsiString)+1 == cbAnsiString, then there is no
    // UNICODE extent.
    //

    cbAnsiStrLen = (USHORT)strlen(pszAnsiString);

    if ((cbAnsiStrLen + 1) == cbAnsiString)
    {
        //
        // There is not a UNICODE extent. Convert from Ansi to UNICODE
        //
        pwcsString = NULL;

        hr= MnkMultiToUnicode(pszAnsiString,
                              pwcsString,
                              0,
                              ccString,
                              CP_ACP);

        mnkDebugOut((DEB_ITRACE,
                     "ExtractUnicodeString converted (%s) to (%ws) ccString(0x%x)\n",
                     ANSICHECK(pszAnsiString),
                     WIDECHECK(pwcsString),
                     ccString));
    }
    else
    {
        mnkDebugOut((DEB_ITRACE,
                     "ExtractUnicodeString found UNICODE extent\n"));

        //
        // There are extra characters following the AnsiString. Make a
        // new buffer to copy them. Don't forget to add an extra WCHAR for
        // the NULL termination
        //
                                            // AnsiStrLen + AnsiNull char
        USHORT cbWideString = cbAnsiString - (cbAnsiStrLen + 1);

        Assert(cbWideString != 0);

        //
        // There had best be an even number of bytes, or else something
        // has gone wrong.
        //

        Assert( ! (cbWideString & 1));
                                            // Strlen + sizeof(1 NULL char)
        pwcsString = (WCHAR *) PrivMemAlloc(cbWideString + sizeof(WCHAR));
        if (pwcsString == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto errRet;
        }

        memcpy(pwcsString,pszAnsiString + cbAnsiStrLen + 1, cbWideString);

        ccString = cbWideString / sizeof(WCHAR);

        pwcsString[ccString] = 0;

        hr = NOERROR;
    }

errRet:
    mnkDebugOut((DEB_ITRACE,
                 "ExtractUnicodeString result hr(%x) pwcsString(%ws) ccString(0x%x)\n",
                 hr,
                 WIDECHECK(pwcsString),
                 ccString));
    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::Load
//
//  Synopsis:   Loads an Item moniker from a stream
//
//  Effects:    The first version of CItemMoniker stored two counted strings
//              in the stream. Both were stored in ANSI.
//
//              This version saves a UNICODE string on the end of the ANSI
//              string. Therefore, when it is read back in, the count of
//              bytes read as the ANSI string may include a UNICODE string.
//
//              See ::Save() for more details.
//
//
//  Arguments:  [pStm] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CItemMoniker::Load (LPSTREAM pStm)
{
    mnkDebugOut((DEB_ITRACE,
                 "CItemMoniker::Load(%x)\n",
                 this));

    VDATEIFACE(pStm);

    ValidateMoniker();

    HRESULT hresult;
    LPSTR pszAnsiItem = NULL;
    LPSTR pszAnsiDelim = NULL;

    LPWSTR pwcsItem = NULL;
    LPWSTR pwcsDelim = NULL;

    USHORT cbAnsiDelim;
    USHORT cbAnsiItem;

    USHORT ccDelim;
    USHORT ccItem;

    //
    // First, read in the two strings into the Ansi versions
    //

    hresult = ReadAnsiStringStream( pStm, pszAnsiDelim,cbAnsiDelim );
    if (hresult != NOERROR)
    {
        goto errRet;
    }

    mnkDebugOut((DEB_ITRACE,
                 "::Load(%x) pszAnsiDelim(%s) cbAnsiDelim(0x%x)\n",
                 this,
                 pszAnsiDelim,
                 cbAnsiDelim));

    hresult = ReadAnsiStringStream( pStm, pszAnsiItem, cbAnsiItem );

    if (hresult != NOERROR)
    {
        goto errRet;
    }

    mnkDebugOut((DEB_ITRACE,
                 "::Load(%x) pszAnsiItem(%s) cbAnsiItem(0x%x)\n",
                 this,
                 pszAnsiItem,
                 cbAnsiItem));
    //
    // Now, determine the UNICODE strings. They may be stashed at the
    // end of the Ansi strings.
    //

    hresult = ExtractUnicodeString(pszAnsiDelim,
                                   cbAnsiDelim,
                                   pwcsDelim,
                                   ccDelim);

    if (FAILED(hresult))
    {
        goto errRet;
    }

    hresult = ExtractUnicodeString(pszAnsiItem,
                                   cbAnsiItem,
                                   pwcsItem,
                                   ccItem);
    if (FAILED(hresult))
    {
        goto errRet;
    }

    Initialize ( pwcsDelim,
                 ccDelim,
                 pszAnsiDelim,
                 cbAnsiDelim,
                 pwcsItem,
                 ccItem,
                 pszAnsiItem,
                 cbAnsiItem );

    ValidateMoniker();
    return(NOERROR);

errRet:
    PrivMemFree(pszAnsiItem);
    PrivMemFree(pszAnsiDelim);
    PrivMemFree(pwcsItem);
    PrivMemFree(pwcsDelim);
    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveUnicodeAsAnsi
//
//  Synopsis:   This function will save a string to the stream
//
//  Effects:
//      This routine always attempts to save the string in Ansi. If it isn't
//      possible to save an Ansi version of the string, it will save an
//      Ansi version (which may be NULL), and a UNICODE version.
//
//  Arguments:  [pStm] --       Stream to write to
//              [pwcsWide] --   Unicode string
//              [ccWide] --     Count of UNICODE characters (EXCL NULL)
//              [pszAnsi] --    Ansi string
//              [cbAnsi] --     Count of bytes (INCL NULL)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-17-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT SaveUnicodeAsAnsi( LPSTREAM     pStm,
                           LPWSTR       pwcsWide,
                           USHORT       ccWide,
                           LPSTR        pszAnsi,
                           USHORT       cbAnsi)
{
    mnkDebugOut((DEB_ITRACE,
                 "::SaveUnicodeAsAnsi pwcsWide(%ws) ccWide(0x%x) pwsAnsi(%s) cbAnsi(0x%x)\n",
                 WIDECHECK(pwcsWide),
                 ccWide,
                 ANSICHECK(pszAnsi),
                 cbAnsi));
    HRESULT hr;
    BOOL fFastConvert;

    //
    // If the Ansi version exists, or the Unicode string is NULL,
    // write out the Ansi version
    //

    if ((pszAnsi != NULL) || (pwcsWide == NULL))
    {
        mnkDebugOut((DEB_ITRACE,
                     "::SaveUnicodeAsAnsi Ansi Only (%s)\n",
                     ANSICHECK(pszAnsi)));

        hr = WriteAnsiStringStream( pStm,
                                    pszAnsi,
                                    cbAnsi);
    }
    else
    {
        //
        // There isn't an AnsiVersion, and the UNICODE version isn't NULL
        // Try to convert the UNICODE to Ansi
        //

        Assert( (pwcsWide != NULL) &&
                (ccWide == lstrlenW(pwcsWide)));

        mnkDebugOut((DEB_ITRACE,
                     "::SaveUnicodeAsAnsi Unicode string exists(%ws)\n",
                     WIDECHECK(pwcsWide)));

        //
        // We can use the pszAnsi pointer since it is NULL
        //

        Assert( pszAnsi == NULL);

        hr = MnkUnicodeToMulti( pwcsWide,
                                ccWide,
                                pszAnsi,
                                cbAnsi,
                                fFastConvert);

        Assert( (pszAnsi == NULL) || (cbAnsi == strlen(pszAnsi)+1) );

        //
        // A failure would mean out of memory, or some other terrible thing
        // happened.
        //

        if (FAILED(hr))
        {
            goto errRet;
        }

        //
        // If fFastConvert, then the UnicodeString was converted using a
        // truncation algorithm, and the resulting Ansi string can be saved
        // without the Unicode section appended
        //

        if (fFastConvert)
        {
            mnkDebugOut((DEB_ITRACE,
                         "::SaveUnicodeAsAnsi Fast converted wide(%ws) to (%s) cbAnsi(0x%x)\n",
                         WIDECHECK(pwcsWide),
                         ANSICHECK(pszAnsi),
                         cbAnsi));

            hr = WriteAnsiStringStream( pStm,
                                        pszAnsi,
                                        cbAnsi);
        }
        else
        {
            mnkDebugOut((DEB_ITRACE,
                         "::SaveUnicodeAsAnsi Full conversion wide(%ws) to (%s) cbAnsi(0x%x)\n",
                         WIDECHECK(pwcsWide),
                         ANSICHECK(pszAnsi),
                         cbAnsi));

            hr = WriteDoubleString( pStm,
                                    pwcsWide,
                                    ccWide,
                                    pszAnsi,
                                    cbAnsi);
        }

        //
        // We are done with the Ansi string.
        //
        // (KevinRo) It would be nice if we could get the double
        // string back from WriteDoubleString and cache it. Perhaps later
        // this can be done. [Suggestion]
        //

        PrivMemFree(pszAnsi);
    }

errRet:
    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::Save
//
//  Synopsis:   Save the moniker to a stream
//
//  Effects:    The first version of CItemMoniker stored two counted strings
//              in the stream. Both were stored in ANSI.
//
//              This version saves a UNICODE string on the end of the ANSI
//              string. Therefore, when it is read back in, the count of
//              bytes read as the ANSI string may include a UNICODE string.
//
//              We don't actually write the UNICODE string unless we have
//              to.
//
//  Arguments:  [pStm] --
//              [fClearDirty] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//      There are two ways to create a CItemMoniker. Using CreateItemMoniker(),
//      and Load().
//
//      If we were Load()'d, then it will be the case that we already have an
//      Ansi version of both strings. In this case, we will just save those
//      Ansi strings back out. If they already contain the UNICODE sections,
//      then they are saved as part of the package. Hopefully, this will be
//      the common case.
//
//      Another possibility is the moniker was created using CreateItemMoniker.
//      If this is the case, then there are no Ansi versions of the strings.
//      We need to create Ansi strings, if possible. If we can't convert the
//      string to Ansi cleanly, then we need to save away a UNICODE section
//      of the string.
//
//----------------------------------------------------------------------------
STDMETHODIMP CItemMoniker::Save (LPSTREAM pStm, BOOL fClearDirty)
{
    mnkDebugOut((DEB_ITRACE,
                 "CItemMoniker::Save(%x)\n",
                 this));

    ValidateMoniker();

    VDATEIFACE(pStm);
    UNREFERENCED(fClearDirty);
    HRESULT hr;

    //
    // If a AnsiDelimiter exists, OR the UNICODE version is NULL, then
    // write out the Ansi version
    //

    hr = SaveUnicodeAsAnsi( pStm,
                            m_lpszDelimiter,
                            m_ccDelimiter,
                            m_pszAnsiDelimiter,
                            m_cbAnsiDelimiter);
    if (FAILED(hr))
    {
        mnkDebugOut((DEB_ITRACE,
                     "CItemMoniker::Save(%x) SaveUnicodeAsAnsi Delim failed (%x)\n",
                     this,
                     hr));
        goto errRet;
    }

    hr = SaveUnicodeAsAnsi( pStm,
                            m_lpszItem,
                            m_ccItem,
                            m_pszAnsiItem,
                            m_cbAnsiItem);
    if (FAILED(hr))
    {
        mnkDebugOut((DEB_ITRACE,
                     "CItemMoniker::Save(%x) SaveUnicodeAsAnsi Item failed (%x)\n",
                     this,
                     hr));
        goto errRet;
    }

errRet:

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::GetSizeMax
//
//  Synopsis:   Get the maximum size required to serialize this moniker
//
//  Effects:
//
//  Arguments:  [pcbSize] -- Place to return value
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-17-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CItemMoniker::GetSizeMax (ULARGE_INTEGER FAR* pcbSize)
{
    ValidateMoniker();
    VDATEPTROUT(pcbSize, ULARGE_INTEGER);
    UINT cb = 0;

    //
    // The largest a UNICODE to MBSTRING should end up being is
    // 2 * character count.
    //
    if (m_lpszItem)
    {
        cb = (m_ccItem + 1) * 2 * sizeof(WCHAR);
    }
    if (m_lpszDelimiter)
    {
        cb += (m_ccDelimiter + 1) * 2 * sizeof(WCHAR);
    }

    //
    // sizeof(CLSID) accounts for the GUID that OleSaveToStream might
    // write on our behalf. The two ULONGs are the string lengths,
    // and cb is the max string sizes.
    //

    ULISet32(*pcbSize, sizeof(CLSID) + 2*(1 + sizeof(ULONG)) + cb);

    return(NOERROR);
}


#define dwModerateTime 2500
//  2.5 seconds divides immediate from moderate.

DWORD BindSpeedFromBindCtx( LPBC pbc )
{
    BIND_OPTS bindopts;
    HRESULT hresult;
    DWORD dwBindSpeed = BINDSPEED_INDEFINITE;

        bindopts.cbStruct = sizeof(bindopts);
    hresult = pbc->GetBindOptions( &bindopts );
    if (hresult != NOERROR) return dwBindSpeed;
    Assert( bindopts.cbStruct >= 16);
    if (bindopts.dwTickCountDeadline != 0)
    {
        if (bindopts.dwTickCountDeadline < dwModerateTime)
            dwBindSpeed = BINDSPEED_IMMEDIATE;
        else dwBindSpeed = BINDSPEED_MODERATE;
    }
    //  else speed = default, BINDSPEED_INDEFINITE
    return dwBindSpeed;
}

STDMETHODIMP CItemMoniker::BindToObject ( LPBC pbc,
        LPMONIKER pmkToLeft, REFIID iidResult,
        VOID FAR * FAR * ppvResult)
{
        M_PROLOG(this);
        VDATEPTROUT(ppvResult, LPVOID);
        *ppvResult = NULL;
        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);
        VDATEIID(iidResult);

        ValidateMoniker();
        HRESULT hresult;
        LPOLEITEMCONTAINER pOleCont;

        if (pmkToLeft)
        {
                hresult = pmkToLeft->BindToObject( pbc, NULL, IID_IOleItemContainer,
                        (LPVOID FAR*)&pOleCont);
                // AssertOutPtrIface(hresult, pOleCont);
                if (hresult != NOERROR) return hresult;

                hresult = RegisterContainerBound(pbc, pOleCont);
                hresult = pOleCont->GetObject(m_lpszItem, BindSpeedFromBindCtx(pbc),
                        pbc, iidResult, ppvResult);
                // AssertOutPtrIface(hresult, *ppvResult);
                pOleCont->Release();
                return hresult;
        }
        return ResultFromScode(E_INVALIDARG);   //      needs non-null moniker to left.
}


STDMETHODIMP CItemMoniker::BindToStorage (LPBC pbc, LPMONIKER
        pmkToLeft, REFIID riid, LPVOID FAR* ppvObj)
{
        M_PROLOG(this);
        VDATEPTROUT(ppvObj,LPVOID);
        *ppvObj = NULL;
        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);
        VDATEIID(riid);

        HRESULT hresult;
        LPOLEITEMCONTAINER pOleCont;

        ValidateMoniker();

        if (pmkToLeft)
        {
                hresult = pmkToLeft->BindToObject( pbc, NULL, IID_IOleItemContainer,
                        (LPVOID FAR*)&pOleCont);
                // AssertOutPtrIface(hresult, pOleCont);
                if (hresult != NOERROR) return hresult;
                hresult = RegisterContainerBound(pbc, pOleCont);
                hresult = pOleCont->GetObjectStorage(m_lpszItem, pbc,
                        riid, ppvObj);
                // AssertOutPtrIface(hresult, *ppvObj);
                pOleCont->Release();
                return hresult;
        }
        return ResultFromScode(E_INVALIDARG);   //      needs non-null moniker to left.
}



//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::ComposeWith
//
//  Synopsis:   Compose this moniker with another moniker
//
//  Effects:
//
//  Arguments:  [pmkRight] --
//              [fOnlyIfNotGeneric] --
//              [ppmkComposite] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-04-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CItemMoniker::ComposeWith ( LPMONIKER pmkRight,
        BOOL fOnlyIfNotGeneric, LPMONIKER FAR* ppmkComposite)
{

    VDATEPTROUT(ppmkComposite,LPMONIKER);
    *ppmkComposite = NULL;
    VDATEIFACE(pmkRight);

    HRESULT hresult = NOERROR;

    ValidateMoniker();

    //
    // If this is an AntiMoniker, then we are going to ask the AntiMoniker
    // for the composite. This is a backward compatibility problem. Check
    // out the CAntiMoniker::EatOne() routine for details.
    //

    CAntiMoniker *pCAM = IsAntiMoniker(pmkRight);
    if (pCAM)
    {
        pCAM->EatOne(ppmkComposite);
    }
    else
    {
        if (!fOnlyIfNotGeneric)
        {
            hresult = CreateGenericComposite( this, pmkRight, ppmkComposite );
        }
        else
        {
            hresult = ResultFromScode(MK_E_NEEDGENERIC);
            *ppmkComposite = NULL;
        }
    }
    return hresult;
}



STDMETHODIMP CItemMoniker::Enum  (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
        M_PROLOG(this);
        VDATEPTROUT(ppenumMoniker,LPENUMMONIKER);
        *ppenumMoniker = NULL;
        noError;
}



STDMETHODIMP CItemMoniker::IsEqual  (THIS_ LPMONIKER pmkOtherMoniker)
{
        M_PROLOG(this);
        VDATEIFACE(pmkOtherMoniker);

        ValidateMoniker();

        CItemMoniker FAR* pCIM = IsItemMoniker(pmkOtherMoniker);
        if (!pCIM)
            return ResultFromScode(S_FALSE);

        // the other moniker is a item moniker.
        // for the names, we do a case-insensitive compare.
        if (m_lpszItem && pCIM->m_lpszItem)
        {
            if (0 == lstrcmpiW(pCIM->m_lpszItem, m_lpszItem))
                return NOERROR; // S_TRUE;
        }
        else
            return (m_lpszItem || pCIM->m_lpszItem ? ResultFromScode(S_FALSE ) : NOERROR /*S_TRUE*/);

                return ResultFromScode(S_FALSE);

}



//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::Hash
//
//  Synopsis:   Compute a hash value
//
//  Effects:    Computes a hash using the same basic algorithm as the
//              file moniker.
//
//  Arguments:  [pdwHash] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-17-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CItemMoniker::Hash  (THIS_ LPDWORD pdwHash)
{
    CLock2 lck(m_mxs); // protect m_fHashValueValid and m_dwHashValue

    VDATEPTROUT(pdwHash, DWORD);

    ValidateMoniker();
    if (m_fHashValueValid == FALSE)
    {
        m_dwHashValue = CalcFileMonikerHash(m_lpszItem, m_ccItem);
        m_fHashValueValid = TRUE;
    }
    *pdwHash = m_dwHashValue;

    return(NOERROR);
}


STDMETHODIMP CItemMoniker::IsRunning  (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
                                      LPMONIKER pmkNewlyRunning)
{
    VDATEIFACE (pbc);
    HRESULT hresult;

    if (pmkToLeft)
        VDATEIFACE (pmkToLeft);
    if (pmkNewlyRunning)
        VDATEIFACE (pmkNewlyRunning);

    LPMONIKER pmk = NULL;
    LPOLEITEMCONTAINER pCont = NULL;
    LPRUNNINGOBJECTTABLE prot = NULL;

    if (pmkToLeft == NULL)
    {
        if (pmkNewlyRunning != NULL)
        {
            hresult = IsEqual(pmkNewlyRunning);
            if (hresult == NOERROR) goto errRet;
            hresult = IsEqual(pmkNewlyRunning);
            if (hresult != NOERROR)
            {
                hresult = ResultFromScode(S_FALSE);
                goto errRet;
            }
        }
        pbc->GetRunningObjectTable( &prot );
        //  check to see if "this" is in ROT
        hresult = prot->IsRunning(this);
        goto errRet;
    }

    hresult = pmkToLeft->IsRunning(pbc, NULL, NULL);
    if (hresult == NOERROR)
    {
        hresult = pmkToLeft->BindToObject(pbc, NULL, IID_IOleItemContainer,
                                          (LPVOID FAR *)&pCont );
        if (hresult == NOERROR)
        {
            // don't use RegisterContainerBound(pbc, pCont) here since we
            // will lock/unlock the container unecessarily and possibly
            // shut it down.
            hresult = pbc->RegisterObjectBound(pCont);
            if (hresult != NOERROR) goto errRet;
            hresult = pCont->IsRunning(m_lpszItem);
        }
    }
errRet:
    if (pCont) pCont->Release();
    if (prot) prot->Release();
    return hresult;
}



STDMETHODIMP CItemMoniker::GetTimeOfLastChange  (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        FILETIME FAR* pfiletime)
{
        M_PROLOG(this);
        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);
        VDATEPTROUT(pfiletime, FILETIME);

        ValidateMoniker();

        HRESULT hresult;
        LPMONIKER pmkTemp = NULL;
        LPRUNNINGOBJECTTABLE prot = NULL;

        if (pmkToLeft == NULL)
                return ResultFromScode(MK_E_NOTBINDABLE);
                        // Getting time of last change
                        // for an orphan item moniker.

        //      Check to see if the composite is in the running object table
        hresult = CreateGenericComposite( pmkToLeft, this, &pmkTemp );
        if (hresult != NOERROR) goto errRet;
        hresult = pbc->GetRunningObjectTable(& prot);
        if (hresult != NOERROR) goto errRet;
        hresult = prot->GetTimeOfLastChange( pmkTemp, pfiletime);
        if (hresult != MK_E_UNAVAILABLE) goto errRet;

        // if not, pass on to the left.
        hresult = pmkToLeft->GetTimeOfLastChange(pbc, NULL, pfiletime);
errRet:
        if (pmkTemp) pmkTemp->Release();
        if (prot) prot->Release();
        return hresult;
}



STDMETHODIMP CItemMoniker::Inverse  (THIS_ LPMONIKER FAR* ppmk)
{
        M_PROLOG(this);
        VDATEPTROUT(ppmk, LPMONIKER);
        return CreateAntiMoniker(ppmk);
}



STDMETHODIMP CItemMoniker::CommonPrefixWith  (LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkPrefix)
{
    ValidateMoniker();
    VDATEPTROUT(ppmkPrefix,LPMONIKER);
    *ppmkPrefix = NULL;
    VDATEIFACE(pmkOther);

    if (!IsItemMoniker(pmkOther))
    {
        return(MonikerCommonPrefixWith(this,pmkOther,ppmkPrefix));
    }

    if (NOERROR == IsEqual(pmkOther))
    {
        *ppmkPrefix = this;
        AddRef();
        return ResultFromScode(MK_S_US);
    }
    return ResultFromScode(MK_E_NOPREFIX);
}



STDMETHODIMP CItemMoniker::RelativePathTo  (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkRelPath)
{
    ValidateMoniker();
    VDATEPTROUT(ppmkRelPath,LPMONIKER);

    *ppmkRelPath = NULL;

    VDATEIFACE(pmkOther);

    return ResultFromScode(MK_E_NOTBINDABLE);
}



STDMETHODIMP CItemMoniker::GetDisplayName ( LPBC pbc, LPMONIKER
        pmkToLeft, LPWSTR FAR * lplpszDisplayName )
{
    mnkDebugOut((DEB_ITRACE,
                 "CItemMoniker::GetDisplayName(%x)\n",
                 this));

    ValidateMoniker();

    VDATEPTROUT(lplpszDisplayName, LPWSTR);
    *lplpszDisplayName = NULL;

    VDATEIFACE(pbc);

    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }

    ULONG cc = m_ccItem + m_ccDelimiter;

    //
    // cc holds the count of characters. Make extra room for the NULL
    //

    *lplpszDisplayName = (LPWSTR) CoTaskMemAlloc(sizeof(WCHAR)*(1 + cc));

    if (*lplpszDisplayName == NULL)
    {
        mnkDebugOut((DEB_ITRACE,
                     "::GetDisplayName(%x) returning out of memory\n",
                     this));

        return E_OUTOFMEMORY;

    }

    //
    // To handle the case where both strings are NULL, we set the first
    // (and perhaps only) character to 0
    //

    *lplpszDisplayName[0] = 0;

    //
    // Concat the two strings. Don't forget the NULL! Thats what the
    // extra character is for.
    //

    if (m_lpszDelimiter != NULL)
    {
        memcpy( *lplpszDisplayName,
                m_lpszDelimiter,
                (m_ccDelimiter + 1) * sizeof(WCHAR));
    }

    //
    // The existing string was NULL terminated to just in case the
    // Item string is NULL.
    //
    // Concat the Item string on the end of the Delimiter Again, don't
    // forget the NULL.
    //

    if (m_lpszItem != NULL)
    {
        memcpy( *lplpszDisplayName + m_ccDelimiter,
                m_lpszItem,
                (m_ccItem + 1) * sizeof(WCHAR));
    }

    mnkDebugOut((DEB_ITRACE,
                 "::GetDisplayName(%x) returning %ws\n",
                 this,
                 *lplpszDisplayName));

    return(NOERROR);
}



//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::ParseDisplayName
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pbc] --        Bind Context
//              [pmkToLeft] --  Left moniker
//              [lpszDisplayName] -- String to parse
//              [pchEaten] --  Output number of characters eaten
//              [ppmkOut] -- Output moniker
//
//  Requires:
//      pmkToLeft MUST be valid. NULL is inappropriate
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CItemMoniker::ParseDisplayName ( LPBC pbc,
                                              LPMONIKER pmkToLeft,
                                              LPWSTR lpszDisplayName,
                                              ULONG FAR* pchEaten,
                                              LPMONIKER FAR* ppmkOut)
{
    HRESULT hresult;
    VDATEPTRIN(lpszDisplayName, WCHAR);
    VDATEPTROUT(pchEaten,ULONG);
    VDATEPTROUT(ppmkOut,LPMONIKER);

    IParseDisplayName FAR * pPDN = NULL;
    IOleItemContainer FAR * pOIC = NULL;

    ValidateMoniker();

    *pchEaten = 0;
    *ppmkOut = NULL;

    VDATEIFACE(pbc);

    //
    // Item monikers require the moniker on the left to be non-null, so
    // they can get the container to parse the display name
    //

    if (pmkToLeft != NULL)
    {
        VDATEIFACE(pmkToLeft);
    }
    else
    {
        hresult = MK_E_SYNTAX;
        goto errRet;
    }


    hresult = pmkToLeft->BindToObject( pbc,
                                       NULL,
                                       IID_IOleItemContainer,
                                       (VOID FAR * FAR *)&pOIC );
    if (FAILED(hresult))
    {
        goto errRet;
    }

    hresult = RegisterContainerBound(pbc, pOIC);

    if (FAILED(hresult))
    {
        goto errRet;
    }

    hresult = pOIC->GetObject( m_lpszItem,
                               BindSpeedFromBindCtx(pbc),
                               pbc,
                               IID_IParseDisplayName,
                               (LPVOID FAR*)&pPDN);
    if (FAILED(hresult))
    {
        goto errRet;
    }

    hresult = pPDN->ParseDisplayName(pbc,
                                     lpszDisplayName,
                                     pchEaten,
                                     ppmkOut );
    if (FAILED(hresult))
    {
        goto errRet;
    }

    hresult = pbc->RegisterObjectBound( pPDN );

errRet:
    if (pPDN)
    {
        pPDN->Release();
    }

    if (pOIC)
    {
        pOIC->Release();
    }

    return hresult;
}


STDMETHODIMP CItemMoniker::IsSystemMoniker  (THIS_ LPDWORD pdwType)
{
        M_PROLOG(this);
        VDATEPTROUT(pdwType,DWORD);

        *pdwType = MKSYS_ITEMMONIKER;
        return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::GetComparisonData
//
//  Synopsis:   Get comparison data for registration in the ROT
//
//  Arguments:  [pbData] - buffer to put the data in.
//              [cbMax] - size of the buffer
//              [pcbData] - count of bytes used in the buffer
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//  Algorithm:  Build the ROT data from internal data of the item moniker.
//
//  History:    03-Feb-95   ricksa  Created
//
// Note:        Validating the arguments is skipped intentionally because this
//              will typically be called internally by OLE with valid buffers.
//
//----------------------------------------------------------------------------
STDMETHODIMP CItemMoniker::GetComparisonData(
    byte *pbData,
    ULONG cbMax,
    DWORD *pcbData)
{
    //
    // CLSID plus delimiter plus item plus one NULL
    //
    ULONG ulLength = sizeof(CLSID_ItemMoniker) +
                     (m_ccItem + m_ccDelimiter + 1) * sizeof(WCHAR);

    Assert(pcbData != NULL);
    Assert(pbData != NULL);

    if (cbMax < ulLength)
    {
        return(E_OUTOFMEMORY);
    }

    //
    // Copy the classID
    //
    memcpy(pbData,&CLSID_ItemMoniker,sizeof(CLSID_FileMoniker));

    //
    // Copy the delimiter WITHOUT the NULL. This saves a little space,
    // and allows us to uppercase them both as a single string
    //
    memcpy(pbData+sizeof(CLSID_FileMoniker),
           m_lpszDelimiter,
           m_ccDelimiter * sizeof(WCHAR));

    //
    // Copy the item plus the NULL
    //
    memcpy(pbData+sizeof(CLSID_FileMoniker)+(m_ccDelimiter * sizeof(WCHAR)),
           m_lpszItem,
           (m_ccItem + 1)*sizeof(WCHAR));

    //
    // Insure entire string is upper case, since the item monikers are spec'd
    // (and already do) case insensitive comparisions
    //
    CharUpperW((WCHAR *)(pbData+sizeof(CLSID_FileMoniker)));

    *pcbData = ulLength;

    return NOERROR;
}

#ifdef _DEBUG

STDMETHODIMP_(void) NC(CItemMoniker,CDebug)::Dump ( IDebugStream FAR * pdbstm)
{
        VOID_VDATEIFACE(pdbstm);

        *pdbstm << "CItemMoniker @" << (VOID FAR *)m_pItemMoniker;
        *pdbstm << '\n';
        pdbstm->Indent();
        *pdbstm << "Refcount is " << (int)(m_pItemMoniker->m_refs) << '\n';
        *pdbstm << "Item string is " << m_pItemMoniker->m_lpszItem << '\n';
        *pdbstm << "Delimiter is " << m_pItemMoniker->m_lpszDelimiter << '\n';
        pdbstm->UnIndent();
}

STDMETHODIMP_(BOOL) NC(CItemMoniker,CDebug)::IsValid ( BOOL fSuspicious )
{
        return ((LONG)(m_pItemMoniker->m_refs) > 0);
        //      add more later, maybe
}

#endif


//
// Unlock Delay object
//
class FAR CDelayUnlockContainer : public CPrivAlloc, public IUnknown
{
public:
        STDMETHOD(QueryInterface) ( REFIID iid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

    CDelayUnlockContainer();

private:
    ULONG                               m_refs;
        IOleItemContainer FAR * m_pOleCont;

        friend INTERNAL RegisterContainerBound(LPBC pbc, LPOLEITEMCONTAINER pOleCont);
};


CDelayUnlockContainer::CDelayUnlockContainer()
{
        m_pOleCont = NULL;
        m_refs = 1;
}


STDMETHODIMP CDelayUnlockContainer::QueryInterface (REFIID iid, LPLPVOID ppv)
{
        M_PROLOG(this);
        if (IsEqualIID(iid, IID_IUnknown))
        {
                *ppv = this;
                AddRef();
                return NOERROR;
        }
        else {
                *ppv = NULL;
                return ResultFromScode(E_NOINTERFACE);
        }
}


STDMETHODIMP_(ULONG) CDelayUnlockContainer::AddRef ()
{
    return(InterlockedIncrement((long *)&m_refs));

}


STDMETHODIMP_(ULONG) CDelayUnlockContainer::Release ()
{
    if (InterlockedDecrement((long *)&m_refs) == 0)
    {
        if (m_pOleCont != NULL)
        {
            m_pOleCont->LockContainer(FALSE);
            m_pOleCont->Release();
        }
        delete this;
        return 0;
    }

    return 1;
}


INTERNAL RegisterContainerBound (LPBC pbc, LPOLEITEMCONTAINER pOleCont)
{
        // don't give the delay object the pOleCont before we lock it; do in
        // this order so error checking is correct and we don't lock/unlock
        // inappropriately.

        CDelayUnlockContainer FAR* pCDelay = new CDelayUnlockContainer();
        if (pCDelay == NULL)
                return ResultFromScode(E_OUTOFMEMORY);

        HRESULT hresult;
        if ((hresult = pbc->RegisterObjectBound(pCDelay)) != NOERROR)
                goto errRet;

        if ((hresult = pOleCont->LockContainer(TRUE)) != NOERROR) {
                // the delay object is still in the bindctx; no harm
                hresult = E_FAIL;
                goto errRet;
        }


        pCDelay->m_pOleCont = pOleCont;
        pOleCont->AddRef();

errRet:
        pCDelay->Release();
        return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\cobjrmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       cobjrmon.cxx
//
//  Contents:   Base64 conversion routines
//                              CObjref Moniker class and routines
//
//  Classes:
//
//  Functions:
//
//  History:    04-16-97   ronans   Created
//
//----------------------------------------------------------------------------
#include <ole2int.h>
#include "cbasemon.hxx"
#include "cptrmon.hxx"
#include "cantimon.hxx"
#include "mnk.h"
#include "cobjrmon.hxx"

// CODEWORK - ronans - this is the official base64 alphabet but it may make
// sense to substitute the '+' and '/' characters as they may not be suitable for
// internet URL usage. If we choose substitutions it is worth noting that the existing
// base64 alphabet is guarenteed have the same ASCII values across all (according to BASE64 specs)
// ISO standard character sets.

static WCHAR szBase64Alphabet[] =
{
    L'A', L'B', L'C', L'D', L'E', L'F', L'G', L'H', L'I', L'J', L'K',
    L'L', L'M', L'N', L'O', L'P', L'Q', L'R', L'S', L'T', L'U', L'V',
    L'W', L'X', L'Y', L'Z', L'a', L'b', L'c', L'd', L'e', L'f', L'g',
    L'h', L'i', L'j', L'k', L'l', L'm', L'n', L'o', L'p', L'q', L'r',
    L's', L't', L'u', L'v', L'w', L'x', L'y', L'z', L'0', L'1', L'2',
    L'3', L'4', L'5', L'6', L'7', L'8', L'9', L'+', L'/'
};

const WCHAR cPadding = L'=';    // padding character used in base 64
const BYTE  bytPadValue = 64;
//+-------------------------------------------------------------------
//
//  Function:   utByteToBase64
//
//  Synopsis:   convert a 6 bit value to the corresponding base 64 char
//
//--------------------------------------------------------------------
inline WCHAR utByteToBase64 (BYTE aByte)
{
    ASSERT(aByte < 64);
    return szBase64Alphabet[aByte];
}

//+-------------------------------------------------------------------
//
//  Function:   utBase64ToByte
//
//  Synopsis:   convert a base64 char to corresponding value
//
//  Notes: The value 64 represents a padding value
//
//--------------------------------------------------------------------
BYTE utBase64ToByte (WCHAR wch)
{
    BYTE value;

    if ((wch >= L'A') && (wch <= L'Z'))
        value = (BYTE) (wch - L'A');
    else if ((wch >= L'a') && (wch <= L'z'))
        value = 26+(BYTE) (wch - L'a');
    else if ((wch >= L'0') && (wch <= L'9'))
        value = 52+(BYTE) (wch - L'0');
    else if (wch == L'+')
        value = 62;
    else if (wch == L'/')
        value = 63;
    else
        value = bytPadValue;

	return value;
}

//+-------------------------------------------------------------------
//
//  Function:   utQuantumToBase64
//
//  Synopsis:   convert a quantum to 4 base64 chars
//
//  Notes:      nBytes is the number of bytes in the quantum - it should be less than
//              or equal three
//
//--------------------------------------------------------------------
short utQuantumToBase64(BYTE * pbByteStream, short nBytes, WCHAR *lpszOutputStream)
{
    // get quantum
    DWORD dwQuantum = 0;
    short nIndex;

    ASSERT((nBytes > 0) && (nBytes <= 3));

    // build each set of three bytes into a 24 bit quantum zero padding if necessary
    for (nIndex = 0; nIndex < 3; nIndex ++)
    {
        dwQuantum = dwQuantum << 8;
        if (nIndex < nBytes)
            dwQuantum += pbByteStream[nIndex];
    }

    // convert quantum to chars for each 6 bits of quantum
    for (nIndex = 0; nIndex < 4; nIndex ++)
    {
        BYTE bytChar = (BYTE)(dwQuantum & 0x3F);
        WCHAR wch;

        // check for padding cases - essentially if we have 2 bytes in our quantum we will add one
        // padding char. If we have one byte in our quantum we will add 2 padding chars
        if (!bytChar)
        {
            if ((nBytes == 2) && (nIndex == 0))
                wch = cPadding;
            else if ((nBytes == 1) && (nIndex <= 1))
                wch = cPadding;
            else
                wch = L'A'; // base 64 representation of 0
        }
        else
            wch = utByteToBase64(bytChar);

        lpszOutputStream[3 - nIndex] = wch;
        dwQuantum = dwQuantum >> 6;
    }

    // return number of non pad chars
    return nBytes+1;
}


//+-------------------------------------------------------------------
//
//  Function:   utByteStreamToBase64
//
//  Synopsis:   convert a bytestream to a base64 stream
//
//  returns:    Size of output stream in characters
//
//	Note:		not true Base64 as no line breaks are embedded
//
//--------------------------------------------------------------------
long utByteStreamToBase64(BYTE * pbByteStream, long nBytes, WCHAR *lpszOutputStream)
{
    int nIndexOut = 0;
    int nIndexIn = 0;

    // write out data - processing in quantums of up to three bytes

    for (nIndexIn = 0; nIndexIn < nBytes; nIndexIn += 3)
    {
        utQuantumToBase64(&pbByteStream[nIndexIn],
                          ((nBytes - nIndexIn)  < 3) ? (short)(nBytes - nIndexIn)  : 3,
                          &lpszOutputStream[nIndexOut]);
        nIndexOut += 4;
    }
    // write out terminating null
    lpszOutputStream[nIndexOut++] = L'\0';

    /// return total chars written.
    return nIndexOut;
}

//+-------------------------------------------------------------------
//
//  Function:   utBase64ToQuantum
//
//  Synopsis:   convert 4 base64 chars to quantum of 1 to 3 bytes
//
//  Returns:    Number of bytes translated into quantum
//
//--------------------------------------------------------------------
short utBase64ToQuantum(WCHAR *lpszInputStream, BYTE * pbByteStream)
{
    // get quantum
    DWORD dwQuantum = 0;
    short nPadChars = 0;
    short nIndex;
    short nBytes;

    ASSERT(lpszInputStream );
    ASSERT(lstrlenW(lpszInputStream) >= 4 );
    ASSERT(pbByteStream);

    // build each set of four characters into a 24 bit quantum
    for (nIndex = 0; nIndex < 4; nIndex ++)
    {
        dwQuantum = dwQuantum << 6;

        BYTE bytChar = utBase64ToByte(lpszInputStream[nIndex]);

        if (bytChar == bytPadValue )
            nPadChars++;
        else
            dwQuantum += bytChar;
    }

    // calculate number of bytes
    nBytes = 3 - nPadChars;

    // convert quantum to bytes for each 8 bits of quantum
    for (nIndex = 0; nIndex < 3; nIndex ++)
    {
        BYTE bytChar = (BYTE)(dwQuantum & 0xFF);
        WCHAR wch;

        // check for padding cases
        if (nIndex >= nPadChars)
            pbByteStream[2 - nIndex] = bytChar;
        dwQuantum = dwQuantum >> 8;
    }

    // return number of bytes written
    return nBytes;
}

//+-------------------------------------------------------------------
//
//  Function:   utBase64ToByteStream
//
//  Synopsis:   convert a base64 stream to a byte stream
//
//  returns:    Size of output stream in characters
//
//	Note:		not true Base64 as no line breaks are embedded
//
//--------------------------------------------------------------------
long utBase64ToByteStream(WCHAR *lpszInputStream, BYTE * pbByteStream)
{
    ASSERT(lpszInputStream);
    ASSERT(pbByteStream);
    long nBase64len = lstrlenW(lpszInputStream);

    // the input stream should be an exact multiple of 4.
    ASSERT(nBase64len % 4 == 0);

    int nIndexOut = 0;
    int nIndexIn = 0;

    for (nIndexIn = 0; nIndexIn < nBase64len; nIndexIn += 4)
    {
        nIndexOut += utBase64ToQuantum(&lpszInputStream[nIndexIn],
                                        &pbByteStream[nIndexOut]);
    }

    /// return total bytes written.
    return nIndexOut;
}

//+-------------------------------------------------------------------
//
//  Function:   utBase64ToIStream
//
//  Synopsis:   convert a base64 stream to an IStream containing the binary data
//
//  returns:    The allocated stream
//
//      Note:
//
//--------------------------------------------------------------------
IStream * utBase64ToIStream(WCHAR *pszBase64)
{
    // calculate stream size
    ULONG strSize = (lstrlenW(pszBase64) / 4) * 3;

    IStream *pIStream = NULL;
    HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &pIStream);

    if (SUCCEEDED(hr))
    {
        HGLOBAL hgl;
        ULARGE_INTEGER uli;

        ULISet32(uli, strSize);
        pIStream -> SetSize(uli);
        hr = GetHGlobalFromStream(pIStream, &hgl);

        if (SUCCEEDED(hr))
        {
            BYTE * pbStream = (BYTE*)GlobalLock(hgl);
            if (pbStream)
            {
                utBase64ToByteStream(pszBase64, pbStream);
                GlobalUnlock(hgl);
            }
        }
        else
        {
            pIStream -> Release();
            return NULL;
        }

        return pIStream;
    }

    return NULL;
}

//+-------------------------------------------------------------------
//
//  Function:   utIStreamToBase64
//
//  Synopsis:   convert a stream containing binary data to a base64 string
//
//  returns:    The success code
//
//      Note:
//
//--------------------------------------------------------------------
HRESULT utIStreamToBase64(IStream* pIStream, WCHAR * pszOutStream, ULONG cbOutStreamSize)
{
    ASSERT(pIStream != NULL);

    // calculate size needed for buffer;
    STATSTG strmStat;
    HRESULT hr = pIStream -> Stat(&strmStat, STATFLAG_NONAME);

    if (SUCCEEDED(hr))
    {
        ULONG strmSize;
        ULIGet32(strmStat. cbSize, strmSize);

        // allocate buffer for stream
        BYTE *pbStream = (BYTE*)CoTaskMemAlloc( strmSize);
        if (pbStream)
        {
            ULONG cbBytesRead = 0;
            hr = pIStream -> Read((void*)pbStream, strmSize, &cbBytesRead);
            if (SUCCEEDED(hr) && cbBytesRead)
            {
                // allocate WCHAR buffer for base64 data if needed
                ULONG cbOutStream = ((ULONG)((cbBytesRead+2) / 3)) * 4;

                if (!pszOutStream)
                    pszOutStream = (WCHAR*)CoTaskMemAlloc((cbOutStream + 1) *sizeof(WCHAR));

                // check that output stream is of sufficient size
                if (pszOutStream && (cbOutStreamSize >= ((cbOutStream + 1) *sizeof(WCHAR))))
                    utByteStreamToBase64(pbStream, cbBytesRead, pszOutStream);
                else
                    hr = E_OUTOFMEMORY;
            }
            CoTaskMemFree(pbStream);
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::CObjrefMoniker
//
//  Synopsis:   Constructor
//
//  Arguments:  [pUnk] --
//
//  Returns:    -
//
//  Algorithm:
//
//  History:    04-Apr 97   Ronans
//
//----------------------------------------------------------------------------
CObjrefMoniker::CObjrefMoniker( LPUNKNOWN pUnk )
: CPointerMoniker(pUnk)
{
	// no special behavior - just want to distinguish for debugging at present
    mnkDebugOut((DEB_ITRACE,
                "CObjrefMoniker::constructor(%x,%x)\n",
                this, pUnk));

    m_lpszDisplayName = NULL;
}


//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::~CObjrefMoniker
//
//  Synopsis:   Destructor
//
//  Arguments:  -
//
//  Returns:    -
//
//  Algorithm:
//
//  History:    04-Apr 97   Ronans
//
//----------------------------------------------------------------------------
CObjrefMoniker::~CObjrefMoniker( void )
{
	// no special behavior - just want to distinguish for debugging at present
    mnkDebugOut((DEB_ITRACE,
                "CObjrefMoniker::destructor(%x,%x)\n",
                this, m_pUnk));

    if (m_lpszDisplayName)
    {
        CoTaskMemFree(m_lpszDisplayName);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   IsObjrefMoniker : Private
//
//  Synopsis:   Constructor
//
//  Arguments:  [pmk] --
//
//  Returns:    pmk if it supprts CLSID_ObjrefMoniker
//              NULL otherwise
//
//  Algorithm:
//
//  History:    04-Apr-97  ronans       Created
//
//----------------------------------------------------------------------------
INTERNAL_(CObjrefMoniker *) IsObjrefMoniker ( LPMONIKER pmk )
{
    CObjrefMoniker *pCORM;

    if ((pmk->QueryInterface(CLSID_ObjrefMoniker, (void **)&pCORM)) == S_OK)
    {
        // we release the AddRef done by QI but return the pointer
        pCORM->Release();
        return pCORM;
    }

    // dont rely on user implementations to set pCORM to NULL on failed QI
    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::Create
//
//  Synopsis:   Create a new objref moniker
//
//  Arguments:  [pmk] --
//
//  Returns:    pmk if it supprts CLSID_ObjrefMoniker
//              NULL otherwise
//
//  Algorithm:
//
//  History:    04-Apr-97  ronans       Created
//
//----------------------------------------------------------------------------
CObjrefMoniker *CObjrefMoniker::Create(LPUNKNOWN pUnk )
{
    mnkDebugOut((DEB_ITRACE, "CObjrefMoniker::Create(%x)\n", pUnk ));
    CObjrefMoniker *pCORM = new CObjrefMoniker(pUnk);

    return pCORM;
}


//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid]
//              [ppvObj]
//
//  Returns:
//
//  Algorithm:
//
//  History:    04-Apr-97  ronans       Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::QueryInterface (THIS_ REFIID riid, LPVOID *ppvObj)
{
    M_PROLOG(this);
    VDATEIID (riid);
    VDATEPTROUT(ppvObj, LPVOID);

#ifdef _DEBUG
    if (riid == IID_IDebug)
    {
	*ppvObj = &(m_Debug);
	return NOERROR;
    }
#endif

    if (IsEqualIID(riid, CLSID_ObjrefMoniker))
    {
        //  called by IsObjrefMoniker.
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    return CPointerMoniker::QueryInterface(riid, ppvObj);
}

//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::GetClassId
//
//  Synopsis:
//
//  Arguments:  [riid]
//              [ppvObj]
//
//  Returns:
//
//  Algorithm:
//
//  History:    04-Apr-97  ronans       Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::GetClassID (LPCLSID lpClassId)
{
    M_PROLOG(this);
    VDATEPTROUT(lpClassId, CLSID);

    *lpClassId = CLSID_ObjrefMoniker;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::IsEqual
//
//  Synopsis:
//
//  Arguments:  [pmkOtherMoniker]
//
//  Returns:
//
//  Algorithm:
//
//  History:    04-Apr-97  ronans       Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::IsEqual  (THIS_ LPMONIKER pmkOtherMoniker)
{
    M_PROLOG(this);
    VDATEIFACE(pmkOtherMoniker);

    CObjrefMoniker FAR* pCIM = IsObjrefMoniker(pmkOtherMoniker);
    if (pCIM)
    {
        // the other moniker is an objref moniker.
        //for the names, we do a case-insensitive compare.
        if (m_pUnk == pCIM->m_pUnk)
        {
            return S_OK;
        }
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::IsSystemMoniker
//
//  Synopsis:
//
//  Arguments:  [pdwType]
//
//  Returns:
//
//  Algorithm:
//
//  History:    04-Apr-97  ronans       Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::IsSystemMoniker  (THIS_ LPDWORD pdwType)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CObjrefMoniker::IsSystemMoniker(%x,%x)\n",
                this, pdwType));

    __try
    {
	    *pdwType = MKSYS_OBJREFMONIKER;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::CommonPrefixWith
//
//  Synopsis:
//
//  Arguments:  [pmkOther]
//              [ppmkPrefix]
//
//  Returns:
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::CommonPrefixWith	(LPMONIKER pmkOther,
                                                 LPMONIKER *ppmkPrefix)
{
    M_PROLOG(this);
    VDATEPTROUT(ppmkPrefix,LPMONIKER);
    *ppmkPrefix = NULL;
    VDATEIFACE(pmkOther);

    if (S_OK == IsEqual(pmkOther))
    {
        *ppmkPrefix = this;
        AddRef();
        return MK_S_US;
    }

    return CBaseMoniker::CommonPrefixWith(pmkOther, ppmkPrefix);
}









//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::RelativePathTo
//
//  Synopsis:
//
//  Arguments:  [pmkOther]
//              [ppmkRelPath]
//
//  Returns:
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::RelativePathTo  (THIS_ LPMONIKER pmkOther,
                                               LPMONIKER *ppmkRelPath)
{
    return CBaseMoniker::RelativePathTo(pmkOther, ppmkRelPath);
}

//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::IsDirty
//
//  Synopsis:   Checks the object for changes since it was last saved.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::IsDirty()
{
    mnkDebugOut((DEB_ITRACE,
                "CObjrefMoniker::IsDirty(%x)\n",
                this));

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::Load
//
//  Synopsis:   Loads an objref moniker from a stream
//
//  Notes:      objref monikers are loaded as marshalled data
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::Load(IStream *pStream)
{
    HRESULT hr;
    ULONG   cbRead;

    mnkDebugOut((DEB_ITRACE, "CObjrefMoniker::Load(%x,%x)\n", this, pStream));
    __try
    {
        // Unmarshal the object we're wrapping
        hr = CoUnmarshalInterface(pStream, IID_IUnknown,(LPVOID *) &m_pUnk);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::Save
//
//  Synopsis:   Save the objref moniker to a stream
//
//  Notes:      Objref moniker is saved as table marshalled data
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::Save(IStream *pStream, BOOL fClearDirty)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CObjrefMoniker::Save(%x,%x,%x)\n",
                this, pStream, fClearDirty));

    if (!m_pUnk)
        return E_UNEXPECTED;

    __try
    {
        // Marshal the wrapped object
        hr = CoMarshalInterface(pStream,
                            IID_IUnknown,
                            m_pUnk,
                            MSHCTX_DIFFERENTMACHINE,
                            0,
                            MSHLFLAGS_TABLEWEAK);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::GetSizeMax
//
//  Synopsis:   Get the maximum size required to serialize this moniker
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::GetSizeMax(ULARGE_INTEGER * pcbSize)
{
    HRESULT hr = E_FAIL;

    mnkDebugOut((DEB_ITRACE,
				"CObjrefMoniker::GetSizeMax(%x,%x)\n",
                this, pcbSize));

    if (!m_pUnk)
        return E_UNEXPECTED;

    __try
    {
        DWORD dwSize;
        hr = CoGetMarshalSizeMax(&dwSize, IID_IUnknown, m_pUnk,
                            MSHCTX_DIFFERENTMACHINE,
                            0,
                            MSHLFLAGS_TABLEWEAK);
        if (SUCCEEDED(hr))
            ULISet32(*pcbSize, dwSize);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::GetDisplayName - IMoniker implementation
//
//  Synopsis:   Get the display name of this moniker.
//
//  Notes:      Call ProgIDFromClassID to get the ProgID
//              Append a ':' to the end of the string.
//              If no ProgID is available, then use
//              objref:<marshalling data in base64>:
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::GetDisplayName(
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    LPWSTR   * lplpszDisplayName)
{
    HRESULT hr = S_OK;
    LPWSTR pszDisplayName;

    mnkDebugOut((DEB_ITRACE,
                "CObjrefMoniker::GetDisplayName(%x,%x,%x,%x)\n",
                this, pbc, pmkToLeft, lplpszDisplayName));

    // check that we are holding a valid interface and that there is no
    // moniker to the left of us
    if ((!m_pUnk) || pmkToLeft)
        return E_UNEXPECTED;

    __try
    {
        LPWSTR pszPrefix;
        WCHAR szClassID[37];

        *lplpszDisplayName = NULL;


        // if we don't have a cached display name , build one
        if (!m_lpszDisplayName)
        {
            //Get the prefix
            hr = ProgIDFromCLSID(CLSID_ObjrefMoniker, &pszPrefix);

            if (!SUCCEEDED(hr))
            {
                // set the prefix to "objref"
                pszPrefix = (LPWSTR)CoTaskMemAlloc(7 * sizeof(WCHAR));
                lstrcpyW(pszPrefix, L"objref");
                hr = S_OK;
            }

            // build up marshalling information for display name
            // note we can only cache data based on TABLE MARSHALLED DATA
            IStream *pIStream = NULL;

            if (SUCCEEDED(hr))
            {
                hr = CreateStreamOnHGlobal(NULL, TRUE, &pIStream);
            }

            if (SUCCEEDED(hr))
            {
                hr = Save(pIStream, TRUE);
                if(SUCCEEDED(hr))
                {
                    // determine string buffer size needed
                    ULONG  cName = lstrlenW(pszPrefix) + 1; // colon

                    // GetStreamSize
                    ULARGE_INTEGER uli;
                    ULISet32(uli, 0);

                    hr = GetSizeMax(&uli);
                    if (SUCCEEDED(hr))
                    {
                        // max size of output buffer for base64 data will be
                        // 4/3 of stream size;
                        ULONG ulStreamSize;

                        ULIGet32(uli, ulStreamSize);
                        ulStreamSize = ((DWORD)((ulStreamSize+2)/3)) * 4;
                        ulStreamSize++; // allow for null terminator

                        // rewind the stream to starting position
                        LARGE_INTEGER liPos;
                        ULARGE_INTEGER uliNewPos;

                        LISet32(liPos, 0);
                        hr = pIStream -> Seek(liPos, STREAM_SEEK_SET, &uliNewPos);
                        if (SUCCEEDED(hr))
                        {
                            // total size is size of prefix + 2 (for : and null terminators)
                            m_lpszDisplayName = (LPWSTR) CoTaskMemAlloc((cName + ulStreamSize+1)* sizeof(wchar_t));
                            if(m_lpszDisplayName != NULL)
                            {
                                // write out prefix
                                lstrcpyW(m_lpszDisplayName, pszPrefix);
                                lstrcatW(m_lpszDisplayName, L":");

                                // write out marshalling data
                                hr = utIStreamToBase64(pIStream, &m_lpszDisplayName[cName], ulStreamSize *sizeof(wchar_t));

                                // write terminating colon
                                if (SUCCEEDED(hr))
                                    lstrcatW(m_lpszDisplayName, L":");
                            }
                            else
                                hr = E_OUTOFMEMORY;
                        }
                    }
                }
                pIStream -> Release();
            }

            if (pszPrefix)
                CoTaskMemFree(pszPrefix);
        }

        // create copy of display name to return
        if (m_lpszDisplayName && SUCCEEDED(hr))
        {
            int dnameLen = lstrlenW(m_lpszDisplayName);

            // CODEWORK - special case for display name greater than 2048
            if (dnameLen && (dnameLen >= 2048))
            {
                // downlevel MSIE 3.0 clients have a hardwired limit of 2048
                hr = E_INVALIDARG;

                mnkDebugOut((DEB_ERROR, "Error: CObjrefMoniker::GetDisplayName - name too long \n"));
            }
            else if (dnameLen)
            {
            *lplpszDisplayName =  (LPWSTR) CoTaskMemAlloc((dnameLen+1)* sizeof(wchar_t));
            if (*lplpszDisplayName)
                {
                lstrcpyW(*lplpszDisplayName, m_lpszDisplayName);
                hr = S_OK;
                }
            else
                hr = E_OUTOFMEMORY;
            }
            else
                hr = E_FAIL;
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CObjrefMoniker::Enum (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
    M_PROLOG(this);
    VDATEPTROUT(ppenumMoniker,LPMONIKER);
    *ppenumMoniker = NULL;
    return S_OK;
}

STDMETHODIMP CObjrefMoniker::GetTimeOfLastChange(THIS_ LPBC pbc, LPMONIKER pmkToLeft, FILETIME *pfiletime)
{
    M_PROLOG(this);
    VDATEIFACE(pbc);
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }
    VDATEPTROUT(pfiletime, FILETIME);

    return MK_E_UNAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\cptrmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       cptrmon.cxx
//
//  Contents:   Implementation of CPointerMoniker
//
//  Classes:
//
//  Functions:
//
//  History:	12-27-93   ErikGav   Created
//		06-14-94   Rickhi    Fix type casting
//              07-06-95   BruceMa   Make remotable
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "cptrmon.hxx"
#include "cantimon.hxx"
#include "mnk.h"

NAME_SEG(CPtrMon)







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::CPointerMoniker
//
//  Synopsis:   Constructor
//
//  Arguments:  [pUnk] -- 
//
//  Returns:    -
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
CPointerMoniker::CPointerMoniker( LPUNKNOWN pUnk ) CONSTR_DEBUG
{
    // We allow pUnk == NULL initially when remoting a pointer moniker
    if (pUnk)
    {
        pUnk->AddRef();
    }
    m_pUnk        = pUnk;
}







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::~CPointerMoniker
//
//  Synopsis:   Destructor
//
//  Arguments:  -
//
//  Returns:    -
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
CPointerMoniker::~CPointerMoniker( void )
{
    M_PROLOG(this);

    if (m_pUnk)
    {
        m_pUnk->Release();
    }
}






//+---------------------------------------------------------------------------
//
//  Function:   IsPointerMoniker : Private
//
//  Synopsis:   Constructor
//
//  Arguments:  [pmk] -- 
//
//  Returns:    pmk if it supprts CLSID_PointerMoniker
//              NULL otherwise
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
INTERNAL_(CPointerMoniker *) IsPointerMoniker ( LPMONIKER pmk )
{
    CPointerMoniker *pCPM;

    if ((pmk->QueryInterface(CLSID_PointerMoniker, (void **)&pCPM)) == S_OK)
    {
	// we release the AddRef done by QI but return the pointer
	pCPM->Release();
	return pCPM;
    }

    // dont rely on user implementations to set pCPM to NULL on failed QI
    return NULL;
}







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::Create
//
//  Synopsis:   Create a new pointer moniker
//
//  Arguments:  [pmk] -- 
//
//  Returns:    pmk if it supprts CLSID_PointerMoniker
//              NULL otherwise
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
CPointerMoniker *CPointerMoniker::Create(
	LPUNKNOWN pUnk )
{
    CPointerMoniker *pCIM = new CPointerMoniker(pUnk);

    return pCIM;
}








//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::QueryInterface
//
//  Synopsis:   
//
//  Arguments:  [riid]
//              [ppvObj]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::QueryInterface (THIS_ REFIID riid,
                                              LPVOID *ppvObj)
{
    M_PROLOG(this);
    VDATEIID (riid);
    VDATEPTROUT(ppvObj, LPVOID);

#ifdef _DEBUG
    if (riid == IID_IDebug)
    {
	*ppvObj = &(m_Debug);
	return NOERROR;
    }
#endif

    if (IsEqualIID(riid, CLSID_PointerMoniker))
    {
	//  called by IsPointerMoniker.
	AddRef();
	*ppvObj = this;
	return S_OK;
    }

    if (IsEqualIID(riid, IID_IMarshal))
    {
	AddRef();
	*ppvObj = (IMarshal *) this;
	return S_OK;
    }

    if (IsEqualIID(riid, IID_IROTData))
    {
	return E_NOINTERFACE;
    }


    return CBaseMoniker::QueryInterface(riid, ppvObj);
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::AddRef
//
//  Synopsis:   
//
//  Arguments:  -
//
//  Returns:    New reference count
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPointerMoniker::AddRef (void)
{
    M_PROLOG(this);

    CBaseMoniker::AddRef();
    return m_refs;
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::Release
//
//  Synopsis:   
//
//  Arguments:  -
//
//  Returns:    Current reference count
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPointerMoniker::Release (void)
{
    M_PROLOG(this);
    Assert(m_refs != 0);

    ULONG ul = m_refs;

    if (InterlockedDecrement((long *)&m_refs) == 0)
    {
    	delete this;
    	return 0;
    }
    return ul - 1;
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::GetClassId
//
//  Synopsis:   
//
//  Arguments:  [riid]
//              [ppvObj]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::GetClassID (LPCLSID lpClassId)
{
    M_PROLOG(this);
    VDATEPTROUT(lpClassId, CLSID);

    *lpClassId = CLSID_PointerMoniker;
    return S_OK;
}





        

//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::GetUnmarshalClass
//
//  Synopsis:   Return the unmarshaling class
//
//  Arguments:  [riid]
//              [pv]
//              [dwMemctx]
//              [pvMemctx]
//              [mshlflags]
//              [pClsid]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::GetUnmarshalClass(THIS_ REFIID riid,
                                                LPVOID pv,
                                                DWORD dwMemctx,
                                                LPVOID pvMemctx,
                                                DWORD mshlflags,
                                                LPCLSID pClsid)
{
    M_PROLOG(this);

    // ronans - objref moniker changes
    return GetClassID(pClsid);
}







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::GetMarshalSizeMax
//
//  Synopsis:   Return the maximum stream size needed
//
//  Arguments:  [riid]
//              [pv]
//              [dwMemctx]
//              [pvMemctx]
//              [mshlflags]
//              [lpdwSize]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::GetMarshalSizeMax(THIS_ REFIID riid,
                                                LPVOID pv,
                                                DWORD dwMemctx,
                                                LPVOID pvMemctx,
                                                DWORD mshlflags,
                                                LPDWORD lpdwSize)
{
    M_PROLOG(this);

    
    return CoGetMarshalSizeMax(lpdwSize, riid, m_pUnk, dwMemctx,
                               pvMemctx, mshlflags);
}







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::MarshalInterface
//
//  Synopsis:   Marshal the object we're wrapping
//
//  Arguments:  [pStm]
//              [riid]
//              [pv]
//              [dwMemctx]
//              [pvMemctx]
//              [mshlflags]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::MarshalInterface(THIS_ LPSTREAM pStm,
                                               REFIID riid,
                                               LPVOID pv,
                                               DWORD dwMemctx,
                                               LPVOID pvMemctx,
                                               DWORD mshlflags)
{
    HRESULT hr;
    LPVOID  pUnk;
    
    M_PROLOG(this);

    // Make sure we support the requested interface
    if (FAILED(hr = QueryInterface(riid, &pUnk)))
    {
        return hr;
    }
    Release();

    // Marshal the wrapped object
    hr = CoMarshalInterface(pStm,
                            IID_IUnknown,
                            m_pUnk,
                            dwMemctx,
                            pvMemctx,
                            mshlflags);
    return hr;
}







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::UnmarshalInterface
//
//  Synopsis:   Unmarshal the object we're wrapping
//
//  Arguments:  [pStm]
//              [riid]
//              [ppv]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::UnmarshalInterface(THIS_ LPSTREAM pStm,
                                                 REFIID riid, LPVOID *ppv)
{
    HRESULT hr;
    LPVOID  pUnk;
    
    M_PROLOG(this);

    // Unmarshal the object we're wrapping
    if (FAILED(hr = CoUnmarshalInterface(pStm, IID_IUnknown,
                                         (LPVOID *) &m_pUnk)))
    {
        return hr;
    }

    // Make sure we support the requested interface - this also takes
    // the reference we need
    if (FAILED(hr = QueryInterface(riid, &pUnk)))
    {
        return hr;
    }

    // Return ourselves as the unmarshaled object
    *ppv = this;

    return S_OK;
}







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::ReleaseMarshalData
//
//  Synopsis:   Don't do anything
//
//  Arguments:  [pStm]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::ReleaseMarshalData(THIS_ LPSTREAM pStm)
{
    M_PROLOG(this);

    return CoReleaseMarshalData(pStm);;
}







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::DisconnectObject
//
//  Synopsis:   Don't do anything
//
//  Arguments:  [pStm]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::DisconnectObject(THIS_ DWORD dwReserved)
{
    M_PROLOG(this);

    return CoDisconnectObject(m_pUnk, NULL);
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::BindToObject
//
//  Synopsis:   
//
//  Arguments:  [pbc]
//              [pmkToLeft]
//              [iidResult]
//              [ppvResult]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::BindToObject ( LPBC pbc,
	LPMONIKER pmkToLeft, REFIID iidResult,
	VOID **ppvResult)
{
    HRESULT        hr;
    LARGE_INTEGER  cMove = {0, 0};

    M_PROLOG(this);
    VDATEPTROUT(ppvResult, LPVOID);
    *ppvResult = NULL;
    VDATEIFACE(pbc);
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }
    VDATEIID(iidResult);
    
    // Attempt to return the requested interface
    if (m_pUnk)
    {
        return m_pUnk->QueryInterface(iidResult, ppvResult);
    }

    // No object
    return E_UNEXPECTED;
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::BindToStorage
//
//  Synopsis:   
//
//  Arguments:  [lpbc]
//              [pmkToLeft]
//              [riid]
//              [ppvResult]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::BindToStorage (LPBC pbc, LPMONIKER
	pmkToLeft, REFIID riid, LPVOID *ppvObj)
{
    M_PROLOG(this);

    // Same logic as for BindToStorage
    return BindToObject(pbc, pmkToLeft, riid, ppvObj);
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::ComposeWith
//
//  Synopsis:   
//
//  Arguments:  [pmkRight]
//              [fOnlyIfNotGeneric]
//              [ppmkComposite]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::ComposeWith (LPMONIKER pmkRight,
	BOOL fOnlyIfNotGeneric, LPMONIKER *ppmkComposite)
{

    VDATEPTROUT(ppmkComposite,LPMONIKER);
    *ppmkComposite = NULL;
    VDATEIFACE(pmkRight);

    HRESULT hresult = NOERROR;

    //
    // If this is an AntiMoniker, then we are going to ask the AntiMoniker
    // for the composite. This is a backward compatibility problem. Check
    // out the CAntiMoniker::EatOne() routine for details.
    //

    CAntiMoniker *pCAM = IsAntiMoniker(pmkRight);
    if (pCAM)
    {
	pCAM->EatOne(ppmkComposite);
    }
    else
    {
	if (!fOnlyIfNotGeneric)
	{
	    hresult = CreateGenericComposite( this, pmkRight, ppmkComposite );	
	}
	else
	{
	    hresult = ResultFromScode(MK_E_NEEDGENERIC);
	    *ppmkComposite = NULL;
	}
    }
    return hresult;
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::IsEqual
//
//  Synopsis:   
//
//  Arguments:  [pmkOtherMoniker]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::IsEqual  (THIS_ LPMONIKER pmkOtherMoniker)
{
    M_PROLOG(this);
    VDATEIFACE(pmkOtherMoniker);

    CPointerMoniker FAR* pCIM = IsPointerMoniker(pmkOtherMoniker);
    if (pCIM)
    {
        // the other moniker is a ptr moniker.
        if (m_pUnk == pCIM->m_pUnk)
        {
            return S_OK;
        }
    }

    return S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::Hash
//
//  Synopsis:   
//
//  Arguments:  [pdwHash]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::Hash  (THIS_ LPDWORD pdwHash)
{
    M_PROLOG(this);
    VDATEPTROUT(pdwHash, DWORD);

//
// REVIEW Sundown - v-thief 06/98:
//
//    In this first pass, I have considered Hash values are DWORDs for all the class members/methods.
//    This has to be checked with ScottRob or RickHi especially in terms of consumers.
//
    *pdwHash = PtrToUlong(m_pUnk);	
    noError;
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::GetTimeOfLastChange
//
//  Synopsis:   
//
//  Arguments:  [pbc]
//              [pmkToLeft]
//              [pFileTime]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::GetTimeOfLastChange(THIS_ LPBC pbc,
                                                  LPMONIKER pmkToLeft,
                                                  FILETIME *pfiletime)
{
    M_PROLOG(this);
    VDATEIFACE(pbc);
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }
    VDATEPTROUT(pfiletime, FILETIME);

    return E_NOTIMPL; // GetTimeOfLastChange not implemented
                      // for pointer monikers
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::Inverse
//
//  Synopsis:   
//
//  Arguments:  [ppmk]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::Inverse  (THIS_ LPMONIKER *ppmk)
{
    M_PROLOG(this);
    VDATEPTROUT(ppmk, LPMONIKER);
    return CreateAntiMoniker(ppmk);
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::CommonPrefixWith
//
//  Synopsis:   
//
//  Arguments:  [pmkOther]
//              [ppmkPrefix]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::CommonPrefixWith	(LPMONIKER pmkOther,
                                                 LPMONIKER *ppmkPrefix)
{
    M_PROLOG(this);
    VDATEPTROUT(ppmkPrefix,LPMONIKER);
    *ppmkPrefix = NULL;
    VDATEIFACE(pmkOther);

    if (S_OK == IsEqual(pmkOther))
    {
        *ppmkPrefix = this;
        AddRef();
        return MK_S_US;
    }
    
    return MK_E_NOPREFIX;
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::RelativePathTo
//
//  Synopsis:   
//
//  Arguments:  [pmkOther]
//              [ppmkRelPath]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::RelativePathTo  (THIS_ LPMONIKER pmkOther,
                                               LPMONIKER *ppmkRelPath)
{
    M_PROLOG(this);
    VDATEPTROUT(ppmkRelPath, LPMONIKER);
    *ppmkRelPath = NULL;
    VDATEIFACE(pmkOther);
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::GetDisplayName
//
//  Synopsis:   
//
//  Arguments:  [pbc]
//              [pmkToLeft]
//              [lplpszisplayName]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::GetDisplayName (LPBC pbc,
                                              LPMONIKER pmkToLeft,
                                              LPWSTR  *lplpszDisplayName )
{
    M_PROLOG(this);
    VDATEPTROUT(lplpszDisplayName, LPWSTR);
    *lplpszDisplayName = NULL;
    VDATEIFACE(pbc);
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }

    return E_NOTIMPL;
}



//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::ParseDisplayName
//
//  Synopsis:   
//
//  Arguments:  [pbc]
//              [pmkToLeft]
//              [lpszDisplayName]
//              [pchEaten]
//              [ppmkOut]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::ParseDisplayName (LPBC pbc,
                                                LPMONIKER pmkToLeft,
                                                LPWSTR lpszDisplayName,
                                                ULONG *pchEaten,
                                                LPMONIKER *ppmkOut)
{
    M_PROLOG(this);
    VDATEPTROUT(ppmkOut,LPMONIKER);
    *ppmkOut = NULL;
    VDATEIFACE(pbc);
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }
    VDATEPTRIN(lpszDisplayName, WCHAR);
    VDATEPTROUT(pchEaten,ULONG);

    IParseDisplayName FAR * lpPDN;
    HRESULT hresult;

    hresult = m_pUnk->QueryInterface(IID_IParseDisplayName, (LPLPVOID)&lpPDN);
    if (hresult == S_OK)
    {
        hresult = lpPDN->ParseDisplayName(pbc, lpszDisplayName,
                                          pchEaten, ppmkOut);
        lpPDN->Release();
    }

    return hresult;
}








//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::IsRunning
//
//  Synopsis:   Objects that pointer monikers point to must be running, since
//		the pointer moniker holds an active reference to it.
//		Therefore, this routine will validate the parameters, then
//		always return S_OK.
//
//  Effects:
//
//  Arguments:  [pbc] --
//		[pmkToLeft] --
//		[pmkNewlyRunning] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    3-03-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::IsRunning (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
	      LPMONIKER pmkNewlyRunning)
{
    M_PROLOG(this);
    VDATEIFACE (pbc);
    if (pmkToLeft)
    {
	VDATEIFACE (pmkToLeft);
    }

    if (pmkNewlyRunning)
    {
	VDATEIFACE (pmkNewlyRunning);
    }

    //
    // Always running.
    //
    return(S_OK);
}











//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::IsSystemMoniker
//
//  Synopsis:   
//
//  Arguments:  [pdwType]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::IsSystemMoniker  (THIS_ LPDWORD pdwType)
{
    M_PROLOG(this);
    *pdwType = MKSYS_POINTERMONIKER;
    return S_OK;		
}


STDMETHODIMP CPointerMoniker::Enum (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::CDebug::Dump
//
//  Synopsis:   
//
//  Arguments:  [riid]
//              [ppvObj]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
#ifdef _DEBUG
STDMETHODIMP_(void) NC(CPointerMoniker,CDebug)::Dump ( IDebugStream *pdbstm)
{
    VOID_VDATEIFACE( pdbstm );
	
    *pdbstm << "CPointerMoniker @" << (VOID FAR *)m_pPointerMoniker;
    *pdbstm << '\n';
    pdbstm->Indent();
    *pdbstm << "Refcount is " << (int)(m_pPointerMoniker->m_refs) << '\n';
    *pdbstm << "Pointer is " << (LPVOID)m_pPointerMoniker->m_pUnk << '\n';
    pdbstm->UnIndent();
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::CDebug::IsValid
//
//  Synopsis:   
//
//  Arguments:  [fSuspicious]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP_(BOOL) NC(CPointerMoniker,CDebug)::IsValid ( BOOL fSuspicious )
{
    return ((LONG)(m_pPointerMoniker->m_refs) > 0);
    //	add more later, maybe
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\cmonimp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       cmonimp.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-27-93   ErikGav   Created
//              16-May-94   AlexT   Removed reference variables
//                                  Added support for '!' in paths
//              21-Jun-94  KentCe   Corrected string dup routine.
//              11-Nov-94  BruceMa  Make use of GetLongPathName more efficient
//                                   and enable its use for Chicago
//              20-Jul-95  BruceMa  Rewrote MkParseDisplayName
//                                  Rewrote FindMaximalFileName
//                                  General cleanup
//              22-Sep-95  MikeHill Added CreateFileMonikerEx
//              29-Nov-95  MikeHill Added ValidateBindOpts().
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include <io.h>

#include "cbasemon.hxx"
#include "citemmon.hxx"
#include "cfilemon.hxx"
#include "cantimon.hxx"
#include "cbindctx.hxx"
#include "cptrmon.hxx"
#include "mnk.h"
#include "rothint.hxx"
#include "crot.hxx"
#include "classmon.hxx"
#include "cobjrmon.hxx"
#include "csessmon.hxx"
#include <longname.h>

#define IsFileSystemSeparator(ch)   ('\\' == (ch) || '/' == (ch) || ':' == (ch))
#define IsItemMonikerSeparator(ch)  ('!' == (ch) || '/' == (ch) || '[' == (ch) || '#' == (ch))
#define IsDriveLetter(ch) ( ( (ch) >= L'A' && (ch) <= L'Z') ||  ( (ch) >= L'a' && (ch) <= L'z'))


#ifdef _CAIRO_

//+---------------------------------------------------------------------------
//
//  Function:   ValidateBindOpts
//
//  Synopsis:   Validates the fields of a BIND_OPTS (or BIND_OPTS2) structure with
//              respect to file monikers.
//
//  Effects:    Outputs a debugger message if an invalid condition is found.
//
//  Arguments:  [pbind_opts] -- Pointer to a BIND_OPTS or BIND_OPTS2 structure.
//
//  Requires:   None.
//
//  Returns:    TRUE if valid.  FALSE otherwise.
//
//  Signals:    None.
//
//  Modifies:   None.
//
//  Algorithm:  Verify that bits set in dwTrackFlags are defined.
//
//  History:    11-29-95    MikeHill    Created.
//
//  Notes:      This routine can process either BIND_OPTS or BIND_OPTS2 structures,
//              but the latter must be cast as an LPBIND_OPTS.
//
//----------------------------------------------------------------------------

BOOL ValidateBindOpts( const LPBIND_OPTS pbind_opts )
{
    Assert( pbind_opts != NULL );

    // Validate fields that only exist in BIND_OPTS2.

    if( pbind_opts->cbStruct >= sizeof( BIND_OPTS2 ))
    {
        const LPBIND_OPTS2 &pbind_opts2 = (const LPBIND_OPTS2) pbind_opts;

        // Verify the TRACK_FLAGS.

        if( pbind_opts2->dwTrackFlags & ~TRACK_FLAGS_MASK )
        {
            mnkDebugOut(( DEB_ITRACE,
                          "ValidateBindOpts:  Invalid TRACK_FLAGS (%x)\n",
                          pbind_opts2->dwTrackFlags ));
            return( FALSE );
        }
    }

    // No error conditions were found, so we'll declare this a valid Bind Opts.

    return( TRUE );

}   // ValidateBindOpts

#endif // _CAIRO_



//+---------------------------------------------------------------------------
//
//  Function:   DupWCHARString
//
//  Synopsis:   Duplicate a WCHAR string
//
//  Effects:
//              lpwcsOutput is allocated via PrivMemAlloc(), and lpwcsString
//              is copied into it.
//
//  Arguments:  [lpwcsString] -- String to dup
//              [lpwcsOutput] -- Reference to new string pointer
//              [ccOutput] -- Reference to character count in string
//
//  Requires:
//
//  Returns:
//              If lpwcsString == NULL, then lpwcsOutput == NULL, and
//              ccOutput == 0.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT DupWCHARString(LPCWSTR lpwcsString,
                        LPWSTR & lpwcsOutput,
                        USHORT & ccOutput)
{
    if (lpwcsString != NULL)
    {
        ccOutput = (USHORT) lstrlenW(lpwcsString);

        lpwcsOutput = (WCHAR *)PrivMemAlloc(sizeof(WCHAR)*(1+ccOutput));

        if (lpwcsOutput != NULL)
        {
            memcpy(lpwcsOutput, lpwcsString, (ccOutput + 1) * sizeof(WCHAR));

            return(NOERROR);
        }
        else
        {
            return(E_OUTOFMEMORY);
        }

    }
    lpwcsOutput = NULL;
    ccOutput = 0;
    return(NOERROR);
}

HRESULT CItemMonikerCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    // validated by the standard class factory
    Win4Assert(pUnkOuter == NULL);
    return CreateItemMoniker(OLESTR(""), OLESTR(""), (IMoniker **)ppv);
}

STDAPI CreateItemMoniker ( LPCWSTR lpszDelim, LPCWSTR lpszItem,
    LPMONIKER FAR * ppmk )
{
    OLETRACEIN((API_CreateItemMoniker, PARAMFMT("lpszDelim= %ws, lpszItem= %ws, ppmk= %p"),
                lpszDelim, lpszItem, ppmk));

    mnkDebugOut((DEB_ITRACE,
                 "CreateItemMoniker lpszDelim(%ws) lpszItem(%ws)\n",
                 lpszDelim?lpszDelim:L"<NULL>",
                 lpszItem?lpszItem:L"<NULL>"));

    CItemMoniker FAR * pCIM;
    HRESULT hresult;

    VDATEPTROUT_LABEL(ppmk,LPMONIKER, errRtn, hresult);
    VDATEPTRIN_LABEL(lpszDelim,WCHAR, errRtn, hresult);

    *ppmk = NULL;

    //VDATEPTRIN rejects NULL
    if( lpszItem )
        VDATEPTRIN_LABEL(lpszItem,WCHAR, errRtn, hresult);

    pCIM = CItemMoniker::Create(lpszDelim, lpszItem);

    if (pCIM)
    {
        *ppmk = (LPMONIKER)pCIM;
        CALLHOOKOBJECTCREATE(S_OK,CLSID_ItemMoniker,IID_IMoniker,(IUnknown **)ppmk);
        hresult = NOERROR;
    }
    else
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
    }

errRtn:
    OLETRACEOUT((API_CreateItemMoniker, hresult));

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsAbsolutePath
//
//  Synopsis:   Returns true if the path starts with a drive letter, or
//              with a UNC delimiter ('\\')
//
//  Effects:
//
//  Arguments:  [szPath] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-03-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsAbsolutePath (LPCWSTR szPath)
{
    if (NULL==szPath || *szPath == '\0')
    {
        return FALSE;
    }

    if (*szPath == '\\')
    {
        //  return TRUE if UNC path
        return (szPath[1] == '\\');
    }

    //
    // If the second character is a ':', then
    // it could very well be a drive letter and a ':'
    //
    // We could test for valid drive letters, but we don't have a really
    // compelling reason to do so. It will either work or fail later
    //
    return (szPath[1] == ':');
}

//+---------------------------------------------------------------------------
//
//  Function:   IsAbsoluteNonUNCPath
//
//  Synopsis:   Returns true if the path is an absolute, non UNC path
//
//  Effects:
//
//  Arguments:  [szPath] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-03-94   kevinro   Created
//             04-27-94   darryla   changed to return FALSE if first char
//                                  a \ since either relative or UNC
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsAbsoluteNonUNCPath (LPCWSTR szPath)
{
    if (NULL==szPath || *szPath == '\0')
    {
        return FALSE;
    }

    if (*szPath == '\\' || *szPath == '/')
    {
        //  return FALSE since it is either a UNC path or a relative
        //  path like \foo or /foo.
        return FALSE;
    }

    //
    // If the second character is a ':', then
    // it could very well be a drive letter and a ':'
    //
    // We could test for valid drive letters, but we don't have a really
    // compelling reason to do so. It will either work or fail later
    //

    return (szPath[1] == ':');
}

//+---------------------------------------------------------------------------
//
//  Function:   FindUNCEndServer
//
//  Synopsis:   Finds the end of the server section of a UNC path
//
//  Effects:
//
//  Arguments:  [lpszPathName] -- Path to search for UNC prefix
//              [endServer] -- Returned offset to end of UNC name
//
//  Requires:
//
//  Returns:
//      If the path is a UNC name, then endServer will point to the first
//      character of the 'path' section.
//
//      For example, \\server\share\path would return with endServer = 14
//      or \\server\share would also return with endServer = 14.
//
//      If the path isn't of this form, endServer == DEF_ENDSERVER on return.
//      Also, we need to make sure that if the form is ill-formed, we
//      mislead later steps into thinking this is a real UNC name. For
//      example, \\server\ is ill-formed and would later be treated as a
//      real UNC name.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-11-94   kevinro   Created
//             03-27-94   darryla   Changed to catch \\server\share legal
//                                  form and illegal \\server\.
//
//  Notes:
//
//----------------------------------------------------------------------------
void FindUNCEndServer(LPCWSTR lpszPathName, USHORT *pendServer)
{
    if (lpszPathName[0] == '\\' && lpszPathName[1] == '\\')
    {
        //
        // Need to find the second slash following the UNC delimiter
        //
        ULONG ulCountDown = 2;

        //
        // Found UNC prefix. Now find the second backslash
        //
        for(*pendServer = 2 ; lpszPathName[*pendServer] != 0 ; (*pendServer)++)
        {
            if (lpszPathName[*pendServer] == '\\')
            {
                if( --ulCountDown == 0)
                {
                    return;
                }
            }
        }

        // If we reached the end of the string and found one \, then we
        // have the form \\server\share and the *pendServer is the terminator
        // as long as we aren't looking at \\server\.
        if(lpszPathName[*pendServer] == '\0' &&
           ulCountDown == 1 &&
           lpszPathName[*pendServer - 1] != '\\')
        {
            return;
        }
    }

    *pendServer = DEF_ENDSERVER;
}



//+---------------------------------------------------------------------------
//
//  Function:   ExpandUNCName
//
//  Synopsis:   Given a path, determine a UNC share to it
//
//  Effects:
//
//  Arguments:  [lpszIn] --     Path to determine UNC name of
//              [lplpszOut] --  Output UNC name, allocated using new
//              [pEndServer] -- Output USHORT offset to start of actual path
//
//  Requires:
//      lpszIn should be of the form 'A:\<path>'
//
//  Returns:
//
//      lplpszOut can return as NULL if there was no UNC path available. In
//      this case, the caller should just use the normal string
//
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-11-94   kevinro   Created
//              05-25-94  AlexT     Use WNetGetUniversalName for non-Chicago
//              06-15-94  AlexT     Only call WNetGetUniversalName for remote
//
//  Notes:
//
//----------------------------------------------------------------------------
#ifdef _CAIRO_

//  We need to pass a buffer to WNetGetUniversalName which will get filled in
//  with a UNIVERSAL_NAME_INFOW structure plus a universal path which
//  can be up to MAX_PATH long.

#define UNIVERSAL_NAME_BUFFER_SIZE (sizeof(UNIVERSAL_NAME_INFOW) +         \
                                    MAX_PATH * sizeof(WCHAR) )

#else

//  We need to pass a buffer to WNetGetUniversalName which will get filled in
//  with a REMOTE_NAME_INFO structure add three strings - a universal path
//  (can be up to MAX_PATH long) and a remote connection and remaing path
//  (these last two will be at most MAX_PATH + 1 characters).


#define REMOTE_NAME_BUFFER_SIZE (sizeof(REMOTE_NAME_INFO) +         \
                                 MAX_PATH * sizeof(WCHAR) +         \
                                 (MAX_PATH + 1) * sizeof(WCHAR))
#endif

INTERNAL ExpandUNCName ( LPWSTR lpszIn, LPWSTR FAR * lplpszOut, USHORT FAR* pEndServer )
{
    mnkDebugOut((DEB_ITRACE,
                 "%p _IN ExpandUNCName (%ws, %p, %p)\n",
                 NULL, lpszIn, lplpszOut, pEndServer));

    WCHAR szDevice[] = L"A:\\";
    ULONG ulDriveType;

    *pEndServer = DEF_ENDSERVER;

    *szDevice = *lpszIn;
    Assert(lpszIn[1] == ':');
    ulDriveType = GetDriveType(szDevice);

    mnkDebugOut((DEB_ITRACE,
                 "ExpandUNCName: GetDriveType(%ws) says %s (%x)\n",
                 szDevice,
                 ulDriveType==DRIVE_REMOTE?"DRIVE_REMOTE":"not remote",
                 ulDriveType));

#ifdef _CHICAGO_
    //
    // Note: szRemoteName doesn't really need to be this big. Need to
    // findout what the largest \\server\share combination is allowed, and
    // use that as the size.
    //

    WCHAR  szRemoteName[MAX_PATH];
    DWORD cbRemoteName = MAX_PATH;
    HRESULT hr = NOERROR;

    int lenRemoteName;
    int lenIn;

    //
    // If this is a remote drive, attempt to get the UNC path that maps
    // to it.
    //

    //
    // The device name needs to be A:, not a root like the other API wanted.
    //
    szDevice[2] = 0;

    if (ulDriveType == DRIVE_REMOTE &&
       (WN_SUCCESS == (hr = OleWNetGetConnection(szDevice, szRemoteName,&cbRemoteName))))
    {
        //
        // Allocate a buffer large enough to hold the UNC server and share,
        // plus the size of the path
        //
        //

        lenRemoteName = lstrlenW(szRemoteName);
        lenIn = lstrlenW(lpszIn);

        //
        // Make sure we aren't about to create a path that is too large.
        //

        //
        // (lenIn - 2) removes the space required by the drive and the
        // colon, which are not going to be copied
        //
        if ((lenRemoteName + lenIn - 2) > MAX_PATH)
        {
            hr = MK_E_SYNTAX;
            goto errRet;
        }

        //
        // Allocate room for the concatenated string. The length of the
        // buffer is the length of the remote name, plus the length of the
        // input string. Subtract from that the drive + colon (2 WCHARS),
        // then add back room for a terminating NULL. This is where
        // (lenIn - 1) is derived
        //
        *lplpszOut = (WCHAR *)
            PrivMemAlloc(sizeof(WCHAR) * (lenRemoteName + (lenIn - 1)));

        if( !*lplpszOut )
        {
            hr = ResultFromScode(E_OUTOFMEMORY);
            goto errRet;
        }

        memcpy( *lplpszOut, szRemoteName, lenRemoteName * sizeof(WCHAR));

        //
        // We know that the lpszIn is of the form A:\path and we want to end
        // up with \\server\share\path. Skipping the first two characters of
        // lpszIn should suffice. Copying (lenIn - 1) characters makes us
        // copy over the NULL character from lpszIn
        //
        memcpy( *lplpszOut + lenRemoteName, lpszIn + 2, (lenIn - 1) * sizeof(WCHAR));

        //
        // EndServer is the offset to the start of the 'path'. It should point at the
        // first backslash
        //

        *pEndServer = lenRemoteName;
    }
    else
    {
        //
        // Its possible that WNetGetConnection failed. In this case, we
        // can only use the path that we were given.
        //

        if (ulDriveType == DRIVE_REMOTE)
        {
            mnkDebugOut((DEB_IERROR,
                         "ExpandUNCName: WNetGetConnection(%ws) failed (%x)\n",
                         szDevice,
                         hr));
        }

        //
        // There was no UNC form of this path. Set the output pointer to be
        // NULL
        //

        // NOTE:
        //
        // This would be a very good place to determine if the given path
        // has a UNC equivalent, even if it is a local drive.
        //

        *lplpszOut = NULL;
        *pEndServer = DEF_ENDSERVER;
    }
errRet:

#else

    //
    // If this is a remote drive, attempt to get the UNC path that maps
    // to it.
    //


    HRESULT hr = NOERROR;

# ifdef _CAIRO_
    // [mikese] This is the correct thing to do -- use the universal path the
    //  provider gives back to us. The Daytona code is broken. [Don't think so]

    BYTE abInfoBuffer[UNIVERSAL_NAME_BUFFER_SIZE];
    DWORD dwBufferSize = UNIVERSAL_NAME_BUFFER_SIZE;

    if ((DRIVE_REMOTE == ulDriveType) &&
        (WN_SUCCESS == OleWNetGetUniversalName(lpszIn, UNIVERSAL_NAME_INFO_LEVEL,
                                            abInfoBuffer, &dwBufferSize)))
    {
        UNIVERSAL_NAME_INFOW * pUniversalInfo = (UNIVERSAL_NAME_INFOW*)abInfoBuffer;

        int cchPath = lstrlenW ( pUniversalInfo->lpUniversalName );

        // Allocate space to copy the path, including the terminating null
        *lplpszOut = (WCHAR *) PrivMemAlloc(sizeof(WCHAR) * (cchPath + 1));

        if( *lplpszOut == NULL )
        {
            hr = ResultFromScode(E_OUTOFMEMORY);
            goto errRet;
        }

        memcpy(*lplpszOut, pUniversalInfo->lpUniversalName,
               (cchPath + 1) * sizeof(WCHAR));

        FindUNCEndServer ( *lplpszOut, pEndServer );
    }

# else

    BYTE abInfoBuffer[REMOTE_NAME_BUFFER_SIZE];
    LPREMOTE_NAME_INFO pRemoteNameInfo;
    DWORD dwBufferSize;
    int cchConnectionName;
    int cchRemainingPath;

    //
    // If this is a remote drive, attempt to get the UNC path that maps
    // to it.
    //

    pRemoteNameInfo = (LPREMOTE_NAME_INFO) abInfoBuffer;
    dwBufferSize = REMOTE_NAME_BUFFER_SIZE;

    if ((DRIVE_REMOTE == ulDriveType) &&
        (WN_SUCCESS == OleWNetGetUniversalName(lpszIn, REMOTE_NAME_INFO_LEVEL,
                                            pRemoteNameInfo, &dwBufferSize)))
    {
        //  Got it
        cchConnectionName = lstrlenW(pRemoteNameInfo->lpConnectionName);
        cchRemainingPath = lstrlenW(pRemoteNameInfo->lpRemainingPath);

        //
        // Make sure we aren't about to create a path that is too large.
        //

        if ((cchConnectionName + cchRemainingPath + 1) > MAX_PATH)
        {
            hr = MK_E_SYNTAX;
            goto errRet;
        }

        // Allocate room for the concatenated string. The length of the
        // buffer is the length of the remote name, plus the length of the
        // remaining path, plus room for a terminating NULL.

        *lplpszOut = (WCHAR *)
            PrivMemAlloc(sizeof(WCHAR) * (cchConnectionName + cchRemainingPath + 1));

        if( !*lplpszOut )
        {
            hr = ResultFromScode(E_OUTOFMEMORY);
            goto errRet;
        }

        memcpy(*lplpszOut, pRemoteNameInfo->lpConnectionName,
               cchConnectionName * sizeof(WCHAR));
        memcpy(*lplpszOut + cchConnectionName, pRemoteNameInfo->lpRemainingPath,
               (cchRemainingPath + 1) * sizeof(WCHAR));

        //
        // EndServer is the offset to the start of the 'path'. It should point at the
        // first backslash
        //

        *pEndServer = (USHORT) cchConnectionName;
    }
#endif
    else
    {
#if DBG==1
        if (DRIVE_REMOTE == ulDriveType)
        {
            mnkDebugOut((DEB_ITRACE,
                        "Local drive or WNetGetUniversalName failed - %ld\n",
                        GetLastError()));
        }
#endif

        //
        // There was no UNC form of this path. Set the output pointer to be
        // NULL
        //

        // NOTE:
        //
        // This would be a very good place to determine if the given path
        // has a UNC equivalent, even if it is a local drive.
        //

        *lplpszOut = NULL;
        *pEndServer = DEF_ENDSERVER;
    }
errRet:

#endif  // !_CHICAGO_
    mnkDebugOut((DEB_ITRACE,
                 "%p OUT ExpandUNCName (%lx) [%ws, %d]\n",
                 NULL, hr, *lplpszOut ? *lplpszOut : L"<NULL>",
                 *pEndServer));
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   CreateFileMoniker
//
//  Synopsis:   Creates a FileMoniker
//
//  Effects:
//
//  Arguments:  [lpszPathName] -- Path to create moniker to
//              [ppmk] --         Output moniker interface pointer
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-11-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateFileMoniker ( LPCWSTR lpszPathName, LPMONIKER FAR * ppmk )
{
    OLETRACEIN((API_CreateFileMoniker, PARAMFMT("lpszPathName= %ws, ppmk= %p"),
                        lpszPathName, ppmk));

    mnkDebugOut((DEB_TRACE,
                 "CreateFileMoniker(%ws)\n",
                 lpszPathName?lpszPathName:L"<NULL PATH>"));

    HRESULT hresult = NOERROR;
    CFileMoniker FAR * pCFM = NULL;

    USHORT endServer = DEF_ENDSERVER;
    *ppmk = NULL;
    LPWSTR lpsz = NULL;
    WCHAR szBuffer[MAX_PATH];
    LPWSTR pszBuffer = szBuffer;
    ULONG  bufferLength = MAX_PATH;
    ULONG  pathLength;
    LPOLESTR posPath;

    if (NULL == lpszPathName)
    {
        return MK_E_SYNTAX;
    }

    VDATEPTROUT_LABEL(ppmk,LPMONIKER, errNoHookRet, hresult);
    VDATEPTRIN_LABEL(lpszPathName,WCHAR, errNoHookRet, hresult);


    //
    // If this is an absolute path, then create as strong of a link to it
    // that we can. If not, then its relative, just use the name.
    //

    if ( IsAbsoluteNonUNCPath(lpszPathName))
    {
        mnkDebugOut((DEB_ITRACE,
                     "CreateFileMoniker(%ws) Is absolute path\n",
                     lpszPathName?lpszPathName:L"<NULL PATH>"));

        //
        // GetFullPathName resolves, using the current directory and drive,
        // the path into as much of a normal form as possible
        //

        LPWSTR pszFilePart;

        pathLength = GetFullPathName(lpszPathName, bufferLength, pszBuffer, &pszFilePart);
        if(pathLength > bufferLength)
        {
            //The buffer is too small.  Allocate a new buffer.
            pszBuffer = (LPWSTR) alloca(pathLength * sizeof(WCHAR));
            if(pszBuffer)
            {
                bufferLength = pathLength;
                pathLength = GetFullPathName(lpszPathName, bufferLength, pszBuffer, &pszFilePart);
            }
            else
            {
                hresult = E_OUTOFMEMORY;
                goto errRet;
            }
        }

        if (0 == pathLength || pathLength > bufferLength)
        {
            hresult = MK_E_SYNTAX;
            goto errRet;
        }

        //
        // We now demand to have a drive based path.
        //

        if (*(pszBuffer + 1) != ':')
        {
            hresult = MK_E_SYNTAX;
            goto errRet;
        }

        Assert(*(pszBuffer + 1) == ':');

        hresult = ExpandUNCName(pszBuffer, &lpsz, &endServer);


        mnkDebugOut((DEB_ITRACE,
                     "CreateFileMoniker(%ws) Expanded name (%ws)\n",
                     lpszPathName?lpszPathName:L"<NULL PATH>",
                     lpsz?lpsz:pszBuffer));

        if (hresult != NOERROR)
        {
            goto errRet;
        }

        posPath = lpsz ? lpsz : pszBuffer;
    }
    else
    {
        //
        // If this is a UNC path, then we need to set the
        // m_endServer variable. Otherwise, it defaults to DEF_ENDSERVER
        //
        mnkDebugOut((DEB_ITRACE,
                     "CreateFileMoniker(%ws) Is relative path\n",
                     lpszPathName?lpszPathName:L"<NULL PATH>"));


        FindUNCEndServer(lpszPathName, &endServer);
        posPath = (LPOLESTR)lpszPathName;
    }


    // Now that we have a path, expand each component into its long
    // form so that monikers create with short names equal their
    // long name equivalents
    // This only works for files that exist, so if it fails
    // simply use the given path

    // Special case zero-length paths since the length returns from
    // GetLongPathName become ambiguous when zero characters are processed
    if (posPath[0])
    {
        // Attempt to build the long path on the stack
        pathLength = InternalGetLongPathNameW(posPath, pszBuffer, bufferLength);

        if(pathLength > bufferLength)
        {
            //The buffer is too small.  Allocate a new buffer.
            pszBuffer = (LPWSTR) alloca(pathLength * sizeof(WCHAR));
            if(pszBuffer)
            {
                bufferLength = pathLength;
                pathLength = InternalGetLongPathNameW(posPath, pszBuffer, bufferLength);
            }
            else
            {
                hresult = E_OUTOFMEMORY;
                goto errRet;
            }
        }

        if (pathLength > 0 && pathLength < bufferLength)
        {
            mnkDebugOut((DEB_ITRACE, "CreateFileMoniker: "
                         "Lengthened '%ws' to '%ws'\n",
                         posPath, pszBuffer));
            posPath = pszBuffer;
        }
    }
    else
    {
        mnkDebugOut((DEB_ITRACE, "CreateFileMoniker: No long path for '%ws'\n",
                     posPath));
    }

    pCFM = CFileMoniker::Create(posPath,
                                0,
                                endServer);

    if (lpsz != NULL)
    {
        PrivMemFree(lpsz);
    }

    if (!pCFM)
    {
        hresult = E_OUTOFMEMORY;
        goto errRet;
    }

    *ppmk = (LPMONIKER)pCFM;

errRet:

    CALLHOOKOBJECTCREATE(hresult, CLSID_FileMoniker, IID_IMoniker, (IUnknown **)ppmk);  //  HOOKOLE

errNoHookRet:
    OLETRACEOUT((API_CreateFileMoniker, hresult));

    return hresult;
}





#ifdef _CAIRO_

//+---------------------------------------------------------------------------
//
//  Function:   CreateFileMonikerEx
//
//  Synopsis:   Creates a tracking FileMoniker.
//
//  Effects:
//
//  Arguments:  [DWORD] dwTrackFlags
//                -- Tracking flags ("TRACK_*").
//              [LPCWSTR] lpszPathName
//                -- Path to which to create the moniker.
//              [LPMONIKER FAR *] pmk
//                -- Output moniker interface pointer.
//
//  Requires:
//
//  Returns:    [HRESULT]
//
//  Signals:    None.
//
//  Modifies:   None.
//
//  Algorithm:  Create a FileMoniker, and initializes the tracking
//              state.
//
//  History:    9-20-95 MikeHill    Created
//
//  Notes:      This function was added to extend the CreateFileMoniker
//              API for the newer tracking file monikers.  This allows
//              the caller to configure the tracking algorithm (with the
//              dwTrackFlags) at creation time.
//
//----------------------------------------------------------------------------

STDAPI CreateFileMonikerEx (DWORD dwTrackFlags,
                            LPCWSTR lpszPathName,
                            LPMONIKER FAR * ppmk )
{

    OLETRACEIN((API_CreateFileMoniker, PARAMFMT("lpszPathName= %ws, ppmk= %p"),
                        lpszPathName, ppmk));


    mnkDebugOut( (DEB_TRACE,
                 "CreateFileMonikerEx(%ws)\n",
                 lpszPathName?lpszPathName:L"<NULL PATH>"));


    HRESULT hresult = E_FAIL;

    VDATEPTROUT_LABEL(ppmk,LPMONIKER, errNoHookRet, hresult);
    VDATEPTRIN_LABEL(lpszPathName,WCHAR, errNoHookRet, hresult);

    *ppmk = NULL;


    // Create a default (i.e. non-tracking) File Moniker.

    if( FAILED( hresult = CreateFileMoniker( lpszPathName,
                                             ppmk ))
      )
    {
        goto errRet;
    }
    Assert( *ppmk != NULL );

    // Perform the tracking-related initialization of this moniker.
    // Note that the Track Flags are piggy-backed onto the
    // EnableTracking routine's OT flags.

    hresult = ( (CFileMoniker *) *ppmk)->EnableTracking( NULL,
                                                         TRACK_2_OT_FLAGS( dwTrackFlags )
                                                         |
                                                         OT_MAKETRACKING
                                                       );

    if( FAILED( hresult ))
    {
      goto errRet;
    }

    //  ----
    //  Exit
    //  ----

errRet:

    // Return S_OK unless there was an error.  (Word considers everything
    // except S_OK to be fatal).

    hresult = SUCCEEDED( hresult ) ? S_OK : hresult;

    CALLHOOKOBJECTCREATE(hresult, CLSID_FileMoniker, IID_IMoniker, (IUnknown **)ppmk);  //  HOOKOLE

errNoHookRet:
    OLETRACEOUT((API_CreateFileMoniker, hresult));

    return hresult;

} // CreateFileMonikerEx

#endif  // _CAIRO_


//+---------------------------------------------------------------------------
//
//  Function:   CreateOle1FileMoniker
//
//  Synopsis:   Creates a FileMoniker
//
//  Effects:
//
//  Arguments:  [lpszPathName] -  Path to create moniker to
//              [rclsidOle1]   -  Ole1 clsid
//              [ppmk]         -  Output moniker interface pointer
//
//  Returns:    HRESULT
//
//
//  Algorithm:
//
//  History:    01-Aug-95  BruceMa  Added this header
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
STDAPICALLTYPE
CreateOle1FileMoniker ( LPWSTR lpszPathName,
                        REFCLSID rclsidOle1,
                        LPMONIKER FAR * ppmk)
{
    CFileMoniker FAR * pCFM;
    HRESULT hr;

    hr = CreateFileMoniker( lpszPathName, (LPMONIKER FAR *)&pCFM);

    *ppmk = pCFM;           // this nulls *ppmk in case of error

    if (hr == NOERROR)
    {
        pCFM->m_ole1 = CFileMoniker::ole1;
            pCFM->m_clsid = rclsidOle1;
        pCFM->m_fClassVerified = TRUE;

    }

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   CreateAntiMoniker
//
//  Synopsis:   Creates a anti moniker
//
//  Effects:
//
//  Arguments:  [ppmk] -  Path to create moniker to
//
//  Returns:    HRESULT
//
//
//  Algorithm:
//
//  History:    01-Aug-95  BruceMa  Added this header
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CAntiMonikerCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    // validated by the standard class factory
    Win4Assert(pUnkOuter == NULL);
    return CreateAntiMoniker((IMoniker **)ppv);
}

STDAPI CreateAntiMoniker (LPMONIKER FAR* ppmk)
{
    CAntiMoniker FAR* pCAM;
    HRESULT hr;

    OLETRACEIN((API_CreateAntiMoniker, PARAMFMT("ppmk= %p"), ppmk));

    VDATEPTROUT_LABEL(ppmk, LPMONIKER, errRtn, hr);

    *ppmk = NULL;
    pCAM = CAntiMoniker::Create();

    if (pCAM != NULL)
    {
        *ppmk = pCAM;
        CALLHOOKOBJECTCREATE(S_OK,CLSID_AntiMoniker,IID_IMoniker,(IUnknown **)ppmk);
        hr = NOERROR;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

errRtn:
    OLETRACEOUT((API_CreateAntiMoniker, hr));

    return hr;
}








//+---------------------------------------------------------------------------
//
//  Function:   CreateBindCtx
//
//  Synopsis:   Creates a bind context
//
//  Effects:
//
//  Arguments:  [reserved] -  Reserved for future expansion
//              [ppbc]     -  Where to place the created bnind context
//
//  Returns:    HRESULT
//
//
//  Algorithm:
//
//  History:    01-Aug-95  BruceMa  Added this header
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateBindCtx ( DWORD reserved, LPBC FAR * ppbc )
{
    HRESULT hr;

    OLETRACEIN((API_CreateBindCtx, PARAMFMT("reserved= %x, ppbc= %p"), reserved, ppbc));

    VDATEPTROUT_LABEL(ppbc, LPBC, errRtn, hr);

    if(reserved != 0)
    {
        return E_INVALIDARG;
    }

    *ppbc = CBindCtx::Create();

    if (*ppbc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto errRtn;
    }

    CALLHOOKOBJECTCREATE(S_OK,CLSID_PSBindCtx,IID_IBindCtx,(IUnknown **)ppbc);
    hr = NOERROR;

errRtn:
    OLETRACEOUT((API_CreateBindCtx, hr));

    return hr;
}






//+---------------------------------------------------------------------------
//
//  Function:   CreatePointerMoniker
//
//  Synopsis:   Creates a pointer moniker
//
//  Effects:
//
//  Arguments:  [punk]         -  Pointer being wrappaed
//              [ppmk]         -  Output moniker interface pointer
//
//  Returns:    HRESULT
//
//
//  Algorithm:
//
//  History:    01-Aug-95  BruceMa  Added this header
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CPointerMonikerCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    // validated by the standard class factory
    Win4Assert(pUnkOuter == NULL);
    return CreatePointerMoniker(NULL, (IMoniker **)ppv);
}

STDAPI CreatePointerMoniker (LPUNKNOWN punk, LPMONIKER FAR* ppmk)
{
    OLETRACEIN((API_CreatePointerMoniker, PARAMFMT("punk= %p, ppmk= %p"),
                        punk, ppmk));

    HRESULT hresult;
    CPointerMoniker FAR* pCPM;

    VDATEPTROUT_LABEL(ppmk, LPMONIKER, errRtn, hresult);
    *ppmk = NULL;

    // When unmarshaling a remoted pointer moniker punk is initially NULL
    if (punk)
    {
        VDATEIFACE_LABEL(punk, errRtn, hresult);
    }

    pCPM = CPointerMoniker::Create(punk);
    if (pCPM)
    {
        *ppmk = pCPM;
        CALLHOOKOBJECTCREATE(S_OK,CLSID_PointerMoniker,IID_IMoniker,(IUnknown **)ppmk);
        hresult = NOERROR;
    }
    else
    {
        hresult = E_OUTOFMEMORY;
    }

errRtn:
    OLETRACEOUT((API_CreatePointerMoniker, hresult));

    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateObjrefMoniker
//
//  Synopsis:   Creates an objref moniker
//
//  Effects:
//
//  Arguments:  [punk]         -  object being referenced
//              [ppmk]         -  Output moniker interface pointer
//
//  Returns:    HRESULT
//
//
//  Algorithm:
//
//  History:    04-Apr-97  ronans Added objref moniker support
//
//  Notes:
//
//----------------------------------------------------------------------------

STDAPI CreateObjrefMoniker (LPUNKNOWN punk, LPMONIKER FAR* ppmk)
{
//    OLETRACEIN((API_CreateObjrefMoniker, PARAMFMT("punk= %p, ppmk= %p"),
//                       punk, ppmk));

    HRESULT hresult;
    CObjrefMoniker FAR* pCORM;

    VDATEPTROUT_LABEL(ppmk, LPMONIKER, errRtn, hresult);
    *ppmk = NULL;

    // When unmarshaling a remoted objref moniker punk is initially NULL
    if (punk)
    {
        VDATEIFACE_LABEL(punk, errRtn, hresult);
    }

    pCORM = CObjrefMoniker::Create(punk);
    if (pCORM )
    {
        *ppmk = pCORM ;
        CALLHOOKOBJECTCREATE(S_OK,CLSID_ObjrefMoniker,IID_IMoniker,(IUnknown **)ppmk);
        hresult = NOERROR;
    }
    else
    {
        hresult = E_OUTOFMEMORY;
    }

errRtn:
    //OLETRACEOUT((API_CreateObjrefMoniker, hresult));

    return hresult;
}




//+---------------------------------------------------------------------------
//
//  Function:   OleLoadFromStream
//
//  Synopsis:   Load a moniker from a stream and QI for the
//              requested interface
//
//  Effects:
//
//  Arguments:  [pStm]         -  The stream to load from
//              [iidInterface] -  The requested interface
//              [ppvObj]       -  Output moniker interface pointer
//
//  Returns:    HRESULT
//
//
//  Algorithm:
//
//  History:    01-Aug-95  BruceMa  Added this header
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleLoadFromStream ( LPSTREAM pStm, REFIID iidInterface,
    LPVOID FAR* ppvObj)
{
    OLETRACEIN((API_OleLoadFromStream, PARAMFMT("pStm= %p, iidInterface= %I"),
                pStm, &iidInterface));

    //  Assumptions:  The name of the object class is in the stream,
    //  as a length-prefixed string.
    HRESULT         hresult = NOERROR;
    CLSID               cid;
    LPPERSISTSTREAM pPS;
    LPUNKNOWN       pUnk;

    VDATEPTROUT_LABEL(ppvObj,LPVOID, errRtn, hresult);
    *ppvObj = NULL;
    VDATEIID_LABEL(iidInterface, errRtn, hresult);
    VDATEIFACE_LABEL(pStm, errRtn, hresult);


    if ((hresult = ReadClassStm(pStm, &cid)) != NOERROR)
        goto errRtn;

    hresult = CoCreateInstance(cid, NULL,
        CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        iidInterface,
        (LPVOID FAR *) &pUnk);
    if (hresult)
        goto errRtn;
    hresult = pUnk->QueryInterface(IID_IPersistStream,
        (LPVOID FAR*) &pPS);
    if (!hresult)
    {
        hresult = pPS->Load( pStm );
        pPS->Release();
    }
    if (!hresult)
        hresult = pUnk->QueryInterface(iidInterface, ppvObj );
    pUnk->Release();

errRtn:
    OLETRACEOUT((API_OleLoadFromStream, hresult));

    return hresult;
}








//+---------------------------------------------------------------------------
//
//  Function:   OleSaveToStream
//
//  Synopsis:   Given an IPersistStream on a moniker, save that moniker
//              to a stream
//
//  Effects:
//
//  Arguments:  [pPStm]        -  IPersistStream pointer
//              [pStm]         -  Stream to save the moniker to
//
//  Returns:    HRESULT
//
//
//  Algorithm:
//
//  History:    01-Aug-95  BruceMa  Added this header
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleSaveToStream ( LPPERSISTSTREAM pPStm, LPSTREAM pStm)
{
    OLETRACEIN((API_OleSaveToStream, PARAMFMT("pPStm= %p, pStm= %p"),
                pPStm, pStm));

    HRESULT hresult = 0;
    CLSID   clsid;

    VDATEIFACE_LABEL(pPStm, errRtn, hresult);
    VDATEIFACE_LABEL(pStm, errRtn, hresult);


    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IPersistStream,(IUnknown **)&pPStm);
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)&pStm);


    if (!pPStm)
    {
        hresult = ResultFromScode(OLE_E_BLANK);
        goto errRtn;
    }

    if (hresult = pPStm->GetClassID(&clsid))
        goto errRtn;

    if ((hresult = WriteClassStm(pStm, clsid)) != NOERROR)
        goto errRtn;

    hresult = pPStm->Save(pStm, TRUE);

errRtn:
    OLETRACEOUT((API_OleSaveToStream, hresult));

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Parse10DisplayName    private
//
//  Synopsis:   Parse a ProgId string as an ole 1.0 file moniker
//
//  Arguments:  [pbc]                   -       Bind context
//              [pszDisplayName]        -       Display name
//              [pcchEaten]             -       Number of characters eaten
//              [ppmk]                  -       Moniker of running object
//                                              if successful, otherwise NULL
//
//  Returns:
//
//  Algorithm:  This routine is being rewritten for performance, hence the
//
//  History:    20-Jul-95 BruceMa   Added this header and cleaned up
//
//----------------------------------------------------------------------------
STDAPI Parse10DisplayName(REFCLSID   clsid,
                          LPCWSTR    szDisplayName,
                          ULONG     *pcchEaten,
                          ULONG      cchEatenSoFar,
                          LPMONIKER *ppmk)
{
    LPCWSTR   pch     = szDisplayName;
    LPMONIKER pmkFile = NULL;
    LPMONIKER pmkItem = NULL;
    HRESULT   hres    = NOERROR;
    size_t    cbFile;

    // Skip past the "file" name, looking for first delimiter character
    // Note: strtok is not DBCS-friendly.
    while (*pch  &&  !wcschr (L"!\"'*+,/;<=>?@[]`|" , *pch))
    {
        IncLpch(pch);
    }

    if (*pch)
    {
        // We hit a delimiter, so there is an item moniker.
        CreateItemMoniker (L"!", (LPWSTR)pch+1, &pmkItem);

        // Copy the "file" part
        LPWSTR szFile = (WCHAR *)
            PrivMemAlloc(sizeof(WCHAR) * (cbFile = (ULONG)(pch - szDisplayName + 1)));
        if (NULL==szFile)
        {
            hres = ResultFromScode (E_OUTOFMEMORY);
            goto errRtn;
        }
        _fmemcpy (szFile, szDisplayName, (cbFile - 1) * sizeof(WCHAR));
        szFile [cbFile - 1] = '\0';

        hres = CreateOle1FileMoniker (szFile, clsid, &pmkFile);
        PrivMemFree(szFile);
        if (hres != NOERROR)
        {
            goto errRtn;
        }
        hres = CreateGenericComposite (pmkFile, pmkItem, ppmk);
    }
    else
    {
        // no Item moniker, just a file
        hres = CreateOle1FileMoniker ((LPWSTR)szDisplayName, clsid, ppmk);
    }

  errRtn:
    if (pmkFile)
    {
        pmkFile->Release();
    }
    if (pmkItem)
    {
        pmkItem->Release();
    }
    *pcchEaten = ((hres==NOERROR) ? lstrlenW (szDisplayName) + cchEatenSoFar : 0);
    return hres;

}
//+---------------------------------------------------------------------------
//
//  Function:   FindProgIdMoniker    private
//
//  Synopsis:   Interpreting a display name as a ProgID, derive a
//              moniker from it
//
//  Arguments:  [pbc]                   -       Bind context
//              [pszDisplayName]        -       Display name to parse
//              [pcchEaten]             -       Number of characters eaten
//              [ppmk]                  -       Moniker of running object
//
//  Returns:    S_OK if successful
//              Another HRESULT otherwise
//
//  Algorithm:  Find largest left-bounded name that corresponds to a
//              valid initial moniker, either of an object currently running
//              and registered in the ROT or of an extant file.  Call
//              IParseDisplayName::ParseDisplayName on the right-part of the
//              display name not yet consumed.
//
//  History:    20-Jul-95 BruceMa   Added this header and cleaned up
//
//----------------------------------------------------------------------------
STDAPI  FindProgIdMoniker(LPBC       pbc,
                          LPCWSTR    pszDisplayName,
                          ULONG     *pcchEaten,
                          LPMONIKER *ppmk)
{
    int                cbProgId;
    LPWSTR             sz = NULL;
    WCHAR const       *pch;
    HRESULT            hres;
    CLSID              cid;
    IParseDisplayName *pPDN;


    // Initialize
    *pcchEaten = 0;
    *ppmk      = NULL;

    //  find the prog id
    pch = pszDisplayName;
    Assert(*pch == '@');
    pch++;
    if (*pch >= '0' && *pch <= '9')
    {
        return ResultFromScode(MK_E_SYNTAX);
    }
    while ((*pch >= '0' && *pch <= '9') || (*pch >= 'a' && *pch <= 'z') ||
           (*pch >= 'A' && *pch <= 'Z') || (*pch == '.'))
    {
        pch++;
    }
    cbProgId = (ULONG) (pch - pszDisplayName);

    sz = (WCHAR *) PrivMemAlloc(sizeof(WCHAR) * cbProgId);
    if (sz == NULL)
    {
        return E_OUTOFMEMORY;
    }
    _fmemcpy(sz, pszDisplayName + 1, (cbProgId - 1) * sizeof(WCHAR));
    sz[cbProgId - 1] = '\0';

    //  prog id string is now in sz
    hres = CLSIDFromProgID(sz, &cid);
    if (hres == NOERROR)
    {
        if (CoIsOle1Class (cid))
        {
            hres = Parse10DisplayName (cid, pch + 1, pcchEaten, cbProgId + 1,
                                       ppmk);
            CairoleAssert(hres!=NOERROR  ||
                          *pcchEaten == (ULONG)lstrlenW(pszDisplayName));
            goto errRet;
        }

        hres = CoGetClassObject(cid,
                                CLSCTX_ALL | CLSCTX_NO_CODE_DOWNLOAD,
                                NULL, IID_IParseDisplayName,
                                (LPVOID *) &pPDN);
        if (hres != NOERROR)
        {
            hres = CoCreateInstance(cid, NULL,
                                    CLSCTX_INPROC | CLSCTX_NO_CODE_DOWNLOAD,
                                    IID_IParseDisplayName,
                                    (LPVOID *) &pPDN);
        }
    }

    if (hres == NOERROR)
    {
        //  Unfortunately, IParseDisplayName's 2nd parameter is
        //  LPOLESTR instead of LPCOLESTR
        hres = pPDN->ParseDisplayName(pbc,
                                      (LPOLESTR) pszDisplayName,
                                      pcchEaten,
                                      ppmk);
        // AssertOutPtrIface(hres, *ppmk);

        pPDN->Release();
    }


errRet:

    if (sz)
    {

        PrivMemFree(sz);
    }

    return hres;
}


//+---------------------------------------------------------------------------
//
//  Function:   MkParseDisplayName    public
//
//  Synopsis:   Attempts to parse the given file moniker "display name" and
//              return the corresponding moniker
//
//  Arguments:  [pbc]                   -       Bind context
//              [pszDisplayName]        -       Display name to parse
//              [pcchEaten]             -       Number of characters eaten
//              [ppmk]                  -       Moniker of running object
//
//  Returns:    S_OK if successful
//              Another HRESULT otherwise
//
//  Algorithm:  Find the largest left-bounded name that corresponds to a
//              valid initial moniker, either of an object currently running
//              and registered in the ROT or of an extant file.  Then call
//              IParseDisplayName::ParseDisplayName on this moniker
//              inductively with the right-part of the display name not
//              yet consumed, composing the current moniker with the result to
//              form the next moniker in the induction
//
//  History:    20-Jul-95 BruceMa   Rewrote
//              22-Feb-96 ShannonC  Added class moniker support.
//
//----------------------------------------------------------------------------
STDAPI  MkParseDisplayName(LPBC       pbc,
                           LPCWSTR    pwszDisplayName,
                           ULONG     *pchEaten,
                           LPMONIKER *ppmk)
{
    HRESULT     hr = MK_E_SYNTAX;
    LPCWSTR     pszRemainder = pwszDisplayName;
    ULONG       cchEaten = 0;
    LONG        cbUneaten;
    LPMONIKER   pmk;
    LPMONIKER   pmkNext;
    LPMONIKER   pmkTemp;

    // Some simple checks
    if (pwszDisplayName == NULL  ||  pwszDisplayName[0] == L'\0')
    {
        return E_INVALIDARG;
    }

    OLETRACEIN((API_MkParseDisplayName,
         PARAMFMT("pbc= %p, pszDisplayName= %ws, pchEaten= %p, ppmk= %p"),
         pbc, pwszDisplayName, pchEaten, ppmk));

    // Trace
    mnkDebugOut((DEB_ITRACE, "In MkParseDisplayName \"%ws\"\n",
                 pwszDisplayName));

    // Validate parameters
    VDATEPTRIN_LABEL(pwszDisplayName, WCHAR, errRet, hr);
    VDATEIFACE_LABEL(pbc, errRet, hr);
    VDATEPTROUT_LABEL(pchEaten, ULONG, errRet, hr);
    VDATEPTROUT_LABEL(ppmk, LPMONIKER, errRet, hr);

    // Call hook ole
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IBindCtx,(IUnknown **)&pbc);

    // Initialize
    *ppmk     = NULL;
    *pchEaten = 0;


    //Find the initial moniker.

    //Parse a session moniker
    hr = FindSessionMoniker(pbc, pwszDisplayName, &cchEaten, &pmk);

    if(MK_E_UNAVAILABLE == hr)
    {
        //Parse a class moniker display name.
        hr = FindClassMoniker(pbc, pwszDisplayName, &cchEaten, &pmk);
    }

    if(MK_E_UNAVAILABLE == hr)
    {
        //Parse a file moniker display name.
        hr = FindFileMoniker(pbc, pwszDisplayName, &cchEaten, &pmk);
    }

    if(FAILED(hr) && (L'@' == pwszDisplayName[0]))
    {
        //Parse the leftmost part of the display name as a ProgID.
        hr = FindProgIdMoniker(pbc, pwszDisplayName, &cchEaten, &pmk);
    }



    // Inductively consume the remainder of the display name.

    // Initialize to loop
    if(SUCCEEDED(hr))
    {
        pszRemainder  += cchEaten;
        cbUneaten     = lstrlenW(pszRemainder);
    }

    // While more display name remains, successively pass the remainder to the
    // current moniker for it to parse
    while (SUCCEEDED(hr) && cbUneaten > 0)
    {
        cchEaten = 0;
        hr = pmk->ParseDisplayName(pbc,
                                   NULL,
                                   (LPOLESTR) pszRemainder,
                                   &cchEaten,
                                   &pmkNext);

        if (SUCCEEDED(hr) && pmkNext != 0)
        {
            hr = pmk->ComposeWith(pmkNext, FALSE, &pmkTemp);
            if(SUCCEEDED(hr))
            {
                pmk->Release();
                pmk = pmkTemp;

                // Update the amount consumed so far
                pszRemainder += cchEaten;
                cbUneaten    -= cchEaten;
            }
            pmkNext->Release();
        }
    }

    *ppmk = pmk;
    *pchEaten = (ULONG) (pszRemainder - pwszDisplayName);

errRet:
   // Trace
    mnkDebugOut((DEB_ITRACE, "Out MkParseDisplayName: %ws",
                 pwszDisplayName));
    OLETRACEOUT((API_MkParseDisplayName, hr));

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   BindMoniker    public
//
//  Synopsis:   Given a moniker, bind to the object it names and
//              QI for the requested interface.
//
//  Arguments:  [pmk]                   -       The moniker
//              [grfOpt]                -       RESERVED (0l)
//              [iidResult]             -       Interface requested
//              [ppvResult]             -       Where to store interface
//
//  Returns:    S_OK if successful
//              Another HRESULT otherwise
//
//  Algorithm:  Create a bind context and call BindToObject on the moniker
//              within that bind context
//
//  History:    20-Jul-95 BruceMa   Rewrote
//
//  Note:       This is simply a convenience function
//
//----------------------------------------------------------------------------
STDAPI BindMoniker (LPMONIKER pmk,
                    DWORD     grfOpt,
                    REFIID    iidResult,
                    LPVOID   *ppvResult)
{
    LPBC    pbc = NULL;
    HRESULT hr;

    OLETRACEIN((API_BindMoniker, PARAMFMT("pmk= %p, grfOpt= %x, iidResult= %I, ppvResult= %p"),
                        pmk, grfOpt, &iidResult, ppvResult));

    // Validate parameters
    VDATEPTROUT_LABEL(ppvResult,LPVOID, errSafeRtn, hr);
    *ppvResult = NULL;
    VDATEIFACE_LABEL(pmk, errSafeRtn, hr);
    VDATEIID_LABEL(iidResult, errSafeRtn, hr);

    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pmk);

    if (grfOpt != 0)
    {
        hr = E_INVALIDARG;
        goto errSafeRtn;
    }

    // Initialize
    *ppvResult = NULL;

    // Create a bind context
    if (FAILED(hr = CreateBindCtx( 0, &pbc)))
    {
        goto errRtn;
    }

    // Bind to the object
    hr = pmk->BindToObject(pbc, NULL, iidResult, ppvResult);

errRtn:
    if (pbc)
    {
        pbc->Release();
    }

    // An ole spy hook
    CALLHOOKOBJECT(hr,CLSID_NULL,iidResult,(IUnknown **)ppvResult);

errSafeRtn:
    OLETRACEOUT((API_BindMoniker, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CoGetObject    public
//
//  Synopsis:   Get the object identified by the display name.
//
//  Arguments:  [pszName]      - Supplies the display name of the object.
//              [pBindOptions] - Supplies the bind options.  May be NULL.
//              [riid]         - Supplies the IID of the requested interface.
//              [ppv]          - Returns interface pointer to the object.
//
//  Returns:    S_OK if successful
//              Another HRESULT otherwise
//
//  Algorithm:  Create a bind context, parse the display name, then bind to
//              the object.
//
//  Note:       This is simply a convenience function.
//
//  History:    22-Feb-96 ShannonC  Created
//
//----------------------------------------------------------------------------
STDAPI CoGetObject(
    LPCWSTR     pszName,
    BIND_OPTS * pBindOptions,
    REFIID      riid,
    void     ** ppv)
{
    HRESULT    hr;
    IBindCtx * pbc;
    IID        iid;

    OLETRACEIN((API_CoGetObject,
               PARAMFMT("%ws, %p, %I, %p"),
               pszName, pBindOptions, &riid, ppv));

    __try
    {
        //Validate parameters.
        *ppv = 0;
        iid = riid;

        //Create a bind context.
        hr = CreateBindCtx(0, &pbc);

        if(SUCCEEDED(hr))
        {
            //Set the bind options.
            if(pBindOptions != 0)
            {
                hr = pbc->SetBindOptions(pBindOptions);
            }

            if(SUCCEEDED(hr))
            {
                IMoniker * pmk = 0;
                ULONG      chEaten = 0;

                //Parse the display name.
                hr = MkParseDisplayName(pbc, pszName, &chEaten, &pmk);
                if(SUCCEEDED(hr))
                {
                    //Bind to the object.
                    hr = pmk->BindToObject(pbc, 0, iid, ppv);
                    pmk->Release();
                }
            }
            pbc->Release();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    CALLHOOKOBJECT(hr, CLSID_NULL, iid, (IUnknown **)ppv);
    OLETRACEOUT((API_CoGetObject, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindClassID    private
//
//  Synopsis:   Parse a display name to get a CLSID.
//
//  Arguments:  [pszDisplayName]        -       Display name to parse
//              [pcchEaten]             -       Number of characters eaten
//              [pClassID]              -       returns the CLSID
//
//  Returns:    S_OK if successful
//              MK_E_SYNTAX
//              E_OUTOFMEMORY
//
//  History:    22-Feb-96 ShannonC  Created
//
//----------------------------------------------------------------------------
STDAPI FindClassID(
    LPCWSTR pszDisplayName,
    ULONG * pcchEaten,
    CLSID * pClassID)
{
    HRESULT            hr = MK_E_SYNTAX;
    WCHAR const       *pch = pszDisplayName;
    ULONG              cchProgID = 0;

    mnkDebugOut((DEB_ITRACE,
                "FindClassID(%ws,%x,%x)\n",
                pszDisplayName, pcchEaten, pClassID));

    *pcchEaten = 0;

    //Check if display name contains ProgID:
    //or {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}:
    while (*pch != '\0' && *pch != ':')
    {
        pch++;
    }

    if(':' == *pch)
    {
        cchProgID = (ULONG) (pch - pszDisplayName);
        pch++;
    }

    //cchProgID has the number of characters in the ProgID or CLSID.
    //pch points to the next character to be parsed.
    if(cchProgID > 1)
    {
        LPWSTR psz;

        //Allocate memory from the stack.
        //This memory is freed automatically on function return.
        psz = (WCHAR *) alloca(sizeof(WCHAR) * cchProgID + sizeof(WCHAR));

        if (psz != 0)
        {
            //Copy the ProgID string.
            memcpy(psz, pszDisplayName, cchProgID * sizeof(WCHAR));

            //Add a zero terminator.
            psz[cchProgID] = '\0';

            //Convert the string to a CLSID.  Note that CLSIDFromString will
            //parse both ProgID strings and {CLSID} strings.
            hr = CLSIDFromString(psz, pClassID);

            if(SUCCEEDED(hr))
            {
                //Calculate the number of characters parsed.
                *pcchEaten = (ULONG) (pch - pszDisplayName);
            }

       }
       else
       {
           hr = E_OUTOFMEMORY;
       }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   FindClassMoniker    private
//
//  Synopsis:   Interpreting a display name as a ProgID, derive a
//              moniker from it.
//
//  Arguments:  [pbc]                   -       Bind context
//              [pszDisplayName]        -       Display name to parse
//              [pcchEaten]             -       Number of characters eaten
//              [ppmk]                  -       Moniker of running object
//
//  Returns:    S_OK if successful
//              MK_E_UNAVAILABLE or the return value from ParseDisplayName.
//
//  Algorithm:  Parse the first part of the display name to get a CLSID.
//              Use the CLSID to create a class moniker.
//
//  History:    22-Feb-96 ShannonC  Created
//
//----------------------------------------------------------------------------
STDAPI FindClassMoniker(
    IBindCtx * pbc,
    LPCWSTR    pszDisplayName,
    ULONG    * pcchEaten,
    IMoniker **ppmk)
{
    HRESULT hr;
    CLSID   classID;
    ULONG   cEaten = 0;

    *ppmk = 0;
    *pcchEaten = 0;

    mnkDebugOut((DEB_ITRACE,
                "FindClassMoniker(%x,%ws,%x,%x)\n",
                pbc, pszDisplayName, pcchEaten, ppmk));

    hr =  FindClassID(pszDisplayName, &cEaten, &classID);

    if(SUCCEEDED(hr))
    {
        IParseDisplayName *pPDN = NULL;
        DWORD dwClassContext;

        dwClassContext = CLSCTX_ALL;

        hr = CoGetClassObject(classID,
                              dwClassContext | CLSCTX_NO_CODE_DOWNLOAD,
                              NULL,
                              IID_IParseDisplayName,
                              (LPVOID *) &pPDN);
        if (FAILED(hr))
        {
            hr = CoCreateInstance(classID,
                                  NULL,
                                  dwClassContext | CLSCTX_NO_CODE_DOWNLOAD,
                                  IID_IParseDisplayName,
                                  (LPVOID *) &pPDN);
        }

        if(SUCCEEDED(hr))
        {
            hr = pPDN->ParseDisplayName(pbc,
                                        (LPOLESTR) pszDisplayName,
                                        pcchEaten,
                                        ppmk);
            pPDN->Release();
            return hr;
        }
    }
    return MK_E_UNAVAILABLE;
}


INTERNAL_(BOOL) RunningMoniker ( LPBINDCTX pbc,
                                 LPWSTR pszFullPath,
                                 USHORT ccFullPath,
                                 ULONG FAR *pcchEaten,
                                 LPMONIKER FAR * ppmk)
{

    mnkDebugOut((DEB_ITRACE,
                 "RunningMoniker szDisplayName(%ws)",
                 WIDECHECK(pszFullPath)));

    WCHAR ch;
    LPWSTR pch;
    HRESULT hresult;
    CFileMoniker FAR * pCFM = NULL;
    LPRUNNINGOBJECTTABLE pRot = NULL;
    BOOL retVal = FALSE;
    *pcchEaten = 0;

    pch = pszFullPath + ccFullPath;

    hresult = pbc->GetRunningObjectTable(&pRot);

    if (hresult != NOERROR) goto errRet;

    while (pch > pszFullPath)
    {
        if (IsFileSystemSeparator(*pch)  ||
            IsItemMonikerSeparator(*pch) ||
            ('\0' == *pch))
        {
            ch = *pch;
            *pch = '\0';
            hresult = CreateFileMoniker( pszFullPath, (LPMONIKER FAR *)&pCFM );
            *pch = ch;

            if(SUCCEEDED(hresult))
            {
                hresult = pRot->IsRunning(pCFM);

                //
                // If found, then pCFM is our return moniker
                //
                if (hresult == S_OK)
                {
                    *ppmk = pCFM;
                    *pcchEaten = (ULONG) (pch - pszFullPath);
                    retVal = TRUE;
                    break;
                }
                else
                {
                    //
                    // This one isn't a match. Release it and try the next smaller
                    // path
                    //

                    pCFM->Release();
                    pCFM = NULL;
                }
            }
        }
        pch--;
    }


errRet:
    if (pRot) pRot->Release();

    return retVal;
}

INTERNAL FindMaximalFileMoniker(LPWSTR pszFullPath,
                                USHORT ccFullPath,
                                ULONG FAR *pcchEaten,
                                LPMONIKER FAR * ppmk)
{
    HRESULT hr = MK_E_SYNTAX;
    WCHAR ch;
    LPWSTR pch;
    DWORD dwAttr;

    *pcchEaten = 0;
    *ppmk = 0;

    pch = pszFullPath + ccFullPath;

    while((pch > pszFullPath) &&
          (MK_E_SYNTAX == hr))
    {
        if (IsFileSystemSeparator(*pch)  ||
            IsItemMonikerSeparator(*pch) ||
            ('\0' == *pch))
        {
            ch = *pch;
            *pch = '\0';

            // Check if this path exists
            dwAttr = GetFileAttributes(pszFullPath);

            // The file exists
            if (dwAttr != 0xffffffff)
            {
                // We fail if we found a directory
                // but not a file.
                if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
                {
                    hr = MK_E_CANTOPENFILE;
                }
                else
                {
                    hr = CreateFileMoniker(pszFullPath, ppmk);
                    if(SUCCEEDED(hr))
                    {
                        *pcchEaten = (ULONG) (pch - pszFullPath);
                    }
                }
            }

            *pch = ch;
        }
        pch--;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   FindFileMoniker
//
//  Synopsis:   Parse a file moniker display name.
//
//  Arguments:  [pbc]                   -       Bind context
//              [pszDisplayName]        -       Display name to parse
//              [pcchEaten]             -       Number of characters eaten
//              [ppmk]                  -       Moniker of running object
//
//  Returns:    S_OK if successful
//              Another HRESULT otherwise
//
//  Algorithm:  Find the largest left-bounded name that corresponds to a
//              valid initial moniker, either of an object currently running
//              and registered in the ROT or of an extant file.
//
//  History:    22-Feb-96 ShannonC  Moved code from MkParseDisplayName.
//
//----------------------------------------------------------------------------
STDAPI  FindFileMoniker(
    LPBC       pbc,
    LPCWSTR    pszDisplayName,
    ULONG     *pcchEaten,
    LPMONIKER *ppmk)
{
    HRESULT hr = E_OUTOFMEMORY;
    USHORT ccPath;
    LPWSTR pszPath;

    ccPath = (USHORT) lstrlenW(pszDisplayName);

    pszPath = (WCHAR *) alloca((ccPath + 1) * sizeof(WCHAR));
    if(pszPath != NULL)
    {
        memcpy(pszPath, pszDisplayName, (ccPath + 1) * sizeof(WCHAR));

        if (RunningMoniker(pbc, pszPath, ccPath, pcchEaten, ppmk))
        {
            hr = S_OK;
        }
        else
        {
            hr = FindMaximalFileMoniker(pszPath, ccPath, pcchEaten, ppmk);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\classmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       classmon.cxx
//
//  Contents:   Implementation of CClassMoniker
//
//  Classes:    CClassMoniker
//
//  Functions:  CreateClassMoniker
//
//  History:    22-Feb-96 ShannonC  Created
//              25-Feb-97 ShannonC  Use AsyncGetClassBits.
//
//----------------------------------------------------------------------------
#include <ole2int.h>
#include <classmon.hxx>
#include <dllhost.hxx>
#include <cfactory.hxx>
#include "mnk.h"

#ifndef OLETRACEIN
#define OLETRACEIN(x)
#endif

#ifndef OLETRACEOUT
#define OLETRACEOUT(x)
#endif

// This needs to be in a public header if it's still used.
// Comes from private\inet\urlmon\download\cdl.h
#define CD_FLAGS_NEED_CLASSFACTORY  0x4

HMODULE                     hUrlMon                       = 0;
ASYNCGETCLASSBITS          *pfnAsyncGetClassBits          = PrivAsyncGetClassBits;
REGISTERBINDSTATUSCALLBACK *pfnRegisterBindStatusCallback = PrivRegisterBindStatusCallback;
REVOKEBINDSTATUSCALLBACK   *pfnRevokeBindStatusCallback   = PrivRevokeBindStatusCallback;

#define REG_BSCB_HOLDER     OLESTR("_BSCB_Holder_")

//+---------------------------------------------------------------------------
//
//  Function:   CreateClassMoniker
//
//  Synopsis:   Creates a class moniker for the specified CLSID.
//
//  Arguments:  [rclsid]  -  Supplies the CLSID of the class.
//              [ppmk]    -  Returns interface pointer of the new moniker.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//----------------------------------------------------------------------------
STDAPI CreateClassMoniker(
    REFCLSID   rclsid,
    IMoniker **ppmk)
{
    HRESULT   hr;
    CLSID     clsid;
    IMoniker *pmk;

    __try
    {
        OLETRACEIN((API_CreateClassMoniker,
                    PARAMFMT("rclsid= %I, ppmk= %p"),
                    &rclsid, ppmk));

        //Validate parameters.
        *ppmk = NULL;
        clsid = rclsid;

        pmk = new CClassMoniker(clsid);

        if (pmk != NULL)
        {
            *ppmk = pmk;
            hr = S_OK;
            CALLHOOKOBJECTCREATE(hr,
                                 CLSID_ClassMoniker,
                                 IID_IMoniker,
                                 (IUnknown **)ppmk);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;

    }

    OLETRACEOUT((API_CreateFileMoniker, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::CClassMoniker
//
//  Synopsis:   Constructor for class moniker.
//
//  Arguments:  rclsid - Supplies the CLSID of the class.
//
//----------------------------------------------------------------------------
CClassMoniker::CClassMoniker(REFCLSID rclsid)
: _cRefs(1),
  _pExtra(NULL),
  _pszCodeBase(NULL),
  _dwFileVersionMS(0),
  _dwFileVersionLS(0)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::CClassMoniker(%x,%I)\n",
                this, &rclsid));

    _data.clsid = rclsid;
    _data.cbExtra = 0;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::~CClassMoniker
//
//  Synopsis:   Constructor for class moniker.
//
//  Arguments:  rclsid - Supplies the CLSID of the class.
//
//----------------------------------------------------------------------------
CClassMoniker::~CClassMoniker()
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::~CClassMoniker(%x)\n",
                this));

    if(_pExtra != NULL)
    {
        PrivMemFree(_pExtra);
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::SetParameters
//
//  Synopsis:   Set the parameters on the class moniker
//
//  Arguments:  pszName -  Name of the parameter.
//              pszValue - Value of the parameter.
//
//----------------------------------------------------------------------------
HRESULT CClassMoniker::SetParameters(
    LPCWSTR pszParameters)
{
    HRESULT hr = S_OK;

    //Free the old data.
    if(_pExtra != NULL)
    {
        PrivMemFree(_pExtra);
        _pExtra = NULL;
    }

     if(pszParameters != NULL)
     {
        _data.cbExtra = lstrlenW(pszParameters) * sizeof(WCHAR) + sizeof(WCHAR);

        //Allocate memory for the extra bytes.
        _pExtra = PrivMemAlloc(_data.cbExtra);

        if(_pExtra != 0)
        {
            memcpy(_pExtra, pszParameters, _data.cbExtra);
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::QueryInterface
//
//  Synopsis:   Gets a pointer to the specified interface.  The class
//              moniker supports the IMarshal, IMoniker, IPersistStream,
//              IPersist, IROTData, and IUnknown interfaces.  The class
//              moniker also supports CLSID_ClassMoniker so that the
//              IsEqual method can directly access the data members.
//
//  Arguments:  [iid] -- the requested interface
//              [ppv] -- where to put the interface pointer
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_NOINTERFACE
//
//  Notes:      Bad parameters will raise an exception.  The exception
//              handler catches exceptions and returns E_INVALIDARG.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::QueryInterface(
    REFIID riid,
    void **ppv)
{
    HRESULT hr;

    __try
    {
        mnkDebugOut((DEB_ITRACE,
                    "CClassMoniker::QueryInterface(%x,%I,%x)\n",
                    this, &riid, ppv));

        //Parameter validation.
        *ppv = NULL;

        if (IsEqualIID(riid, IID_IMarshal))
        {
            AddRef();
            *ppv = (IMarshal *) this;
            hr = S_OK;
        }
        else if (IsEqualIID(riid, IID_IUnknown)
                 || IsEqualIID(riid, IID_IMoniker)
                 || IsEqualIID(riid, IID_IPersistStream)
                 || IsEqualIID(riid, IID_IPersist))
        {
            AddRef();
            *ppv = (IMoniker *) this;
            hr = S_OK;
        }
        else if (IsEqualIID(riid, IID_IROTData))
        {
            AddRef();
            *ppv = (IROTData *) this;
            hr =  S_OK;
        }
        else if (IsEqualIID(riid, CLSID_ClassMoniker))
        {
            AddRef();
            *ppv = (CClassMoniker *) this;
            hr =  S_OK;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::AddRef
//
//  Synopsis:   Increment the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the new reference count
//
//  Notes:      Use InterlockedIncrement to make it multi-thread safe.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassMoniker::AddRef(void)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::AddRef(%x)\n",
                this));

    InterlockedIncrement(&_cRefs);
    return _cRefs;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::Release
//
//  Synopsis:   Decrement the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the remaining reference count
//
//  Notes:      Use InterlockedDecrement to make it multi-thread safe.
//              We use a local variable so that we don't access
//              a data member after decrementing the reference count.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassMoniker::Release(void)
{
    ULONG count = _cRefs - 1;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::Release(%x)\n",
                this));

    if(0 == InterlockedDecrement(&_cRefs))
    {
            delete this;
            count = 0;
    }

    return count;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::GetClassID
//
//  Synopsis:   Gets the class ID of the object.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::GetClassID(
    CLSID *pClassID)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::GetClassID(%x,%x)\n",
                this, pClassID));

    __try
    {

        *pClassID = CLSID_ClassMoniker;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::IsDirty
//
//  Synopsis:   Checks the object for changes since it was last saved.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::IsDirty()
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::IsDirty(%x)\n",
                this));

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::Load
//
//  Synopsis:   Loads a class moniker from a stream
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::Load(
    IStream *pStream)
{
    HRESULT hr;
    ULONG   cbRead;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::Load(%x,%x)\n",
                this, pStream));

    __try
    {
        hr = pStream->Read(&_data, sizeof(_data), &cbRead);

        if(SUCCEEDED(hr))
        {
            if(sizeof(_data) == cbRead)
            {
                if(_data.cbExtra != 0)
                {
                    //Free the old buffer if necessary.
                    if(_pExtra != NULL)
                    {
                        PrivMemFree(_pExtra);
                    }

                    //Allocate buffer and read the extra bytes.
                    _pExtra = PrivMemAlloc(_data.cbExtra);
                    if(_pExtra != NULL)
                    {
                        hr = pStream->Read(_pExtra,
                                           _data.cbExtra,
                                           &cbRead);
                        if(SUCCEEDED(hr))
                        {
                            if(cbRead == _data.cbExtra)
                                hr = S_OK;
                            else
                                hr = STG_E_READFAULT;
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    hr = S_OK;
                }
            }
            else
            {
                hr = STG_E_READFAULT;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::Save
//
//  Synopsis:   Save the class moniker to a stream
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::Save(
    IStream *pStream,
    BOOL     fClearDirty)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::Save(%x,%x,%x)\n",
                this, pStream, fClearDirty));

    __try
    {
        hr = pStream->Write(&_data, sizeof(_data), NULL);
        if(SUCCEEDED(hr) && _pExtra != NULL && _data.cbExtra > 0)
        {
            //Write the extra bytes.
            hr = pStream->Write(_pExtra, _data.cbExtra, NULL);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::GetSizeMax
//
//  Synopsis:   Get the maximum size required to serialize this moniker
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::GetSizeMax(
    ULARGE_INTEGER * pcbSize)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::GetSizeMax(%x,%x)\n",
                this, pcbSize));

    __try
    {
        ULISet32(*pcbSize, sizeof(_data) + _data.cbExtra);
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::BindToObject
//
//  Synopsis:   Bind to the object named by this moniker.
//
//  Notes:  If pmkToLeft is zero, then the class moniker calls
//          AsyncGetClassBits to get the class object.
//
//          If pmkToLeft is non-zero, then the class moniker binds to the
//          IClassActivator interface and then calls
//          IClassActivator::GetClassObject.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::BindToObject (
    IBindCtx *pbc,
    IMoniker *pmkToLeft,
    REFIID    riid,
    void **   ppv)
{
    HRESULT    hr;
    BIND_OPTS2 bindOpts;

    __try
    {
        mnkDebugOut((DEB_ITRACE,
                    "CClassMoniker::BindToObject(%x,%x,%x,%I,%x)\n",
                    this, pbc, pmkToLeft, &riid, ppv));

        //Validate parameters
        *ppv = NULL;

        bindOpts.cbStruct = sizeof(bindOpts);
        hr = pbc->GetBindOptions(&bindOpts);

        if(SUCCEEDED(hr))
        {
            if(bindOpts.cbStruct < sizeof(BIND_OPTS2))
            {
               //Initialize the new BIND_OPTS2 fields
               bindOpts.dwTrackFlags = 0;
               bindOpts.locale = GetThreadLocale();
               bindOpts.pServerInfo = 0;
               bindOpts.dwClassContext = CLSCTX_SERVER;
            }

            if(NULL == pmkToLeft)
            {
                if(!bindOpts.pServerInfo)
                {
                    IUrlMon *pUrlMon = NULL;

                    hr = ApartmentDllGetClassObject(CLSID_UrlMonWrapper,
                                                    IID_IUrlMon,
                                                    (void **) &pUrlMon);
                    if(SUCCEEDED(hr) && pUrlMon)
                    {
                        hr = pUrlMon->AsyncGetClassBits(_data.clsid,
                                                        NULL,
                                                        NULL,
                                                        _dwFileVersionMS,
                                                        _dwFileVersionLS,
                                                        _pszCodeBase,
                                                        pbc,
                                                        bindOpts.dwClassContext,
                                                        riid,
                                                        CD_FLAGS_NEED_CLASSFACTORY);
                    }

                    if(pUrlMon)
                        pUrlMon->Release();
                }

                if(SUCCEEDED(hr) && (hr != MK_S_ASYNCHRONOUS))
                {
                    hr = CoGetClassObject(_data.clsid,
                                          bindOpts.dwClassContext | CLSCTX_NO_CODE_DOWNLOAD,
                                          bindOpts.pServerInfo,
                                          riid,
                                          ppv);
                }
            }
            else
            {
                IClassActivator *pActivate;

                hr = pmkToLeft->BindToObject(pbc,
                                             NULL,
                                             IID_IClassActivator,
                                             (void **) &pActivate);

                if(SUCCEEDED(hr))
                {
                    hr = pActivate->GetClassObject(_data.clsid,
                                                   bindOpts.dwClassContext,
                                                   bindOpts.locale,
                                                   riid,
                                                   ppv);

                    pActivate->Release();
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::BindToStorage
//
//  Synopsis:   Bind to the storage for the object named by the moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::BindToStorage(
    IBindCtx *pbc,
    IMoniker *pmkToLeft,
    REFIID    riid,
    void **   ppv)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::BindToStorage(%x,%x,%x,%I,%x)\n",
                this, pbc, pmkToLeft, &riid, ppv));

    hr = BindToObject(pbc, pmkToLeft, riid, ppv);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::Reduce
//
//  Synopsis:   Reduce the moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::Reduce(
    IBindCtx *  pbc,
    DWORD       dwReduceHowFar,
    IMoniker ** ppmkToLeft,
    IMoniker ** ppmkReduced)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::Reduce(%x,%x,%x,%x,%x)\n",
                this, pbc, dwReduceHowFar, ppmkToLeft, ppmkReduced));

    __try
    {
        //Validate parameters.
        *ppmkReduced = NULL;

        AddRef();
        *ppmkReduced = (IMoniker *) this;
        hr = MK_S_REDUCED_TO_SELF;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::ComposeWith
//
//  Synopsis:   Compose another moniker onto the end of this moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::ComposeWith(
    IMoniker * pmkRight,
    BOOL       fOnlyIfNotGeneric,
    IMoniker **ppmkComposite)
{
    HRESULT   hr;
    IMoniker *pmk;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::ComposeWith(%x,%x,%x,%x)\n",
                this, pmkRight, fOnlyIfNotGeneric, ppmkComposite));

    __try
    {
        //Validate parameters.
        *ppmkComposite = NULL;

        //Check for an anti-moniker
        hr = pmkRight->QueryInterface(CLSID_AntiMoniker, (void **)&pmk);

        if(FAILED(hr))
        {
            //pmkRight is not an anti-moniker.
            if (!fOnlyIfNotGeneric)
            {
                hr = CreateGenericComposite(this, pmkRight, ppmkComposite);
            }
            else
            {
                hr = MK_E_NEEDGENERIC;
            }
        }
        else
        {
            //pmkRight is an anti-moniker.
            pmk->Release();
            hr = S_OK;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::Enum
//
//  Synopsis:   Enumerate the components of this moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::Enum(
    BOOL            fForward,
    IEnumMoniker ** ppenumMoniker)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::Enum(%x,%x,%x)\n",
                this, fForward, ppenumMoniker));

    __try
    {
        *ppenumMoniker = NULL;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::IsEqual
//
//  Synopsis:   Compares with another moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::IsEqual(
    IMoniker *pmkOther)
{
    HRESULT        hr;
    CClassMoniker *pClassMoniker;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::IsEqual(%x,%x)\n",
                this, pmkOther));

    __try
    {
        hr = pmkOther->QueryInterface(CLSID_ClassMoniker,
                                      (void **) &pClassMoniker);

        if(SUCCEEDED(hr))
        {
            if(IsEqualCLSID(_data.clsid,
                            pClassMoniker->_data.clsid))
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }

            pClassMoniker->Release();
        }
        else
        {
            hr = S_FALSE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::Hash
//
//  Synopsis:   Compute a hash value
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::Hash(
    DWORD * pdwHash)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::Hash(%x,%x)\n",
                this, pdwHash));

    __try
    {
        *pdwHash = _data.clsid.Data1;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::IsRunning
//
//  Synopsis:   Determines if the object identified by this moniker is
//              running.  Since we can't search the class table to determine
//              if the object is running, we just return E_NOTIMPL.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::IsRunning(
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    IMoniker * pmkNewlyRunning)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::IsRunning(%x,%x,%x,%x)\n",
                this, pbc, pmkToLeft, pmkNewlyRunning));

    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::GetTimeOfLastChange
//
//  Synopsis:  Returns the time when the object identified by this moniker
//             was changed.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::GetTimeOfLastChange (
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    FILETIME * pFileTime)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::GetTimeOfLastChange(%x,%x,%x,%x)\n",
                this, pbc, pmkToLeft, pFileTime));

    return MK_E_UNAVAILABLE;
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::Inverse
//
//  Synopsis:  Returns the inverse of this moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::Inverse(
    IMoniker ** ppmk)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::Inverse(%x,%x)\n",
                this, ppmk));

    return CreateAntiMoniker(ppmk);
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::CommonPrefixWith
//
//  Synopsis:  Returns the common prefix shared by this moniker and the
//             other moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::CommonPrefixWith(
    IMoniker *  pmkOther,
    IMoniker ** ppmkPrefix)
{
    HRESULT        hr;
    CClassMoniker *pClassMoniker;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::CommonPrefixWith(%x,%x,%x)\n",
                this, pmkOther, ppmkPrefix));

    __try
    {
        //Validate parameters.
        *ppmkPrefix = NULL;

        hr = pmkOther->QueryInterface(CLSID_ClassMoniker,
                                      (void **) &pClassMoniker);

        if(SUCCEEDED(hr))
        {
            if(IsEqualCLSID(_data.clsid,
                            pClassMoniker->_data.clsid))
            {
                AddRef();
                *ppmkPrefix = (IMoniker *) this;
                hr = MK_S_US;
            }
            else
            {
                hr = MK_E_NOPREFIX;
            }

            pClassMoniker->Release();
        }
        else
        {
            hr = MonikerCommonPrefixWith(this, pmkOther, ppmkPrefix);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::RelativePathTo
//
//  Synopsis:  Returns the relative path between this moniker and the
//             other moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::RelativePathTo(
    IMoniker *  pmkOther,
    IMoniker ** ppmkRelPath)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::RelativePathTo(%x,%x,%x)\n",
                this, pmkOther, ppmkRelPath));

    __try
    {
        *ppmkRelPath = NULL;
        hr = MonikerRelativePathTo(this, pmkOther, ppmkRelPath, TRUE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::GetDisplayName
//
//  Synopsis:   Get the display name of this moniker.
//
//  Notes:      Call ProgIDFromClassID to get the ProgID
//              Append a ':' to the end of the string.
//              If no ProgID is available, then use
//              clsid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx;parameters:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::GetDisplayName(
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    LPWSTR   * lplpszDisplayName)
{
    HRESULT hr = E_FAIL;
    LPWSTR pszDisplayName;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::GetDisplayName(%x,%x,%x,%x)\n",
                this, pbc, pmkToLeft, lplpszDisplayName));

    __try
    {
        LPWSTR pszPrefix;
        WCHAR szClassID[37];
        LPWSTR pszParameters = (LPWSTR) _pExtra;

        //Validate parameters.
        *lplpszDisplayName = NULL;


        //Create a display name from the class ID.
        //Get the class ID string.
        wStringFromUUID(_data.clsid, szClassID);

        //Get the prefix
        hr = ProgIDFromCLSID(CLSID_ClassMoniker,
                             &pszPrefix);

        if(SUCCEEDED(hr))
        {
            ULONG  cName;
            cName = lstrlenW(pszPrefix) + 1 + lstrlenW(szClassID);
            if(pszParameters != NULL)
            {
                cName += lstrlenW(pszParameters);
            }
            cName += 2;

            pszDisplayName = (LPWSTR) CoTaskMemAlloc(cName * sizeof(wchar_t));
            if(pszDisplayName != NULL)
            {
                lstrcpyW(pszDisplayName, pszPrefix);
                lstrcatW(pszDisplayName, L":");
                lstrcatW(pszDisplayName, szClassID);
                if(pszParameters != NULL)
                {
                    lstrcatW(pszDisplayName, pszParameters);
                }

                lstrcatW(pszDisplayName, L":");
                *lplpszDisplayName = pszDisplayName;
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            CoTaskMemFree(pszPrefix);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::ParseDisplayName
//
//  Synopsis:   Parse the display name.
//
//  Algorithm:  Call BindToObject to get an IParseDisplayName on the class
//              object.  Call IParseDisplayName::ParseDisplayName on the
//              class object.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::ParseDisplayName (
    IBindCtx *  pbc,
    IMoniker *  pmkToLeft,
    LPWSTR      lpszDisplayName,
    ULONG    *  pchEaten,
    IMoniker ** ppmkOut)
{
    HRESULT            hr;
    IParseDisplayName *pPDN;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::ParseDisplayName(%x,%x,%x,%ws,%x,%x)\n",
                this, pbc, pmkToLeft, lpszDisplayName, pchEaten, ppmkOut));

    __try
    {
        //Validate parameters
        *ppmkOut = NULL;
        *pchEaten = 0;

        hr = BindToObject(pbc,
                          pmkToLeft,
                          IID_IParseDisplayName,
                          (void **) &pPDN);

        if(SUCCEEDED(hr))
        {
            //Register the object with the bind context.
            hr = pbc->RegisterObjectBound(pPDN);
            if(SUCCEEDED(hr))
            {
                //Parse the display name.
                hr = pPDN->ParseDisplayName(pbc,
                                            lpszDisplayName,
                                            pchEaten,
                                            ppmkOut);
            }
            pPDN->Release();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::IsSystemMoniker
//
//  Synopsis:   Determines if this is one of the system supplied monikers.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::IsSystemMoniker(
    DWORD * pdwType)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::IsSystemMoniker(%x,%x)\n",
                this, pdwType));

    __try
    {
        *pdwType = MKSYS_CLASSMONIKER;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::GetComparisonData
//
//  Synopsis:   Get comparison data for registration in the ROT
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::GetComparisonData(
    byte * pbData,
    ULONG  cbMax,
    DWORD *pcbData)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::GetComparisonData(%x,%x,%x,%x)\n",
                this, pbData, cbMax, pcbData));

    __try
    {
        *pcbData = 0;
        if(cbMax >= sizeof(CLSID_ClassMoniker) + sizeof(_data.clsid))
        {
            memcpy(pbData, &CLSID_ClassMoniker, sizeof(CLSID_ClassMoniker));
            pbData += sizeof(CLSID);
            memcpy(pbData, &_data.clsid, sizeof(_data.clsid));
            *pcbData = sizeof(CLSID_ClassMoniker) + sizeof(_data.clsid);
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::GetUnmarshalClass
//
//  Synopsis:   Get the class ID.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::GetUnmarshalClass(
    REFIID  riid,
    LPVOID  pv,
    DWORD   dwDestContext,
    LPVOID  pvDestContext,
    DWORD   mshlflags,
    CLSID * pClassID)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::GetUnmarshalClass(%x,%I,%x,%x,%x,%x,%x)\n",
                this, &riid, pv, dwDestContext, pvDestContext, mshlflags,
                pClassID));

    return GetClassID(pClassID);
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::GetMarshalSizeMax
//
//  Synopsis:   Get maximum size of marshalled moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::GetMarshalSizeMax(
    REFIID riid,
    LPVOID pv,
    DWORD  dwDestContext,
    LPVOID pvDestContext,
    DWORD  mshlflags,
    DWORD *pSize)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::GetMarshalSizeMax(%x,%I,%x,%x,%x,%x,%x)\n",
                this, &riid, pv, dwDestContext, pvDestContext, mshlflags,
                pSize));

    __try
    {
        *pSize =  sizeof(_data) + _data.cbExtra;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::MarshalInterface
//
//  Synopsis:   Marshal moniker into a stream.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::MarshalInterface(
    IStream * pStream,
    REFIID    riid,
    void    * pv,
    DWORD     dwDestContext,
    LPVOID    pvDestContext,
    DWORD     mshlflags)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::MarshalInterface(%x,%x,%I,%x,%x,%x,%x)\n",
                this, pStream, &riid, pv, dwDestContext, pvDestContext,
                mshlflags));

    return Save(pStream, FALSE);
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::UnmarshalInterface
//
//  Synopsis:   Unmarshal moniker from a stream.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::UnmarshalInterface(
    IStream * pStream,
    REFIID    riid,
    void   ** ppv)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::UnmarshalInterface(%x,%x,%I,%x)\n",
                this, pStream, &riid, ppv));

    __try
    {
        //Validate parameters.
        *ppv = NULL;

        hr = Load(pStream);

        if(SUCCEEDED(hr))
        {
            hr = QueryInterface(riid, ppv);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::ReleaseMarshalData
//
//  Synopsis:   Release a marshalled class moniker.
//              Just seek to the end of the marshalled class moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::ReleaseMarshalData(
    IStream * pStream)
{
    HRESULT hr;
    LARGE_INTEGER liSize;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::ReleaseMarshalData(%x,%x)\n",
                this, pStream));

    hr = GetSizeMax((ULARGE_INTEGER *) &liSize);
    if(SUCCEEDED(hr))
    {
        hr = pStream->Seek(liSize, STREAM_SEEK_CUR, NULL);
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::DisconnectObject
//
//  Synopsis:   Disconnect the object.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::DisconnectObject(
    DWORD dwReserved)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::DisconnectObject(%x,%x)\n",
                this, dwReserved));

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Member:     CUrlMonWrapper::QueryInterface
//
//  Synopsis:   The UrlMon wrapper supports IUnknown and IUrlMon.
//
//  Arguments:  [iid]           -- the requested interface
//              [ppvObj]        -- where to put the interface pointer
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_NOINTERFACE
//
//  Notes:      Bad parameters will raise an exception.  The exception
//              handler catches exceptions and returns E_INVALIDARG.
//
//--------------------------------------------------------------------------
STDMETHODIMP CUrlMonWrapper::QueryInterface (REFIID iid, void ** ppv)
{
    HRESULT hr;

    __try
    {
        mnkDebugOut((DEB_TRACE,
                    "CUrlMonWrapper::QueryInterface(%x,%I,%x)\n",
                     this, &iid, ppv));

        if(IsEqualIID(iid,IID_IUnknown) ||
           IsEqualIID(iid,IID_IUrlMon))
        {
            AddRef();
            *ppv = (IUrlMon *) this;
            hr = S_OK;
        }
        else
        {
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CUrlMonWrapper::CUrlMonWrapper
//
//  Synopsis:   Constructor for CUrlMonWrapper.
//
//  Arguments:  void
//
//  Returns:    void
//
//
//--------------------------------------------------------------------------
CUrlMonWrapper::CUrlMonWrapper()
: _cRef(1)
{
    mnkDebugOut((DEB_TRACE,
                 "CUrlMonWrapper::CUrlMonWrapper\n"));
}

//+-------------------------------------------------------------------------
//
//  Member:     CUrlMonWrapper::AddRef
//
//  Synopsis:   Increment the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the new reference count
//
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlMonWrapper::AddRef(void)
{
    mnkDebugOut((DEB_TRACE,
                 "CUrlMonWrapper::AddRef(%x)\n",
                 this));

    InterlockedIncrement(&_cRef);
    return _cRef;
}

//+-------------------------------------------------------------------------
//
//  Member:     CUrlMonWrapper::Release
//
//  Synopsis:   Decrements the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the remaining reference count
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlMonWrapper::Release(void)
{
    ULONG count = _cRef - 1;

    mnkDebugOut((DEB_TRACE,
                 "CUrlMonWrapper::Release(%x)\n",
                 this));

    if(0 == InterlockedDecrement(&_cRef))
    {
        delete this;
        count = 0;
    }
    return count;
}

//+-------------------------------------------------------------------------
//
//  Member:     CUrlMonWrapper::AsyncGetClassBits
//
//  Synopsis:   This wrapper function supports both synchronous and
//              asynchronous operation. In synchronous mode, this
//              function waits in a modal loop for completion of the
//              operation.  In asynchronous mode, the client supplies
//              an IBindStatusCallback.  The function returns
//              immediately with MK_S_ASYNCHRONOUS.  When the operation
//              completes, the client is notified via
//              IBindStatusCallback::OnCompletion.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP CUrlMonWrapper::AsyncGetClassBits(
    REFCLSID  rclsid,
    LPCWSTR   pszMimeType,
    LPCWSTR   pszFileExt,
    DWORD     dwFileVersionMS,
    DWORD     dwFileVersionLS,
    LPCWSTR   pszCodeBase,
    IBindCtx *pBindCtx,
    DWORD     dwClassContext,
    REFIID    riid,
    DWORD     flags)
{
    HRESULT hr;

    mnkDebugOut((DEB_TRACE,
                 "CUrlMonWrapper::AsyncGetClassBits(%I, %s)\n",
                 rclsid, pszCodeBase));

    __try
    {
        if(pBindCtx != NULL)
        {
            IUnknown *punk;

            //Check if an IBindStatusCallback is registered.
            hr = pBindCtx->GetObjectParam(REG_BSCB_HOLDER, &punk);
            if(SUCCEEDED(hr))
            {
                //Asynchronous call with IBindStatusCallback.
                hr = (*pfnAsyncGetClassBits)(rclsid,
                                             pszMimeType,
                                             pszFileExt,
                                             dwFileVersionMS,
                                             dwFileVersionLS,
                                             pszCodeBase,
                                             pBindCtx,
                                             dwClassContext,
                                             NULL,
                                             riid,
                                             flags);
                punk->Release();
            }
            else
            {
                //Synchronous call with bind context.
                CBindStatusCallback *pCallback = new CBindStatusCallback(hr);

                if(pCallback != NULL)
                {
                    if(SUCCEEDED(hr))
                    {
                        IBindStatusCallback * pibsc;
                        // this will give us the progress UI
                        hr = CreateStdProgressIndicator(NULL,
                                                        NULL,
                                                        pCallback,
                                                        &pibsc);
                        if(SUCCEEDED(hr))
                        {
                            hr = (*pfnRegisterBindStatusCallback)(pBindCtx, pibsc, 0, 0);
                            if(SUCCEEDED(hr))
                            {
                                hr = (*pfnAsyncGetClassBits)(rclsid,
                                                             pszMimeType,
                                                             pszFileExt,
                                                             dwFileVersionMS,
                                                             dwFileVersionLS,
                                                             pszCodeBase,
                                                             pBindCtx,
                                                             dwClassContext,
                                                             NULL,
                                                             riid,
                                                             flags);

                                //Wait for completion of the operation.
                                if(hr == MK_S_ASYNCHRONOUS)
                                {
                                    hr = pCallback->Wait(0,30000);
                                }

                                (*pfnRevokeBindStatusCallback)(pBindCtx, pCallback);
                            }
                            pibsc->Release();
                        }
                    }
                    pCallback->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        else
        {
            //Synchronous call without bind context.
            //Create a bind context and make recursive call.
            IBindCtx *pbc;

            hr = CreateBindCtx(0, &pbc);
            if(SUCCEEDED(hr))
            {
                hr = AsyncGetClassBits(rclsid,
                                       pszMimeType,
                                       pszFileExt,
                                       dwFileVersionMS,
                                       dwFileVersionLS,
                                       pszCodeBase,
                                       pbc,
                                       dwClassContext,
                                       riid,
                                       flags);
                pbc->Release();
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   PrivAsyncGetClassBits
//
//  Synopsis:   Loads urlmon.dll and calls AsyncGetClassBits
//
//  Returns:    S_OK, ERROR_MOD_NOT_FOUND
//
//--------------------------------------------------------------------
STDAPI PrivAsyncGetClassBits(
    REFCLSID rclsid,                    // CLSID
    LPCWSTR szTYPE,
    LPCWSTR szExt,
    DWORD dwFileVersionMS,              // CODE=http://foo#Version=a,b,c,d
    DWORD dwFileVersionLS,              // MAKEDWORD(c,b) of above
    LPCWSTR szURL,                      // CODE= in INSERT tag
    IBindCtx *pbc,                      // bind ctx
    DWORD dwClsContext,                 // CLSCTX flags
    LPVOID pvReserved,                  // Must be NULL
    REFIID riid,                        // Usually IID_IClassFactory
    DWORD flags)
{
    HRESULT hr = E_FAIL;

    if(!hUrlMon)
    {
        hUrlMon = LoadLibraryA("urlmon.dll");
    }

    if(hUrlMon != 0)
    {
        void *pfn = GetProcAddress(hUrlMon, "AsyncGetClassBits");
        if(pfn != NULL)
        {
           pfnAsyncGetClassBits = (ASYNCGETCLASSBITS *) pfn;
           hr = (*pfnAsyncGetClassBits)(rclsid,
                                        szTYPE,
                                        szExt,
                                        dwFileVersionMS,
                                        dwFileVersionLS,
                                        szURL,
                                        pbc,
                                        dwClsContext,
                                        pvReserved,
                                        riid,
                                        flags);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   PrivRegisterBindStatusCallback
//
//  Synopsis:   Loads urlmon.dll and calls RegisterBindStatusCallback
//
//  Returns:    S_OK, ERROR_MOD_NOT_FOUND
//
//--------------------------------------------------------------------
STDAPI PrivRegisterBindStatusCallback(
    LPBC pBC,
    IBindStatusCallback *pBSCb,
    IBindStatusCallback**  ppBSCBPrev,
    DWORD dwReserved)
{
    HRESULT hr = E_FAIL;

    if(!hUrlMon)
    {
        hUrlMon = LoadLibraryA("urlmon.dll");
    }

    if(hUrlMon != 0)
    {
        void *pfn = GetProcAddress(hUrlMon, "RegisterBindStatusCallback");
        if(pfn != NULL)
        {
           pfnRegisterBindStatusCallback = (REGISTERBINDSTATUSCALLBACK *) pfn;
           hr = (*pfnRegisterBindStatusCallback)(pBC,
                                                 pBSCb,
                                                 ppBSCBPrev,
                                                 dwReserved);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   PrivRevokeBindStatusCallback
//
//  Synopsis:   Loads urlmon.dll and calls RevokeBindStatusCallback.
//
//  Returns:    S_OK, ERROR_MOD_NOT_FOUND
//
//--------------------------------------------------------------------
STDAPI PrivRevokeBindStatusCallback(
    LPBC pBC,
    IBindStatusCallback *pBSCb)
{
    HRESULT hr = E_FAIL;

    if(!hUrlMon)
    {
        hUrlMon = LoadLibraryA("urlmon.dll");
    }

    if(hUrlMon != 0)
    {
        void *pfn = GetProcAddress(hUrlMon, "RevokeBindStatusCallback");
        if(pfn != NULL)
        {
           pfnRevokeBindStatusCallback = (REVOKEBINDSTATUSCALLBACK *) pfn;
           hr = (*pfnRevokeBindStatusCallback)(pBC, pBSCb);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


// ===========================================================================
//                     CBindStatusCallback Implementation
// ===========================================================================

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::CBindStatusCallback
//
//  Synopsis:   Creates a bind status callback object.
//
//----------------------------------------------------------------------------
CBindStatusCallback::CBindStatusCallback(HRESULT &hr)
: _cRef(1), _hr(MK_S_ASYNCHRONOUS)
{
    _hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if(_hEvent != NULL)
    {
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::~CBindStatusCallback
//
//  Synopsis:   Destructor for CBindStatusCallback object.
//
//----------------------------------------------------------------------------
CBindStatusCallback::~CBindStatusCallback()
{
    if(_hEvent != NULL)
    {
        CloseHandle(_hEvent);
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::QueryInterface
//
//  Synopsis:   Gets an interface pointer to the bind status callback object.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    if(IsEqualIID(riid, IID_IUnknown) ||
       IsEqualIID(riid, IID_IBindStatusCallback))
    {
        AddRef();
        *ppv = (IBindStatusCallback *) this;
    }
    else if(IsEqualIID(riid, IID_ISynchronize))
    {
        AddRef();
        *ppv = (ISynchronize *) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::AddRef
//
//  Synopsis:   Increments the reference count.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBindStatusCallback::AddRef()
{
    InterlockedIncrement((long *) &_cRef);
    return _cRef;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::Release
//
//  Synopsis:   Decrements the reference count.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBindStatusCallback::Release()
{
    LONG count = _cRef - 1;

    if(0 == InterlockedDecrement((long *) &_cRef))
    {
        delete this;
        count = 0;
    }

    return count;
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnStartBinding
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnStartBinding(DWORD grfBSCOption, IBinding* pbinding)
{
    ComDebOut((DEB_ACTIVATE,"CBindStatusCallback::OnStartBinding\n"));
    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetPriority
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::GetPriority(LONG* pnPriority)
{
    ComDebOut((DEB_ACTIVATE,
              "CBindStatusCallback::GetPriority\n"));
    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnLowResource
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    ComDebOut((DEB_ACTIVATE,
              "CBindStatusCallback::OnLowResource\n"));
    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnStopBinding
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR pszError)
{
    ComDebOut((DEB_ACTIVATE,
              "CBindStatusCallback::OnStopBinding hrStatus:%x\n",
              hrStatus));

    _hr = hrStatus;

    Signal();

    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetBindInfo
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    ComDebOut((DEB_ACTIVATE,
              "CBindStatusCallback::GetBindInfo\n"));
    return (NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnDataAvailable
// This function is called whenever data starts arriving. When the file download is
// complete then the BSCF_LASTDATANOTIFICATION comes and you can get the local cached
// File Name.
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnDataAvailable(
    DWORD grfBSCF,
    DWORD dwSize,
    FORMATETC* pfmtetc,
    STGMEDIUM* pstgmed)
 {
    ComDebOut((DEB_ACTIVATE,
              "CBindStatusCallback::OnDataAvailable\n"));
    return(NOERROR);
 }


// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnObjectAvailable
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    ComDebOut((DEB_ACTIVATE,
              "CBindStatusCallback::OnObjectAvailable\n"));
    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnProgress
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnProgress
(
     ULONG ulProgress,
     ULONG ulProgressMax,
     ULONG ulStatusCode,
     LPCWSTR pwzStatusText
)
{
    ComDebOut((DEB_ACTIVATE,
              "CBindStatusCallback::OnProgress %d of %d\n",
              ulProgress,
              (ulProgress > ulProgressMax) ? ulProgress : ulProgressMax));
#if DBG==1
    if(pwzStatusText != NULL)
    {
        int cb = lstrlenW(pwzStatusText) * 2 + 1;
        char *psz = (char *) alloca(cb);
        if(psz != NULL)
        {
            WideCharToMultiByte(CP_ACP, 0, pwzStatusText,-1, psz, cb, 0,0);
            ComDebOut((DEB_ACTIVATE, "%s\n", psz));
        }
    }
#endif
    return(NOERROR);
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::Wait
//
//  Synopsis:   Waits in a message loop for completion of an operation.
//              The message loop dispatches the timer messages required
//              by the urlmon state machine.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::Wait(DWORD dwFlags, DWORD dwMilliseconds)
{
    HRESULT hr;
    DWORD dwWakeReason = WAIT_OBJECT_0 + 1;
    MSG msg;

    while(WAIT_OBJECT_0 + 1 == dwWakeReason)
    {
        //Process the incoming Windows messages.
        while(SSPeekMessage(&msg, NULL, 0, 0, PM_REMOVE) != 0)
        {
            TranslateMessage(&msg);
            SSDispatchMessage(&msg);
        }

        dwWakeReason = MsgWaitForMultipleObjects(1,
                                                 &_hEvent,
                                                 FALSE,
                                                 dwMilliseconds,
                                                 QS_ALLINPUT);
    }

    switch(dwWakeReason)
    {
    case WAIT_OBJECT_0:
        hr = _hr;
        break;

    case WAIT_TIMEOUT:
        hr = RPC_E_TIMEOUT;
        break;

    case 0xFFFFFFFF:
        hr = HRESULT_FROM_WIN32(GetLastError());
        break;

    default:
        hr = E_FAIL;
        break;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::Signal
//
//  Synopsis:   Signal the event.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::Signal()
{
    HRESULT hr = S_OK;

    if(!SetEvent(_hEvent))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::Reset
//
//  Synopsis:   Reset the event.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::Reset()
{
    HRESULT hr = S_OK;

    if(!ResetEvent(_hEvent))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\cmarshal.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       cmarshal.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-27-93   ErikGav   Commented
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "ccompmon.hxx"
#include "mnk.h"

CMarshalImplPStream::CMarshalImplPStream( LPPERSISTSTREAM pPS )
{
    GET_A5();
    m_pPS = pPS;
}



STDMETHODIMP CMarshalImplPStream::QueryInterface (THIS_
    REFIID riid, LPVOID FAR* ppvObj)
{
    M_PROLOG(this);
    *ppvObj = NULL;
    VDATEIID (riid);
    VDATEPTROUT (ppvObj, LPVOID);

    return m_pPS->QueryInterface(riid, ppvObj);
}



STDMETHODIMP_(ULONG) CMarshalImplPStream::AddRef (THIS)
{
    M_PROLOG(this);
    return m_pPS->AddRef();
}



STDMETHODIMP_(ULONG) CMarshalImplPStream::Release (THIS)
{
    M_PROLOG(this);
    return m_pPS->Release();
}


    // *** IMarshal methods ***
STDMETHODIMP CMarshalImplPStream::GetUnmarshalClass(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, CLSID FAR* pCid)
{
    M_PROLOG(this);
    VDATEIID (riid);
    VDATEPTROUT (pCid, CLSID);

    return m_pPS->GetClassID(pCid);
}



STDMETHODIMP CMarshalImplPStream::GetMarshalSizeMax (REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, DWORD FAR* pSize)
{
    ULARGE_INTEGER ularge_integer;

    M_PROLOG(this);
    VDATEIID (riid);
    VDATEPTROUT (pSize, DWORD);

    LPMONIKER pmk;

    HRESULT hres;

    hres = m_pPS->QueryInterface(IID_IMoniker, (LPVOID FAR*)&pmk);
    if (hres == NOERROR)
    {
	CCompositeMoniker *pmkComp = IsCompositeMoniker(pmk);
	if (pmkComp)
	{
       DWORD size ;

       hres = CoGetMarshalSizeMax(pSize, riid, pmkComp->m_pmkLeft,
                  dwDestContext, pvDestContext, mshlflags) ;

       if (hres != NOERROR)
       {
           goto errRet ;
       }

       hres = CoGetMarshalSizeMax(&size, riid, pmkComp->m_pmkRight,
                  dwDestContext, pvDestContext, mshlflags) ;

       if (hres != NOERROR)
       {
           goto errRet ;
       }

	    *pSize += size + sizeof(CLSID);
	    goto errRet;
	}
	else
	{
	    hres = m_pPS->GetSizeMax( &ularge_integer );
	    if (hres == NOERROR)
	    *pSize = ularge_integer.LowPart;
	}
    }
    else
	hres = ResultFromScode(E_FAIL);
errRet:
    if (pmk) pmk->Release();
    return hres;
}

	
	
STDMETHODIMP CMarshalImplPStream::MarshalInterface (IStream FAR* pStm, REFIID riid,
    void FAR* pv, DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags)
{
    M_PROLOG(this);
    VDATEIFACE (pStm);
    VDATEIID (riid);


    LPMONIKER pmk;
    CCompositeMoniker FAR* pmkComp;
    HRESULT hres;

    hres = m_pPS->QueryInterface(IID_IMoniker, (LPVOID FAR*)&pmk);
    if (hres == NOERROR)
    {
    if ((pmkComp = IsCompositeMoniker(pmk)) != NULL)
    {
	//  special code for the composite moniker case
	hres = CoMarshalInterface(pStm, riid, pmkComp->m_pmkLeft, dwDestContext,
	pvDestContext, mshlflags);

	if (hres != NOERROR) goto errRet;

	hres = CoMarshalInterface(pStm, riid, pmkComp->m_pmkRight, dwDestContext,
	pvDestContext, mshlflags);

	if (hres != NOERROR) goto errRet;
    }
    else
	hres = m_pPS->Save(pStm, FALSE);
    }
    else
    hres = ResultFromScode(E_FAIL);
errRet:
    if (pmk) pmk->Release();
    return hres;
}

	
	
STDMETHODIMP CMarshalImplPStream::UnmarshalInterface (IStream FAR* pStm,
    REFIID riid, void FAR* FAR* ppv)
{
    M_PROLOG(this);
    VDATEPTROUT (ppv, LPVOID);
    *ppv = NULL;
    VDATEIFACE (pStm);
    VDATEIID (riid);

    HRESULT hresult;
    LPMONIKER pmk = NULL;
    CCompositeMoniker FAR* pmkComp;

    hresult = m_pPS->QueryInterface(IID_IMoniker, (LPVOID FAR*)&pmk);
    if (hresult == NOERROR)
    {
    if ((pmkComp = IsCompositeMoniker(pmk)) != NULL)
    {
	//  special code for the composite moniker case
	hresult = CoUnmarshalInterface(pStm, IID_IMoniker,
	(LPVOID FAR*)&(pmkComp->m_pmkLeft));
	if (hresult != NOERROR) goto errRet;

	hresult = CoUnmarshalInterface(pStm, IID_IMoniker,
	(LPVOID FAR*)&(pmkComp->m_pmkRight));
	if (hresult != NOERROR) goto errRet;
    }
    else
    {
	hresult = m_pPS->Load(pStm);
    }
    }
    else
    hresult = ResultFromScode(E_FAIL);
    if (hresult == NOERROR)
    {
    hresult = m_pPS->QueryInterface(riid, ppv);
    }
errRet:
    if (pmk)
    pmk->Release();
    return hresult;
}


STDMETHODIMP CMarshalImplPStream::ReleaseMarshalData (IStream FAR* pStm)
{
    M_PROLOG(this);
    return NOERROR;
}


STDMETHODIMP CMarshalImplPStream::DisconnectObject (DWORD dwReserved)
{
    M_PROLOG(this);
    return NOERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\csessmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       csessmon.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-25-98   GilleG    Created
//
//  The purpose of a Session moniker is to active an object on a given
//  session id.
//
//
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include <cbasemon.hxx>
#include <csessmon.hxx>
#include <immact.hxx>
#include "mnk.h"


#define SESSION_MONIKER_NAME L"Session:"
#define SESSION_MONIKER_DELIMITER L"!"
#define CONSOLE_SESSION_TOKEN L"Console"

//+---------------------------------------------------------------------------
//
//  Function:   FindSessionMoniker
//
//  Synopsis:   Interpreting a display name as a SessionID, derive a
//              moniker from it.
//
//  Arguments:  [pbc]                   -       Bind context
//              [pszDisplayName]        -       Display name to parse
//              [pcchEaten]             -       Number of characters eaten
//              [ppmk]                  -       Moniker of running object
//
//  Returns:    S_OK if successful
//              MK_E_UNAVAILABLE or the return value from ParseDisplayName.
//
//  Algorithm:  Parse the first part of the display name to see if it's a
//              session moniker and create a session moniker.
//
//----------------------------------------------------------------------------
STDAPI FindSessionMoniker(
    IBindCtx * pbc,
    LPCWSTR    pszDisplayName,
    ULONG    * pcchEaten,
    IMoniker **ppmk)
{
    HRESULT      hr = S_OK;
    WCHAR*       pwch;
    ULONG        ullength;
    ULONG        ulchcount;
    ULONG        ulSessionID;
    BOOL         bUseConsole;

    mnkDebugOut((DEB_ITRACE,
                "FindSessionMoniker(%x,%ws,%x,%x)\n",
                pbc, pszDisplayName, pcchEaten, ppmk));

    *ppmk = NULL;
    ulchcount = 0;

    ullength = wcslen(SESSION_MONIKER_NAME);

    //
    // We now support two different syntaxes:
    //
    //  "Session:XX" -- where XX is a numeric session id
    //  "Session:Console" -- this means direct the activation to the
    //       currently active TS user session.
    //
    if(_wcsnicmp(pszDisplayName, SESSION_MONIKER_NAME, ullength ) == 0)
    {
        WCHAR* pwchTmp;
        pwch = (LPWSTR)pszDisplayName + ullength;
        ulchcount = ullength;
        
        ullength = wcslen(CONSOLE_SESSION_TOKEN);

        // First look for "Console"
        if (_wcsnicmp(pwch, CONSOLE_SESSION_TOKEN, ullength) == 0) 
        {
            pwchTmp = pwch + ullength;

            if ((*pwchTmp == L'\0') || (*pwchTmp == L'!')) 
            {
                ulchcount += ullength;
                
                if (*pwchTmp == L'!') 
                {
                    ulchcount++;
                }
                
                ulSessionID = 0; // doesn't matter, but init it anyway
                bUseConsole = TRUE;

            } 
            else 
            {
                hr = MK_E_UNAVAILABLE;
                ulchcount = 0;
            }
        } 
        else 
        {
            // else it must be the original syntax

            //
            // verify that we've got a correct session id
            //
            ulSessionID = wcstoul( pwch, &pwchTmp, 10 );
            if ((*pwchTmp == L'\0') || (*pwchTmp == L'!')) 
            {

                ulchcount += (ULONG)((ULONG_PTR)pwchTmp - (ULONG_PTR)pwch)/sizeof(WCHAR);

                if (*pwchTmp == L'!') 
                {
                    ulchcount++;
                }

                bUseConsole = FALSE;  // user was specific

            } 
            else 
            {
                hr = MK_E_UNAVAILABLE;
                ulchcount = 0;
            }
        }
    } 
    else 
    {
        hr = MK_E_UNAVAILABLE;
    }
    
    if (hr == S_OK) 
    {
        CSessionMoniker *pCSM = new CSessionMoniker( ulSessionID, bUseConsole );
        if (pCSM) 
        {
            *ppmk = pCSM;
            hr = S_OK;
        } 
        else 
        {
            hr = E_OUTOFMEMORY;
            ulchcount = 0;                          
        }
    }

    *pcchEaten = ulchcount;

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::QueryInterface
//
//  Synopsis:   Gets a pointer to the specified interface.  The session
//              moniker supports the IMarshal, IMoniker, IPersistStream,
//              IPersist, IROTData, IClassActivator and IUnknown interfaces.
//              The session moniker also supports CLSID_SessionMoniker so that
//              the IsEqual method can directly access the data members.
//
//  Arguments:  [iid] -- the requested interface
//              [ppv] -- where to put the interface pointer
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_NOINTERFACE
//
//  Notes:      Bad parameters will raise an exception.  The exception
//              handler catches exceptions and returns E_INVALIDARG.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::QueryInterface(
    REFIID riid,
    void **ppv)
{
    HRESULT hr;

    __try
    {
        mnkDebugOut((DEB_ITRACE,
                    "CSessionMoniker::QueryInterface(%x,%I,%x)\n",
                    this, &riid, ppv));

        //Parameter validation.
        *ppv = NULL;

        // assume success
        hr = S_OK;

        if (IsEqualIID(riid, IID_IClassActivator))
        {
            AddRef();
            *ppv = (IClassActivator *)this;
        }
        // not supported by the CBaseMoniker::QueryInterface
        else if (IsEqualIID(riid, IID_IPersist))
        {
            AddRef();
            *ppv = (IMoniker *) this;
        }
        else if (IsEqualIID(riid, CLSID_SessionMoniker))
        {
            AddRef();
            *ppv = (CSessionMoniker *) this;
        }
        else
        {
            hr = CBaseMoniker::QueryInterface(riid, ppv);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::GetClassID
//
//  Synopsis:   Gets the class ID of the object.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::GetClassID(
    CLSID *pClassID)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::GetClassID(%x,%x)\n",
                this, pClassID));

    __try
    {

        *pClassID = CLSID_SessionMoniker;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::Load
//
//  Synopsis:   Loads a session moniker from a stream
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::Load(
    IStream *pStream)
{
    HRESULT hr;
    ULONG   cbRead;
    DWORD   sessionid;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::Load(%x,%x)\n",
                this, pStream));

    __try
    {
        hr = pStream->Read(&sessionid, sizeof(sessionid), &cbRead);

        if(SUCCEEDED(hr))
        {
            if(sizeof(sessionid) == cbRead)
            {
                m_sessionid = sessionid;
                hr = S_OK;
            }
            else
            {
                hr = STG_E_READFAULT;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::Save
//
//  Synopsis:   Saves the session moniker to a stream
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::Save(
    IStream *pStream,
    BOOL     fClearDirty)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::Save(%x,%x,%x)\n",
                this, pStream, fClearDirty));

    __try
    {
        hr = pStream->Write(&m_sessionid, sizeof(m_sessionid), NULL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::GetSizeMax
//
//  Synopsis:   Get the maximum size required to serialize this moniker
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::GetSizeMax(
    ULARGE_INTEGER * pcbSize)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::GetSizeMax(%x,%x)\n",
                this, pcbSize));

    __try
    {
        ULISet32(*pcbSize, sizeof(CLSID) + sizeof(m_sessionid));
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::BindToObject
//
//  Synopsis:   Bind to the session specified by this moniker.
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSessionMoniker::BindToObject (
    IBindCtx *pbc,
    IMoniker *pmkToLeft,
    REFIID    riid,
    void **   ppv)
{
    HRESULT    hr;

    __try
    {
        mnkDebugOut((DEB_ITRACE,
                    "CSessionMoniker::BindToObject(%x,%x,%x,%I,%x)\n",
                    this, pbc, pmkToLeft, &riid, ppv));

        //Validate parameters
        *ppv = NULL;


        //
        // This is being called by the ClassMoniker.
        // The actual binding is done in GetClassObject
        //
        if (riid == IID_IClassActivator) 
        {
            m_bindopts2.cbStruct = sizeof(BIND_OPTS2);

            hr = pbc->GetBindOptions(&m_bindopts2);
            if (SUCCEEDED(hr))
            {              
              m_bHaveBindOpts = TRUE;
              AddRef();
              *ppv = (IClassActivator*)this;
            }

        } else {

            hr = E_NOINTERFACE;

        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::BindToStorage
//
//  Synopsis:   Bind to the storage for the session specified by the moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::BindToStorage(
    IBindCtx *pbc,
    IMoniker *pmkToLeft,
    REFIID    riid,
    void **   ppv)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::BindToStorage(%x,%x,%x,%I,%x)\n",
                this, pbc, pmkToLeft, &riid, ppv));

    hr = BindToObject(pbc, pmkToLeft, riid, ppv);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::ComposeWith
//
//  Synopsis:   Compose this moniker with another moniker.
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::ComposeWith(
    IMoniker * pmkRight,
    BOOL       fOnlyIfNotGeneric,
    IMoniker **ppmkComposite)
{
    HRESULT   hr;
    IMoniker *pmk;

    mnkDebugOut((DEB_ITRACE,
          "CSessionMoniker::ComposeWith(%x,%x,%x,%x)\n",
          this, pmkRight, fOnlyIfNotGeneric, ppmkComposite));

    __try
    {
        //Validate parameters.
        *ppmkComposite = NULL;

        //Check for an anti-moniker
        hr = pmkRight->QueryInterface(CLSID_AntiMoniker, (void **)&pmk);

        if(FAILED(hr))
        {
          //pmkRight is not an anti-moniker.
          if (!fOnlyIfNotGeneric)
          {
              hr = CreateGenericComposite(this, pmkRight, ppmkComposite);
          }
          else
          {
              hr = MK_E_NEEDGENERIC;
          }
        }
        else
        {
          //pmkRight is an anti-moniker.
          pmk->Release();
          hr = S_OK;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::IsEqual
//
//  Synopsis:   Compares with another moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::IsEqual(
    IMoniker *pmkOtherMoniker)
{
    HRESULT        hr;
    CSessionMoniker *pSessionMoniker;

    mnkDebugOut((DEB_ITRACE,
                 "CSessionMoniker::IsEqual(%x,pmkOther(%x))\n",
                 this,
                 pmkOtherMoniker));

    __try
    {
        hr = pmkOtherMoniker->QueryInterface(CLSID_SessionMoniker,
                                      (void **) &pSessionMoniker);

        if(SUCCEEDED(hr))
        {
            if( m_sessionid == pSessionMoniker->m_sessionid )
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }

            pSessionMoniker->Release();
        }
        else
        {
            hr = S_FALSE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;

}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::Hash
//
//  Synopsis:   Computes a hash value
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::Hash(
    DWORD * pdwHash)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::Hash(%x,%x)\n",
                this, pdwHash));

    __try
    {
        *pdwHash = m_sessionid;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::GetTimeOfLastChange
//
//  Synopsis:  Returns the time when the object identified by this moniker
//             was changed.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::GetTimeOfLastChange (
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    FILETIME * pFileTime)
{
    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::GetTimeOfLastChange(%x,%x,%x,%x)\n",
                this, pbc, pmkToLeft, pFileTime));

    return MK_E_UNAVAILABLE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::Inverse
//
//  Synopsis:  Returns the inverse of this moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::Inverse(
    IMoniker ** ppmk)
{
    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::Inverse(%x,%x)\n",
                this, ppmk));

    return CreateAntiMoniker(ppmk);
}



//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::CommonPrefixWith
//
//  Synopsis:  Returns the common prefix shared by this moniker and the
//             other moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::CommonPrefixWith(
    IMoniker *  pmkOther,
    IMoniker ** ppmkPrefix)
{
    HRESULT        hr;
    CSessionMoniker *pSessionMoniker;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::CommonPrefixWith(%x,%x,%x)\n",
                this, pmkOther, ppmkPrefix));

    __try
    {
        //Validate parameters.
        *ppmkPrefix = NULL;

        hr = pmkOther->QueryInterface(CLSID_SessionMoniker,
                                      (void **) &pSessionMoniker);

        if(SUCCEEDED(hr))
        {
            if( m_sessionid == pSessionMoniker->m_sessionid )
            {
                AddRef();
                *ppmkPrefix = (IMoniker *) this;
                hr = MK_S_US;
            }
            else
            {
                hr = MK_E_NOPREFIX;
            }

            pSessionMoniker->Release();
        }
        else
        {
            hr = MonikerCommonPrefixWith(this, pmkOther, ppmkPrefix);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::GetDisplayName
//
//  Synopsis:   Get the display name of this moniker.
//
//  Notes:      The name is returned in the format:
//              "Session:3" if the session id is 3.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::GetDisplayName(
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    LPWSTR   * lplpszDisplayName)
{
    HRESULT hr = E_FAIL;
    LPWSTR pszDisplayName;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::GetDisplayName(%x,%x,pmkLeft(%x),%x)\n",
                this, pbc, pmkToLeft, lplpszDisplayName));

    __try
    {
        WCHAR szSessionID[20];
        ULONG cName;

        //Validate parameters.
        *lplpszDisplayName = NULL;

        //Create a display name from the session ID.
        //Get the session ID string.
        wsprintfW( szSessionID, L"%d", m_sessionid );

        cName = lstrlenW(SESSION_MONIKER_NAME) + lstrlenW(szSessionID) +
                lstrlenW(SESSION_MONIKER_DELIMITER) + 2;

        pszDisplayName = (LPWSTR) CoTaskMemAlloc(cName * sizeof(WCHAR));
        if(pszDisplayName != NULL)
        {
            lstrcpyW(pszDisplayName, SESSION_MONIKER_NAME);
            lstrcatW(pszDisplayName, szSessionID);

            lstrcatW(pszDisplayName, SESSION_MONIKER_DELIMITER);
            *lplpszDisplayName = pszDisplayName;
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::ParseDisplayName
//
//  Synopsis:   Parses the display name.
//
//  Algorithm:
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::ParseDisplayName (
    IBindCtx *  pbc,
    IMoniker *  pmkToLeft,
    LPWSTR      lpszDisplayName,
    ULONG    *  pchEaten,
    IMoniker ** ppmkOut)
{
    HRESULT      hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::ParseDisplayName(%x,%x,pmkLeft(%x),lpszDisplayName(%ws),%x,%x)\n",
                this, pbc, pmkToLeft, lpszDisplayName, pchEaten, ppmkOut));

    __try
    {
        //Validate parameters
        *ppmkOut = NULL;
        *pchEaten = 0;

        ULONG chEaten;
        IMoniker* pmkNext;

        //
        // Parse the remaining display name.
        //
        hr = MkParseDisplayName(pbc, lpszDisplayName, &chEaten, &pmkNext);

        if (SUCCEEDED(hr)) {
            *ppmkOut = pmkNext;
            *pchEaten = chEaten;
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::IsSystemMoniker
//
//  Synopsis:   Determines if this is one of the system supplied monikers.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::IsSystemMoniker(
    DWORD * pdwType)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::IsSystemMoniker(%x,%x)\n",
                this, pdwType));

    __try
    {
        *pdwType = MKSYS_SESSIONMONIKER;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::GetComparisonData
//
//  Synopsis:   Gets comparison data for registration in the ROT
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::GetComparisonData(
    byte * pbData,
    ULONG  cbMax,
    DWORD *pcbData)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::GetComparisonData(%x,%x,%x,%x)\n",
                this, pbData, cbMax, pcbData));

    __try
    {
        *pcbData = 0;
        if(cbMax >= sizeof(CLSID_SessionMoniker) + sizeof(m_sessionid))
        {
            memcpy(pbData, &CLSID_SessionMoniker, sizeof(CLSID_SessionMoniker));
            memcpy(pbData + sizeof(CLSID_SessionMoniker), &m_sessionid, sizeof(m_sessionid));
            *pcbData = sizeof(CLSID_SessionMoniker) + sizeof(m_sessionid);
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::GetClassObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::GetClassObject(
    REFCLSID pClassID,
    DWORD dwClsContext,
    LCID locale,
    REFIID riid,
    void** ppv)
{
    HRESULT    hr;

    __try
    {
        mnkDebugOut((DEB_ITRACE,
                    "CSessionMoniker::GetClassObject(%x,%x,%x,%x,%I,%x)\n",
                    this, pClassID, dwClsContext, &locale, &riid, ppv));

        //Validate parameters
        *ppv = NULL;


        CComActivator *pComAct;
        ISpecialSystemProperties *pSSp;

        hr = CoCreateInstance( CLSID_ComActivator,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IStandardActivator,
                               (void **) &pComAct);
        if(SUCCEEDED(hr))
        {
            hr = pComAct->QueryInterface( IID_ISpecialSystemProperties,
                                          (void**) &pSSp );

            if(SUCCEEDED(hr))
            {
                // Pass in TRUE here since we want session moniker-specified 
                // id's to go off-machine:
                hr = pSSp->SetSessionId( m_sessionid, m_bUseConsoleSession, TRUE);

                if(SUCCEEDED(hr))
                {
                    hr = pComAct->StandardGetClassObject( pClassID,
                                                          dwClsContext,
                                                          m_bHaveBindOpts ? m_bindopts2.pServerInfo : NULL,
                                                          riid,
                                                          ppv );
                }

                pSSp->Release();
            }

            pComAct->Release();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\extents.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       extents.cxx
//
//  Contents:   Implmentation for CExtentList
//
//  Classes:	CExtentList
//
//  Functions:
//
//  History:    1-08-94   kevinro   Created
//              31-Jan-95 BruceMa   Set size to 0 if E_OUTOFMEMORY
//              17-Jul-95 BruceMa   Add mutex to protect AddExtent (Cairo only)
//              10-13-95  stevebl   moved mutex to CFileMoniker as part of
//                                  adding general threadsafety to monikers
//
//----------------------------------------------------------------------------
#include <ole2int.h>

#include "extents.hxx"
#include "mnk.h"


CExtentList::CExtentList():
    m_pchMonikerExtents(NULL),
     m_cbMonikerExtents(0)
{
    ;
}
CExtentList::~CExtentList()
{
    if (m_pchMonikerExtents != NULL)
    {
	CoTaskMemFree(m_pchMonikerExtents);
    }


}

//+---------------------------------------------------------------------------
//
//  Method:     CExtentList::Copy
//
//  Synopsis:   Make a copy of a CExtentList
//
//  Effects:
//
//  Arguments:  [newExtent] --	Recieving list
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CExtentList::Copy(CExtentList & newExtent)
{
    newExtent.m_cbMonikerExtents = m_cbMonikerExtents;
    newExtent.m_pchMonikerExtents = (BYTE *) CoTaskMemAlloc(m_cbMonikerExtents);

    if ( newExtent.m_pchMonikerExtents == NULL )
    {
        newExtent.m_cbMonikerExtents = 0;
	return(E_OUTOFMEMORY);
    }

    memcpy(newExtent.m_pchMonikerExtents,
	   m_pchMonikerExtents,
	   m_cbMonikerExtents);

    return(NOERROR);

}

//+---------------------------------------------------------------------------
//
//  Method:     CExtentList::FindExtent
//
//  Synopsis:   Searches the extent list, looking for a matching extent.
//
//  Effects:
//
//  Arguments:  [usKeyValue] --
//
//  Requires:
//
//  Returns:	NULL	not found
//		UNALIGNED POINTER to extent.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//  WARNINGS:
//
//  The pointer returned is not aligned.
//
//  The pointer will become invalide if an extent is added to the block.
//  This falls under the not multi-thread safe category. This is done for
//  efficiency reasons, since we don't ever expect to both add and lookup
//  at the same time.
//
//----------------------------------------------------------------------------
MONIKEREXTENT UNALIGNED *
CExtentList::FindExtent(USHORT usKeyValue)
{
    ULONG ulOffset = 0;

    while(ulOffset < m_cbMonikerExtents)
    {

	MONIKEREXTENT UNALIGNED *pExtent = (MONIKEREXTENT UNALIGNED *)
					  &m_pchMonikerExtents[ulOffset];

	//
	// There had better be enough bytes left to look at! If not, there
	// is some corruption in the extent block. Not much we can do about
	// it, other than return NULL
        // If the end minus the pointer is less than sizeof MONIKEREXTENT
        // we have a problem.

	if( (m_pchMonikerExtents + m_cbMonikerExtents) - ((BYTE*)pExtent ) <
            sizeof(MONIKEREXTENT) )
	{
	    return(NULL);
	}

	//
	// Get the key value from the buffer and compare against what we want.
	// Be careful about alignment here.
	//


	if (pExtent->usKeyValue == usKeyValue )
	{
	    return(pExtent);
	}

	ulOffset += MonikerExtentSize(pExtent);
    }
    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Method:     CExtentList::DeleteExtent
//
//  Synopsis:   Deletes the given extent if it exists.
//
//  Effects:
//
//  Arguments:  [usKeyValue] --
//
//  Requires:
//
//  Returns:	S_OK -- found and deleted.
//              S_FALSE -- not found.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-95   BillMo   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

#ifdef _TRACKLINK_
HRESULT
CExtentList::DeleteExtent(USHORT usKeyValue)
{
    MONIKEREXTENT UNALIGNED *pExtent = FindExtent(usKeyValue);
    BYTE *pbExtent = (BYTE *)pExtent;

    if (pExtent != NULL)
    {
        ULONG cbRemove = MonikerExtentSize(pExtent);
        BYTE * pbFrom = pbExtent + cbRemove;

        MoveMemory(pbExtent,
               pbFrom,
               m_cbMonikerExtents - (pbFrom - m_pchMonikerExtents));

        m_cbMonikerExtents -= cbRemove;
        return(S_OK);
    }
    return(S_FALSE);
}
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CExtentList::AddExtent
//
//  Synopsis:   Adds an extent to the list. This function adds a copy
//		of the data.
//  Effects:
//
//  Arguments:  [pExtent] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CExtentList::AddExtent(MONIKEREXTENT const * pExtent)
{
    //
    // Reallocate the current buffer to make room for the new extent
    // The new extent is appended to the end of the current list.
    //

    ULONG	ulNewSize = m_cbMonikerExtents + MonikerExtentSize(pExtent);
    BYTE *	pchNewBuffer;

    pchNewBuffer =  (BYTE *)CoTaskMemRealloc(m_pchMonikerExtents,ulNewSize);

    if (pchNewBuffer == NULL)
    {
	return(E_OUTOFMEMORY);
    }

    m_pchMonikerExtents = pchNewBuffer;

    //
    // Append new extent
    //

    memcpy(m_pchMonikerExtents + m_cbMonikerExtents,
	   pExtent,
	   MonikerExtentSize(pExtent));

    m_cbMonikerExtents = ulNewSize;

    return(NOERROR);
}

//+---------------------------------------------------------------------------
//
//  Method:     CExtentList::PutExtent
//
//  Synopsis:   Deletes the extent (if it exists) and then adds it back.
//
//  Effects:
//
//  Arguments:  [pExtent] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-15-95   BillMo   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

#ifdef _TRACKLINK_
HRESULT
CExtentList::PutExtent(MONIKEREXTENT const * pExtent)
{
    DeleteExtent(pExtent->usKeyValue);
    return(AddExtent(pExtent));
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   Save
//
//  Synopsis:   Save the extent to a stream
//
//  Effects:    Nice straightforward write of the entire blob to a stream
//
//  Arguments:  [pStm] -- Stream to write to
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CExtentList::Save(IStream * pStm)
{
    HRESULT hr;

    //
    // It must be true that both are zero, or neither is zero
    //

    Assert( ((m_cbMonikerExtents == 0) && (m_pchMonikerExtents == NULL)) ||
    	    ((m_pchMonikerExtents != NULL) && (m_cbMonikerExtents != 0)));

    //
    // First, write the length, then write the blob
    //
    hr = pStm->Write((void *)&m_cbMonikerExtents,
		     sizeof(m_cbMonikerExtents),
		     NULL);

    if (FAILED(hr))
    {
	return(hr);
    }

    //
    // Only write moniker extents if some exist
    //

    if (m_cbMonikerExtents != 0)
    {
	hr = pStm->Write((void *)m_pchMonikerExtents,
			 m_cbMonikerExtents,
			 NULL);
    }

    return(hr);

}

//+---------------------------------------------------------------------------
//
//  Method:     CExtentList::Load
//
//  Synopsis:   Load the moniker extents from stream
//
//  Effects:
//
//  Arguments:  [pStm] -- Stream to load from
//		[ulSize] -- Size of extents, in bytes
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CExtentList::Load(IStream * pStm, ULONG ulSize)
{
    HRESULT hr;

    //
    // In the debugging verision, we should never have an extent larger
    // than say about 2k. This should catch any errors
    //

    Assert( ulSize < (2 * 1024));

    //
    // Be sure not to drop any memory. This normally should never happen.
    //

    if (m_pchMonikerExtents != NULL)
    {
	CoTaskMemFree(m_pchMonikerExtents);
    }

    m_cbMonikerExtents = ulSize;

    m_pchMonikerExtents = (BYTE *)CoTaskMemAlloc(m_cbMonikerExtents);

    if (m_pchMonikerExtents == NULL)
    {
        m_cbMonikerExtents = 0;
	return(E_OUTOFMEMORY);
    }

    hr = StRead(pStm, m_pchMonikerExtents, m_cbMonikerExtents);

    return(hr);

}
//+---------------------------------------------------------------------------
//
//  Method:     CExtentList::GetSize
//
//  Synopsis:	Returns the size needed to serialize this object
//
//  Effects:
//
//  Arguments:  [pcbSize] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG
CExtentList::GetSize()
{
    return sizeof(m_cbMonikerExtents)+m_cbMonikerExtents;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   moniker
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..
INCLUDES=     $(INCLUDES);..\..\inc;..\..\rot;..\..\objact;
INCLUDES=     $(INCLUDES);..\..\dcomrem;..\..\..\actprops
INCLUDES=     $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)

LINKLIBS=     ..\..\common\daytona\$(O)\common.lib

SOURCES=      \
              ..\cantimon.cxx \
              ..\cbindctx.cxx \
              ..\ccompmon.cxx \
              ..\cfactory.cxx \
              ..\cfilemon.cxx \
              ..\classmon.cxx \
              ..\extents.cxx \
              ..\citemmon.cxx \
              ..\cmonimp.cxx  \
              ..\cptrmon.cxx  \
              ..\mkparse.cxx  \
              ..\cbasemon.cxx \
              ..\cmarshal.cxx \
              ..\progress.cxx \
              ..\cdialog.cxx  \
              ..\cobjrmon.cxx \
              ..\csessmon.cxx


UMTYPE=       windows
!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\actapi.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       actapi.cxx
//
//  Contents:   Functions that activate objects residing in persistent storage.
//
//  Functions:  CoGetPersistentInstanceEx
//
//  History:    20-Sep-95  GregJen    Created
//              21-Oct-98  SteveSw    104665; 197253;
//                                    fix COM+ persistent activation
//
//--------------------------------------------------------------------------
#include <ole2int.h>

#include    <iface.h>
#include    <objsrv.h>
#include    <security.hxx>
#include    "resolver.hxx"
#include    "smstg.hxx"
#include    "objact.hxx"
#include    "clsctx.hxx"
#include    "immact.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   CoGetClassObject
//
//  Synopsis:   External entry point that returns an instantiated class object
//
//  Arguments:  [rclsid] - class id for class object
//              [dwContext] - kind of server we wish
//              [pvReserved] - Reserved for future use
//              [riid] - interface to bind class object
//              [ppvClassObj] - where to put interface pointer
//
//  Returns:    S_OK - successfully bound class object
//
//  Algorithm:  Validate all then parameters and then pass this to the
//              internal version of the call.
//
//  History:    11-May-93 Ricksa    Created
//              11-May-94 KevinRo   Added OLE 1.0 support
//              23-May-94 AlexT     Make sure we're initialized!
//              15-Nov-94 Ricksa    Split into external and internal calls
//
//--------------------------------------------------------------------------
STDAPI CoGetClassObject(
                       REFCLSID rclsid,
                       DWORD dwContext,
                       LPVOID pvReserved,
                       REFIID riid,
                       void FAR* FAR* ppvClassObj)
{
    OLETRACEIN((API_CoGetClassObject, PARAMFMT("rclsid= %I, dwContext= %x, pvReserved= %p, riid= %I, ppvClassObj= %p"),
                &rclsid, dwContext, pvReserved, &riid, ppvClassObj));

    TRACECALL(TRACE_ACTIVATION, "CoGetClassObject");

    HRESULT hr = CComActivator::DoGetClassObject(rclsid,
                                                 dwContext,
                                                 (COSERVERINFO *) pvReserved,
                                                 riid,
                                                 ppvClassObj,
                                                 NULL);


    OLETRACEOUT((API_CoGetClassObject, hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoCreateInstance    (public)
//
//  Synopsis:   helper function to create instance in given context
//
//  Arguments:  [rclsid]    - the class of object to create
//              [pUnkOuter] - the controlling unknown (for aggregation)
//              [dwContext] - class context
//              [riid]      - interface id
//              [ppv]       - pointer for returned object
//
//  Returns:    REGDB_E_CLASSNOTREG, REGDB_E_READREGDB, REGDB_E_WRITEREGDB
//
//--------------------------------------------------------------------------
STDAPI CoCreateInstance(
    REFCLSID rclsid,
    LPUNKNOWN pUnkOuter,
    DWORD dwContext,
    REFIID riid,
    LPVOID * ppv)
{
    MULTI_QI    OneQI;
    HRESULT     hr;

    if (ppv == NULL) 
    {
        return E_INVALIDARG;
    }

    OneQI.pItf = NULL;
    OneQI.pIID = &riid;

    hr = CoCreateInstanceEx( rclsid, pUnkOuter, dwContext, NULL, 1, &OneQI );

    *ppv = OneQI.pItf;
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoCreateInstanceEx
//
//  Synopsis:   Returns an instantiated interface to an object
//
//
// Arguments:   [Clsid] - requested CLSID
//              [pServerInfo] - server information block
//              [punkOuter] - controlling unknown for aggregating
//              [dwCtrl] - kind of server required
//              [dwCount] - count of interfaces
//              [pResults] - MULTI_QI struct of interfaces
//
//  Returns:    S_OK - object bound successfully
//      MISSING
//
//
//--------------------------------------------------------------------------
STDAPI CoCreateInstanceEx(
    REFCLSID                    Clsid,
    IUnknown    *               punkOuter, // only relevant locally
    DWORD                       dwClsCtx,
    COSERVERINFO *              pServerInfo,
    DWORD                       dwCount,
    MULTI_QI        *           pResults )
{
    return CComActivator::DoCreateInstance(
                Clsid,
                punkOuter,
                dwClsCtx,
                pServerInfo,
                dwCount,
                pResults,
                NULL);
}

//+-------------------------------------------------------------------------
//
//  Function:   CoGetInstanceFromFile
//
//  Synopsis:   Returns an instantiated interface to an object whose
//              stored state resides on disk.
//
//  Arguments:  [pServerInfo] - server information block
//              [dwCtrl] - kind of server required
//              [grfMode] - how to open the storage if it is a file.
//              [pwszName] - name of storage if it is a file.
//              [pstg] - IStorage to use for object
//              [pclsidOverride]
//              [ppvUnk] - where to put bound interface pointer
//
//  Returns:    S_OK - object bound successfully
//      MISSING
//--------------------------------------------------------------------------

STDAPI CoGetInstanceFromFile(
    COSERVERINFO *              pServerInfo,
    CLSID       *               pclsidOverride,
    IUnknown    *               punkOuter, // only relevant locally
    DWORD                       dwClsCtx,
    DWORD                       grfMode,
    OLECHAR *                   pwszName,
    DWORD                       dwCount,
    MULTI_QI        *           pResults )
{
    TRACECALL(TRACE_ACTIVATION, "CoGetInstanceFromFile");

    return CComActivator::DoGetInstanceFromFile( pServerInfo,
                              pclsidOverride,
                              punkOuter,
                              dwClsCtx,
                              grfMode,
                              pwszName,
                              dwCount,
                              pResults ,
                              NULL);
}


//+-------------------------------------------------------------------------
//
//  Function:   CoGetInstanceFromIStorage
//
//  Synopsis:   Returns an instantiated interface to an object whose
//              stored state resides on disk.
//
//  Arguments:  [pServerInfo] - server information block
//              [dwCtrl] - kind of server required
//              [grfMode] - how to open the storage if it is a file.
//              [pwszName] - name of storage if it is a file.
//              [pstg] - IStorage to use for object
//              [pclsidOverride]
//              [ppvUnk] - where to put bound interface pointer
//
//  Returns:    S_OK - object bound successfully
//      MISSING
//
//--------------------------------------------------------------------------

STDAPI CoGetInstanceFromIStorage(
    COSERVERINFO *              pServerInfo,
    CLSID       *               pclsidOverride,
    IUnknown    *               punkOuter, // only relevant locally
    DWORD                       dwClsCtx,
    struct IStorage *           pstg,
    DWORD                       dwCount,
    MULTI_QI        *           pResults )
{
    return CComActivator::DoGetInstanceFromStorage( pServerInfo,
                            pclsidOverride,
                            punkOuter,
                            dwClsCtx,
                            pstg,
                            dwCount,
                            pResults,
                            NULL );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\progress.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       progress.cxx
//
//  Contents:   standard IBindStatusCallback implementation used by OLE
//              during network component installations
//
//  Functions:  GetDefaultIBindStatusCallback
//
//  History:    7-01-1997   stevebl   Created
//
//---------------------------------------------------------------------------

#include <ole2int.h>
#include <classmon.hxx>
#include <commctrl.h>
#include "cdialog.h"
#include "resource.h"

#define WM_UPDATECONTROLS WM_USER

//+--------------------------------------------------------------------------
//
//  Class:      DefaultIBindStatusCallback
//
//  Purpose:    default implementation for IBindStatusCallback
//
//  Interface:  QueryInterface              --
//              AddRef                      --
//              Release                     --
//              GetBindInfo                 --
//              OnStartBinding              --
//              GetPriority                 --
//              OnProgress                  --
//              OnDataAvailable             --
//              OnObjectAvailable           --
//              OnLowResource               --
//              OnStopBinding               --
//              DefaultIBindStatusCallback  --
//              Init                        --
//              ~DefaultIBindStatusCallback --
//
//  History:    7-02-1997   stevebl   Created
//
//  Notes:      puts up a window with a progress bar and a cancel button
//
//---------------------------------------------------------------------------

class DefaultIBindStatusCallback : IBindStatusCallback, ICodeInstall, CHlprDialog
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(
                             REFIID iid,
                             void ** ppvObject
                             );
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IBindStatusCallback methods
    STDMETHOD(GetBindInfo)(
                          DWORD * pgrfBINDF,
                          BINDINFO * pbindinfo
                          );
    STDMETHOD(OnStartBinding)(
                             DWORD dwReserved,
                             IBinding * pbinding
                             );
    STDMETHOD(GetPriority)(LONG * pnPriority);
    STDMETHOD(OnProgress)(
                         ULONG ulProgress,
                         ULONG ulProgressMax,
                         ULONG ulStatusCode,
                         LPCOLESTR szStatusText
                         );
    STDMETHOD(OnDataAvailable)(
                              DWORD grfBSCF,
                              DWORD dwSize,
                              FORMATETC * pfmtetc,
                              STGMEDIUM * pstgmed
                              );
    STDMETHOD(OnObjectAvailable)(
                                REFIID riid,
                                IUnknown * punk
                                );
    STDMETHOD(OnLowResource)(DWORD dwReserved);
    STDMETHOD(OnStopBinding)(
                            HRESULT hrStatus,
                            LPCOLESTR szStatusText
                            );

    // IWindowForBindingUI methods
    STDMETHOD(GetWindow)(
        REFGUID rguidReason,
        HWND* phwnd
        );

    // ICodeInstall methods
    STDMETHOD(OnCodeInstallProblem)(
        ULONG ulStatusCode,
        LPCWSTR szDestination,
        LPCWSTR szSource,
        DWORD dwReserved
        );

    // constructor
    DefaultIBindStatusCallback(HWND hwndParent, IBindStatusCallback * pibsc);

    // extra initialization, call after contstructor but before other methods
    BOOL Init(LPCOLESTR m_pszTitle);

    // destructor
    ~DefaultIBindStatusCallback();

private:
    // CHlprDialog method
    BOOL DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    IBindStatusCallback * m_pibsc;
    LONG        m_lRef;
    IBinding *  m_pBinding;
    HWND        m_hwndParent;
    HWND        m_hDlg;
    ULONG       m_ulProgress;
    ULONG       m_ulProgressMax;
    WCHAR       m_szStatusText[MAX_PATH];
    BOOL        m_fShown;
};

DefaultIBindStatusCallback::DefaultIBindStatusCallback(HWND hwndParent, IBindStatusCallback * pibsc)
{
    // Initialize with no references since it will be QIed right after
    // creation.
    m_lRef = 0;

    m_pBinding = NULL;
    m_hwndParent = hwndParent;
    m_pibsc = pibsc;
    if (pibsc)
    {
        pibsc->AddRef();
    }

    m_szStatusText[0] = 0;
    m_ulProgress = 0;
    m_ulProgressMax = 1;
    m_fShown = FALSE;
    m_hDlg = NULL;
}

typedef WINCOMMCTRLAPI void (WINAPI *PFNINITCOMMONCONTROLS) (void);

BOOL CallInitCommonControls(void)
{
    static PFNINITCOMMONCONTROLS pfnInitCommonControls = NULL;

    if ( pfnInitCommonControls == NULL )
    {
        HINSTANCE hLibrary = NULL;
        PFNINITCOMMONCONTROLS pfnICCTemp = NULL;

        hLibrary = LoadLibrary ( L"comctl32.dll" );
        if ( hLibrary == NULL )
        {
            return FALSE;
        }

        pfnICCTemp = (PFNINITCOMMONCONTROLS) GetProcAddress ( hLibrary, "InitCommonControls" );
        if ( pfnICCTemp == NULL )
        {
            return FALSE;
        }

        if ( NULL != InterlockedCompareExchangePointer ( (PVOID*) &pfnInitCommonControls, 
                                                         (PVOID) pfnICCTemp,
                                                         NULL 
                                                       ) )
        {
            FreeLibrary ( hLibrary );
        }
    }

    if ( pfnInitCommonControls != NULL )
    {
        pfnInitCommonControls();
    }

    return pfnInitCommonControls != NULL ;
}

BOOL DefaultIBindStatusCallback::Init(LPCOLESTR pszTitle)
{
    if (!CallInitCommonControls()) 
    {
        return FALSE;
    }

    // Create and show the dialog
    m_hDlg = CreateDlg(g_hinst, MAKEINTRESOURCE(IDD_DIALOG1), m_hwndParent);
    if (m_hDlg)
    {
        // set title if a different one is provided
        if (pszTitle)
        {
            SetWindowTextW(m_hDlg, pszTitle);
        }
        // Going to move this dialog so it's always in the center of our
        // parent window's client area.

        RECT rectDLG;
        RECT rectParent;
        GetWindowRect(m_hDlg, &rectDLG);
        if (m_hwndParent)
        {
            GetClientRect(m_hwndParent, &rectParent);
        }
        else
        {
            GetClientRect(GetDesktopWindow(), &rectParent);
        }
        LONG dx = rectDLG.right - rectDLG.left;
        LONG dy = rectDLG.bottom - rectDLG.top;
        LONG x = ((rectParent.right - rectParent.left) - dx)/2;
        LONG y = ((rectParent.bottom - rectParent.top) - dy)/2;
        MoveWindow(m_hDlg, x, y, dx, dy, FALSE);
    }
    return (NULL != m_hDlg);
}

DefaultIBindStatusCallback::~DefaultIBindStatusCallback()
{
    // cleanup
    if (m_hDlg)
    {
       DestroyWindow(m_hDlg);
    }
    if (m_pBinding)
    {
        m_pBinding->Release();
    }
    if (m_pibsc)
    {
        m_pibsc->Release();
    }
}

HRESULT DefaultIBindStatusCallback::QueryInterface(
                                                  REFIID iid,
                                                  void ** ppvObject
                                                  )
{
    if (IsEqualCLSID(iid, IID_IUnknown) ||
        IsEqualCLSID(iid, IID_IBindStatusCallback))
    {
        AddRef();
        *ppvObject = (IBindStatusCallback *)this;
        return S_OK;
    }
    else if (IsEqualCLSID(iid, IID_ICodeInstall))
    {
        AddRef();
        *ppvObject = (ICodeInstall *)this;
        return S_OK;
    }
    else if (IsEqualCLSID(iid, IID_IWindowForBindingUI))
    {
        AddRef();
        *ppvObject = (IWindowForBindingUI *)this;
        return S_OK;
    }

    return E_NOTIMPL;
}

ULONG DefaultIBindStatusCallback::AddRef(void)
{
    return InterlockedIncrement(&m_lRef);
}

ULONG DefaultIBindStatusCallback::Release(void)
{
    LONG lTemp = InterlockedDecrement(&m_lRef);
    if (0 == lTemp)
    {
        delete this;
    }
    return lTemp;
}

HRESULT DefaultIBindStatusCallback::GetBindInfo(
                                               DWORD * pgrfBINDF,
                                               BINDINFO * pbindinfo
                                               )
{
    *pgrfBINDF = BINDF_ASYNCHRONOUS;
    return S_OK;
}

HRESULT DefaultIBindStatusCallback::OnStartBinding(
                                                  DWORD dwReserved,
                                                  IBinding * pbinding
                                                  )
{
    if (m_pibsc)
    {
        m_pibsc->OnStartBinding(dwReserved, pbinding);
    }
    m_pBinding = pbinding;
    m_pBinding->AddRef();

    ShowWindow(m_hDlg, SW_SHOWNORMAL);
    m_fShown = TRUE;

    return S_OK;
}

HRESULT DefaultIBindStatusCallback::GetPriority(LONG * pnPriority)
{
    if (m_pibsc)
    {
        return m_pibsc->GetPriority(pnPriority);
    }
    else
    {
        return E_NOTIMPL;
    }
}

HRESULT DefaultIBindStatusCallback::OnProgress(
                                              ULONG ulProgress,
                                              ULONG ulProgressMax,
                                              ULONG ulStatusCode,
                                              LPCOLESTR szStatusText
                                              )
{
    if (m_pibsc)
    {
        m_pibsc->OnProgress(ulProgress, ulProgressMax, ulStatusCode, szStatusText);
    }
    m_ulProgress = ulProgress;
    m_ulProgressMax = ulProgressMax;
    lstrcpynW(m_szStatusText, szStatusText, MAX_PATH);

    // UNDONE - send a message to update the dialog controls

    if (!m_fShown)
    {
        ShowWindow(m_hDlg, SW_SHOWNORMAL);
        m_fShown = TRUE;
    }
    else
    {
        SendMessage(m_hDlg, WM_UPDATECONTROLS, 0, 0);
    }
    return S_OK;
}

HRESULT DefaultIBindStatusCallback::OnDataAvailable(
                                                   DWORD grfBSCF,
                                                   DWORD dwSize,
                                                   FORMATETC * pfmtetc,
                                                   STGMEDIUM * pstgmed
                                                   )
{
    if (m_pibsc)
    {
        return m_pibsc->OnDataAvailable(grfBSCF, dwSize, pfmtetc, pstgmed);
    }
    else
    {
        return E_NOTIMPL;
    }
}

HRESULT DefaultIBindStatusCallback::OnObjectAvailable(
                                                     REFIID riid,
                                                     IUnknown * punk
                                                     )
{
    if (m_pibsc)
    {
        return m_pibsc->OnObjectAvailable(riid, punk);
    }
    else
    {
        return E_NOTIMPL;
    }
}

HRESULT DefaultIBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    if (m_pibsc)
    {
        return m_pibsc->OnLowResource(dwReserved);
    }
    else
    {
        return E_NOTIMPL;
    }
}

HRESULT DefaultIBindStatusCallback::OnStopBinding(
                                                 HRESULT hrStatus,
                                                 LPCOLESTR szStatusText
                                                 )
{
    if (m_pibsc)
    {
        m_pibsc->OnStopBinding(hrStatus, szStatusText);
    }
    ShowWindow(m_hDlg, SW_HIDE);
    m_fShown = FALSE;

    return S_OK;
}

HRESULT DefaultIBindStatusCallback::GetWindow(
    REFGUID rguidReason,
    HWND* phwnd
    )
{
    *phwnd = GetDesktopWindow();
    return S_OK;
}

HRESULT DefaultIBindStatusCallback::OnCodeInstallProblem(
    ULONG ulStatusCode,
    LPCWSTR szDestination,
    LPCWSTR szSource,
    DWORD dwReserved
    )
{
    return S_OK;
}
    
BOOL DefaultIBindStatusCallback::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return TRUE;
    case WM_SHOWWINDOW:
        {
            if (NULL == m_pBinding)
            {
                // remove the cancel button
                ShowWindow(GetDlgItem(hwndDlg, IDCANCEL),SW_HIDE);
            }
            SendMessage(hwndDlg, WM_UPDATECONTROLS, 0, 0);
        }
        break;
    case WM_UPDATECONTROLS:
        {
            // update the dialog controls
            SendDlgItemMessage(hwndDlg, IDC_PROGRESS1, PBM_SETRANGE, 0, MAKELPARAM(0, m_ulProgressMax));
            SendDlgItemMessage(hwndDlg, IDC_PROGRESS1, PBM_SETPOS, m_ulProgress, 0);
            SetDlgItemTextW(hwndDlg, IDC_TEXT, m_szStatusText);
        }
        break;
    case WM_COMMAND:
        if (IDCANCEL == LOWORD(wParam))
        {
            // user has clicked cancel
            if (NULL != m_pBinding)
            {
                WCHAR szText[256];
                WCHAR szCaption[256];
                LoadStringW(m_hInstance, IDS_TEXT, szText, 256);
                LoadStringW(m_hInstance, IDS_CAPTION, szCaption, 256);
                m_pBinding->Suspend();
                if (IDYES == MessageBoxW(hwndDlg, szText, szCaption, MB_YESNO))
                {
                    m_pBinding->Abort();
                }
                else
                {
                    m_pBinding->Resume();
                }
            }

            // don't let the dialog box close itself
            return TRUE;
        }
        break;
    default:
        break;
    }

    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Function:   CreateStdProgressIndicator
//
//  Synopsis:   retrieves a standard implementation of the
//              IBindStatusCallback interface
//
//  Arguments:  [hwndParent]  - (in) handle to the parent window (may be NULL)
//              [pszTitle]    - (in) optional text for the dialog's title bar
//              [pIbscCaller] - (in) optional IBindStatusCallback interface
//                               to recieve notifications (see notes)
//              [ppIbsc]      - (out) standard IBindStatusCallback
//                               implementation
//
//  Returns:    S_OK          - success
//              E_OUTOFMEMORY - not enough memory to create the dialog object
//              E_UNEXPECTED  - error initializing the dialog
//
//  History:    7-01-1997   stevebl   Created
//              7-07-1997   stevebl   Added pszTitle and pIbsc parameters
//
//  Notes:      The implementation of IBindStatusStatusCallback provided by
//              this function will forward any notifications it recieves
//              (i.e. method calls) to the pIbsc pointer (if one provided).
//              This provides a mechanism for a program to monitor the
//              progress of the operation and thereby determine when it has
//              completed.
//
//              NOTE: The IBindStatusCallback::GetBindInfo method is _NOT_
//              forwarded.  This implementation always requests asynchronous
//              binding by setting *pgrfBINDF to BIND_ASYNCHRONOUS.
//
//              Typically, the caller will want to implement only
//              IBindStatusCallback::StopBinding, returning E_NOTIMPL for
//              the other methods.
//
//---------------------------------------------------------------------------

STDMETHODIMP CreateStdProgressIndicator(HWND hwndParent,
    LPCOLESTR pszTitle,
    IBindStatusCallback * pIbscCaller,
    IBindStatusCallback ** ppIbsc)
{
    DefaultIBindStatusCallback * p = new DefaultIBindStatusCallback(hwndParent, pIbscCaller);
    if (p)
    {
        if (p->Init(pszTitle))
        {
            p->QueryInterface(IID_IBindStatusCallback, (void **) ppIbsc);
            return S_OK;
        }
        else
        {
            delete p;
            return E_UNEXPECTED;
        }
    }
    else
        return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\actvator.cxx ===
//+-------------------------------------------------------------------
//
//  File:       actvator.cxx
//
//  Contents:   Implementation of client context system activator.
//
//  Classes:    CClientContextActivator
//
//  History:    21-Feb-98   SatishT     Created
//              22-Jun-98   CBiks       See comments in code.
//              27-Jun-98   CBiks       See RAID# 171549 and comments
//                                      in the code.
//              14-Sep-98   CBiks       Fixed RAID# 214719.
//              10-Oct-98   CBiks       Fixed RAID# 151056.
//              21-Oct-98   SteveSw     104665; 197253;
//                                      fix COM+ persistent activation
//              03-Nov-98   CBiks       Fix RAID# 231613.
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <actvator.hxx>
#include    <resolver.hxx>
#include    <dllcache.hxx>
#include    <objact.hxx>
#include    <marshal.hxx>
#include    <context.hxx>

#if DBG==1
// Debugging hack: set this to TRUE to break on unexpected failures
// in debug builds.
BOOL gfDebugHResult = FALSE;
#endif


//+------------------------------------------------------------------------
//
//  Secure references hash table buckets. This is defined as a global
//  so that we dont have to run any code to initialize the hash table.
//
//+------------------------------------------------------------------------
SHashChain ApartmentBuckets[23] =
{
    {&ApartmentBuckets[0],  &ApartmentBuckets[0]},
    {&ApartmentBuckets[1],  &ApartmentBuckets[1]},
    {&ApartmentBuckets[2],  &ApartmentBuckets[2]},
    {&ApartmentBuckets[3],  &ApartmentBuckets[3]},
    {&ApartmentBuckets[4],  &ApartmentBuckets[4]},
    {&ApartmentBuckets[5],  &ApartmentBuckets[5]},
    {&ApartmentBuckets[6],  &ApartmentBuckets[6]},
    {&ApartmentBuckets[7],  &ApartmentBuckets[7]},
    {&ApartmentBuckets[8],  &ApartmentBuckets[8]},
    {&ApartmentBuckets[9],  &ApartmentBuckets[9]},
    {&ApartmentBuckets[10], &ApartmentBuckets[10]},
    {&ApartmentBuckets[11], &ApartmentBuckets[11]},
    {&ApartmentBuckets[12], &ApartmentBuckets[12]},
    {&ApartmentBuckets[13], &ApartmentBuckets[13]},
    {&ApartmentBuckets[14], &ApartmentBuckets[14]},
    {&ApartmentBuckets[15], &ApartmentBuckets[15]},
    {&ApartmentBuckets[16], &ApartmentBuckets[16]},
    {&ApartmentBuckets[17], &ApartmentBuckets[17]},
    {&ApartmentBuckets[18], &ApartmentBuckets[18]},
    {&ApartmentBuckets[19], &ApartmentBuckets[19]},
    {&ApartmentBuckets[20], &ApartmentBuckets[20]},
    {&ApartmentBuckets[21], &ApartmentBuckets[21]},
    {&ApartmentBuckets[22], &ApartmentBuckets[22]}
};

CApartmentHashTable gApartmentTbl;    // global table of apartment entries
COleStaticMutexSem CApartmentHashTable::_mxsAptTblLock;

const GUID *GetPartitionIDForClassInfo(IComClassInfo *pCI);

//+--------------------------------------------------------------------------
//
//  Function:   CheckMemoryGate
//
//  Synopsis:   Helper function to check memory gate. This code must
//              be executed in two activators, so I wrote it as an inline
//              function to maintain brevity of activator code.
//
//  History:    01-Nov-99   a-sergiv    Created to implement Memory Gates
//
//----------------------------------------------------------------------------

inline HRESULT CheckMemoryGate(IUnknown *punk, ResourceGateId id)
{
	HRESULT hr = S_OK;
	IResourceGates *pResGates = NULL;

	if(punk->QueryInterface(IID_IResourceGates, (void**) &pResGates) == S_OK)
	{		
		BOOL bResult = TRUE;
		hr = pResGates->Test(id, &bResult);
		pResGates->Release();

		if(SUCCEEDED(hr) && !bResult)
		{
			// The gate said NO!
			hr = E_OUTOFMEMORY;
		}
		else
		{
			// Make it S_OK
			hr = S_OK;
		}
	}

	return hr;
}

//----------------------------------------------------------------------------
// CClientContextActivator Implementation.
//----------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Member:     CClientContextActivator::CheckInprocClass , private
//
//  Synopsis:   Check various parameters to determine if activation should be
//              inproc and clear the ClientContextOK flag if not
//
//  History:    21-Feb-98   SatishT     Created
//              04-Apr-98   CBiks       Added updated support for Wx86 that was removed
//                                      during the Com+ merge.
//              23-Jun-98   CBiks       See RAID# 169589.  Added activation
//                                      flags to NegotiateDllInstantiationProperties().
//
//              09-Oct-09   vinaykr     Changed to not give RSN priority
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientContextActivator::CheckInprocClass(
                    IActivationPropertiesIn *pInActProperties,
                    DLL_INSTANTIATION_PROPERTIES *pdip,
                    BOOL &bActivateInproc,
                    ILocalSystemActivator **ppAct)
{
    DWORD dwClsCtx;

    *ppAct = NULL;

    IComClassInfo *pClassInfo = NULL;
    IServerLocationInfo *pSrvLocInfo = NULL;
    HRESULT hrNegotiate = S_OK;

    ActivationPropertiesIn *pActIn=NULL;
    // This does not need to be released
    HRESULT hr = pInActProperties->QueryInterface(
                                        CLSID_ActivationPropertiesIn,
                                        (LPVOID*)&pActIn
                                        );
    Win4Assert((hr == S_OK) && (pActIn != NULL));

    hr = pInActProperties->GetClsctx(&dwClsCtx);
    CHECK_HRESULT(hr);

    // This does not need to be released
    pClassInfo = pActIn->GetComClassInfo();
    Win4Assert(pClassInfo != NULL);

    // Pick up RSN from Server Location Info
    pSrvLocInfo = pActIn->GetServerLocationInfo();
    Win4Assert(pSrvLocInfo != NULL);
    PWSTR pwstrRSN = NULL;

    // Note that, by the memory management rules
    // of the catalog interfaces, this string is
    // a direct pointer to the buffer in the
    // properties object, and should not be deleted
    hr = pSrvLocInfo->GetRemoteServerName(&pwstrRSN);

    CLSID *pClsid;
    hr = pClassInfo->GetConfiguredClsid(&pClsid);

    if (dwClsCtx & CLSCTX_INPROC_MASK1632)
    {
        // Now see if the activation should occur INPROC

        //  CBiks, 10-Oct-98
        //      Cleaned up the code to let NegotiateDllInstantiationProperties()
        //      do all the work.

        DWORD actvflags;
        hr = pInActProperties->GetActivationFlags(&actvflags);
        CHECK_HRESULT(hr)

        hr = CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties(
            dwClsCtx,
            actvflags,
            *pClsid,
            *pdip,
            pClassInfo,
            TRUE);

        bActivateInproc = SUCCEEDED(hr);

        // Propagate BADTHREADINGMODEL return code.
        if (REGDB_E_BADTHREADINGMODEL == hr)
            hrNegotiate = hr;

        hr = S_OK;

    }
    else
    {
        bActivateInproc = FALSE;
    }

    IActivationStageInfo *pStageInfo = (IActivationStageInfo*)pActIn;

    if (bActivateInproc)    // get ready for server process stage
    {
        pActIn->SetDip(pdip);
        hr = pStageInfo->SetStageAndIndex(SERVER_PROCESS_STAGE,0);
        CHECK_HRESULT(hr);
    }
    else
    {
        if (((dwClsCtx &
             ~(CLSCTX_INPROC_MASK1632|CLSCTX_NO_CODE_DOWNLOAD|
               CLSCTX_NO_WX86_TRANSLATION|CLSCTX_NO_CUSTOM_MARSHAL)) != 0) ||
            (pwstrRSN != NULL))
        {
            if (pwstrRSN == NULL)
            {
            //Try to intercept case where we are already running
            //in a complus server app for which this activation
            //is destined.
                GUID *pProcessGuid=NULL;
                if (CSurrogateActivator::AmIComplusProcess(&pProcessGuid))
                {
                    Win4Assert(pProcessGuid);
                    IClassClassicInfo *pIClassCI;
                    hr = pClassInfo->QueryInterface (IID_IClassClassicInfo,
                                     (void**) &pIClassCI );

                    if ((pIClassCI != NULL) &&
                        (SUCCEEDED(hr)))
                    {
                        IComProcessInfo *pProcessInfo;

                        hr = pIClassCI->GetProcess(IID_IComProcessInfo,
                                               (void**) &pProcessInfo);

                        pIClassCI->Release();

                        if (SUCCEEDED(hr) && pProcessInfo)
                        {

                            GUID *pGuid;
                            hr = pProcessInfo->GetProcessId(&pGuid);

                            HRESULT hr2 = S_OK;

                            if (SUCCEEDED(hr) &&
                                (*pGuid == *pProcessGuid))
                            {
                                bActivateInproc = TRUE;
                                //DebugBreak();
                                *ppAct = (ILocalSystemActivator*)
                                    CSurrogateActivator::GetSurrogateActivator();
                                Win4Assert(*ppAct);

                                DWORD actvflags;
                                hr2 = pInActProperties->GetActivationFlags(&actvflags);
                                CHECK_HRESULT(hr2)

                                hr2 = CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties(
                                    CLSCTX_INPROC,
                                    actvflags,
                                    *pClsid,
                                    *pdip,
                                    pClassInfo,
                                    TRUE);

                                if (SUCCEEDED(hr2))
                                    pActIn->SetDip(pdip);

                            }

                            pProcessInfo->Release();

                            if (FAILED(hr2))
                            {
                                return hr2;
                            }
                        }
                    }

                    hr = S_OK;
                }
            }

            if (!bActivateInproc)
            {
            // get ready for client SCM stage
             ContextInfo *pActCtxInfo;

             pActCtxInfo = pActIn->GetContextInfo();
             Win4Assert(pActCtxInfo != NULL);

             hr = pActCtxInfo->SetClientContextNotOK();
             CHECK_HRESULT(hr);

             hr = pStageInfo->SetStageAndIndex(CLIENT_MACHINE_STAGE,0);
             CHECK_HRESULT(hr);
            }
        }
        else
        {
             hr = (hrNegotiate == S_OK) ? REGDB_E_CLASSNOTREG : hrNegotiate;
        }
    }



    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CClientContextActivator::GetClassObject , public
//
//  Synopsis:   Delegate to server process stage if the activation will be
//              completed inproc, otherwise, clear the ClientContextOK flag
//              and delegate to the client SCM stage.
//
//  History:    21-Feb-98   SatishT      Created
//              01-Nov-99   a-sergiv     Implemented Memory Gates
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientContextActivator::GetClassObject(
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    TRACECALL(TRACE_ACTIVATION, "CClientContextActivator::GetClassObject");
    ComDebOut((DEB_ACTIVATE, "CClientContextActivator::GetClassObject [IN]\n"));

    HRESULT hr;
    BOOL bActivateInproc;
    DLL_INSTANTIATION_PROPERTIES *pdip;
    int nRetries = 0;

    GETREFCOUNT(pInActProperties,__relCount__);

    ActivationPropertiesIn *pActIn=NULL;
    // This does not need to be released
    hr = pInActProperties->QueryInterface(
                                          CLSID_ActivationPropertiesIn,
                                          (LPVOID*)&pActIn
                                          );
    Win4Assert((hr == S_OK) && (pActIn != NULL));

RETRY_ACTIVATION:
	
    // Check CreateObjectMemoryGate
    hr = CheckMemoryGate(pActIn->GetComClassInfo(), CreateObjectMemoryGate);
    if(FAILED(hr)) goto exit_point;

    pdip = (DLL_INSTANTIATION_PROPERTIES *) pActIn->GetDip();
    if (!pdip)
    {
        pdip = (DLL_INSTANTIATION_PROPERTIES *) _alloca(sizeof(DLL_INSTANTIATION_PROPERTIES));
        pdip->_pDCE = NULL;
    }


    ILocalSystemActivator *pAct;
    hr = CheckInprocClass(pInActProperties, pdip, bActivateInproc, &pAct);

    if (SUCCEEDED(hr))
    {
        if (bActivateInproc)    // just move to the process stage already set
        {
            if (pAct)
                hr = pAct->GetClassObject(pInActProperties,
                                          ppOutActProperties);
            else
	    {
	       hr = pInActProperties->DelegateGetClassObject(ppOutActProperties);
	       // Sajia-support for partitions
	       // If the delegated activation returns ERROR_RETRY,
	       // we walk the chain again, but AT MOST ONCE.
	       if (ERROR_RETRY == hr) 
	       {
		  Win4Assert(!nRetries);
		  if (!nRetries)
		  {
		     nRetries++;
		     goto RETRY_ACTIVATION;
		  }
	       }
	    }
        }
        else
        {
            // Go to the SCM
            hr = gResolver.GetClassObject(
                                          pInActProperties,
                                          ppOutActProperties
                                          );
        }
    }

exit_point:

    CHECKREFCOUNT(pInActProperties,__relCount__);

    ComDebOut((DEB_ACTIVATE, "CClientContextActivator::GetClassObject [OUT] hr:%x\n", hr));

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CClientContextActivator::CreateInstance , public
//
//  Synopsis:
//
//  History:    21-Feb-98   SatishT      Created
//              01-Nov-99   a-sergiv     Implemented Memory Gates
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientContextActivator::CreateInstance(
                    IN  IUnknown *pUnkOuter,
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    TRACECALL(TRACE_ACTIVATION, "CClientContextActivator::CreateInstance");
    ComDebOut((DEB_ACTIVATE, "CClientContextActivator::CreateInstance [IN]\n"));
    
    HRESULT hr;
    BOOL bActivateInproc;
    DLL_INSTANTIATION_PROPERTIES *pdip;
    int nRetries = 0;
    
    GETREFCOUNT(pInActProperties,__relCount__);
    ActivationPropertiesIn *pActIn=NULL;

    // This does not need to be released
    hr = pInActProperties->QueryInterface(
                                CLSID_ActivationPropertiesIn,
                                (LPVOID*)&pActIn
                                );
    Win4Assert((hr == S_OK) && (pActIn != NULL));
    
RETRY_ACTIVATION:
    // Check CreateObjectMemoryGate
    hr = CheckMemoryGate(pActIn->GetComClassInfo(), CreateObjectMemoryGate);
    if(FAILED(hr)) goto exit_point;
    
    pdip = (DLL_INSTANTIATION_PROPERTIES *) pActIn->GetDip();
    if (!pdip)
    {
        pdip = (DLL_INSTANTIATION_PROPERTIES *) _alloca(sizeof(DLL_INSTANTIATION_PROPERTIES));
        pdip->_pDCE = NULL;
    }
    
    ILocalSystemActivator *pAct;
    hr = CheckInprocClass(pInActProperties, pdip, bActivateInproc, &pAct);    
    if (SUCCEEDED(hr))
    {
        if (bActivateInproc)    // just move to the process stage already set
        {
            if (pAct)
            {
                hr = pAct->CreateInstance(pUnkOuter,
                                pInActProperties,
                                ppOutActProperties);
            }
            else
            {
                hr = pInActProperties->DelegateCreateInstance(pUnkOuter, ppOutActProperties);
                // Sajia-support for partitions
                // If the delegated activation returns ERROR_RETRY,
                // we walk the chain again, but AT MOST ONCE.
                if (ERROR_RETRY == hr) 
                {
                    Win4Assert(!nRetries);
                    if (!nRetries)
                    {
                        nRetries++;
                        goto RETRY_ACTIVATION;
                    }
                }
            }
        }
        else
        {
            IInstanceInfo* pInstanceInfo = NULL;
            
            if ( pUnkOuter )    // can't send this to the SCM
            {
                hr = CLASS_E_NOAGGREGATION;
            }
            else if ( FAILED(pInActProperties->QueryInterface(IID_IInstanceInfo, (void**) &pInstanceInfo)) )
            {
                // Go to the SCM
                hr = gResolver.CreateInstance(
                                        pInActProperties,
                                        ppOutActProperties
                                        );
            }
            else
            {
                BOOL    FoundInROT  = FALSE;
                DWORD   cLoops      = 0;
                
                pInstanceInfo->Release();
                do
                {
                    hr = gResolver.GetPersistentInstance(pInActProperties, ppOutActProperties, &FoundInROT);
                }
                while ( (hr != S_OK) && (FoundInROT) && (++cLoops < 5) );
            }
        }
    }
    
    
exit_point:
    CHECKREFCOUNT(pInActProperties,__relCount__);
    
    ComDebOut((DEB_ACTIVATE, "CClientContextActivator::CreateInstance [OUT] hr:%x\n", hr));
    
    return hr;
}



//----------------------------------------------------------------------------
// CServerContextActivator Implementation.
//----------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Member:     CServerContextActivator::GetClassObject , public
//
//  Synopsis:
//
//  History:    21-Feb-98   SatishT     Created
//              22-Jun-98   CBiks       See RAID# 164432.  Added code to set
//                                      OleStubInvoked when Wx86 is calling so
//                                      whOleDllGetClassObject will allow
//                                      the return of unknown interfaces.
//                                      See RAID# 159589.  Added the activation
//                                      flags to ACTIVATION_PROPERTIES constructor.
//              12-Feb-01   JohnDoty    Widened ACTIVATION_PROPERTIES for partitions.
//
//----------------------------------------------------------------------------
STDMETHODIMP CServerContextActivator::GetClassObject(
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    TRACECALL(TRACE_ACTIVATION, "CServerContextActivator::GetClassObject");
    ComDebOut((DEB_ACTIVATE, "CServerContextActivator::GetClassObject [IN]\n"));

    CLSID *pClsid  = NULL;
    HRESULT hrSave = E_FAIL;

    ActivationPropertiesIn *pActIn=NULL;
    // This does not need to be released
    HRESULT hr = pInActProperties->QueryInterface(
                                        CLSID_ActivationPropertiesIn,
                                        (LPVOID*)&pActIn
                                        );
    Win4Assert((hr == S_OK) && (pActIn != NULL));

    // This does not need to be released
    IComClassInfo *pComClassInfo;
    pComClassInfo = pActIn->GetComClassInfo();
    Win4Assert(pComClassInfo != NULL);

    hr = pComClassInfo->GetConfiguredClsid(&pClsid);
    CHECK_HRESULT(hr);
    Win4Assert(pClsid && "Configured class id missing in class info");

    DWORD ulCount = 0;
    IID *prgIID = NULL;
    IUnknown *pUnk = NULL;

    hr = pInActProperties->GetRequestedIIDs(&ulCount, &prgIID);
    CHECK_HRESULT(hr);
    Win4Assert(ulCount == 1);

    DWORD dwClsCtx = 0;

    DWORD actvflags;
    pActIn->GetActivationFlags( &actvflags );


#ifdef WX86OLE
    //  If Wx86 is calling set OleStubInvoked so whOleDllGetClassObject will
    //  thunk unknown interfaces as IUnknown.  This happens when apps call
    //  DllGetClassObject() with a GUID we can't thunk.
    if ( actvflags & ACTVFLAGS_WX86_CALLER )
    {
        gcwx86.SetStubInvokeFlag((UCHAR) -1);
    }
#endif

    // NOTE:  Do not change the IID passed below.  There are some objects in which
    //        IUnknown is broken and the object cannot be QI'd for the interface
    //        later.  The work around for these objects relies on this code
    //        asking for the correct IID when calling DllGetClassObject.

    DLL_INSTANTIATION_PROPERTIES *pdip = (DLL_INSTANTIATION_PROPERTIES *)pActIn->GetDip();
    if (pdip && pdip->_pDCE)
    {
        //
        // we have the cache line already, so just activate it
        //

        hr = hrSave = pdip->_pDCE->GetClassObject(*pClsid, prgIID[0], &pUnk, dwClsCtx);
    }
    else
    {
         if (pdip)
         {
             dwClsCtx = pdip->_dwContext;
         }
         else
         {
             hr = pInActProperties->GetClsctx(&dwClsCtx);
             CHECK_HRESULT(hr)
         }

         // Grab the partition ID, if possible.         
         const GUID *pguidPartition = GetPartitionIDForClassInfo(pComClassInfo);
         
         // This goes to the class cache to actually lookup the DPE and get the factory
         //
         ACTIVATION_PROPERTIES ap(*pClsid, 
                                  *pguidPartition,
                                  prgIID[0], 
                                  0, 
                                  dwClsCtx, 
                                  actvflags, 
                                  0,
                                  NULL, 
                                  &pUnk, 
                                  pComClassInfo);
         hr = hrSave = CCGetClassObject(ap);
    }

#ifdef WX86OLE
    //  Clear the flag in case it was not used.  We don't want to leave
    //  this stuff laying around in the street for school kids to play with.
    if ( actvflags & ACTVFLAGS_WX86_CALLER )
    {
        gcwx86.SetStubInvokeFlag(0);
    }
#endif

    if (SUCCEEDED(hr))
    {
        //
        // Grammatik has reference counting problems.  The old class cache did
        // not call AddRef or Release before returning the object to the app.
        // We will special case Grammatik for the same behavior.
        //

        Win4Assert((pUnk != NULL) && "CCGetClassObject Succeeded but ..");
        hr = pInActProperties->GetReturnActivationProperties(pUnk,ppOutActProperties);


        if (!IsBrokenRefCount(pClsid))
        {
            // The out activation properties should have a ref on this
            pUnk->Release();
        }
    }

    ComDebOut((DEB_ACTIVATE, "CServerContextActivator::GetClassObject [OUT] hr:%x\n", hr));

    if (SUCCEEDED(hr))
    {
       Win4Assert(SUCCEEDED(hrSave));
       return hrSave;
    }
    else
    {
       return hr;
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CServerContextActivator::CreateInstance , public
//
//  Synopsis:
//
//  History:    21-Feb-98   SatishT     Created
//              22-Jun-98   CBiks       See RAID# 164432.  Added code to set
//                                      OleStubInvoked when Wx86 is calling so
//                                      whOleDllGetClassObject will allow
//                                      the return of unknown interfaces.
//                                      See RAID# 159589.  Added the activation
//                                      flags to ACTIVATION_PROPERTIES constructor.
//
//----------------------------------------------------------------------------
STDMETHODIMP CServerContextActivator::CreateInstance(
                    IN  IUnknown *pUnkOuter,
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    TRACECALL(TRACE_ACTIVATION, "CServerContextActivator::CreateInstance");
    ComDebOut((DEB_ACTIVATE, "CServerContextActivator::CreateInstance [IN]\n"));

    CLSID *pClsid = NULL;

    // This does not need to be released
    ActivationPropertiesIn *pActIn=NULL;
    HRESULT hr = pInActProperties->QueryInterface(
                                        CLSID_ActivationPropertiesIn,
                                        (LPVOID*)&pActIn
                                        );

    Win4Assert((hr == S_OK) && (pActIn != NULL));

    // This code checks to make sure we're not doing cross-context aggregation
    hr = CheckCrossContextAggregation (pActIn, pUnkOuter);
    if (FAILED (hr))
    {
        return hr;
    }

    // This does not need to be released
    IComClassInfo *pComClassInfo;
    pComClassInfo = pActIn->GetComClassInfo();
    Win4Assert(pComClassInfo != NULL);

    hr = pComClassInfo->GetConfiguredClsid(&pClsid);
    CHECK_HRESULT(hr);
    Win4Assert(pClsid && "Configured class id missing in class info");

    IClassFactory *pCF = NULL;
    IUnknown *pUnk = NULL;

    DWORD dwClsCtx = 0;

    DWORD actvflags;
    pActIn->GetActivationFlags( &actvflags );

#ifdef WX86OLE
    //  If Wx86 is calling set OleStubInvoked so whOleDllGetClassObject will
    //  thunk unknown interfaces as IUnknown.  This happens when apps call
    //  DllGetClassObject() with a GUID we can't thunk.
    if ( actvflags & ACTVFLAGS_WX86_CALLER )
    {
        gcwx86.SetStubInvokeFlag((UCHAR) -1);
    }
#endif

    DLL_INSTANTIATION_PROPERTIES *pdip = (DLL_INSTANTIATION_PROPERTIES *)pActIn->GetDip();
    if (pdip && pdip->_pDCE)
    {
        //
        // we have the cache line already, so just activate it
        //

        hr = pdip->_pDCE->GetClassObject(*pClsid, IID_IClassFactory,
                                         (IUnknown **) &pCF, dwClsCtx);
    }
    else
    {
        if (pdip)
        {
            dwClsCtx = ((DLL_INSTANTIATION_PROPERTIES *)pActIn->GetDip())->_dwContext;
        }
        else
        {
            hr = pInActProperties->GetClsctx(&dwClsCtx);
            CHECK_HRESULT(hr);            
        }

        // Grab the partition ID, if possible.
        const GUID *pguidPartition = GetPartitionIDForClassInfo(pComClassInfo);

        // This goes to the class cache to actually lookup the DPE and get the factory
        ACTIVATION_PROPERTIES ap(*pClsid, 
                                 *pguidPartition,
                                 IID_IClassFactory, 
                                 0, 
                                 dwClsCtx, 
                                 actvflags, 
                                 0, 
                                 NULL,
                                 (IUnknown **)&pCF, 
                                 pComClassInfo);
        hr = CCGetClassObject(ap);
    }

#ifdef WX86OLE
    //  Clear the flag in case it was not used.  We don't want to leave
    //  this stuff laying around in the street for school kids to play with.
    if ( actvflags & ACTVFLAGS_WX86_CALLER )
    {
        gcwx86.SetStubInvokeFlag(0);
    }
#endif

    if (SUCCEEDED(hr))
    {
        Win4Assert((pCF != NULL) && "CCGetClassObject Succeeded but ..");
        
        DWORD ulCount = 0;
        IID *prgIID = NULL;

        // This mysterious piece of code is here to take care of VB4 which sometimes
        // produces "COM objects" that refuse to supply IUnknown when requested.
        //
        // jsimmons 5/21/00 -- in addition to handling buggy VB4 objects, people get 
        // upset when their class factory CreateInstance method is called and we don't
        // ask for the same IID that was passed to CoCreateInstance.
        hr = pInActProperties->GetRequestedIIDs(&ulCount, &prgIID);
        if (SUCCEEDED(hr))
        {
            for (DWORD i=0;i<ulCount; i++)
            {
#ifdef WX86OLE
                //  If we're being called by x86 code and the class factory is x86
                //  then set the OleStubInvoked flag to allow MapIFacePtr() to thunk
                //  unknown IP return values as -1 because we're just returning this
                //  to x86 code anyway.
                if ( (actvflags & ACTVFLAGS_WX86_CALLER) && gcwx86.IsN2XProxy(pCF))
                {
                    gcwx86.SetStubInvokeFlag((UCHAR)-1);
                }
#endif
                // 
                // Actually create the object
                //
                hr = pCF->CreateInstance(pUnkOuter, prgIID[i], (LPVOID*)&pUnk);
                if (SUCCEEDED(hr))
                    break;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        Win4Assert((pUnk != NULL) && "pCF->CreateInstance Succeeded but ..");

        // This not only sets the object interface, it also applies any constructors that
        // are required such as those involved in persistent instances
        hr = pActIn->GetReturnActivationPropertiesWithCF(pUnk,
                                                         pCF,
                                                         ppOutActProperties);

        // The out activation properties should have a ref on this
        pUnk->Release();
    }

    // If Activation Succeeded, Out Actprops should have reference on this
    if (pCF)
        pCF->Release();

    ComDebOut((DEB_ACTIVATE, "CServerContextActivator::CreateInstance [OUT] hr:%x\n", hr));

    return hr;
}

HRESULT CServerContextActivator::CheckCrossContextAggregation (
                                IN ActivationPropertiesIn *pActIn,
                                IN IUnknown* pUnkOuter
                                )
{
    CObjectContext* pCtx = NULL;
    CObjectContext* pClientCtxUnk = NULL;
    CObjectContext* pCurrentCtxUnk = NULL;
    ContextInfo *cInfo = NULL;
    CObjectContext *pContext = NULL;

    HRESULT hr = S_OK, hrRet = S_OK;

    // Short cut
    if (pUnkOuter == NULL)
    {
        return S_OK;
    }

    // This does not need to be released
    cInfo = pActIn->GetContextInfo();
    Win4Assert(cInfo != NULL);

    hr = cInfo->GetInternalClientContext(&pCtx);
    if (SUCCEEDED(hr) && pCtx)
    {
        hr = pCtx->InternalQueryInterface(IID_IUnknown, (void**) &pClientCtxUnk);
        pCtx->InternalRelease();
        pCtx = NULL;
    }
    if (SUCCEEDED(hr) && pClientCtxUnk)
    {
        pContext = GetCurrentContext();
        if (pContext)
        {
            hr = pContext->InternalQueryInterface(IID_IUnknown, (void**) &pCurrentCtxUnk);
            pContext = NULL;
        }
    }
    if (SUCCEEDED(hr) && pCurrentCtxUnk && pClientCtxUnk)
    {
        if (pClientCtxUnk != pCurrentCtxUnk)
        {
            hrRet = CLASS_E_NOAGGREGATION;
        }
    }

    if (pClientCtxUnk)
    {
        pClientCtxUnk->InternalRelease();
        pClientCtxUnk = NULL;
    }

    if (pCurrentCtxUnk)
    {
        pCurrentCtxUnk->InternalRelease();
        pCurrentCtxUnk = NULL;
    }

    return hrRet;
}

//----------------------------------------------------------------------------
// CProcessActivator Implementation.
//----------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Member:     CProcessActivator::GetApartmentActivator , private
//
//  Synopsis:   Check if a custom activator set the apartment and if not
//              call the class cache to find or create the default apartment
//              in which this class should run.
//
//  History:    25-Feb-98   SatishT     Created
//              23-Jun-98   CBiks       See RAID# 169589.  Added activation
//                                      flags to NegotiateDllInstantiationProperties().
//
//----------------------------------------------------------------------------
STDMETHODIMP CProcessActivator::GetApartmentActivator(
            IN  ActivationPropertiesIn *pInActProperties,
            OUT ISystemActivator      **ppActivator)
{
    HRESULT hr = E_FAIL;
    IServerLocationInfo *pSrvLoc;

    pSrvLoc = pInActProperties->GetServerLocationInfo();
    Win4Assert(pSrvLoc != NULL);

    HActivator hActivator = 0;

    hr = pSrvLoc->GetApartment(&hActivator);

    // HACK ALERT:  This should only be entered if hActivator==0
    // But in lieu of restructuring the DllCache to load the DLL in the
    // server context, we currently do this for all activations to make sure
    // that the DLL is actually loaded in the process and a ref is held to the
    // DllPathEntry until activation is either completed or aborted

    // The downsides of the hack are:
    // 1.  default DLL HOST based apartment created even when not needed
    // 2.  DLL unloading logic is broken because the DLL is validated in
    //     an apartment in which it may never be used

    {
        // none of the custom activators set the apartment

        // This code will find or create the default apartment
        // in which this class should run

        CLSID *pClsid = NULL;
        DWORD ClassContext;

        HActivator hStdActivator = 0;


        IComClassInfo *pComClassInfo = pInActProperties->GetComClassInfo();
        Win4Assert(pComClassInfo != NULL);

        hr = pComClassInfo->GetConfiguredClsid(&pClsid);
        CHECK_HRESULT(hr);
        Win4Assert(pClsid && "Configured class id missing in class info");

        DWORD actvflags;
        hr = pInActProperties->GetActivationFlags(&actvflags);
        CHECK_HRESULT(hr)

        DLL_INSTANTIATION_PROPERTIES *pdip =
            (DLL_INSTANTIATION_PROPERTIES *) pInActProperties->GetDip();

        if (!pdip)
        {
            //
            // this can happen in a surrogate activation
            //

            pdip = (DLL_INSTANTIATION_PROPERTIES *) _alloca(sizeof(DLL_INSTANTIATION_PROPERTIES));
            pdip->_pDCE = NULL;
            hr = pInActProperties->GetClsctx(&(pdip->_dwContext));
            CHECK_HRESULT(hr)

            hr = CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties(
                         pdip->_dwContext,
                         actvflags,
                         *pClsid,
                         *pdip,
                         pComClassInfo,
                         TRUE);
        }

        if (SUCCEEDED(hr))
        {
            // Go to the class cache for the apartment creation
            hr = FindOrCreateApartment(
                                       *pClsid,
                                       actvflags,
                                       pdip,
                                       &hStdActivator
                                       );


            // this is part of the HACK ALERT above
            if (SUCCEEDED(hr) && (hActivator == 0))
            {
                hActivator = hStdActivator;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        Win4Assert(hActivator != 0);

        if (CURRENT_APARTMENT_TOKEN != hActivator)
        {
            // cross apartment activation
            *ppActivator = NULL;
            hr = GetInterfaceFromStdGlobal(hActivator,
                                           IID_ISystemActivator,
                                           (LPVOID*)ppActivator);

            if (SUCCEEDED(hr))
            {
                // Since we are going cross apartment, the client context
                // won't do as the server context, so set the flag appropriately
                ContextInfo *pActCtxInfo = NULL;

                pActCtxInfo = pInActProperties->GetContextInfo();
                Win4Assert(pActCtxInfo != NULL);
                hr = pActCtxInfo->SetClientContextNotOK();
            }
        }
        else
        {
            // same apartment activation, just get the raw pointer
            *ppActivator = gApartmentActivator.GetSystemActivator();
        }
    }

    ComDebOut((DEB_ACTIVATE, "CProcessActivator::GetApartmentActivator [OUT] hr:%x\n", hr));

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CProcessActivator::GetClassObject , public
//
//  Synopsis:   End of the server process activation stage.
//              Responsibilities:
//
//                  1. Find or create apartment for activation
//                  2. Find a match for the prototype context in the right
//                     apartment, and if none, freeze the prototype into a new
//                     context to be used for the class object.
//
//              If we got this far with GetClassObject, the class factory will be
//              born in a fixed context and all instances of the factory will most
//              likely live there unless the factory does something unusual.
//
//  History:    24-Feb-98   SatishT      Created
//              07-Mar-98   Gopalk       Fixup leaking ISystemActivator
//              01-Nov-99   a-sergiv     Implemented Memory Gates
//
//----------------------------------------------------------------------------
STDMETHODIMP CProcessActivator::GetClassObject(
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    TRACECALL(TRACE_ACTIVATION, "CProcessActivator::GetClassObject");
    ComDebOut((DEB_ACTIVATE, "CProcessActivator::GetClassObject [IN]\n"));

    GETREFCOUNT(pInActProperties,__relCount__);

    HRESULT hr = E_FAIL;


    ActivationPropertiesIn *pActIn=NULL;
    hr = pInActProperties->QueryInterface(
                                        CLSID_ActivationPropertiesIn,
                                        (LPVOID*)&pActIn
                                        );

    Win4Assert((hr == S_OK) && (pActIn != NULL));

    // Check CreateObjectMemoryGate
    hr = CheckMemoryGate(pActIn->GetComClassInfo(), CreateObjectMemoryGate);
    if(FAILED(hr)) goto exit_point;

    //
    // We must retry for each CLSCTX separately because the handler
    // case could go to a different apartment or context than the
    // inproc server
    //

    hr = ActivateByContext(pActIn, NULL, pInActProperties,
                           ppOutActProperties, GCOCallback);



    if (FAILED(hr)) goto exit_point;

    /*

    If we arrive at the end of the server process activation stage without
    running into an activator that short circuits CGCO due to a desire to
    intercept instance creation, do we then proceed to construct a context
    for it as though it were an instance of the said class and park the
    class factory in that context?  Is this consistent with JIT/Pooling
    and other strange activators?  Even if the interface required from
    the class is not a standard factory interface?  There has been some
    concern about object pooling in particular.

    */

exit_point:

    CHECKREFCOUNT(pInActProperties,__relCount__);

    ComDebOut((DEB_ACTIVATE, "CProcessActivator::GetClassObject [OUT] hr:%x\n", hr));

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CProcessActivator::CreateInstance , public
//
//  Synopsis:   End of the server process activation stage.
//              Responsibilities:
//
//                  1. Find or create apartment for activation
//                  2. Find a match for the prototype context in the right
//                     apartment, and if none, freeze the prototype into a new
//                     context to be used for the instance object.
//
//  History:    25-Feb-98   SatishT      Created
//              07-Mar-98   Gopalk       Fixup leaking ISystemActivator
//              01-Nov-99   a-sergiv     Implemented Memory Gates
//
//----------------------------------------------------------------------------
STDMETHODIMP CProcessActivator::CreateInstance(
                    IN  IUnknown *pUnkOuter,
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    TRACECALL(TRACE_ACTIVATION, "CProcessActivator::GetClassObject");
    ComDebOut((DEB_ACTIVATE, "CProcessActivator::GetClassObject [IN]\n"));

    HRESULT hr = E_FAIL;

    GETREFCOUNT(pInActProperties,__relCount__);

    ActivationPropertiesIn *pActIn=NULL;
    hr = pInActProperties->QueryInterface(
                                        CLSID_ActivationPropertiesIn,
                                        (LPVOID*)&pActIn
                                        );
    Win4Assert((hr == S_OK) && (pActIn != NULL));

    // Check CreateObjectMemoryGate
    hr = CheckMemoryGate(pActIn->GetComClassInfo(), CreateObjectMemoryGate);
    if(FAILED(hr)) goto exit_point;


    hr = ActivateByContext(pActIn, pUnkOuter, pInActProperties,
                           ppOutActProperties, CCICallback);

    if (FAILED(hr)) goto exit_point;


exit_point:

    CHECKREFCOUNT(pInActProperties,__relCount__);

    ComDebOut((DEB_ACTIVATE, "CProcessActivator::CreateInstance [OUT] hr:%x\n", hr));

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:        CProcessActivator::ActivateByContext
//
//  Synopsis:      Tries each context in the correct order.
//
//  History:       27-Apr-98  MattSmit  Created
//                 22-Jun-98  CBiks     See RAID# 169589.  Fixed an order of
//                                      operations typo the Wx86 detection
//                                      code that resulted Wx86 never working.
//                                      HEY MATT! == binds stronger than & !!
//                 09-Oct-98  CBiks     Modified the INPROCs to check for
//                                      x86 activation first on Alpha.
//
//-----------------------------------------------------------------------------
STDMETHODIMP  CProcessActivator::ActivateByContext(ActivationPropertiesIn     *pActIn,
                                                   IUnknown                   *pUnkOuter,
                                                   IActivationPropertiesIn    *pInActProperties,
                                                   IActivationPropertiesOut  **ppOutActProperties,
                                                   PFNCTXACTCALLBACK           pfnCtxActCallback)

{
    ClsCacheDebugOut((DEB_TRACE, "CProcessActivator::ActivateByContext IN "
                      "pActIn:0x%x, pInActProperties:0x%x, ppOutActProperties:0x%x,"
                      " pfnCtxActCallback:0x%x\n", pActIn, pInActProperties,
                       ppOutActProperties, pfnCtxActCallback));

    // Be careful in this function regarding which error gets returned
    // to the caller, since we do all of these retries.  General philosophy 
    // is to return the first error encountered, regardless of what other
    // errors were encountered after that.
    HRESULT hrFinal, hrtmp;
    DWORD dwContext;
    BOOL  triedOne = FALSE;

    hrtmp = pInActProperties->GetClsctx(&dwContext);
    Win4Assert(SUCCEEDED(hrtmp));

#ifdef WX86OLE
    DWORD actvflags;
    hrtmp = pInActProperties->GetActivationFlags(&actvflags);
    CHECK_HRESULT(hrx86)
#endif
    
    hrFinal = S_OK;  // overwritten by the first error, or set to CLASS_E_CLASSNOTAVAILABLE 
                     // if none of the below cases apply (unexpected for this to happen)
    hrtmp = E_FAIL;

    // try an INPROC_SERVER first
    if (dwContext & CLSCTX_INPROC_SERVERS)
    {
#ifdef WX86OLE
        if (actvflags & ACTVFLAGS_WX86_CALLER)
        {
            //  If x86 code is calling then try to activate an x86 server
            //  first.
            hrtmp = AttemptActivation(pActIn, pUnkOuter, pInActProperties,
                                      ppOutActProperties, pfnCtxActCallback,
                                      CLSCTX_INPROC_SERVERX86);
            if (FAILED(hrtmp) && SUCCEEDED(hrFinal))
                hrFinal = hrtmp;
            else if (SUCCEEDED(hrtmp)
                hrFinal = hrtmp;

            triedOne = TRUE;
        }
#endif

        if (FAILED(hrtmp))
        {
            hrtmp = AttemptActivation(pActIn, pUnkOuter, pInActProperties,
                                      ppOutActProperties, pfnCtxActCallback,
                                      dwContext & CLSCTX_INPROC_SERVERS);
            if (FAILED(hrtmp) && SUCCEEDED(hrFinal))
                hrFinal = hrtmp;
            else if (SUCCEEDED(hrtmp))
                hrFinal = hrtmp;

            triedOne = TRUE;

#ifdef WX86OLE
            if (FAILED(hrtmp) &&
                ((actvflags & ACTVFLAGS_WX86_CALLER) == 0) &&
                ((dwContext & CLSCTX_INPROC_SERVERX86) == 0))
            {
                //  If x86 code was not calling and the caller did not specify
                //  an x86 INPROC and the native load above failed then try
                //  to activate an x86 server.
                hrtmp = AttemptActivation(pActIn, pUnkOuter, pInActProperties,
                                          ppOutActProperties, pfnCtxActCallback,
                                          CLSCTX_INPROC_SERVERX86);
                if (FAILED(hrtmp) && SUCCEEDED(hrFinal))
                    hrFinal = hrtmp;
                else if (SUCCEEDED(hrtmp))
                    hrFinal = hrtmp;
            }
#endif
        }
    }

    // Try for an inproc handler
    if (FAILED(hrtmp) && (dwContext & CLSCTX_INPROC_HANDLERS))
    {
#ifdef WX86OLE
        if (actvflags & ACTVFLAGS_WX86_CALLER)
        {
            //  If x86 code is calling then try to activate an x86 server
            //  first.
            hrtmp = AttemptActivation(pActIn, pUnkOuter, pInActProperties,
                                      ppOutActProperties,
                                      pfnCtxActCallback, CLSCTX_INPROC_HANDLERX86);
            if (FAILED(hrtmp) && SUCCEEDED(hrFinal))
                hrFinal = hrtmp;
            else if (SUCCEEDED(hrtmp))
                hrFinal = hrtmp;

            triedOne = TRUE;
        }
#endif

        if (FAILED(hrtmp))
        {
            hrtmp = AttemptActivation(pActIn, pUnkOuter, pInActProperties,
                                   ppOutActProperties, pfnCtxActCallback,
                                   dwContext & CLSCTX_INPROC_HANDLERS);
            if (FAILED(hrtmp) && SUCCEEDED(hrFinal))
                hrFinal = hrtmp;
            else if (SUCCEEDED(hrtmp))
                hrFinal = hrtmp;

            triedOne = TRUE;

#ifdef WX86OLE
            if (FAILED(hrtmp) &&
                ((actvflags & ACTVFLAGS_WX86_CALLER) == 0) &&
                ((dwContext & CLSCTX_INPROC_HANDLERX86) == 0))
            {
                //  If x86 code was not calling and the caller did not specify
                //  an x86 INPROC and the native load above failed then try
                //  to activate an x86 server.
                hrtmp = AttemptActivation(pActIn, pUnkOuter, pInActProperties,
                                         ppOutActProperties,
                                         pfnCtxActCallback, CLSCTX_INPROC_HANDLERX86);
                if (FAILED(hrtmp) && SUCCEEDED(hrFinal))
                    hrFinal = hrtmp;
                else if (SUCCEEDED(hrtmp))
                    hrFinal = hrtmp;
            }
#endif
        }
    }

    // that didn't work, so try a LOCAL_SERVER
    if (FAILED(hrtmp) && (dwContext & CLSCTX_LOCAL_SERVER))
    {
        // Don't need to release this
        IComClassInfo *pCI = pActIn->GetComClassInfo();
        Win4Assert(pCI);

        DWORD stage;
        BOOLEAN fComplusForSure=FALSE;


        if (triedOne)
        for ( stage = CLIENT_CONTEXT_STAGE;
              stage <= SERVER_CONTEXT_STAGE;
              stage++ )
        {
            DWORD cCustomActForStage = 0;
            pCI->GetCustomActivatorCount((ACTIVATION_STAGE)stage,
                                              &cCustomActForStage);

            if (cCustomActForStage)
            {
                fComplusForSure = TRUE;
                break;
            }
        }

        // Retry only if no custom activators
        if (!fComplusForSure || !triedOne)
        {
            hrtmp = AttemptActivation(pActIn, pUnkOuter, pInActProperties,
                               ppOutActProperties, pfnCtxActCallback,
                               CLSCTX_LOCAL_SERVER);
            if (FAILED(hrtmp) && SUCCEEDED(hrFinal))
                hrFinal = hrtmp;
            else if (SUCCEEDED(hrtmp))
                hrFinal = hrtmp;
            
            triedOne = TRUE;
        }
    }
    
    // If we never even tried one of the above, then we need to reset the hr
    // to CLASS_E_CLASSNOTAVAILABLE
    if (!triedOne)
    {
        hrFinal = CLASS_E_CLASSNOTAVAILABLE;
    }

    ClsCacheDebugOut((DEB_TRACE, "CProcessActivator::ActivateByContext OUT hr:0x%x\n", hrFinal));
    return hrFinal;
}



//+----------------------------------------------------------------------------
//
//  Member:        CProcessActivator::AttemptActivation
//
//  Synopsis:      Attempts to activate given a CLSCTX
//
//  History:       27-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CProcessActivator::AttemptActivation(ActivationPropertiesIn     *pActIn,
                                                  IUnknown                   *pUnkOuter,
                                                  IActivationPropertiesIn    *pInActProperties,
                                                  IActivationPropertiesOut  **ppOutActProperties,
                                                  PFNCTXACTCALLBACK           pfnCtxActCallback,
                                                  DWORD                       dwContext)
{
    ISystemActivator *pAptActivator;
    HRESULT hr;

    ASSERT_ONE_CLSCTX(dwContext);

    ClsCacheDebugOut((DEB_TRACE, "CProcessActivator::AttemptActivation IN dwContext:0x%x,"
                      " pActIn:0x%x, pInActProperties:0x%x, ppOutActProperties:0x%x\n",
                       dwContext, pActIn, pInActProperties, ppOutActProperties));

    if (pActIn->GetDip())
    {
        ((DLL_INSTANTIATION_PROPERTIES *)(pActIn->GetDip()))->_dwContext = dwContext;
    }

    hr = (this->*pfnCtxActCallback)(dwContext, pUnkOuter,
                                    pActIn, pInActProperties,
                                    ppOutActProperties);
    ClsCacheDebugOut((DEB_TRACE, "CProcessActivator::AttemptActivation OUT hr:0x%x\n", hr));
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:      GCOCallback
//
//  Synopsis:      Call back for each context attemp
//
//  History:       27-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CProcessActivator::GCOCallback(DWORD                       dwContext,
                                       IUnknown                   *pUnkOuter,
                                       ActivationPropertiesIn     *pActIn,
                                       IActivationPropertiesIn    *pInActProperties,
                                       IActivationPropertiesOut  **ppOutActProperties)
{

    ClsCacheDebugOut((DEB_TRACE, "GCOCallback IN dwContext:0x%x, pActIn:0x%x,"
                      " pInActProperties:0x%x, ppOutActProperties:0x%x\n",
                      dwContext, pActIn, pInActProperties, ppOutActProperties));

    Win4Assert(pUnkOuter == NULL);

    HRESULT hr;
    ISystemActivator *pAptActivator;

    ASSERT_ONE_CLSCTX(dwContext);



    //
    // get the apartment activator
    //

    hr = GetApartmentActivator(pActIn, &pAptActivator);
    if (SUCCEEDED(hr))
    {
        //
        // switch to the server apartment and attempt the
        // activation there
        //

        hr = pAptActivator->GetClassObject(pInActProperties,ppOutActProperties);
        pAptActivator->Release();
    }

    ClsCacheDebugOut((DEB_TRACE, "GCOCallback OUT hr:0x%x\n", hr));
    return hr;

}

//+----------------------------------------------------------------------------
//
//  Function:      CCICallback
//
//  Synopsis:      callback for each context attempt
//
//  History:       27-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CProcessActivator::CCICallback(DWORD                       dwContext,
                                       IUnknown                   *pUnkOuter,
                                       ActivationPropertiesIn     *pActIn,
                                       IActivationPropertiesIn    *pInActProperties,
                                       IActivationPropertiesOut  **ppOutActProperties)
{
    ISystemActivator *pAptActivator;
    HRESULT hr;


    ASSERT_ONE_CLSCTX(dwContext);

    hr = GetApartmentActivator(pActIn, &pAptActivator);

    if (SUCCEEDED(hr))
    {


        // Figure out of we have aggregation and if it is OK
        // Note: if the apartment activatior is in a different
        // apartment the flag should be set to false already
        if (pUnkOuter)
        {
            ContextInfo *pActCtxInfo = NULL;

            pActCtxInfo = pActIn->GetContextInfo();

            Win4Assert(pActCtxInfo != NULL);

            BOOL fClientContextOK;

            hr = pActCtxInfo->IsClientContextOK(&fClientContextOK);
            CHECK_HRESULT(hr);

            if (!fClientContextOK)
            {
                hr = CLASS_E_NOAGGREGATION;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pAptActivator->CreateInstance(pUnkOuter,pInActProperties,ppOutActProperties);
        }

        pAptActivator->Release();
    }

    ClsCacheDebugOut((DEB_TRACE, "CCICallBack OUT hr:0x%x\n", hr));
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CApartmentActivator::ContextMaker , private
//
//  Synopsis:
//
//  History:    06-Mar-98   SatishT      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CApartmentActivator::ContextSelector(
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT BOOL &fCurrentContextOK,
                    OUT CObjectContext *&pContext)
{
    TRACECALL(TRACE_ACTIVATION, "CApartmentActivator::ContextMaker");
    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::ContextMaker [IN]\n"));

    HRESULT hr = E_FAIL;

    // This is a fake QI that gives back a non-refcounted pointer to the
    // actual class
    ActivationPropertiesIn *pActIn=NULL;
    hr = pInActProperties->QueryInterface(
                                        CLSID_ActivationPropertiesIn,
                                        (LPVOID*)&pActIn
                                        );
    Win4Assert((hr == S_OK) && (pActIn != NULL));

    IActivationStageInfo *pStageInfo = (IActivationStageInfo*) pActIn;

    hr = pStageInfo->SetStageAndIndex(SERVER_CONTEXT_STAGE,0);
    CHECK_HRESULT(hr);

    ContextInfo *pActCtxInfo = pActIn->GetContextInfo();
    Win4Assert(pActCtxInfo != NULL);

    // Check whether the target context was overridden. If it was,
    // then I can tell you right now that client context is not OK.

    if(pActCtxInfo->_ctxOverride != GUID_NULL)
    {
        // Client context is NOT OK
        fCurrentContextOK = FALSE;

        // Lookup the existing context
        LOCK(gContextLock);
        pContext = CCtxTable::LookupExistingContext(pActCtxInfo->_ctxOverride);
        UNLOCK(gContextLock);

        if(!pContext)
            return E_UNEXPECTED;
        return S_OK;
    }

    // This initialization assumes fCurrentContextOK -- we will reset
    // if we conclude later after much debate that fCurrentContextOK==FALSE
    pContext = NULL;

    hr = pActCtxInfo->IsClientContextOK(&fCurrentContextOK);
    CHECK_HRESULT(hr);

    // Pick the context we are going to use as the server context
    if (!fCurrentContextOK)
    {
        // Note: fProtoExists does not imply !fProtoEmpty
        //       fProtoEmpty does not imply !fProtoExists
        //       !fProtoExists does imply fProtoEmpty
        BOOL fProtoExists = TRUE,   //  was the prototype context ever created?
             fProtoEmpty = TRUE;    //  is the theoretical prototype context empty?
        CObjectContext *pProtoContext = NULL;
        hr = pActCtxInfo->PrototypeExists(&fProtoExists);
        CHECK_HRESULT(hr);

        if (fProtoExists)
        {
            // we initialized fProtoEmpty to TRUE but it might be FALSE
            hr = pActCtxInfo->GetInternalPrototypeContext(&pProtoContext);
            CHECK_HRESULT(hr);
            Win4Assert(pProtoContext);
            fProtoEmpty = IsEmptyContext(pProtoContext);
        }

        if (fProtoEmpty)
        {
            // prototype context is empty -- if the current context is
            // also empty we will just activate in the current context
            CObjectContext *pCurrentContext = NULL;
            hr = PrivGetObjectContext(IID_IStdObjectContext,
                                      (LPVOID*)&pCurrentContext);
            CHECK_HRESULT(hr);
            Win4Assert(pCurrentContext);

            if (pCurrentContext->GetCount() == 0)
            {
                fCurrentContextOK = TRUE;
            }

            pCurrentContext->InternalRelease();
        }

        // Here is where we find an existing context if possible
        // This should set fCurrentContextOK if prototype is
        // found to be equivalent
        if (!fCurrentContextOK)
        {
            CObjectContext* pMatchingContext = NULL;

            // Prefix says we might not have a prototype context available 
            // here.  Should never happen with our current code, but humor
            // the prefix gods anyway.  
            hr = E_UNEXPECTED;
            Win4Assert(pProtoContext);

            if (pProtoContext)
            {
                // Freeze the prototype context for now and forever..
                hr = pProtoContext->Freeze();

                if(SUCCEEDED(hr))
                {
                    // Here is where we find an existing context if possible
                    ASSERT_LOCK_NOT_HELD(gContextLock);
                    LOCK(gContextLock);

                    pMatchingContext = CCtxTable::LookupExistingContext(pProtoContext);

                    // Release lock
                    UNLOCK(gContextLock);
                    ASSERT_LOCK_NOT_HELD(gContextLock);

                    if(NULL != pMatchingContext)
                    {
                        ComDebOut((DEB_ACTIVATE, "CApartmentActivator::ContextSelector found matching context %p [IN]\n", pMatchingContext));

                        // We found an existing context which matches the prototype context
                        // Discard the prototype context and use the existing context
                        // Lookup would have addrefed the context
                        pProtoContext->InternalRelease();
                        pProtoContext = pMatchingContext;

                        // Check if the client context is the same as the
                        // matched context
                        CObjectContext* pClientContext = NULL;
                        hr = pActIn->GetContextInfo()->GetInternalClientContext(&pClientContext);
                        if(SUCCEEDED(hr) && pClientContext)
                        {
                            if (pMatchingContext == pClientContext)
                            {
                                CObjectContext *pCurrentContext;
                                hr = PrivGetObjectContext(IID_IStdObjectContext,
                                                    (void **) &pCurrentContext);

                                Win4Assert(SUCCEEDED(hr));

                                // If the client context is the same as the
                                // matched context and current context
                                // then the current context is OK
                                if (pCurrentContext == pClientContext)
                                    fCurrentContextOK = TRUE;

                                pCurrentContext->InternalRelease();
                            }

                            pClientContext->InternalRelease();
                        }
                    }
                    else
                    {
                        // Darn! We did not find an existing context matching the prototype
                        // context.

                        // Add the context to the hash table which will facilitate finding
                        // a matching context later
                        hr = CCtxTable::AddContext((CObjectContext *)pProtoContext);
                    }
                }
            }
        }

        if (FAILED(hr))
            goto exit_point;

        if(!fCurrentContextOK)
        {
            // Check to see if we are allowed to switch contexts
            // for this requested class
            IComClassInfo *pClassInfo = NULL;
            //This does not need to be released
            pClassInfo = pActIn->GetComClassInfo();
            BOOL fCreateOnlyInCC=FALSE;
            hr = pClassInfo->MustRunInClientContext(&fCreateOnlyInCC);
            if (SUCCEEDED(hr) && fCreateOnlyInCC)
            {
               pProtoContext->InternalRelease();
               hr = CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT;
               goto exit_point;
            }

            pContext = pProtoContext;
        }
        else
        {
            // get rid of our reference to pProtoContext if we have one
            if (pProtoContext) pProtoContext->InternalRelease();
        }
    }

exit_point:

    // at this point we own a reference to pContext if it is not NULL

    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::ContextMaker [OUT] hr:%x\n", hr));

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CApartmentActivator::ContextCallHelper , private
//
//  Synopsis:
//
//  History:    06-Mar-98   SatishT      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CApartmentActivator::ContextCallHelper(
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties,
                    PFNCTXCALLBACK pfnCtxCallBack,
                    CObjectContext *pContext)
{
    TRACECALL(TRACE_ACTIVATION, "CApartmentActivator::ContextCallHelper");
    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::ContextCallHelper [IN]\n"));

    HRESULT hr = E_FAIL;
    HRESULT hrSave = E_FAIL;

    // Must use new since there is a constructor/destructor for one of the fields
    ServerContextWorkData *pServerContextWorkData = new ServerContextWorkData;
    if ( pServerContextWorkData == NULL )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {

        pServerContextWorkData->pInActProps = pInActProperties;

        // Get inside the server context, do the work and get out with marshalled
        // out activation properties -- the function parameter does CGCO or CCI
        hr = hrSave = pContext->DoCallback(pfnCtxCallBack,
                                           pServerContextWorkData,
                                           IID_ISystemActivator,
                                           0
                                           );
    }

    // Our reference should now be released
    pContext->InternalRelease();

    if ( SUCCEEDED(hr) )
    {
        IStream *pStream = &pServerContextWorkData->xrpcOutProps;

        // reset the stream to the beginning before unmarshalling
        LARGE_INTEGER  lSeekStart;
        lSeekStart.LowPart  = 0;
        lSeekStart.HighPart = 0;
        hr = pStream->Seek(lSeekStart, STREAM_SEEK_SET, NULL);
        CHECK_HRESULT(hr);

        hr = CoUnmarshalInterface(
                         pStream,
                         IID_IActivationPropertiesOut,
                         (LPVOID*) ppOutActProperties
                         );
    }

    if ( pServerContextWorkData != NULL)
    {
        delete pServerContextWorkData;
    }

    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::ContextCallHelper [OUT] hr:%x\n", hr));

    if (SUCCEEDED(hr))
    {
       Win4Assert(SUCCEEDED(hrSave));
       if (*ppOutActProperties)
       {
           CHECKREFCOUNT(*ppOutActProperties,1);
       }
       return hrSave;
    }
    else
    {
       return hr;
    }

}

//+-------------------------------------------------------------------------
//
//  Implementation of callback functions for server context activation.
//
//+-------------------------------------------------------------------------

HRESULT __stdcall DoServerContextGCO(void *pv)
{
    ServerContextWorkData *pData = (ServerContextWorkData*) pv;
    IActivationPropertiesOut *pOutActProperties = NULL;

    HRESULT hrSave;
    HRESULT hr = hrSave = pData->pInActProps->DelegateGetClassObject(&pOutActProperties);

    if ( SUCCEEDED(hr) )
    {
        hr = CoMarshalInterface(&pData->xrpcOutProps,
                                IID_IActivationPropertiesOut,
                                (IUnknown*)pOutActProperties,
                                MSHCTX_CROSSCTX,
                                NULL,
                                MSHLFLAGS_NORMAL);
    }

    // the ref is now in the marshalled packet if we had anything useful
    if (pOutActProperties) pOutActProperties->Release();

    if (SUCCEEDED(hr))
    {
       Win4Assert(SUCCEEDED(hrSave));
       return hrSave;
    }
    else
    {
       return hr;
    }

}

HRESULT __stdcall DoServerContextCCI(void *pv)
{
    ServerContextWorkData *pData = (ServerContextWorkData*) pv;
    IActivationPropertiesOut *pOutActProperties = NULL;
	
    // Code to prevent cross-context aggregation is in CServerContextActivator::CreateInstance
    HRESULT hrSave;
    HRESULT hr = hrSave = pData->pInActProps->DelegateCreateInstance(NULL,&pOutActProperties);

    if(SUCCEEDED(hr))
    {
        hr = CoMarshalInterface(&pData->xrpcOutProps,
                                IID_IActivationPropertiesOut,
                                (IUnknown*)pOutActProperties,
                                MSHCTX_CROSSCTX,
                                NULL,
                                MSHLFLAGS_NORMAL);
    }

    // the ref is now in the marshalled packet if we had anything useful
    if (pOutActProperties) pOutActProperties->Release();

    if (SUCCEEDED(hr))
    {
       Win4Assert(SUCCEEDED(hrSave));
       return hrSave;
    }
    else
    {
       return hr;
    }

}

//+--------------------------------------------------------------------------
//
//  Member:     CApartmentActivator::GetClassObject , public
//
//  Synopsis:
//
//  History:    06-Mar-98   SatishT      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CApartmentActivator::GetClassObject(
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    TRACECALL(TRACE_ACTIVATION, "CApartmentActivator::GetClassObject");
    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::GetClassObject [IN]\n"));

    CObjectContext *pContext = NULL;
    BOOL fCurrentContextOK = FALSE;

    Win4Assert(NULL == *ppOutActProperties);


    HRESULT hr = ContextSelector(
                            pInActProperties,
                            fCurrentContextOK,
                            pContext
                            );

    if ( SUCCEEDED(hr) )
    {
        if (fCurrentContextOK)
        {
            Win4Assert(pContext == NULL);
            // we are instantiating in the current context, so just delegate
            hr = pInActProperties->DelegateGetClassObject(ppOutActProperties);
        }
        else
        {
            hr = ContextCallHelper(
                                pInActProperties,
                                ppOutActProperties,
                                DoServerContextGCO,
                                pContext
                                );
        }
    }

    if (*ppOutActProperties)
    {
        CHECKREFCOUNT(*ppOutActProperties,1);
    }

    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::GetClassObject [OUT] hr:%x\n", hr));

    return hr;
}

STDAPI CoGetDefaultContext(APTTYPE aptType, REFIID riid, void** ppv);

//+--------------------------------------------------------------------------
//
//  Member:     CApartmentActivator::CreateInstance , public
//
//  Synopsis:
//
//  History:    06-Mar-98   SatishT      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CApartmentActivator::CreateInstance(
                    IN  IUnknown *pUnkOuter,
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    TRACECALL(TRACE_ACTIVATION, "CApartmentActivator::GetClassObject");
    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::GetClassObject [IN]\n"));

    Win4Assert(NULL == *ppOutActProperties);

    // First, handle MustRunInDefaultContext property. This must be done
    // here as it requires knowledge of object's intended apartment.
    // COM Services doesn't have such knowledge, Stage-5 activators execute
    // AFTER the target context is selected, so this is only logical...

    IComClassInfo2 *pClassInfo2 = NULL;
    HRESULT hr = pInActProperties->GetClassInfo(IID_IComClassInfo2, (void**) &pClassInfo2);
    if(SUCCEEDED(hr))
    {
        BOOL bMustRunInDefaultContext = FALSE;
        hr = pClassInfo2->MustRunInDefaultContext(&bMustRunInDefaultContext);
        pClassInfo2->Release();

        if(SUCCEEDED(hr) && bMustRunInDefaultContext)
        {
            IGetContextId *pGetCtxtId = NULL;
            IOverrideTargetContext *pOverride = NULL;
            GUID ctxtId;

            hr = CoGetDefaultContext(APTTYPE_CURRENT, IID_IGetContextId, (void**) &pGetCtxtId);
            if(FAILED(hr)) goto exit;

            hr = pGetCtxtId->GetContextId(&ctxtId);
            pGetCtxtId->Release();
            if(FAILED(hr)) goto exit;

            hr = pInActProperties->QueryInterface(IID_IOverrideTargetContext, (void**) &pOverride);
            if(FAILED(hr)) goto exit;

            pOverride->OverrideTargetContext(ctxtId);
            pOverride->Release();
        }
    }

    // Then go about our other business...

    CObjectContext *pContext;
    BOOL fCurrentContextOK;

    pContext = NULL;
    fCurrentContextOK = FALSE;

    hr = ContextSelector(
                            pInActProperties,
                            fCurrentContextOK,
                            pContext
                            );

    if ( SUCCEEDED(hr) )
    {
        if (fCurrentContextOK)
        {
            Win4Assert(pContext == NULL);
            // we are instantiating in the current context, so just delegate
            hr = pInActProperties->DelegateCreateInstance(pUnkOuter,ppOutActProperties);
        }
        else
        {
            hr = ContextCallHelper(
                                pInActProperties,
                                ppOutActProperties,
                                DoServerContextCCI,
                                pContext
                                );
        }
    }

    if (*ppOutActProperties)
    {
        CHECKREFCOUNT(*ppOutActProperties,1);
    }

exit:
    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::CreateInstance [OUT] hr:%x\n", hr));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Helpers related to the activator architecture.
//
//+-------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Helper to register apartment activator for current apartment.
//  Do the registration only if the current apartment is unregistered.
//
//+-------------------------------------------------------------------------
HRESULT RegisterApartmentActivator(HActivator &hActivator)
{
    CURRENT_CONTEXT_EMPTY   // don't do this in a non-default context

    HRESULT hr = E_FAIL;

    HAPT hApt = GetCurrentApartmentId();
    ApartmentEntry *pEntry = gApartmentTbl.Lookup(hApt);

    if (NULL == pEntry)     // the expected case
    {
        hr = gApartmentTbl.AddEntry(hApt,hActivator);
    }
    else
    {
        Win4Assert(0 && "RegisterApartmentActivator found existing entry");
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Helper to revoke apartment activator for current apartment.
//  Used in cleanup in CDllHost.
//
//+-------------------------------------------------------------------------
HRESULT RevokeApartmentActivator()
{
    HRESULT hr = S_OK;

    HAPT hApt = GetCurrentApartmentId();
    ApartmentEntry *pEntry = gApartmentTbl.Lookup(hApt);

    if (pEntry == NULL)
    {
        hr = E_FAIL;
    }
    else
    {
        // This call will delete the pEntry memory
        hr = gApartmentTbl.ReleaseEntry(pEntry);
    }

    return hr;
}


// CODEWORK:  These aren't the most efficient ways to do this -- we should switch
//          over to agile proxies as in the previous DllHost code ASAP



//+-------------------------------------------------------------------------
//
//  Helper to find or create apartment activator for current apartment.
//
//+-------------------------------------------------------------------------
HRESULT GetCurrentApartmentToken(HActivator &hActivator, BOOL fCreate)
{
    HRESULT hr = E_FAIL;

    HAPT hApt = GetCurrentApartmentId();
    ApartmentEntry *pEntry = gApartmentTbl.Lookup(hApt);
    if (NULL != pEntry)     // Previously registered
    {
        hActivator = pEntry->hActivator;
        hr = S_OK;
    }
    else if(fCreate)       // Not yet registered
    {
        hr = RegisterApartmentActivator(hActivator);
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Globals related to the activator architecture.
//
//+-------------------------------------------------------------------------


// The One and Only Client Context Standard Activator
CClientContextActivator gComClientCtxActivator;

// The One and Only Process Standard Activator
CProcessActivator gComProcessActivator;

// The One and Only Server Context Standard Activator
CServerContextActivator gComServerCtxActivator;

// The One and Only Apartment Activator
CApartmentActivator gApartmentActivator;


//+-------------------------------------------------------------------------
//
//  Helper to find the end of delegation chain at each activation stage.
//
//+-------------------------------------------------------------------------
ISystemActivator *GetComActivatorForStage(ACTIVATION_STAGE stage)
{
    switch (stage)
    {
    case CLIENT_CONTEXT_STAGE:
        return gComClientCtxActivator.GetSystemActivator();

    case CLIENT_MACHINE_STAGE:
        Win4Assert(0 && "CLIENT_MACHINE_STAGE reached in OLE32");
        return NULL;

    case SERVER_MACHINE_STAGE:
        Win4Assert(0 && "SERVER_MACHINE_STAGE reached in OLE32");
        return NULL;

    case SERVER_PROCESS_STAGE:
        return gComProcessActivator.GetSystemActivator();

    case SERVER_CONTEXT_STAGE:
        return gComServerCtxActivator.GetSystemActivator();
    default:
        Win4Assert(0 && "Default reached in GetComActivatorForStage");
        return NULL;

    }
}


//+-------------------------------------------------------------------------
//
//  Helper to check if a context is empty/default.
//
//+-------------------------------------------------------------------------
BOOL IsEmptyContext(CObjectContext *pContext)
{
    Win4Assert(pContext && "IsEmptyContext called with NULL context");
    BOOL fResult = pContext->GetCount() == 0;
    return fResult;
}


//+------------------------------------------------------------------------
//
//       Implementations of CApartmentHashTable methods
//
//+------------------------------------------------------------------------


//+--------------------------------------------------------------------------
//
//  Member:     CApartmentHashTable::AddEntry , public
//
//  Synopsis:   Register a new apartment activator in the global table.
//
//  History:    28-Feb-98   SatishT      Created
//
//----------------------------------------------------------------------------
HRESULT CApartmentHashTable::AddEntry(HAPT hApt, HActivator &hActivator)
{
    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);

    DWORD dwAAmshlflags = MSHLFLAGS_TABLESTRONG | MSHLFLAGS_AGILE | MSHLFLAGS_NOPING;
    HRESULT hr = RegisterInterfaceInStdGlobal((IUnknown*)&gApartmentActivator,
                                              IID_ISystemActivator,
                                              dwAAmshlflags,
                                              &hActivator);

    if (SUCCEEDED(hr))
    {
        ApartmentEntry *pApartmentEntry = new ApartmentEntry;
        if ( pApartmentEntry == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pApartmentEntry->hActivator = hActivator;
            ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
            LOCK(_mxsAptTblLock);
            _hashtbl.Add(hApt, hApt, &pApartmentEntry->node);
            UNLOCK(_mxsAptTblLock);
            ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
        }
    }

    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CApartmentHashTable::Lookup , public
//
//  Synopsis:   Lookup an apartment activator in the global table,
//              given the current apartment ID.
//
//  History:    28-Feb-98   SatishT      Created
//
//----------------------------------------------------------------------------
ApartmentEntry *CApartmentHashTable::Lookup(HAPT hApt)
{
    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
    LOCK(_mxsAptTblLock);

    ApartmentEntry *pResult = (ApartmentEntry*) _hashtbl.Lookup(hApt, hApt);

    UNLOCK(_mxsAptTblLock);
    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
    return pResult;
}

//+--------------------------------------------------------------------------
//
//  Member:     CApartmentHashTable::ReleaseEntry , public
//
//  Synopsis:   Remove an apartment's entry in the global table,
//              given the entry itself.
//
//  History:    28-Feb-98   SatishT      Created
//
//----------------------------------------------------------------------------
HRESULT CApartmentHashTable::ReleaseEntry(ApartmentEntry *pEntry)
{
    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
    HRESULT hr = RevokeInterfaceFromStdGlobal(pEntry->hActivator);

    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
    LOCK(_mxsAptTblLock);

    _hashtbl.Remove(&pEntry->node.chain);

    UNLOCK(_mxsAptTblLock);
    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);

    delete pEntry;

    return hr;
}


//  This is defined in ..\com\dcomrem\hash.cxx
void DummyCleanup( SHashChain *pIgnore );


//+--------------------------------------------------------------------------
//
//  Member:     CApartmentHashTable::Cleanup , public
//
//  Synopsis:   Remove an apartment's entry in the global table,
//              given the entry itself.
//
//  History:    28-Feb-98   SatishT      Created
//
//----------------------------------------------------------------------------
void CApartmentHashTable::Cleanup()
{
    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
    LOCK(_mxsAptTblLock);

    if(_fTableInitialized){
        _hashtbl.Cleanup(DummyCleanup);
    }

    UNLOCK(_mxsAptTblLock);
    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
}


//+--------------------------------------------------------------------------
//
//  Member:     ActivationThreadCleanup, public
//
//  Synopsis:   This routine is called when an apartment is being uninitialized
//              It should cleanup per apartment structures
//
//  History:    07-Mar-98   Gopalk      Created
//
//----------------------------------------------------------------------------
void ActivationAptCleanup()
{
    // Delete ObjServer
    ObjactThreadUninitialize();

    // Revoke apartment activator
    RevokeApartmentActivator();

    return;
}


//+--------------------------------------------------------------------------
//
//  Member:     ActivationProcessCleanup, public
//
//  Synopsis:   This routine is called when an process is being uninitialized
//              It should cleanup per process structures
//
//  History:    07-Mar-98   Gopalk      Created
//
//----------------------------------------------------------------------------
void ActivationProcessCleanup()
{
    // Cleanup apartment table
    gApartmentTbl.Cleanup();

    return;
}


//+--------------------------------------------------------------------------
//
//  Member:     ActivationProcessInit, public
//
//  Synopsis:   This routine is called when an process is being initialized
//              It should initialize per process structures
//
//  History:    07-Mar-98   Gopalk      Created
//
//----------------------------------------------------------------------------
HRESULT ActivationProcessInit()
{
    HRESULT hr = S_OK;

    // Initialize apartment table
    gApartmentTbl.Initialize();

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     LoadPersistentObject, public
//
//  Synopsis:
//
//  History:    18-Mar-98   Vinaykr      Created
//
//----------------------------------------------------------------------------
HRESULT LoadPersistentObject(
                             IUnknown *pobj,
                             IInstanceInfo *pInstanceInfo)
{
    HRESULT hr = E_FAIL;

    XIPersistStorage xipstg;
    XIPersistFile xipfile;
    IStorage *pstg;
    hr = pInstanceInfo->GetStorage(&pstg);
    if (FAILED(hr))
        return hr;

    // First check if storage is requested
    if (pstg)
    {
        // Load the storage requested as a template
        if ((hr = pobj->QueryInterface(IID_IPersistStorage, (void **) &xipstg))
                == S_OK)
        {
            hr = xipstg->Load(pstg);
        }
        pstg->Release();
    }
    else // check for File
    {
        DWORD mode;
        WCHAR *path;
        pInstanceInfo->GetFile(&path, &mode);
        if ((hr = pobj->QueryInterface(IID_IPersistFile, (void **) &xipfile))
                == S_OK)
        {
            hr = xipfile->Load(path, mode);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\mkparse.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       mkparse.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    06-Nov-92  jasonful  Created
//              12-27-93   ErikGav   Commented
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "ccompmon.hxx"
#include "citemmon.hxx"
#include "mnk.h"

// Moved here as a temporary measure since this macro is not used in 32 bit
#define RetErr(x) {HRESULT hresult; if (NOERROR != (hresult=(x))) {return hresult;}}

// INTERNAL Ole10_ParseMoniker
//
// If pmk is a file moniker or a file::item composite, then return
// the obvious strings in *pszFile and *pszItem.
// NOTE: these strings must be deleted.
// Return error if moniker is of some other type.
//
// Can pass NULL, meaning you don't care about the strings
//
INTERNAL Ole10_ParseMoniker
	(LPMONIKER pmk,
	LPWSTR FAR* pszFile,
	LPWSTR FAR* pszItem)
{
	LPWSTR	  szFile = NULL;
	LPWSTR	  szItem = NULL;
	LPMONIKER pmkFile= NULL;
	LPMONIKER pmkItem= NULL;
	HRESULT   hr 	 = ResultFromScode (E_UNSPEC);
	LPBC	pbc = NULL;

	CCompositeMoniker *pCMk = NULL;
	CItemMoniker	  *pIMk = NULL;

    if (pmk == NULL)
    {
		hr = ResultFromScode (E_UNSPEC);
		goto errRtn;
	}

	if (IsFileMoniker(pmk))
	{
		RetErr (CreateBindCtx(0, &pbc));
		Assert(pbc != NULL);
		if (NOERROR != pmk->GetDisplayName (pbc, NULL, &szFile))
		{
			Assert(szFile == NULL);
			CairoleAssert(0 && "Could not get Display name for file piece");
			goto errRtn;
		}
		// AssertOutPtrParam(NOERROR, szFile);
	}
	else if ((pCMk = IsCompositeMoniker(pmk)) != NULL)
	{
		pmkFile = pCMk->First();
		if (NULL==pmkFile)
		{
			CairoleAssert(0 && "Composite moniker does not have car");
			hr = ResultFromScode(E_UNSPEC);
			goto errRtn;	
		}
		// Is first piece a file moniker?
		if (IsFileMoniker (pmkFile))
		{
			RetErr (CreateBindCtx(0, &pbc));
			Assert(pbc != NULL);
			if (NOERROR != pmkFile->GetDisplayName (pbc, NULL, &szFile))
			{
				Assert(szFile == NULL);
				CairoleAssert(0 && "Could not get Display name for file piece");
				goto errRtn;
			}
			// AssertOutPtrParam(NOERROR, szFile);
		}
		else
		{
			CairoleAssert(0 && "First piece is not a file moniker");
			hr = NOERROR;
			goto errRtn;
		}

		// Get Item Moniker

		pmkItem = pCMk->AllButFirst();
		if (NULL==pmkItem)
		{
			CairoleAssert(0 && "Composite moniker does not have cdr");
			hr = ResultFromScode(E_UNSPEC);
			goto errRtn;	
		}
		if ((pIMk = IsItemMoniker (pmkItem)) != NULL)
		{
			// This is the case we want: FileMoniker :: ItemMoniker

			if (NULL==(szItem = pIMk->m_lpszItem))
			{
				CairoleAssert(0 && "Could not get string for item moniker");
				goto errRtn;
			}
			szItem = UtDupString (szItem); // so it'll be allocated like
 										  // an out parm from GetDisplayName
		}
		else
		{
			// This is the FileMoniker - ItemMoniker - ItemMoniker... case
			// We cannot convert this to 1.0
			hr = ResultFromScode(S_FALSE);
			goto errRtn;
		}
	}
	else
	{
		CairoleAssert(0 && "Cannot identify moniker type");
		hr = ResultFromScode (E_UNSPEC);
		goto errRtn;
	}

	if (pszFile)
		*pszFile = szFile;
	else
		CoTaskMemFree(szFile);

	if (pszItem)
		*pszItem = szItem;
	else
		CoTaskMemFree(szItem);

	if (pmkFile)
		pmkFile->Release();
	if (pmkItem)
		pmkItem->Release();

	if (pbc)
		pbc->Release();

	return NOERROR;

  errRtn:
	CoTaskMemFree(szFile);
	CoTaskMemFree(szItem);
	if (pmkFile)
		pmkFile->Release();
	if (pmkItem)
		pmkItem->Release();
	if (pbc)
		pbc->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\moniker2\mnk.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       mnk.h
//
//  Contents:   Internal moniker functions
//
//  Classes:
//
//  Functions:
//
//  History:	12-27-93   ErikGav   Created
//		06-14-94   Rickhi    Fix type casting
//              12-01-95   MikeHill  Added prototype for ValidateBindOpts().
//
//----------------------------------------------------------------------------

INTERNAL_(DWORD) GetMonikerType( LPMONIKER pmk );

//  The following APIs determine if the given moniker is of the specified
//  class and if so, return a pointer to the C++ class IN A TYPE SAFE WAY!
//
//  NEVER do the casting directly, always use these APIs to do it for you!

class CCompositeMoniker;
class CPointerMoniker;
class CAntiMoniker;
class CFileMoniker;
class CItemMoniker;

INTERNAL_(CCompositeMoniker *) IsCompositeMoniker( LPMONIKER pmk );
INTERNAL_(CPointerMoniker *) IsPointerMoniker( LPMONIKER pmk );
INTERNAL_(CAntiMoniker *) IsAntiMoniker( LPMONIKER pmk );
INTERNAL_(CFileMoniker *) IsFileMoniker( LPMONIKER pmk );
INTERNAL_(CItemMoniker *) IsItemMoniker( LPMONIKER pmk );

STDAPI Concatenate( LPMONIKER pmkFirst, LPMONIKER pmkRest,
	LPMONIKER FAR* ppmkComposite );

#define BINDRES_INROTREG 1

#define DEF_ENDSERVER 0xFFFF

// STDAPI CreateOle1FileMoniker(LPWSTR, REFCLSID, LPMONIKER FAR*);

#ifdef _CAIRO_
extern
BOOL ValidateBindOpts( const LPBIND_OPTS pbind_opts );
#endif

extern
HRESULT DupWCHARString( LPCWSTR lpwcsString,
			LPWSTR & lpwcsOutput,
			USHORT & ccOutput);
extern
HRESULT ReadAnsiStringStream( IStream *pStm,
			      LPSTR & pszAnsiPath ,
			      USHORT &cbAnsiPath);
extern
HRESULT WriteAnsiStringStream( IStream *pStm,
			       LPSTR pszAnsiPath ,
			       ULONG cbAnsiPath);
extern
HRESULT MnkMultiToUnicode(LPSTR pszAnsiPath,
			  LPWSTR &pWidePath,
			  ULONG ccWidePath,
			  USHORT &ccNewString,
			  UINT nCodePage);
extern
HRESULT
MnkUnicodeToMulti(LPWSTR 	pwcsWidePath,
		  USHORT 	ccWidePath,
		  LPSTR &	pszAnsiPath,
		  USHORT &	cbAnsiPath,
		  BOOL &	fFastConvert);

extern
DWORD CalcFileMonikerHash(LPWSTR lp, ULONG cch);

extern
BOOL IsAbsoluteNonUNCPath (LPCWSTR szPath);

extern
BOOL IsAbsolutePath (LPCWSTR szPath);


#define WIDECHECK(x) (x?x:L"<NULL>")
#define ANSICHECK(x) (x?x:"<NULL>")


#if DBG == 1
    DECLARE_DEBUG(mnk)
#   define mnkDebugOut(x) mnkInlineDebugOut x
#   define mnkAssert(x)   Win4Assert(x)
#   define mnkVerify(x)	 mnkAssert(x)
#else
#   define mnkDebugOut(x)
#   define mnkAssert(x)
#   define mnkVerify(x) 	x

#endif

#define MNK_P_STREAMOP	0x01000000
#define MNK_P_RESOURCE  0x02000000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\dllapi.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dllapi.cxx
//
//  Contents:   API entry points for DLL manipulation
//
//  Functions:  CoLoadLibrary
//              CoFreeLibrary
//              CoFreeAllLibraries
//              CoFreeUnusedLibraries
//
//  History:    12-May-93 Ricksa    Created
//              31-Dec-93 ErikGav   Chicago port
//
//--------------------------------------------------------------------------

#include    <ole2int.h>
#include    <objact.hxx>

STDAPI_(void) CoFreeUnusedLibrariesEx(DWORD dwUnloadDelay, DWORD dwReserved);

//+-------------------------------------------------------------------------
//
//  Function:   CoLoadLibrary
//
//  Synopsis:   Loads a DLL
//
//  Arguments:  [pLibName] - name of DLL to load
//              [fAutoLoad] - whether DLL s/b unloaded automatically.
//
//  Returns:    HINSTANCE
//
//  Algorithm:  Just calls through to the Windows.
//
//  History:    12-May-93 Ricksa    Created
//
//  Notes:      This API is provided for Cross Platform portability.
//
//--------------------------------------------------------------------------
STDAPI_(HINSTANCE) CoLoadLibrary(LPWSTR pLibName, BOOL fAutoLoad)
{
    OLETRACEIN((API_CoLoadLibrary, PARAMFMT("pLibName= %ws, fAutoLoad= %B"), pLibName, fAutoLoad));
    TRACECALL(TRACE_DLL, "CoLoadLibrary");

    HINSTANCE hInst = NULL;

    hInst = LoadLibraryEx(pLibName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    OLETRACEOUTEX((API_CoLoadLibrary, RETURNFMT("%x"), hInst));

    return hInst;
}


//+-------------------------------------------------------------------------
//
//  Function:   CoFreeLibrary
//
//  Synopsis:   Used to free a DLL loaded by CoLoadLibrary.
//
//  Arguments:  [hInst] - handle to DLL
//
//  Algorithm:  Just passes through call to the OS
//
//  History:    12-May-93 Ricksa    Created
//
//  Notes:      This API is provided for Cross Platform portability.
//
//--------------------------------------------------------------------------
STDAPI_(void) CoFreeLibrary(HINSTANCE hInst)
{
    OLETRACEIN((API_CoFreeLibrary, PARAMFMT("hInst= %x"), hInst));
    TRACECALL(TRACE_DLL, "CoFreeLibrary");

    FreeLibrary(hInst);

    OLETRACEOUTEX((API_CoFreeLibrary, NORETURN));
}


//+-------------------------------------------------------------------------
//
//  Function:   CoFreeAllLibraries
//
//  Synopsis:   Free all libraries
//
//  History:    12-May-93 Ricksa    Created
//
//  Notes:      All libraries are freed at process exit in Win32 anyway
//              so we just notify any unused libraries that they can
//              go way in the DEV build so memory can be totally cleaned
//              up to facilitate the discovery of memory leaks.
//
//--------------------------------------------------------------------------
STDAPI_(void) CoFreeAllLibraries(void)
{
    OLETRACEIN((API_CoFreeAllLibraries, NOPARAM));

#if DBG == 1
    CoFreeUnusedLibraries();
#endif // DBG

    OLETRACEOUTEX((API_CoFreeAllLibraries, NORETURN));
}

//+-------------------------------------------------------------------------
//
//  Function:   CoFreeUnusedLibraries
//
//  Synopsis:   Free any unused single-threaded DLLS.
//
//  Algorithm:  Ask DLL cache objects to free any DLLs that respond
//              to DllCanUnloadNow with TRUE.
//
//  History:    12-May-93 Ricksa    Created
//
//  Notes:      The DllCanUnloadNow protocol is as follows:
//
//              Apartment Model DLLs: CoFreeUnusedLibraries must be called on
//              each thread that has loaded an object from the DLL, before the
//              DLL will realy be unloaded.
//
//              FreeThreaded DLLs: OLE will wait 10 minutes from the last
//              use of the DLL before unloading it.
//
//--------------------------------------------------------------------------
STDAPI_(void) CoFreeUnusedLibraries(void)
{
    OLETRACEIN((API_CoFreeUnusedLibraries, NOPARAM));
    TRACECALL(TRACE_DLL, "CoFreeUnusedLibraries");

    CoFreeUnusedLibrariesEx(INFINITE, 0);

    OLETRACEOUTEX((API_CoFreeUnusedLibraries, NORETURN));
}

//+-------------------------------------------------------------------------
//
//  Function:   CoFreeUnusedLibraries
//
//  Synopsis:   Free any unused single-threaded DLLS.
//
//  Algorithm:  Ask DLL cache objects to free any DLLs that respond
//              to DllCanUnloadNow with TRUE.
//
//  History:    12-May-93 Ricksa    Created
//
//  Notes:      The DllCanUnloadNow protocol is as follows:
//
//              Apartment Model DLLs: CoFreeUnusedLibraries must be called on
//              each thread that has loaded an object from the DLL, before the
//              DLL will realy be unloaded.
//
//              ThreadNeutral and FreeThreaded DLLs: OLE will wait dwUnloadDelay
//              milliseconds from the last use of the DLL before unloading it.
//
//--------------------------------------------------------------------------
STDAPI_(void) CoFreeUnusedLibrariesEx(DWORD dwUnloadDelay, DWORD dwReserved)
{
    OLETRACEIN((API_CoFreeUnusedLibraries, PARAMFMT("dwUnloadDelay= %x"), dwUnloadDelay));
    TRACECALL(TRACE_DLL, "CoFreeUnusedLibrariesEx");

    HRESULT hr;
    COleTls tls(hr);    // ensure TLS exists

    if (SUCCEEDED(hr))
    {
        if (!IsWOWProcess())
        {
            CCFreeUnused(dwUnloadDelay);
        }
    }

    OLETRACEOUTEX((API_CoFreeUnusedLibraries, NORETURN));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\defcxact.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       defcxact.cxx
//
//  Contents:   Activation Functions used by object servers.
//
//  Classes:    CObjServer
//
//  History:    24-Feb-98 vinaykr   Created/Separated from sobjact
//              15-Jun-98 GopalK    Simplified creation/destruction
//              22-Jun-98 CBiks     See RAID# 169589.  Added the activator
//                                  flags to the ACTIVATION_PROPERTIES
//                                  constructors.
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <iface.h>
#include    <olerem.h>

#include    <cfactory.hxx>
#include    <classmon.hxx>
#include    "resolver.hxx"
#include    "smstg.hxx"
#include    "objact.hxx"
#include    "service.hxx"
#include    <sobjact.hxx>
#include    <comsrgt.hxx>
#include    <security.hxx>

//CObjServer *gpMTAObjServer = NULL;
//static COleStaticMutexSem g_mxsSingleThreadObjReg;

void *GetDestCtxPtr(COMVERSION *pComVersion)
{
    return new CDestObject(*pComVersion, MSHCTX_DIFFERENTMACHINE);
}

extern "C" const GUID GUID_DefaultAppPartition;
const GUID *GetPartitionIDForClassInfo(IComClassInfo *pCI);

//+-------------------------------------------------------------------
//
//  Member:     CObjServer::CObjServer, public
//
//  Synopsis:   construction
//
//  History:    10 Apr 95    AlexMit     Created
//              15 Jun 98    GopalK      Simplified creation
//
//--------------------------------------------------------------------
CObjServer::CObjServer(HRESULT &hr)
{
    OBJREF objref;
    hr = MarshalInternalObjRef(objref, IID_ILocalSystemActivator,
                               (ILocalSystemActivator*) this,
                               MSHLFLAGS_NOPING, (void **) &_pStdID);
    if(SUCCEEDED(hr))
    {
        _ipid = objref.u_objref.u_standard.std.ipid;
        _oxid = objref.u_objref.u_standard.std.oxid;
        SetObjServer(this);
        FreeObjRef(objref);
    }
    else
    {
        _pStdID = NULL;
        _ipid = GUID_NULL;
        _oxid = 0;
    }

    ComDebOut((DEB_ACTIVATE, "CObjServer::CObjServer hr:%x\n", hr));
}

//+-------------------------------------------------------------------
//
//  Member:     CObjServer::~CObjServer, public
//
//  Synopsis:   dtor for activation object
//
//  History:    19 Jun 95   Rickhi      Created
//              15 Jun 98    GopalK     Simplified destruction
//
//--------------------------------------------------------------------
CObjServer::~CObjServer()
{
    if(_pStdID)
    {
        SetObjServer(NULL);
        ((CStdMarshal *) _pStdID)->Disconnect(DISCTYPE_SYSTEM);
        _pStdID->Release();
    }

    ComDebOut((DEB_ACTIVATE, "CObjServer::~CObjServer\n"));
}

//+-------------------------------------------------------------------
//
//  Member:     CObjServer::AddRef, public
//
//  Synopsis:   we dont refcnt this object so this is a noop
//
//  History:    10 Apr 95    AlexMit     Created
//
//--------------------------------------------------------------------
ULONG CObjServer::AddRef(void)
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CObjServer::Release, public
//
//  Synopsis:   we dont refcnt this object so this is a noop
//
//  History:    10 Apr 95    AlexMit     Created
//
//--------------------------------------------------------------------
ULONG CObjServer::Release(void)
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CObjServer::QueryInterface, public
//
//  Synopsis:   returns supported interfaces
//
//  History:    10 Apr 95   AlexMit     Created
//
//--------------------------------------------------------------------
STDMETHODIMP CObjServer::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_ILocalSystemActivator) ||  //   more common than IUnknown
        IsEqualIID(riid, IID_ISystemActivator) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (ILocalSystemActivator *) this;
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CObjServer::LocalGetClassObject
//
//--------------------------------------------------------------------------
STDMETHODIMP CObjServer::GetClassObject(
    IActivationPropertiesIn *pActIn,
    IActivationPropertiesOut **ppActOut)
{
    HRESULT hr;
    CLSID *pClsid = NULL;

    *ppActOut = NULL;
    
    IActivationContextInfo *pCtxInfo=NULL;
    hr = pActIn->QueryInterface(IID_IActivationContextInfo, (void**)&pCtxInfo);

    if (FAILED(hr))
        return hr;
    
    Win4Assert(pCtxInfo);
    
    pCtxInfo->Release(); 

    IComClassInfo *pComClassInfo = NULL;
    hr = pActIn->GetClassInfo(IID_IComClassInfo,(LPVOID*)&pComClassInfo);
    Win4Assert(hr == S_OK);

    hr = pComClassInfo->GetConfiguredClsid(&pClsid);
    Win4Assert(hr == S_OK);
    Win4Assert(pClsid && "Configured class id missing in class info");

    const GUID *pguidPartition = GetPartitionIDForClassInfo(pComClassInfo);

    ComDebOut((DEB_ACTIVATE,
               "CObjServer::LocalGetClassObject clsid:%I\n", pClsid));

    InstantiationInfo *pinst;
    hr = pActIn->QueryInterface(IID_IInstantiationInfo, (LPVOID*)&pinst);
    Win4Assert(hr == S_OK);

    BOOL fSurrogate;
    pinst->GetIsSurrogate(&fSurrogate);
    pinst->Release();

    DWORD dwcount;
    IID *pIID;
    pActIn->GetRequestedIIDs(&dwcount, &pIID);

    if (dwcount != 1)
    {
        pComClassInfo->Release();
        return E_INVALIDARG;
    }

    // Check access.
    if (!CheckObjactAccess())
    {
        pComClassInfo->Release();
        return HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }
    
    IUnknown *pcf;

    // Get the class object
    DWORD actvflags;
    pActIn->GetActivationFlags( &actvflags );

    ACTIVATION_PROPERTIES ap(*pClsid, 
                             *pguidPartition,
                             (fSurrogate ? IID_IClassFactory : *pIID) ,
                             (ACTIVATION_PROPERTIES::fFOR_SCM |
                              (fSurrogate ? ACTIVATION_PROPERTIES::fSURROGATE : 0) |
                              ACTIVATION_PROPERTIES::fDO_NOT_LOAD),
                             CLSCTX_LOCAL_SERVER,
                             actvflags,
                             0,
                             NULL,
                             &pcf,
                             pComClassInfo);

    hr = CCGetOrLoadClass(ap);

    if (hr == S_OK)
    {
        hr = CCLockServerForActivation();
        if (SUCCEEDED(hr)) 
        {
            IActivationProperties *pActProps;
            hr = pActIn->QueryInterface(IID_IActivationProperties,
                                        (void**) &pActProps);
            
            pActProps->SetMarshalFlags(MSHLFLAGS_NOTIFYACTIVATION|MSHLFLAGS_NORMAL);
            Win4Assert(hr==S_OK);
            pActProps->Release();
            
            hr = pActIn->GetReturnActivationProperties(pcf, ppActOut);
            
            CCUnlockServerForActivation();
            
            // marshal should have bumped up the global count by now.
            // make sure the shutdown bit has not been strobed
            
            //        LOCK(CClassCache::_mxs);
            //  if (CClassCache::_dwFlags & CClassCache::fSHUTTINGDOWN) 
            //  {
            //      hr = CO_E_SERVER_STOPPING;
            //      }
            //      UNLOCK(CClassCache::_mxs);
        }

        // Release our Reference
        pcf->Release();
    }
    else
    {
        //It is possible that the error is on a classfactory
        //where the interface is not supported. In this case
        //the server could linger around because the LockServer
        //API is never toggled. We effect this toggling on an
        //error path.
        IClassFactory *pCF;
        if ((*pIID != IID_IClassFactory) && (!fSurrogate))
        {
            HRESULT hr2;
            ACTIVATION_PROPERTIES ap(*pClsid, 
                                     *pguidPartition,
                                     IID_IClassFactory ,
                                     (ACTIVATION_PROPERTIES::fFOR_SCM |
                                      ACTIVATION_PROPERTIES::fDO_NOT_LOAD),
                                     CLSCTX_LOCAL_SERVER,
                                     actvflags,
                                     0,
                                     NULL,
                                     (IUnknown**)&pCF,
                                     pComClassInfo);

            hr2 = CCGetOrLoadClass(ap);
            
            if (SUCCEEDED(hr2))
            {
                pCF->LockServer(TRUE);
                pCF->LockServer(FALSE);
                pCF->Release();
            }
        }
    }

    pComClassInfo->Release();
    
    ComDebOut((DEB_ACTIVATE,
        "CObjServer::LocalGetClassObject hr:%x\n", hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjServer::CreateInstance
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjServer::CreateInstance(
                   /* [in] */  IUnknown *pUnkOuter,
                   /* [in] */  IActivationPropertiesIn *pActIn,
                   /* [out] */ IActivationPropertiesOut **ppActOut)
{
    HRESULT hr;
    CLSID *pClsid = NULL;
    IID *newIIDs;
    DWORD i;
    IPrivActivationPropertiesIn *privActIn;
    COMVERSION version;
    CDestObject destObj;

   *ppActOut = NULL;

    IActivationContextInfo *pCtxInfo=NULL;
    hr = pActIn->QueryInterface(IID_IActivationContextInfo, (void**)&pCtxInfo);

    if (FAILED(hr))
        return hr;

    Win4Assert(pCtxInfo);

    pCtxInfo->Release();

    IComClassInfo * pComClassInfo = NULL;
    hr = pActIn->GetClassInfo(IID_IComClassInfo,(LPVOID*)&pComClassInfo);
    Win4Assert(hr == S_OK);

    hr = pComClassInfo->GetConfiguredClsid(&pClsid);
    Win4Assert(hr == S_OK);
    Win4Assert(pClsid && "Configured class id missing in class info");

    const GUID *pguidPartition = GetPartitionIDForClassInfo(pComClassInfo);

    ComDebOut((DEB_ACTIVATE,
       "CObjServer::CreateInstance clsid:%I\n", pClsid));

    // Check access.
    if (!CheckObjactAccess())
    {
        pComClassInfo->Release();
        return HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }


    hr = pActIn->QueryInterface(IID_IPrivActivationPropertiesIn,
                                (void**) &privActIn);

    privActIn->GetCOMVersion(&version);
    destObj.SetComVersion(version);
    destObj.SetDestCtx(MSHCTX_DIFFERENTMACHINE);


    Win4Assert(hr==S_OK);

    IUnknown *pcf;

    DWORD dwInterfaces=0;
    IID *pIIDs=0;
    MInterfacePointer **ppIFDs=0;
    HRESULT *pResults=0;

    // First check if GetInstanceFrom..Storage/File
    IInstanceInfo *pInstanceInfo = NULL;
    if (pActIn->QueryInterface(IID_IInstanceInfo,
                                   (LPVOID*)&pInstanceInfo) == S_OK)
    {
        DWORD mode;
        WCHAR *path;
        MInterfacePointer *pStg;
        MInterfacePointer *pIFDROT;
        pInstanceInfo->GetFile(&path, &mode);
        pInstanceInfo->GetStorageIFD(&pStg);
        pInstanceInfo->GetIfdROT(&pIFDROT);
	pInstanceInfo->Release();
        hr = pActIn->GetRequestedIIDs(&dwInterfaces, &pIIDs);
        Win4Assert(hr == S_OK);
        ppIFDs = (MInterfacePointer**)
                    _alloca(sizeof(MInterfacePointer*)*dwInterfaces);
        pResults = (HRESULT*)
                    _alloca(sizeof(HRESULT)*dwInterfaces);
        hr = GetPersistentInstance(pClsid,
                                   mode,
                                   path,
                                   pStg,
                                   dwInterfaces,
                                   pIIDs,
                                   pIFDROT,
                                   ppIFDs,
                                   pResults,
                                   &destObj);
         if (hr != S_OK)
            goto exit_CI;
    }
    else // Normal Create Instance
    {

        // Get the class object
        DWORD actvflags;
        pActIn->GetActivationFlags( &actvflags );

        ACTIVATION_PROPERTIES ap(*pClsid, 
                                 *pguidPartition,
                                 IID_IClassFactory,
                                 ACTIVATION_PROPERTIES::fFOR_SCM |
                                 ACTIVATION_PROPERTIES::fDO_NOT_LOAD,
                                 CLSCTX_LOCAL_SERVER,
                                 actvflags,
                                 0,
                                 NULL,
                                 &pcf,
                                 pComClassInfo);
        hr = CCGetOrLoadClass(ap);

        if (SUCCEEDED(hr))
        {
            hr = pActIn->GetRequestedIIDs(&dwInterfaces, &pIIDs);
            Win4Assert(hr == S_OK);

            ppIFDs = (MInterfacePointer**)
                        _alloca(sizeof(MInterfacePointer*)*dwInterfaces);
            pResults = (HRESULT*)
                        _alloca(sizeof(HRESULT)*dwInterfaces);

            // first, check if the server is willing to accept the incoming call
            // on IClassFactory. The reason we need this is that EXCEL's message
            // filter rejects calls on IID_IClassFactory if it is busy. They dont
            // know about IID_ILocalSystemActivator.
            hr = HandleIncomingCall(IID_IClassFactory, 3,
                                    CALLCAT_SYNCHRONOUS,
                                    (void *)pcf);
            if (SUCCEEDED(hr))
            {
                // Load the object
                DWORD flags;

                InstantiationInfo *pinst;
                hr = pActIn->QueryInterface(IID_IInstantiationInfo, (LPVOID*)&pinst);
                Win4Assert(hr == S_OK);

                pinst->GetInstFlag(&flags);
                pinst->Release();

#ifdef SERVER_HANDLER
                if (flags & CREATE_EMBEDDING_SERVER_HANDLER)
                {
                    hr = GetEmbeddingServerHandlerInterfaces((IClassFactory *)pcf,
                                                        flags,
                                                        dwInterfaces,
                                                        pIIDs,
                                                        ppIFDs,
                                                        pResults,
                                                        NULL,
                                                        &destObj);
                }
                else
#endif // SERVER_HANDLER
                {
                    hr = GetInstanceHelperMulti((IClassFactory *)pcf,
                                                    dwInterfaces,
                                                    pIIDs,
                                                    ppIFDs,
                                                    pResults,
                                                    NULL,
                                                    &destObj);
                }
            }
            pcf->Release();
        }
        else
            goto exit_CI;
    }

    IPrivActivationPropertiesOut *privActOut;
    hr = privActIn->PrivGetReturnActivationProperties(&privActOut);
    if (hr != S_OK)
        goto exit_CI;

    hr = privActOut->SetMarshalledResults(dwInterfaces,
                                          pIIDs,
                                          pResults,
                                          ppIFDs);

    // pIIDs belongs to pActIn, so don't free
    for(i=0;i<dwInterfaces;i++)
        MIDL_user_free(ppIFDs[i]);

    *ppActOut = (IActivationPropertiesOut*) privActOut;

    ComDebOut((DEB_ACTIVATE,
       "CObjServer::CreateInstance hr:%x\n", hr));

exit_CI:
    pComClassInfo->Release();
    privActIn->Release();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CObjServer::GetInstance
//
//--------------------------------------------------------------------------
STDMETHODIMP CObjServer::GetPersistentInstance(
                                                GUID *rclsid,
                                                DWORD grfMode,
                                                WCHAR *pwszPath,
                                                MInterfacePointer *pIFDstg,
                                                DWORD Interfaces,
                                                IID *pIIDs,
                                                MInterfacePointer *pIFDFromROT,
                                                MInterfacePointer **ppIFDs,
                                                HRESULT *pResults,
                                                CDestObject *pDestObj)
{
    ComDebOut((DEB_ACTIVATE, "GetInstance clsid:%I\n", rclsid));
    HRESULT hr = S_OK;

    // Check access.
    if (!CheckObjactAccess())
    {
        return HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }

    if (pIFDFromROT != NULL)
    {
        // If the SCM has passed us an object from the ROT, we
        // try to use that first by unmarshalling it and then
        // marshaling it normal.
        CXmitRpcStream xrpcForUnmarshal((InterfaceData*)pIFDFromROT);
        IUnknown *punk;

        hr = CoUnmarshalInterface(&xrpcForUnmarshal, IID_IUnknown,
            (void **) &punk);

        if (SUCCEEDED(hr))
        {
            hr = E_NOINTERFACE;

            for ( DWORD i = 0; i < Interfaces; i++ )
            {
                // Stream to put marshaled interface in
                CXmitRpcStream xrpc;
                HRESULT hr2;

                // use DIFFERENTMACHINE so we get the long form OBJREF
                hr2 = CoMarshalInterface(&xrpc, pIIDs[i], punk,
                    SetMarshalContextDifferentMachine(), pDestObj, MSHLFLAGS_NORMAL);

                if (SUCCEEDED(hr2))
                {
                    // Report OK if any interface is found.
                    hr = hr2;
                    xrpc.AssignSerializedInterface((InterfaceData **) &ppIFDs[i]);
                }
                pResults[i] = hr2;
            }
            // Don't need the unknown ptr any more
            punk->Release();

            ComDebOut((DEB_ACTIVATE, "GetInstance hr:%x\n", hr));
            return hr;
        }

        // Assume any errors are the result of a stale entry in the ROT
        // so we just fall into the regular code path from here.
        hr = S_OK;
    }

    // Get the class object
    DWORD actvflags = ACTVFLAGS_NONE;

#ifdef WX86OLE
    if ( gcwx86.IsWx86Calling() )
    {
        actvflags |= ACTVFLAGS_WX86_CALLER;
    }
#endif

    if ( gCapabilities & EOAC_DISABLE_AAA )
    {
        actvflags |= ACTVFLAGS_DISABLE_AAA;
    }
    
    // REVIEW: I'm not so sure about this DefaultAppPartition here...
    IUnknown *pcf = NULL;
    ACTIVATION_PROPERTIES ap(*rclsid, 
                             GUID_DefaultAppPartition, 
                             IID_IClassFactory,
                             ACTIVATION_PROPERTIES::fFOR_SCM |
                             ACTIVATION_PROPERTIES::fDO_NOT_LOAD,
                             CLSCTX_LOCAL_SERVER,
                             actvflags,
                             0,
                             NULL,
                             &pcf);
    hr = CCGetOrLoadClass(ap);

    if (SUCCEEDED(hr))
    {
      // Unmarshal the storage which we're going to use to initialize the object
      CSafeMarshaledStg smstg( (InterfaceData*) pIFDstg, hr);
      if (SUCCEEDED(hr))
      {
        // first, check if the server is willing to accept the incoming call
        // on IClassFactory. The reason we need this is that EXCEL's message
        // filter rejects calls on IID_IClassFactory if it is busy. They dont
        // know about IID_ILocalSystemActivator.
        hr = HandleIncomingCall(IID_IClassFactory, 3,
          CALLCAT_SYNCHRONOUS,
          (void *)pcf);
        if (SUCCEEDED(hr))
        {
          // Load the object
          hr = GetObjectHelperMulti((IClassFactory *)pcf, grfMode, NULL,
            pwszPath, smstg, Interfaces, pIIDs, ppIFDs, pResults, NULL,
            pDestObj);
        }
      }
      pcf->Release();
    }
    else
    {
      // Need to cleanup the marshaled stg buffer so we don't leak a reference; do 
      // this only if we're not returning CO_E_SERVERSTOPPING, in which case the SCM
      // will be re-trying the activation in a different server and will still want
      // the stg objref to be valid.
      if (hr != CO_E_SERVER_STOPPING)
      {
        // Turn raw marshalled data into a stream
        CXmitRpcStream xrpc((InterfaceData*)pIFDstg);
        
        // Release the data (don't care about the return value here, the original 
        // error code takes precedence)
        CoReleaseMarshalData(&xrpc);
      }
    }

    ComDebOut((DEB_ACTIVATE, "GetInstance hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CObjServer::ObjectServerLoadDll
//
//  Synopsis:   Loads the requested dll into a surrogate process which
//              implements the ISurrogate interface
//
//--------------------------------------------------------------------------
STDMETHODIMP CObjServer::ObjectServerLoadDll(
            /* [in] */ GUID *rclsid,
            /* [out] */ DWORD* pStatus)
{
    ComDebOut((DEB_ACTIVATE, "ObjectServerLoadDll clsid:%I\n", rclsid));

    *pStatus = RPC_S_OK;

    HRESULT hr = CCOMSurrogate::LoadDllServer(*rclsid);

    ComDebOut((DEB_ACTIVATE, "ObjectServerLoadDll hr:%x\n", hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\immact.cxx ===
//+-------------------------------------------------------------------
//
//  File:       immact.cxx
//
//  Contents:   immediate activator
//
//  History:    15-Oct-98   Vinaykr     Created
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <immact.hxx>

//----------------------------------------------------------------------------
// Internal class factory for the COM Activator
//----------------------------------------------------------------------------
HRESULT CComActivatorCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    CComActivator *act =
           new CComActivator();

    if (act==NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = act->QueryInterface(riid, ppv);
    act->Release();
    return hr;
}

//----------------------------------------------------------------------------
// Methods from IUnknown
//----------------------------------------------------------------------------
STDMETHODIMP CComActivator::QueryInterface( REFIID riid, LPVOID* ppv)
{
 HRESULT hr;


    //-------------------------------------------------------------------
    //  Check for Top level interfaces
    //-------------------------------------------------------------------
    if (IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IStandardActivator))
        *ppv = (IStandardActivator*)this;
    else
    if (IsEqualIID(riid, IID_IOpaqueDataInfo))
        *ppv = (IOpaqueDataInfo*)this;
    else
    if (IsEqualIID(riid, IID_ISpecialSystemProperties))
        *ppv = (ISpecialSystemProperties*)this;
    else
    if (IsEqualIID(riid, IID_IInitActivationPropertiesIn))
        *ppv = (IInitActivationPropertiesIn*)this;
    else
        *ppv = NULL;

    if (*ppv != NULL)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG CComActivator::AddRef(void)
{
   return InterlockedIncrement(&_ulRef);
}


ULONG CComActivator::Release(void)
{
   ULONG count;

   if ((count = InterlockedDecrement(&_ulRef)) == 0)
   {
       delete this;
       return 0;
   }

   return count;
}


//----------------------------------------------------------------------------
// Methods from IStandardActivator
//----------------------------------------------------------------------------

STDMETHODIMP CComActivator::StandardGetClassObject (REFCLSID rclsid,
                                      DWORD dwContext,
                                      COSERVERINFO *pServerInfo,
                                      REFIID riid,
                                      void **ppvClassObj)
{
    // Create ActivationPropertiesIn on stack
    ActivationPropertiesIn actIn;
    actIn.SetNotDelete();

    // Initialize Actprops with set stuff
    InitializeActivation(&actIn);

    return DoGetClassObject(rclsid,
                            dwContext,
                            pServerInfo,
                            riid,
                            ppvClassObj,
                            &actIn);
}

STDMETHODIMP CComActivator::StandardCreateInstance (REFCLSID Clsid,
                                      IUnknown *punkOuter,
                                      DWORD dwClsCtx,
                                      COSERVERINFO *pServerInfo,
                                      DWORD dwCount,
                                      MULTI_QI *pResults)
{
    // Create ActivationPropertiesIn on stack
    ActivationPropertiesIn actIn;
    actIn.SetNotDelete();

    // Initialize Actprops with set stuff
    InitializeActivation(&actIn);

    return DoCreateInstance(Clsid,
                            punkOuter,
                            dwClsCtx,
                            pServerInfo,
                            dwCount,
                            pResults,
                            &actIn);

}

STDMETHODIMP CComActivator::StandardGetInstanceFromFile 
                                      (COSERVERINFO *pServerInfo,
                                       CLSID        *pclsidOverride,
                                       IUnknown     *punkOuter,
                                       DWORD        dwClsCtx,
                                       DWORD        grfMode,
                                       OLECHAR      *pwszName,
                                       DWORD        dwCount,
                                       MULTI_QI     *pResults )
{
    // Create ActivationPropertiesIn on stack
    ActivationPropertiesIn actIn;
    actIn.SetNotDelete();

    // Initialize Actprops with set stuff
    InitializeActivation(&actIn);


    return DoGetInstanceFromFile( pServerInfo,
                                  pclsidOverride,
                                  punkOuter,
                                  dwClsCtx,
                                  grfMode,
                                  pwszName,
                                  dwCount,
                                  pResults,
                                  &actIn);
}

STDMETHODIMP CComActivator::StandardGetInstanceFromIStorage 
                                      (COSERVERINFO *pServerInfo,
                                       CLSID        *pclsidOverride,
                                       IUnknown     *punkOuter,
                                       DWORD        dwClsCtx,
                                       IStorage     *pstg,
                                       DWORD        dwCount,
                                       MULTI_QI     *pResults )
{
    // Create ActivationPropertiesIn on stack
    ActivationPropertiesIn actIn;
    actIn.SetNotDelete();

    // Initialize Actprops with set stuff
    InitializeActivation(&actIn);

    return DoGetInstanceFromStorage( pServerInfo,
                                     pclsidOverride,
                                     punkOuter,
                                     dwClsCtx,
                                     pstg,
                                     dwCount,
                                     pResults,
                                     &actIn);
}

STDMETHODIMP CComActivator::Reset ()
{
    ReleaseData();
    _pOpaqueData = NULL;
    _pProps = NULL;
    _fActPropsInitNecessary = FALSE;
    return S_OK;
}

//----------------------------------------------------------------------------
// Methods from IOpaqueDataInfo
//----------------------------------------------------------------------------

STDMETHODIMP CComActivator::AddOpaqueData (OpaqueData *pData)
{
    if (!_pOpaqueData)
        _pOpaqueData = new OpaqueDataInfo();

    if (!_pOpaqueData)
        return E_OUTOFMEMORY;

    _fActPropsInitNecessary = TRUE;

    return _pOpaqueData->AddOpaqueData(pData);
}

STDMETHODIMP CComActivator::GetOpaqueData (REFGUID guid,
                               OpaqueData **pData)
{
    Win4Assert(_pOpaqueData);
    if (!_pOpaqueData)
        return E_INVALIDARG; 

    return _pOpaqueData->GetOpaqueData(guid, pData);
}

STDMETHODIMP  CComActivator::DeleteOpaqueData (REFGUID guid)
{
    Win4Assert(_pOpaqueData);
    if (!_pOpaqueData)
        return E_INVALIDARG;

    return _pOpaqueData->DeleteOpaqueData(guid);
}

STDMETHODIMP  CComActivator::GetOpaqueDataCount (ULONG *pulCount)
{
    Win4Assert(_pOpaqueData);
    if (!_pOpaqueData)
        return E_INVALIDARG;

    return _pOpaqueData->GetOpaqueDataCount(pulCount);
}

STDMETHODIMP  CComActivator::GetAllOpaqueData (OpaqueData **prgData)
{
    Win4Assert(_pOpaqueData);
    if (!_pOpaqueData)
        return E_INVALIDARG;

    return _pOpaqueData->GetAllOpaqueData(prgData);
}


//----------------------------------------------------------------------------
// Methods from ISpecialSystemProperties
//----------------------------------------------------------------------------
STDMETHODIMP CComActivator::SetSessionId (ULONG dwSessionId, BOOL bUseConsole, BOOL fRemoteThisSessionId)
{
    if (!_pProps)
    {
        _pProps = new SpecialProperties();
        if (!_pProps)
            return E_OUTOFMEMORY;

        _fActPropsInitNecessary = TRUE;
    }

    _pProps->SetSessionId(dwSessionId, bUseConsole, fRemoteThisSessionId);

    return S_OK;
}

STDMETHODIMP CComActivator::GetSessionId (ULONG *pdwSessionId, BOOL* pbUseConsole)
{
    Win4Assert(_pProps);
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->GetSessionId(pdwSessionId, pbUseConsole);
}

STDMETHODIMP CComActivator::GetSessionId2 (ULONG *pdwSessionId, BOOL* pbUseConsole, BOOL* pfRemoteThisSessionId)
{
    Win4Assert(_pProps);
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->GetSessionId2(pdwSessionId, pbUseConsole, pfRemoteThisSessionId);
}

STDMETHODIMP CComActivator::SetClientImpersonating (BOOL fClientImpersonating)
{
    Win4Assert(_pProps);
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->SetClientImpersonating(fClientImpersonating);
}

STDMETHODIMP CComActivator::GetClientImpersonating (BOOL* pfClientImpersonating)
{
    Win4Assert(_pProps);
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->GetClientImpersonating(pfClientImpersonating);
}

STDMETHODIMP CComActivator::SetPartitionId (REFGUID guidPartition)
{
   if (!_pProps)
   {
       _pProps = new SpecialProperties();
       if (!_pProps)
	   return E_OUTOFMEMORY;

       _fActPropsInitNecessary = TRUE;
   }

   _pProps->SetPartitionId(guidPartition);

   return S_OK;

}

STDMETHODIMP CComActivator::GetPartitionId (GUID *pguidPartition)
{
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->GetPartitionId(pguidPartition);
}

STDMETHODIMP CComActivator::SetProcessRequestType (DWORD dwPRT)
{
    if (!_pProps)
    {
        _pProps = new SpecialProperties();
        if (!_pProps)
            return E_OUTOFMEMORY;

        _fActPropsInitNecessary = TRUE;
    }

    return _pProps->SetProcessRequestType(dwPRT);
}


STDMETHODIMP CComActivator::GetProcessRequestType (DWORD* pdwPRT)
{
    Win4Assert(_pProps);
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->GetProcessRequestType(pdwPRT);
}

STDMETHODIMP CComActivator::SetOrigClsctx(DWORD dwClsctx)
{


   if (!_pProps)
   {
       _pProps = new SpecialProperties();
       if (!_pProps)
	   return E_OUTOFMEMORY;

       _fActPropsInitNecessary = TRUE;
   }

   _pProps->SetOrigClsctx(dwClsctx);

   return S_OK;

}

STDMETHODIMP CComActivator::GetOrigClsctx(DWORD *pdwClsCtx)
{
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->GetOrigClsctx(pdwClsCtx);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\dllcache.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       dllcache.cxx
//
//  Contents:   Implementation of CClassCache as declared in dllcache.hxx
//
//  Functions:
//              CClassCache::CClassEntry::~CClassEntry
//              CClassCache::CClassEntry::CycleToClassEntry
//              CClassCache::CClassEntry::NoLongerNeeded
//              CClassCache::CClassEntry::SearchBaseClassEntry
//              CClassCache::CClassEntry::SearchBaseClassEntryHelp
//              CClassCache::CDllClassEntry::GetClassInterface
//              CClassCache::CLSvrClassEntry::GetClassInterface
//              CClassCache::GetApartmentChain
//              CClassCache::CLSvrClassEntry::AddToApartmentChain
//              CClassCache::CLSvrClassEntry::RemoveFromApartmentChain
//              CClassCache::CLSvrClassEntry::Release
//              CClassCache::CLSvrClassEntry::GetDDEInfo
//              CClassCache::CLSvrClassEntry::CFinishObject::Finish
//              CClassCache::CDllPathEntry::IsValidInApartment
//              CClassCache::CDllPathEntry::Release
//              CClassCache::CDllPathEntry::CanUnload_rl
//              CClassCache::CDllPathEntry::CFinishObject::Finish
//              CClassCache::CDllAptEntry::Release
//              CClassCache::CFinishComposite::~CFinishComposite
//              CClassCache::CFinishComposite::Finish
//              CClassCache::CFinishComposite::Add
//              CClassCache::Init
//              CClassCache::GetOrLoadClass
//              CClassCache::SearchDPEHash
//              CClassCache::Revoke
//              CClassCache::FreeUnused
//              CClassCache::CleanUpDllsForApartment
//              CClassCache::CleanUpLocalServersForApartment
//              CClassCache::CleanUpDllsForProcess
//              CClassCache::AddRefServerProcess
//              CClassCache::ReleaseServerProcess
//              CClassCache::SuspendProcessClassObjects
//              CClassCache::ResumeProcessClassObjects
//              CClassCache::GetClassInformationForDde
//              CClassCache::GetClassInformationFromKey
//              CClassCache::SetDdeServerWindow
//              CClassCache::CDllFnPtrMoniker::CDllFnPtrMoniker
//              CClassCache::CDllFnPtrMoniker::~CDllFnPtrMoniker
//              CClassCache::CDllFnPtrMoniker::BindToObject
//              CClassCache::CpUnkMoniker::CpUnkMoniker
//              CClassCache::CpUnkMoniker::~CpUnkMoniker
//              CClassCache::CpUnkMoniker::BindToObject
//              CCGetOrLoadClass
//              CCGetClass
//              CCIsClsidRegisteredInApartment
//              CCRegisterServer
//              CCRevoke
//              CCAddRefServerProcess
//              CCReleaseServerProcess
//              CCSuspendProcessClassObjects
//              CCResumeProcessClassObjects
//              CCCleanUpDllsForApartment
//              CCCleanUpDllsForProcess
//              CCCleanUpLocalServersForApartment
//              CCFreeUnused
//              CCGetClassInformationForDde
//              CCGetClassInformationFromKey
//              CCSetDdeServerWindow
//              CCGetDummyNodeForApartmentChain
//              CCReleaseDummyNodeForApartmentChain
//              CCInitMTAApartmentChain
//              CCReleaseMTAApartmentChain
//
//  Classes:    CClassCache
//              CClassCache::ClassEntry
//              CClassCache::CBaseClassEntry
//              CClassCache::CDllClassEntry
//              CClassCache::CLSvrClassEntry
//              CClassCache::CDllPathEntry
//              CClassCache::CDllAptEntry
//
//  History:    18-Nov-96   MattSmit    Created
//              26-Feb-98   CBiks       Modified the DLL cache to include
//                                       the context information as part of
//                                       the DLLs identity.
//              23-Jun-98   CBiks       See comments in the code.
//              14-Sep-98   CBiks       Fixed RAID# 214719.
//              09-Oct-98   CBiks       Cleaned up debugging code.
//              20-Oct-98    TarunA     Fixed RAID# 148288
//
//--------------------------------------------------------------------------

#include    <ole2int.h>
#include    <ole2com.h>
#include    <tracelog.hxx>

#include    "objact.hxx"
#include    <dllhost.hxx>
#include    <sobjact.hxx>
#include    "dllcache.hxx"

HRESULT GetClassInfoFromClsid(REFCLSID rclsid, IComClassInfo **ppClassInfo);
HRESULT HelperGetImplementedClsid(IComClassInfo* pCI, /*[in]*/ CLSID* pConfigCLSID, /*[out]*/ CLSID* pImplCLSID);
const IID IID_IMiniMoniker =
{0x00000153,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

#ifdef _UNICODE
#define TSZFMT     "%ws"
#else
#define TSZFMT      "%s"
#endif


// Macros to help iterating linked lists
#define FOREACH_SAFE(ptr, lst, nxt, fldnext) \
for ( ptr = (lst), nxt = ptr->fldnext; \
      ptr->fldnext != (lst); \
      ptr = nxt, nxt = ptr->fldnext)

#define FOREACH(ptr, lst, fldnext) \
for ( ptr = (lst); \
      ptr->fldnext != (lst); \
      ptr = ptr->fldnext)

// convert an HRESULT to a string
#define HR2STRING(hr) (SUCCEEDED(hr) ? "SUCCEEDED" : "FAILED")
#define HRDBG(hr) (SUCCEEDED(hr) ? DEB_ACTIVATE : DEB_ERROR)


//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// static data initialization /////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

// collection
DWORD CClassCache::CCollectable::_dwCollectionGracePeriod = 500 ;
DWORD CClassCache::CCollectable::_dwCollectionFrequency = 5;
CClassCache::CCollectable * CClassCache::_ObjectsForCollection = NULL;
CClassCache::CCollectable  *CClassCache::CCollectable::NOT_COLLECTED =
(CClassCache::CCollectable *)LongToPtr(0xffffffff);


// hash tables -- entry points
CClassCache::CCEHashTable   CClassCache::_ClassEntries;
CClassCache::CDPEHashTable  CClassCache::_DllPathEntries;

// mutex
CStaticRWLock   CClassCache::_mxs;

// flags
DWORD                CClassCache::_dwFlags = 0;

// data
ULONG                CClassCache::_cRefsServerProcess = 0;
CClassCache::CLSvrClassEntry *CClassCache::_MTALSvrsFront = 0;
CClassCache::CLSvrClassEntry *CClassCache::_NTALSvrsFront = 0;

//
// NOTE:   These parameters are purposely small in order to
//         ensure that stress and regression tests will attempt
//         to collect objects on a faily regualar basis.  After
//         these changes have had a chance to be well tested,
//         I will change these parameters to more appropriate
//         values.
//
//         (MattSmit)
//

const ULONG          CClassCache::_CollectAtObjectCount = 2;
const ULONG          CClassCache::_CollectAtInterval    = 5000;
ULONG                CClassCache::_LastCollectionTickCount = 0;
ULONG                CClassCache::_LastObjectCount      = 0;

// backing store for hash tables
const ULONG CClassCache::_cCEBuckets = 23;
SHashChain CClassCache::_CEBuckets[CClassCache::_cCEBuckets] =
{
    {&_CEBuckets[0],  &_CEBuckets[0]},
    {&_CEBuckets[1],  &_CEBuckets[1]},
    {&_CEBuckets[2],  &_CEBuckets[2]},
    {&_CEBuckets[3],  &_CEBuckets[3]},
    {&_CEBuckets[4],  &_CEBuckets[4]},
    {&_CEBuckets[5],  &_CEBuckets[5]},
    {&_CEBuckets[6],  &_CEBuckets[6]},
    {&_CEBuckets[7],  &_CEBuckets[7]},
    {&_CEBuckets[8],  &_CEBuckets[8]},
    {&_CEBuckets[9],  &_CEBuckets[9]},
    {&_CEBuckets[10], &_CEBuckets[10]},
    {&_CEBuckets[11], &_CEBuckets[11]},
    {&_CEBuckets[12], &_CEBuckets[12]},
    {&_CEBuckets[13], &_CEBuckets[13]},
    {&_CEBuckets[14], &_CEBuckets[14]},
    {&_CEBuckets[15], &_CEBuckets[15]},
    {&_CEBuckets[16], &_CEBuckets[16]},
    {&_CEBuckets[17], &_CEBuckets[17]},
    {&_CEBuckets[18], &_CEBuckets[18]},
    {&_CEBuckets[19], &_CEBuckets[19]},
    {&_CEBuckets[20], &_CEBuckets[10]},
    {&_CEBuckets[21], &_CEBuckets[21]},
    {&_CEBuckets[22], &_CEBuckets[22]}
};

const ULONG CClassCache::_cDPEBuckets = 23;
SHashChain CClassCache::_DPEBuckets[CClassCache::_cDPEBuckets] =
{
    {&_DPEBuckets[0],  &_DPEBuckets[0]},
    {&_DPEBuckets[1],  &_DPEBuckets[1]},
    {&_DPEBuckets[2],  &_DPEBuckets[2]},
    {&_DPEBuckets[3],  &_DPEBuckets[3]},
    {&_DPEBuckets[4],  &_DPEBuckets[4]},
    {&_DPEBuckets[5],  &_DPEBuckets[5]},
    {&_DPEBuckets[6],  &_DPEBuckets[6]},
    {&_DPEBuckets[7],  &_DPEBuckets[7]},
    {&_DPEBuckets[8],  &_DPEBuckets[8]},
    {&_DPEBuckets[9],  &_DPEBuckets[9]},
    {&_DPEBuckets[10], &_DPEBuckets[10]},
    {&_DPEBuckets[11], &_DPEBuckets[11]},
    {&_DPEBuckets[12], &_DPEBuckets[12]},
    {&_DPEBuckets[13], &_DPEBuckets[13]},
    {&_DPEBuckets[14], &_DPEBuckets[14]},
    {&_DPEBuckets[15], &_DPEBuckets[15]},
    {&_DPEBuckets[16], &_DPEBuckets[16]},
    {&_DPEBuckets[17], &_DPEBuckets[17]},
    {&_DPEBuckets[18], &_DPEBuckets[18]},
    {&_DPEBuckets[19], &_DPEBuckets[19]},
    {&_DPEBuckets[20], &_DPEBuckets[10]},
    {&_DPEBuckets[21], &_DPEBuckets[21]},
    {&_DPEBuckets[22], &_DPEBuckets[22]}
};

// page tables
CPageAllocator      CClassCache::CDllPathEntry::_palloc;
CPageAllocator      CClassCache::CClassEntry::_palloc;
CPageAllocator      CClassCache::CDllClassEntry::_palloc;
CPageAllocator      CClassCache::CLSvrClassEntry::_palloc;
CPageAllocator      CClassCache::CDllAptEntry::_palloc;

const unsigned long CClassCache::CDllPathEntry::_cNumPerPage = 15;
const unsigned long CClassCache::CClassEntry::_cNumPerPage = 50;
const unsigned long CClassCache::CDllClassEntry::_cNumPerPage = 50;
// Do not grow this number past 16 w/o changing cookie code


const unsigned long CClassCache::CLSvrClassEntry::_cNumPerPage = 16 ;
const unsigned long CClassCache::CDllAptEntry::_cNumPerPage = 50;

// signatures
const DWORD CClassCache::CClassEntry::TREAT_AS_SIG = *((DWORD *)"TA ");
const DWORD CClassCache::CClassEntry::INCOMPLETE_ENTRY_SIG = *((DWORD *)"INC");
const DWORD CClassCache::CClassEntry::CLASS_ENTRY_SIG = *((DWORD *)"CE ");
const DWORD CClassCache::CDllClassEntry::SIG =  *((DWORD *) "DLL");
const DWORD CClassCache::CLSvrClassEntry::SIG = *((DWORD *) "LSV");
const DWORD CClassCache::CLSvrClassEntry::DUMMY_SIG = *((DWORD *) "DUM");
const DWORD CClassCache::CDllPathEntry::SIG =  *((DWORD *) "DPE");
const DWORD CClassCache::CDllAptEntry::SIG =  *((DWORD *) "APT");

//other
const ULONG CClassCache::CDllPathEntry::DLL_DELAY_UNLOAD_TIME = 600000; // 600,000 ticks == 10 minutes
const char CClassCache::CDllPathEntry::DLL_GET_CLASS_OBJECT_EP[] = "DllGetClassObject";
const char CClassCache::CDllPathEntry::DLL_CAN_UNLOAD_EP[] =       "DllCanUnloadNow";

const DWORD CClassCache::CLSvrClassEntry::NO_SCM_REG = 0xffffffff;
DWORD CClassCache::CLSvrClassEntry::_dwNextCookieCount = 0;
DWORD CClassCache::CLSvrClassEntry::_cOutstandingObjects = 0;



//+-------------------------------------------------------------------------
//
//  Function:   GetPartitionIDForClassInfo
//
//  Synopsis:   Figure out what partition this classinfo lives in.
//
//  Arguments:  pCI      - [in] The classinfo in question
//
//  Algorithm:  QI the classinfo for IComClasSInfo2, and use that interface
//              to get back the partition ID.  If anything fails, return
//              GUID_DefaultAppPartition.
//
//  History:    12-Mar-01 JohnDoty Created
//
//+-------------------------------------------------------------------------
const GUID *GetPartitionIDForClassInfo(
    IN IComClassInfo *pCI
)
{
    IComClassInfo2 *pCI2;
    const GUID *pguidPartition = &GUID_DefaultAppPartition;

    HRESULT hr = pCI->QueryInterface(IID_IComClassInfo2, (void **)&pCI2);
    if (SUCCEEDED(hr))
    {
        hr = pCI2->GetApplicationPartitionId((GUID**)&pguidPartition);
        Win4Assert(SUCCEEDED(hr));
        
        pCI2->Release();
    }
    
    return pguidPartition;
}

//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////// Method Implementation /////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////
// ClassCache::CClassEntry ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::~CClassEntry()
//
//  Synopsis:   Destructor
//
//  Arguments:  none
//
//  Returns:    n/a
//
//  Algorithm:  Assert that this object is ok to delete, flag it deleted by
//              zeroing the sig and flags, delete the treat as objects in
//              chain, and remove this object from the hash
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
CClassCache::CClassEntry::~CClassEntry()
{
    ClsCacheDebugOut((DEB_ACTIVATE,"Destroying CClassEntry: 0x%x\n", this));

    Win4Assert(NoLongerNeeded());

    // NOTE:: before adding logic to this destructor,
    // please examine the code and accompanying note in
    // CClassCache::CleanupDllsForProcess, in which some CClassEntry
    // objects are freed w/o the destructor running.


    ASSERT_LOCK_HELD(_mxs);

    // Zap the sig
    _dwSig = 0;

    // Zap the flags
    _dwFlags = 0;

    // remove treat as entries

    if (_pTreatAsList && _pTreatAsList->_dwSig != 0)
    {
        delete _pTreatAsList;
    }

    // remove from hash
    _hashNode.chain.pPrev->pNext = (SHashChain *) _hashNode.chain.pNext;
    _hashNode.chain.pNext->pPrev = (SHashChain *) _hashNode.chain.pPrev;

    // release class info if there
    if (_pCI)
    {
        _pCI->Release();
    }

    AssertNoRefsToThisObject();
}

#if DBG == 1
void CClassCache::CClassEntry::AssertNoRefsToThisObject()
{
    ASSERT_LOCK_HELD(_mxs);

    for (int k = 0; k < _cCEBuckets; k++)
    {
        SHashChain *pHN;
        FOREACH(pHN, _CEBuckets[k].pNext, pNext)
        {
            CClassEntry *pCE = CClassEntry::SafeCastFromHashNode((SMultiGUIDHashNode *) pHN);
            Win4Assert(pCE != this && "AssertNoRefsToThisObject");
        }
    }
}

#endif
//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::CreateIncomplete()
//
//  Synopsis:   Creates an CClassEntry object w/o consulting the registry
//
//  Arguments:  rclsid         - CLSID of the object to create
//              dwClsHash      - computed 32-bit hash code
//              pCE            - out parameter
//              dwFlags        - fDO_NOT_HASH - don't put in hash table
//
//  Returns:    S_OK/error code
//
//  Algorithm:  Create a class entry. No need to check the registry for
//              TreatAs types
//
//  History:    11-Mar-97 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CClassEntry::CreateIncomplete(REFCLSID rclsid,
                                                   DWORD dwClsHash,
                                                   IComClassInfo *pCI,
                                                   CClassEntry *&pCE,
                                                   DWORD dwFlags)
{
    ASSERT_LOCK_HELD(_mxs);
    ClsCacheDebugOut((DEB_ACTIVATE, "Creating incomplete CClassEntry: clsid: %I\n", &rclsid));

    //
    // We no longer call GetClassInfoFromClsid because it can lead to 
    // deadlocks with MSI because they switch threads when servicing calls.
    // Consequently, all callers to this function must provide their own pCI,
    // obtained outside the class cache lock
    //
    if (!pCI)
    {
        Win4Assert (!"pCI should never be NULL - see Windows Bug #108538");
        return E_POINTER;
    }

    CStdMarshal *psm;

    // Call garbage collection algorithm before allocating
    // memory.
    Collect(1);
    
    HRESULT hr = E_OUTOFMEMORY;
    pCE = new CClassEntry();
    if (pCE)
    {
        
        pCE->_dwSig = CClassEntry::INCOMPLETE_ENTRY_SIG;
        pCE->_dwFlags = fINCOMPLETE;
        
        // fill out catalog & complus info
        
        DWORD cCustomActivatorCount = 0;
        DWORD stage;
        
        for (stage = CLIENT_CONTEXT_STAGE; stage <= SERVER_CONTEXT_STAGE; stage++)
        {
            DWORD cCustomActForStage = 0;
            hr = pCI->GetCustomActivatorCount((ACTIVATION_STAGE)stage,&cCustomActForStage);
            if (SUCCEEDED(hr))
            {
                cCustomActivatorCount += cCustomActForStage;
            }
        }
        
        if (cCustomActivatorCount > 0)
        {
            pCE->_dwFlags |= fCOMPLUS;
        }
        else
        {
            pCE->_pCI = pCI;
            pCE->_pCI->AddRef();
        }
        
        // fill out the CClassEntry
        pCE->_guids[iCLSID]     = rclsid;

        const GUID *pguidPartition = GetPartitionIDForClassInfo(pCI);
        pCE->_guids[iPartition] = *pguidPartition;

        // put in the hash
        if (!(dwFlags & fDO_NOT_HASH))
        {
            SMultiGUIDKey key;
            
            key.cGUID = iTotal;
            key.aGUID = pCE->_guids;
            
            ClsCacheDebugOut((DEB_ACTIVATE, "CClassEntry: Adding clsid: %I to the hash, pCE = 0x%x\n", &rclsid, pCE));
            _ClassEntries.AddCE(dwClsHash, key, pCE);
        }
        hr = S_OK;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::Complete
//
//  Synopsis:   Check's the registry for TreatAs entries for this object.
//
//  Arguments:  none
//
//  Returns:    S_OK/error code
//
//  Algorithm:  if this entry is already complete, do nothing.  Otherwise,
//              check the registry.  If there is a TreatAs element for this
//              CLSID, create that and hook it up.  Repeat recursively.
//
//              NOTE: Only Create and SearchBaseClassEntry should
//                    call this function!!
//
//  History:    11-Mar-97 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CClassEntry::Complete(BOOL *pfLockReleased)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "Completing CClassEntry object: this = 0x%x, clsid: %I\n", this, &(_guids[iCLSID])));
    ASSERT_WRITE_LOCK_HELD(_mxs);

    *pfLockReleased = FALSE;

    if (IsComplete())
    {
        return S_OK;
    }

    HRESULT hr;

    CLSID TreatAs_clsid;
    IComClassInfo* pCI = NULL;

    hr = CoGetTreatAsClass(_guids[iCLSID], &TreatAs_clsid);

    if ((hr == S_OK) && (_guids[iCLSID] != TreatAs_clsid))
    {
        // TreatAs class listed in the registry
        // check the hash

        ClsCacheDebugOut((DEB_ACTIVATE, "Treating CLSID %I as %I\n", &_guids[iCLSID], &TreatAs_clsid));

        // TreatAs stuff is only in the base partition...
        DWORD dwTAHash = _ClassEntries.Hash(TreatAs_clsid, GUID_DefaultAppPartition);
        CClassEntry *pTACE = _ClassEntries.LookupCE(dwTAHash, TreatAs_clsid, GUID_DefaultAppPartition);

        if (!pTACE)
        {            
            // Windows Bug #107960
            // Look up class info without write lock
            // before call to CClassEntry::Create

            BOOL fLockReleased;

            UNLOCK_WRITE(_mxs);

            *pfLockReleased = TRUE;

            hr = GetClassInfoFromClsid(TreatAs_clsid, &pCI);

            // Restore the read lock for the caller
            LOCK_WRITE(_mxs);

            if (FAILED (hr))
            {
                goto epilog;
            }

            pTACE = _ClassEntries.LookupCE(dwTAHash, TreatAs_clsid, GUID_DefaultAppPartition);
        }

        if (!pTACE)
        {
            hr = CClassEntry::Create(TreatAs_clsid, dwTAHash, pCI, pTACE);

            if (FAILED(hr))
            {
                goto epilog;
            }
            // check to see if this object was completed while
            // the lock was released
            if (IsComplete())
            {
                hr = S_OK;
                goto epilog;
            }

        }
        else if (!pTACE->IsComplete())
        {
            BOOL fLockReleased = FALSE;
            hr = pTACE->Complete(&fLockReleased);
            Win4Assert(!fLockReleased);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        CompleteTreatAs(pTACE);
    }
    else
    {
        CompleteNoTreatAs();
    }


    MarkCompleted();
    Win4Assert(IsComplete());
    epilog:

    if (pCI)
    {
        pCI->Release();
    }
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::Create()
//
//  Synopsis:   Creates a CClassCache::CClassEntry object
//
//  Arguments:  rclsid      - [in] The class id of the new CClassEntry
//              dwClsHash   - [in] The hash value for the clsid
//              fGetTreatAs - [in] TRUE - then lookup the treatas, else dont
//              pCE         - [out] The new CClassEntry.
//
//  Returns:    S_OK    - operation succeeded
//              E_OUTOFMEMORY - operation failed due to lack of memory
//
//  Algorithm:  if there is a treat as class
//                 create it recursively and link the new
//                 CClassEntry to it
//              else
//                 create a new CClassEntry
//              add the new CClassEntry to the hash table.
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CClassEntry::Create(REFCLSID rclsid,
                                         DWORD dwClsHash,
                                         IComClassInfo *pCI,
                                         CClassEntry *&pCE)
{
    ASSERT_WRITE_LOCK_HELD(_mxs);
    ClsCacheDebugOut((DEB_ACTIVATE, "Creating CClassEntry: clsid: %I\n", &rclsid));

    if (!pCI)
    {
        Win4Assert (!"pCI should never be NULL - see Windows Bug #108538");
        return E_POINTER;
    }

    HRESULT hr = CreateIncomplete(rclsid, dwClsHash, pCI, pCE, fDO_NOT_HASH);
    if (SUCCEEDED(hr))
    {
        BOOL fLockReleased = FALSE;
        hr = pCE->Complete(&fLockReleased);

        ASSERT_WRITE_LOCK_HELD(_mxs);
        
        if (SUCCEEDED(hr))
        {
            // If we released the lock, make sure we still need to add
            // the class entry to the table
            CClassEntry* pNewCE = NULL;

            if (fLockReleased)
            {
                const GUID *pguidPartition = GetPartitionIDForClassInfo(pCI);

                pNewCE = _ClassEntries.LookupCE (dwClsHash, rclsid, *pguidPartition);
            }
        
            if (pNewCE)
            {
                // Discard the current class entry
                delete pCE;
            }
            else
            {
                // put in the hash
                SMultiGUIDKey key;

                key.cGUID = iTotal;
                key.aGUID = pCE->_guids;

                ClsCacheDebugOut((DEB_ACTIVATE, "CClassEntry: Adding clsid: %I to the hash, pCE = 0x%x\n", &rclsid, pCE));
                _ClassEntries.AddCE(dwClsHash, key, pCE);
            }
        }
        else
        {
            delete pCE;
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::CycleToClassEntry()
//
//  Synopsis:   Return a pointer to the ClassEntry for this TreatAs chain
//
//  Arguments:  none
//
//  Returns:    The ClassEntry for this TreatAs chain
//
//  Algorithm:  loop through the _pTreatAsList pointers until the signature
//              is not a TreaAs signature.
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
CClassCache::CClassEntry * CClassCache::CClassEntry::CycleToClassEntry()
{
    ASSERT_RORW_LOCK_HELD(_mxs);

    ClsCacheDebugOut((DEB_ACTIVATE, "CycleToClassEntry: this = 0x%x\n", this));
    Win4Assert(IsComplete()  && "Entry must be complete to call CycleToClassEntry");
    Win4Assert(_pTreatAsList);

    CClassEntry *ret = this;

    while (ret->_dwFlags &  fTREAT_AS)
    {
        ret = ret->_pTreatAsList;
        // check for infinite cycles
        Win4Assert(ret != this && "No Class Entry in this chain!");
    }

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::CreateDllClassEntry_rl()
//
//  Synopsis:   Creates a new CDllClassEntry - releases the lock
//
//  Arguments:  dwContext    - [in]  Context of the CDllClassEntry
//              ap           - [in]  Activation properties passed in from
//                                   caller
//              pDCE         - [out] Pointer to the new CDllClassEntry
//
//  Returns:    S_OK    -  operation succeeded
//              PROPOGATE:NegotiateDllInstantiationProperties
//              PROPOGATE:CDllPathEntry::Create
//
//  Algorithm:  Get the dll instantiation properties.
//              if CDllPathEntry is not in the hash
//                   create one
//                   if another thread created the CDllClassEntry return it
//              Create a new CDllClassEntry
//              Initilize it
//              Link it to the CDllPathEntry, and this CClassEntry
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CClassEntry::CreateDllClassEntry_rl(
                                                        DWORD                        dwContext,
                                                        ACTIVATION_PROPERTIES_PARAM  ap,
                                                        CDllClassEntry*&             pDCE)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CreateDllClassEntry: dwContext = 0x%x\n", dwContext));
    Win4Assert(!(_dwFlags & fTREAT_AS) && "Can only create DllClassEntry's on non-TreatAs ClassEntries");
    Win4Assert((_dwSig == CLASS_ENTRY_SIG) && "Must be a full CClassEntry");
    Win4Assert(!(dwContext & CLSCTX_LOCAL_SERVER));
    Win4Assert(!((dwContext & CLSCTX_INPROC_SERVERS) && (dwContext & CLSCTX_INPROC_HANDLERS)));
    Win4Assert(((dwContext & CLSCTX_INPROC_SERVERS) || (dwContext & CLSCTX_INPROC_HANDLERS)));

    HRESULT hr;
    CDllPathEntry *pDPE;
    DLL_INSTANTIATION_PROPERTIES dip;

    ASSERT_LOCK_NOT_HELD(_mxs);

    //
    // I don't know what the fRELOAD_DARWIN flag means, but if it is not set,
    // we negotiate dll information using registry information.
    //
    if (ap._dwFlags & ACTIVATION_PROPERTIES::fRELOAD_DARWIN)
    {

        if (wCompareDllName(ap._pwszDllServer, OLE32_DLL, OLE32_CHAR_LEN))
        {
            dip.Init( OLE32_DLL, ap._dwDllServerType, 0 );
        }
        else
        {
            dip.Init( ap._pwszDllServer, ap._dwDllServerType, 0 );
        }

        hr = S_OK;
    }
    else
    {
        hr = CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties(
                                                                            dwContext,
                                                                            ap._dwActvFlags,
                                                                            _guids[iCLSID],
                                                                            dip,
                                                                            ap._pCI);
    }




    if (FAILED(hr))
        return hr;

    LOCK(_mxs);

    //
    // Make sure no one else came and added a similar class entry
    // while the lock was released.
    //
    if (pDCE = SearchForDCE(dip._pzDllPath , dip._dwFlags)) 
    {                                                       
        hr = S_OK;                                          
        goto epilog;                                        
    }


    //
    // Look up the dll path in the registry.
    //
    hr = SearchDPEHash(dip._pzDllPath, pDPE, dip._dwHash, dip._dwFlags);
    if (FAILED(hr))
    {
        //
        // No entry for this DLL.  Make one...
        //
        ClsCacheDebugOut((DEB_ACTIVATE, "No Dll found in cache, loading one\n"));
        if (FAILED(hr = CClassCache::CDllPathEntry::Create_rl(dip, ap, pDPE)))
        {
            ClsCacheDebugOut((DEB_ERROR, "CClassEntry::CreateDllClassEntry: CDllPathEntry::Create_rl FAILED! hr = 0x%x\n", hr));
            goto epilog;
        }

        //
        // Make sure no one else came and added a similar class entry
        // while the lock was released.
        //
        if (pDCE = SearchForDCE(dip._pzDllPath, dip._dwFlags))
        {
            hr = S_OK;
            goto epilog;
        }
    }


    //
    // Create a new DLL class entry.
    //

    pDCE = new CClassCache::CDllClassEntry();
    if (!pDCE)
    {
        hr = E_OUTOFMEMORY;
        goto epilog;
    }

    //
    // Fill in Dll Class Entry and add it to the cache.
    //

#ifdef WX86OLE
    if (dip._dwFlags & DLL_INSTANTIATION_PROPERTIES::fLOADED_AS_WX86)
    {
        pDCE->_dwContext = dwContext &
                           (CLSCTX_INPROC_SERVERX86 | CLSCTX_INPROC_HANDLERX86);
    }
    else
#endif
    {
        pDCE->_dwContext = dwContext & (CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER);
        pDCE->_dwContext = dwContext & CLSCTX_INPROC_MASK1632;
    }

    pDCE->_dwSig = CDllClassEntry::SIG;
    pDCE->_dwDllThreadModel = dip._dwThreadingModel;
    hr = HelperGetImplementedClsid(_pCI ? _pCI : ap._pCI, &_guids[iCLSID], &pDCE->_impclsid);
    Win4Assert(SUCCEEDED(hr) && "HelperGetImplementedClsid failed in CClassCache::CClassCache::CreateDllClassEntry_rl");

    pDPE->AddDllClassEntry(pDCE);
    AddBaseClassEntry(pDCE);

    epilog:

    Win4Assert(!!SUCCEEDED(hr) == !!pDCE);

    if (pDCE)
    {
        pDCE->Lock();
    }

    UNLOCK(_mxs);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::SearchForDCE()
//
//  Synopsis:   Scans the CBaseClassEntry list for a DCE with this path
//
//  Arguments:  pzDllPath   - path to look for
//
//  Returns:    pointer to object if found, NULL otherwise
//
//  Algorithm:  linear search of _pBCEList*
//
//  History:    21-Feb-97    MattSmit    Created
//
//+-------------------------------------------------------------------------
CClassCache::CDllClassEntry * CClassCache::CClassEntry::SearchForDCE(WCHAR *pzDllPath, DWORD dwDIPFlags)
{
    CDllClassEntry *pOtherDCE = (CDllClassEntry *) _pBCEListFront->_pPrev;

    while (pOtherDCE != _pBCEListBack)
    {
        pOtherDCE = (CDllClassEntry *) pOtherDCE->_pNext;

        if ((pOtherDCE->_dwSig == CDllClassEntry::SIG) &&
            (lstrcmpW(pOtherDCE->_pDllPathEntry->_psPath, pzDllPath) == 0) &&
            pOtherDCE->_pDllPathEntry->Matches(dwDIPFlags))
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "DllClassEntry created by another thread, leaving\n"));
            return pOtherDCE;
        }
    }

    return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::CreateLSvrClassEntry_rl()
//
//  Synopsis:   Creates a new CLSvrClassEntry - releases the lock
//
//  Arguments:  punk           - [in] New server's IUnknown Interface
//              dwContext      - [in] Context to register the server as
//              dwRegFlags     - [in] Registration flags
//              lpdwRegister   - [out] Cookie so calling program can
//                               revoke the server
//
//  Returns:    S_OK    -  operation succeeded
//              PROPOGATE:gResolver.NotifyStarted()
//
//  Algorithm:  Create a new CLSverClassEntry
//              Fill out members
//              If local server, notify SCM class is started
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CClassEntry::CreateLSvrClassEntry_rl(IUnknown *punk, DWORD dwContext, DWORD dwRegFlags,
                                                          LPDWORD lpdwRegister)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CreateLSvrClassEntry_rl: punk = 0x%x, dwContext = 0x%x, dwRegFlags = 0x%x\n",
                      punk, dwContext, dwRegFlags));

    ASSERT_LOCK_HELD(_mxs);
    HRESULT hr = S_OK;

    CObjServer *pObjServer;
    if (dwContext & CLSCTX_LOCAL_SERVER)
    {
        pObjServer = GetObjServer();
        if (!pObjServer)
        {
            ClsCacheDebugOut((DEB_ERROR, "CreateLSvrClassEntry_rl: error creating the object server\n"));
            return E_FAIL;
        }
    }

    if (IsWOWThread())
    {
        if (dwContext & CLSCTX_INPROC_SERVER)
        {
            dwContext |= CLSCTX_INPROC_SERVER16;
        }
        if (dwContext & CLSCTX_INPROC_HANDLER)
        {
            dwContext |= CLSCTX_INPROC_HANDLER16;
        }
    }


    CLSvrClassEntry *pLSCE = new CLSvrClassEntry(CLSvrClassEntry::SIG,
                                                 punk,
                                                 dwContext,
                                                 dwRegFlags,
                                                 GetCurrentApartmentId());
    if (!pLSCE)
    {
        return E_OUTOFMEMORY;
    }


    if (FAILED(hr = pLSCE->AddToApartmentChain()))
    {
        return hr;
    }

    AddBaseClassEntry(pLSCE);



    if (dwContext & CLSCTX_LOCAL_SERVER)
    {
        // Win95 does lazy create of ObjServer for STA...OleNotificationProc() in com\dcomrem\notify.cxx
        // but only if the clsid is not being registered suspended.  This is coz the bulk update can
        // happen on any thread and therefore the hwnd of the thread corresponding to the clsid will not be
        // known for notification.

        // store off a pointer to the activation server object.
        // Note that on Win95 GetObjServer() will return NULL as the IObjServer will be created lazily.
        pLSCE->_pObjServer = pObjServer;
        if (!(dwRegFlags & REGCLS_SUSPENDED))
        {
            ClsCacheDebugOut((DEB_ACTIVATE,"Notifying SCM that class is started\n"));


            // Notify SCM that the class is started.
            RegOutput     *pRegOut = NULL;

            RegInput RegIn;
            RegIn.dwSize = 1;
            RegIn.rginent[0].clsid = _guids[iCLSID];
            RegIn.rginent[0].dwFlags = dwRegFlags;

            // Win95 does lazy create of ObjServer for STA...OleNotificationProc() in com\dcomrem\notify.cxx
            if (pLSCE->_pObjServer)
            {
                RegIn.rginent[0].ipid = pLSCE->_pObjServer->GetIPID();
                RegIn.rginent[0].oxid = pLSCE->_pObjServer->GetOXID();
            }
            else
            {
                RegIn.rginent[0].ipid = GUID_NULL;
                RegIn.rginent[0].oxid = NULL;
            }

            // Release the lock across outgoing calls to the SCM.
            UNLOCK(_mxs);
            hr = gResolver.NotifyStarted(&RegIn, &pRegOut);
            LOCK(_mxs);


            if (SUCCEEDED(hr))
            {
                pLSCE->_dwScmReg   = pRegOut->RegKeys[0];
                MIDL_user_free(pRegOut);
            }
            else
            {
                ClsCacheDebugOut((DEB_ERROR,"gResolver.NotifyStarted FAILED!!\n"));
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        *lpdwRegister = (DWORD) CLSvrClassEntry::_palloc.GetEntryIndex((PageEntry *)pLSCE);

        Win4Assert(*lpdwRegister != -1);

        CLSvrClassEntry::_dwNextCookieCount++;
        *lpdwRegister |= (CLSvrClassEntry::_dwNextCookieCount << COOKIE_COUNT_SHIFT) & COOKIE_COUNT_MASK ;

        pLSCE->_dwCookie = *lpdwRegister;
    }
    else
    {
        *lpdwRegister = 0;
        pLSCE->RemoveFromApartmentChain();
        RemoveBaseClassEntry(pLSCE);
        delete pLSCE;
        pLSCE = 0;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::NoLongerNeeded()
//
//  Synopsis:   Return whether this object can be deleted
//
//  Arguments:  none
//
//  Returns:    TRUE  - Object can be deleted
//              FALSE - Do not delete object
//
//  Algorithm:  Object can be deleted iff for all object in the treat as chain,
//              the lock count is zero and ther are no attached CBaseClassEntry
//              objects.
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
BOOL CClassCache::CClassEntry::NoLongerNeeded()
{
    ClsCacheDebugOut((DEB_ACTIVATE,"NoLongerNeeded: this = 0x%x\n", this));
    ASSERT_WRITE_LOCK_HELD(_mxs);

    if (_cLocks)
    {
        return FALSE;
    }

    return HasBCEs();
}

BOOL CClassCache::CClassEntry::HasBCEs()
{
    ClsCacheDebugOut((DEB_ACTIVATE,"Has BCEs: this = 0x%x\n", this));
    ASSERT_RORW_LOCK_HELD(_mxs);

    if (!IsComplete())
    {
        return((_pBCEListFront  ==
                ((CBaseClassEntry *) (((DWORD_PTR *)&_pBCEListFront) - 1)))  &&
               (_cLocks == 0));
    }

    CClassEntry *p = this;
    do
    {
        if ((p->_pBCEListFront  !=
             ((CBaseClassEntry *) (((DWORD_PTR *)&p->_pBCEListFront) - 1)))
            || (p->_cLocks != 0))
        {
            return FALSE;
        }
        p = p->_pTreatAsList;

    }
    while (p != this);

    ClsCacheDebugOut((DEB_ACTIVATE,"CClassEntry object 0x%x no longer needed\n", this));

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::SearchBaseClassEntry()
//
//  Synopsis:   Search for a CBaseClassEntry object with give criteria
//
//  Arguments:  dwContext         - [in]  mask of acceptable contexts
//              pBCE              - [out] pointer to found object
//              fForSCM           - [in]  operation originated from the SCM
//
//  Returns:    S_OK   - an object was found
//              E_FAIL - no object was found
//
//  Algorithm:  Search this object first
//              If the search failed && this object is a TreatAs
//                  cycle to the class entry and search it
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CClassEntry::SearchBaseClassEntry(DWORD dwContext,
                                                       CBaseClassEntry *&pBCE,
                                                       DWORD dwActFlags,
                                                       BOOL *pfLockReleased)
{
    ClsCacheDebugOut((DEB_ACTIVATE,"SearchBaseClassEntry: this = 0x%x,"
                      " dwContext = 0x%x, dwActFlags = 0x%x\n",
                      this, dwContext, dwActFlags));
    ASSERT_RORW_LOCK_HELD(_mxs);

    HRESULT hr, tmphr;
    *pfLockReleased = FALSE;

    if (FAILED(hr = SearchBaseClassEntryHelp(dwContext, pBCE, dwActFlags)) &&
        (dwContext & (CLSCTX_INPROC_SERVERS | CLSCTX_INPROC_HANDLERS)))
    {
        // If we're only holding a read lock, upgrade to a write lock
        LockCookie cookie;
        BOOL bExclusive = _mxs.HeldExclusive();

        if (!bExclusive)
        {
            LOCK_UPGRADE(_mxs, &cookie, pfLockReleased);
        }
        
        if (SUCCEEDED(tmphr = Complete(pfLockReleased)))
        {

            if ((_dwFlags & fTREAT_AS) &&
                // if the lock was released we search again.
                (!*pfLockReleased || FAILED(hr = SearchBaseClassEntryHelp(dwContext, pBCE, dwActFlags))))
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "Search Failed, trying TreatAs\n"));
                CClassEntry *pCE = CycleToClassEntry();
                hr = pCE->SearchBaseClassEntryHelp(dwContext, pBCE, dwActFlags);
            }
        }
        else
        {
            hr = tmphr;
        }

        if (!bExclusive)
        {
            LOCK_DOWNGRADE(_mxs, &cookie);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::SearchBaseClassEntryHelp()
//
//  Synopsis:   Helper function for SearchBaseClassEntry, does the actual
//              searching.
//
//  Arguments:  dwContext         - [in]  mask of acceptable contexts
//              pBCE              - [out] pointer to found object
//              fForSCM           - [in]  operation originated from the SCM
//
//  Returns:    S_OK   - an object was found
//              E_FAIL - no object was found
//
//  Algorithm:  For each object in the list
//              if its context matches the context specified
//                  and if it is a local server check apartment and MULTI_SEPARATE semantics
//                  return the object.
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CClassEntry::SearchBaseClassEntryHelp(DWORD dwContext,
                                                           CBaseClassEntry *&pBCE,
                                                           DWORD dwActFlags)
{
    ClsCacheDebugOut((DEB_ACTIVATE,"SearchBaseClassEntryHelp: this = 0x%x,"
                      " dwContext = 0x%x, dwActFlags= 0x%x\n",
                      this, dwContext, dwActFlags));
    ASSERT_RORW_LOCK_HELD(_mxs);


    pBCE = _pBCEListFront->_pPrev;

    while (pBCE != _pBCEListBack)
    {
        pBCE = pBCE->_pNext;

        ClsCacheDebugOut((DEB_ACTIVATE,"SearchBaseClassEntryHelp: this = 0x%x, pBCE->_dwContext = 0x%x\n",
                          pBCE, pBCE->_dwContext));
        if ((pBCE->_dwContext & dwContext))
        {


            if (pBCE->_dwSig == CLSvrClassEntry::SIG)
            {
                // if this is a CLsvrclassEntry object, check that
                // the apartment matches and we are not grabbing
                // a MULTI_SEPARTE w/o being the SCM
                if ((((CLSvrClassEntry *) pBCE)->_hApt != GetCurrentApartmentId()) ||
                    (!(pBCE->_dwContext & CLSCTX_INPROC_SERVERS) &&
                     !(dwActFlags & ACTIVATION_PROPERTIES::fFOR_SCM) &&
                     (((CLSvrClassEntry *) pBCE)->_dwRegFlags & REGCLS_MULTI_SEPARATE)))
                {
                    continue;
                }
            }
            else if (dwActFlags & ACTIVATION_PROPERTIES::fLSVR_ONLY)
            {
                //
                // we only want registered servers, so skip this one
                //

                continue;
            }

            ClsCacheDebugOut((DEB_ACTIVATE,"SearchBaseClassEntryHelp - object found - 0x%x\n", pBCE));

            return S_OK;
        }
    }

    pBCE = 0;
    return E_FAIL;
}




//////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CDllClassEntry ///////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllClassEntry::GetClassInterface
//
//  Synopsis:   Gives out moniker to create the factory from the dll
//
//  Arguments:  ppIM            - [out] pointer to the moniker
//
//  Returns:    S_OK      - operation succeeded
//              PROPOGATE:  CDllPathEntry::MakeVal  idInPartment_rl16
//              PROPOGATE:  CDllFnPtrMoniker::CDllFnPtrMoniker
//
//  Algorithm:  Make the dll valid in this apartment
//              reset the expire time and flag we were here for unload
//                 algorithms
//              create new CDllFnPtrMoniker
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllClassEntry::GetClassInterface(IMiniMoniker ** ppIM)
{

    TRACECALL(TRACE_DLL, "CDllClassEntry::GetClassInterface");
    ClsCacheDebugOut((DEB_ACTIVATE, "CDllClassEntry::GetClassInterface\n"));
    ASSERT_RORW_LOCK_HELD(_mxs);




    // this resets the delay time for delayed unload DLLs
    _pDllPathEntry->_dwExpireTime = 0;
    _pDllPathEntry->_fGCO_WAS_HERE = TRUE;

    HRESULT hr = E_OUTOFMEMORY;
    IUnknown *pUnk = new ((PBYTE) *ppIM) CDllFnPtrMoniker(this, hr);

    if (SUCCEEDED(hr))
    {
        hr = pUnk->QueryInterface(IID_IMiniMoniker, (void **) ppIM);
        if (SUCCEEDED((*ppIM)->CheckApt()) &&
            SUCCEEDED((*ppIM)->CheckNotComPlus()))
        {
            // make valid now so we don't have to take the lock later

            hr = _pDllPathEntry->MakeValidInApartment_rl16();
        }
    }

    if (pUnk)
    {
        pUnk->Release();
    }

    ClsCacheDebugOut((DEB_ACTIVATE, "CDllClassEntry::GetClassInterface new CDllFnPtrMoniker hr = 0x%x\n", hr));

    return hr;

}


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CLSvrClassEntry::GetClassInterface
//
//  Synopsis:   Gives out moniker to hand out the factory.
//
//  Arguments:  ppIM            - [out] pointer to the moniker
//
//  Returns:    S_OK                 - operation succeeded
//              CO_E_SERVER_STOPPING - server is suspended
//              PROPOGATE:  CpUnkMoniker::CpUnkMoniker
//
//  Algorithm:  if class is not suspended
//                 if REGCLS_SINGLEUSE remove from the list, so it won't get
//                  found again.
//                 create the moniker
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CLSvrClassEntry::GetClassInterface(IMiniMoniker **ppIM)
{

    ClsCacheDebugOut((DEB_ACTIVATE, "CLSvrClassEntry::GetClassInterface: this = 0x%x\n", this));
    ASSERT_RORW_LOCK_HELD(_mxs);


    if (!(_dwRegFlags & REGCLS_SUSPENDED))
    {
        HRESULT hr = S_OK;

        if (_dwRegFlags == REGCLS_SINGLEUSE)
        {
            LockCookie cookie;
            BOOL       fLockReleased;
            BOOL       fExclusive = _mxs.HeldExclusive();

            if (!fExclusive)
            {
                LOCK_UPGRADE(_mxs, &cookie, &fLockReleased);
            }

            if (_dwFlags & fBEEN_USED)
            {
                hr = CO_E_SERVER_STOPPING;
            }
            else
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CLSvrClassEntry::GetClassInterface - class is single-use, removing\n"));
                _dwContext = 0;  // zero context so it is not found by search
                _dwFlags |= fBEEN_USED;
            }

            if (!fExclusive)
            {
                LOCK_DOWNGRADE(_mxs, &cookie);
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = E_OUTOFMEMORY;
            IUnknown *pUnk = new ((PBYTE) *ppIM) CpUnkMoniker(this, hr);
            if (SUCCEEDED(hr))
            {
                hr = pUnk->QueryInterface(IID_IMiniMoniker, (void **) ppIM);
            }
            if (pUnk)
            {
                pUnk->Release();
            }

            ClsCacheDebugOut((DEB_ACTIVATE, "CLSvrClassEntry::GetClassInterface: %s, hr = 0x%x, this = 0x%x\n",
                              HR2STRING(hr), hr, this));
        }
        
        return hr;
    }
    else
    {
        ClsCacheDebugOut((DEB_ERROR, "CLSvrClassEntry::GetClassInterface: FAILED, class suspended. this = 0x%x\n", this));
        return CO_E_SERVER_STOPPING;
    }

}


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CLSvrClassEntry::AddToApartmentChain
//
//  Synopsis:   Add this object to the apartment's chain of lsvr's
//
//  Arguments:  none
//
//  Returns:    none
//
//  Algorithm:  Get the correct chain, add it to the front
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CLSvrClassEntry::AddToApartmentChain()
{

    ClsCacheDebugOut((DEB_ACTIVATE, "AddToApartmentChain: this = 0x%x\n", this));
    ASSERT_LOCK_HELD(_mxs);

    Win4Assert((_pNextLSvr == this) && (_pPrevLSvr == this) && "Object is already a member of the apartment chain");

    CLSvrClassEntry *pFront = GetApartmentChain(TRUE);
    if (pFront == 0)
    {
        return E_OUTOFMEMORY;
    }

    _pNextLSvr = pFront->_pNextLSvr;
    _pPrevLSvr = pFront;
    pFront->_pNextLSvr->_pPrevLSvr = this;
    pFront->_pNextLSvr = this;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CLSvrClassEntry::RemoveFromApartmentChain
//
//  Synopsis:   Remove this object from the apartment's chain of lsvr's
//
//  Arguments:  none
//
//  Returns:    none
//
//  Algorithm:  Remove the object
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
void CClassCache::CLSvrClassEntry::RemoveFromApartmentChain()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "RemoveFromApartmentChain: this = 0x%x\n", this));
    ASSERT_LOCK_HELD(_mxs);

    Win4Assert(_pNextLSvr != this && "Object is not a member of the apartment chain");

    _pNextLSvr->_pPrevLSvr = _pPrevLSvr;
    _pPrevLSvr->_pNextLSvr = _pNextLSvr;
    _pPrevLSvr = this;
    _pNextLSvr = this;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CLSvrClassEntry::Release
//
//  Synopsis:   Controlled destruction of a CLSvrClassEntry object
//
//  Arguments:  pFC      - [in] a pointer to a CFinsishComposite object
//                         for attaching IFinish interfaces.
//
//  Returns:    S_OK     - operation succeeded
//
//  Algorithm:  if already releasing, cancel
//              zero context and flags
//              remove from CClassEntry object (if needed) and Apt chain
//              create a CFinishObject to release the server and
//                  notify the SCM.
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CLSvrClassEntry::Release(CFinishObject *pFO)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CLSvrClassEntry::Release: this = 0x%x, pFO = 0x%x\n", this, pFO));
    ASSERT_LOCK_HELD(_mxs);

    HRESULT hr = S_OK;

    pFO->Init(this);
    RemoveFromApartmentChain();
    _pClassEntry->RemoveBaseClassEntry(this);

    delete this;

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CLSvrClassEntry::GetDDEInfo
//
//  Synopsis:   Fills a DDECLASSINFO object with the state from this object
//
//  Arguments:  lpDdeClassInfo  - [in/out] the object to fill out
//              ppIM            - [out] Moniker to make a server if asked for
//
//  Returns:    S_OK     - operation succeeded
//              E_FAIL   - operation failed
//              PROPOGATE:CLSverClassEntry::GetClassInterface
//
//  Algorithm:  if the context mask and the current apartment match
//                  fill out the DDEInfo structure
//                  if asked for get the moniker
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CLSvrClassEntry::GetDDEInfo(LPDDECLASSINFO lpDdeClassInfo,
                                                 IMiniMoniker **ppIM)
{
    ClsCacheDebugOut((DEB_ACTIVATE,"CClassCache::CLSvrClassEntry::GetDDEInfo: "
                      "lpDdeClassInfo = 0x%x, ppIM = 0x%x", lpDdeClassInfo, ppIM));
    ASSERT_LOCK_HELD(_mxs);
    Win4Assert(IsValidPtrOut(lpDdeClassInfo, sizeof(LPDDECLASSINFO))  &&
               "CLSvrClassEntry::GetDDEInfo invalid out parameter");

    if (lpDdeClassInfo->dwContextMask & _dwContext)
    {
        HAPT hApt = GetCurrentApartmentId();

        if (hApt == _hApt)
        {
            // Found a matching record, set its info
            lpDdeClassInfo->dwContext         = _dwContext;
            lpDdeClassInfo->dwFlags           = _dwFlags;
            lpDdeClassInfo->dwThreadId        = _hApt;
            Win4Assert(_dwCookie);
            lpDdeClassInfo->dwRegistrationKey = _dwCookie;

            if (lpDdeClassInfo->fClaimFactory == TRUE)
            {
                HRESULT hr = GetClassInterface(ppIM);
                if (FAILED(hr))
                {
                    return hr;
                }
            }
            else
            {
                lpDdeClassInfo->punk = NULL;
                *ppIM = 0;
            }

            return S_OK;
        }
    }

    return E_FAIL;
}



//////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CLSvrClassEntry::CFinishObject ///////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CLSvrClassEntry::CFinishObject::Finish
//
//  Synopsis:   Finishes up revoking a server
//
//  Arguments:  none
//
//  Returns:    S_OK     - operation succeeded
//              CO_E_RELEASED   - object already released
//
//  Algorithm:  Tell the SCM this class has stopped
//              Notify the DDE Server
//              Release the server
//              delete the CLSvrClassEntry object
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CLSvrClassEntry::CFinishObject::Finish()
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    ClsCacheDebugOut((DEB_ACTIVATE,"CLSvrClassEntry::CFinishObject::Finish: this = 0x%x\n", this));
    HRESULT hr;

    // Tell SCM about multiple use classes stopping.
    if (_dwScmReg != NO_SCM_REG)
    {
        gResolver.NotifyStopped(_clsid, _dwScmReg);
    }

    // If a DDE Server window exists for this class, then we need to
    // release it now.
    if (_hWndDdeServer != NULL)
    {
        // It's possible that SendMessage could fail. However, there
        // really isn't anything we can do about it. So, the error
        // code is not checked.
        SSSendMessage(_hWndDdeServer, WM_USER, 0, 0);
        _hWndDdeServer = NULL;

    }

    // Now really release it
    if (IsValidInterface(_pUnk))
    {
        CoDisconnectObject(_pUnk, NULL);
        _pUnk->Release();

        hr = S_OK;
    }
    else
    {
        ClsCacheDebugOut((DEB_ERROR,"CLSVRClassEntry::CFinishObject::Finish: Registered server destroyed before revoke!!!\n"));
        hr = CO_E_RELEASED;
    }

    return hr;
}




//////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CDllPathEntry ////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::Create_rl
//
//  Synopsis:   Create a CDllPathEntry object
//
//  Arguments:  dip     - [in] DLL instantiation parameters
//              ap      - [in] Activation properties
//              pDPE    - [out] created CDllPathEntry
//
//  Returns:    S_OK    - operation succeeded
//              PROPOGATE:CDllPathEntry::LoadDll
//              PROPOGATE:CDllPathEntry::MakeValidInApartment
//
//  Algorithm:  Release lock, Load Dll, Take lock
//              If the CDllPathObject wasn't created while unlocked
//                 create CDllPathObject, and fill it out
//              make the object valid in this apartment
//
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllPathEntry::Create_rl(DLL_INSTANTIATION_PROPERTIES &dip,
                                              ACTIVATION_PROPERTIES_PARAM ap, CDllPathEntry *&pDPE)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::Create_rl  dip.pzDllPath = \""
                      TSZFMT "\" dip._dwFlags = 0x%x\n",  dip._pzDllPath, dip._dwFlags));
    ASSERT_LOCK_HELD(_mxs);

    HMODULE hDll = 0;
    HRESULT hr = S_OK;

    // load the dll
    LPFNGETCLASSOBJECT  pfnGetClassObject = 0;    // Create object entry point
    DLLUNLOADFNP        pfnDllCanUnload   = 0;    // DllCanUnloadNow entry point

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
    hr  = LoadDll(dip,
                  pfnGetClassObject,
                  pfnDllCanUnload,
                  hDll);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);

    if (FAILED(hr))
    {

        ClsCacheDebugOut((DEB_ERROR, "CDllPathEntry LoadDll Failed this\n"));
        return hr;
    }


    // check to see no one loaded this library while
    // the lock was released.

    hr = CClassCache::SearchDPEHash(dip._pzDllPath, pDPE, dip._dwHash, dip._dwFlags);


    if (FAILED(hr))
    {
        // create a new CDllPathEntry

        hr = E_OUTOFMEMORY;
        pDPE = new CDllPathEntry(dip, hDll, pfnGetClassObject, pfnDllCanUnload);

        if (pDPE)
        {

            pDPE->_psPath = new WCHAR[lstrlenW(dip._pzDllPath)+1];
            if (pDPE->_psPath)
            {

                lstrcpyW(pDPE->_psPath, dip._pzDllPath);

                // add to hash table
                _DllPathEntries.Add(dip._dwHash,  pDPE);
		hr = S_OK;
            }
            else
            {
                delete pDPE;
            }
        }
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::LoadDll
//
//  Synopsis:   Load the DLL
//
//  Arguments:  dip     - [in] DLL instantiation parameters
//              ap      - [in] Activation properties
//              pDPE    - [out] created CDllPathEntry
//
//  Returns:    S_OK    - operation succeeded
//              PROPoGATE:CDllPathEntry::LoadDll
//              PROPOGATE:CDllPathEntry::MakeValidInApartment
//
//  Algorithm:  Load the dll using correct method
//
//
//  History:    18-Nov-96 MattSmit  Created
//              26-Feb-98 CBiks     Removed bogus code that manipulated the
//                                  hard error flag.  It turns out the code
//                                  was originally added because of a Wx86
//                                  Loader bug, but nobody researched it
//                                  enough to figure that out.
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllPathEntry::LoadDll(DLL_INSTANTIATION_PROPERTIES &dip,
                                            LPFNGETCLASSOBJECT &pfnGetClassObject,
                                            DLLUNLOADFNP &pfnDllCanUnload,
                                            HMODULE &hDll)
{

    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::LoadDll dip.pzDllPath = \""
                      TSZFMT "\" dip._dwFlags = 0x%x\n",  dip._pzDllPath, dip._dwFlags));
    ASSERT_LOCK_NOT_HELD(_mxs);

    HRESULT hr = S_OK;
#ifdef WX86OLE
    BOOL fIsX86Dll;
#endif
    if (dip._dwFlags & DLL_INSTANTIATION_PROPERTIES::fIS_OLE32)
    {
        pfnGetClassObject = ::DllGetClassObject;
        pfnDllCanUnload   = 0;
        hDll = 0;
        return S_OK;
    }

    if (dip._dwFlags & DLL_INSTANTIATION_PROPERTIES::fSIXTEEN_BIT)
    {
        ClsCacheDebugOut((DEB_ACTIVATE,
                          "Attempting to load 16 bit DLL " TSZFMT "\n\n", dip._pzDllPath));

        // In this section, we need to call 16-bit DllGetClassObject. The
        // g_OleThunkWow pointer is the VTABLE to use for getting back to
        // the 16-bit implementation.
        hr = g_pOleThunkWOW->LoadProcDll(dip._pzDllPath,
                                         (DWORD *)&pfnGetClassObject,
                                         (DWORD *)&pfnDllCanUnload,
                                         (DWORD *)&hDll);

        // A failure condition would mean that the DLL could not be found,
        // or otherwise could not be loaded
        if (FAILED(hr))
        {
            ClsCacheDebugOut((DEB_ERROR,
                              "Load 16 bit DLL " TSZFMT " failed(%x)\n\n",dip._pzDllPath,hr));
            return CO_E_DLLNOTFOUND;
        }

        // The other possible error is the DLL didn't have the required
        // interface
        if (pfnGetClassObject == NULL)
        {
            ClsCacheDebugOut((DEB_ERROR,
                              "Get pfnGetClassObject %ws failed\n\n",
                              dip._pzDllPath));

            return(CO_E_ERRORINDLL);
        }

    }
    else
    {
        ClsCacheDebugOut((DEB_ACTIVATE,
                          "Attempting to load 32 bit DLL " TSZFMT "\n\n", dip._pzDllPath));

#ifdef WX86OLE
        hDll = NULL;
        if (dip._dwFlags & DLL_INSTANTIATION_PROPERTIES::fWX86)
        {
            //  If caller asked for an x86 DLL via CLSCTX_INPROC_HANDLERX86 or
            //  CLSCTX_INPROC_SERVERX86 then try to load it using Wx86.
            //  Before loading we need to ensure that wx86 is loaded and take an
            //  additional reference to it.
            if (gcwx86.ReferenceWx86())
            {
                hDll = gcwx86.LoadX86Dll(dip._pzDllPath);
                if (hDll == NULL)
                {
                    gcwx86.DereferenceWx86();
                }
            }
        }

        if ( hDll == NULL )
        {
            //  If the DLL was found in InprocServer32 or x86 load failed then
            //  try loading the DLL as native.

            hDll = LoadLibraryExW(dip._pzDllPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

            if ( (hDll == NULL) && (GetLastError() == ERROR_BAD_EXE_FORMAT) )
            {
                //  If the native load failed because of an architecture mismatch...
                if ( (dip._dwFlags & DLL_INSTANTIATION_PROPERTIES::fWX86) == 0 )
                {
                    //  If the caller originally asked for a native DLL then retry
                    //  the load via Wx86.
                    //  Before loading we need to ensure that wx86 is loaded and
                    //  take an additional reference to it.
                    if (gcwx86.ReferenceWx86())
                    {
                        hDll = gcwx86.LoadX86Dll(dip._pzDllPath);
                        if (hDll == NULL)
                        {
                            gcwx86.DereferenceWx86();
                        }
                    }
                }
            }
        }
#else // WX86OLE
        hDll = LoadLibraryExW(dip._pzDllPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
#endif // WX86OLE

        if (hDll == NULL)
        {
            //  Dll could not be loaded
            ClsCacheDebugOut((DEB_ERROR,
                              "Load of " TSZFMT " failed\n\n",
                              dip._pzDllPath));
            return HRESULT_FROM_WIN32(GetLastError());
        }
#ifdef WX86OLE
        fIsX86Dll = gcwx86.IsModuleX86(hDll);
        if (fIsX86Dll)
        {
            dip._dwFlags |= DLL_INSTANTIATION_PROPERTIES::fLOADED_AS_WX86;
        }
#endif

        // Get the entry points if desired

#ifdef WX86OLE
        pfnGetClassObject = (LPFNGETCLASSOBJECT) GetProcAddress(hDll, DLL_GET_CLASS_OBJECT_EP);
        if ((pfnGetClassObject == NULL) ||
            (fIsX86Dll && ( (pfnGetClassObject = gcwx86.TranslateDllGetClassObject(pfnGetClassObject)) == NULL)))
#else
        if ((pfnGetClassObject = (LPFNGETCLASSOBJECT) GetProcAddress(hDll, DLL_GET_CLASS_OBJECT_EP)) == NULL)
#endif
        {
            // Doesn't have a valid entry point for creation of class objects
            return CO_E_ERRORINDLL;
        }


        // Not having an unload entry point is valid behavior
        pfnDllCanUnload = (DLLUNLOADFNP) GetProcAddress(hDll, DLL_CAN_UNLOAD_EP);
#ifdef WX86OLE
        if (fIsX86Dll)
        {
            // Translating a NULL address will do nothing but return a
            // NULL address
            pfnDllCanUnload = gcwx86.TranslateDllCanUnloadNow(pfnDllCanUnload);
        }
#endif
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::MakeValidInApartment_rl16
//
//  Synopsis:   Makes the dll valid for instantiations in this apartment
//
//  Arguments:  hDll    - [in] handle if dll load already done (16 bit)
//              pfnGetClassObject - [in] entry point if dll already loaded (16 bit)
//              pfnDllCanUnload   - [in] entry point if dll already loaded (16 bit)
//
//  Returns:    S_OK    - operation succeeded
//              E_OUTOFMEMORY - Operation failed due to lack of memory
//              PROPGATE:CDllPathEntry::LoadDll
//
//  Algorithm:  if already valid in apartment return
//              create apartment entry and add it to the list
//              if 16 bit load up the dll on this thread
//
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllPathEntry::MakeValidInApartment_rl16(HMODULE hDll,
                                                              LPFNGETCLASSOBJECT pfnGetClassObject,
                                                              DLLUNLOADFNP pfnDllCanUnload)

{
    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::MakeValidInApartment_rl16: this = 0x%x\n"
                      "hDll = 0x%x, pfnGetClassObject = 0x%x, pfnDllCanUnload 0x%x\n",
                      this, hDll, pfnGetClassObject, pfnDllCanUnload));

    ASSERT_RORW_LOCK_HELD(_mxs);
    LockCookie cookie;

    HRESULT hr = S_OK;
#ifdef WX86OLE
    BOOL fIsX86Dll;
#endif

    //  Walk the list of apartment entries looking for a match
    //  with the current apartment id. If one exists, we are valid,
    //  Otherwise, we will try to create an entry for the current
    //  apartment.
    HAPT hApt = GetCurrentApartmentId();
    if (IsValidInApartment(hApt))
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "Dll " TSZFMT " already valid in apt %d\n",
                          _psPath, hApt));
        return S_OK;
    }
    else
    {
        BOOL fLockReleased;
        LOCK_UPGRADE(_mxs, &cookie, &fLockReleased);
        if (fLockReleased)
        {
            if (IsValidInApartment(hApt))
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "Dll " TSZFMT " already valid in apt %d\n",
                                  _psPath, hApt));
                LOCK_DOWNGRADE(_mxs, &cookie);
                return S_OK;
            }
        }

    }

    ASSERT_WRITE_LOCK_HELD(_mxs);

    // No match found, create a new entry and link up to this DPE
    CDllAptEntry *pAptent = new CDllAptEntry(hApt);


    if (pAptent == 0)
    {
        hr = E_OUTOFMEMORY;
        goto epilog;
    }


    // Dll is always valid for non-WOW case
    if (!(_dwFlags & CDllPathEntry::fSIXTEEN_BIT) || (_dwFlags & CDllPathEntry::fIS_OLE32))
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "Making dll " TSZFMT " valid in apt %d, 32 bit or OLE32\n",
                          _psPath, hApt));
        AddDllAptEntry(pAptent);
        hr = S_OK;
        goto epilog;
    }

    // We need to release the lock across the LoadLibrary since there is
    // a chance that an exiting thread waits on our mutext to
    // CleanUpFoApartment while we wait on the kernel mutex which the
    // exiting thread owns
    // Reset the entry point values on every apartment initialization
    // to handle DLLs being unloaded and then reloaded at a different
    // address.
    if (!hDll)
    {
        DLL_INSTANTIATION_PROPERTIES dip;


        dip.Init(_psPath, 0,
                 ((_dwFlags & fSIXTEEN_BIT) ? DLL_INSTANTIATION_PROPERTIES::fSIXTEEN_BIT : 0) |
#ifdef WX86OLE
                 ((_dwFlags & fWX86) ? DLL_INSTANTIATION_PROPERTIES::fWX86 : 0) |
#endif
                 (wCompareDllName(_psPath, OLE32_DLL, OLE32_CHAR_LEN) ? DLL_INSTANTIATION_PROPERTIES::fIS_OLE32 : 0)
                );
        if (FAILED(hr))
        {
            goto epilog;
        }
        LockCookie cookie2;

        LOCK_RELEASE(_mxs, &cookie2);

        hr = LoadDll(dip,
                     pfnGetClassObject,
                     pfnDllCanUnload,
                     hDll);
        LOCK_RESTORE(_mxs, &cookie2);
        ASSERT_WRITE_LOCK_HELD(_mxs);

#ifdef WX86OLE
        if (dip._dwFlags & DLL_INSTANTIATION_PROPERTIES::fLOADED_AS_WX86)
        {
            _dwFlags |= fWX86;;
        }
#endif
    }
    _pfnGetClassObject = pfnGetClassObject;
    _pfnDllCanUnload = pfnDllCanUnload;

    pAptent->_hDll = hDll;

    if (FAILED(hr))
    {
        delete pAptent;
    }
    else
    {
        AddDllAptEntry(pAptent);

        ClsCacheDebugOut((DEB_ACTIVATE, "Making dll " TSZFMT " valid in apt %d\n",
                          _psPath, hApt));
    }
    epilog:
    ASSERT_WRITE_LOCK_HELD(_mxs);
    LOCK_DOWNGRADE(_mxs, &cookie);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::IsValidInApartment
//
//  Synopsis:   Return whether the current dll is valid in the apartment
//              specified
//
//  Arguments:  hApt     - [in] Apartment to check
//
//  Returns:    TRUE     - Is valid in apartment
//              FALSE    - Is not valid in apartment
//
//  Algorithm:  Sequential search of apartments for one that matches hApt.
//
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
BOOL CClassCache::CDllPathEntry::IsValidInApartment(HAPT hApt)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::IsValidInApartment: this = 0x%x, hApt = 0x%x\n\n", this, hApt));
    ASSERT_RORW_LOCK_HELD(_mxs);

    CDllAptEntry *pDAE = _pAptEntryFront;

    if (_dwFlags & fIS_OLE32)
    {
        return TRUE;
    }

    while (pDAE != (CDllAptEntry *) &_pAptEntryFront)
    {
        if (pDAE->_hApt == hApt)
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::IsValidInApartment:  Valid in current apt\n"));
            return TRUE;
        }
        pDAE = pDAE->_pNext;
    }

    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::IsValidInApartment:  NOT Valid in current apt\n"));
    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::Release
//
//  Synopsis:   Controlled destruction of a CDllPathEntry object
//
//  Arguments:  pFC      - [in/out] pointer to finish composite object to
//                         attach IFinish interfaces
//
//  Returns:    S_OK     - operation succeeded
//
//  Algorithm:  Release the CDllClassEntry objects
//              Remove from DllHash
//
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllPathEntry::Release(CDllPathEntry::CFinishObject *pFO)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::Release: this = 0x%x, _cUsing = %d\n", this, _cUsing));
    ASSERT_LOCK_HELD(_mxs);


    Win4Assert(NoLongerNeeded());

    CDllClassEntry * pDCE, *pDCENext;

    for (pDCE = _p1stClass; pDCE; pDCE = pDCENext)
    {

        pDCENext = pDCE->_pDllClsNext;

        Win4Assert(pDCE->_pClassEntry);

        pDCE->_pClassEntry->RemoveBaseClassEntry(pDCE);


        delete pDCE;

    }

    // remove from dll hash;
    _pPrev->_pNext = _pNext;
    _pNext->_pPrev = _pPrev;

    // free the string
    delete [] _psPath;

    pFO->Init(_hDll32, _dwFlags);

    delete this;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties
//
//  Synopsis:   Registry work to read class and DLL properties
//
//  Arguments:  dwContext   - [in] Context mask
//              rclsid      - [in] CLSID to instantiate
//              dip         - [out] dll instantiaion properties
//
//  Returns:    S_OK     - operation succeeded
//              E_FAIL   - operation failed
//
//  Algorithm:  see comments below
//
//  History:    18-Nov-96 MattSmit  Created
//              26-Feb-98 CBiks     See RAID# 169589.  Factored
//                                  NegotiateDllInstantiationProperties() into
//                                  two functions so the code the the new
//                                  Negotiate...() wouldn't have to be duplicated
//                                  everyplace it was called.
//
//+-------------------------------------------------------------------------


#define PREFIX_STRING_OFFSET (CLSIDBACK_CHAR_LEN + GUIDSTR_MAX)

HRESULT  CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties(
                                                                        DWORD                        dwContext,
                                                                        DWORD                        actvflags,
                                                                        REFCLSID                     rclsid,
                                                                        DLL_INSTANTIATION_PROPERTIES &dip,
                                                                        IComClassInfo *pClassInfo,
                                                                        BOOL fTMOnly)
{
    BOOL fX86TriedFirst = FALSE;
    HRESULT hr = E_FAIL;
    DWORD dwContextX86 = dwContext & CLSCTX_PS_DLL;

    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties2:"
                      "dwContext = 0x%x\n", dwContext));


    //  If any INPROC flags are specified then set the Wx86 equivalents
    //  in a seperate set of context flags.

    //  The only context information we seed Wx86's context with is
    //  the class factory bit.

    if ( dwContext & CLSCTX_INPROC_SERVERS )
    {
        dwContextX86 |= CLSCTX_INPROC_SERVERX86;
    }

    if ( dwContext & CLSCTX_INPROC_HANDLERS )
    {
        dwContextX86 |= CLSCTX_INPROC_HANDLERX86;
    }

    if ( actvflags & ACTVFLAGS_WX86_CALLER )
    {
        //  If the caller is Wx86 and we're trying to load an INPROC then
        //  try the Wx86 flags first.
        if ( dwContextX86 & (CLSCTX_INPROC_HANDLERX86 | CLSCTX_INPROC_SERVERX86) )
        {
            hr = CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties2(
                                                                                 dwContextX86,
                                                                                 rclsid,
                                                                                 dip,
                                                                                 pClassInfo);

            fX86TriedFirst = TRUE;
        }
    }

    if ( !fX86TriedFirst || FAILED( hr ) )
    {
        //  If we didn't try to load the DLL as x86 first, or that load
        //  failed, then try the native load.
        hr = CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties2(
                                                                             dwContext,
                                                                             rclsid,
                                                                             dip,
                                                                             pClassInfo);
    }

    if ( FAILED( hr ) && !fX86TriedFirst )
    {
        //  If the native load failed and we haven't already tried Wx86
        //  then give it a try, if any INPROC flags were specified.
        if ( dwContextX86 & (CLSCTX_INPROC_HANDLERX86 | CLSCTX_INPROC_SERVERX86) )
        {
            HRESULT tempHr;

            tempHr = CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties2(
                                                                                     dwContextX86,
                                                                                     rclsid,
                                                                                     dip,
                                                                                     pClassInfo);

            if (SUCCEEDED(tempHr))
            {
                hr = tempHr;
            }
        }
    }

    return hr;
}

inline HRESULT GetUnquotedPath(IClassClassicInfo* pClassicInfo,
                               CLSCTX             dwContext,
                               WCHAR**            ppwszDllPath,
                               WCHAR*             pTempDllPath)
{
  HRESULT hr = pClassicInfo->GetModulePath(dwContext, ppwszDllPath);
  if (SUCCEEDED(hr))
  {
    // The catalog has prestripped leading and trailing blanks from the path
    // Just strip the quotes

    if ((*ppwszDllPath)[0] == L'\"') {
      // String is Quoted so copy to temp removing leading quote
      wcscpy(pTempDllPath,(*ppwszDllPath)+1);
      *ppwszDllPath = pTempDllPath;

      // Remove trailing " if present
      size_t iLen = wcslen(pTempDllPath);
      if ((iLen > 0) &&
          (pTempDllPath[iLen-1] == L'\"'))
      {
          pTempDllPath[iLen-1] = L'\0';
      }
    }
  }
  return hr;
}


HRESULT  CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties2(
                                                                         DWORD                        dwContext,
                                                                         REFCLSID                     rclsid,
                                                                         DLL_INSTANTIATION_PROPERTIES &dip,
                                                                         IComClassInfo *pClassInfo,
                                                                         BOOL fTMOnly)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties2:"
                      "dwContext = 0x%x\n", dwContext));

    ASSERT_LOCK_NOT_HELD(_mxs);
    HRESULT     hr=S_OK;


    IComClassInfo* pClassInfoToRel=NULL;
    IClassClassicInfo* pClassicInfo=NULL;
    LPWSTR pszDllPath=NULL;
    WCHAR szTempDllPath[MAX_PATH+1];

    if (pClassInfo==NULL)
    {
        hr = GetClassInfoFromClsid(rclsid, &pClassInfo);
        if (FAILED(hr)) goto exit;
        pClassInfoToRel = pClassInfo;
    }
    Win4Assert(NULL != pClassInfo);

    hr=pClassInfo->QueryInterface(IID_IClassClassicInfo, (void**) &pClassicInfo);
    if (FAILED(hr))
    {
        goto exit;
    }
    Win4Assert(NULL != pClassicInfo);

    ULONG       ulDllType;

    //
    // If 16-bit has been requested and we find it, we'll return that.
    //
    if (dwContext & CLSCTX_INPROC_SERVER16)
    {
        hr=GetUnquotedPath(pClassicInfo,CLSCTX_INPROC_SERVER16,&pszDllPath,szTempDllPath);
        if (SUCCEEDED(hr))
        {
            if (wCompareDllName(pszDllPath, OLE2_DLL, OLE2_CHAR_LEN))
            {
                dip.Init(OLE32_DLL, BOTH_THREADED, 0, fTMOnly);
                hr=S_OK;
                goto exit;
            }
            else
            {
                //
                // Otherwise, load the 16-bit fellow but only if in WOW thread.
                //

                if (IsWOWThread())
                {

                    dip.Init(pszDllPath,
                             APT_THREADED,
                             DLL_INSTANTIATION_PROPERTIES::fSIXTEEN_BIT,
                             fTMOnly);

                    goto exit;
                }
            }
        }
    }

#ifdef WX86OLE
    if (dwContext & CLSCTX_INPROC_SERVERX86)
    {
        hr=GetUnquotedPath(pClassicInfo,CLSCTX_INPROC_SERVERX86,&pszDllPath,szTempDllPath);
        if (SUCCEEDED(hr))
        {
            if (wCompareDllName(pszDllPath, OLE32_DLL, OLE32_CHAR_LEN))
            {
                pszDllPath=(LPWSTR) OLE32_DLL;
                ulDllType = BOTH_THREADED;
            }
            else
            {
                hr=pClassicInfo->GetThreadingModel((ThreadingModel*)&ulDllType);
                if (FAILED(hr))
                {
                    hr = REGDB_E_BADTHREADINGMODEL;
                    goto exit;
                }
            }
            //
            // If we are after a proxy/stub dll, then load it as both
            // no matter what the DLL says.
            //

            if (dwContext & CLSCTX_PS_DLL)
                ulDllType = BOTH_THREADED;


            dip.Init(pszDllPath,
                     ulDllType,
                     (pszDllPath == OLE32_DLL ?
                      0 : DLL_INSTANTIATION_PROPERTIES::fWX86),
                     fTMOnly);
            hr=S_OK;
            goto exit;
        }
    }
#endif // WX86OLE

    //
    // Could be that we are trying to load an INPROC_SERVER
    //

    if (dwContext & CLSCTX_INPROC_SERVER)
    {


        hr=GetUnquotedPath(pClassicInfo,CLSCTX_INPROC_SERVER,&pszDllPath,szTempDllPath);
        if (SUCCEEDED(hr))
        {
            if (wCompareDllName(pszDllPath, OLE32_DLL, OLE32_CHAR_LEN))
            {
                pszDllPath=(LPWSTR) OLE32_DLL;
                ulDllType = BOTH_THREADED;
            }
            else
            {
                hr=pClassicInfo->GetThreadingModel((ThreadingModel*) &ulDllType);
                if (FAILED(hr))
                {
                    hr = REGDB_E_BADTHREADINGMODEL;
                    goto exit;
                }
            }

            //
            // If we are after a proxy/stub dll, then load it as both
            // no matter what the DLL says.
            //

            if (dwContext & CLSCTX_PS_DLL)
                ulDllType = BOTH_THREADED;

            //
            // load it.
            //


            hr = S_OK;
            dip.Init(pszDllPath, ulDllType, 0, fTMOnly);


            goto exit;
        }
    }


    //
    // If INPROC_HANDLER16 set, then we look to load a 16-bit handler.
    // If the handler is ole2.dll, then we will load ole32 instead.
    // Otherwise we load the found 16bit dll but only if in a WOW thread.
    //

    if (dwContext & CLSCTX_INPROC_HANDLER16 )
    {
        hr=GetUnquotedPath(pClassicInfo,CLSCTX_INPROC_HANDLER16,&pszDllPath,szTempDllPath);
        if (SUCCEEDED(hr))
        {
            //
            // If the inproc handler is ole2.dll, then subst
            // ole32.dll instead
            //
            if (wCompareDllName(pszDllPath,OLE2_DLL,OLE2_CHAR_LEN))
            {
                dip.Init(OLE32_DLL, BOTH_THREADED, 0, fTMOnly);
                hr=S_OK;
                goto exit;
            }
            else
            {
                // Otherwise, load the 16-bit fellow but only if in WOW thread
                if (IsWOWThread())
                {
                    dip.Init(pszDllPath, APT_THREADED,
                             DLL_INSTANTIATION_PROPERTIES::fSIXTEEN_BIT,
                             fTMOnly);
                    hr=S_OK;
                    goto exit;
                }
            }
        }
    }

    //
    // See about 32-bit handlers. A was a change made after the
    // Win95 (August release) and Windows/NT 3.51 release. Previously
    // the code would give preference to loading 32-bit handlers. This
    // means that even if an ISV provided both 16 and 32-bit handlers,
    // the code would only attempt to provide the 32-bit handler. This
    // was bad because servers with handlers could not be inserted into
    // containers in the wrong model. We have fixed it here.
    //
    // Another thing to watch out for are applications that use our
    // default handler. 16-bit applications can and should be able to
    // use OLE32 has a handler. This will happen if the server app is
    // actually a 32-bit.
    //
    //
#ifdef WX86OLE
    if (dwContext & CLSCTX_INPROC_HANDLERX86)
    {
        hr=GetUnquotedPath(pClassicInfo,CLSCTX_INPROC_HANDLERX86,&pszDllPath,szTempDllPath);
        if (SUCCEEDED(hr))
        {
            // Handlers are both threaded.
            ulDllType=BOTH_THREADED;
            if (wCompareDllName(pszDllPath, OLE32_DLL, OLE32_CHAR_LEN))
            {
                pszDllPath=(LPWSTR) OLE32_DLL;
            }

            //
            // If it turns out this path is for OLE32.DLL, then add the DLL without the
            // path.
            //
            LPCTSTR pDllName = wCompareDllName(pszDllPath,OLE32_DLL,OLE32_CHAR_LEN)?
                               OLE32_DLL:pszDllPath;



            dip.Init(pszDllPath,
                     ulDllType,
                     ((pDllName == OLE32_DLL) ? 0 : DLL_INSTANTIATION_PROPERTIES::fWX86),
                     fTMOnly);

            hr=S_OK;
            goto exit;
        }
    }
#endif

    if (dwContext & CLSCTX_INPROC_HANDLERS)
    {


        if (SUCCEEDED(hr=GetUnquotedPath(pClassicInfo,CLSCTX_INPROC_HANDLER,&pszDllPath,szTempDllPath)))
        {
            // Handlers are both threaded.
            ulDllType=BOTH_THREADED; 
            if (wCompareDllName(pszDllPath, OLE32_DLL, OLE32_CHAR_LEN))
            {
                pszDllPath=(LPWSTR) OLE32_DLL;
            }

            //
            // If it turns out this path is for OLE32.DLL, then add the DLL without the
            // path.
            //
            LPCWSTR pDllName = wCompareDllName(pszDllPath,OLE32_DLL,OLE32_CHAR_LEN)?
                               OLE32_DLL:pszDllPath;

            //
            // If we are looking for a INPROC_HANDER16 and this is OLE32.DLL, or if we
            // are looking for an INPROC_HANDLER, then load this path. Note that pDllName
            // was set above.
            //
            // If we're in a Wow thread the only 32 bit DLL we're allowed to load is
            // OLE32.DLL
            if ((IsWOWThread() && (pDllName == OLE32_DLL)) ||
                (!IsWOWThread() ))
            {
                // Add a 32-bit handler to the pile.
                dip.Init(pDllName, ulDllType, 0, fTMOnly);
                hr=S_OK;
                goto exit;

            }
        }

        else
        {
            // We're here if we couldn't find a 32-bit handler.  If non-Wow caller didn't
            // explicitly request 16-bit handler we'll look for one here.  But the only one
            // allowed is OLE2.DLL => OLE32.DLL
            if (!IsWOWThread() && !(dwContext & CLSCTX_INPROC_HANDLER16))
            {
                hr=GetUnquotedPath(pClassicInfo,CLSCTX_INPROC_HANDLER16,&pszDllPath,szTempDllPath);
                if (SUCCEEDED(hr))
                {
                    //
                    // If the inproc handler is ole2.dll, then subst
                    // ole32.dll instead
                    //
                    if (wCompareDllName(pszDllPath,OLE2_DLL,OLE2_CHAR_LEN))
                    {
                        // Add and load OLE32.DLL
                        dip.Init(OLE32_DLL, BOTH_THREADED, 0, fTMOnly);
                        //return S_OK;
                        goto exit;
                    }
                }
            }
        }
    }


    hr=REGDB_E_CLASSNOTREG;

    exit:

    if (pClassInfoToRel)
    {
        pClassInfoToRel->Release();
        pClassInfoToRel=NULL;
    }
    if (pClassicInfo)
    {
        pClassicInfo->Release();
        pClassicInfo=NULL;
    }
    if (FAILED(hr))
    {
        ClsCacheDebugOut((DEB_TRACE, "CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties:"
                          "returns %x for CLSID %I dwContext = 0x%x\n", hr, &rclsid, dwContext));
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::CanUnload_rl
//
//  Synopsis:   Determine if it is safe to unload a dll
//
//  Arguments:  dwUnloadDelay - [in] amount to age DLL that could be unloaded
//
//  Returns:    S_OK     - operation succeeded can unload
//              S_FALSE  - operation succeeded cannot unload
//
//
//  Algorithm:  see comments below
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllPathEntry::CanUnload_rl(DWORD dwUnloadDelay)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl on " TSZFMT "\n",
                      _psPath));

    // Single thread access to the table
    ASSERT_LOCK_HELD(_mxs);

    // Unless the code is changed, we should not be here in the Wow case
    ClsCacheAssert(!IsWOWProcess() && "Freeing unused libraries in WOW");


    if (_cUsing != 0)
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: Dll in use. Cancel unload. _cUsing = %d", _cUsing));
        // At least one thread is using the object unlocked so we better
        // not release the DLL object.
        return S_FALSE;
    }

    // Does DLL support unloading itself?
    if (_pfnDllCanUnload)
    {
        // Release the lock across outgoing call
        BOOL  fSixteenBit     = _dwFlags & CDllPathEntry::fSIXTEEN_BIT;
        HRESULT       hr;

        _cUsing++;

        _fGCO_WAS_HERE = FALSE;




        // Need to check to see if the class is 16-bit.
        // If it is 16-bit, then this call needs to be routed through a thunk
        if (!fSixteenBit)
        {

            // Call through to the DLL -- does it think it can unload?
            UNLOCK(_mxs);
            ASSERT_LOCK_NOT_HELD(_mxs);
            hr = (*_pfnDllCanUnload)();
            LOCK(_mxs);
            ASSERT_LOCK_HELD(_mxs);

            ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: Dll says %s\n", (hr == S_OK) ? "S_OK" : "S_FALSE"));

            if (hr == S_OK && _fGCO_WAS_HERE)
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: Dll says %s,"
                                  "but GetClassObject touched this dll.\n",
                                  (hr == S_OK) ? "S_OK" : "S_FALSE"));
                // the Dll thinks it's OK to unload, but this DllPathEntry object
                // was touched by GetclassObject while the lock was released
                hr = S_FALSE;
            }
            if (hr == S_OK && _dwFlags & CDllPathEntry::fDELAYED_UNLOAD)
            {
                // the DLL thinks it's OK to unload, but we are employing
                // delayed unloading, so go check if we've reached the
                // expire time yet.

                DWORD dwCurrentTime = GetTickCount();

                // Handle special dwUnloadDelay values
                if (dwUnloadDelay == 0)
                {
                    // A new delay time of 0 overrides any existing delays
                    // Immediate unload requested
                    _dwExpireTime = dwCurrentTime;
                }
                else if (dwUnloadDelay == INFINITE)
                {
                    // Default delay requested
                    dwUnloadDelay = DLL_DELAY_UNLOAD_TIME;
                }


                if (_dwExpireTime == 0)
                {
                    // first time we've reached this state, record the
                    // expire timer. When current time exceeds this time
                    // we can unload.

                    _dwExpireTime = dwCurrentTime + dwUnloadDelay;
                    if (_dwExpireTime < dwUnloadDelay)
                    {
                        // handle counter wrapping, we'll just wait a little
                        // longer once every 49.7 days.
                        _dwExpireTime = dwUnloadDelay;
                    }
                    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: "
                                      "Delaying Unload _dwExpireTime = %d, dwCurrentTime = %d\n",
                                      _dwExpireTime, dwCurrentTime));
                    hr = S_FALSE;
                }
                else
                {
                    if ((_dwExpireTime > dwCurrentTime) ||
                        (dwCurrentTime + dwUnloadDelay < _dwExpireTime))
                    {
                        ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: "
                                          "Still Delaying unload _dwExpireTime = %d, dwCurrentTime = %d\n",
                                          _dwExpireTime, dwCurrentTime));
                        hr = S_FALSE;
                    }
                }
            }
        }
        else  // sixteen-bit
        {
#if defined(_WIN64)

            ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: "
                              "Sundown - This class should not be 16bit,  returning S_FALSE\n"));
            hr = S_FALSE;

#else  // !_WIN64

            if (!IsWOWThread() || !IsWOWThreadCallable())
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: "
                                  "Not On WOW Thread,  returning S_FALSE\n"));
                hr = S_FALSE;
            }
            else
            {
                UNLOCK(_mxs);
                hr = g_pOleThunkWOW->CallCanUnloadNow((DWORD) _pfnDllCanUnload);
                ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: Sixteen bit Dll says %s\n",
                                  (hr == S_OK) ? "S_OK" : "S_FALSE"));

                LOCK(_mxs);
            }

#endif // !_WIN64

        }

        _cUsing--;

        // Check _cUsing in case someone started using this object while
        // the lock was released
        if (_cUsing != 0)
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: SomeOne is using the object now. _cUsing = %d\n",
                              _cUsing));

            hr = S_FALSE;
        }



        return hr;

    }

    return S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::DllGetclassObject
//
//  Synopsis:   Callback method from CDllHost to create the object on
//              the correct thread.
//
//  Arguments:  rclsid   - class id to get
//              riid     - interface it to query
//              ppUnk    - location for object
//
//  Returns:    S_OK     - operation succeeded can unload
//              other    - failed
//
//  Algorithm:  see comments below
//
//  History:    02-Mar-97  MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllPathEntry::DllGetClassObject(REFCLSID rclsid, REFIID riid, LPUNKNOWN * ppUnk, BOOL fMakeValid)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::DllGetClassObject clsid = %I,  riid = %I, ppunk = 0x%x",
                      &rclsid, &riid, ppUnk));
    HRESULT hr = E_FAIL;

    // The Class Cache lock is not currently held.  This is ok because there should
    // be a positive count in _cUsing for this object.
    ASSERT_LOCK_NOT_HELD(_mxs);
    Win4Assert((LONG) _cUsing >= 0);

    // Create the object
    if (_dwFlags & CDllPathEntry::fSIXTEEN_BIT) // 16 bit server
    {

#if defined(_WIN64)

        ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::DllGetClassObject - Sundown: Server should not be 16bits"));
        hr = S_FALSE;

#else  // !_WIN64

        hr = g_pOleThunkWOW->CallGetClassObject((DWORD)_pfnGetClassObject,
                                                rclsid,
                                                riid,
                                                (void **)ppUnk);
#endif // !_WIN64

    }
    else
    {
        // Phew!  32 bit server
        hr = _pfnGetClassObject(rclsid, riid, (void **) ppUnk);

        if (SUCCEEDED(hr) && fMakeValid)
        {
            LOCK_READ(_mxs);
            hr = MakeValidInApartment_rl16();
            UNLOCK_READ(_mxs);
        }

    }

    return hr;
}



//////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CDllPathEntry::CFinishObject /////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::CFinishObject::Finish
//
//  Synopsis:   Finish releasing a CDllPathEntry object
//
//  Arguments:  none
//
//  Returns:    S_OK     - operation succeeded can unload
//
//
//  Algorithm:  free the library, and delete the object
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllPathEntry::CFinishObject::Finish()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CDllPathEntry::CFinishObject::Finish: 0x%x\n", this));
    ASSERT_LOCK_NOT_HELD(_mxs);

    if (_hDll)
    {
#ifdef WX86OLE
        if (_dwFlags & CDllPathEntry::fWX86)
        {
            gcwx86.FreeX86Dll(_hDll);
            gcwx86.DereferenceWx86();
        }
        else
#endif
        {
            if (_dwFlags & CDllPathEntry::fSIXTEEN_BIT)
            {
#if defined(_WIN64)
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CDllPathEntry::CFinishObject::Finish: Sundown - DllPathEntry should not be 16bit\n"));
                return( S_FALSE );
#else   // !_WIN64
                g_pOleThunkWOW->UnloadProcDll(_hDll);
#endif  // !_WIN64
            }
            else if (!(_dwFlags & CDllPathEntry::fIS_OLE32))
            {
                FreeLibrary(_hDll);
            }
        }
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CDllAptEntry /////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllAptEntry::Release
//
//  Synopsis:   Release an apartment entry
//
//  Arguments:  pFC  - [in/out] CFinishComposite object for adding IFinish
//              interfaces.
//
//  Returns:    S_OK     - operation succeeded can unload
//
//
//  Algorithm:  if there is a dll handle create a finish object to free it.
//              remove from the apartment list, delete this apartment.
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllAptEntry::Release(CDllPathEntry::CFinishObject *pFO, BOOL &fUsedFO)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CDllAptEntry::Release: this = 0x%p\n", this));
    ASSERT_LOCK_HELD(_mxs);

    if (_hDll)
    {
        pFO->Init(_hDll, CDllPathEntry::fSIXTEEN_BIT);
        fUsedFO = TRUE;
    }

    _pNext->_pPrev = _pPrev;
    _pPrev->_pNext = _pNext;

    delete this;
    return S_OK;
}





//////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CFinishComposite /////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CFinishComposite:~CFinishComposite
//
//  Synopsis:   Destructor
//
//  Arguments:  none
//
//  Returns:    n/a
//
//  Algorithm:  Release all aquired interfaces
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
CClassCache::CFinishComposite::~CFinishComposite()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CFinishComposite: Destructing this = 0x%x\n", this));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    node *p, *pNextNode;
    FOREACH_SAFE(p, _pFinishNodesFront, pNextNode, _pNext)
    {
        if (p->_pIF)
        {
            delete p->_pIF;
        }
        delete p;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CFinishComposite:Finish
//
//  Synopsis:   Executes the finish operation
//
//  Arguments:  none
//
//  Returns:    n/a
//
//  Algorithm:  for all interfaces, call Finish and release the interface
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CFinishComposite::Finish()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CFinishComposite::Finish this = 0x%x\n", this));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    HRESULT hr;
    node *p, *pNextNode;
    FOREACH_SAFE(p, _pFinishNodesFront, pNextNode, _pNext)
    {
        if (p->_pIF)
        {
            hr = p->_pIF->Finish();
            delete p->_pIF;
        }
        delete p;
    }
    _pFinishNodesFront = (node *) &_pFinishNodesFront;
    _pFinishNodesBack  = (node *) &_pFinishNodesFront;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CDllFnPtrMoniker ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CClassCache::CDllFnPtrMoniker::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
    {
        return E_INVALIDARG;
    }


    *ppv = NULL;
    if (riid == IID_IUnknown)
    {
        *ppv = this;
    }
    else if (riid == IID_IMiniMoniker)
    {
        *ppv = (IMiniMoniker*) this;
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        return S_OK;
    }
    else
    {

        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CClassCache::CDllFnPtrMoniker::AddRef()
{
    return InterlockedIncrement((PLONG) &_cRefs);
}

STDMETHODIMP_(ULONG) CClassCache::CDllFnPtrMoniker::Release()
{
    ULONG ret = (ULONG)  InterlockedDecrement((PLONG) &_cRefs);

    if (ret == 0)
    {
        delete this;
    }
    return 0;
}



//+----------------------------------------------------------------------------
//
//  Member:        CClassCache::GetActivatorFromDllHost
//
//  Synopsis:      figure out where this dll should be activated and get an
//                 apartment token
//
//  History:       25-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CClassCache::GetActivatorFromDllHost(BOOL fSixteenBit,
                                             DWORD dwDllThreadModel,
                                             HActivator *phActivator)
{

    ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetActivatorFromDllHost IN fSixteenBit:%s, "
                      "dwDllThreadModel:0x%x, phActivator:0x%x\n",
                      fSixteenBit ? "TRUE" : "FALSE", dwDllThreadModel, phActivator));

    ASSERT_LOCK_NOT_HELD(_mxs);
    HRESULT hr = S_OK;

    // attach reference to the out parameter
    HActivator &hActivator = *phActivator;


    // Need to check to see if the class is 16-bit or not.
    // If it is 16-bit, then this call needs to be routed through
    // a thunk
    if (!fSixteenBit)
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetActivatorFromDllHost - 32 bit factory\n"));
        // Find 32 bit interface
        //
        // We load single threaded DLLs specially if we are not in WOW.
        // The reason for this is that the initial release of Daytona
        // did not know about multiple threads and therefore, we want
        // to make sure that they don't get inadvertently multithreaded.
        // The reason we don't have to do this if we are in WOW is that
        // only one thread is allowed to execute at a time even though
        // there are multiple physical threads and therefore the DLL
        // will never be executed in a multithreaded manner.

        BOOL fThisThread = TRUE;
        switch (dwDllThreadModel)
        {
        case SINGLE_THREADED:
            if ((!IsWOWProcess() || !IsWOWThread() || !IsWOWThreadCallable())
                && (!OnMainThread() || IsThreadInNTA()))
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetActivatorFromDllHost - passing call to main thread\n"));
                // Pass the call to the main thread
                fThisThread = FALSE;
                if (IsMTAThread())
                {
                    hr = DoSTMTApartmentCreate(hActivator);
                }
                else
                {
                    hr = DoSTApartmentCreate(hActivator);
                }
            }
            break;

        case APT_THREADED:
            if (IsMTAThread() || IsThreadInNTA())
            {
                // pass call to apartment thread worker
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetActivatorFromDllHost - passing call to apartment thread worker\n"));
                fThisThread = FALSE;
                hr = DoATApartmentCreate(hActivator);
            }
            break;

        case FREE_THREADED:
            if (IsSTAThread() || IsThreadInNTA())
            {
                // pass call to MTA
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetActivatorFromDllHost - passing call to MTA\n"));

                fThisThread = FALSE;
                hr = DoMTApartmentCreate(hActivator);
            }
            break;

        case BOTH_THREADED:
            break;

        case NEUTRAL_THREADED:
            if (!IsThreadInNTA())
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetActivatorFromDllHost - passing call to NTA\n"));

                fThisThread = FALSE;
                hr = DoNTApartmentCreate(hActivator);
            }
            break;
        }

        if (fThisThread)
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetActivatorFromDllHost - creating on this thread\n"));
            hr = S_OK;

            // return the special (phoney) cookie to signify same apartment
            hActivator = CURRENT_APARTMENT_TOKEN;
        }

        if (FAILED(hr))
        {
            ClsCacheDebugOut((DEB_ERROR,"CClassCache::GetActivatorFromDllHost failed (0x%x)\n\n",hr));
        }

    }
    else
    {
        ClsCacheDebugOut((DEB_ACTIVATE,
                          "CClassCache::GetActivatorFromDllHost setting apartment for 16 bit factory\n"));

        //
        // Check to be sure this is a sensible situation for a 16bit server.
        //

        if (!IsWOWProcess())
        {
            ClsCacheDebugOut((DEB_ACTIVATE,
                              "CClassCache::GetActivatorFromDllHost: on 16bit; not in VDM\n\n"));
            return E_FAIL;
        }

        if (!IsWOWThread())
        {
            ClsCacheDebugOut((DEB_ACTIVATE,
                              "CClassCache::GetActivatorFromDllHost on 16bit; not in 16-bit thread\n\n"));
            return E_FAIL;
        }

        // 16 bit inproc servers are always used in the current apartment
        if (SUCCEEDED(hr))
        {
            hActivator = CURRENT_APARTMENT_TOKEN;
        }
    }

    ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetActivatorFromDllHost OUT"
                      "*phActivator:0x%x, hr:0x%x\n", *phActivator, hr));
    return hr;

}


HRESULT HelperGetImplementedClsid(IComClassInfo* pCI, /*[in]*/ CLSID* pConfigCLSID, /*[out]*/ CLSID* pImplCLSID)
{
    HRESULT hr=E_FAIL;
    IClassClassicInfo* pClassicInfo=NULL;
    Win4Assert(pImplCLSID);
    Win4Assert(pConfigCLSID);

    if (!pCI)
    {
        IComClassInfo* pTemp=NULL;
        hr = GetClassInfoFromClsid(*pConfigCLSID, &pTemp);
        if (FAILED(hr))
            return hr;

        hr=pTemp->QueryInterface(IID_IClassClassicInfo, (void**) &pClassicInfo);
        pTemp->Release();
    }
    else
    {
        hr=pCI->QueryInterface(IID_IClassClassicInfo, (void**) &pClassicInfo);
    }

    // Now check the result of the QI
    if (SUCCEEDED(hr))
    {
        // Use temporary pointer because pTemp's life time is bound by the class info object's life time
        CLSID* pTemp=NULL;
        hr=pClassicInfo->GetImplementedClsid(&pTemp);
        if (FAILED(hr))
        {
            Win4Assert(FALSE && "IClassClassicInfo::GetImplementedCLSID failed in HelperGetImplementedClsid");
            // Fall back: use configured class id
            *pImplCLSID=*pConfigCLSID;
        }
        else
        {
            // Copy the buffer
            Win4Assert(pTemp);
            *pImplCLSID=*pTemp;
        }
        pClassicInfo->Release();
        pClassicInfo=NULL;
    }
    else
    {
        Win4Assert(FALSE && "QI for IClassClassicInfo failed in HelperGetImplementedClsid");
        // Fall back: use configured class id
        *pImplCLSID=*pConfigCLSID;
    }
    return hr;
}

// IMiniMoniker


HRESULT CClassCache::CDllFnPtrMoniker::CheckApt()
{

    BOOL fThisApartment = TRUE;
    switch (_pDCE->_dwDllThreadModel)
    {
    case SINGLE_THREADED:
        if ((!IsWOWProcess() || !IsWOWThread() || !IsWOWThreadCallable())
            && !OnMainThread())
        {
            fThisApartment = FALSE;
        }
        break;

    case APT_THREADED:
        if (IsThreadInNTA() || IsMTAThread())
        {
            fThisApartment = FALSE;
        }
        break;
    case FREE_THREADED:
        if (IsThreadInNTA() || IsSTAThread())
        {
            fThisApartment = FALSE;
        }
        break;
    case BOTH_THREADED:
        break;
    case NEUTRAL_THREADED:
        fThisApartment = FALSE;
        break;
    }

    return fThisApartment ? S_OK : CLASS_E_CLASSNOTAVAILABLE;
}

HRESULT CClassCache::CDllFnPtrMoniker::CheckNotComPlus()
{

    return(_pDCE->_pClassEntry->_dwFlags & CClassEntry::fCOMPLUS) ?
    E_FAIL :
    S_OK;
}
//+----------------------------------------------------------------------------
//
//  Member:        CClassCache::CDllFnPtrMoniker::BindToObjectNoSwitch
//
//  Synopsis:      BindToObject which does not switch threads.
//
//  History:       28-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CClassCache::CDllFnPtrMoniker::BindToObjectNoSwitch(
                                                           REFIID  riid,
                                                           void**  ppvResult)
{
    return _pDCE->_pDllPathEntry->DllGetClassObject(_pDCE->_impclsid, riid, (IUnknown **) ppvResult, TRUE);
}

HRESULT CClassCache::CDllFnPtrMoniker::GetDCE(CClassCache::CDllClassEntry **ppDCE)
{

    LOCK(_mxs);
    _pDCE->Lock();
    UNLOCK(_mxs);
    *ppDCE = _pDCE;
    return S_OK;
}
//+----------------------------------------------------------------------------
//
//  Member:        CClassCache::CDllFnPtrMoniker::BindToObject
//
//  Synopsis:      Switchs to the correct thread and calls into the DLL to
//                 get the class object
//
//  History:       28-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CClassCache::CDllFnPtrMoniker::BindToObject(
                                                   REFIID  riid,
                                                   void**  ppvResult)

{
    char* msghdr = "CDllFnPtrMoniker::BindToObject - ";

    ClsCacheDebugOut((DEB_ACTIVATE, "CDllFnPtrMoniker::BindToObject\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    HRESULT hr = S_OK;

    //
    // Need to check to see if the class is 16-bit or not.  If it is 16-bit,
    // then this call needs to be routed through a thunk.
    //

    if (!(_pDCE->_pDllPathEntry->_dwFlags & CDllPathEntry::fSIXTEEN_BIT))
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "%screating 32-bit factory\n", msghdr));

        //
        // Find 32 bit interface
        //
        // We load single threaded DLLs specially if we are not in WOW.
        // The reason for this is that the initial release of Daytona
        // did not know about multiple threads and therefore, we want
        // to make sure that they don't get inadvertently multithreaded.
        // The reason we don't have to do this if we are in WOW is that
        // only one thread is allowed to execute at a time even though
        // there are multiple physical threads and therefore the DLL
        // will never be executed in a multithreaded manner.
        //

        BOOL fThisApartment = TRUE;
        switch (_pDCE->_dwDllThreadModel)
        {
        case SINGLE_THREADED:

            if ((!IsWOWProcess() || !IsWOWThread() || !IsWOWThreadCallable())
                && (!OnMainThread() || IsThreadInNTA()))
            {
                //
                // Single threaded object, not on a WOW thread and not already
                // in the main thread.  Switch to the main thread to create
                // the object.
                //

                ClsCacheDebugOut((DEB_ACTIVATE, "%sswitching to main thread\n", msghdr));
                fThisApartment = FALSE;
                if (IsMTAThread())
                {
                    hr = DoSTMTClassCreate(_pDCE->_pDllPathEntry,
                                           _pDCE->_pClassEntry->GetCLSID(),
                                           riid,
                                           (IUnknown **) ppvResult);
                }
                else
                {
                    hr = DoSTClassCreate(_pDCE->_pDllPathEntry,
                                         _pDCE->_pClassEntry->GetCLSID(),
                                         riid,
                                         (IUnknown **) ppvResult);
                }
            }
            break;

        case APT_THREADED:

            if (IsThreadInNTA() || IsMTAThread())
            {
                // An apartment model object is being created by code running
                // in the NTA or on an MTA thread.  Switch to an STA thread to
                // create the object.

                ClsCacheDebugOut((DEB_ACTIVATE, "%sswitching to STA worker\n", msghdr));
                fThisApartment = FALSE;
                hr = DoATClassCreate(_pDCE->_pDllPathEntry,
                                     _pDCE->_pClassEntry->GetCLSID(),
                                     riid, (IUnknown **) ppvResult);
            }
            break;

        case FREE_THREADED:

            if (IsThreadInNTA() || IsSTAThread())
            {
                // A freethreaded model object is being created by code
                // running in the NTA or on an STA thread.  Switch to the MTA
                // to create the object.

                ClsCacheDebugOut((DEB_ACTIVATE, "%sswitching to MTA worker\n", msghdr));
                fThisApartment = FALSE;
                hr = DoMTClassCreate(_pDCE->_pDllPathEntry, _pDCE->_pClassEntry->GetCLSID(),
                                     riid, (IUnknown **) ppvResult);
            }
            break;

        case BOTH_THREADED:

            //
            // In all cases, an object marked BOTH is created in the same
            // apartment and on the same thread as the cleint code.
            //

            break;

        case NEUTRAL_THREADED:

            //
            // Create NEUTRAL model objects in the NEUTRAL apartment.
            //

            fThisApartment = FALSE;
            hr = DoNTClassCreate(_pDCE->_pDllPathEntry, _pDCE->_pClassEntry->GetCLSID(),
                                 riid, (IUnknown**) ppvResult);
            break;
        }

        if (fThisApartment)
        {
            //
            // The object can be created in same apartment as the client.
            // Return a direct pointer to its class factory.
            //

            ClsCacheDebugOut((DEB_ACTIVATE, "%screating in current apt\n", msghdr));
            hr = _pDCE->_pDllPathEntry->DllGetClassObject(_pDCE->_impclsid, riid, (IUnknown **) ppvResult, FALSE);
        }

        if (FAILED(hr))
        {
            ClsCacheDebugOut((DEB_ACTIVATE,"%sfailed (0x%x)\n\n", msghdr, hr));
        }

    }
    else
    {
#if defined(_WIN64)

        ClsCacheDebugOut((DEB_ACTIVATE, "%sfailed - Sundown: We should not create 16 bit factory\n", msghdr));
        hr = E_FAIL;

#else   // !_WIN64

        ClsCacheDebugOut((DEB_ACTIVATE, "%screating 16 bit factory\n", msghdr));

        //
        // Find 16-bit interface.
        //

        if (!IsWOWProcess())
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "%son 16bit; not in VDM\n\n", msghdr));
            return E_FAIL;
        }

        if (!IsWOWThread())
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "%son 16bit; not in 16-bit thread\n\n", msghdr));
            return E_FAIL;
        }

        LOCK(_mxs);
        hr = _pDCE->_pDllPathEntry->MakeValidInApartment_rl16();
        UNLOCK(_mxs);
        if (SUCCEEDED(hr))
        {
            hr = g_pOleThunkWOW->CallGetClassObject((DWORD)_pDCE->_pDllPathEntry->_pfnGetClassObject,
                                                    _pDCE->_pClassEntry->GetCLSID(),
                                                    riid,
                                                    (void **)ppvResult);

            if (FAILED(hr))
            {
                ClsCacheDebugOut((DEB_ACTIVATE,
                                  "CDllFnPtrMoniker::BindToObject 16-bit failed (0x%x)\n\n",hr));
            }
        }

#endif // !_WIN64

    }

    return hr;
}




/////////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CpUnkMoniker ////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClassCache::CpUnkMoniker::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
    {
        return E_INVALIDARG;
    }

    *ppv = NULL;
    if (riid == IID_IUnknown)
    {
        *ppv = (IUnknown *)this;
    }
    else if (riid == IID_IMiniMoniker)
    {
        *ppv = (IMiniMoniker*) this;
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        return S_OK;
    }
    else
    {

        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CClassCache::CpUnkMoniker::AddRef()
{
    return InterlockedIncrement((PLONG) &_cRefs);
}

STDMETHODIMP_(ULONG) CClassCache::CpUnkMoniker::Release()
{
    ULONG ret = (ULONG)  InterlockedDecrement((PLONG) &_cRefs);

    if (ret == 0)
    {
        delete this;
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Member:        CClassCache::CpUnkMoniker::BindToObjectNoSwitch
//
//  Synopsis:      delegate to BindToObject see CDllFnPtrMoniker::BindToObjectNoSwitch
//                 for info on why this must be implemented.
//
//  History:       28-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CClassCache::CpUnkMoniker::BindToObjectNoSwitch(REFIID riidResult, void **ppvResult)
{
    return BindToObject(riidResult, ppvResult);
}



//+-------------------------------------------------------------------------
//
//  Function:   CClassCache::CCpUnkMoniker::BindToObject
//
//  Synopsis:   Creates an object based on the internal state
//
//  Arguments:  riid   - [in] IID to return
//              ppvResult - [out] where to put the new object
//
//  Returns:    S_OK   -  operation succeeded
//              PROPOGATE:QueryInterface
//
//
//  Algorithm:  see comments below
//
//  History:    09-Sep-96  MattSmit   Created
//
//+-------------------------------------------------------------------------

HRESULT CClassCache::CpUnkMoniker::BindToObject(REFIID riidResult, void **ppvResult)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CpUnkMoniker::BindToObject\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    // Since we are being called on behalf of SCM we know that
    // we are being invoked remotely. Set the Wx86 stub invoked flag
    // if we are calling into x86 code so that any custom interfaces
    // can be thunked back and not rejected.
#ifdef WX86OLE
    if (gcwx86.IsN2XProxy(_pUnk))
    {
        gcwx86.SetStubInvokeFlag(1);
    }
#endif

    return  _pUnk->QueryInterface(riidResult, ppvResult);
}

HRESULT CClassCache::CpUnkMoniker::GetDCE(CClassCache::CDllClassEntry **ppDCE)
{
    return E_NOTIMPL;
}

HRESULT CClassCache::CpUnkMoniker::CheckApt()
{
    return S_OK;
}
HRESULT CClassCache::CpUnkMoniker::CheckNotComPlus()
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////
// CClassCache ///////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   Initialize the ClassCache.
//
//  Arguments:  none
//
//  Returns:    TRUE/FALSE - Init success
//
//  Algorithm:  If the ClassCache has not been initialized, initialize it.
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
BOOL CClassCache::Init()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Init\n"));
    ASSERT_LOCK_NOT_HELD(_mxs);
    STATIC_WRITE_LOCK(lck, _mxs);

    if (!(_dwFlags & fINITIALIZED))
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Init -- Initializing\n"));
        // initilize some hash tables
        _ClassEntries.Initialize(_CEBuckets, &_mxs);
        _DllPathEntries.Initialize(_DPEBuckets, &_mxs);



        // initialize some page tables
        CDllPathEntry::_palloc.Initialize(sizeof(CDllPathEntry), CDllPathEntry::_cNumPerPage,
                                          NULL);
        CClassEntry::_palloc.Initialize(sizeof(CClassEntry), CClassEntry::_cNumPerPage,
                                        NULL);
        CDllClassEntry::_palloc.Initialize(sizeof(CDllClassEntry), CDllClassEntry::_cNumPerPage,
                                           NULL);
        CLSvrClassEntry::_palloc.Initialize(sizeof(CLSvrClassEntry), CLSvrClassEntry::_cNumPerPage,
                                            NULL, CPageAllocator::fCOUNT_ENTRIES);
        CLSvrClassEntry::_cOutstandingObjects = 0;
        CDllAptEntry::_palloc.Initialize(sizeof(CDllAptEntry), CDllAptEntry::_cNumPerPage,
                                         NULL);

        // this must be the last thing we do since the API entry
        // points check it without taking the lock.
        _dwFlags |= fINITIALIZED;
    }
    else
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Init -- Already initialized\n"));
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   Collect
//
//  Synopsis:   Clean up unneeded objects
//
//  Arguments:  cNewObjects - Number of new objects to be created
//                            after this collection.
//
//  Returns:    S_OK or error code
//
//  Algorithm:  for each object in the _objectsForCollection list
//                  check that it still valid for collection
//                  check collection policies
//                  delete if above is ok
//
//  History:    11-Mar-97  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::Collect(ULONG cNewObjects)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Collect\n"));
    ASSERT_LOCK_HELD(_mxs);

    _LastObjectCount += cNewObjects;

    DWORD currTickCount = GetTickCount();

    // handle counter wrap
    if (currTickCount < _LastCollectionTickCount)
    {
        _LastCollectionTickCount = 0;
    }

    if ((_LastObjectCount >= _CollectAtObjectCount) ||
        (currTickCount > (_LastCollectionTickCount + _CollectAtInterval)))
    {
        CCollectable *back = 0;
        CCollectable *curr = _ObjectsForCollection;

        while (curr)
        {
            //  if something attached to this, or locked it,
            //  take it out of the collection list

            if (!curr->NoLongerNeeded())
            {
                curr->RemoveCollectee(back);
                CCollectable *tmp = curr;
                curr = curr->_pNextCollectee;
                // back stays the same
                tmp->_pNextCollectee = CCollectable::NOT_COLLECTED;

            }
            else
            {
                // collect this object if it is ready

                if (curr->CanBeCollected())
                {
                    curr->RemoveCollectee(back);
                    CCollectable *tmp = curr;
                    curr = curr->_pNextCollectee;
                    tmp->Release();
                    // back stays the same
                }
                else
                {
                    back = curr;
                    curr = curr->_pNextCollectee;
                }
            }
        }
        _LastCollectionTickCount = GetTickCount();
        _LastObjectCount = 0;
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetOrLoadClass
//
//  Synopsis:   This is an entry point into the ClassCache.  The code for
//              CoGetClassObject uses this as well as the SCM activation code.
//
//  Arguments:  ap  - activation properties
//
//  Returns:    S_OK or error code
//
//  Algorithm:  Attempt different contexts in order (see below)
//              upon success, release the lock and instantiate the moniker
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::GetOrLoadClass(ACTIVATION_PROPERTIES_PARAM ap)

{
    TRACECALL(TRACE_DLL, "CClassCache::GetOrLoadClass ");

    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClass ap._dwContext = 0x%x, ap._dwFlags = 0x%x"
                      "ap._rclsid == %I\n",
                      ap._dwContext, ap._dwFlags, &(ap._rclsid)));

    IMiniMoniker *pIM = (IMiniMoniker *)_alloca(max(sizeof(CDllFnPtrMoniker),
                                                    sizeof(CpUnkMoniker)));
    HRESULT hr = E_FAIL;

    ASSERT_LOCK_NOT_HELD(_mxs);
    DWORD dwCEHash = _ClassEntries.Hash(ap._rclsid, ap._partition);

    IComClassInfo* pCI = ap._pCI;

    if (pCI)
    {
        pCI->AddRef();
    }
    else
    {
        // Windows Bug #107960
        // Look up class info without write lock
        // before call to CClassEntry::Create, which is
        // called by GetOrLoadClassByContext_rl below

        hr = GetClassInfoFromClsid(ap._rclsid, &pCI);
        if (FAILED (hr))
        {
            goto Cleanup;
        }  
    }

    {
        STATIC_WRITE_LOCK(lck, _mxs);

        // check the hash
        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClass: dwCEHash = 0x%x\n", dwCEHash));
        CClassEntry *pCE = _ClassEntries.LookupCE(dwCEHash, ap._rclsid, ap._partition);
        ClsCacheDebugOut((DEB_ACTIVATE,
                          "CClassCache::GetOrLoadClass Lookup for clsid %I %s!\n",
                          &(ap._rclsid), pCE ? "SUCCEEDED" : "FAILED"));
        if (pCE)
        {
            pCE->SetLockedInMemory();
        }



        if (ap._dwFlags & ACTIVATION_PROPERTIES::fFOR_SCM)
        {
            hr = GetOrLoadClassByContext_rl(ap._dwContext & CLSCTX_LOCAL_SERVER, ap, pCI, pCE, dwCEHash, pIM);
        }
        else if (ap._dwFlags & ACTIVATION_PROPERTIES::fRELOAD_DARWIN)
        {
            hr = GetOrLoadClassByContext_rl(ap._dwContext & CLSCTX_INPROC_SERVERS, ap, pCI, pCE, dwCEHash, pIM);
        }
        else
        {
            // try an INPROC_SERVER first
            if (ap._dwContext & CLSCTX_INPROC_SERVERS)
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClass -- trying INPROC_SERVERS\n"));
                hr = GetOrLoadClassByContext_rl(ap._dwContext & CLSCTX_INPROC_SERVERS, ap, pCI, pCE, dwCEHash, pIM);
#ifdef WX86OLE
                if ( FAILED( hr ) )
                {
                    if ( (ap._dwContext & CLSCTX_INPROC_SERVERX86) == 0 )
                    {
                        //  If Wx86 is installed and the call requested a native interface then try to
                        //  get an x86 interface.
                        ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetOrLoadClass -- trying INPROC_SERVERX86\n"));
                        hr = GetOrLoadClassByContext_rl(CLSCTX_INPROC_SERVERX86, ap, pCI, pCE, dwCEHash, pIM);
                    }
                }
#endif
            }

            // that didn't work, so try an INPROC_HANDLER
            if (FAILED(hr) && (ap._dwContext & CLSCTX_INPROC_HANDLERS))
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClass -- trying INPROC_HANDLERS\n"));
                hr = GetOrLoadClassByContext_rl(ap._dwContext & CLSCTX_INPROC_HANDLERS, ap, pCI, pCE, dwCEHash, pIM);
#ifdef WX86OLE
                if ( FAILED( hr ) )
                {
                    if ( (ap._dwContext & CLSCTX_INPROC_HANDLERX86) == 0 )
                    {
                        //  If Wx86 is installed and the call requested a native interface then try to
                        //  get an x86 interface.
                        ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetOrLoadClass -- trying INPROC_HANDLERX86\n"));
                        hr = GetOrLoadClassByContext_rl(CLSCTX_INPROC_HANDLERX86, ap, pCI, pCE, dwCEHash, pIM);
                    }
                }
#endif
            }

            // that didn't work, so try a LOCAL_SERVER
            if (FAILED(hr) && (ap._dwContext & CLSCTX_LOCAL_SERVER))
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClass -- trying INPROC_LOCAL_SERVER\n"));
                hr = GetOrLoadClassByContext_rl(ap._dwContext & CLSCTX_LOCAL_SERVER, ap, pCI, pCE, dwCEHash, pIM);
            }

            if (pCE)
            {
                ASSERT_LOCK_HELD(_mxs);
                BOOL fLockReleased;
                pCE->ReleaseMemoryLock(&fLockReleased);
                Win4Assert(!fLockReleased);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = pIM->BindToObject(ap._riid, (void **) ap._ppUnk);
        pIM->Release();
    }

Cleanup:

    if (pCI)
    {
        pCI->Release();
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CClassCache::SearchForLoadedClass
//
//  Synopsis:      Searches for classes that require little or no work to
//                 activate.  These being classes that are one of
//                 the following, and not a COM+ class.
//                     * registered using CoRegisterClassObject
//                     * dll already loaded, no switching necessary.
//
//  History:       6-May-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CClassCache::SearchForLoadedClass(ACTIVATION_PROPERTIES_PARAM ap,
                                          CDllClassEntry **ppDCE)
{
    ClsCacheDebugOut((DEB_TRACE, "CClassCache::SearchForLoadedClass"
                      " IN ap:0x%x, ppDCE:0x%x\n", &ap, ppDCE));

    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }

    HRESULT hr = S_OK;
    *ppDCE = NULL;
    *(ap._ppUnk) = NULL;

    if (ap._dwContext & CLSCTX_INPROC_SERVERS)
    {
        IMiniMoniker *pMM =  (IMiniMoniker *) _alloca(max(sizeof(CDllFnPtrMoniker),
                                                          sizeof(CpUnkMoniker)));

#ifdef WX86OLE
        hr = E_FAIL;

        if ( (ap._dwContext & CLSCTX_NO_WX86_TRANSLATION) == 0 )
        {
            if ( ap._dwActvFlags & ACTVFLAGS_WX86_CALLER )
            {
                //  If the caller is x86 search for an x86 class first.
                hr = GetClassObjectActivator(CLSCTX_INPROC_SERVERX86 | CLSCTX_PS_DLL,
                                             ap, &pMM);
            }
        }

        if ( ((ap._dwActvFlags & ACTVFLAGS_WX86_CALLER) == 0) || FAILED( hr ) )
        {
            //  If the caller was not x86, or the x86 class was not found,
            //  search for the class type specified by the caller.  Note: this
            //  type may CLSCTX_INPROC_SERVERX86.
            hr = GetClassObjectActivator(ap._dwContext & CLSCTX_INPROC_SERVERS,
                                         ap, &pMM);

            if ( FAILED( hr ) )
            {
                if ( (ap._dwContext & CLSCTX_NO_WX86_TRANSLATION) == 0 )
                {
                    if ( ((ap._dwContext & CLSCTX_INPROC_SERVERX86) == 0) &&
                         ((ap._dwActvFlags & ACTVFLAGS_WX86_CALLER) == 0) )
                    {
                        //  If we still haven't found a class and we haven't tried x86
                        //  yet, then try it.
                        hr = GetClassObjectActivator(CLSCTX_INPROC_SERVERX86 | CLSCTX_PS_DLL,
                                                     ap, &pMM);
                    }
                }
            }
        }
#else
        hr = GetClassObjectActivator(ap._dwContext & CLSCTX_INPROC_SERVERS,
                                     ap, &pMM);
#endif
        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(pMM->CheckApt()) &&
                SUCCEEDED(pMM->CheckNotComPlus()))
            {
#ifdef WX86OLE
                if (ap._dwActvFlags & ACTVFLAGS_WX86_CALLER)
                {
                    gcwx86.SetStubInvokeFlag((UCHAR)-1);
                }
#endif
                hr = pMM->BindToObject(ap._riid, (void **) ap._ppUnk);
#ifdef WX86OLE
                if (ap._dwActvFlags & ACTVFLAGS_WX86_CALLER)
                {
                    gcwx86.SetStubInvokeFlag(0);
                }
#endif
            }
            else
            {
                hr = pMM->GetDCE(ppDCE);
                Win4Assert(SUCCEEDED(hr));
            }
            pMM->Release();
        }
        else
        {
            // we still return success, so the COM+
            // activation will happen.
            hr = S_OK;
        }
    }


    return hr;

}
//+-------------------------------------------------------------------------
//
//  Function:   GetClassObject
//
//  Synopsis:   This is an entry point into the ClassCache.  The code for
//              the server context activator uses this.
//
//  Arguments:  ap  - activation properties
//
//  Returns:    S_OK or error code
//
//  Algorithm:  Search for a DCE for the class.  It must be present by this time.
//              Just call DllGetClassObject on the DPE in the DCE.
//
//  History:    26-Feb-98   SatishT   Created
//              04-Apr-98   CBiks     Added updated support for Wx86 that was removed
//                                    during the Com+ merge.
//
//--------------------------------------------------------------------------

HRESULT CClassCache::GetClassObject(ACTIVATION_PROPERTIES_PARAM ap)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassObject\n"));
    HRESULT hr = E_FAIL;
    ASSERT_LOCK_NOT_HELD(_mxs);
    ASSERT_ONE_CLSCTX(ap._dwContext);
    IMiniMoniker *pIM = (IMiniMoniker *) _alloca(max(sizeof(CDllFnPtrMoniker),
                                                     sizeof(CpUnkMoniker)));

#ifdef WX86OLE
    if ( (ap._dwActvFlags & ACTVFLAGS_WX86_CALLER) &&
         (ap._dwContext & CLSCTX_NO_WX86_TRANSLATION) == 0 )
    {
        //  If the caller is x86 and NO_TRANSLATION is clear, search for an
        //  x86 class first.
        DWORD dwContext = ap._dwContext;

        if (dwContext & CLSCTX_INPROC_SERVER)
        {
            dwContext = (dwContext & ~CLSCTX_INPROC_SERVER) | CLSCTX_INPROC_SERVERX86;
        }
        if (dwContext & CLSCTX_INPROC_HANDLER)
        {
            dwContext = (dwContext & ~CLSCTX_INPROC_HANDLER) | CLSCTX_INPROC_HANDLERX86;
        }

        //ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassObject Activator 1, dwContext=%x\n", dwContext));

        hr = GetClassObjectActivator(dwContext, ap, &pIM);
    }

    if ( ((ap._dwActvFlags & ACTVFLAGS_WX86_CALLER) == 0) || FAILED( hr ) )
    {
        //  If the caller was not x86, or the x86 class was not found,
        //  search for the class type specified by the caller.  Note: this
        //  type may be CLSCTX_INPROC_SERVERX86.

        //ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassObject Activator 2, dwContext=%x\n", ap._dwContext));
        hr = GetClassObjectActivator(ap._dwContext, ap, &pIM);

        if ( FAILED( hr ) &&
             (ap._dwActvFlags & ACTVFLAGS_WX86_CALLER) == 0 &&
             (ap._dwContext & (CLSCTX_NO_WX86_TRANSLATION)) == 0 &&
             (ap._dwContext & (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)) &&
             (ap._dwContext & (CLSCTX_INPROC_SERVERX86|CLSCTX_INPROC_HANDLERX86) != (CLSCTX_INPROC_SERVERX86|CLSCTX_INPROC_HANDLERX86) ))
        {
            // Caller is Alpha, NO_WX86_TRANSLATION is clear,
            // INPROCSERVER is set, and INPROC_SERVERX86 is not.  Try again
            // with INPROCSERVERX86.
            DWORD dwContext = ap._dwContext;

            if (dwContext & CLSCTX_INPROC_SERVER)
            {
                dwContext = (dwContext & ~CLSCTX_INPROC_SERVER) | CLSCTX_INPROC_SERVERX86;
            }
            if (dwContext & CLSCTX_INPROC_HANDLER)
            {
                dwContext = (dwContext & ~CLSCTX_INPROC_HANDLER) | CLSCTX_INPROC_HANDLERX86;
            }

            //ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassObject Activator 3, dwContext=%x\n", dwContext));

            hr = GetClassObjectActivator(dwContext, ap, &pIM);
        }
    }

#else
    hr = GetClassObjectActivator(ap._dwContext, ap, &pIM);
#endif

    //
    // finally activate the object now that the lock is released
    //

    if (SUCCEEDED(hr))
    {
        hr = pIM->BindToObjectNoSwitch(ap._riid, (void **)ap._ppUnk);
        pIM->Release();
    }


    return hr;

}

//+----------------------------------------------------------------------------
//
//  Member:        CClassCache::GetClassObjectActivator
//
//  Synopsis:      Gets the a cache line for a clsid-context pair, no thread
//                 switching.
//
//  History:       6-May-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CClassCache::GetClassObjectActivator(DWORD dwContext,
                                             ACTIVATION_PROPERTIES_PARAM ap,
                                             IMiniMoniker **ppIM)

{
    ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetClassObjectActivator IN\n"));


    HRESULT hr = E_FAIL;



    BOOL fLockUpgraded = FALSE;
    LockCookie cookie;
    BOOL fLockReleased;
    ASSERT_LOCK_NOT_HELD(_mxs);
    ASSERT_ONE_CLSCTX(dwContext);

    DWORD dwCEHash = _ClassEntries.Hash(ap._rclsid,
                                        ap._partition);
    CBaseClassEntry *pBCE = NULL;
    
    IComClassInfo* pCI = ap._pCI;
    if (pCI)
    {
        pCI->AddRef();
    }

    
    LOCK_READ(_mxs);

    //
    // Lookup the ClassEntry
    //
    CClassEntry *pCE = _ClassEntries.LookupCE(dwCEHash, 
                                              ap._rclsid,
                                              ap._partition);

    if (!pCE && !pCI)
    {
        // Windows Bug #107960
        // Look up class info without write lock
        // before call to CClassEntry::Create
        
        UNLOCK_READ(_mxs);

        hr = GetClassInfoFromClsid(ap._rclsid, &pCI);
        if (FAILED (hr))
        {
            ClsCacheDebugOut((DEB_ERROR, "CClassCache::GetClassObjectActivator:"
                              " GetClassInfoFromClsid failed hr = 0x%x\n", hr));
            goto Cleanup;
        }

        LOCK_READ(_mxs);

        pCE = _ClassEntries.LookupCE(dwCEHash, 
                                     ap._rclsid,
                                     ap._partition);
    }

    if (!pCE)
    {
        //
        // Load the class
        //

        if (ap._dwFlags & ACTIVATION_PROPERTIES::fDO_NOT_LOAD)
        {
            ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetClassObjectActivator_rl:"
                              " No class in cache, not loading\n"));
            hr = CO_E_SERVER_STOPPING;
            goto epilog;
        }

        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassObjectActivator_rl:"
                          " No class in cache, "
                          "will attempt to create CE\n"));

        //
        // Create the new CClassEntry
        //
        LOCK_UPGRADE(_mxs, &cookie, &fLockReleased);
        fLockUpgraded = TRUE;
        
        if (fLockReleased)
        {
            pCE = _ClassEntries.LookupCE(dwCEHash, 
                                         ap._rclsid,
                                         ap._partition);
        }

        if (!pCE && FAILED(hr = CClassEntry::Create(ap._rclsid, dwCEHash, pCI, pCE)))
        {
            ClsCacheDebugOut((DEB_ERROR, "CClassCache::GetClassObjectActivator_rl:"
                              " Create failed hr = 0x%x\n", hr));
            goto epilog;
        }
    }

    Win4Assert(pCE->_dwSig);

    //
    // now we have a valid Class Entry (pCE), check to see if we have
    // tried to activate this clsid previously with this context.  If
    // it has failed before, fail it right away unless it is a Darwin
    // reload.
    //
    //
    //    if ( !(ap._dwFlags & ACTIVATION_PROPERTIES::fRELOAD_DARWIN) &&
    //         !(dwContext  & ~pCE->_dwFailedContexts) )
    //    {
    //        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassObjectActivator_rl:"
    //                          " We have already failed this context, exiting,\n"
    //                          "pCE->_dwFailedContexts = 0x%x", pCE->_dwFailedContexts));
    //        hr = E_FAIL;
    //        goto epilog;
    //    }
    //

    //
    // search the class entry for a BCE that meets our criteria,
    // this could come back with either an LSCE or a DCE.
    //
    pCE->SetLockedInMemory();
    fLockReleased = FALSE;
    hr = pCE->SearchBaseClassEntry(dwContext, pBCE,
                                   (ap._dwFlags & ACTIVATION_PROPERTIES::fFOR_SCM),
                                   &fLockReleased);
    if (FAILED(hr))
    {
        if (ap._dwFlags & ACTIVATION_PROPERTIES::fDO_NOT_LOAD)
        {
            ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetClassObjectActivator_rl:"
                              " No class in cache, not loading\n"));
            hr = CO_E_SERVER_STOPPING;
        }
        else if (pCE->IsComplete() &&
                 (dwContext & (CLSCTX_INPROC_SERVERS | CLSCTX_INPROC_HANDLERS)))
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassObjectActivator_rl:"
                              " No class in cache, creating DCE\n"));
            //
            // if there is not an existing BCE the only choice is to
            // try and make a DCE.
            //

            CClassCache::CDllClassEntry *pDCE = 0;

            pCE = pCE->CycleToClassEntry();

            if (fLockUpgraded)
            {
                LOCK_DOWNGRADE(_mxs, &cookie);
            }
            UNLOCK_READ(_mxs);

            hr = pCE->CreateDllClassEntry_rl(dwContext, ap, pDCE);

            LOCK_READ(_mxs);
            fLockUpgraded = FALSE;

            // NOTE: At one time, there was an effort to remember the contexts
            //       a creation had failed in.  This was abandoned because we
            //       didn't have a way to flush the "failed" entries.
            if (SUCCEEDED(hr))
            {
                pBCE = pDCE;
                pDCE->Unlock();
            }            
        }
    }

    // if there is a valid base class entry, then we can use it
    // to get the class factory

    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassObjectActivator_rl:"
                      " Class %s found or loaded, hr = 0x%x\n",
                      FAILED(hr) ? "NOT " : "", hr));

    if (SUCCEEDED(hr))
    {

        hr = pBCE->GetClassInterface(ppIM);

        ClsCacheDebugOut((HRDBG(hr), "CClassCache::GetClassObjectActivator_rl:"
                          " GetClassInterface %s, "
                          "hr = 0x%x\n", HR2STRING(hr), hr));
    }

    pCE->ReleaseMemoryLock(&fLockReleased); // ok if cache lock releases


    epilog:
    if (fLockUpgraded)
    {
        LOCK_DOWNGRADE(_mxs, &cookie);
    }

    UNLOCK_READ(_mxs);

Cleanup:
    
    if (pCI)
    {
        pCI->Release();
    }

    ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetClassObjectActivator OUT hr:0x%x\n", hr));
    ASSERT_LOCK_NOT_HELD(_mxs);
    return hr;

}

//+-------------------------------------------------------------------------
//
//  Function:   GetOrCreateApartment
//
//  Synopsis:   This is an entry point into the ClassCache.  The code for
//              the process activator uses this.
//
//  Arguments:  ap  - activation properties
//
//  Returns:    S_OK or error code
//
//  Algorithm:  Attempt different contexts in order (see below)
//              upon success, release the lock and return the apartment cookie
//
//  History:    25-Feb-98   SatishT   Created
//              04-Apr-98   CBiks     Fixed bug introduced by the Com+ merge.
//                                    Someone removed the () in the Wx86
//                                    tests.
//
//--------------------------------------------------------------------------

HRESULT CClassCache::GetOrCreateApartment(ACTIVATION_PROPERTIES_PARAM ap,
                                          DLL_INSTANTIATION_PROPERTIES *pdip,
                                          HActivator *phActivator)


{
    TRACECALL(TRACE_DLL, "CClassCache::GetOrCreateApartment ");
    ASSERT_ONE_CLSCTX(ap._dwContext);
    Win4Assert(pdip);

    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrCreateApartment "
                      "ap._dwContext = 0x%x, ap._dwFlags = 0x%x"
                      "ap._rclsid == %I\n",
                      ap._dwContext, ap._dwFlags, &(ap._rclsid)));
    HRESULT hr;

    hr = GetActivatorFromDllHost(pdip->_dwFlags & DLL_INSTANTIATION_PROPERTIES::fSIXTEEN_BIT,
                                 pdip->_dwThreadingModel,
                                 phActivator);

    return hr;

}



//+-------------------------------------------------------------------------
//
//  Function:   GetOrLoadClassByContext_rl
//
//  Synopsis:   Helper function to GetOrLoadClass.
//
//  Arguments:  dwContext      - [in] context mask
//              ap             - [in] activation properties
//              pCE            - [in] class entry already looked up
//              dwCEHash       - [in] hash code for pCE
//              pIM            - [out] IMiniMoniker Interface out
//
//  Returns:    S_OK or error code
//
//  Algorithm:  create a class entry if needed
//              search the class entry for a matching context
//              if not found and an INPROC is asked for, attempt to load a DLL
//
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::GetOrLoadClassByContext_rl(
                                               DWORD                        dwContext,
                                               ACTIVATION_PROPERTIES_PARAM  ap,
                                               IComClassInfo*               pCI,
                                               CClassEntry*                 pCE,
                                               DWORD                        dwCEHash,
                                               IMiniMoniker               *&pIM
                                               )
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClassByContext_rl:"
                      " dwContext = 0x%x, pCE = 0x%x\n", dwContext, pCE));
    ASSERT_LOCK_HELD(_mxs);

    HRESULT hr = S_OK;
    CBaseClassEntry *pBCE = 0;

    if (!pCE)
    {
        // Load the class

        if (ap._dwFlags & ACTIVATION_PROPERTIES::fDO_NOT_LOAD)
        {
            ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetOrLoadClassByContext_rl:"
                              " No class in cache, not loading\n"));
            return CO_E_SERVER_STOPPING;
        }

        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClassByContext_rl:"
                          " No class in cache, will attempt to create CE\n"));

        // Create the new CClassEntry
        if (FAILED(hr = CClassEntry::Create(ap._rclsid, dwCEHash, pCI, pCE)))
        {
            ClsCacheDebugOut((DEB_ERROR, "CClassCache::GetOrLoadClassByContext_rl:"
                              " Create failed hr = 0x%x\n", hr));
            return hr;
        }
    }

    Win4Assert(pCE->_dwSig);
    if ( !(ap._dwFlags & ACTIVATION_PROPERTIES::fRELOAD_DARWIN) &&
         !(dwContext  & ~pCE->_dwFailedContexts) )
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClassByContext_rl:"
                          " We have already failed this context, exiting,\n"
                          "pCE->_dwFailedContexts = 0x%x", pCE->_dwFailedContexts));
        return E_FAIL;
    }

    pCE->SetLockedInMemory();


    //
    // Search the class entry for a BCE that meets our criteria, this could
    // come back with either an LSCE or a DCE.
    //
    ASSERT_WRITE_LOCK_HELD(_mxs);
    BOOL fLockReleased = FALSE;
    hr = pCE->SearchBaseClassEntry(
                                  dwContext,
                                  pBCE,
                                  ap._dwFlags,
                                  &fLockReleased);
    Win4Assert(!fLockReleased);
    if (FAILED(hr))
    {
        if (ap._dwFlags & ACTIVATION_PROPERTIES::fDO_NOT_LOAD)
        {
            ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetOrLoadClassByContext_rl:"
                              " No class in cache, not loading\n"));
            hr = CO_E_SERVER_STOPPING;
        }
        else if (pCE->IsComplete()
                 && (dwContext
                     & (CLSCTX_INPROC_SERVERS | CLSCTX_INPROC_HANDLERS)))
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClassByContext_rl:"
                              " No class in cache, creating DCE\n"));

            //
            // If there is not an existing BCE the only choice is to
            // try and make a DCE.
            //

            CClassCache::CDllClassEntry *pDCE = 0;

            pCE = pCE->CycleToClassEntry();

            UNLOCK(_mxs);
            hr = pCE->CreateDllClassEntry_rl(dwContext, ap, pDCE);
            LOCK(_mxs);

            if (FAILED(hr))
            {
                pCE->_dwFailedContexts |= dwContext;
            }

            pBCE = pDCE;
        }
    }

    //
    // if there is a valid base class entry, then we can use it
    // to get the class interface.
    //

    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClassByContext_rl:"
                      " Class %s found or loaded, hr = 0x%x\n",
                      FAILED(hr) ? "NOT " : "", hr));

    if (SUCCEEDED(hr))
    {
        hr = pBCE->GetClassInterface(&pIM);
        ClsCacheDebugOut((HRDBG(hr), "CClassCache::GetOrLoadClassByContext_rl:"
                          " GetClassInterface %s, hr = 0x%x, pIM = 0x%x\n",
                          HR2STRING(hr), hr, pIM));
    }

    pCE->ReleaseMemoryLock(&fLockReleased);
    Win4Assert(!fLockReleased);

    return hr;
}







//+-------------------------------------------------------------------------
//
//  Function:   SearchDPEHash
//
//  Synopsis:   Lookup an entry in _DllPathEntries.
//
//  Arguments:  pszDllPath     - [in] the path to look up
//              pDPE           - [out] the entry if found
//              dwHashValue    - [in/optional] Hash value, -1 if not present
//
//  Returns:    S_OK   -  found
//              E_FAIL -  not found
//
//  Algorithm:  convert using the DSA Wrapper
//              lookup in the hash
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::SearchDPEHash(LPWSTR pszDllPath, CDllPathEntry *& pDPE, DWORD dwHashValue, DWORD dwDIPFlags)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::SearchDPEHash: pszDllPath = \"" TSZFMT"\", dwHashValue 0x%x, dwDIPFlags 0x%x\n",
                      pszDllPath, dwHashValue, dwDIPFlags));
    ASSERT_LOCK_HELD(CClassCache::_mxs);
    HRESULT hr;



    SDPEHashKey lookupKey;
    lookupKey._pstr = pszDllPath;
    lookupKey._dwDIPFlags = dwDIPFlags;

    // search for a DPE in the DllPathEntries hash
    pDPE = (CDllPathEntry *)_DllPathEntries.Lookup(dwHashValue, &lookupKey);

    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::SearchDPEHash: pszDllPath(\"" TSZFMT "\") %s!! 0x%x\n",
                      pszDllPath, pDPE ? "FOUND" : "NOT FOUND\n", pDPE));

    return(pDPE ? S_OK : E_FAIL);
}

//+-------------------------------------------------------------------------
//
//  Function:   RegisterServer
//
//  Synopsis:   Inserts a server into the cache for later use
//
//  Arguments:  rclsid    -   [in] the clsid of the server
//              punk      -   [in] the server
//              dwContext -   [in] context
//              dwRegFlags- [in] registration flags
//              lpdwRegister  - [out] cookie for identifying this server later
//
//  Returns:    S_OK   -  operation succeeded
//              PROPOGATE:CClassEntry::Create
//              PROPOGATE:CClassEntry::CreateLSvrClassEntry_rl
//
//  Algorithm:  Get or create the class entry
//              Create a CLSvrClassEntry
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::RegisterServer(REFCLSID rclsid, IUnknown *punk,
                                    DWORD dwContext, DWORD dwRegFlags,
                                    LPDWORD lpdwRegister)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::RegisterServer:punk = 0x%x, dwContext = 0x%x, dwRegFlags = 0x%x\n",
                      punk, dwContext, dwRegFlags));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);


    HRESULT hr = S_OK;
    IComClassInfo* pCI = NULL;
 
    punk->AddRef();

    // LocalServers only exist in the base partition... (if not, we'll have to fetch the partition
    // from the context.)
    DWORD dwCEHash = _ClassEntries.Hash(rclsid, GUID_DefaultAppPartition);

    {
        LOCK_WRITE(_mxs);


        // lookup class

        // check the hash
        CClassEntry *pCE = _ClassEntries.LookupCE(dwCEHash, rclsid, GUID_DefaultAppPartition);

        if (!pCE)
        {
            // Windows Bug #107960
            // Look up class info without write lock
            // before call to CClassEntry::Create

            UNLOCK_WRITE(_mxs);
            
            hr = GetClassInfoFromClsid (rclsid, &pCI);
            if (FAILED (hr))
            {
                goto Cleanup;
            }

            LOCK_WRITE(_mxs);

            const GUID *pguidPartition = GetPartitionIDForClassInfo(pCI);            
            pCE = _ClassEntries.LookupCE(dwCEHash, rclsid, *pguidPartition);
        }
    
        // create if not found
        if (!pCE)
        {
            // Create a new CClassEntry. Don't get the TreatAs yet.
            hr = CClassEntry::CreateIncomplete(rclsid, dwCEHash, pCI, pCE, 0);
        }

        if (SUCCEEDED(hr))
        {
            // create LSvrClassEntry
            pCE->SetLockedInMemory();
            hr = pCE->CreateLSvrClassEntry_rl(punk, dwContext, dwRegFlags, lpdwRegister);
            BOOL fLockReleased;
            pCE->ReleaseMemoryLock(&fLockReleased);
            Win4Assert(!fLockReleased);
        }

        UNLOCK_WRITE(_mxs);
    }

Cleanup:
    
    if (FAILED(hr))
    {
        punk->Release();
    }

    if (pCI)
    {
        pCI->Release();
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   Revoke
//
//  Synopsis:   Removes a previouly registered server from the cache
//
//  Arguments:  dwRegister  - [in] Cookie representing the server to revoke
//
//  Returns:    S_OK   -  operation succeeded
//              PROPOGATE:CLSvrClassEntry::SafeCastFromDWORD
//
//  Algorithm:  get the CLSvrClassEntry object by safe-casting the DWORD
//              check for correct apartment, and recursive revokes
//              release the object
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::Revoke(DWORD dwRegister)
{
    TRACECALL(TRACE_DLL, "ClassCache::Revoke");
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Revoke: dwRegister = 0x%x\n", dwRegister));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    HRESULT hr;

    CLSvrClassEntry::CFinishObject fo;
    {
        // Single thread access to the table
        STATIC_WRITE_LOCK (lck, _mxs);
        CLSvrClassEntry *pLSCE = 0;

        if (FAILED(hr = CLSvrClassEntry::SafeCastFromDWORD(dwRegister, pLSCE)))
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Revoke: SafeCastFromDWORD FAILED dwRegister = 0x%x, hr = 0x%x\n",
                              dwRegister, hr));
            return hr;
        }

        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Revoke: SafeCastFromDWORD SUCCESS! pLSCE->_dwFlags = 0x%x\n",
                          pLSCE->_dwFlags));




        // Make sure apartment id's match

        if (GetCurrentApartmentId() != pLSCE->_hApt)
        {
            ClsCacheDebugOut((DEB_ERROR,
                              "CClassCache::Revoke %x:  Wrong thread attempting to revoke\n\n", dwRegister));
            return RPC_E_WRONG_THREAD;
        }


        // Make sure some other thread is not already using this object
        if (pLSCE->_cUsing > 0)
        {
            // mark the object as pending for revoke, the thread
            // which is using this object will have to revoke it.
            // we zero the context, so it cannot be found.
            pLSCE->_dwContext = 0;
            pLSCE->_dwFlags |= CLSvrClassEntry::fREVOKE_PENDING;
            return S_OK;
        }
        else
        {            
            ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Revoke: Releasing cache line for dwRegister = 0x%x, pLSCE = 0x%x\n",
                              dwRegister, pLSCE));
            
            pLSCE->Release(&fo);
        }
    }
    fo.Finish();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::GetApartmentChain
//
//  Synopsis:   Select the correct apartment chain based on the current
//              apartment
//
//  Arguments:  none
//
//  Returns:    apartment chain
//
//  Algorithm:  if in the MTA get from global, else use TLS
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
CClassCache::CLSvrClassEntry *CClassCache::GetApartmentChain(BOOL fCreate)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "GetApartmentChain\n"));
    ASSERT_LOCK_HELD(CClassCache::_mxs);

    APTKIND AptKind = GetCurrentApartmentKind();
    if (AptKind == APTKIND_MULTITHREADED)
    {
        if (!CClassCache::_MTALSvrsFront && fCreate)
        {
            CClassCache::_MTALSvrsFront =
            new CClassCache::CLSvrClassEntry(CClassCache::CLSvrClassEntry::DUMMY_SIG, 0, 0, 0, 0);
        }
        return CClassCache::_MTALSvrsFront;
    }
    else if (AptKind == APTKIND_NEUTRALTHREADED)
    {
        if (!CClassCache::_NTALSvrsFront && fCreate)
        {
            CClassCache::_NTALSvrsFront =
            new CClassCache::CLSvrClassEntry(
                                            CClassCache::CLSvrClassEntry::DUMMY_SIG, 0, 0, 0, 0);
        }
        return CClassCache::_NTALSvrsFront;
    }
    else
    {
        COleTls tls;
        if (!tls->pSTALSvrsFront && fCreate)
        {
            tls->pSTALSvrsFront =
            new CClassCache::CLSvrClassEntry(CClassCache::CLSvrClassEntry::DUMMY_SIG, 0, 0, 0, 0);
        }

        return(CLSvrClassEntry *)tls->pSTALSvrsFront;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   FreeUnused
//
//  Synopsis:   Free all Dlls which are no longer in use
//
//  Arguments:  dwUnloadDelay - [in] number of milliseconds to age a unused DLL
//
//  Returns:    S_OK   -  operation succeeded
//
//  Algorithm:  For each Dll
//                if the dll says it can unload
//                   release this apartment
//                   if the dll is no longer needed release it
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::FreeUnused(DWORD dwUnloadDelay)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::FreeUnused\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    CFinishComposite fc;
    CFinishComposite::node *p;

    {
        STATIC_WRITE_LOCK(lck, _mxs);

        HAPT hCurrApt = GetCurrentApartmentId();
        HAPT hNeutralApt = NTATID;

        for (int i = 0; i < _cDPEBuckets; i++)
        {

            BOOL fUsedFO = 0;
            CDllPathEntry::CFinishObject *pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();


            CDllPathEntry * pDPE, * pDPENext;
            FOREACH_SAFE(pDPE, ((CDllPathEntry *) _DPEBuckets[i].pNext), pDPENext, _pNext)
            {
                HRESULT hr = pDPE->CanUnload_rl(dwUnloadDelay);

                // CanUnload_rl guarantees pDPE won't go away, but the
                // next one might, so reset it
                pDPENext = pDPE->_pNext;

                if (hr == S_OK)
                {
                    // The dll says its ok to unload.  This is good
                    // for this apartment and the NA, so we will take either
                    // entry off this DPE

                    CDllAptEntry *pDAE, *pDAENext;
                    FOREACH_SAFE(pDAE, pDPE->_pAptEntryFront, pDAENext, _pNext)
                    {
                        if ( (pDAE->_hApt == hCurrApt) ||
                             (pDAE->_hApt == hNeutralApt) )
                        {
                            // release the apartment
                            hr = pDAE->Release(pFO, fUsedFO);
                            Win4Assert(SUCCEEDED(hr));
                            // if the release used the finish object,
                            // allocate another
                            if (fUsedFO)
                            {
                                STACK_FC_ADD(fc, p, pFO);
                                fUsedFO = 0;
                                pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();
                            }

                        }
                    }
                    if (pDPE->NoLongerNeeded())
                    {
                        // the Dll is no longer needed, so we free it
                        hr = pDPE->Release(pFO);
                        Win4Assert(SUCCEEDED(hr));
                        STACK_FC_ADD(fc, p, pFO);
                        pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();
                    }
                }

            }
            // we "leak" one finish object, but it is on the stack,
            // and there is no dtor.
        }
    }
    fc.Finish();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   CleanUpDllsForApartment
//
//  Synopsis:   Cleans up all references this apartment hold on a dll
//
//  Arguments:  none
//
//  Returns:    S_OK   -  operation succeeded
//
//  Algorithm:  For each Dll
//                 find the apartment entry for this apt and release it
//                 if the dll says its ok, and it is no longer needed release the dll
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::CleanUpDllsForApartment(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CleanUpDllsForApartment Apt = 0x%x\n", GetCurrentApartmentId()));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    
    HRESULT hr;
    CFinishComposite fc;
    CFinishComposite::node *p;
    
    {
        STATIC_WRITE_LOCK(lck, _mxs);
        
        HAPT hCurrApt = GetCurrentApartmentId();
        
        for (int i = 0; i < _cDPEBuckets; i++)
        {
            CDllPathEntry * pDPE, * pDPENext;
            FOREACH_SAFE(pDPE, ((CDllPathEntry *) _DPEBuckets[i].pNext), pDPENext, _pNext)
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CleanUpDllsForApartment - "
                                  "Cleaning up apt entries for pDPE = 0x%x\n", pDPE));
                
                CDllAptEntry *pDAE, *pDAENext;
                
                BOOL fUsedFO = 0;
                BOOL fInThisApartment = FALSE;
                
                CDllPathEntry::CFinishObject *pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();
                
                FOREACH_SAFE(pDAE, pDPE->_pAptEntryFront, pDAENext, _pNext)
                {                    
                    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CleanUpDllsForApartment - "
                                      "Cleaning up apt entries pDAE = 0x%x ... testing\n", pDAE));
                    if (pDAE->_hApt == hCurrApt)
                    {
                        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CleanUpDllsForApartment - "
                                          "Releaseing apt entry - pDAE = pDAE = 0x%x\n", pDAE));
                        hr = pDAE->Release(pFO, fUsedFO);
                        Win4Assert(SUCCEEDED(hr));
                        if (fUsedFO)
                        {
                            STACK_FC_ADD(fc, p, pFO);
                            fUsedFO = 0;
                            pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();
                        }
                        
                        fInThisApartment = TRUE;
                    }
                }
                
                if (pDPE->NoLongerNeeded() && (fInThisApartment))
                {
                    hr = S_OK;
                    if (!IsWOWProcess()) 
                    {
                        hr = pDPE->CanUnload_rl(INFINITE);
                    }
                    
                    // CanUnload_rl guarantees pDPE won't go away, but the
                    // next one might, so reset it
                    pDPENext = pDPE->_pNext;
                    
                    if (hr == S_OK) 
                    {
                        // the Dll is no longer needed, so we free it
                        hr = pDPE->Release(pFO);
                        Win4Assert(SUCCEEDED(hr));
                        STACK_FC_ADD(fc, p, pFO);
                        pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();
                    }
                }
                
                // we "leak" one finish object, but it is on the stack,
                // and there is no dtor.
            }
        }

    }
    fc.Finish();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   CleanUpLocalServersForApartment
//
//  Synopsis:   Cleans up all lsvrs held in this apartment
//
//  Arguments:  none
//
//  Returns:    S_OK   -  operation succeeded
//
//  Algorithm:  For each lsvr in this apt
//                  release it
//              clean up apt chain in tls
//
//  History:    09-Sep-96  MattSmit   Created
//              13-Feb-98  Johnstra   Made NTA aware
//
//--------------------------------------------------------------------------
HRESULT CClassCache::CleanUpLocalServersForApartment(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CleanUpLocalServersForApartment\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    CFinishComposite fc;
    CFinishComposite::node *p;

    {
        STATIC_WRITE_LOCK(lck, _mxs);

        CLSvrClassEntry *pLSCEChain, *pLSCE, *pLSCENext;


        pLSCEChain = GetApartmentChain(FALSE);
        if (pLSCEChain == 0)
        {
            return S_OK;
        }

        FOREACH_SAFE(pLSCE, pLSCEChain->_pNextLSvr, pLSCENext, _pNextLSvr)
        {
            CLSvrClassEntry::CFinishObject *pFO = STACK_ALLOCATE_LSVRCLASSENTRY_FINISHOBJECT();
            pLSCE->Release(pFO);
            STACK_FC_ADD(fc, p, pFO);
        }


        COleTls tls;
        APTKIND AptKind = GetCurrentApartmentKind(tls);
        if (AptKind == APTKIND_NEUTRALTHREADED && _NTALSvrsFront)
        {
            delete (CLSvrClassEntry *) _NTALSvrsFront;
            _NTALSvrsFront = 0;
        }
        else if ((AptKind == APTKIND_APARTMENTTHREADED) && tls->pSTALSvrsFront)
        {
            delete (CLSvrClassEntry *) tls->pSTALSvrsFront;
            tls->pSTALSvrsFront = 0;
        }
        else if (_MTALSvrsFront)
        {
            delete (CLSvrClassEntry *) _MTALSvrsFront;
            _MTALSvrsFront = 0;
        }
    }

    return fc.Finish();
}

//+-------------------------------------------------------------------------
//
//  Function:   ReleaseCatalogObjects
//
//  Synopsis:   Release all ClassInfo objects held by the dll cache
//
//  Arguments:  none
//
//  Returns:    S_OK   -  operation succeeded
//
//  History:    11-Jan-99  MattSmit   Created
//
//--------------------------------------------------------------------------
void CClassCache::ReleaseCatalogObjects(void)
{
#if DBG == 1
    const ULONG cMaxCI = 2;
#else
    const ULONG cMaxCI = 10;
#endif
    struct STmpCI
    {
        IComClassInfo  *arCI[cMaxCI];
        STmpCI         *pNext;
    };
    STmpCI   *pCI2Rel     = NULL;
    STmpCI   *pCI2RelHead = NULL;
    ULONG cCI = 0;
    LOCK(_mxs);
    for (ULONG k = 0; k < _cCEBuckets; k++)
    {
        SHashChain *pHN;
        FOREACH(pHN, _CEBuckets[k].pNext, pNext)
        {
            CClassEntry *pCE = CClassEntry::SafeCastFromHashNode((SMultiGUIDHashNode *) pHN);
            if (pCE->_pCI)
            {
                ULONG ndx = cCI % cMaxCI;
                if (ndx == 0)
                {
                    // allocate more memory
                    STmpCI *tmp = (STmpCI *) _alloca(sizeof(STmpCI));
                    tmp->pNext = NULL;
                    if (pCI2Rel)
                    {
                        pCI2Rel->pNext = tmp;
                        Win4Assert(pCI2RelHead);
                    }
                    else
                    {
                        Win4Assert(!pCI2RelHead);
                        pCI2RelHead = tmp;
                    }
                    pCI2Rel = tmp;
                }
                pCI2Rel->arCI[ndx] = pCE->_pCI;
                pCE->_pCI = NULL;
                cCI++;
            }
        }
    }
    UNLOCK(_mxs);

    pCI2Rel = pCI2RelHead;
    for (k = 0; k < cCI; k++)
    {
        ULONG ndx = k % cMaxCI;
        pCI2Rel->arCI[ndx]->Release();

        if (ndx == (cMaxCI-1))
        {
            pCI2Rel = pCI2Rel->pNext;
        }
        Win4Assert(k+1 >= cCI || pCI2Rel);
    }
}
//+-------------------------------------------------------------------------
//
//  Function:   CleanUpDllsForProcess
//
//  Synopsis:   Cleans up all lsvrs held in this apartment
//
//  Arguments:  none
//
//  Returns:    S_OK   -  operation succeeded
//
//  Algorithm:  For each Dll
//                release all the apt entries
//                release the dll
//              Cleanup the page tables
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::CleanUpDllsForProcess(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CleanUpDllsForProcess\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    CFinishComposite fc;
    CFinishComposite::node *p;

    {
        STATIC_WRITE_LOCK(lck, _mxs); // do we need this?
        HAPT hCurrApt = GetCurrentApartmentId();

        for (int i = 0; i < _cDPEBuckets; i++)
        {
            CDllPathEntry * pDPE, * pDPENext;


            FOREACH_SAFE(pDPE, ((CDllPathEntry *) _DPEBuckets[i].pNext), pDPENext, _pNext)
            {
                CDllAptEntry *pDAE, *pDAENext;

                BOOL fUsedFO = FALSE;
                CDllPathEntry::CFinishObject *pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();

                FOREACH_SAFE(pDAE, pDPE->_pAptEntryFront, pDAENext, _pNext)
                {

                    HRESULT hr;
                    hr = pDAE->Release(pFO, fUsedFO);
                    Win4Assert(SUCCEEDED(hr));
                    if (fUsedFO)
                    {
                        STACK_FC_ADD(fc, p, pFO);
                        fUsedFO = 0;
                        pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();
                    }

                }

                HRESULT hr;

                hr = pDPE->Release(pFO);
                Win4Assert(SUCCEEDED(hr));
                STACK_FC_ADD(fc, p, pFO);
            }
        }

        // reset the CEBuckets because there may be some
        // CClassEntry objects hanging around from calls
        // to CCGetTreatAs
        for (int iBucket = 0; iBucket < _cCEBuckets; iBucket++)
        {
            // NOTE:: the destructor does not run.  this is ok for now, because
            // we are going to blow away the memory anyway.

            _CEBuckets[iBucket].pNext =  &(_CEBuckets[iBucket]);
            _CEBuckets[iBucket].pPrev =  &(_CEBuckets[iBucket]) ;

        }

        // reset collection information

        _LastObjectCount = 0;
        _LastCollectionTickCount = 0;
        _ObjectsForCollection = 0;



        CDllPathEntry::_palloc.Cleanup();
        CClassEntry::_palloc.Cleanup();
        CDllClassEntry::_palloc.Cleanup();
        CLSvrClassEntry::_palloc.Cleanup();
        CLSvrClassEntry::_cOutstandingObjects = 0;
        CDllAptEntry::_palloc.Cleanup();


    }

    fc.Finish();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   AddRefServerProcess
//
//  Synopsis:   Addrefs the process one
//
//  Arguments:  none
//
//  Returns:    number of references
//
//  Algorithm:  Increment _cRefsServerProcess
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
ULONG CClassCache::AddRefServerProcess(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::AddRefServerProcess\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    STATIC_WRITE_LOCK(lck,_mxs);
    return ++_cRefsServerProcess;

}

//+-------------------------------------------------------------------------
//
//  Function:   ReleaseServerProcess
//
//  Synopsis:   Removes a reference from the process
//
//  Arguments:  none
//
//  Returns:    number of references
//
//  Algorithm:  Decrement _cRefsServerProcess
//              if 0 suspend all process objects
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
ULONG CClassCache::ReleaseServerProcess(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::ReleaseServerProcess\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    STATIC_WRITE_LOCK(lck,_mxs);

    ULONG cRefs = --_cRefsServerProcess;
    if (cRefs == 0)
    {
        CClassCache::_dwFlags |= fSHUTTINGDOWN;
        HRESULT hr = SuspendProcessClassObjectsHelp();
        Win4Assert(hr == S_OK);
    }
    return cRefs;
}
//+-------------------------------------------------------------------------
//
//  Function:   LockServerForActivation
//
//  Arguments:  none
//
//  Algorithm:  Increments _cRefsServerProcess
//
//  History:    06-Oct-98  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::LockServerForActivation(void)
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    STATIC_WRITE_LOCK(lck, _mxs);

    if (CClassCache::_dwFlags & fSHUTTINGDOWN)
    {
        return CO_E_SERVER_STOPPING;
    }
    else
    {
        ++_cRefsServerProcess;
        return S_OK;
    }
}
//+-------------------------------------------------------------------------
//
//  Function:   UnlockServerForActivation
//
//  Arguments:  none
//
//  Algorithm:  Decrements _cRefsServerProcess
//
//  History:    06-Oct-98  MattSmit   Created
//
//--------------------------------------------------------------------------
void CClassCache::UnlockServerForActivation(void)
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    STATIC_WRITE_LOCK(lck, _mxs);

    --_cRefsServerProcess;
}



//+-------------------------------------------------------------------------
//
//  Function:   SuspendProcessClassObjects
//
//  Synopsis:   Mark all registered objecst suspended
//
//  Arguments:  none
//
//  Returns:    S_OK    - operation succeeded
//
//  Algorithm:  take lock and call helper fn
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::SuspendProcessClassObjects(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::SuspendProcessClassObjects\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    STATIC_WRITE_LOCK(lck, _mxs);

    return SuspendProcessClassObjectsHelp();
}

//+-------------------------------------------------------------------------
//
//  Function:   SuspendProcessClassObjectsHelp
//
//  Synopsis:   Mark all registered objecst suspended
//
//  Arguments:  none
//
//  Returns:    S_OK    - operation succeeded
//
//  Algorithm:  foreach CLSvrClassEntry
//                  mark it suspended
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::SuspendProcessClassObjectsHelp(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::SuspendProcessClassObjectsHelp\n"));
    ASSERT_LOCK_HELD(_mxs);

    // walk the list of class entries, and for any that are registered as
    // local servers, mark them as suspended.

    for (int k = 0; k < _cCEBuckets; k++)
    {
        SHashChain *pHN;
        FOREACH(pHN, _CEBuckets[k].pNext, pNext)
        {
            CClassEntry *pCE = CClassEntry::SafeCastFromHashNode((SMultiGUIDHashNode *) pHN);

            CBaseClassEntry * pBCE;
            FOREACH(pBCE, pCE->_pBCEListFront, _pNext)
            {
                if (pBCE->_dwContext & CLSCTX_LOCAL_SERVER)
                {
                    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::SuspendProcessClassObjectsHelp - suspending"
                                      " pBCE = 0x%x, pBCE->_dwContext = 0x%x, pBCE->_dwSig = %s\n",
                                      pBCE, pBCE->_dwContext, &(pBCE->_dwSig)));

                    Win4Assert(pBCE->_dwSig == CLSvrClassEntry::SIG);
                    ((CLSvrClassEntry *) pBCE)->_dwRegFlags |= REGCLS_SUSPENDED;
                }
            }

        }
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   ResumeProcessClassObjects
//
//  Synopsis:   Resume all registered objects
//
//  Arguments:  none
//
//  Returns:    S_OK    - operation succeeded
//              PROPOGATE - gResolver.NotifyStarted
//
//  Algorithm:  foreach suspended CLSvrClassEntry
//                 remove suspended flag
//                 put in structure to notify SCM
//              notify SCM
//              fill in AT_STORAGE and SCM registration
//
//  History:    09-Sep-96  MattSmit   Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::ResumeProcessClassObjects(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::ResumeProcessClassObjects\n\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    CFinishComposite fc;
    CFinishComposite::node *p;

    HRESULT hr = S_OK;
    {
        STATIC_WRITE_LOCK(lck,_mxs);

        const ULONG    cLSCEInUse = CLSvrClassEntry::_cOutstandingObjects;

        if (cLSCEInUse == 0)
        {
            return S_OK;
        }

        // allocate a block of memory on the stack, large enough to hold the
        // maximum number of entries we may have to register with the SCM.

        ULONG          cbAlloc = sizeof(RegInput) +
                                 ((sizeof(RegInputEntry) + sizeof(CLSvrClassEntry *))*
                                  cLSCEInUse);

        RegInput         *pRegIn  = (RegInput*) _alloca(cbAlloc);
        RegInputEntry    *pRegEnt = &pRegIn->rginent[0];
        CLSvrClassEntry **pRegIndex = (CLSvrClassEntry **)(&pRegIn->rginent[cLSCEInUse]);
        ULONG             cToReg  = 0;


        // walk the list of class entries, and for any that are registered as
        // local servers and marked suspended, mark them as available and
        // notify the SCM about them.
        for (int k = 0; k < _cCEBuckets; k++)
        {
            SHashChain *pHN;
            FOREACH(pHN, _CEBuckets[k].pNext, pNext)
            {
                CClassEntry *pCE = CClassEntry::SafeCastFromHashNode((SMultiGUIDHashNode *) pHN);

                CBaseClassEntry * pBCE;
                FOREACH(pBCE, pCE->_pBCEListFront, _pNext)
                {
                    if (pBCE->_dwContext & CLSCTX_LOCAL_SERVER)
                    {
                        Win4Assert(pBCE->_dwSig == CLSvrClassEntry::SIG);
                        CLSvrClassEntry *pLSCE = (CLSvrClassEntry *)pBCE;
                        if (pLSCE->_dwRegFlags & REGCLS_SUSPENDED)
                        {
                            // turn off the suspended flag for this clsid.
                            pLSCE->_dwRegFlags &= ~REGCLS_SUSPENDED;

                            if (pLSCE->_dwScmReg == CLSvrClassEntry::NO_SCM_REG)
                            {
                                Win4Assert(pLSCE->_pObjServer != NULL);

                                // add to the list to tell the SCM about
                                pRegEnt->clsid    = pLSCE->_pClassEntry->GetCLSID();
                                pRegEnt->dwFlags  = pLSCE->_dwRegFlags;
                                pRegEnt->oxid     = pLSCE->_pObjServer->GetOXID();
                                pRegEnt->ipid     = pLSCE->_pObjServer->GetIPID();
                                pRegEnt++;

                                *pRegIndex = pLSCE;     // remember the pointer to this entry
                                pRegIndex++;            // so we can update it below.

                                pLSCE->_cUsing++;

                                cToReg++;
                            }
                        }
                    }
                }
            }
        }

        // reset the pointers we mucked with in the loop above, and set the
        // total number of entries we are passing to the SCM.

        pRegIn->dwSize = cToReg;
        pRegEnt        = &pRegIn->rginent[0];
        pRegIndex      = (CLSvrClassEntry **)(&pRegIn->rginent[cLSCEInUse]);


        // call the SCM to register all the classes and get back all the
        // registration keys.

        RegOutput *pRegOut = NULL;

        UNLOCK(_mxs);
        hr = gResolver.NotifyStarted(pRegIn, &pRegOut);
        LOCK(_mxs);

        if (SUCCEEDED(hr))
        {
            Win4Assert((pRegOut->dwSize == pRegIn->dwSize) &&
                       "CRpcResolver::NotifyStarted Invalid regout");

            // update the entries with the registration keys from the SCM.
            for (ULONG i = 0; i < cToReg; i++)
            {
                CLSvrClassEntry *pLSCE = *pRegIndex;
                pRegIndex++;

                pLSCE->_dwScmReg   = pRegOut->RegKeys[i];

                if ((--pLSCE->_cUsing  == 0 ) && (pLSCE->_dwFlags & CLSvrClassEntry::fREVOKE_PENDING))
                {
                    CLSvrClassEntry::CFinishObject *pFO = STACK_ALLOCATE_LSVRCLASSENTRY_FINISHOBJECT();
                    pLSCE->Release(pFO);
                    STACK_FC_ADD(fc, p, pFO);
                }
            }

            // Free memory from RPC
            MIDL_user_free(pRegOut);
        }
    }

    fc.Finish();

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetClassInformationForDde
//
//  Synopsis:   Get info for dde routines
//
//  Arguments:  clsid   - [in] class id queried
//              lpDdeInfo - [out] DDECLASSINFO object to fill out
//
//  Returns:    TRUE   -  operation succeeded
//              FALSE  -  operation failed
//
//  Algorithm:  find an lsvr with this clsid in the cache
//              use GetDDEInfo to fill out the information
//
//  History:    09-Sep-96  MattSmit   Created
//
//+-------------------------------------------------------------------------
BOOL CClassCache::GetClassInformationForDde(REFCLSID clsid, LPDDECLASSINFO lpDdeInfo)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassInformationForDde: lpDdeInfo = 0x%x\n",
                      lpDdeInfo));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    IMiniMoniker *pIM = (IMiniMoniker *) _alloca(max(sizeof(CDllFnPtrMoniker),
                                                     sizeof(CpUnkMoniker)));

    // REVIEW: Should we be getting the partition ID out of the context?  I don't think so.
    HRESULT hr;
    DWORD dwCEHash = _ClassEntries.Hash(clsid, GUID_DefaultAppPartition);

    {
        STATIC_WRITE_LOCK(lck, _mxs);

        // check the hash
        CClassEntry *pCE = _ClassEntries.LookupCE(dwCEHash, clsid, GUID_DefaultAppPartition);

        if (!pCE)
        {
            return FALSE;
        }

        CBaseClassEntry *pBCE;
        ASSERT_WRITE_LOCK_HELD(_mxs);
        BOOL fLockReleased = FALSE;
        hr = pCE->SearchBaseClassEntry(CLSCTX_LOCAL_SERVER, pBCE, ACTIVATION_PROPERTIES::fFOR_SCM, &fLockReleased);
        Win4Assert(!fLockReleased);

        if (FAILED(hr))
        {
            return FALSE;
        }

        Win4Assert(pBCE->_dwSig == CLSvrClassEntry::SIG);
        CLSvrClassEntry *pLSCE = (CLSvrClassEntry *) pBCE;

        hr = pLSCE->GetDDEInfo(lpDdeInfo, &pIM);


    }

    if (SUCCEEDED(hr) && pIM)
    {
        hr = pIM->BindToObjectNoSwitch(IID_IClassFactory, (void **) &lpDdeInfo->punk);
        pIM->Release();
    }
    else
    {
        lpDdeInfo->punk = 0;
    }

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetClassInformationFromKey
//
//  Synopsis:   Get info for dde routines
//
//  Arguments:  lpDdeInfo - [in/out] DDECLASSINFO object to fill out,
//                            also contains cookie for the server
//
//  Returns:    TRUE   -  operation succeeded
//              FALSE  -  operation failed
//
//  Algorithm:  find an lsvr by safe casting the cookie
//              use GetDDEInfo to fill out the information
//
//  History:    09-Sep-96  MattSmit   Created
//
//+-------------------------------------------------------------------------
BOOL CClassCache::GetClassInformationFromKey(LPDDECLASSINFO lpDdeInfo)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassInformationFromKey: lpDdeInfo = 0x%x\n",
                      lpDdeInfo));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);


    IMiniMoniker *pIM = (IMiniMoniker *) _alloca(max(sizeof(CDllFnPtrMoniker),
                                                     sizeof(CpUnkMoniker)));
    HRESULT hr;

    {
        STATIC_WRITE_LOCK(lck, _mxs);

        CLSvrClassEntry *pLSCE;


        if (FAILED(hr = CLSvrClassEntry::SafeCastFromDWORD(lpDdeInfo->dwRegistrationKey, pLSCE)))
        {
            return FALSE;
        }

        hr = pLSCE->GetDDEInfo(lpDdeInfo, &pIM);


    }

    if (SUCCEEDED(hr) && pIM)
    {
        hr = pIM->BindToObjectNoSwitch(IID_IClassFactory, (void **) &lpDdeInfo->punk);
        pIM->Release();
    }
    else
    {
        lpDdeInfo->punk = 0;
    }

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetDdeServerWindow
//
//  Synopsis:   set dde server window
//
//  Arguments:  dwKey   - [in] Cookie designating the server
//              hWndDdeServer - [in] window to set
//
//  Returns:    TRUE   -  operation succeeded
//              FALSE  -  operation failed
//
//  Algorithm:  find an lsvr by safe casting the cookie
//              set its window to hWndDdeServer
//
//  History:    09-Sep-96  MattSmit   Created
//
//+-------------------------------------------------------------------------
BOOL CClassCache::SetDdeServerWindow(DWORD dwKey, HWND hWndDdeServer)
{
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::SetDdeServerWindow: dwKey = 0x%x, hWndDdeServer = 0x%x\n",
                      dwKey, hWndDdeServer));
    {
        STATIC_WRITE_LOCK(lck, _mxs);

        CLSvrClassEntry *pLSCE;
        HRESULT hr;

        if (FAILED(hr = CLSvrClassEntry::SafeCastFromDWORD(dwKey, pLSCE)))
        {
            return FALSE;
        }

        pLSCE->_hWndDdeServer = hWndDdeServer;

    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// API Implementation //////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCGetOrLoadClass
//
//  Delegates to:     CClassCache::GetOrLoadClass
//
//  Special Behavior: none
//
//  History:    23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCGetOrLoadClass(ACTIVATION_PROPERTIES_PARAM ap)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetorLoadClass\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }
    *(ap._ppUnk) = 0;
    return CClassCache::GetOrLoadClass(ap);
}




//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCGetOrCreateApartment
//
//  Delegates to:     CClassCache::GetOrCreateApartment
//
//  Special Behavior: none
//
//  History:    25-Feb-98   SatishT    Created
//
//--------------------------------------------------------------------------


HRESULT CCGetOrCreateApartment(ACTIVATION_PROPERTIES_PARAM ap,
                               DLL_INSTANTIATION_PROPERTIES *pdip,
                               HActivator *phActivator)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetOrCreateApartment\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }
    return CClassCache::GetOrCreateApartment(ap, pdip, phActivator);
}


//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCGetClassObject
//
//  Delegates to:     CClassCache::GetClassObject
//
//  Special Behavior: none
//
//  History:    26-Feb-98   SatishT    Created
//
//--------------------------------------------------------------------------


HRESULT CCGetClassObject(ACTIVATION_PROPERTIES_PARAM ap)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetClassObject\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }
    return CClassCache::GetClassObject(ap);
}


//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCIsClsidRegisteredInApartment
//
//  Delegates to:     CClassCache::IsClsIdRegisteredInApartment
//
//  Special Behavior: none
//
//  History:    23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
BOOL CCIsClsidRegisteredInApartment(REFCLSID rclsid, REFGUID guidPartition, DWORD dwContext)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCIsClsidRegisteredIniApartment\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return FALSE;
    }

    return CClassCache::IsClsidRegisteredInApartment(rclsid, guidPartition, dwContext);
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCRegisterServer
//
//  Delegates to:     CClassCache::RegisterServer
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCRegisterServer(REFCLSID rclsid, IUnknown *punk, DWORD dwFlags, DWORD dwType, LPDWORD lpdwCookie)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCRegisterServer: punk = 0x%x, dwFlags = 0x%x, dwType = 0x%x\n", punk, dwFlags, dwType));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }

    return CClassCache::RegisterServer(rclsid, punk, dwFlags, dwType, lpdwCookie);
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCRevoke
//
//  Delegates to:     CClassCache::Revoke
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCRevoke(DWORD dwCookie)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCRevoke: dwCookie = 0x%x\n", dwCookie));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return CO_E_OBJNOTREG;
    }

    return CClassCache::Revoke(dwCookie);
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCAddRefServerProcess
//
//  Delegates to:     CClassCache::AddRefServerProcess
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
ULONG CCAddRefServerProcess()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCAddRefServerProcess\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }

    return CClassCache::AddRefServerProcess();
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCReleaseServerProcess
//
//  Delegates to:     CClassCache::ReleaseServerProcess
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
ULONG CCReleaseServerProcess()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCReleaseServerProcess\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return 0;
    }

    return CClassCache::ReleaseServerProcess();
}
//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCLockServerForActivation
//
//  Delegates to:     CClassCache::LockServerForActivation
//
//  Special Behavior: none
//
//  History:          06-Oct-98 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCLockServerForActivation()
{
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return E_FAIL;
    }

    return CClassCache::LockServerForActivation();


}
//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCUnlockServerForActivation
//
//  Delegates to:     CClassCache::UnlockServerForActivation
//
//  Special Behavior: none
//
//  History:          06-Oct-98 MattSmit    Created
//
//--------------------------------------------------------------------------
void CCUnlockServerForActivation()
{
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if ((CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::UnlockServerForActivation();
    }
}
//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCSuspendProcessClassObjects
//
//  Delegates to:     CClassCache::SuspendProcessClassObjects
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCSuspendProcessClassObjects()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCSuspendProcessClassObjects\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return S_OK;
    }

    return CClassCache::SuspendProcessClassObjects();
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCResumeProcessClassObjects
//
//  Delegates to:     CClassCache::ResumeProcessClassObjects
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCResumeProcessClassObjects()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCResumeProcessClassObjects\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return S_OK;
    }

    return CClassCache::ResumeProcessClassObjects();
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCCleanUpDllsForApartment
//
//  Delegates to:     CClassCache::CleanupDllsForApartment
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCCleanUpDllsForApartment()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCCleanUpDllsForApartment\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return S_OK;
    }

    return CClassCache::CleanUpDllsForApartment();
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCCleanupDllsForProcess
//
//  Delegates to:     CClassCache::CleanupDllsforProcess
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCCleanUpDllsForProcess()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCCleanUpDllsForProcess\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return S_OK;
    }

    return CClassCache::CleanUpDllsForProcess();
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCReleaseCatalogObjects
//
//  Delegates to:     CClassCache::ReleaseCatalogObjects
//
//  Special Behavior: none
//
//  History:          11-Jan-99 MattSmit    Created
//
//--------------------------------------------------------------------------
void CCReleaseCatalogObjects()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCReleaseCatalogObjects\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return;
    }

    CClassCache::ReleaseCatalogObjects();
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCCleanUpLocalServersForApartment
//
//  Delegates to:     CClassCache::CleanUpLocalServersForApartment
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCCleanUpLocalServersForApartment()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCCleanUpLocalServersForApartment\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return S_OK;
    }

    return CClassCache::CleanUpLocalServersForApartment();
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCFreeUnused
//
//  Delegates to:     CClassCache::FreeUnused
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCFreeUnused(DWORD dwUnloadDelay)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetFreeUnused\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return S_OK;
    }

    return CClassCache::FreeUnused(dwUnloadDelay);
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCGetClassInformationForDde
//
//  Delegates to:     CClassCache:GetClassInformationForDde
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
BOOL CCGetClassInformationForDde(REFCLSID clsid, LPDDECLASSINFO lpDdeInfo)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetClassInformationForDde: lpDdeInfo = 0x%x\n", lpDdeInfo));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return FALSE;
    }

    return CClassCache::GetClassInformationForDde(clsid, lpDdeInfo);
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCGetClassInformationFromKey
//
//  Delegates to:     CClassCache:GetClassInformationFromKey
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
BOOL CCGetClassInformationFromKey(LPDDECLASSINFO lpDdeInfo)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetClassInformationFromKey: lpDdeInfo = 0x%x\n", lpDdeInfo));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return FALSE;
    }

    return CClassCache::GetClassInformationFromKey(lpDdeInfo);
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCSetDdeServerWindow
//
//  Delegates to:     CClassCache:SetDdeServerWindow
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
BOOL CCSetDdeServerWindow(DWORD dwKey,HWND hwndDdeServer)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCSetDdeServerWindow: dwKey = 0x%x, hwndDdeServer = 0x%x\n", dwKey, hwndDdeServer));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return FALSE;
    }

    return CClassCache::SetDdeServerWindow(dwKey, hwndDdeServer);
}

//+-------------------------------------------------------------------------
//
//  Function:    CCGetDummyNodeForApartmentChain
//
//  Synopsis:    Allocates a "dummy" node for an apartment chain
//
//  Parameters:  ppv - [out] where to put a pointer to the dummy node
//
//  Algorithm:   allocate the node
//               put a dummy node signature on it
//
//  History:     23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCGetDummyNodeForApartmentChain(void **ppv)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetDummyNodeForApartmentChain: ppv = 0x%x\n", ppv));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }

    {
        STATIC_WRITE_LOCK(lck, CClassCache::_mxs);

        if (!*ppv)
        {

            *ppv = new CClassCache::CLSvrClassEntry(CClassCache::CLSvrClassEntry::DUMMY_SIG, 0, 0, 0, 0);
            if (*ppv)
            {
                return S_OK;
            }
            return E_FAIL;
        }

        return S_OK;
    }

}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCGetTreatAs
//
//  Delegates to:     CClassCache
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCGetTreatAs(REFCLSID rclsid, CLSID &clsid)
{
    HRESULT hr = S_OK;

    IComClassInfo* pCI = NULL;
    
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetTreatAs rclsid = %I\n", &rclsid));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }

    {
        LOCK_WRITE(CClassCache::_mxs);

        // check the hash
        DWORD dwCEHash = CClassCache::_ClassEntries.Hash(rclsid, GUID_DefaultAppPartition);
        ClsCacheDebugOut((DEB_ACTIVATE, "CCGetTreatAs: dwCEHash = 0x%x\n", dwCEHash));
        CClassCache::CClassEntry *pCE = CClassCache::_ClassEntries.LookupCE(dwCEHash, 
                                                                            rclsid, 
                                                                            GUID_DefaultAppPartition);
        ClsCacheDebugOut(( DEB_ACTIVATE,
                           "CCGetTreatAs: Lookup for clsid %I %s!\n",
                           &(rclsid), pCE ? "SUCCEEDED" : "FAILED"));

        if (!pCE)
        {
            // Windows Bug #107960
            // Look up class info without write lock
            // before call to CClassEntry::Create

            UNLOCK_WRITE(CClassCache::_mxs);
            
            hr = GetClassInfoFromClsid(rclsid, &pCI);
            if (FAILED (hr))
            {
                goto Cleanup;
            }

            LOCK_WRITE(CClassCache::_mxs);

            const GUID *pguidPartition = GetPartitionIDForClassInfo(pCI);

            pCE = CClassCache::_ClassEntries.LookupCE(dwCEHash, rclsid, *pguidPartition);
        }

        if (!pCE)
        {
            hr = CClassCache::CClassEntry::Create(rclsid, dwCEHash, pCI, pCE);
            if (FAILED(hr))
            {
                ClsCacheDebugOut((DEB_ERROR, "CCGetTreatAs: Create failed hr = 0x%x\n", hr));
                clsid = rclsid;
                goto CleanupUnlock;
            }
        }
        else
        {
            ASSERT_WRITE_LOCK_HELD(CClassCache::_mxs);
            BOOL fLockReleased = FALSE;
            HRESULT hr = pCE->Complete(&fLockReleased);
            Win4Assert(!fLockReleased);
            if (FAILED(hr))
            {
                goto CleanupUnlock;
            }
        }

        Win4Assert(pCE->IsComplete());
        pCE = pCE->CycleToClassEntry();

        // This will stay in the cache until it gets cleaned
        // up by the last couninit.

        pCE->SetLockedInMemory();
        clsid = pCE->GetCLSID();
    }

CleanupUnlock:

    UNLOCK_WRITE(CClassCache::_mxs);

Cleanup:

    if (pCI)
    {
        pCI->Release();
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CDPEHashTable ///////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
DWORD CClassCache::CDPEHashTable::HashNode(SHashChain *pNode)
{
    return Hash( ((CDllPathEntry *) pNode)->_psPath );
}

DWORD CClassCache::CDPEHashTable::Hash(LPCWSTR psz)
{
    DWORD  dwHash  = 0;
    WORD   *pw     = (WORD *) psz;
    DWORD  dwLen   = lstrlenW( psz );
    ULONG  i;

    // Hash the name.
    for (i=0; i < dwLen; i++)
    {
        dwHash = (dwHash << 8) ^ *pw++;
    }

    return dwHash;
}

void  CClassCache::CDPEHashTable::Add(DWORD dwHash, CDllPathEntry *pDPE)
{
    CHashTable::Add(dwHash, (SHashChain *) pDPE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\dllhost.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dllhost.cxx
//
//  Contents:   code for activating inproc dlls of one threading model
//              from apartments of a different threading model.
//
//  History:    04-Mar-96   Rickhi      Created
//              06-Feb-98   JohnStra    Add NTA (Neutral Threaded Apartment)
//                                      support.
//              18-Jun-98   GopalK      Fixed shutdown races
//
//  Notes:      the basic idea is to call over to an apartment of the
//              appropriate type, get it to do the object creation, then
//              marshal the object back to the calling apartment.
//
//              NTA objects are different in that the can be on the same
//              thread as STA or MTA objects.  This means we dont always
//              need a full-blown proxy/channel/stub between objects just
//              because they are in different apartments.  We still need
//              to marshal a pointer to an interface on the object back to
//              the client, though, because we will need a way to put in a
//              lightweight switcher when they are available.
//
//+-------------------------------------------------------------------------
#include <ole2int.h>
#include <dllcache.hxx>
#include <dllhost.hxx>
#include <comsrgt.hxx>
#include <..\dcomrem\marshal.hxx>

// globals for the various thread-model hosts
CDllHost    gSTHost;      // single-threaded host object for STA clients
CDllHost    gSTMTHost;    // single-threaded host object for MTA clients
CDllHost    gATHost;      // apartment-threaded host object fo MTA clients
CDllHost    gMTHost;      // mutli-threaded host object for STA client
CDllHost    gNTHost;      // neutral-threaded host object for STA/MTA clients

ULONG       gcHostProcessInits = 0; // count of DLL host threads.
ULONG       gcNAHosts = 0;          // count of NA hosts.
UINT_PTR    gTimerId = 0;           // Timer Id for STAHost thread.


//+-------------------------------------------------------------------
//
//  Member:     CDllHost::QueryInterface, public
//
//  Synopsis:   returns supported interfaces
//
//  History:    04-Mar-96   Rickhi      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CDllHost::QueryInterface(REFIID riid, void **ppv)
{
    // only valid to call this from within the host apartment
    Win4Assert(NeutralHost() || _dwHostAptId == GetCurrentApartmentId());

    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IDLLHost) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IDLLHost *) this;
        AddRef();
        hr = S_OK;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CDllHost::AddRef, public
//
//  Synopsis:   we dont refcnt this object so this is a noop
//
//  History:    04-Mar-96   Rickhi      Created
//
//--------------------------------------------------------------------
ULONG CDllHost::AddRef(void)
{
    // only valid to call this from within the host apartment
    Win4Assert(NeutralHost() || _dwHostAptId == GetCurrentApartmentId());
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CDllHost::Release, public
//
//  Synopsis:   we dont refcnt this object so this is a noop
//
//  History:    04-Mar-96   Rickhi      Created
//
//--------------------------------------------------------------------
ULONG CDllHost::Release(void)
{
    // only valid to call this from within the host apartment
    Win4Assert(NeutralHost() || _dwHostAptId == GetCurrentApartmentId());
    return 1;
}

//+-------------------------------------------------------------------------
//
//  Function:   DoSTClassCreate / DoATClassCreate / DoMTClassCreate
//
//  Synopsis:   Package up get class object so that happens on the proper
//              thread
//
//  Arguments:  [fnGetClassObject] - DllGetClassObject entry point
//              [rclsid] - class id of class object
//              [riid] - interface requested
//              [ppunk] - where to put output interface.
//
//  Returns:    NOERROR - Successfully returned interface
//              E_OUTOFMEMORY - could not allocate memory buffer.
//
//  Algorithm:  pass on to the CDllHost object for the correct apartment.
//
//  History:    06-Nov-94   Ricksa      Created
//              22-Feb-96   KevinRo     Changed implementation drastically
//              06-Mar-96   Rickhi      Use CDllHost
//
//--------------------------------------------------------------------------
HRESULT DoSTClassCreate(CClassCache::CDllPathEntry *pDPE,
                        REFCLSID rclsid, REFIID riid, IUnknown **ppunk)
{
    ComDebOut((DEB_DLL, "DoSTClassCreate rclsid:%I\n", &rclsid));

    HActivator hActivator;
    gSTHost.GetApartmentToken(hActivator);

    return gSTHost.GetClassObject((ULONG64) pDPE, rclsid, riid, ppunk, DLLHOST_IS_DPE);
}

HRESULT DoSTMTClassCreate(CClassCache::CDllPathEntry *pDPE,
                        REFCLSID rclsid, REFIID riid, IUnknown **ppunk)
{
    ComDebOut((DEB_DLL, "DoSTClassCreate rclsid:%I\n", &rclsid));

    HActivator hActivator;
    gSTMTHost.GetApartmentToken(hActivator);

    return gSTMTHost.GetClassObject((ULONG64) pDPE, rclsid, riid, ppunk, DLLHOST_IS_DPE);
}

HRESULT DoATClassCreate(CClassCache::CDllPathEntry *pDPE,
                        REFCLSID rclsid, REFIID riid, IUnknown **ppunk)
{
    ComDebOut((DEB_DLL, "DoATClassCreate rclsid:%I\n", &rclsid));
    return gATHost.GetClassObject((ULONG64) pDPE, rclsid, riid, ppunk, DLLHOST_IS_DPE);
}

HRESULT DoATClassCreate(LPFNGETCLASSOBJECT pfn,
                        REFCLSID rclsid, REFIID riid, IUnknown **ppunk)
{
    ComDebOut((DEB_DLL, "DoATClassCreate rclsid:%I\n", &rclsid));
    HActivator hActivator;

    gATHost.GetApartmentToken(hActivator);
    return gATHost.GetClassObject((ULONG64) pfn, rclsid, riid, ppunk, DLLHOST_IS_PFN);
}

HRESULT DoMTClassCreate(CClassCache::CDllPathEntry *pDPE,
                        REFCLSID rclsid, REFIID riid, IUnknown **ppunk)
{
    ComDebOut((DEB_DLL, "DoMTClassCreate rclsid:%I\n", &rclsid));
    return gMTHost.GetClassObject((ULONG64) pDPE, rclsid, riid, ppunk, DLLHOST_IS_DPE);
}
//+-------------------------------------------------------------------------
//
//  Function:   DoSTApartmentCreate / DoATApartmentCreate / DoMTApartmentCreate
//
//  Synopsis:   Package up get class object so that happens on the proper
//              thread
//
//  Arguments:  [fnGetClassObject] - DllGetClassObject entry point
//              [rclsid] - class id of class object
//              [riid] - interface requested
//              [ppunk] - where to put output interface.
//
//  Returns:    NOERROR - Successfully returned interface
//              E_OUTOFMEMORY - could not allocate memory buffer.
//
//  Algorithm:  pass on to the CDllHost object for the correct apartment.
//
//  History:    06-Nov-94   Ricksa      Created
//              22-Feb-96   KevinRo     Changed implementation drastically
//              06-Mar-96   Rickhi      Use CDllHost
//
//--------------------------------------------------------------------------
HRESULT DoSTApartmentCreate(HActivator &hActivator)
{
    ComDebOut((DEB_DLL, "DoSTApartmentCreate\n"));
    return gSTHost.GetApartmentToken(hActivator);
}

HRESULT DoSTMTApartmentCreate(HActivator &hActivator)
{
    ComDebOut((DEB_DLL, "DoSTApartmentCreate\n"));
    return gSTMTHost.GetApartmentToken(hActivator);
}

HRESULT DoATApartmentCreate(HActivator &hActivator)
{
    ComDebOut((DEB_DLL, "DoATApartmentCreate\n"));
    return gATHost.GetApartmentToken(hActivator);
}

HRESULT DoMTApartmentCreate(HActivator &hActivator)
{
    ComDebOut((DEB_DLL, "DoMTApartmentCreate\n"));
    return gMTHost.GetApartmentToken(hActivator);
}

HRESULT DoNTApartmentCreate(HActivator &hActivator)
{
    ComDebOut((DEB_DLL, "DoNTApartmentCreate\n" ));
    return gNTHost.GetApartmentToken(hActivator);
}

HRESULT DoNTClassCreate(
    CClassCache::CDllPathEntry* pDPE,
    REFCLSID                    rclsid,
    REFIID                      riid,
    IUnknown**                  ppunk
    )
{
    ComDebOut((DEB_DLL, "DoNTClassCreate rclsid:%I STA:%d\n", &rclsid, IsSTAThread()));
    return gNTHost.GetClassObject((ULONG64) pDPE, rclsid, riid, ppunk, DLLHOST_IS_DPE);
}

HRESULT ATHostActivatorGetClassObject(REFIID riid, LPVOID *ppvClassObj)
{
    ComDebOut((DEB_DLL, "ATHostActivatorGetClassObject\n"));

    HActivator hActivator;
    HRESULT hr;

    hr = gATHost.GetApartmentToken(hActivator);

    if (SUCCEEDED(hr))
    {
        hr = GetInterfaceFromStdGlobal(hActivator,
                                       riid,
                                       ppvClassObj);
    }
    return hr;
}

HRESULT MTHostActivatorGetClassObject(REFIID riid, LPVOID *ppvClassObj)
{
    ComDebOut((DEB_DLL, "MTHostActivatorGetClassObject\n"));

    HActivator hActivator;
    HRESULT hr;

    hr = gMTHost.GetApartmentToken(hActivator);

    if (SUCCEEDED(hr))
    {
        hr = GetInterfaceFromStdGlobal(hActivator,
                                       riid,
                                       ppvClassObj);
    }
    return hr;
}

HRESULT NTHostActivatorGetClassObject(REFIID riid, LPVOID *ppvClassObj)
{
    ComDebOut((DEB_DLL, "NTHostActivatorGetClassObject\n"));

    HActivator hActivator;
    HRESULT hr;

    hr = gNTHost.GetApartmentToken(hActivator);

    if (SUCCEEDED(hr))
    {
        hr = GetInterfaceFromStdGlobal(hActivator,
                                       riid,
                                       ppvClassObj);
    }
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::GetClassObject
//
//  Synopsis:   called by an apartment to get a class object from
//              a host apartment.
//
//  History:    04-Mar-96   Rickhi      Created
//              06-Feb-98   JohnStra    Added NTA (NEUTRAL) support
//
//--------------------------------------------------------------------------
HRESULT CDllHost::GetClassObject(
    ULONG64  hDPE,
    REFCLSID   rclsid,
    REFIID     riid,
    IUnknown** ppUnk,
    DWORD      dwFlags
    )
{
    ComDebOut((DEB_DLL, "CDllHost::GCO this:%x tid:%x hDPE:%I64x rclsid:%I riid:%I ppUnk:%x\n", this, GetCurrentThreadId(), hDPE, &rclsid, &riid, ppUnk));

    // Get a pointer to a proxy for the host running in the appropriate
    // appartment.  When we've acquired the proxy, we can call its
    // DllGetClassObject method.  The class factory will then get
    // marshaled and we will have a pointer to the factory's proxy.

    HRESULT hr = CO_E_DLLNOTFOUND;

    IDLLHost *pIDLLHost = GetHostProxy();
    if (pIDLLHost)
    {
        hr = pIDLLHost->DllGetClassObject(hDPE, rclsid, riid, ppUnk, dwFlags);
        pIDLLHost->Release();
    }

    ComDebOut((DEB_DLL, "CDllHost::GetClassObject this:%x hr:%x\n", this, hr));
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::DllGetClassObject
//
//  Synopsis:   Calls the passed in DllGetClassObject on the current thread.
//              Used by an apartment of one threading model to load a DLL
//              of another threading model.
//
//  History:    04-Mar-96   Rickhi      Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CDllHost::DllGetClassObject(ULONG64 hDPE,
                REFCLSID rclsid, REFIID riid, IUnknown **ppUnk, DWORD dwFlags)
{
    ComDebOut((DEB_DLL,
        "CDllHost::DllGetClassObject this:%x tid:%x hDPE:%I64x rclsid:%I riid:%I ppUnk:%x\n",
        this, GetCurrentThreadId(), hDPE, &rclsid, &riid, ppUnk));

    // only valid to call this from within the host apartment
    Win4Assert(NeutralHost() || _dwHostAptId == GetCurrentApartmentId());
    Win4Assert((dwFlags == DLLHOST_IS_DPE) || (dwFlags == DLLHOST_IS_PFN));

    HRESULT hr;

    if (dwFlags == DLLHOST_IS_DPE)
    {
        hr = ((CClassCache::CDllPathEntry *)hDPE)->DllGetClassObject(rclsid, riid, ppUnk, TRUE);
    }
    else
    {
        hr = ((LPFNGETCLASSOBJECT)hDPE)(rclsid, riid, (void **) ppUnk);
    }

    ComDebOut((DEB_DLL,"CDllHost::DllGetClassObject this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::GetHostProxy
//
//  Synopsis:   returns the host proxy, AddRef'd.  Creates it (and
//              potentially the host apartment) if it does not yet exist.
//
//  History:    04-Mar-96   Rickhi      Created
//              06-Feb-98   JohnStra    Added NTA (NEUTRAL) support
//              24-Jun-98   GopalK      Simplified by removing redundant
//                                      functionality
//--------------------------------------------------------------------------
IDLLHost *CDllHost::GetHostProxy()
{
    // We could be called from any thread, esp one that has not done any
    // marshaling/unmarshaling yet, so we need to initialize the channel
    // if not already done.
    if (FAILED(InitChannelIfNecessary()))
        return NULL;

    // Prevent two threads from creating the proxy simultaneously.
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    // Check if the host is shutting down before attempting to do anything
    // with it.  If its shutting down, return NULL.
    IDLLHost *pIDH = NULL;
    if ((_dwType & HDLLF_SHUTTINGDOWN) == 0)
    {
        pIDH = _pIDllProxy;
        if (pIDH == NULL)
        {
            // The host thread marshaled the interface pointer into _objref and
            // placed the hresult into _hrMarshal. Check it and unmarshal to
            // get the host interface proxy.
            if (SUCCEEDED(_hrMarshal))
            {
                Win4Assert(_pIDllProxy == NULL);
                Unmarshal();
                pIDH = _pIDllProxy;
            }
        }

        // AddRef the proxy before releasing the lock.
        if (pIDH)
            pIDH->AddRef();
    }

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
    return pIDH;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::GetApartmentToken
//
//  Synopsis:   returns GIT cookie for host apartment's activator.
//              Creates the host apartment if it does not yet exist.
//
//  History:    25-Feb-98   SatishT      Created
//
//--------------------------------------------------------------------------
HRESULT CDllHost::GetApartmentToken(HActivator &hActivator)
{
    // we could be called from any thread, esp one that has not done any
    // marshaling/unmarshaling yet, so we need to initialized the channel
    // if not already done.

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
    {
        return hr;
    }

    // prevent two threads from creating the apartment simultaneously.
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    hActivator = NULL;
    hr = CO_E_SERVER_STOPPING;

    if (!(_dwType & HDLLF_SHUTTINGDOWN))
    {
        hr = S_OK;

        // host is still active, get or create the proxy
        if (_hActivator == NULL)
        {
            // apartment does not yet exist, create it -- only
            // done for apartment-threaded and multi-threaded.
            DWORD dwType = _dwType & HDLLF_HOSTTYPEMASK;
            if (dwType == HDLLF_SINGLETHREADED && gdwMainThreadId == 0)
            {
                // single threaded DLL and there is no main thread yet, so we
                // create an apartment thread that will also act as the main
                // thread.
                dwType = HDLLF_APARTMENTTHREADED;
            }

            switch (dwType)
            {
            case HDLLF_SINGLETHREADED:
                {
                    COleTls Tls;
                    CObjectContext *pSavedCtx;
                    CObjectContext *pDefaultCtx = IsSTAThread() ? Tls->pNativeCtx : g_pMTAEmptyCtx;
                    BOOL fRestore = (GetCurrentThreadId()==gdwMainThreadId) && IsThreadInNTA();

                    // If the current thread itself is the main thread,
                    // restore native state
                    if(fRestore)
                    {
                        pSavedCtx = LeaveNTA(pDefaultCtx);
                    }

                    // send a message to the single-threaded host apartment (the
                    // OleMainThread) to marshal the host interface.
                    _hr = CO_E_SERVER_STOPPING;
                    SSSendMessage(ghwndOleMainThread, WM_OLE_GETCLASS,
                                  WMSG_MAGIC_VALUE, (LPARAM) this);
                    hr = _hr;

                    // If we switched out of the NA above, switch back now.
                    if (fRestore)
                    {
                        pSavedCtx = EnterNTA(pSavedCtx);
                        Win4Assert(pSavedCtx == pDefaultCtx);
                    }

                    break;
                }

            case HDLLF_NEUTRALTHREADED:
                {
                    // Increment the host process inits
                    InterlockedIncrement( (LONG *)&gcHostProcessInits );
                    InterlockedIncrement( (LONG *)&gcNAHosts );

                    // Unconditionally enter the NTA.  We must enter it to
                    // initialize the NTA channel and get a token for the
                    // apartment.
                    COleTls tls;
                    CObjectContext* pCurrentCtx;
                    BOOL fSwitched = EnterNTAIfNecessary(tls, &pCurrentCtx);

                    // Create an apartment activator cookie.
                    _dwHostAptId = GetCurrentApartmentId();
                    _dwTid       = GetCurrentThreadId();
                    _dwType     |= HDLLF_COMAPARTMENT;
                    hr = GetCurrentApartmentToken(_hActivator, TRUE);

                    // That's it.  Now that we've initialized the NTA channel
                    // and registered the NTA in the activator table, we pop
                    // back to the previous apartment.
                    LeaveNTAIfNecessary(tls, fSwitched, pCurrentCtx);

                    break;
                }

            case HDLLF_MULTITHREADED:
                // it is possible that we're comming through here twice if
                // the first time through we got an error in the marshal or
                // unmarshal, so dont create the event twice.
                if (_hEventWakeUp == NULL)
                    _hEventWakeUp = CreateEvent(NULL, FALSE, FALSE, NULL);

                if (_hEventWakeUp == NULL)
                {
                    hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
                    break;
                }

                // fallthru to common code for these two cases.

            case HDLLF_APARTMENTTHREADED:
                // create a thread to act as the apartment for the dll host. It
                // will marshal the host interface and set an event when done.

                // it is possible that we're comming through here twice if
                // the first time through we got an error in the marshal or
                // unmarshal, so dont create the event twice.
                if (_hEvent == NULL)
                    _hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

                if (_hEvent)
                {
                    _dwType |= HDLLF_COMAPARTMENT;
                    hr = CacheCreateThread( DLLHostThreadEntry, this );
                    if (SUCCEEDED(hr))
                    {
                        WaitForSingleObject(_hEvent, 0xffffffff);
                        hr = _hr;
                    }
                    else
                    {
                        _dwType &= ~HDLLF_COMAPARTMENT;
                    }
                }
                else
                {
                    hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
                }

                // dont try to cleanup if there are errors from the other
                // thread, we'll just try again later.
                break;
            }

        }

        // the other thread registered its activator in the GIT and
        // placed the GIT cookie into _hActivator. If there was an error
        // it will be NULL, and that's fine.

        hActivator = _hActivator;
    }


    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetSingleThreadedHost
//
//  Synopsis:   Get the host interface for single threaded inproc class
//              object creation.
//
//  Arguments:  [param] - pointer to the CDllHost for the single-threaded
//                        host apartment.
//
//  History:    06-Mar-96   Rickhi    Created
//
//--------------------------------------------------------------------------
HRESULT GetSingleThreadedHost(LPARAM param)
{
    ComDebOut((DEB_DLL,
               "GetSingleThreadedHost pDllHost:%x tid:%x\n",
               param,
               GetCurrentThreadId()));

    // param is the ptr to the CDllHost object. Just tell it to marshal
    // it's IDLLHost interface into it's _objref. The _objref will be
    // unmarshaled by the calling apartment and the proxy placed in
    // _pIDllProxy.   Dont need to call Lock because we are already
    // guarenteed to be the only thread accessing the state at this time.

    CDllHost *pDllHost = (CDllHost *)param;
    return pDllHost->GetSingleThreadHost();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::GetSingleThreadedHost
//
//  Synopsis:   Get the host interface for single threaded inproc class
//              object creation.
//
//  History:    06-Apr-96   Rickhi    Created
//
//--------------------------------------------------------------------------
HRESULT CDllHost::GetSingleThreadHost()
{
    // set up the TID and apartment id, then marshal the interface
    _dwHostAptId = GetCurrentApartmentId();
    _dwTid       = GetCurrentThreadId();

    // Get or Create an apartment activator cookie
    HRESULT hr = GetCurrentApartmentToken(_hActivator, TRUE);


    if (SUCCEEDED(hr))
    {
        // Marshal here, because you must marshal when you initialize your
        // Activator token.
        hr = Marshal(); 
    }

    //
    // Send the HRESULT back in the object
    //

    _hr = hr;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   DLLHostThreadEntry
//
//  Synopsis:   Worker thread entry point for AT & MT DLL loading
//
//  History     06-Apr-96   Rickhi      Created
//
//+-------------------------------------------------------------------------
DWORD _stdcall DLLHostThreadEntry(void *param)
{
    ComDebOut((DEB_DLL, "DLLHostThreadEntry Tid:%x\n", GetCurrentThreadId()));

    CDllHost *pDllHost = (CDllHost *)param;
    ComDebOut((DEB_DLL, "--> WorkerThread CDllHost:0x%x, HostInits:%d, ProcessInits:%d\n",
               pDllHost, gcHostProcessInits, g_cProcessInits));
    HRESULT hr = pDllHost->WorkerThread();
    ComDebOut((DEB_DLL, "<-- WorkerThread CDllHost:0x%x, HostInits:%d, ProcessInits:%d\n",
               pDllHost, gcHostProcessInits, g_cProcessInits));

    ComDebOut((DEB_DLL, "DLLHostThreadEntry hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     WorkerThread
//
//  Synopsis:   Worker thread for STA and MTA DLL loading. Single threaded
//              Dlls are loaded on the main thread (gdwOleMainThread).
//
//  History     06-Apr-96   Rickhi      Created
//
//+-------------------------------------------------------------------------
HRESULT CDllHost::WorkerThread()
{
    ComDebOut((DEB_DLL, "WorkerThread pDllHost:%x\n", this));

    // We can't look at _hEvent after we let the caller go because the caller
    // can NULL it. Thus we save it in a local stack var.
    Win4Assert(_hEvent);
    HANDLE hEventDone = _hEvent;

    HRESULT hr;
    COleTls Tls(hr);
    if(SUCCEEDED(hr))
    {
        // Mark the thread as a host
        Tls->dwFlags &= ~OLETLS_DISPATCHTHREAD;
        Tls->dwFlags  |= OLETLS_HOSTTHREAD;

        // Init the thread appropriatly
        BOOL fMTA = ((_dwType & HDLLF_HOSTTYPEMASK) == HDLLF_MULTITHREADED) ? TRUE : FALSE;
        hr = CoInitializeEx(NULL, fMTA ? COINIT_MULTITHREADED : COINIT_APARTMENTTHREADED);
        if(SUCCEEDED(hr))
        {
            // Count 1 more host process.
            InterlockedIncrement( (LONG *)&gcHostProcessInits );

            // Marshal the DllHost interface to pass back to the caller.
            _dwHostAptId = GetCurrentApartmentId();
            _dwTid       = GetCurrentThreadId();

            // Marshal IDllInterface
            hr = Marshal();

            // Create an apartment activator cookie
            if(SUCCEEDED(hr))
            {
                Win4Assert(fMTA || FAILED(GetCurrentApartmentToken(_hActivator, FALSE)));
                hr = GetCurrentApartmentToken(_hActivator, TRUE);
            }

            if(SUCCEEDED(hr))
            {
                // Wake up the thread that started us. Note we can't look
                // at the _hEventWakeup after that time because the other
                // thread could NULL it. Thus we stick it in a stack var.
                HANDLE hEventWakeUp = _hEventWakeUp;
                _hr = hr;
                SetEvent(hEventDone);

                // Enter a wait loop for work. stay there until told to exit.
                if (hEventWakeUp)
                {
                    MTAWorkerLoop(hEventWakeUp);
                }
                else
                {
                    STAWorkerLoop();
                }
            }

            // Special uninitialize for the host threads that does not take
            // the single thread mutex and does not check for process uninits.
            wCoUninitialize(Tls, TRUE);
            Win4Assert(_dwType & HDLLF_COMAPARTMENT);
            _dwType &= ~HDLLF_COMAPARTMENT;

            // Count 1 less host process *after* doing the Uninit.
            InterlockedDecrement((LONG *)&gcHostProcessInits);
        }

        // Revert the thread type
        Tls->dwFlags &= ~OLETLS_HOSTTHREAD;
    }

    // send back the status code inside the object
    _hr = hr;

    // Either CoInit/Marshal failed or we are exiting due to the last
    // CoUninitialize by some other thread. Wake up the calling thread.
    SetEvent(hEventDone);

    ComDebOut((DEB_DLL, "WorkerThread pDllHost:%x hr:%x\n", this, hr));
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     MTAWorkerLoop
//
//  Synopsis:   Worker thread loop for MTA Host.
//
//  History     24-Oct-96   Rickhi      Created
//
//+-------------------------------------------------------------------------
void CDllHost::MTAWorkerLoop(HANDLE hEventWakeUp)
{
    while (1)
    {
        DWORD dwWakeReason = WaitForSingleObject(hEventWakeUp, 300000);
        if (dwWakeReason == WAIT_TIMEOUT)
        {
            //
            // We woke up because of a timeout. Go poll CoFreeUnusedLibraries.
            //

            CoFreeUnusedLibraries();
        }
        else
        {
            //
            // Woke up because the exit event was signalled. Just exit.
            //

            CloseHandle(hEventWakeUp);
            break;
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   STAHostTimerProc
//
//  Synopsis:   Timer proc for STA Host. When called, it calls CoFreeUnused
//              Libraries.
//
//  History     24-Oct-96   Rickhi      Created
//
//
//+-------------------------------------------------------------------------
void CALLBACK STAHostTimerProc(HWND hWnd, UINT uMsg, UINT_PTR uTimerId, DWORD dwTime)
{
    // go check if there are libraries to free
    CoFreeUnusedLibraries();
}

//+-------------------------------------------------------------------------
//
//  Member:     STAWorkerLoop
//
//  Synopsis:   Worker thread loop for STA Host.
//
//  History     24-Oct-96   Rickhi      Created
//
//+-------------------------------------------------------------------------
void CDllHost::STAWorkerLoop()
{
    HWND hWnd = TLSGethwndSTA();
    gTimerId = SetTimer(hWnd, 0, 300000, STAHostTimerProc);

    // enter a message loop to process requests.
    MSG msg;
    while (SSGetMessage(&msg, NULL, 0, 0))
    {
        if (CSurrogatedObjectList::TranslateAccelerator(&msg))
            continue;

        TranslateMessage(&msg);
        SSDispatchMessage(&msg);

        // Leverage appverifier.   Check for orphaned critsecs (should
        // never own any locks at this point).
        RtlCheckForOrphanedCriticalSections(GetCurrentThread());
    }

    KillTimer(hWnd, gTimerId);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::Marshal
//
//  Synopsis:   marshals IDLLHost interface on this object
//
//  History:    04-Mar-96   Rickhi      Created
//
//--------------------------------------------------------------------------
HRESULT CDllHost::Marshal()
{
    ComDebOut((DEB_DLL, "CDllHost::Marshal this:%x tid:%x\n",
        this, GetCurrentThreadId()));

    // Only valid to call this from inside the host apartment.
    Win4Assert(IsThreadInNTA() || _dwHostAptId == GetCurrentApartmentId());

    // Marshal this objref so another apartment can unmarshal it.
    _hrMarshal = MarshalInternalObjRef(_objref,
                                       IID_IDLLHost,
                                       (IDLLHost*) this,
                                       MSHLFLAGS_NOPING,
                                       (void **)&_pStdId);

    if (SUCCEEDED(_hrMarshal))
    {
        // Make the unmarshaled proxy callable from any apartment.
        MakeCallableFromAnyApt(_objref);
    }

    ComDebOut((DEB_DLL, "CDllHost::Marshal this:%x hr:%x\n", this, _hrMarshal));
    return _hrMarshal;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::UnMarshal
//
//  Synopsis:   unmarshals the IDLLHost interface to create a proxy
//
//  History:    04-Mar-96   Rickhi      Created
//              12-Feb-98   Johnstra    Added NTA support
//
//  Notes:      Unmarshal never enters the NTA.  If it did, then it
//              just find the StdId for the NTA instead of the caller's.
//
//--------------------------------------------------------------------------
HRESULT CDllHost::Unmarshal()
{
    ComDebOut((DEB_DLL, "CDllHost::Unmarshal this:%x tid:%x\n",
              this,
              GetCurrentThreadId()));

    // Unless this is the NTA host, unmarshaling is only valid to call this from
    // outside the host apartment.

    Win4Assert((HDLLF_NEUTRALTHREADED & (_dwType & HDLLF_HOSTTYPEMASK)) ||
                _dwHostAptId != GetCurrentApartmentId());

    HRESULT hr = _hrMarshal;
    if (SUCCEEDED(hr))
    {
        // Unmarshal this objref so it can be used in this apartment.
        hr = UnmarshalInternalObjRef(_objref, (void **)&_pIDllProxy);

        // free the resouces held by the OBJREF.
        FreeObjRef(_objref);

        // indicate that we have free'd the OBJREF
        _hrMarshal = RPC_E_INVALID_OBJREF;
    }

    ComDebOut((DEB_DLL, "CDllHost::Unmarshal this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::Initialize
//
//  Synopsis:   initializer for Dll host object.
//
//  History:    04-Mar-96   Rickhi      Created
//
//--------------------------------------------------------------------------
HRESULT CDllHost::Initialize(DWORD dwType)
{
    ComDebOut((DEB_DLL,"CDllHost::Initialize this:%x type:%x\n", this,dwType));

    _dwType           = dwType;
    _dwHostAptId      = 0;
    _hActivator       = 0;
    _dwTid            = 0;
    _hrMarshal        = E_UNSPEC; // never been marshaled yet, dont cleanup
    _pStdId           = NULL;
    _pIDllProxy       = NULL;
    _hEvent           = NULL;
    _hEventWakeUp     = NULL;	

    return _mxs.Init();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::ClientCleanupStart
//
//  Synopsis:   starts client-side cleanup for Dll host object.
//
//  History:    04-Apr-96   Rickhi      Created
//              18-Jun-98   GopalK      Fixed races during shutdown
//
//--------------------------------------------------------------------------
HANDLE CDllHost::ClientCleanupStart()
{
    ComDebOut((DEB_DLL, "CDllHost::ClientCleanupStart this:%x AptId:%x\n",
        this, GetCurrentApartmentId()));
    ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    HANDLE hWait = NULL;

    COleTls tls;
    CObjectContext* pCurrentCtx;
    BOOL fSwitched = EnterNTAIfNecessary(tls, &pCurrentCtx);

    // flag the host as shutting down. Prevents GetHostProxy from
    // creating another proxy
    Win4Assert(!(_dwType & HDLLF_SHUTTINGDOWN));
    _dwType |= HDLLF_SHUTTINGDOWN;

    if (_dwType & HDLLF_COMAPARTMENT)
    {
        if (_dwType & HDLLF_NEUTRALTHREADED)
        {
            // Unlike the MTA and STA hosts, the NTA host doesn't need to
            // call wCoUnintialize.  It can do all of its cleanup right
            // here.
            if (SUCCEEDED(_hrMarshal))
            {
                // still have the OBJREF around that we have
                // not yet Unmarshaled, so clean it up now.
                ReleaseMarshalObjRef(_objref);
                FreeObjRef(_objref);
                _hrMarshal = E_UNSPEC;
            }
            _dwType &= ~HDLLF_COMAPARTMENT;
            InterlockedDecrement( (LONG *) &gcHostProcessInits );
            InterlockedDecrement( (LONG *) &gcNAHosts );
        }
        else
        {
            // wakeup host thread to tell it to exit, then wait for it
            // to complete it's Uninitialization before continuing.
            Win4Assert(_hEvent);
            hWait = _hEvent;
            _hEvent = NULL;

            if (_dwType & HDLLF_MULTITHREADED)
            {
                Win4Assert(_hEventWakeUp);
                SetEvent(_hEventWakeUp);
                _hEventWakeUp = NULL;
            }
            else
            {
                PostThreadMessage(_dwTid, WM_QUIT, 0, 0);
            }
        }
    }

    // Since we own all the code that will run during cleanup, we know it
    // is safe to hold the lock for the duration.
    if (_pIDllProxy)
    {
        // proxy exists, release it.
        _pIDllProxy->Release();
        _pIDllProxy = NULL;
    }

    // Close the event handles.
    if (_hEvent)
    {
        CloseHandle(_hEvent);
        _hEvent = NULL;
    }

    if (_hEventWakeUp)
    {
        CloseHandle(_hEventWakeUp);
        _hEventWakeUp = NULL;
    }

    LeaveNTAIfNecessary(tls, fSwitched, pCurrentCtx);

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);

    ComDebOut((DEB_DLL, "CDllHost::ClientCleanupStart this:%x hWait:%x\n",
        this, hWait));
    return hWait;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::ClientCleanupFinish
//
//  Synopsis:   Finishes client-side cleanup for Dll host object.
//
//  History:    04-Apr-96   Rickhi      Created
//
//--------------------------------------------------------------------------
void CDllHost::ClientCleanupFinish(HANDLE hEvent)
{
    COleTls tls;
    CObjectContext* pCurrentCtx;
    BOOL fSwitched = EnterNTAIfNecessary(tls, &pCurrentCtx);

    ComDebOut((DEB_DLL, "CDllHost::ClientCleanupFinish this:%x AptId:%x hEvent:%x\n",
        this, GetCurrentApartmentId(), hEvent));
    ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
    ASSERT_LOCK_NOT_HELD(_mxs);

    // wait for the server apartments to uninitialize before continuing.
    // Don't hold the lock across this call since some host apartment
    // may currently be processing a call which wants to use this
    // host.
    if (hEvent)
    {
        WaitForSingleObject(hEvent, 0xffffffff);
        CloseHandle(hEvent);
    }

    // allow activation again
    Win4Assert(!(_dwType & HDLLF_COMAPARTMENT));
    _dwType = (_dwType & HDLLF_HOSTTYPEMASK);

    LeaveNTAIfNecessary(tls, fSwitched, pCurrentCtx);
    ComDebOut((DEB_DLL, "CDllHost::ClientCleanupFinish this:%x\n", this));
}


//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::ServerCleanup
//
//  Synopsis:   server-side cleanup for Dll host object.
//
//  History:    04-Apr-96   Rickhi      Created
//              14-Feb-98   Johnstra    make NTA aware
//
//  Notes:      Don't attempt to enter the NTA from within this method.
//              Per-apartment cleanup code will switch to the NTA
//              before calling us.
//
//--------------------------------------------------------------------------
void CDllHost::ServerCleanup(DWORD dwAptId)
{
    // only do cleanup if the apartment id's match
    if (_dwHostAptId != dwAptId)
        return;

    ComDebOut((DEB_DLL, "CDllHost::ServerCleanup this:%x AptId:%x Type:%x\n",
        this, GetCurrentApartmentId(), _dwType));

    // the _mxs mutex is already held in order to
    // prevent simultaneous use/creation of the proxy while this thread
    // is doing the cleanup. Since we own all the code that will run during
    // cleanup, we know it is safe to hold the lock for the duration.

    // revoke the apartment activator cookie (best faith effort)
    RevokeApartmentActivator();
    _hActivator = 0;

    if (SUCCEEDED(_hrMarshal))
    {
        // server side, marshal was successful and has not been
        // unmarshaled so release it now via RMD
        ReleaseMarshalObjRef(_objref);
        FreeObjRef(_objref);
        _hrMarshal = E_UNSPEC;
    }

    if (_pStdId)
    {
        // cleanup the server-side marshaling infrastructure.
        ((CStdMarshal *)_pStdId)->Disconnect(DISCTYPE_SYSTEM);
        _pStdId->Release();
        _pStdId = NULL;
    }

    ComDebOut((DEB_DLL,
        "CDllHost::Cleanup this:%x tid:%x\n", this, GetCurrentThreadId()));
}

//+-------------------------------------------------------------------------
//
//  Function:   IsMTAHostInitialized
//
//  Synopsis:   Returns TRUE if MTA Host is active
//
//  History     02-Jul-98   GopalK      Created
//
//+-------------------------------------------------------------------------
BOOL IsMTAHostInitialized()
{
    return(gMTHost.IsComApartment());
}

//+-------------------------------------------------------------------------
//
//  Function:   DllHostProcessInitialize
//
//  Synopsis:   initializes the state for DllHost objects.
//
//  History     06-Mar-96   Rickhi      Created
//              06-Feb-98   JohnStra    Add NTA support.
//
//+-------------------------------------------------------------------------
HRESULT DllHostProcessInitialize()
{
    HRESULT hr = gSTHost.Initialize(HDLLF_SINGLETHREADED);

    if (SUCCEEDED(hr)) 
        hr = gSTMTHost.Initialize(HDLLF_SINGLETHREADED);

    if (SUCCEEDED(hr)) 
        hr = gATHost.Initialize(HDLLF_APARTMENTTHREADED);

    if (SUCCEEDED(hr)) 
        hr = gMTHost.Initialize(HDLLF_MULTITHREADED);

    if (SUCCEEDED(hr)) 
        hr = gNTHost.Initialize(HDLLF_NEUTRALTHREADED);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllHostProcessUninitialize
//
//  Synopsis:   Cleans up the state for DllHost objects. This is called when
//              the process is going to uninitialize. It cleans up the
//              client half of the objects, and wakes the worker threads to
//              cleanup the server half of the objects.
//
//  History     06-Mar-96   Rickhi      Created
//              06-Feb-98   JohnStra    Add NTA support
//
//+-------------------------------------------------------------------------
void DllHostProcessUninitialize()
{
    ASSERT_LOCK_HELD(g_mxsSingleThreadOle);
    UNLOCK(g_mxsSingleThreadOle);
    ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);

    // initiate the cleanup of the STA and MTA host objects
    // Dont hold the mxsSingleThreadOle because it has a lower
    // rank in the mutex hierarchy (ie another thread could call
    // GetHostProxy which takes mxs then creates a thread that takes
    // mxsSinglThreadOle which would be the opposite order of the
    // calls here).
    HANDLE h1 = gSTHost.ClientCleanupStart();
    HANDLE h2 = gSTMTHost.ClientCleanupStart();
    HANDLE h3 = gATHost.ClientCleanupStart();
    HANDLE h4 = gMTHost.ClientCleanupStart();
    HANDLE h5 = gNTHost.ClientCleanupStart();

    // Complete the cleanup of the STA and MTA host objects
    gSTHost.ClientCleanupFinish(h1);
    gSTMTHost.ClientCleanupFinish(h2);
    gATHost.ClientCleanupFinish(h3);
    gMTHost.ClientCleanupFinish(h4);
    gNTHost.ClientCleanupFinish(h5);

    // Sanity check
    Win4Assert(gcHostProcessInits - gcNAHosts == 0 );

    ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
    LOCK(g_mxsSingleThreadOle);
}

//+-------------------------------------------------------------------------
//
//  Function:   DllHostThreadUninitialize
//
//  Synopsis:   Cleans up the server-side state for any DllHost objects
//              that happen to live on this thread.
//
//  History     06-Mar-96   Rickhi      Created
//              08-Feb-98   JohnStra    Added NTA support
//
//+-------------------------------------------------------------------------
void DllHostThreadUninitialize()
{
    DWORD dwAptId = GetCurrentApartmentId();

    gSTHost.ServerCleanup(dwAptId);
    gSTMTHost.ServerCleanup(dwAptId);
    gATHost.ServerCleanup(dwAptId);
    gMTHost.ServerCleanup(dwAptId);
    gNTHost.ServerCleanup(dwAptId);
}



//+---------------------------------------------------------------------------
//
//  Function:   CoIsSurrogateProcess
//
//  Synopsis:   Returns TRUE if this is a surrogate process
//
//  History:    20-Oct-97   MikeW   Created
//
//----------------------------------------------------------------------------
BOOL CoIsSurrogateProcess()
{
    return (NULL != CCOMSurrogate::_pSurrogate);
}



//+-------------------------------------------------------------------------
//
//  Method:     CSurrogatedObjectList::TranslateAccelerator, static
//
//  Synopsis:   Try to translate an accelerator key in this message
//
//  Parameters: [pMsg]          -- The message
//
//  Returns:    TRUE if the message was translated, else FALSE
//
//  History:    17-Oct-97   MikeW   Created
//
//-------------------------------------------------------------------------

BOOL CSurrogatedObjectList::TranslateAccelerator(MSG *pMsg)
{
    if (pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST)
        return FALSE;

    COleTls                 tls;
    CSurrogatedObjectList  *pObject = tls->pSurrogateList;

    //
    // Try to find the object that owns this window
    //

    for ( ; NULL != pObject; pObject = pObject->_pNext)
    {
        //
        // Get the top level window for this object if we don't already have it
        //

        if (NULL == pObject->_hWnd)
        {
            if (S_OK != pObject->_pInplaceObject->GetWindow(&pObject->_hWnd))
            {
                pObject->_hWnd = NULL;      // just to be sure
                continue;
            }
        }

        //
        // If the destination window of the accelerator message is this object's
        // window or a child of it, then let it do the translation
        //

        if (pMsg->hwnd == pObject->_hWnd || IsChild(pObject->_hWnd, pMsg->hwnd))
        {
            HRESULT hr = pObject->_pInplaceObject->TranslateAccelerator(pMsg);

            return (S_OK == hr);
        }
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Function:   CoRegisterSurrogatedObject
//
//  Synopsis:   Register an object in the surrogate list
//
//  Parameters: [pObject]           -- The object
//
//  Returns:    S_OK if all is well
//
//  History:    17-Oct-97   MikeW   Created
//
//  CODEWORK:   Currently there is no way to remove the object from the
//              list.  This should be ok for restricted sites because
//              rpcss should forcibaly kill the process when all the
//              external refs are gone.
//
//-------------------------------------------------------------------------

HRESULT CoRegisterSurrogatedObject(IUnknown *pObject)
{
    IOleInPlaceActiveObject *pInplaceObject;
    HRESULT                  hr;
    CSurrogatedObjectList   *pEntry;
    HWND                     hWnd;

    hr = pObject->QueryInterface(
                        IID_IOleInPlaceActiveObject,
                        (void **) &pInplaceObject);

    if (S_OK == hr)
    {
        pEntry = new CSurrogatedObjectList(pInplaceObject);

        if (NULL == pEntry)
        {
            hr = E_OUTOFMEMORY;
            pInplaceObject->Release();
        }
        else
        {
            COleTls tls;

            //
            // NOTE: Not thread safe! This routine must be called on the
            // same thread that created the object
            //

            pEntry->_pNext = tls->pSurrogateList;
            tls->pSurrogateList = pEntry;
        }
    }
    else if (E_NOINTERFACE == hr)
    {
        //
        // We only need to do something if the object supports
        // IOleInPlaceActiveObject so don't complain if it doesn't
        //

        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\mainthrd.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1996.
//
//  File:       mainthrd.cxx
//
//  Contents:   Main Thread Procedure and support functions
//
//  History:    03-Dec-96   MattSmit   Created
//
//----------------------------------------------------------------------------


#include    <ole2int.h>
#include    <channelb.hxx>
#include    <tracelog.hxx>

#include    "objact.hxx"
#include    <dllhost.hxx>
#include    <sobjact.hxx>

// Name of window class and message class for dispatching messages.
LPTSTR  gOleWindowClass = NULL;         // class used to create windows

// Various things used for special single threaded DLL processing
DWORD gdwMainThreadId = 0;
HWND  ghwndOleMainThread = NULL;

// this flag is to indicate whether it is UninitMainThread that is
// destroying the window, or system shut down destroying the window.
BOOL gfDestroyingMainWindow = FALSE;

const TCHAR *ptszOleMainThreadWndName = TEXT("OleMainThreadWndName");

const WCHAR *ptszOleMainThreadWndClass = L"OleMainThreadWndClass";

//+---------------------------------------------------------------------------
//
//  Function:   OleMainThreadWndProc
//
//  Synopsis:   Window proc for handling messages to the main thread
//
//  Arguments:  [hWnd] - window the message is on
//              [message] - message the window receives
//              [wParam] - first message parameter
//              [lParam] - second message parameter.
//
//  Returns:    Depends on the message
//
//  Algorithm:  If the message is one a user message that we have defined,
//              dispatch it. Otherwise, send any other message to the
//              default window proc.
//
//  History:    22-Nov-94   Ricksa  Created
//
//----------------------------------------------------------------------------
LRESULT OleMainThreadWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch(message)
    {
    case WM_OLE_GETCLASS:
        // get the host interface for single-threaded dlls
        return GetSingleThreadedHost(lParam);

    // Check whether it is UninitMainThreadWnd or system shutdown that
    // is destroying the window. Only actually do the destroy if it is us.
    case WM_DESTROY:
    case WM_CLOSE:
        if (gfDestroyingMainWindow == FALSE)
        {
            // Not in UninitMainThreadWnd so just ignore this message. Do not
            // dispatch it.
            ComDebOut((DEB_WARN, "Attempted to destroy Window outside of UninitMainThreadWnd"));
            return 0;
        }
        // else fallthru
    }

    // We don't process the message so pass it on to the default
    // window proc.
    return SSDefWindowProc(hWnd, message, wParam, lParam);
}



//+---------------------------------------------------------------------------
//
//  Function:   InitMainThreadWnd
//
//  Synopsis:   Do initialization necessary for main window processing.
//
//  Returns:    S_OK - we got initialized
//              S_FALSE - initialization skipped due to WOW thread.
//              other - failure creating window
//
//  Algorithm:  Create our main thread window and save the threadid.
//
//  History:    22-Nov-94   Ricksa  Created
//              24-Mar-95   JohannP Added notify mechanismen
//
//----------------------------------------------------------------------------
HRESULT InitMainThreadWnd(void)
{
    HRESULT hr = S_FALSE;

    ComDebOut((DEB_ENDPNT, "InitMainThreadWnd on %x\n", GetCurrentThreadId()));
    Win4Assert(IsSTAThread());

    // Use IsWOWThread and NOT IsWOWProcess because there may be 32 bit threads
    // in WOW that call CoInitializeEx for their own purpose. IsWowThread gets
    // set in the TLS only when CoInitializeWow is called (when a 16-bit app
    // calls CoInitialize).

    if (!IsWOWThread())
    {
        // We could get here in NTVDM (Wow) only if a 32-bit thread
        // calls CoInit before WOW calls it on behalf of any 16-bit app
        // Otherwise there is no "main" thread in WOW. A thread in WOW
        // gets marked as a WOW thread when WOW calls CoInit (coming from
        // the 16-bit world) on that thread.

        // this window is only needed for the non WOW case since
        // WOW is not a real apartment case
        // Create a main window for this application instance.

        // NT has defined a new window type that won't receive broadcast
        // messages. We use this whenever possible.
        HWND hwndParent = HWND_MESSAGE;
		
        Win4Assert(gOleWindowClass != NULL);

        // gdwMainThreadId and ghwndOleMainThread should be
        // set or cleared together as a matched pair
        Win4Assert(gdwMainThreadId == 0);
        Win4Assert(ghwndOleMainThread == NULL);

        ghwndOleMainThread = CreateWindowEx(
                0,
                gOleWindowClass,
                ptszOleMainThreadWndName,
                // must use WS_POPUP so the window does not get assigned
                // a hot key by user.
                (WS_DISABLED | WS_POPUP),
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                hwndParent,
                NULL,
                g_hinst,
                NULL);       
        if (!ghwndOleMainThread)
        {
            ComDebOut((DEB_WARN, "Register Window on OleWindowClass failed \n"));

            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            // Success.  Remember this thread
            gdwMainThreadId = GetCurrentThreadId();
            hr = S_OK;
        }
    }

    ComDebOut((DEB_ENDPNT, "InitMainThreadWnd done on %x\n", gdwMainThreadId));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterOleWndClass
//
//  Synopsis:   Registers the Ole window class
//
//  History:    04-Apr-01   JSimmons  Moved here from InitMainThreadWnd
//
//----------------------------------------------------------------------------
HRESULT RegisterOleWndClass(void)
{
    HRESULT hr = S_OK;

    ComDebOut((DEB_ENDPNT, "RegisterOleWndClass on %x\n", GetCurrentThreadId()));
    Win4Assert(IsSTAThread());
    Win4Assert(gOleWindowClass == NULL);

    // Register windows class.
    WNDCLASST        xClass;
    xClass.style         = 0;
    xClass.lpfnWndProc   = OleMainThreadWndProc;
    xClass.cbClsExtra    = 0;

    // DDE needs some extra space in the window
    xClass.cbWndExtra    = sizeof(LPVOID) + sizeof(ULONG) + sizeof(HANDLE);
    xClass.hInstance     = g_hinst;
    xClass.hIcon         = NULL;
    xClass.hCursor       = NULL;
    xClass.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
    xClass.lpszMenuName  = NULL;
    xClass.lpszClassName = ptszOleMainThreadWndClass;	

    gOleWindowClass = (LPTSTR)RegisterClass(&xClass);
    if (gOleWindowClass == 0)
    {
        // it is possible the dll got unloaded without us having called
        // unregister so we call it here and try again.

        // jsimmons 04/04/01
        // I don't know if the above comment still holds true or
        // not -- it's probably some antique holdover from the 9x
        // days.  However, retrying the registration should be benign
        // in any case.
        (void)UnregisterClass(ptszOleMainThreadWndClass, g_hinst);

        gOleWindowClass = (LPTSTR) RegisterClass(&xClass);
        if (gOleWindowClass == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            ComDebOut((DEB_ERROR, "RegisterOleWndClass failed; GLE=0x%x\n", GetLastError()));
        }
    }

    ComDebOut((DEB_ENDPNT,"RegisterOleWndClass done on %x\n", GetCurrentThreadId()));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   UnRegisterOleWndClass
//
//  Synopsis:   Unregister Ole window class
//
//  Algorithm:  Unregister the window class.
//
//  History:    13-Dec-96   MurthyS  Created
//
//----------------------------------------------------------------------------
void UnRegisterOleWndClass(void)
{
    ComDebOut((DEB_ENDPNT, "UnRegisterOleWndClass on %x\n", GetCurrentThreadId()));
    Win4Assert(IsSTAThread());

    Win4Assert(gOleWindowClass != NULL);

    // Unregister the window class.  We use the string name of the class, but we could
    // also use the atom (gOleWindowClass).  In any event, once we unregister the class,
    // the class atom is invalid so we null it out for easier debugging if someone
    // tries to use afterwards.
    if (UnregisterClassT(ptszOleMainThreadWndClass, g_hinst) == FALSE)
    {
        ComDebOut((DEB_ERROR,"Unregister Class failed on OleMainThreadWndClass %ws because %d\n", ptszOleMainThreadWndClass, GetLastError()));
    }
    
    gOleWindowClass = NULL;

    ComDebOut((DEB_ENDPNT,"UnRegisterOleWndClass done on %x\n", GetCurrentThreadId()));
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   UninitMainThreadWnd
//
//  Synopsis:   Free resources used by main window processing.
//
//  Algorithm:  Destroy the main thread window if this is indeed the main thread.
//
//  History:    22-Nov-94   Ricksa  Created
//              24-Mar-95   JohannP Added notify mechanismen
//
//----------------------------------------------------------------------------
void UninitMainThreadWnd(void)
{
    ComDebOut((DEB_ENDPNT, "UninitMainThreadWnd on %x\n", GetCurrentThreadId()));
    Win4Assert(IsSTAThread());

    if (gdwMainThreadId == GetCurrentThreadId())
    {
        BOOL fRet = FALSE;

        // we can get here through a 32-bit thread in Wow (Shell32 has
        // started calling CoInit as of 7/98 and we do end up having
        // gdwMainThreadId in ntvdm.exe.

        // Destroy the window
        if (IsWindow(ghwndOleMainThread))
        {
            // flag here is to indicate that we are destroying the window.
            // as opposed to the system shutdown closing the window. the
            // flag is looked at in dcomrem\chancont\ThreadWndProc.
            gfDestroyingMainWindow = TRUE;
            SSDestroyWindow(ghwndOleMainThread);
            gfDestroyingMainWindow = FALSE;
            ghwndOleMainThread = NULL;
        }

        gdwMainThreadId = 0;
    }

    ComDebOut((DEB_ENDPNT,"UninitMainThreadWnd done on %x\n", GetCurrentThreadId()));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\dsapi.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       dsapi.cxx
//
//  Contents:   Routines for lookup/queries of application state in the DS.
//
//  Functions:
//
//  History:    Feb-97  DKays   Created
//
//--------------------------------------------------------------------------

#include <ole2int.h>
#include <appmgmt.h>

#include "cfactory.hxx"
#include "resolver.hxx"
#include "objact.hxx"

LPCWSTR FindExt(LPCWSTR szPath);

#ifdef DIRECTORY_SERVICE

DWORD CheckDownloadRegistrySettings (void)
{
    static DWORD dwCSEnabled=0;
    static BOOL fInitialized=FALSE;

    if (!fInitialized)
    {
        DWORD dwType=0;
        DWORD dwSize=0;
        HKEY hKeyAppMgmt=NULL;

        // First check for a user specific policy
        if (ERROR_SUCCESS==RegOpenKeyEx(HKEY_CURRENT_USER,
                                        L"Software\\Policies\\Microsoft\\Windows\\App Management",
                                        0,
                                        KEY_QUERY_VALUE,
                                        &hKeyAppMgmt))
        {
            dwSize=sizeof(dwCSEnabled);
            if (ERROR_SUCCESS!=RegQueryValueEx(hKeyAppMgmt,
                                               L"COMClassStore",
                                               NULL,
                                               &dwType,
                                               (LPBYTE) &dwCSEnabled,
                                               &dwSize))
            {
                dwCSEnabled=0;
            }
            else if (dwType != REG_DWORD || 0 == dwSize)
            {
                dwCSEnabled=0;
            }
            RegCloseKey(hKeyAppMgmt);
        }

        // If no per-user policy was found or per-user policy didn't request
        // class store, check for per-machine policy
        if (!dwCSEnabled)
        {
            DWORD dwCSEnabledForMachine=0;
            if (ERROR_SUCCESS==RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                            L"Software\\Policies\\Microsoft\\Windows\\App Management",
                                            0,
                                            KEY_QUERY_VALUE,
                                            &hKeyAppMgmt))
            {
                dwSize=sizeof(dwCSEnabledForMachine);
                if (ERROR_SUCCESS!=RegQueryValueEx(hKeyAppMgmt,
                                                   L"COMClassStore",
                                                   NULL,
                                                   &dwType,
                                                   (LPBYTE) &dwCSEnabledForMachine,
                                                   &dwSize))
                {
                    // no value there
                    dwCSEnabledForMachine=0;
                }
                else if (dwType!=REG_DWORD || 0==dwSize)
                {
                    // the value is of wrong type
                    dwCSEnabledForMachine=0;
                }
                RegCloseKey(hKeyAppMgmt);
                if (dwCSEnabledForMachine)
                {
                    dwCSEnabled=dwCSEnabledForMachine;
                }
            }
        }
        fInitialized = TRUE;
    }

    return dwCSEnabled;
}


/*---------------------------------------------------------------
    Function(s) : DownloadClass

    Synopsis    : Downloads class from the Directory if it exists

    Remarks     : This is an overloaded function. It takes either a filename
                  or a class id as an argument. In either case, it downloads
                  the corresponding class from the Directory

    Arguments   :
        For the ClassID version :
                [clsid] : ClassID of the class that is to be downloaded
        For the filename version :
                [lpwszFileName] : Name of the file that needs to be handled. The file extension is
                                                 used to figure out the class that can handle this file
        Common parameters :
                [dwClsCtx] : Context for object creation
                [dwFlags]   : creation flags

    Return values : S_OK, MK_E_INVALIDEXTENSION, REGDB_E_CLASSNOTREG

    Created by    : RahulTh (11/21/97)
----------------------------------------------------------------*/
HRESULT DownloadClass( LPWSTR lpwszFileName, DWORD dwClsCtx )
{
    DWORD dwCSEnabled = (dwClsCtx & CLSCTX_ENABLE_CODE_DOWNLOAD) ? 1 : CheckDownloadRegistrySettings();

    if (dwCSEnabled)
    {
        INSTALLDATA InstallData;

        InstallData.Type = FILEEXT;
        InstallData.Spec.FileExt = (PWCHAR) FindExt(lpwszFileName);

        if ( ! InstallData.Spec.FileExt )
        {
            return HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        }

        DWORD code = InstallApplication( &InstallData );
        if (code != 0)
        {
            return HRESULT_FROM_WIN32(code);
        }
        else
        {
            return S_OK;
        }
    }

    return CS_E_PACKAGE_NOTFOUND; // this will get mapped to REGDB_E_CLASSNOTREG further up
}

HRESULT DownloadClass( CLSID clsid, DWORD dwClsCtx )
{
    // Determine if class store downloads are enabled
    // If either per-user or per-machine policy requests class store downloads we perform the lookup:
    // If we didn't, we would break per-user or per-machine applications that rely on class store download.

    DWORD dwCSEnabled = (dwClsCtx & CLSCTX_ENABLE_CODE_DOWNLOAD) ? 1 : CheckDownloadRegistrySettings();

    if (dwCSEnabled)
    {
        INSTALLDATA InstallData;

        InstallData.Type = COMCLASS;
        InstallData.Spec.COMClass.Clsid = clsid;
        InstallData.Spec.COMClass.ClsCtx = dwClsCtx;

        DWORD code = InstallApplication( &InstallData );
        if (code != 0)
        {
            return HRESULT_FROM_WIN32(code);
        }
        else
        {
            return S_OK;
        }
    }

    return CS_E_PACKAGE_NOTFOUND; // this will get mapped to REGDB_E_CLASSNOTREG further up
}

//+-------------------------------------------------------------------
//
//  Function:   CoInstall
//
//  Synopsis:   Downloads the specified class.
//
//  Returns:    S_OK, REGDB_E_CLASSNOTREG.
//
//  This routine is called from IE to do app/component downloads from
//  the NT5 Directory.
//
//--------------------------------------------------------------------
STDAPI CoInstall(
    IBindCtx     *pbc,
    DWORD         dwFlags,
    uCLSSPEC     *pClassSpec,
    QUERYCONTEXT *pQuery,
    LPWSTR        pszCodeBase)
{
    INSTALLDATA     InstallData;
    DWORD           Status;

    if ( ! pClassSpec )
        return E_INVALIDARG;

    if ( pClassSpec->tyspec !=  TYSPEC_CLSID )
        return CS_E_PACKAGE_NOTFOUND;

    InstallData.Type = COMCLASS;
    InstallData.Spec.COMClass.Clsid = pClassSpec->tagged_union.clsid;
    InstallData.Spec.COMClass.ClsCtx = pQuery->dwContext;

    Status = InstallApplication( &InstallData );

    if ( Status != ERROR_SUCCESS )
        return HRESULT_FROM_WIN32( Status );
    else
        return S_OK;

    //
    // TDB : How COM+ wants to interact with IE code download.
    //
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\objact.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       objact.cxx
//
//  Contents:   Helper Functions for object activation
//
//  Functions:
//
//  History:    12-May-93 Ricksa    Created
//              31-Dec-93 ErikGav   Chicago port
//              23-Jun-98 CBiks     See RAID# 159589.  Added activation
//                                  flags where appropriate.
//              24-Jul-98 CBiks     Fixed Raid# 19960.
//              21-Oct-98 SteveSw   104665; 197253;
//                                  fix COM+ persistent activation
//
//--------------------------------------------------------------------------

#include <ole2int.h>
#include <iface.h>
#include <objact.hxx>
#include <clsctx.hxx>
#include "resolver.hxx"
#include "smstg.hxx"
#include "events.hxx"
#include <objsrv.h>
#include <utils.h>
#include "dllcache.hxx"
#include <security.hxx>
#include <immact.hxx>

// only for CHECKREFCOUNT which should be moved to a common header
#include <actvator.hxx>

#include "partitions.h"

#if DBG == 1
extern BOOL gAssertOnCreate;
#endif

HRESULT ATHostActivatorGetClassObject(REFIID riid, LPVOID *ppvClassObj);
HRESULT MTHostActivatorGetClassObject(REFIID riid, LPVOID *ppvClassObj);
HRESULT NTHostActivatorGetClassObject(REFIID riid, LPVOID *ppvClassObj);
HINSTANCE g_hComSvcs = NULL;     // module handle of com svcs.

// Add type definition for the get class function of the comsvcs dll.
typedef HRESULT (*InternalGetClass) (REFCLSID, REFIID, LPVOID *);

InternalGetClass ComSvcGetClass;

extern "C" CLSID CLSID_ThumbnailUpdater;

const CLSID guidPartitionProperty = {0xecabaeba, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};


extern "C" HRESULT GetActivationPropertiesIn(
                                            ActivationPropertiesIn *pInActivationProperties,
                                            REFCLSID rclsid,
                                            DWORD dwContext,
                                            COSERVERINFO * pServerInfo,
                                            DWORD cIIDs,
                                            IID *iidArray,
                                            DWORD dwActvFlags,
                                            DLL_INSTANTIATION_PROPERTIES *pdip,
                                            IComClassInfo *pClassInfo);


#define INTERNAL_CLSCTX(clsctx) (clsctx & CLSCTX_PS_DLL)

//+-------------------------------------------------------------------------
//
//  Function:   GetClassInfoFlags
//
//  Synopsis:   Get some useful flags from the class info
//
//  Arguments:  pActIn (in/out) activationproperties object
//
//  Returns:    Flags indicating whether the component is enabled, private or VB debug is in progress
//
//--------------------------------------------------------------------------

void GetClassInfoFlags
(
    ActivationPropertiesIn * i_pActIn, 
    BOOL * o_pfEnabled, 
    BOOL * o_pfPrivate, 
    BOOL * o_pfDebugInProgress
)
{
    HRESULT hr = S_OK;
    IComClassInfo * pIComClassInfo = NULL;
    IComClassInfo2 * pIComClassInfo2 = NULL;

    Win4Assert(i_pActIn);

    // default values
    
    if (o_pfEnabled)
        *o_pfEnabled = TRUE;        // NOTE: important!

    if (o_pfPrivate)
        *o_pfPrivate = FALSE;

    if (o_pfDebugInProgress)
        *o_pfDebugInProgress = FALSE;

    pIComClassInfo = i_pActIn->GetComClassInfo();
    Win4Assert(pIComClassInfo);
    pIComClassInfo->AddRef(); 

    hr = pIComClassInfo->QueryInterface(IID_IComClassInfo2, (void **)&pIComClassInfo2); 

    if (S_OK == hr)
    {
        Win4Assert(pIComClassInfo2);

        if (o_pfEnabled)
            pIComClassInfo2->IsEnabled(o_pfEnabled);
        if (o_pfPrivate)
            pIComClassInfo2->IsPrivateComponent(o_pfPrivate);
        if (o_pfDebugInProgress)
            pIComClassInfo2->VBDebugInProgress(o_pfDebugInProgress);
    }

    pIComClassInfo2->Release();
    pIComClassInfo->Release();

} // GetClassInfoFlags


//+-------------------------------------------------------------------------
//
//  Function:   AddPartitionID
//
//  Synopsis:   Add the partition id from the context property (if available) to the actprops object.
//
//  Arguments:  pActIn (in/out) activationproperties object
//
//  Returns:    none
//
//--------------------------------------------------------------------------

void AddPartitionID(ActivationPropertiesIn *pActIn)
{
	HRESULT hr = S_OK;

	SpecialProperties * pSSP = NULL;

	Win4Assert(pActIn);

	pSSP = pActIn->GetSpecialProperties();
	
	// Don't clean up pSSP, it is not reference counted

	if (NULL == pSSP)	// unexpected, should be there
	{
		Win4Assert(!"GetSpecialProperties");

		return;
	}

	GUID guidPartitionId = GUID_NULL;

	hr = pSSP->GetPartitionId(&guidPartitionId);

	if (S_OK == hr)		// valid case, partition id is already set
		return;								

	// There is no existing partition id on the ActPropsIn, try to get one from context

	CObjectContext * pClientContext = GetCurrentContext();

	// Don't need to release this pClientContext

	if (NULL == pClientContext)		// unexpected, should be there
	{
		Win4Assert(!"GetCurrentContext");

		return;
	}

	IUnknown * punk = NULL;

	CPFLAGS flags;	// not used

	hr  = pClientContext->GetProperty(guidPartitionProperty, &flags, &punk);

	if (NULL == punk)		// valid case, normal case, partition property not on context
		return;

	Win4Assert(S_OK == hr);

	// Found the partition property on the client context

	IPartitionProperty * pPartitionProp = NULL;

	hr = punk->QueryInterface(__uuidof(IPartitionProperty), (void**)&pPartitionProp);

	punk->Release();

	if ((hr != S_OK) || (NULL == pPartitionProp))		// unexpected, must support this interface
	{
		Win4Assert(!"QI for IPartitionProperty");

		return;
	}

	Win4Assert(GUID_NULL == guidPartitionId);

	hr = pPartitionProp->GetPartitionID(&guidPartitionId);

	pPartitionProp->Release();

	Win4Assert(S_OK == hr);

	// Set the partition id on the ActPropsIn

	pSSP->SetPartitionId(guidPartitionId);

} // AddPartitionID

//+-------------------------------------------------------------------------
//
//  Function:   AddHydraSessionID
//
//  Synopsis:   Add the current hydra session to the actprops object if 
//              running in a session; otherwise set it to zero.   Meant to
//              be used early in the activation process to store the client
//              app's session id.
//
//  Arguments:  pActIn (in/out) activationproperties object
//
//  Returns:    none
//
//--------------------------------------------------------------------------

void AddHydraSessionID(ActivationPropertiesIn *pActIn)
{
    SpecialProperties* pSSP = NULL;
    ULONG ulSessionId;
    
    pSSP = pActIn->GetSpecialProperties();
    if (pSSP != NULL)
    {
        HRESULT hr;
        BOOL bUseConsole;
        BOOL bRemoteSessionId = FALSE;

        // If a session moniker has already set this upstream from us, don't
        // overwrite anything.   The session moniker always sets the "remote this
        // session id" flag to TRUE, so we can use that flag to detect this case.
        hr = pSSP->GetSessionId2(&ulSessionId, &bUseConsole, &bRemoteSessionId);
        if (SUCCEEDED(hr) && bRemoteSessionId)
        {
            // return immediately
            return;
        }

        // Ask Hydra what our current session ID is:
        if ( !ProcessIdToSessionId( GetCurrentProcessId(), (DWORD *) &ulSessionId ) )
        {
            // if that failed for any reason, fall back on zero
            ulSessionId = 0;
        }
        
        // Pass in FALSE here since this session id should NOT go off 
        // machine.  Pass in FALSE for bUseConsole since this is an implicit
        // session setting, not explicit.
        pSSP->SetSessionId (ulSessionId, FALSE, FALSE);
        // Don't clean up pSSP, it's not reference counted
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   AddOrigClsCtx
//
//  Synopsis:   Add the the CLSCTX as supplied by the client.
//
//  Arguments:  pActIn (in/out) activationproperties object
//             dwClsCtx (in) CLSCTX as supplied by the client  
//
//  Returns:    none
//
//--------------------------------------------------------------------------

void AddOrigClsCtx(ActivationPropertiesIn *pActIn, DWORD dwClsCtx)
{
    SpecialProperties* pSSP = NULL;
    DWORD dwCurClsCtx = 0;

    pSSP = pActIn->GetSpecialProperties();
    
    if (pSSP != NULL)
    {
        pSSP->GetOrigClsctx(&dwCurClsCtx);

        if(!dwCurClsCtx){
            pSSP->SetOrigClsctx(dwClsCtx);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   GetClassInfoFromClsid
//
//  Synopsis:   Initialize the catalog interface if necessary and query it
//              for a CLSID
//
//
//  Arguments:
//
//  Returns:    S_OK - no errors or inconsistencies found
//
//
//--------------------------------------------------------------------------

HRESULT GetClassInfoFromClsid(REFCLSID rclsid, IComClassInfo **ppClassInfo)
{
    HRESULT hr = InitializeCatalogIfNecessary();
    if ( FAILED(hr) )
    {
        return hr;
    }
    else
    {
        return gpCatalog->GetClassInfo(rclsid,IID_IUnknown,(LPVOID*)ppClassInfo);
    }
}


STDAPI CoGetDefaultContext(APTTYPE aptType, REFIID riid, void** ppv);

//+-------------------------------------------------------------------------
//
//  Function:   GetActivationPropertiesIn
//
//  Synopsis:   Create and initialize an ActivationPropertiesIn
//              object based on the activation parameters
//
//
// Arguments:   [rclsid] - requested CLSID
//              [pServerInfo] - server information block
//              [dwContext] - kind of server required
//              [cIIDs] - count of interface ids
//              [iidArray] - array of interface ids
//              [ppActIn] - ActivationPropertiesIn object returned
//
//  Returns:    S_OK - no errors or inconsistencies found
//
//
//--------------------------------------------------------------------------
extern "C" HRESULT GetActivationPropertiesIn(
                                            ActivationPropertiesIn *pInActivationProperties,
                                            REFCLSID rclsid,
                                            DWORD dwContext,
                                            COSERVERINFO * pServerInfo,
                                            DWORD cIIDs,
                                            IID *iidArray,
                                            DWORD dwActvFlags,
                                            DLL_INSTANTIATION_PROPERTIES *pdip,
                                            IComClassInfo *pClassInfo)
{
    // We may be doing out of proc activation for a class that is not
    // registered so allow it to go through
    HRESULT hr;
    if ( pClassInfo )
    {
        pClassInfo->AddRef();
    }
    else
    {
        hr = GetClassInfoFromClsid(rclsid, &pClassInfo);
        if ( FAILED(hr) && (hr != REGDB_E_CLASSNOTREG) )
            return hr;
    }

    hr = pInActivationProperties->SetClassInfo(pClassInfo);
    if ( FAILED(hr) && (hr != REGDB_E_CLASSNOTREG) )
        return hr;

    pClassInfo->Release();      // pInActivationProperties owns it

    hr = pInActivationProperties->SetClsctx(dwContext);
    if ( FAILED(hr) )
        return hr;

    hr = pInActivationProperties->SetActivationFlags(dwActvFlags);
    if ( FAILED(hr) )
        return hr;

    hr = pInActivationProperties->AddRequestedIIDs(cIIDs,iidArray);
    if ( FAILED(hr) )
        return hr;

    // Figure out what the client context should be.
    BOOL fReleaseClientContext;
    CObjectContext *pClientContext;
    if (dwContext & CLSCTX_FROM_DEFAULT_CONTEXT)
    {        
        hr = CoGetDefaultContext(APTTYPE_CURRENT, IID_IStdObjectContext, (void **)&pClientContext);
        fReleaseClientContext = TRUE;
    }
    else
    {
        fReleaseClientContext = FALSE;
        pClientContext = GetCurrentContext();
        if (NULL == pClientContext)
            hr = CO_E_NOTINITIALIZED;
    }

    if (FAILED(hr))
        return hr;


    // Create prototype context only if there are properties marked
    // PROPAGATE in the client context -- and add them to the prototype
    // context
    CObjectContext *pPrototypeContext = NULL;
    hr = CObjectContext::CreatePrototypeContext(pClientContext,
                                                &pPrototypeContext);
    if ( SUCCEEDED(hr) )
    {
        // Set the client and prototype contexts in the activation properties
        // The prototype context is set to NULL when not needed and is created on demand
        hr = pInActivationProperties->SetContextInfo((IContext*)pClientContext,
                                                     (IContext*)pPrototypeContext);
    }

    if (fReleaseClientContext)
        pClientContext->Release();

    if (pPrototypeContext)
        pPrototypeContext->Release();

    if ( FAILED(hr) )
        return hr;

    if ( pServerInfo )
    {
        SecurityInfo                  * pLegacyInfo = NULL;
        // This special private interface saves us some labor in
        // setting security properties
        pLegacyInfo = pInActivationProperties->GetSecurityInfo();
        Win4Assert(pLegacyInfo != NULL);

        hr = pLegacyInfo->SetCOSERVERINFO(pServerInfo);
        if ( FAILED(hr) )
            return hr;
    }


    //if (pdip)    {

    ActivationPropertiesIn *pActIn;
    hr = pInActivationProperties->QueryInterface(CLSID_ActivationPropertiesIn,
                                                 (void **) &pActIn);

    Win4Assert(!FAILED(hr));

#if DBG == 1
    DLL_INSTANTIATION_PROPERTIES *check_pdip;
    check_pdip = (DLL_INSTANTIATION_PROPERTIES *)pActIn->GetDip();
    Win4Assert(!check_pdip);
#endif
    pActIn->SetDip(pdip);
    //    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   ValidateAndRemapParams
//
//  Synopsis:   Common parameter checking for internal activation APIs
//
//
// Arguments:   [Clsid] - requested CLSID
//              [pServerInfo] - server information block
//              [dwCount] - count of interfaces
//              [pResults] - MULTI_QI struct of interfaces
//
//  Returns:    S_OK - no errors or inconsistencies found
//
//
//--------------------------------------------------------------------------

INTERNAL ValidateAndRemapParams(
                               REFCLSID                    Clsid,
                               DWORD                     & dwClsCtx,
                               COSERVERINFO              * pServerInfo,
                               DWORD                       dwCount,
                               MULTI_QI                  * pResults )
{
    if ( !IsApartmentInitialized() )
        return  CO_E_NOTINITIALIZED;

    HRESULT hr = ValidateCoServerInfo(pServerInfo);
    if ( FAILED(hr) )
    {
        return hr;
    }

    DWORD dwValidMask = CLSCTX_VALID_MASK | CLSCTX_PS_DLL;

    // Make sure input request is at least slightly logical
    if (
       ((dwClsCtx & ~dwValidMask) != 0)
       || ( dwCount < 1 )
       || ( pResults == NULL )
       )
    {
        return E_INVALIDARG;
    }
    // can't ask for both
    if ( (dwClsCtx & CLSCTX_DISABLE_AAA) && (dwClsCtx & CLSCTX_ENABLE_AAA) ) 
    {
       return E_INVALIDARG;
    }
    // check the MULTI_QI for validity (and clear out the hresults)
    for ( UINT i=0; i<dwCount; i++ )
    {
        if ( pResults[i].pItf || !pResults[i].pIID )
        {
            return E_INVALIDARG;
        }
        pResults[i].hr = E_NOINTERFACE;
        Win4Assert (pResults[i].pItf == NULL);
    }

    // Make sure we are asking for the correct inproc server
    dwClsCtx = RemapClassCtxForInProcServer(dwClsCtx);

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IsComsvcsCLSID
//
//  Synopsis:   checks if the given clsid is implemented in COMSVCS.DLL.
//
//  Arguments:  [rclsid] - clsid to look for
//
//  History:    11-18-98    JohnStra      Created
//
//+-------------------------------------------------------------------------
BOOL IsComsvcsCLSID(
    REFCLSID rclsid
    )
{
    // The range of CLSIDs implemented by COMSVCS.DLL is:
    // from: ecabaeb0-7f19-11d2-978e-0000f8757e2a
    // to:   ecabb297-7f19-11d2-978e-0000f8757e2a

    DWORD *ptr = (DWORD *) &rclsid;
    if (*(ptr+1) == 0x11d27f19 &&
        *(ptr+2) == 0x00008e97 &&
        *(ptr+3) == 0x2a7e75f8)
    {
        if (*ptr >= 0xecabaeb0 && *ptr <= 0xecabb297)
        {
            return TRUE;
        }
    }
    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   IsMarshalerCLSID
//
//  Synopsis:   checks if the given clsid implements the marshaler category.
//
//  Arguments:  [rclsid] - clsid to look for
//
//  History:    05-04-00    Sajia         Created
//
//+-------------------------------------------------------------------------
BOOL IsMarshalerCLSID(
    REFCLSID rclsid
    )
{
    const WCHAR *WSZ_IMPLMARSHALERCATID = L"\\Implemented Categories\\{00000003-0000-0000-C000-000000000046}";
    WCHAR szKey[200];
    lstrcpyW(szKey, L"Clsid\\");
    wStringFromGUID2(rclsid,szKey+6,GUIDSTR_MAX);
    lstrcat(szKey, WSZ_IMPLMARSHALERCATID);
    HKEY hKey;
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS) 
    {
       RegCloseKey(hKey);
       return TRUE;
    }
    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   ICoGetClassObject
//
//  Synopsis:   Internal entry point that returns an instantiated class object
//
//  Arguments:  [rclsid] - class id for class object
//              [dwContext] - kind of server we wish
//              [pvReserved] - Reserved
//              [riid] - interface to bind class object
//              [ppvClassObj] - where to put interface pointer
//
//  Returns:    S_OK - successfully bound class object
//
//  Algorithm:  First, the context is validated. Then we try to use
//              any cached information by looking up either cached in
//              process servers or handlers based on the context.
//              If no cached information suffices, we call the SCM
//              to find out what to use. If the SCM returns a handler
//              or an inprocess server, we cache that information.
//              If the class is implemented by a local server, then
//              the class object is unmarshaled. Otherwise, the object
//              is instantiated locally using the returned DLL.
//
//
//  History:    15-Nov-94 Ricksa    Split into external and internal calls
//
//
//--------------------------------------------------------------------------
INTERNAL ICoGetClassObject(
                          REFCLSID rclsid,
                          DWORD dwContext,
                          COSERVERINFO * pServerInfo,
                          REFIID riid,
                          DWORD dwActvFlags,
                          void FAR* FAR* ppvClassObj,
                          ActivationPropertiesIn *pActIn)
{
    TRACECALL(TRACE_ACTIVATION, "CoGetClassObject");
    Win4Assert(gAssertOnCreate && "Assertion Testing");
    CLSID ConfClsid;
    
    MULTI_QI multi_qi = { &riid, NULL, E_NOINTERFACE};
    HRESULT hr = ValidateAndRemapParams(rclsid,dwContext,pServerInfo,1,&multi_qi);
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    
    IUnknown *punk = NULL;
    MInterfacePointer *pIFD = NULL;
    CLSID realclsid = rclsid;
    DWORD dwDllServerModel = 0;
    WCHAR * pwszDllServer = 0;
    int nRetries = 0;
    
    // IsInternalCLSID will also check to determine if the CLSID is
    // an OLE 1.0 CLSID, in which case we get back our internal
    // class factory.
    
    if ( IsInternalCLSID(rclsid, dwContext, riid, hr, ppvClassObj) )
    {
        //  this is an internally implemented clsid, or an OLE 1.0 class
        //  so we already got the class factory (if available) and set
        //  the return code appropriately.
        
    }
    else
    {
        if ((dwContext & CLSCTX_NO_CUSTOM_MARSHAL) && !IsComsvcsCLSID(rclsid)
            && !IsMarshalerCLSID(rclsid))
        {
            // don't allow custom marshalers that do not belong to
            // com services.
            return E_ACCESSDENIED;
        }

        // Remap from a reference clsid to a configured clsid through the catalogs
        hr = LookForConfiguredClsid(rclsid, ConfClsid);
        if (FAILED(hr) && (hr != REGDB_E_CLASSNOTREG))
            goto exit_point;

        // It's OK to pass in GUID_DefaultAppPartition, since 
        // SearchForLoadedClass ignores COM+ classes anyway.
        CClassCache::CDllClassEntry *pDCE = NULL;        
        ACTIVATION_PROPERTIES ap(ConfClsid, 
                                 GUID_DefaultAppPartition, 
                                 riid,
                                 ACTIVATION_PROPERTIES::fDO_NOT_LOAD,
                                 dwContext, 
                                 dwActvFlags, 
                                 0, 
                                 NULL,
                                 (IUnknown **) ppvClassObj);
        
        hr = CClassCache::SearchForLoadedClass(ap, &pDCE);
        if ( SUCCEEDED(hr) )
        {
            if ( *ppvClassObj )
            {
                //
                // an object was found, nothing left to do
                //
                Win4Assert(!pDCE);
            }
            else
                // Check if it's one we need to activate right here
                if (INTERNAL_CLSCTX(dwContext))
                {
                    // This goes to the class cache to actually lookup the DPE and
                    // get the factory                    
                    //
                    // Internal CLSCTX-- Proxy/Stubs are always in the base partition.
                    ACTIVATION_PROPERTIES ap(ConfClsid, 
                                             GUID_DefaultAppPartition,
                                             riid,
                                             0,
                                             dwContext, 
                                             dwActvFlags, 
                                             0, 
                                             NULL,
                                             (IUnknown **) ppvClassObj);
                    hr = CCGetClassObject(ap);
                }
                else
                {
                    //
                    // do COM+ activation
                    //
                    // Allocate In object on stack
                    IActivationPropertiesOut  * pOutActivationProperties = NULL;     // output
                    
                    if (!pActIn)
                    {
                        pActIn=(ActivationPropertiesIn*)
                          _alloca(sizeof(ActivationPropertiesIn));
                        pActIn->ActivationPropertiesIn::ActivationPropertiesIn();
                        pActIn->SetNotDelete(TRUE);
                    }
                    
                    AddHydraSessionID(pActIn);
                    AddPartitionID(pActIn);
                    AddOrigClsCtx(pActIn, dwContext);
                    
                    IID iid = riid;
                    
                    BOOL fRetry = FALSE, fDownloadDone = FALSE, bClassEnabled = TRUE;
                    DWORD relCount = 0;
                    
                    do
                    {                        
                        if ( fRetry )
                        {
                            relCount = pActIn->Release();
                            Win4Assert(relCount==0);
                            
                            pActIn = new ActivationPropertiesIn();
                            
                            if ( pActIn == NULL )
                                return E_OUTOFMEMORY;

                            AddOrigClsCtx(pActIn, dwContext);
                            fRetry = FALSE; // start with the assumption of termination
                        }
                        
                        Win4Assert(pActIn != NULL);

                        IComClassInfo *pCI = NULL;                        
                        DLL_INSTANTIATION_PROPERTIES *pdip;
                        
                        if ( pDCE )
                        {
                            pdip = (DLL_INSTANTIATION_PROPERTIES *)_alloca(sizeof(DLL_INSTANTIATION_PROPERTIES));
                            memset(pdip, 0, sizeof(DLL_INSTANTIATION_PROPERTIES));
                            pdip->_pDCE = pDCE;
                            pCI = pdip->_pDCE->_pClassEntry->_pCI;
                            if ( pCI )
                            {
                                pCI->AddRef();
                            }
                        }
                        else
                        {
                            pdip = NULL;
                        }
                        
                        // croft up an input activation properties object
                        hr = GetActivationPropertiesIn(
                            pActIn,
                            ConfClsid,
                            dwContext,
                            pServerInfo,
                            1,
                            &iid,
                            dwActvFlags,
                            pdip,
                            pCI);
                        
                        
                        if(SUCCEEDED(hr))
                        {
                            HRESULT TempHR; //This is here because it is OK to fail and we use hr later
                            IComClassInfo2 *pCI2 = NULL;
                            
                            if(!pCI)
                            {
                                pCI = pActIn->GetComClassInfo();
                                Win4Assert(pCI != NULL);
                                pCI->AddRef(); 
                            }
                            
                            TempHR = pCI->QueryInterface(IID_IComClassInfo2, (void **)&pCI2); 
                            if(SUCCEEDED(TempHR))
                            {
                                pCI2->IsEnabled(&bClassEnabled);
                                pCI2->Release();
                            }
                        }
                        
                        if ( pCI )
                        {
                            pCI->Release();
                            pCI = NULL;
                        }
                        
                        
                        if ( FAILED(hr) )
                        {
                            
                            pActIn->Release();      
                            goto exit_point;
                        }
                        
                        if(bClassEnabled == FALSE)
                        {
                            pActIn->Release(); 
                            hr = CO_E_CLASS_DISABLED; 
                            goto exit_point; 
                        }
RETRY_ACTIVATION:                   
                        IActivationStageInfo *pStageInfo = (IActivationStageInfo*) pActIn;
                        
                        // Start off activation at the beginning of client context stage
                        hr = pStageInfo->SetStageAndIndex(CLIENT_CONTEXT_STAGE,0);
                        CHECK_HRESULT(hr);
                        
                        // This is the whole activation process
                        hr = pActIn->DelegateGetClassObject(&pOutActivationProperties);
                        // If the delegated activation returns ERROR_RETRY,
                        // we walk the chain again, but AT MOST ONCE.
                        // This is to support the private activations.
                        if (ERROR_RETRY == hr) 
                        {
                            Win4Assert(!nRetries);
                            if (!nRetries)
                            {
                                BOOL fEnabled = TRUE;

                                GetClassInfoFlags(pActIn, &fEnabled, NULL, NULL);
                                             
                                if (!fEnabled)
                                {   
                                    hr = CO_E_CLASS_DISABLED;
                                    pActIn->Release();      
                                    goto exit_point;
                                }

                                nRetries++;
                                goto RETRY_ACTIVATION;
                            }
                        }
                        
#ifdef DIRECTORY_SERVICE
                        
                        if ( FAILED(hr) && !(dwContext & CLSCTX_NO_CODE_DOWNLOAD) )
                        {
                            //download class if not registered locally -- but only once!
                            if ( (REGDB_E_CLASSNOTREG == hr) && !fDownloadDone )
                            {
                                //if successful, this will add a darwin id to the registry
                                hr = DownloadClass(realclsid,dwContext);
                                fDownloadDone = fRetry = SUCCEEDED(hr);
                            }
                            
                            if ( hr == CS_E_PACKAGE_NOTFOUND )
                            {
                                hr = REGDB_E_CLASSNOTREG;
                            }                            
                        }
#endif //DIRECTORY_SERVICE
                        
                        
                } while ( fRetry );
                
                
                if ( hr == S_OK )
                {
                    Win4Assert(pOutActivationProperties != NULL);
                    if (pOutActivationProperties == NULL)
                    {
                        hr = E_UNEXPECTED;
                    }
                    else
                    {
                        MULTI_QI mqi;
                        mqi.hr = S_OK;
                        mqi.pIID = &riid;
                        mqi.pItf = NULL;
                        hr = pOutActivationProperties->GetObjectInterfaces(1, dwActvFlags, &mqi);
                        if ( SUCCEEDED(hr) )
                        {
                            *ppvClassObj = mqi.pItf;
                            hr = mqi.hr;
                        }
                    }
                }
                
                if ( pOutActivationProperties )
                {
                    relCount = pOutActivationProperties->Release();
                    Win4Assert(relCount==0);
                }
                
                // Since doing an alloca, must release in after out
                // since actout may be contained by actin for
                // performance optimization
                relCount = pActIn->Release();
                Win4Assert(relCount==0);
                
                if ( pDCE )
                {
                    LOCK(CClassCache::_mxs);
                    pDCE->Unlock();
                    UNLOCK(CClassCache::_mxs);
                }
            }
        }
    }
exit_point:
    
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   LookForConfiguredClsid
//
//  Synopsis:   Internal mapper to find a ConfClsid given a RefClsid
//
//  Arguments:  [RefClsid] - Reference classid to map
//              [rFoundConfClsid] - Configured clsid found in catalogs
//
//  Returns:    S_OK - Successfully mapped clsid to configured clsid
//
//              S_FALSE - Didn't find catalog entry for clsid, confclsid is
//                        the same as the refclsid
//
//  Algorithm:  Simply look in the catalogs for the given clsid. The catalogs
//              will do all the heavy-lifting to find this clsid in their lists
//              When a victim^Wmatch is found, we ask for its configured clsid
//              that will be used to look this clsid up in all other instances.
//
//  History:    02-Jun-02 Jonwis      Created
//
//--------------------------------------------------------------------------
HRESULT
LookForConfiguredClsid(
    REFCLSID    RefClsid,
    CLSID      &rFoundConfClsid
    )
{
    IComClassInfo *pFoundClassInfo = NULL;
    HRESULT hr;
    
    hr = GetClassInfoFromClsid(RefClsid, &pFoundClassInfo);
    
    if (FAILED(hr))
    {
        rFoundConfClsid = RefClsid;
        hr = S_FALSE;
    }
    else
    {
        GUID *pConfiguredGuid = NULL;
        if (SUCCEEDED(hr = pFoundClassInfo->GetConfiguredClsid(&pConfiguredGuid)))
        {
            if (pConfiguredGuid != NULL)
            {
                rFoundConfClsid = *pConfiguredGuid;
                hr = S_OK;
            }
            else
            {
                rFoundConfClsid = RefClsid;
                hr = S_FALSE;
            }
        }
        pFoundClassInfo->Release();
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ICoCreateInstanceEx
//
//  Synopsis:   Internal version of CoCreateInstance
//
//
// Arguments:   [Clsid] - requested CLSID
//              [pServerInfo] - server information block
//              [punkOuter] - controlling unknown for aggregating
//              [dwCtrl] - kind of server required
//              [dwCount] - count of interfaces
//              [dwActvFlags] - activation flags
//              [pResults] - MULTI_QI struct of interfaces
//
//  Returns:    S_OK - object bound successfully
//
//
//--------------------------------------------------------------------------
INTERNAL ICoCreateInstanceEx(
                            REFCLSID                    Clsid,
                            IUnknown    *               punkOuter, // only relevant locally
                            DWORD                       dwClsCtx,
                            COSERVERINFO *              pServerInfo,
                            DWORD                       dwCount,
                            DWORD                       dwActvFlags,
                            MULTI_QI        *           pResults,
                          ActivationPropertiesIn *pActIn )
{
    int nRetries = 0;
    TRACECALL(TRACE_ACTIVATION, "CoCreateInstanceEx");
    Win4Assert(gAssertOnCreate && "Assertion Testing");
    CLSID ConfClsid;
    
    HRESULT hrSave = E_FAIL;
    HRESULT hr = ValidateAndRemapParams(Clsid,dwClsCtx,pServerInfo,dwCount,pResults);
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    // an OLE 1.0 CLSID, in which case we get back our internal
    // class factory.
    
    IClassFactory *pcf = NULL;
    
    if (IsInternalCLSID(Clsid, dwClsCtx, IID_IClassFactory, hr, (void **)&pcf))
    {
        // this is an internally implemented clsid, or an OLE 1.0 class
        // so we already got the class factory (if available) and set
        // the return code appropriately.
        
        // get the interfaces
        if ( SUCCEEDED(hr) && pcf )
        {
            hr = hrSave = CreateInprocInstanceHelper(pcf,
                dwActvFlags,
                punkOuter,
                dwCount,
                pResults);
        }
    }
    else
    {
        // The class is not internal. If the CLSCTX_NO_CUSTOM_MARSHAL flag is set
        // return E_ACCESSDENIED.
        
        if ((dwClsCtx & CLSCTX_NO_CUSTOM_MARSHAL) && !IsComsvcsCLSID(Clsid)
            && !IsMarshalerCLSID(Clsid))
        {
            // don't allow custom marshalers that do not belong to
            // com services.
            return E_ACCESSDENIED;
        }
        
        // Look in our catalogs for a mapping for this clsid to a configured clsid,
        // since we store configured clsids in our class caching table. Don't fail if
        // we couldn't do the mapping.
        hr = LookForConfiguredClsid(Clsid, ConfClsid);
        if (FAILED(hr) && (hr != REGDB_E_CLASSNOTREG))
            goto exit_point;
        
        // It's OK to pass in GUID_DefaultAppPartition, since 
        // SearchForLoadedClass ignores COM+ classes anyway.
        CClassCache::CDllClassEntry *pDCE = NULL;
        ACTIVATION_PROPERTIES ap(ConfClsid, 
                                 GUID_DefaultAppPartition,
                                 IID_IClassFactory,
                                 ACTIVATION_PROPERTIES::fDO_NOT_LOAD,
                                 dwClsCtx, 
                                 dwActvFlags, 
                                 0, 
                                 NULL,
                                 (IUnknown **) &pcf);        
        
        hr = CClassCache::SearchForLoadedClass(ap, &pDCE);
        if ( SUCCEEDED(hr) )
        {
            // Check if it's one we need to activate right here
            if ((!pcf) && INTERNAL_CLSCTX(dwClsCtx))
            {
                // This goes to the class cache to actually lookup the DPE and
                // get the factory
                //
                // Proxy/Stubs are never partitioned.
                ACTIVATION_PROPERTIES ap(ConfClsid, 
                                         GUID_DefaultAppPartition,
                                         IID_IClassFactory,
                                         0,
                                         dwClsCtx, 
                                         dwActvFlags, 
                                         0, 
                                         NULL,
                                         (IUnknown **) &pcf);
                hr = hrSave = CCGetClassObject(ap);
                if (FAILED(hr))
                    goto exit_point;
            }
            
            if (pcf)
            {
                //
                // an object was found get the interfaces
                //
                Win4Assert(!pDCE);
                hr = hrSave = CreateInprocInstanceHelper(pcf,
                                                         dwActvFlags,
                                                         punkOuter,
                                                         dwCount,
                                                         pResults);
            }
            else
            {
                
                //
                // do COM+ activation
                //
                
                // Initialize activation properties
                // Allocate In on stack
                IActivationPropertiesOut  * pOutActivationProperties = NULL;     // output
                if (!pActIn)
                {
                    pActIn=(ActivationPropertiesIn*)
                        _alloca(sizeof(ActivationPropertiesIn));
                    pActIn->ActivationPropertiesIn::ActivationPropertiesIn();
                    pActIn->SetNotDelete(TRUE);
                }
                
                AddHydraSessionID(pActIn);                
                AddPartitionID(pActIn);
                AddOrigClsCtx(pActIn, dwClsCtx);
                
                // split the array of structs into individual arrays
                CSplit_QI    SplitQI( hr, dwCount, pResults );
                
                if ( FAILED(hr) )
                    goto exit_point;
                
                DLL_INSTANTIATION_PROPERTIES *pdip;
                IComClassInfo *pCI = NULL;
                
                if ( pDCE )
                {
                    pdip = (DLL_INSTANTIATION_PROPERTIES *)
                        _alloca(sizeof(DLL_INSTANTIATION_PROPERTIES));
                    pdip->_pDCE = pDCE;
                    pCI = pdip->_pDCE->_pClassEntry->_pCI;
                    if ( pCI )
                    {
                        pCI->AddRef();
                    }
                }
                else
                {
                    pdip = NULL;
                }
                
                BOOL fRetry=FALSE, fDownloadDone = FALSE, bClassEnabled = TRUE;
                DWORD relCount = 0;
                
                do
                {
                    if ( fRetry )
                    {
                        DWORD relCount = pActIn->Release();
                        Win4Assert(relCount==0);
                        
                        pActIn = new ActivationPropertiesIn;
                        
                        if ( pActIn == NULL )
                            return E_OUTOFMEMORY;

                        AddOrigClsCtx(pActIn, dwClsCtx);
                            
                        fRetry = FALSE; // start with the assumption of termination
                    }
                    
                    Win4Assert(pActIn != NULL);
                    
                    hr = GetActivationPropertiesIn(
                        pActIn,
                        ConfClsid,
                        dwClsCtx,
                        pServerInfo,
                        dwCount,
                        SplitQI._pIIDArray,
                        dwActvFlags,
                        pdip,
                        pCI);
                    
                    if(SUCCEEDED(hr))
                    {
                        HRESULT TempHR; //This is here because it is OK to fail and we use hr later
                        IComClassInfo2 *pCI2 = NULL;
                        
                        if(!pCI)
                        {
                            pCI = pActIn->GetComClassInfo();
                            Win4Assert(pCI != NULL);
                            pCI->AddRef(); 
                        }
                        
                        TempHR = pCI->QueryInterface(IID_IComClassInfo2, (void **)&pCI2); 
                        if(SUCCEEDED(TempHR))
                        {
                            pCI2->IsEnabled(&bClassEnabled);
                            pCI2->Release();
                        }
                    }
                    
                    if ( pCI )
                    {
                        pCI->Release();
                        pCI = NULL;
                    }
                    
                    
                    
                    if ( FAILED(hr) )
                    {
                        
                        pActIn->Release();      
                        goto exit_point;
                    }
                    
                    if(bClassEnabled == FALSE)
                    {
                        pActIn->Release(); 
                        hr = CO_E_CLASS_DISABLED; 
                        goto exit_point; 
                    }
RETRY_ACTIVATION:                   
                    IActivationStageInfo *pStageInfo = (IActivationStageInfo*) pActIn;
                    
                    // Start off activation at the beginning of client context stage
                    hr = pStageInfo->SetStageAndIndex(CLIENT_CONTEXT_STAGE,0);
                    if (FAILED (hr))
                    {
                        pActIn->Release();      
                        goto exit_point;
                    }
                    
                    // This is the whole activation process
                    hr = hrSave = pActIn->DelegateCreateInstance(
                        punkOuter,
                        &pOutActivationProperties);
                    
                    // If the delegated activation returns ERROR_RETRY,
                    // we walk the chain again, but AT MOST ONCE.
                    // This is to support the private activations.
                    if (ERROR_RETRY == hr) 
                    {
                        Win4Assert(!nRetries);
                        if (!nRetries)
                        {
                            BOOL fEnabled = TRUE;

                            GetClassInfoFlags(pActIn, &fEnabled, NULL, NULL);
                                         
                            if (!fEnabled)
                            {   
                                hr = CO_E_CLASS_DISABLED;
                                pActIn->Release();      
                                goto exit_point;
                            }
                    
                            nRetries++;
                            goto RETRY_ACTIVATION;
                        }
                    }
                    
#ifdef DIRECTORY_SERVICE
                    
                    if ( FAILED(hr) && !(dwClsCtx & CLSCTX_NO_CODE_DOWNLOAD) )
                    {
                        //download class if not registered locally -- but only once!
                        if ( (REGDB_E_CLASSNOTREG == hr) && !fDownloadDone )
                        {
                            //if successful, this will add a darwin id to the registry
                            hr = DownloadClass(Clsid,dwClsCtx);
                            fDownloadDone = fRetry = SUCCEEDED(hr);
                        }
                        
                        if ( hr == CS_E_PACKAGE_NOTFOUND )
                        {
                            hr = REGDB_E_CLASSNOTREG;
                        }                        
                    }
#endif //DIRECTORY_SERVICE
                    
                    
                } while ( fRetry );
                
                
                if ( SUCCEEDED(hr) )
                {
                    Win4Assert(pOutActivationProperties != NULL);
                    if (pOutActivationProperties == NULL)
                    {
                        hr = E_UNEXPECTED;
                    }
                    else
                    {
                        hr = pOutActivationProperties->GetObjectInterfaces(dwCount,
                                                                           dwActvFlags,
                                                                           pResults);
                    }
                }
                
                if ( pOutActivationProperties )
                {
                    relCount = pOutActivationProperties->Release();
                    Win4Assert(relCount==0);
                }
                
                
                // Since doing an alloca, must release in after out
                // since actout may be contained by actin for
                // performance optimization
                relCount = pActIn->Release();
                Win4Assert(relCount==0);
                
                if ( pDCE )
                {
                    LOCK(CClassCache::_mxs);
                    pDCE->Unlock();
                    UNLOCK(CClassCache::_mxs);
                }
            }
        }
    }
    
exit_point:
    
    if ( pcf != NULL )
    {
        pcf->Release();
    }

    //
    // hrSave is the result of the entire activation chain, hr is the
    // result of any work done after the activation (unmarshalling the
    // interfaces, etc).  If hr succeeded, then we want to update the
    // MULTI_QI array with the result of the actual activation, not the
    // rest.  If hr failed, then we want to use it regardless of the value
    // of hrSave.
    //
    if (SUCCEEDED(hr))
        hr = hrSave;

    hr = UpdateResultsArray( hr, dwCount, pResults );
    
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateInprocInstanceHelper
//
//  Synopsis:   Uses the supplied class factory to create instances
//              of multiple interfaces on an inproc server
//
//
// Arguments:   [pcf] - class factory object. this ALWAYS gets released
//                      if you call this function
//              [fX86Caller] - TRUE if caller is WX86
//              [punkOuter] - controlling unknown for aggregating
//              [pResults] - MULTI_QI struct of interfaces
//
//  Returns:    S_OK - if results array was successfully updated
//
//
//--------------------------------------------------------------------------
HRESULT CreateInprocInstanceHelper(
                                  IClassFactory* pcf,
                                  DWORD          dwActvFlags,
                                  IUnknown*      pUnkOuter,
                                  DWORD          dwCount,
                                  MULTI_QI*      pResults)
{
#ifdef WX86OLE
    // If we are calling through the wx86 thunk layer then set a
    // flag that to let it know that ole32 is calling and let any
    // custom interface that was specified for an out parameter to
    // x86 code via an api be thunked as IUnknown since we know it
    // will just be returned back to x86 code.
    BOOL fX86Caller = (dwActvFlags & ACTVFLAGS_WX86_CALLER) && gcwx86.IsN2XProxy(pcf);
    if ( fX86Caller )
    {
        gcwx86.SetStubInvokeFlag((UCHAR)-1);
    }
#endif
    IUnknown * pUnk;
    HRESULT hr;

    // ask for the first interface (we'll use it as our IUnknown)
    hr = pcf->CreateInstance(pUnkOuter, *(pResults[0].pIID), (void**)&pUnk);

    if ( FAILED(hr) )
    {
        return hr;
    }

    // assign the first interface, then get the rest
    pResults[0].pItf = pUnk;
    pResults[0].hr   = S_OK;

    for ( DWORD i=1; i<dwCount; i++ )
    {
#ifdef WX86OLE
        // If we are calling through the wx86 thunk layer then set a
        // flag that to let it know that ole32 is calling and let any
        // custom interface that was specified for an out parameter to
        // x86 code via an api be thunked as IUnknown since we know it
        // will just be returned back to x86 code.
        if ( fX86Caller )
        {
            gcwx86.SetStubInvokeFlag((UCHAR)-1);
        }
#endif
        pResults[i].hr = pUnk->QueryInterface( *(pResults[i].pIID),
                                               (void**)&pResults[i].pItf );
    }

    // rely on the UpdateResultsArray to count up failed QI's

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetObjectHelperMulti
//
//  Synopsis:   Creates an object in a persistent state
//
//  Arguments:  [pcf] - class factory
//              [grfMode] - mode to use when loading file
//              [pwszName] - file path to persistent storage
//              [pstg] - storage for persistent storage
//              [ppvUnk] - pointer to IUnknown
//
//  Returns:    S_OK - object successfully instantiated
//
//  Algorithm:  Create an empty instance of the object and then use
//              either the provided storage or file to load the object.
//
//  History:    12-May-93 Ricksa    Created
//
//  Notes:      This helper is called by by servers and clients
//
//--------------------------------------------------------------------------
HRESULT GetObjectHelperMulti(
                            IClassFactory *pcf,
                            DWORD grfMode,
                            IUnknown * punkOuter,
                            WCHAR *pwszName,
                            IStorage *pstg,
                            DWORD dwInterfaces,
                            IID * pIIDs,
                            MInterfacePointer **ppIFDArray,
                            HRESULT * pResultsArray,
                            MULTI_QI *pResults ,
                            CDestObject *pDestObj)
{
    TRACECALL(TRACE_ACTIVATION, "GetObjectHelperMulti");

    XIUnknown xunk;

    // Get the controlling unknown for the instance.
    HRESULT hr = pcf->CreateInstance(punkOuter, IID_IUnknown, (void **) &xunk);

    // This shouldn't fail but it is untrusted code ...
    if ( FAILED(hr) )
    {
        return hr;
    }

    // We put all these safe interface classes in the outer block because
    // we might be in the VDM where some classes will release
    // themselves at ref counts greater than one. Therefore, we avoid
    // releases at all costs.
    XIPersistStorage xipstg;
    XIPersistFile xipfile;

    // This is the case that the class requested is a DLL
    if ( pstg )
    {
        // Load the storage requested as an template
        hr = xunk->QueryInterface(IID_IPersistStorage, (void **) &xipstg);

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = xipstg->Load(pstg);

        if ( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        hr = xunk->QueryInterface(IID_IPersistFile, (void **) &xipfile);

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = xipfile->Load(pwszName, grfMode);

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    // If an interface buffer was passed in, then this is a remote call
    // and we need to marshal the interface.
    if ( ppIFDArray )
    {
        // AddRef the pointer because MarshalHelper expects to release
        // pointer. Because MarshalHelper is called from two other places,
        // we do an AddRef here instead of moving the AddRef out of
        // MarshalHelper.
        xunk->AddRef();
        hr = MarshalHelperMulti(xunk, dwInterfaces, pIIDs, ppIFDArray, pResultsArray,
                                pDestObj);
    }
    else
    {
        // This is an inprocess server so we need to return the output
        // punk
        HRESULT hr2;

        for ( DWORD i=0; i<dwInterfaces; i++ )
        {
            hr2 = xunk->QueryInterface( *(pResults[i].pIID),
                                        (void**)&pResults[i].pItf );

            pResults[i].hr = hr2;

        }
        // rely on the caller to count up the failed QI's
        return S_OK;

    }

    return hr;
}


HRESULT GetInstanceHelper(
                         COSERVERINFO *              pServerInfo,
                         CLSID       *               pclsidOverride,
                         IUnknown    *               punkOuter, // only relevant locally
                         DWORD                       dwClsCtx,
                         DWORD                       grfMode,
                         OLECHAR *                   pwszName,
                         struct IStorage *           pstg,
                         DWORD                       dwCount,
                         MULTI_QI        *           pResults,
                         ActivationPropertiesIn      *pActIn )
{
    IUnknown*       punk            = NULL;
    IClassFactory*  pcf             = NULL;
    HRESULT         hr              = E_FAIL;
    BOOL            fExitBlock;
    DWORD           i;              // handy iterator
    DWORD           dwDllServerModel = 0;
    CLSID           clsid;
    HRESULT         hrSave          = E_FAIL;
    WCHAR*          pwszDllServer   = 0;
    
    int nRetries = 0;
#ifdef DFSACTIVATION
    BOOL        bFileWasOpened = FALSE;
#endif
    
    if ( (pwszName == NULL) && (pstg == NULL) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = ValidateAndRemapParams(clsid,dwClsCtx,pServerInfo,dwCount,pResults);
    }
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    DWORD actvflags = CComActivator::GetActvFlags(dwClsCtx);
    
    if ( pwszName )
    {
        // Limit on loops for retrying to get class of object
        DWORD cGetClassRetries = 0;
        
        // We loop here looking for either the running object or
        // for the class of the file. We do this because there
        // are race conditions where the can be starting or stopping
        // and the class of the object might not be available because
        // of the opening mode of the object's server.
        do
        {
            // Look in the ROT first to see if we need to bother
            // looking up the class of the file.
            
            hr = GetObjectFromRotByPath(pwszName,(IUnknown **) &punk);
            if ( S_OK == hr )
            {
                // Got object from ROT so we are done.
                goto qiexit_point;
            }
            
            // Try to get the class of the file
            if ( pclsidOverride != NULL )
            {
                clsid = *pclsidOverride;
                hr = S_OK;
            }
            else
            {
                hr = GetClassFile(pwszName, &clsid);
#ifdef DIRECTORY_SERVICE
                /*
                If class is not found locally and code download is permitted, download the class from the directory and
                try GetClassFile again.
                
                  - added by RahulTh (11/21/97)
                */
                if ( !(dwClsCtx & CLSCTX_NO_CODE_DOWNLOAD) &&
                    ResultFromScode (MK_E_INVALIDEXTENSION) == hr )
                {
                    dwClsCtx &= ~CLSCTX_NO_CODE_DOWNLOAD;
                    hr = DownloadClass(pwszName,dwClsCtx);
                    if ( hr == CS_E_PACKAGE_NOTFOUND )
                    {
                        hr = REGDB_E_CLASSNOTREG;
                    }
                    if ( SUCCEEDED(hr) )
                    {
                        hr = GetClassFile(pwszName, &clsid);
                    }
                }
#endif //DIRECTORY_SERVICE
#ifdef DFSACTIVATION
                bFileWasOpened = TRUE;
#endif
            }
            
            if ( hr == STG_E_ACCESSDENIED )
            {
                // The point here of the sleep is to try to let the
                // operation that is holding the class id unavailable
                // complete.
                Sleep(GET_CLASS_RETRY_SLEEP_MS);
                continue;
            }
            
            // Either we succeeded or something other than error
            // access denied occurred here. For all these cases
            // we break the loop.
            break;
            
        } while ( cGetClassRetries++ < GET_CLASS_RETRY_MAX );
        
        if ( FAILED(hr) )
        {
            // If we were unable to determine the classid, and the
            // caller provided one as a Ole1 clsid, try loading it
            // If it succeeds, then return
            
            if ( pclsidOverride != NULL )
            {
                goto dde_exit;
            }
            
            goto final_exit;
        }
    }
    
    CLSID       tmpClsid;
    
    hr = OleGetAutoConvert(clsid, &tmpClsid);
    if ( ( hr == REGDB_E_KEYMISSING ) || ( hr == REGDB_E_CLASSNOTREG ) )
    {
        // do nothing
        
    }
    else if ( FAILED(hr) )
    {
        goto exit_point;
    }
    else
    {
        clsid = tmpClsid;
    }
    
    hr = CCGetTreatAs(clsid, clsid);
    if ( FAILED(hr) )
    {
        goto exit_point;
    }
    
    //
    // If this is a OLE 1.0 class, then do a DdeBindToObject on it,
    // and return.
    //
    if ( CoIsOle1Class(clsid) )
    {
        if ( pwszName != NULL )
        {
            goto dde_exit;
        }
        else
        {
            //
            // Something is fishy here. We don't have a pwszName,
            // yet CoIsOle1Class returned the class as an ole1 class.
            // To get to this point without a pwszName, there must have
            // been a pstg passed into the API.
            //
            // This isn't supposed to happen. To recover, just fall
            // through and load the class as an OLE 2.0 class
            //
            CairoleDebugOut((DEB_ERROR,
                "CoIsOle1Class is TRUE on a storage!\n"));
        }
    }
    
    // At this point, we know the clsid we want to activate
    
    {
        // SearchForLoadedClass ignores COM+....
        CClassCache::CDllClassEntry *pDCE = NULL;
        ACTIVATION_PROPERTIES ap(clsid, 
                                 GUID_DefaultAppPartition,
                                 IID_IClassFactory,
                                 ACTIVATION_PROPERTIES::fDO_NOT_LOAD,
                                 dwClsCtx, 
                                 actvflags, 
                                 0, 
                                 NULL,
                                 (IUnknown **) &pcf);
        
        hr = CClassCache::SearchForLoadedClass(ap, &pDCE);
        if ( !SUCCEEDED(hr) )
        {
            goto final_exit;
        }
        else if ( pcf )
        {
            // Create the instance and do the qi's
            Win4Assert(!pDCE);
            hr = GetObjectHelperMulti( pcf,
                grfMode,
                punkOuter,
                pwszName,
                pstg,
                dwCount,
                NULL,
                NULL,
                NULL,
                pResults ,
                NULL);
            
        }
        else
        {
            //
            // do COM+ activation
            //
            
            // Initialize activation properties
            // Allocate In on stack
            
            // split the array of structs into individual arrays
            CSplit_QI    SplitQI( hr, dwCount, pResults );
            
            IActivationPropertiesOut* pOutActivationProperties=0;   // output
            if (!pActIn)
            {
                pActIn=(ActivationPropertiesIn*)
                    _alloca(sizeof(ActivationPropertiesIn));
                pActIn->ActivationPropertiesIn::ActivationPropertiesIn();
                pActIn->SetNotDelete(TRUE);
            }
            
            AddHydraSessionID(pActIn);
            
            AddPartitionID(pActIn);
            
            if ( FAILED(hr) )
                goto exit_point;
            
            DLL_INSTANTIATION_PROPERTIES *pdip;
            IComClassInfo *pCI = NULL;
            
            if ( pDCE )
            {
                pdip = (DLL_INSTANTIATION_PROPERTIES *)
                    _alloca(sizeof(DLL_INSTANTIATION_PROPERTIES));
                pdip->_pDCE = pDCE;
                pCI = pdip->_pDCE->_pClassEntry->_pCI;
                if ( pCI )
                {
                    pCI->AddRef();
                }
            }
            else
            {
                pdip = NULL;
            }
            
            BOOL fRetry=FALSE, fDownloadDone = FALSE, bClassEnabled = TRUE;
            DWORD relCount = 0;
            
            do
            {
                if ( fRetry )
                {
                    relCount = pActIn->Release();
                    Win4Assert(relCount==0);
                    
                    pActIn = new ActivationPropertiesIn;
                    if ( pActIn == NULL )
                        return E_OUTOFMEMORY;
                    fRetry = FALSE; // start with the assumption of termination
                }
                
                Win4Assert(pActIn != NULL);
                
                hr = GetActivationPropertiesIn(
                    pActIn,
                    clsid,
                    dwClsCtx,
                    pServerInfo,
                    dwCount,
                    SplitQI._pIIDArray,
                    actvflags,
                    pdip,
                    pCI);
                
                
                if(SUCCEEDED(hr))
                {
                    HRESULT TempHR; //This is here because it is OK to fail and we use hr later
                    IComClassInfo2 *pCI2 = NULL;
                    
                    if(!pCI)
                    {
                        pCI = pActIn->GetComClassInfo();
                        Win4Assert(pCI != NULL);
                        pCI->AddRef(); 
                    }
                    
                    TempHR = pCI->QueryInterface(IID_IComClassInfo2, (void **)&pCI2); 
                    if(SUCCEEDED(TempHR))
                    {
                        pCI2->IsEnabled(&bClassEnabled);
                        pCI2->Release();
                    }
                }
                
                if ( pCI )
                {
                    pCI->Release();
                    pCI = NULL;
                }
                
                
                
                if ( FAILED(hr) )
                {
                    pActIn->Release();      
                    goto exit_point;
                }
                
                if(bClassEnabled == FALSE)
                {
                    pActIn->Release(); 
                    hr = CO_E_CLASS_DISABLED;
                    goto exit_point;
                }
                
                
                // Tell about the remote activation
                InstanceInfo *pInstanceInfo = pActIn->GetPersistInfo();
                pInstanceInfo->SetStorage(pstg);
                pInstanceInfo->SetFile(pwszName, grfMode);
                
RETRY_ACTIVATION:                   
                // Start off activation at the beginning of client context stage
                IActivationStageInfo *pStageInfo = (IActivationStageInfo*) pActIn;
                hr = pStageInfo->SetStageAndIndex(CLIENT_CONTEXT_STAGE,0);
                if (FAILED (hr))
                {
                    pActIn->Release();      
                    goto exit_point;
                }
                    
                
                // This is the whole activation process
                hr = hrSave = pActIn->DelegateCreateInstance(punkOuter,
                    &pOutActivationProperties);
                
                // If the delegated activation returns ERROR_RETRY,
                // we walk the chain again, but AT MOST ONCE.
                // This is to support the private activations.
                if (ERROR_RETRY == hr) 
                {
                    Win4Assert(!nRetries);
                    if (!nRetries)
                    {
                        BOOL fEnabled = TRUE;

                        GetClassInfoFlags(pActIn, &fEnabled, NULL, NULL);
                                     
                        if (!fEnabled)
                        {   
                            hr = CO_E_CLASS_DISABLED;
                            pActIn->Release();      
                            goto exit_point;
                        }
                
                        nRetries++;
                        goto RETRY_ACTIVATION;
                    }
                }
                
#ifdef DIRECTORY_SERVICE
                
                if ( FAILED(hr) && !(dwClsCtx & CLSCTX_NO_CODE_DOWNLOAD) )
                {
                    //download class if not registered locally -- but only once!
                    if ( (REGDB_E_CLASSNOTREG == hr) && !fDownloadDone )
                    {
                        //if successful, this will add a darwin id to the registry
                        hr = DownloadClass(clsid,dwClsCtx);
                        fDownloadDone = fRetry = SUCCEEDED(hr);
                    }
                    
                    if ( hr == CS_E_PACKAGE_NOTFOUND )
                    {
                        hr = REGDB_E_CLASSNOTREG;
                    }                    
                }
#endif //DIRECTORY_SERVICE
                
                
            } while ( fRetry );
            
            
            
            if ( SUCCEEDED(hr) )
            {
                Win4Assert(pOutActivationProperties != NULL);
                if (pOutActivationProperties == NULL)
                {
                    hr = E_UNEXPECTED;
                }
                else
                {
                    hr = pOutActivationProperties->GetObjectInterfaces(dwCount,
                        actvflags,
                        pResults);
                }
            }
            
            if ( pOutActivationProperties )
            {
                relCount = pOutActivationProperties->Release();
                Win4Assert(relCount==0);
            }
            
            
            // Since doing an alloca, must release in after out
            // since actout may be contained by actin for
            // performance optimization
            relCount = pActIn->Release();
            Win4Assert(relCount==0);
            
            if ( pDCE )
            {
                LOCK(CClassCache::_mxs);
                pDCE->Unlock();
                UNLOCK(CClassCache::_mxs);
            }
        }
    }
    
exit_point:
    
    hr = UpdateResultsArray( hr, dwCount, pResults );
    
final_exit:
    
    if ( pcf != NULL)
    {
        pcf->Release();
    }
    
    return hr;
    
dde_exit:
    
    if ( hr != MK_E_CANTOPENFILE )
    {
        COleTls Tls;
        if ( Tls->dwFlags & OLETLS_DISABLE_OLE1DDE )
        {
            // If this app doesn't want or can tolerate having a DDE
            // window then currently it can't use OLE1 classes because
            // they are implemented using DDE windows.
            //
            hr = CO_E_OLE1DDE_DISABLED;
            goto final_exit;
        }
        
        hr = DdeBindToObject(pwszName,
            clsid,
            FALSE,
            IID_IUnknown,
            (void **)&punk);
        
        if ( FAILED(hr) )
            goto final_exit;
    }
    // FALLTHRU to qi exit point
    
qiexit_point:
    
    // Get the requested interfaces
    for ( i = 0; i<dwCount; i++ )
    {
        pResults[i].hr = punk->QueryInterface(*(pResults[i].pIID),
            (void**)&pResults[i].pItf );
    }
    punk->Release();
    
    // Got object from ROT so we are done.
    goto exit_point;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetInstanceHelperMulti
//
//  Synopsis:   Creates an instance
//
//  Arguments:  [pcf] - class factory
//              [grfMode] - mode to use when loading file
//              [pwszName] - file path to persistent storage
//              [pstg] - storage for persistent storage
//              [ppvUnk] - pointer to IUnknown
//
//  Returns:    S_OK - object successfully instantiated
//
//  Algorithm:  Create an empty instance of the object and then use
//              either the provided storage or file to load the object.
//
//  History:    12-May-93 Ricksa    Created
//
//  Notes:      This helper is called by by servers and clients
//
//--------------------------------------------------------------------------
HRESULT GetInstanceHelperMulti(
                              IClassFactory *pcf,
                              DWORD dwInterfaces,
                              IID * pIIDs,
                              MInterfacePointer **ppIFDArray,
                              HRESULT * pResultsArray,
                              IUnknown **ppunk,
                              CDestObject *pDestObj)
{
    TRACECALL(TRACE_ACTIVATION, "GetInstanceHelperMulti");

    XIUnknown xunk;

    // Get the controlling unknown for the instance.
    HRESULT hr = pcf->CreateInstance(NULL, IID_IUnknown, (void **) &xunk);

    // This shouldn't fail but it is untrusted code ...
    if ( FAILED(hr) || !xunk)
    {
        if (SUCCEEDED (hr))
            hr = E_OUTOFMEMORY;

        if ( ppIFDArray )
            for ( DWORD i=0; i< dwInterfaces; i++ )
            {
                ppIFDArray[i] = NULL;
                pResultsArray[i] = E_FAIL;
            }

        return hr;
    }

    // If an interface buffer was passed in, then this is a remote call
    // and we need to marshal the interface.
    if ( ppIFDArray )
    {
        // AddRef the pointer because MarshalHelper expects to release
        // pointer. Because MarshalHelper is called from two other places,
        // we do an AddRef here instead of moving the AddRef out of
        // MarshalHelper.
        xunk->AddRef();
        hr = MarshalHelperMulti(xunk, dwInterfaces, pIIDs, ppIFDArray, pResultsArray,
                                pDestObj);

        if ( ppunk )
        {
            xunk.Transfer(ppunk);
        }

        return hr;
    }
    else
    {
        // This is an inprocess server so we need to return the output
        // punk
        xunk.Transfer(ppunk);
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   MarshalHelper
//
//  Synopsis:   Marshals an Interface
//
//  Arguments:  [punk] - interface to marshal
//              [riid] - iid to marshal
//              [ppIRD] - where to put pointer to marshaled data
//
//  Returns:    S_OK - object successfully marshaled.
//
//  Algorithm:  Marshal the object and then get the pointer to
//              the marshaled data so we can give it to RPC
//
//  History:    12-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT MarshalHelper(
                     IUnknown *punk,
                     REFIID    riid,
                     DWORD     mshlflags,
                     InterfaceData **ppIRD)
{
    TRACECALL(TRACE_ACTIVATION, "MarshalHelper");

    // Stream to put marshaled interface in
    CXmitRpcStream xrpc;

    // use MSHCTX_DIFFERENTMACHINE so we get the long form OBJREF
    HRESULT hr = CoMarshalInterface(&xrpc, riid, punk,
                                    SetMarshalContextDifferentMachine(),
                                    NULL, mshlflags);

    if ( SUCCEEDED(hr) )
    {
        xrpc.AssignSerializedInterface(ppIRD);
    }

    // We release our reference to this object here. Either we
    // are going to hand it out to the client, in which case, we
    // want to release it when the client is done or the marshal
    // failed in which case we want it to go away since we can't
    // pass it back to the client.
    punk->Release();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   MarshalHelperMulti
//
//  Synopsis:   Marshals a bunch of Interfaces
//
//  Arguments:  [punk] - interface to marshal
//              [riid] - iid to marshal
//              [ppIRD] - where to put pointer to marshaled data
//
//  Returns:    S_OK - object successfully marshaled.
//
//  Algorithm:  Marshal the object and then get the pointer to
//              the marshaled data so we can give it to RPC
//
//  History:    12-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT MarshalHelperMulti(
                          IUnknown *punk,
                          DWORD dwInterfaces,
                          IID * pIIDs,
                          MInterfacePointer **ppIFDArray,
                          HRESULT * pResultsArray,
                          CDestObject *pDestObj)
{
    TRACECALL(TRACE_ACTIVATION, "MarshalHelperMulti");

    HRESULT hr = E_NOINTERFACE;

    for ( DWORD i = 0; i<dwInterfaces; i++ )
    {
        // Stream to put marshaled interface in
        CXmitRpcStream xrpc;

        // use DIFFERENTMACHINE so we get the long form OBJREF
        HRESULT hr2 = CoMarshalInterface(&xrpc, pIIDs[i], punk,
                                         SetMarshalContextDifferentMachine(),
                                         pDestObj, MSHLFLAGS_NORMAL);

        pResultsArray[i] = hr2;
        if ( SUCCEEDED(hr2) )
        {
            xrpc.AssignSerializedInterface((InterfaceData**)&ppIFDArray[i]);
            hr = hr2;       // report OK if ANY interface was found
        }
        else
            ppIFDArray[i] = NULL;

    }

    // We release our reference to this object here. Either we
    // are going to hand it out to the client, in which case, we
    // want to release it when the client is done or the marshal
    // failed in which case we want it to go away since we can't
    // pass it back to the client.
    punk->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   UnMarshalHelper
//
//  Synopsis:
//
//  Arguments:  [pIFP] --
//              [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    10-10-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT UnMarshalHelper(MInterfacePointer *pIFP, REFIID riid, void **ppv)
{
    HRESULT hr = E_INVALIDARG;

    if ( pIFP && ppv )
    {
        CXmitRpcStream Stm((InterfaceData *) pIFP);

        *ppv = NULL;

        hr = CoUnmarshalInterface(&Stm, riid, ppv);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   DoBetterUnmarshal
//
//  Synopsis:   Helper for unmarshaling an interface from remote
//
//  Arguments:  [pIFD] - serialized interface reference returned by SCM
//      [riid] - interface ID requested by application
//      [ppvUnk] - where to put pointer to returned interface
//
//  Returns:    S_OK - Interface unmarshaled
//
//  Algorithm:  Convert marshaled data to a stream and then unmarshal
//      to the right interface
//
//
//  History:    11-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT DoBetterUnmarshal(MInterfacePointer *&pIFD, REFIID riid, IUnknown **ppvUnk)
{
    // Convert returned interface to  a stream
    CXmitRpcStream xrpc( (InterfaceData*)pIFD );

    HRESULT hr = CoUnmarshalInterface(&xrpc, riid, (void **) ppvUnk);

    //CODEWORK: Stress revealed CoGetClassObject returning a null class factory
    // and S_OK
    Win4Assert(((hr == S_OK  &&  *ppvUnk != NULL)  ||
                (hr != S_OK  &&  *ppvUnk == NULL))
               &&  "DoBetterUnmarshal QueryInterface failure");

    MIDL_user_free(pIFD);
    pIFD = NULL;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   UnmarshalMultipleSCMResults
//
//  Synopsis:   Common routine for dealing with results from SCM
//
//  Arguments:  [sc] - SCODE returned by SCM
//      [pIFD] - serialized interface reference returned by SCM
//      [riid] - interface ID requested by application
//      [ppunk] - where to put pointer to returned interface
//      [pwszDllPath] - path to DLL if there is one.
//      [ppunk] - pointer to returned interface.
//      [usMethodOrdinal] - method for error reporting
//
//  Returns:    TRUE - processing is complete for the call
//      FALSE - this is a DLL and client needs to instantiate.
//
//  Algorithm:  If the SCODE indicates a failure, then this sets an
//      SCODE indicating that the service controller returned
//      an error and propagates the result from the SCM. Otherwise,
//      if the SCM has returned a result indicating that a
//      handler has been returned, the handler DLL is cached.
//      If a marshaled interface has been returned, then that is
//      unmarshaled. If an inprocess server has been returned,
//      the DLL is cached and the class object is created.
//
//  History:    11-May-93 Ricksa    Created
//
//  Notes:      This routine is simply a helper for CoGetPersistentInstance.
//
//--------------------------------------------------------------------------
void UnmarshalMultipleSCMResults(
                                HRESULT & hr,
                                PMInterfacePointer *pItfArray,
                                DWORD dwContext,
                                REFCLSID rclsid,
                                IUnknown * punkOuter,
                                DWORD dwCount,
                                IID * pIIDs,
                                HRESULT * pHrArray,
                                MULTI_QI * pResults)
{
    DWORD       i;
    HRESULT     hr2;
    IUnknown    * pUnk;

    if ( hr != S_OK )
        return;

    if ( punkOuter )
    {
        hr = CLASS_E_NOAGGREGATION;
        return;
    }

    for ( i=0; i<dwCount; i++, pResults++ )
    {
        pResults->hr = pHrArray[i];

        if ( SUCCEEDED( pHrArray[i] ) )
        {
            hr2 = DoBetterUnmarshal( pItfArray[i],
                                     *(pResults->pIID),
                                     &pResults->pItf);

            // Try to set the overall HR correctly
            pResults->hr = hr2;

            if ( FAILED( hr2 ) )
                hr = CO_S_NOTALLINTERFACES;
        }
        else
        {
            hr = CO_S_NOTALLINTERFACES;
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   RemapClassCtxForInProcServer
//
//  Synopsis:   Remap CLSCTX so that the correct type of inproc server will
//              be requested.
//
//  Arguments:  [dwCtrl] - requested server context
//
//  Returns:    Updated dwCtrl appropriate for the process' context
//
//  Notes:      If an inproc server is requested make sure it is the right
//              type for the process. In other words, we only load 16 bit
//              inproc servers into 16 bit processes and 32 bit servers
//              into 32 bit processes. The special logic here is only for
//              16 bit servers since the attempt to load a 16-bit DLL into
//              a 32 bit process will fail anyway.
//
//  History:    01-11-95    Ricksa      Created
//
//+-------------------------------------------------------------------------
DWORD RemapClassCtxForInProcServer(DWORD dwCtrl)
{
    if ( IsWOWThread() )
    {
        // 16 bit process - remap CLSCTX_INPROC_SERVER if necessary
        if ( (dwCtrl & CLSCTX_INPROC_SERVER) != 0 )
        {
            // Turn on the 16 bit inproc server request and turn off the
            // 32 bit server request flag.
            dwCtrl = (dwCtrl & ~CLSCTX_INPROC_SERVER) | CLSCTX_INPROC_SERVER16;
        }
        // if handlers are requested make sure 16-bit is looked for first
        // We mask out 32bit handler flag for Wow threads because we will
        // always look for a 32 bit handler if we don't find a 16 bit one
        if ( (dwCtrl & CLSCTX_INPROC_HANDLER) != 0 )
        {
            // Turn on the 16 bit inproc handler request and turn off the
            // 32 bit handler request flag.
            dwCtrl = (dwCtrl & ~CLSCTX_INPROC_HANDLER) | CLSCTX_INPROC_HANDLER16;
        }
    }
    else
    {
        if ( (dwCtrl & CLSCTX_INPROC_SERVER) != 0 )
        {
            // Turn off the 16 bit inproc server request
            dwCtrl &= ~CLSCTX_INPROC_SERVER16;
        }
    }

    return dwCtrl;
}


//+-------------------------------------------------------------------------
//
//  Function:   IsInternalCLSID
//
//  Synopsis:   checks if the given clsid is an internal class, and
//              bypasses the TreatAs and SCM lookup if so. Also checks for
//              OLE 1.0 classes, which are actually considered to be
//              internal, since their OLE 2.0 implementation wrapper is
//              ours.
//
//  Arguments:  [rclsid] - clsid to look for
//              [riid]   - the iid requested
//              [hr]     - returns the hresult from DllGetClassObject
//              [ppvClassObj] - where to return the class factory
//
//  Returns:    TRUE - its an internal class, hr is the return code from
//                     DllGetClassObject and if hr==S_OK ppvClassObj
//                     is the class factory.
//              FALSE - not an internal class
//
//  Notes:      internal classes can not be overridden because there are
//              other mechanisms for creating them eg CreateFileMoniker that
//              bypass implementation lookup.
//
//  History:    5-04-94     Rickhi      Created
//              5-04-94     KevinRo     Added OLE 1.0 support
//
//+-------------------------------------------------------------------------
BOOL IsInternalCLSID(
                    REFCLSID rclsid,
                    DWORD    dwContext,
                    REFIID   riid,
                    HRESULT  &hr,
                    void **  ppvClassObj)
{
    DWORD *ptr = (DWORD *) &rclsid;
    *ppvClassObj = NULL;

    if ( *(ptr+1) == 0x00000000 &&   //  all internal clsid's have these
         *(ptr+2) == 0x000000C0 &&   //   common values
         *(ptr+3) == 0x46000000 )
    {
        if ( IsEqualGUID(rclsid, CLSID_ATHostActivator) )
        {
            hr = ATHostActivatorGetClassObject(riid, ppvClassObj);
        }
        else if ( IsEqualGUID(rclsid, CLSID_MTHostActivator) )
        {
            hr = MTHostActivatorGetClassObject(riid, ppvClassObj);
        }
        else if ( IsEqualGUID(rclsid, CLSID_NTHostActivator) )
        {
            hr = NTHostActivatorGetClassObject(riid, ppvClassObj);
        }

        // Its possible that an OLE 1.0 class has been marked
        // as TREATAS as part of an upgrade. Here we are going
        // to handle the loading of OLE 1.0 servers. We
        // need to do the GetTreatAs trick first. Rather than
        // invalidate this perfectly good caching routine, the
        // GetTreatAs will only be done if the clsid is in the
        // range of the OLE 1.0 UUID's. Note that the GetTreatAs
        // done here will add the class to the cache, so if the
        // resulting class is outside of the internal range, the
        // lookup done later will be nice and fast.

        CLSID clsid  = rclsid;
        WORD  hiWord = HIWORD(clsid.Data1);

        if (hiWord == 3  ||  hiWord == 4)
        {
            // Its in the OLE 1.0 class range. See if it has
            // been marked as 'treatas'

            CCGetTreatAs(rclsid, clsid);
            ptr = (DWORD *) &clsid;
            hiWord = HIWORD(clsid.Data1);
        }

        if ((*ptr >= MIN_INTERNAL_CLSID && *ptr <= MAX_INTERNAL_CLSID       &&
            (dwContext & (CLSCTX_INPROC_SERVERS | CLSCTX_INPROC_HANDLERS))) ||
             (hiWord == 3  ||  hiWord == 4) || (*ptr == 0x0002e005) )
        {
            //  internal class (eg file moniker) or an OLE 1.0 class.

           hr = DllGetClassObject(clsid, riid, ppvClassObj);
           return TRUE;
        }
    }

#if 0
    // CODEWORK: re-enable this code when we can figure out how to make
    // the return code semantics comprehensible.

    // If the CLSCTX_NO_CUSTOM_MARSHAL flag is set, we check if this is a
    // COMSVCS context.  If it is, we try to get it's class factory.

    if (IsComsvcsCLSID(rclsid))
    {
        // if it is a non-configured comsvcs clsid then we can fast-path
        // it's creation, otherwise, we have to take the normal path in
        // order to ensure the object is created in the correct context.
        if (IsNonConfiguredComsvcsCLSID(rclsid))
        {
            // Make sure that the comsvc dll is loaded.
            if (g_hComSvcs == NULL)
            {
               // Load the Com services library.
               HINSTANCE hComSvc = NULL;

               hComSvc = LoadLibraryA("comsvcs.dll");

    #if DBG==1
               if (hComSvc == NULL)
               {
                   CairoleDebugOut((DEB_DLL,
                       "IsInternalCLSID: LoadLibrary comsvcs.dll failed\n"));
               }
    #endif
               // Now try to set the global value for the ComSVC handle. Free
               // the new handle if the exchange does not succeed.

               if(InterlockedCompareExchangePointer((void**)&g_hComSvcs, hComSvc, NULL))
               {
                   FreeLibrary(hComSvc);
               }

               // Get the proc address for the DllGetClassObject
               ComSvcGetClass = (InternalGetClass) GetProcAddress(g_hComSvcs, "DllGetClassObject");
            }

            // Try to get the class object from the Com Svc Dll
            hr = (*ComSvcGetClass) (rclsid, riid, ppvClassObj);
            Win4Assert(FAILED(hr) || *ppvClassObj);
        }

        return(TRUE);
    }
#endif

    if ( IsEqualGUID(rclsid, CLSID_VSA_IEC) )
    {
        // this is Vista EventLog class ID
        hr = LogEventGetClassObject(riid, ppvClassObj);
        return TRUE;
    }
    else if( IsEqualGUID( rclsid, CLSID_ThumbnailUpdater ) )
    {
        hr = DllGetClassObject(rclsid, riid, ppvClassObj);
        return TRUE;
    }

    // not an internal class.
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   FindOrCreateApartment
//
//  Synopsis:   Searches the cache for requested classid.
//              If not found looks to see if an inproc server or handler
//              can be loaded (if requested).
//
//  Arguments:  [Clsid]         Class ID
//              [ClassContext]  Which context to load
//              [DllServerType] ???
//              [pwszDllServerPath] returned dll path
//
//  Returns:    S_OK - Class factory for object
//              otherwise - Class factory could not be found or
//                      constructed.
//
//  History:    2-5-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
FindOrCreateApartment(
                     REFCLSID     Clsid,
                     DWORD        actvflags,
                     DLL_INSTANTIATION_PROPERTIES *pdip,
                     HActivator *phActivator
                     )
{
    // CLSID and Partition are ignored here...
    ACTIVATION_PROPERTIES ap(Clsid, 
                             GUID_NULL,
                             GUID_NULL, 
                             0,
                             pdip->_dwContext, 
                             actvflags, 
                             0, 
                             NULL, 
                             NULL);
    return CCGetOrCreateApartment(ap, pdip, phActivator);
}



// Helper routine to find the apartment activator for the default apartment
// for activating the given class


//+-------------------------------------------------------------------------
//
//  Function:   UpdateResultsArray
//
//  Synopsis:   Helper for returning the correct hr from a multi-qi call
//
//  Arguments:  [hrIn]          - hr from the calling function
//              [dwCount]       - number of IIDs requested
//              [pResults]      - where to put pointer to returned interface
//
//  Returns:    S_OK - All Interface are OK
//
//  History:    30-Aug-95 GregJen    Created
////
//--------------------------------------------------------------------------
HRESULT
UpdateResultsArray( HRESULT hrIn, DWORD dwCount, MULTI_QI * pResults )
{
    HRESULT     hr = hrIn;
    DWORD       i;

    // make sure the HR is set correctly
    if ( SUCCEEDED( hrIn ) )
    {
        // assume no interfaces were found
        DWORD   dwFound = 0;
        for ( i=0; i<dwCount; i++ )
        {
            if ( FAILED( pResults[i].hr ) )
                pResults[i].pItf        = NULL;
            else
            {
                dwFound++;
                Win4Assert(pResults[i].pItf != NULL );
            }
        }

        if ( dwFound == 0 )
        {
            // if there was only 1 interface, return its hr.
            if ( dwCount == 1 )
                hr = pResults[0].hr;
            else
                hr = E_NOINTERFACE;
        }
        else if ( dwFound < dwCount )
            hr = CO_S_NOTALLINTERFACES;
    }
    else
    {
        // failed - set all the hr's to the overall failure code,
        // and clean up any interface pointers we got
        for ( i=0; i<dwCount; i++ )
        {
            if ( pResults[i].pItf )
                pResults[i].pItf->Release();
            pResults[i].pItf    = NULL;
            pResults[i].hr      = hr;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   ValidateCoServerInfo
//
//  Synopsis:   returns S_OK if the COSERVERINFO structure supplied with the
//              call to a COM API function is valid.  Since this depends
//              on other parameters supplied to the API, those parameters must
//              be passed to this validation function.
//
//  Arguments:  [pServerInfo] - server information block to be validated
//
//+----------------------------------------------------------------------------
HRESULT ValidateCoServerInfo(COSERVERINFO* pServerInfo)
{
    if ( !pServerInfo )
    {
        return S_OK;
    }

    if ( !IsValidPtrIn( pServerInfo, sizeof(COSERVERINFO)) )
    {
        return E_INVALIDARG;
    }

    if ( pServerInfo->dwReserved2 )
    {
        return E_INVALIDARG;
    }

    // check the server name
    if ( pServerInfo->pwszName && !IsValidPtrIn(pServerInfo, sizeof(WCHAR)) )
    {
        return E_INVALIDARG;
    }

    // validate the COAUTHINFO
    if ( pServerInfo->pAuthInfo && !IsValidPtrIn(pServerInfo->pAuthInfo, sizeof(COAUTHINFO)) )
    {
        return E_INVALIDARG;
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReleaseMQI
//
//  Synopsis:   Frees all the interfaces in an array of MULTI_QI's
//              Resets the members of each element to values
//              indicating activation failure
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------
void ReleaseMQI(MULTI_QI* pResults, DWORD dwCount)
{
    Win4Assert("Invalid Number of Interfaces in MQI" && ((LONG) dwCount >= 0));

    for ( DWORD i = 0; i < dwCount; i++ )
    {
        if ( pResults[i].pItf )
        {
            pResults[i].pItf->Release();
            pResults[i].pItf = NULL;
            pResults[i].hr = E_NOINTERFACE;
        }
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   CSplit_QI constructor
//
//  Synopsis:   Helper for allocating the arrays for a multi-qi call
//
//  Arguments:  [hr]            - hr to return by reference
//              [count]         - number of IIDs requested
//              [pInputArray]   - the MULTI_QI structure passed in to us
//
//  Returns:    S_OK - everything set up OK
//
//  History:    01-Dec-95 GregJen    Created
////
//--------------------------------------------------------------------------
CSplit_QI::CSplit_QI( HRESULT & hr, DWORD count, MULTI_QI * pInputArray )
{
    _pAllocBlock     = NULL;
    _pItfArray       = NULL;
    _dwCount         = count;

    // if they only asked for 1 or 2, save time by just using
    // our memory on the stack
    if ( count <= 2 )
    {
        _pItfArray       = SomePMItfPtrs;
        _pHrArray        = SomeHRs;
        _pIIDArray       = SomeIIDs;

        for ( DWORD i = 0; i < count; i++ )
        {
            _pIIDArray[i] = *(pInputArray[i].pIID);
        }

        memset( _pItfArray, 0, sizeof(SomePMItfPtrs) );

        hr = S_OK;
        return;
    }

    ULONG ulItfArrSz = count * sizeof( PMInterfacePointer );
    ULONG ulHRArrSz  = count * sizeof( HRESULT );
    ULONG ulIIDArrSz = count * sizeof( IID );

    _pAllocBlock = (char * )PrivMemAlloc( ulItfArrSz +
                                          ulHRArrSz  +
                                          ulIIDArrSz );
    if ( _pAllocBlock )
    {
        hr = S_OK;

        // carve up the allocated block
        _pItfArray = (PMInterfacePointer *) _pAllocBlock;
        _pHrArray = (HRESULT *) (_pAllocBlock +
                                 ulItfArrSz );
        _pIIDArray = (IID * ) ( _pAllocBlock +
                                ulItfArrSz +
                                ulHRArrSz );

        // copy the IIDs and zero the MInterfacePointers
        for ( DWORD i = 0; i < count; i++ )
        {
            _pIIDArray[i] = *(pInputArray[i].pIID);
        }
        memset( _pItfArray, 0, ulItfArrSz );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

}
//+-------------------------------------------------------------------------
//
//  Function:   CSplit_QI destructor
//
//  Synopsis:   Helper for freeing the arrays for a multi-qi call
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    01-Dec-95 GregJen    Created
//
//--------------------------------------------------------------------------
CSplit_QI::~CSplit_QI()
{
    // make sure to clean up any dangling interface pointers
    if ( _pItfArray )
    {
        for ( DWORD i = 0; i < _dwCount; i++ )
        {
            if ( _pItfArray[i] )
            {
                CXmitRpcStream xrpc( (InterfaceData*)_pItfArray[i] );

                CoReleaseMarshalData(&xrpc);

                MIDL_user_free(_pItfArray[i]);
                _pItfArray[i] = NULL;
            }
        }
    }

    // only do the free if we allocated something
    if ( _pAllocBlock )
    {
        PrivMemFree( _pAllocBlock );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   GetEmbeddingServerHandlerInterfaces
//
//  Synopsis:   Creates an instance of the server handler and the server object
//
//  Returns:    S_OK - object successfully instantiated
//
//  Algorithm:  Create the server object then create a server handler that points
//              to the server object.  The two are different objects.  Return only
//              the interfaces requested on the server handler object.
//              The client can get the server object by asking the server handler for it.
//
//  History:    08-oct-96 bchapman    Created
//
//  Notes:      This is called by ObjServerCreateInstance
//
//--------------------------------------------------------------------------
#ifdef SERVER_HANDLER
HRESULT GetEmbeddingServerHandlerInterfaces(
                                           IClassFactory *pcf,
                                           DWORD dwFlags,
                                           DWORD dwInterfaces,
                                           IID * pIIDs,
                                           MInterfacePointer **ppIFDArray,
                                           HRESULT * pResultsArray,
                                           IUnknown **ppunk,
                                           CDestObject *pDestObj)
{
    XIUnknown xunkServer;
    XIUnknown xunkESHandler;
    CStdIdentity *pStdid = NULL;
    HRESULT hr;

    //
    // Create the server object.
    //

    // make sure we got what was expected.
    Win4Assert(2 == dwInterfaces);
    Win4Assert(NULL != ppIFDArray);
    Win4Assert(IID_IUnknown == pIIDs[0]);
    Win4Assert(IID_IServerHandler == pIIDs[1]);
    Win4Assert(NULL == ppunk);



    ppIFDArray[0] = NULL;
    ppIFDArray[1] = NULL;
    pResultsArray[0] = E_NOINTERFACE;
    pResultsArray[1] = E_NOINTERFACE;

    // if the DISABLE_EMBEDDING_SERVER_HANDLER flags is set it means the real
    // object should be returned, else the ServerHandler.

    if ( DISABLE_EMBEDDING_SERVER_HANDLER & dwFlags )
    {
        // only allow Marshal of IID_IUnknown
        hr = GetInstanceHelperMulti(pcf,1,pIIDs,ppIFDArray,pResultsArray,ppunk,
                                    pDestObj);
        pResultsArray[1] = E_NOINTERFACE;
        ppIFDArray[1] = NULL;
        return hr;
    }


    //
    // Create the server handler w/ a pointer to the server
    //

    hr = pcf->CreateInstance(NULL, IID_IUnknown, (void **) &xunkServer);
    if ( FAILED(hr) )
        return hr;

    xunkServer->AddRef();
    hr = MarshalHelperMulti(xunkServer,1, &pIIDs[0], &ppIFDArray[0], &pResultsArray[0],
                            pDestObj);
    if ( FAILED(hr) )
        return hr;

    LookupIDFromUnk(xunkServer, GetCurrentApartmentId(), 0, &pStdid);

    if ( pStdid )
    {
        if ( !pStdid->IsClient() )
        {
            hr = CreateEmbeddingServerHandler(pStdid,&xunkESHandler);

            if ( SUCCEEDED(hr) )
            {
                xunkESHandler->AddRef();
                hr = MarshalHelperMulti(xunkESHandler,1, &pIIDs[1], &ppIFDArray[1], &pResultsArray[1], pDestObj);
            }

        }

        pStdid->Release();
    }

    return NOERROR; // return NOERROR even if ServerHandler was not created.
}
#endif // SERVER_HANDLER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\remapi.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       remapi.cxx
//
//  Contents:   Rem calls to object servers for Win95
//
//  Classes:    SScmGetClassObj
//              SScmCreateObj
//              SScmActivateObj
//
//  Functions:  CallObjSrvGetClassObject
//              CallObjSrvCreateObject
//              CallObjSrvActivateObject
//              GetToRemCoGetActiveClassObject
//              GetToRemCoActivateObject
//              GetToRemCoCreateObject
//
//  History:    06-Jun-95   Ricksa      Created.
//
//  Notes:      This file is Chicago ONLY!
//
//--------------------------------------------------------------------------
#include <ole2int.h>

#include    <iface.h>
#include    <objsrv.h>
#include    <endpnt.hxx>
#include    <service.hxx>
#include    <resolver.hxx>
#include    <objerror.h>
#include    <channelb.hxx>


#ifdef _CHICAGO_




//+-------------------------------------------------------------------------
//
//  Class:      SOSGetClassObj
//
//  Purpose:    Pass GetClassObject parameters through channel threading
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
struct SOSGetClassObj : STHREADCALLINFO
{
    // init base class and copy string in place
    SOSGetClassObj (TRANSMIT_FN fn,CALLCATEGORY callcat)
	: STHREADCALLINFO(fn, callcat, 0)
	{
            // Header does the work
	}

    handle_t            hRpc;               // Rpc handle
    CLSID	        clsid;

    // out params; can't point directly to caller's data because of cancel
    InterfaceData *     pIFDClassObj;
};


//+-------------------------------------------------------------------------
//
//  Class:      SOSCreateObj
//
//  Purpose:    Pass CreatePersistentInstance parameters through channel
//              threading.
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
struct SOSCreateObj : STHREADCALLINFO
{
    // alloc enough for class, strings and iface data together
    void *operator new(size_t size, DWORD cbPath, DWORD cbIFD,
			DWORD cbNewName)
	{ return PrivMemAlloc(size + cbPath + cbIFD + cbNewName); }

    SOSCreateObj (TRANSMIT_FN fn,CALLCATEGORY callcat,
		    WCHAR *pwszP, DWORD cbPath,
		    InterfaceData *pIFD, DWORD cbIFD,
		    WCHAR *pwszN, DWORD cbNewName)
	: STHREADCALLINFO(fn, callcat, 0)
	{
	    // interface data is first to easily get 4byte alignment
	    pIFDstg = CopyInterfaceData(this+1, pIFD, cbIFD);
	    pwszPath = CopyWideString((char *)(this+1) + cbIFD, pwszP, cbPath);
	    pwszNewName = CopyWideString((char *)(this+1) + cbIFD + cbPath,
		pwszN, cbNewName);
	}

    handle_t            hRpc;               // Rpc handle
    CLSID		clsid;
    DWORD               dwMode;
    WCHAR               *pwszPath;
    DWORD               dwTIDCaller;        // will be passed to callee's
                                            //   message filter
    InterfaceData *     pIFDstg;	    // points after this struct
    WCHAR *             pwszNewName;	    // points after this struct

    // out params; can't point directly to caller's data because of cancel
    InterfaceData *     pIFDunk;
};


//+-------------------------------------------------------------------------
//
//  Class:      SOSActivateObj
//
//  Purpose:    Pass GetPersistenInstance request parameters through threading
//              mechanism.
//
//  History:    11-Nov-93 Ricksa    Created
//              18-Aug-94 AlexT     Add dwTIDCaller
//
//--------------------------------------------------------------------------
struct SOSActivateObj : STHREADCALLINFO
{
    // alloc enough for class, strings and iface data together
    void *operator new(size_t size, DWORD cbPath, DWORD cbIFD)
	{ return PrivMemAlloc(size + cbPath + cbIFD); }

    SOSActivateObj(TRANSMIT_FN fn,CALLCATEGORY callcat,
		    WCHAR *pwszP, DWORD cbPath,
		    InterfaceData *pIFD, DWORD cbIFD)
	: STHREADCALLINFO(fn, callcat, 0)
	{
	    // interface data is first to easily get 4byte alignment
	    pIFDstg = CopyInterfaceData(this+1, pIFD, cbIFD);
	    pwszPath = CopyWideString((char *)(this+1) + cbIFD, pwszP, cbPath);
	}


    handle_t            hRpc;               // Rpc handle
    CLSID		clsid;
    DWORD               grfMode;
    DWORD               dwTIDCaller;        // will be passed to callee's
                                            //   message filter
    WCHAR *             pwszPath;	    // points after this struct
    InterfaceData *     pIFDstg;	    // points after this struct
    InterfaceData *     pIFDFromROT;

    // out params; can't point directly to caller's data because of cancel
    InterfaceData *     pIFDunk;

};


//+-------------------------------------------------------------------------
//
//  Member:     CallObjSrvGetClassObject
//
//  Synopsis:   Call through to the SCM to get a class object
//
//  Arguments:  [pData] - parmeters
//
//  Returns:    S_OK
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT __stdcall CallObjSrvGetClassObject( STHREADCALLINFO *pData )
{
    SOSGetClassObj *posclsobj = (SOSGetClassObj *) pData;

    error_status_t rpcstat = RPC_S_OK;

    HRESULT result = _RemCoGetActiveClassObject(posclsobj->hRpc, &pData->lid(),
        &posclsobj->clsid, &posclsobj->pIFDClassObj, &rpcstat);

    if (rpcstat != RPC_S_OK)
    {
        CairoleDebugOut((DEB_ERROR,
            "CallObjSrvGetClassObject error rpcstat = %lx\n", rpcstat));
        result = CO_E_SCM_RPC_FAILURE;
    }

    return result;
}




//+-------------------------------------------------------------------------
//
//  Member:     CallObjSrvCreateObject
//
//  Synopsis:   Call through to the SCM to create an object
//
//  Arguments:  [pData] - parmeters
//
//  Returns:    S_OK
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT __stdcall CallObjSrvCreateObject( STHREADCALLINFO *pData )
{
    SOSCreateObj *poscrtobj = (SOSCreateObj *) pData;
    HRESULT        result;
    DWORD          dwTIDCallee = 0;

    error_status_t rpcstat = RPC_S_OK;

    result = _RemCoCreateObject(poscrtobj->hRpc, NULL, &pData->lid(),
        &poscrtobj->clsid, poscrtobj->dwMode, poscrtobj->pwszPath,
            poscrtobj->pIFDstg, poscrtobj->pwszNewName, poscrtobj->dwTIDCaller,
                &dwTIDCallee, &poscrtobj->pIFDunk, &rpcstat);

    if (rpcstat != RPC_S_OK)
    {
        CairoleDebugOut((DEB_ERROR,
            "CallObjSrvCreateObject error rpcstat = %lx\n", rpcstat));
        result = CO_E_SCM_RPC_FAILURE;
    }

    //  _RemCoCreateObject returns the thread id of the callee - we record it
    //  in the STHREADCALLINFO so that we can pass it to this app's message
    //  filter as needed

    pData->SetTIDCallee(dwTIDCallee);

    return result;
}




//+-------------------------------------------------------------------------
//
//  Member:     CallObjSrvActivateObject
//
//  Synopsis:   Call through to the SCM to activate an object
//
//  Arguments:  [pData] - parmeters
//
//  Returns:    S_OK
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT __stdcall CallObjSrvActivateObject( STHREADCALLINFO *pData )
{
    SOSActivateObj *posactobj = (SOSActivateObj *) pData;
    HRESULT          result;
    DWORD            dwTIDCallee = 0;

    error_status_t rpcstat = RPC_S_OK;

    result = _RemCoActivateObject(posactobj->hRpc, NULL,
        &pData->lid(), &posactobj->clsid, posactobj->grfMode,
            posactobj->pwszPath, posactobj->pIFDstg, posactobj->dwTIDCaller,
                &dwTIDCallee, &posactobj->pIFDunk, posactobj->pIFDFromROT,
                    &rpcstat);

    if (rpcstat != RPC_S_OK)
    {
        CairoleDebugOut((DEB_ERROR,
            "CallObjSrvActivateObject error rpcstat = %lx\n", rpcstat));
        result = CO_E_SCM_RPC_FAILURE;
    }

    //  _RemCoActivateObject returns the thread id of the callee - we record it
    //  in the STHREADCALLINFO so that we can pass it to this app's message
    //  filter as needed

    pData->SetTIDCallee(dwTIDCallee);

    return result;
}







//+-------------------------------------------------------------------------
//
//  Function:   GetToRemCoGetActiveClassObject
//
//  Synopsis:   Dispatch RemCoGetActiveClassObject via call control
//
//  Arguments:  [hRpc] - handle to RPC connection
//              [guidThreadId] - logical thread id
//              [pclsid] - class ID.
//              [ppIFD] - where to return marshaled interface
//              [prpcstat] - communication error status
//
//  Returns:    S_OK - class object successful found & returned
//              Other - call failed.
//
//  Algorithm:  Build packet for dispatching call and then call RPC
//              to get the call dispatched.
//
//  History:    06-Jun-95   Ricksa      Created.
//
//  Notes:      This is only used in Chicago. Its purpose is to create
//              make the call to the object server non-raw so we get
//              the benefit of the call control.
//
//--------------------------------------------------------------------------
HRESULT GetToRemCoGetActiveClassObject(
    handle_t hRpc,
    const GUID *guidThreadId,
    const GUID *pclsid,
    InterfaceData **ppIFD,
    error_status_t *prpcstat)
{
    // Result from call
    HRESULT hr;

    // Make a parameter packet suitable for passing to the channel
    SOSGetClassObj *posclsobj =
       new SOSGetClassObj(CallObjSrvGetClassObject, CALLCAT_SYNCHRONOUS);

    if (posclsobj == NULL)
	return E_OUTOFMEMORY;

    posclsobj->hRpc                = hRpc;
    posclsobj->clsid               = *pclsid;
    posclsobj->pIFDClassObj	   = NULL;

    // Let the channel handle the work of getting this on the right thread
    hr = CChannelControl::GetOffCOMThread((STHREADCALLINFO **)&posclsobj);

    if (SUCCEEDED(hr))
    {
	*ppIFD = posclsobj->pIFDClassObj;
    }

    if (hr != RPC_E_CALL_CANCELED)
    {
	delete posclsobj;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetToRemCoActivateObject
//
//  Synopsis:   Dispatch RemCoActivateObject to object server
//
//  Arguments:  [hRpc] - rpc handle
//              [pwszProtseq] - protocol seq (not used in Chicago)
//              [guidThreadId] - logical thread id.
//              [pclsid] - class ID for the object
//              [grfMode] - mode to open file if file supplied.
//              [pwsPath] - path to object if supplied.
//              [pIFDstg] - marshaled storage if supplied.
//              [dwTIDCaller] - caller's thread id
//              [pdwTIDCallee] - place holder for callee's thread id
//              [ppIFD] - where to return marshaled object.
//              [prpcstat] - communication status
//
//  Returns:    S_OK - Object instantiated and marshaled.
//              Other - call failed.
//
//  Algorithm:  Build packet for dispatching call and then call RPC
//              to get the call dispatched.
//
//  History:    06-Jun-95   Ricksa      Created.
//
//  Notes:      This exists to get the call control in the loop between
//              the client and server since this call in Chicago is actually
//              between the client and the server.
//
//--------------------------------------------------------------------------
HRESULT GetToRemCoActivateObject(
    handle_t hRpc,
    WCHAR *pwszProtseq,
    const GUID *guidThreadId,
    const GUID *pclsid,
    DWORD grfMode,
    WCHAR *pwszPath,
    InterfaceData *pIFDstg,
    DWORD dwTIDCaller,
    DWORD *pdwTIDCallee,
    InterfaceData **ppIFD,
    InterfaceData *pIFDFromROT,
    error_status_t *prpcstat)
{
    // Result from call
    HRESULT hr;

    // Make a parameter packet suitable for passing to the channel
    DWORD cbPath = CbFromWideString(pwszPath);
    DWORD cbIFD = CbFromInterfaceData(pIFDstg);

    SOSActivateObj *posactobj = new(cbPath, cbIFD)
	SOSActivateObj(CallObjSrvActivateObject, CALLCAT_SYNCHRONOUS,
	    pwszPath, cbPath, pIFDstg, cbIFD);

    if (posactobj == NULL)
    {
	return E_OUTOFMEMORY;
    }

    // This call is actually a combination of a number of calls and so
    // gets the category of the weakest.

    posactobj->hRpc                = hRpc;
    posactobj->clsid               = *pclsid;
    posactobj->grfMode             = grfMode;
    // posactobj->pwszPath set above
    // posactobj->pIFDstg set above
    posactobj->pIFDunk             = NULL;
    posactobj->pIFDFromROT         = pIFDFromROT;
    posactobj->dwTIDCaller         = GetCurrentThreadId();

    // Let the channel handle the work of getting this on the right thread
    hr = CChannelControl::GetOffCOMThread((STHREADCALLINFO **) &posactobj);

    if (SUCCEEDED(hr))
    {
	*ppIFD = posactobj->pIFDunk;
    }

    if (hr != RPC_E_CALL_CANCELED)
	delete posactobj;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetToRemCoCreateObject
//
//  Synopsis:   Dispatch RemCoCreateObject to object server via call control
//
//  Arguments:  [hRpc] - RPC handle
//              [pclsid] - class id
//              [grfMode] - mode for loading if file name supplied
//              [pwszPathFrom] - path to file to use for create
//              [pIFDstgFrom] - IStorage to use for new object
//              [pwszPath] - new path to the object
//              [dwTIDCaller] - caller's thread id
//              [pdwTIDCallee] - place holder for callee's thread id
//              [ppIFD] - where to put marshaled interface to the object
//
//  Returns:    S_OK - object successfully instantiated
//              Other - call failed.
//
//  Algorithm:  Build packet for dispatching call and then call RPC
//              to get the call dispatched.
//
//  History:    06-Jun-95   Ricksa      Created.
//
//  Notes:      This exists to get the call control in the loop between
//              the client and server since this call in Chicago is actually
//              between the client and the server.
//
//--------------------------------------------------------------------------
HRESULT GetToRemCoCreateObject(
    handle_t hRpc,
    WCHAR *pwszProtseq,
    const GUID *guidThreadId,
    const GUID *pclsid,
    DWORD grfMode,
    WCHAR *pwszPathFrom,
    InterfaceData *pIFDstgFrom,
    WCHAR *pwszPath,
    DWORD dwTIDCaller,
    DWORD *pdwTIDCallee,
    InterfaceData **ppIFD,
    error_status_t *prpcstat)
{
    // Result from call
    HRESULT hr;

    // Make a parameter packet suitable for passing to the channel
    DWORD cbPath = CbFromWideString(pwszPathFrom);
    DWORD cbIFD = CbFromInterfaceData(pIFDstgFrom);
    DWORD cbNewName = CbFromWideString(pwszPath);

    SOSCreateObj *poscrtobj = new(cbPath, cbIFD, cbNewName)
	SOSCreateObj(CallObjSrvCreateObject, CALLCAT_SYNCHRONOUS,
	    pwszPathFrom, cbPath, pIFDstgFrom, cbIFD, pwszPath, cbNewName);

    if (poscrtobj == NULL)
    {
	return E_OUTOFMEMORY;
    }

    // This call is actually a combination of a number of calls and so
    // gets the category of the weakest.

    poscrtobj->hRpc                = hRpc;
    poscrtobj->clsid               = *pclsid;
    poscrtobj->dwMode              = grfMode;
    // poscrtobj->pwszPath set above
    // poscrtobj->pIFDstg set above
    // poscrtobj->pwszNewName set above
    poscrtobj->pIFDunk             = NULL;

    poscrtobj->dwTIDCaller         = GetCurrentThreadId();

    // Let the channel handle the work of getting this on the right thread
    hr = CChannelControl::GetOffCOMThread((STHREADCALLINFO **)&poscrtobj);

    if (SUCCEEDED(hr))
    {
	*ppIFD = poscrtobj->pIFDunk;
    }

    if (hr != RPC_E_CALL_CANCELED)
    {
	delete poscrtobj;
    }

    return hr;
}



#endif // _CHICAGO_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\sandbox.cxx ===
/*++                 

Copyright (c) 1997 Microsoft Corporation

Module Name:

    factory.c

Abstract:
    
    OLE Class Factory and friends.  Implements DllGetClassObject,
    Dll[Un]RegisterServer, DllCanUnloadNow, IClassFactory, and
    IActiveXSafetyProvider.

Author:


Revision History:

--*/
#include <ole2int.h>
#include <malloc.h>
#include "urlmon.h"     // for IInternetSecurityManager
#include "safeocx.h"    // for IActiveXSafety

// Count of outstanding references to COM objects from OLE interfaces handed out
// out, plus the ClassFactory's lock count.
ULONG DllRefCount;

CLSID CLSID_Sandbox = { /* 0708cc6b-8ba5-11d1-a835-00805f850fc6 */
    0x0708cc6b,
    0x8ba5,
    0x11d1,
    {0xa8, 0x35, 0x00, 0x80, 0x5f, 0x85, 0x0f, 0xc6}
  };


class CSandbox : public IActiveXSafetyProvider {
public:
    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    // IActiveXSafetyProvider methods
    HRESULT STDMETHODCALLTYPE TreatControlAsUntrusted(BOOL fTreatAsUntrusted);
    HRESULT STDMETHODCALLTYPE IsControlUntrusted(BOOL *pfTreatAsUnrusted);
    HRESULT STDMETHODCALLTYPE SetSecurityManager(IInternetSecurityManager *p);
    HRESULT STDMETHODCALLTYPE SetDocumentURLA(LPCSTR szDocumentURL);
    HRESULT STDMETHODCALLTYPE SetDocumentURLW(LPCWSTR szDocumentURL);
    HRESULT STDMETHODCALLTYPE ResetToDefaults(void);
    HRESULT STDMETHODCALLTYPE SafeDllRegisterServerA(LPCSTR szServerName);
    HRESULT STDMETHODCALLTYPE SafeDllRegisterServerW(LPCWSTR szServerName);
    HRESULT STDMETHODCALLTYPE SafeDllUnregisterServerA(LPCSTR szServerName);
    HRESULT STDMETHODCALLTYPE SafeDllUnregisterServerW(LPCWSTR szServerName);
    HRESULT STDMETHODCALLTYPE SafeGetClassObject(
                                    REFCLSID rclsid,
                                    DWORD dwClsContext,
                                    LPVOID reserved,
                                    REFIID riid,
                                    IUnknown **pObj);
    HRESULT STDMETHODCALLTYPE SafeCreateInstance(
                                    REFCLSID rclsid,
                                    LPUNKNOWN pUnkOuter,
                                    DWORD dwClsContext,
                                    REFIID riid,
                                    IUnknown **pObj);

    // constructor/destructor
    CSandbox();

    // private members
    ULONG       m_RefCount;
};



HRESULT STDMETHODCALLTYPE
CSandbox::QueryInterface(
    REFIID riid,
    void **ppvObject
    )
/*++

Routine Description:

    Implements QI, only supports QIs for IUnknown

Arguments:

    riid        - interface to query for
    ppvObject   - pointer to result, set to NULL on failure

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IActiveXSafetyProvider) ||
        IsEqualIID(riid, IID_IUnknown)) {

        *ppvObject = (PVOID *)this;
        AddRef();
        hr = S_OK;

    } else {
        hr = E_NOINTERFACE;
    }

    return hr;
}


ULONG STDMETHODCALLTYPE
CSandbox::AddRef(
    void
    )
/*++

Routine Description:

    Bump our refcount

Arguments:

    none

Return Value:

    the new refcount

--*/
{
    return InterlockedIncrement((LONG *)&m_RefCount);
}


ULONG STDMETHODCALLTYPE
CSandbox::Release(
    void
    )
/*++

Routine Description:

    Lower our refcount, when it hits zero, free this instance

Arguments:

    none

Return Value:

    the new refcount

--*/
{
    ULONG Count = InterlockedDecrement((LONG *)&m_RefCount);

    if (Count == 0) {
        delete this;
    }
    return Count;
}


HRESULT STDMETHODCALLTYPE
CSandbox::TreatControlAsUntrusted(
    BOOL fTreatAsUntrusted
    )
/*++

Routine Description:

    Selects whether subsequent Safe... calls treat the control as
    trusted or untrusted.

Arguments:

    fTreatAsUntrusted

Return Value:

    HRESULT

--*/
{
    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CSandbox::IsControlUntrusted(
    BOOL *pfIsUntrusted
    )
/*++

Routine Description:

    Queries whether subsequent Safe... calls will treat the control as
    trusted or untrusted.

Arguments:

    pfTreatAsUntrusted  - [out] pointer to hold the result

Return Value:

    HRESULT

--*/
{
    if (!pfIsUntrusted) {
        return E_INVALIDARG;
    }
    *pfIsUntrusted = TRUE;

    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CSandbox::SetSecurityManager(
    IInternetSecurityManager *pSecurityManager
    )
/*++

Routine Description:

    Assocates an IInternetSecurityManager with this Safety Provider.
    trusted or untrusted.

Arguments:

    pSecurityManager

Return Value:

    HRESULT

--*/
{
    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CSandbox::SetDocumentURLA(
    LPCSTR szDocumentURL
    )
/*++

Routine Description:

    Assocates the URL of the document about to instantiate the control
    with the Safety Provider

Arguments:

    szDocumentURL

Return Value:

    HRESULT

--*/
{
    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CSandbox::SetDocumentURLW(
    LPCWSTR szDocumentURL
    )
/*++

Routine Description:

    Assocates the URL of the document about to instantiate the control
    with the Safety Provider

Arguments:

    szDocumentURL

Return Value:

    HRESULT

--*/
{
    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CSandbox::ResetToDefaults(
    void
    )
/*++

Routine Description:

    Resets the Safety Provider's settings back to the way they were when
    the Safety Provider was first created.

Arguments:

    none

Return Value:

    HRESULT

--*/
{
    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CSandbox::SafeDllRegisterServerA(
    LPCSTR szServerName
    )
/*++

Routine Description:

    Calls a control's DllRegisterServer.  It will be sandboxed if
    the Safety Provider determines it must be.

Arguments:

    szServerName    - dll filename to call DllRegisterServer on

Return Value:

    HRESULT, E_FAIL if DLL does not exist, or has no DllRegisterServer
    export.

--*/
{
    HRESULT hr = E_FAIL;
    HMODULE hMod;
    FARPROC fp;


    hMod = LoadLibraryExA(szServerName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (hMod) {

        fp = GetProcAddress(hMod, "DllRegisterServer");
        if (fp) {
            hr = (HRESULT) (*fp)();
        }
        FreeLibrary(hMod);
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE
CSandbox::SafeDllRegisterServerW(
    LPCWSTR szServerName
    )
/*++

Routine Description:

    Calls a control's DllRegisterServer.  It will be sandboxed if
    the Safety Provider determines it must be.

Arguments:

    szServerName    - dll filename to call DllRegisterServer on

Return Value:

    HRESULT, E_FAIL if DLL does not exist, or has no DllRegisterServer
    export.

--*/
{
    HRESULT hr = E_FAIL;
    HMODULE hMod;
    FARPROC fp;


    hMod = LoadLibraryExW(szServerName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (hMod) {

        fp = GetProcAddress(hMod, "DllRegisterServer");
        if (fp) {
            hr = (HRESULT) (*fp)();
        }
        FreeLibrary(hMod);
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE
CSandbox::SafeDllUnregisterServerA(
    LPCSTR szServerName
    )
/*++

Routine Description:

    Calls a control's DllUnregisterServer.  It will be sandboxed if
    the Safety Provider determines it must be.

Arguments:

    szServerName    - dll filename to call DllUnregisterServer on

Return Value:

    HRESULT, E_FAIL if DLL does not exist, or has no DllUnregisterServer
    export.

--*/
{
    HRESULT hr = E_FAIL;
    HMODULE hMod;
    FARPROC fp;

    hMod = LoadLibraryA(szServerName);
    if (hMod) {

        fp = GetProcAddress(hMod, "DllUnregisterServer");
        if (fp) {
            hr = (HRESULT) (*fp)();
        }
        FreeLibrary(hMod);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
CSandbox::SafeDllUnregisterServerW(
    LPCWSTR szServerName
    )
/*++

Routine Description:

    Calls a control's DllUnregisterServer.  It will be sandboxed if
    the Safety Provider determines it must be.

Arguments:

    szServerName    - dll filename to call DllUnregisterServer on

Return Value:

    HRESULT, E_FAIL if DLL does not exist, or has no DllUnregisterServer
    export.

--*/
{
    HRESULT hr = E_FAIL;
    HMODULE hMod;
    FARPROC fp;

    hMod = LoadLibraryW(szServerName);
    if (hMod) {

        fp = GetProcAddress(hMod, "DllUnregisterServer");
        if (fp) {
            hr = (HRESULT) (*fp)();
        }
        FreeLibrary(hMod);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
CSandbox::SafeGetClassObject(
    REFCLSID rclsid,
    DWORD dwClsContext,
    LPVOID reserved,
    REFIID riid,
    IUnknown **pObj
    )
/*++

Routine Description:

    Implements a Safe version of OLE32's CoGetClassObject()

Arguments:

    See CoGetClassObject

Return Value:

    HRESULT

--*/
{
    HRESULT hr;
    BOOL fIsUntrusted;

    if (!pObj)
    {
        return E_INVALIDARG;
    }

    *pObj = NULL;

    hr = CoGetClassObject(rclsid,
                          dwClsContext,
                          reserved,
                          riid,
                          (void **)pObj);


    return hr;
}


HRESULT STDMETHODCALLTYPE
CSandbox::SafeCreateInstance(
    REFCLSID rclsid,
    LPUNKNOWN pUnkOuter,
    DWORD dwClsContext,
    REFIID riid,
    IUnknown **pObj
    )
/*++

Routine Description:

    Implements a Safe version of OLE32's CoCreateInstance()

Arguments:

    See CoCreateInstance

Return Value:

    HRESULT

--*/
{
    HRESULT hr;
    BOOL fIsUntrusted;


    if (!pObj)
    {
        return E_INVALIDARG;
    }

    *pObj = NULL;
 
        hr = CoCreateInstance(rclsid,
                              pUnkOuter,
                              dwClsContext,
                              riid,
                              (void **)pObj);

    return hr;
}


CSandbox::CSandbox()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    None

--*/
{
    m_RefCount = 1;
}



HRESULT GetRestrictedSids(
    LPCWSTR pszSite,
    SID_AND_ATTRIBUTES *pSidToRestrict,
    ULONG *pCount)
{
    HRESULT hr = S_OK;

#ifndef _CHICAGO_
    ULONG   i = 0;
    long error;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
 
    *pCount = 0;

    pSidToRestrict[0].Attributes = 0;
    pSidToRestrict[1].Attributes = 0;
    pSidToRestrict[2].Attributes = 0;


    //Get the site SID.
    pSidToRestrict[i].Sid = GetSiteSidFromUrl(pszSite);
    if(pSidToRestrict[i].Sid)
    {
        i++;
    }
    else
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }


    //Get the zone SID.

    //Get the restricted SID.
    error = RtlAllocateAndInitializeSid(&NtAuthority,
                                        1,
                                        SECURITY_RESTRICTED_CODE_RID,
                                        0, 0, 0, 0, 0, 0, 0,
                                        &pSidToRestrict[i].Sid);
    if(!error)
    {
        i++;
    }
    else
    {
        hr =  HRESULT_FROM_WIN32( GetLastError() );
    }
    if(FAILED(hr))
    {
        return hr;
    }


    *pCount = i;

#endif // _CHICAGO_
    return hr;
}

class CActiveXSafetyProvider : public IActiveXSafetyProvider {
public:
    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    // IActiveXSafetyProvider methods
    HRESULT STDMETHODCALLTYPE TreatControlAsUntrusted(BOOL fTreatAsUntrusted);
    HRESULT STDMETHODCALLTYPE IsControlUntrusted(BOOL *pfTreatAsUnrusted);
    HRESULT STDMETHODCALLTYPE SetSecurityManager(IInternetSecurityManager *p);
    HRESULT STDMETHODCALLTYPE SetDocumentURLA(LPCSTR szDocumentURL);
    HRESULT STDMETHODCALLTYPE SetDocumentURLW(LPCWSTR szDocumentURL);
    HRESULT STDMETHODCALLTYPE ResetToDefaults(void);
    HRESULT STDMETHODCALLTYPE SafeDllRegisterServerA(LPCSTR szServerName);
    HRESULT STDMETHODCALLTYPE SafeDllRegisterServerW(LPCWSTR szServerName);
    HRESULT STDMETHODCALLTYPE SafeDllUnregisterServerA(LPCSTR szServerName);
    HRESULT STDMETHODCALLTYPE SafeDllUnregisterServerW(LPCWSTR szServerName);
    HRESULT STDMETHODCALLTYPE SafeGetClassObject(
                                    REFCLSID rclsid,
                                    DWORD dwClsContext,
                                    LPVOID reserved,
                                    REFIID riid,
                                    IUnknown **pObj);
    HRESULT STDMETHODCALLTYPE SafeCreateInstance(
                                    REFCLSID rclsid,
                                    LPUNKNOWN pUnkOuter,
                                    DWORD dwClsContext,
                                    REFIID riid,
                                    IUnknown **pObj);

    // constructor/destructor
    CActiveXSafetyProvider();
    ~CActiveXSafetyProvider();

    // private members
    ULONG       m_RefCount;
    LPOLESTR    m_szDocumentURL;
    IInternetSecurityManager *m_pSecurityManager;
    BOOL        m_fTreatAsUntrusted;
    SID_AND_ATTRIBUTES SidToRestrict[3];
    ULONG              RestrictedSidCount;
    COSERVERINFO2      serverInfo;
    COSERVERINFO *     pServerInfo;
};



class CClassFactory : public IClassFactory {
public:
    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    // IClassFactory methods
    HRESULT STDMETHODCALLTYPE CreateInstance(IUnknown *punkOuter,
                                    REFIID riid,
                                    PVOID *ppvObject);
    HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock);

    // constructor/destructor
    CClassFactory();
    ~CClassFactory();

    // private members
    ULONG m_RefCount;
};


HRESULT STDMETHODCALLTYPE
CActiveXSafetyProvider::QueryInterface(
    REFIID riid,
    void **ppvObject
    )
/*++

Routine Description:

    Implements QI, only supports QIs for IUnknown

Arguments:

    riid        - interface to query for
    ppvObject   - pointer to result, set to NULL on failure

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IActiveXSafetyProvider) ||
        IsEqualIID(riid, IID_IUnknown)) {

        *ppvObject = (PVOID *)this;
        AddRef();
        hr = S_OK;

    } else {
        hr = E_NOINTERFACE;
    }

    return hr;
}


ULONG STDMETHODCALLTYPE
CActiveXSafetyProvider::AddRef(
    void
    )
/*++

Routine Description:

    Bump our refcount

Arguments:

    none

Return Value:

    the new refcount

--*/
{
    return InterlockedIncrement((LONG *)&m_RefCount);
}


ULONG STDMETHODCALLTYPE
CActiveXSafetyProvider::Release(
    void
    )
/*++

Routine Description:

    Lower our refcount, when it hits zero, free this instance

Arguments:

    none

Return Value:

    the new refcount

--*/
{
    ULONG Count = InterlockedDecrement((LONG *)&m_RefCount);

    if (Count == 0) {
        delete this;
    }
    return Count;
}


HRESULT STDMETHODCALLTYPE
CActiveXSafetyProvider::TreatControlAsUntrusted(
    BOOL fTreatAsUntrusted
    )
/*++

Routine Description:

    Selects whether subsequent Safe... calls treat the control as
    trusted or untrusted.

Arguments:

    fTreatAsUntrusted

Return Value:

    HRESULT

--*/
{
    m_fTreatAsUntrusted = fTreatAsUntrusted;
    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CActiveXSafetyProvider::IsControlUntrusted(
    BOOL *pfIsUntrusted
    )
/*++

Routine Description:

    Queries whether subsequent Safe... calls will treat the control as
    trusted or untrusted.

Arguments:

    pfTreatAsUntrusted  - [out] pointer to hold the result

Return Value:

    HRESULT

--*/
{
    if (!pfIsUntrusted) {
        return E_INVALIDARG;
    }
    *pfIsUntrusted = m_fTreatAsUntrusted;

    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CActiveXSafetyProvider::SetSecurityManager(
    IInternetSecurityManager *pSecurityManager
    )
/*++

Routine Description:

    Assocates an IInternetSecurityManager with this Safety Provider.
    trusted or untrusted.

Arguments:

    pSecurityManager

Return Value:

    HRESULT

--*/
{
    // Release the old pointer if there was one
    if (m_pSecurityManager) {
        m_pSecurityManager->Release();
    }

    m_pSecurityManager = pSecurityManager;

    // Prevent the new one from going away while we're holding a pointer to it
    pSecurityManager->AddRef();

    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CActiveXSafetyProvider::SetDocumentURLA(
    LPCSTR szDocumentURL
    )
/*++

Routine Description:

    Assocates the URL of the document about to instantiate the control
    with the Safety Provider

Arguments:

    szDocumentURL

Return Value:

    HRESULT

--*/
{
    LPWSTR szW;
    int len;
    HRESULT hr;

    if (!szDocumentURL) {
        //
        // Caller wants to reset the URL
        //
        return SetDocumentURLW(NULL);
    }

    // Convert to a Unicode string on the stack, assuming the worst-case
    // of 1 Unicode charper Ansi char.
    len = lstrlenA(szDocumentURL)+1;
    szW = (LPWSTR)_alloca(sizeof(WCHAR)*len);
    MultiByteToWideChar(CP_ACP, 0, szDocumentURL, len, szW, len);

    return SetDocumentURLW(szW);
}


HRESULT STDMETHODCALLTYPE
CActiveXSafetyProvider::SetDocumentURLW(
    LPCWSTR szDocumentURL
    )
/*++

Routine Description:

    Assocates the URL of the document about to instantiate the control
    with the Safety Provider

Arguments:

    szDocumentURL

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

#ifndef _CHICAGO_
    ULONG i;

    for(i = 0; i < RestrictedSidCount; i++)
    {
        RtlFreeSid(SidToRestrict[i].Sid);
    }

    RestrictedSidCount = 0;
    pServerInfo = NULL;

    // Release the old pointer if there was one
    if (m_szDocumentURL) {
        PrivMemFree(m_szDocumentURL);
    }

    if (szDocumentURL) {
        int len = (wcslen(szDocumentURL)+1) * sizeof(OLECHAR);

        m_szDocumentURL = (LPOLESTR)PrivMemAlloc(len);
        if (!m_szDocumentURL) {
            return E_OUTOFMEMORY;
        }

        memcpy(m_szDocumentURL, szDocumentURL, len);
        hr = GetRestrictedSids(szDocumentURL, SidToRestrict, &RestrictedSidCount);
        if(SUCCEEDED(hr))
        {
            pServerInfo = (_COSERVERINFO *) &serverInfo;
        }
    } else {
        m_szDocumentURL = NULL;
    }

#endif // _CHICAGO_
    return hr;
}


HRESULT STDMETHODCALLTYPE
CActiveXSafetyProvider::ResetToDefaults(
    void
    )
/*++

Routine Description:

    Resets the Safety Provider's settings back to the way they were when
    the Safety Provider was first created.

Arguments:

    none

Return Value:

    HRESULT

--*/
{
#ifndef _CHICAGO_
    ULONG i;

    for(i = 0; i < RestrictedSidCount; i++)
    {
        RtlFreeSid(SidToRestrict[i].Sid);
    }

    RestrictedSidCount = 0;
    pServerInfo = NULL;

    // Release the old pointer if there was one
    if (m_szDocumentURL) {
        PrivMemFree(m_szDocumentURL);
        m_szDocumentURL = NULL;
    }

    // Release the old pointer if there was one
    if (m_pSecurityManager) {
        m_pSecurityManager->Release();
        m_pSecurityManager = NULL;
    }

    // Treat controls as trusted
    m_fTreatAsUntrusted = FALSE;

#endif // _CHICAGO_
    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CActiveXSafetyProvider::SafeDllRegisterServerA(
    LPCSTR szServerName
    )
/*++

Routine Description:

    Calls a control's DllRegisterServer.  It will be sandboxed if
    the Safety Provider determines it must be.

Arguments:

    szServerName    - dll filename to call DllRegisterServer on

Return Value:

    HRESULT, E_FAIL if DLL does not exist, or has no DllRegisterServer
    export.

--*/
{
    HRESULT hr = E_FAIL;

    if(m_fTreatAsUntrusted)
    {
        IActiveXSafetyProvider *pSandbox;

        //Call CoGetClassObject to start the sandbox
        hr = CoGetClassObject(CLSID_Sandbox,
                              CLSCTX_LOCAL_SERVER,
                              pServerInfo,
                              IID_IActiveXSafetyProvider,
                              (void **)&pSandbox);
        if(SUCCEEDED(hr))
        {
            //Create instance of the class in the sandbox.
            hr = pSandbox->SafeDllRegisterServerA(szServerName);
            pSandbox->Release();
        }
    }
    else
    {
        HMODULE hMod;
        FARPROC fp;

        hMod = LoadLibraryA(szServerName);
        if (hMod)
        {
            fp = GetProcAddress(hMod, "DllRegisterServer");
            if (fp) {
                hr = (HRESULT) (*fp)();
            }
            FreeLibrary(hMod);
        }
    }

    return hr;
}



HRESULT STDMETHODCALLTYPE
CActiveXSafetyProvider::SafeDllRegisterServerW(
    LPCWSTR szServerName
    )
/*++

Routine Description:

    Calls a control's DllRegisterServer.  It will be sandboxed if
    the Safety Provider determines it must be.

Arguments:

    szServerName    - dll filename to call DllRegisterServer on

Return Value:

    HRESULT, E_FAIL if DLL does not exist, or has no DllRegisterServer
    export.

--*/
{
    HRESULT hr = E_FAIL;

    if(m_fTreatAsUntrusted)
    {
        IActiveXSafetyProvider *pSandbox;

        //Call CoGetClassObject to start the sandbox
        hr = CoGetClassObject(CLSID_Sandbox,
                              CLSCTX_LOCAL_SERVER,
                              pServerInfo,
                              IID_IActiveXSafetyProvider,
                              (void **)&pSandbox);
        if(SUCCEEDED(hr))
        {
            //Create instance of the class in the sandbox.
            hr = pSandbox->SafeDllRegisterServerW(szServerName);
            pSandbox->Release();
        }
    }
    else
    {
        HMODULE hMod;
        FARPROC fp;

        hMod = LoadLibraryExW(szServerName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
        if (hMod)
        {
            fp = GetProcAddress(hMod, "DllRegisterServer");
            if (fp)
            {
                hr = (HRESULT) (*fp)();
            }
            FreeLibrary(hMod);
        }
    }

    return hr;
}



HRESULT STDMETHODCALLTYPE
CActiveXSafetyProvider::SafeDllUnregisterServerA(
    LPCSTR szServerName
    )
/*++

Routine Description:

    Calls a control's DllUnregisterServer.  It will be sandboxed if
    the Safety Provider determines it must be.

Arguments:

    szServerName    - dll filename to call DllUnregisterServer on

Return Value:

    HRESULT, E_FAIL if DLL does not exist, or has no DllUnregisterServer
    export.

--*/
{
    HRESULT hr = E_FAIL;

    if(m_fTreatAsUntrusted)
    {
        IActiveXSafetyProvider *pSandbox;

        //Call CoGetClassObject to start the sandbox
        hr = CoGetClassObject(CLSID_Sandbox,
                              CLSCTX_LOCAL_SERVER,
                              pServerInfo,
                              IID_IActiveXSafetyProvider,
                              (void **)&pSandbox);
        if(SUCCEEDED(hr))
        {
            //Create instance of the class in the sandbox.
            hr = pSandbox->SafeDllUnregisterServerA(szServerName);
            pSandbox->Release();
        }
    }
    else
    {
        HMODULE hMod;
        FARPROC fp;

        hMod = LoadLibraryA(szServerName);
        if (hMod)
        {
            fp = GetProcAddress(hMod, "DllUnregisterServer");
            if (fp) {
                hr = (HRESULT) (*fp)();
            }
            FreeLibrary(hMod);
        }
    }

    return hr;
}



HRESULT STDMETHODCALLTYPE
CActiveXSafetyProvider::SafeDllUnregisterServerW(
    LPCWSTR szServerName
    )
/*++

Routine Description:

    Calls a control's DllUnregisterServer.  It will be sandboxed if
    the Safety Provider determines it must be.

Arguments:

    szServerName    - dll filename to call DllUnregisterServer on

Return Value:

    HRESULT, E_FAIL if DLL does not exist, or has no DllUnregisterServer
    export.

--*/
{
    HRESULT hr = E_FAIL;

    if(m_fTreatAsUntrusted)
    {
        IActiveXSafetyProvider *pSandbox;

        //Call CoGetClassObject to start the sandbox
        hr = CoGetClassObject(CLSID_Sandbox,
                              CLSCTX_LOCAL_SERVER,
                              pServerInfo,
                              IID_IActiveXSafetyProvider,
                              (void **)&pSandbox);
        if(SUCCEEDED(hr))
        {
            //Create instance of the class in the sandbox.
            hr = pSandbox->SafeDllUnregisterServerW(szServerName);
            pSandbox->Release();
        }
    }
    else
    {
        HMODULE hMod;
        FARPROC fp;

        hMod = LoadLibraryExW(szServerName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
        if (hMod)
        {
            fp = GetProcAddress(hMod, "DllRegisterServer");
            if (fp)
            {
                hr = (HRESULT) (*fp)();
            }
            FreeLibrary(hMod);
        }
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE
CActiveXSafetyProvider::SafeGetClassObject(
    REFCLSID rclsid,
    DWORD dwClsContext,
    LPVOID reserved,
    REFIID riid,
    IUnknown **pObj
    )
/*++

Routine Description:

    Implements a Safe version of OLE32's CoGetClassObject()

Arguments:

    See CoGetClassObject

Return Value:

    HRESULT

--*/
{
    HRESULT hr;

    if (!pObj)
    {
        return E_INVALIDARG;
    }

    *pObj = NULL;

    if (m_fTreatAsUntrusted)
    {
        IActiveXSafetyProvider *pSandbox;

        //Call CoGetClassObject to start the sandbox
        hr = CoGetClassObject(CLSID_Sandbox,
                              CLSCTX_LOCAL_SERVER,
                              pServerInfo,
                              IID_IActiveXSafetyProvider,
                              (void **)&pSandbox);
        if(SUCCEEDED(hr))
        {
            //Load the class into the sandbox.
            hr = pSandbox->SafeGetClassObject(rclsid, dwClsContext, reserved, riid, pObj);
            pSandbox->Release();
        }
    }
    else
    {
        hr = CoGetClassObject(rclsid,
                              dwClsContext,
                              reserved,
                              riid,
                              (void **)pObj);
    }


    return hr;
}


HRESULT STDMETHODCALLTYPE
CActiveXSafetyProvider::SafeCreateInstance(
    REFCLSID rclsid,
    LPUNKNOWN pUnkOuter,
    DWORD dwClsContext,
    REFIID riid,
    IUnknown **pObj
    )
/*++

Routine Description:

    Implements a Safe version of OLE32's CoCreateInstance().
    We don't call CoCreateInstance directly because it
    requires a DllSurrogate entry in the registry.

Arguments:

    See CoCreateInstance

Return Value:

    HRESULT

--*/
{
    HRESULT hr;
    BOOL fIsUntrusted;


    if (!pObj)
    {
        return E_INVALIDARG;
    }

    *pObj = NULL;
 
    if (m_fTreatAsUntrusted)
    {
        IActiveXSafetyProvider *pSandbox;

        //Call CoGetClassObject to start the sandbox
        hr = CoGetClassObject(CLSID_Sandbox,
                              CLSCTX_LOCAL_SERVER,
                              pServerInfo,
                              IID_IActiveXSafetyProvider,
                              (void **)&pSandbox);
        if(SUCCEEDED(hr))
        {
            //Create instance of the class in the sandbox.
            hr = pSandbox->SafeCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, pObj);
            pSandbox->Release();
        }
    }
    else
    {
        hr = CoCreateInstance(rclsid,
                              pUnkOuter,
                              dwClsContext,
                              riid,
                              (void **)pObj);
    }

    return hr;
}


CActiveXSafetyProvider::CActiveXSafetyProvider()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    None

--*/
{
    m_RefCount = 1;
    m_szDocumentURL = NULL;
    m_pSecurityManager = NULL;
    m_fTreatAsUntrusted = FALSE;
    RestrictedSidCount = 0;

    memset(&serverInfo, 0, sizeof(serverInfo));
    serverInfo.dwFlags = SRVINFO_F_COSERVERINFO2;
    serverInfo.pRestrictedSids = SidToRestrict;
    pServerInfo = NULL;

    InterlockedIncrement((LONG *)&DllRefCount);
}


CActiveXSafetyProvider::~CActiveXSafetyProvider()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{
#ifndef _CHICAGO_
    ULONG i;

    for(i = 0; i < RestrictedSidCount; i++)
    {
        RtlFreeSid(SidToRestrict[i].Sid);
    }

    RestrictedSidCount = 0;
    pServerInfo = NULL;

    if (m_szDocumentURL) {
        PrivMemFree(m_szDocumentURL);
    }
    if (m_pSecurityManager) {
        m_pSecurityManager->Release();
    }
       
    InterlockedDecrement((LONG *)&DllRefCount);
#endif // _CHICAGO_
}







STDAPI
CClassFactory::QueryInterface(
    REFIID riid,
    void **ppvObject
    )
/*++

Routine Description:

    Implements QI, only supports QIs for IUnknown and IActiveXSafetyProvider

Arguments:

    riid        - interface to query for
    ppvObject   - pointer to result, set to NULL on failure

Return Value:

    HRESULT

--*/
{
    HRESULT hr;

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {

        *ppvObject = this;
        AddRef();
        hr = S_OK;

    } else {
        hr = E_NOINTERFACE;
    }

    return hr;
}


ULONG STDMETHODCALLTYPE
CClassFactory::AddRef(
    void
    )
/*++

Routine Description:

    Bump our refcount

Arguments:

    none

Return Value:

    the new refcount

--*/
{
    return InterlockedIncrement((LONG *)&m_RefCount);
}


ULONG STDMETHODCALLTYPE
CClassFactory::Release(
    void
    )
/*++

Routine Description:

    Lower our refcount, when it hits zero, free this instance

Arguments:

    none

Return Value:

    the new refcount

--*/
{
    ULONG Count = InterlockedDecrement((LONG *)&m_RefCount);

    if (Count == 0) {
        delete this;
    }
    return Count;
}


HRESULT STDMETHODCALLTYPE
CClassFactory::CreateInstance(
    IUnknown *punkOuter,
    REFIID riid,
    PVOID *ppvObject
    )
/*++

Routine Description:

    Get the thread's IActiveXSafetyProvider.

Arguments:

    punkOuter   - [optional] controlling unknown
    riid        - interface ID to create
    ppvObject   - [out] pointer to place to store the new object

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_OUTOFMEMORY;

#ifndef _CHICAGO_
    COleTls tls;

    *ppvObject = NULL;

    if (punkOuter) {
        //
        // Aggregation not supported
        //
        return E_INVALIDARG;
    }

    if(!tls->punkActiveXSafetyProvider)
    {
        tls->punkActiveXSafetyProvider = new CActiveXSafetyProvider;
    }
 
    if (tls->punkActiveXSafetyProvider) {
        hr = tls->punkActiveXSafetyProvider->QueryInterface(riid, ppvObject);
    }

#endif // _CHICAGO_
    return hr;
}


HRESULT STDMETHODCALLTYPE
CClassFactory::LockServer(
    BOOL fLock
    )
/*++

Routine Description:

    Lock or unlock the inproc server in memory.

Arguments:

    fLock   - should we lock or unlock

Return Value:

    HRESULT

--*/
{
    if (fLock) {
        InterlockedIncrement((LONG *)&DllRefCount);
    } else {
        InterlockedDecrement((LONG *)&DllRefCount);
    }
    return S_OK;
}


CClassFactory::CClassFactory()
/*++

Routine Description:

    Constructor

Arguments:

    none

Return Value:

    none

--*/
{
    InterlockedIncrement((LONG *)&DllRefCount);
    m_RefCount = 1;
}


CClassFactory::~CClassFactory()
/*++

Routine Description:

    Destructor

Arguments:

    none

Return Value:

    none

--*/
{
    InterlockedDecrement((LONG *)&DllRefCount);
}



extern "C"
STDAPI
SandboxDllGetClassObject(
    REFCLSID clsid,
    REFIID iid,
    LPVOID FAR *ppv
    )
/*++

Routine Description:

    Called by OLE to create a new object

Arguments:

    clsid   - class ID of object to create
    iid     - interface ID of the object to create
    ppv     - destination to store the newly-created object

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_OUTOFMEMORY;
    IUnknown *pCF;
    LPFNGETCLASSOBJECT pfnDllGetClassObject;

    *ppv = NULL;

    if (IsEqualCLSID(clsid, CLSID_IActiveXSafetyProvider)) {

        pCF = new CClassFactory;

        if (pCF) {
            hr = pCF->QueryInterface(iid, ppv);
            pCF->Release();
        }

    } else if(IsEqualCLSID(clsid, CLSID_Sandbox)) {
        //We are loading the helper class into the surrogate.
        pCF = new CSandbox;

        if (pCF) {
            hr = pCF->QueryInterface(iid, ppv);
            pCF->Release();
        }
    } else {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}

HRESULT RegisterClass(
    IN LPCWSTR   pszClassID, 
    IN LPCWSTR   pszClassName OPTIONAL,
    IN LPCWSTR   pszDllFileName,
    IN LPCWSTR   pszThreadingModel OPTIONAL)

/*++

Routine Description:
    Creates a registry entry for an in-process server class.

Arguments:
    pszClassID          - Supplies the class ID.
    pszClassName        - Supplies the class name.  May be NULL.
    pszDllFileName      - Supplies the DLL file name.
    pszThreadingModel   - Supplies the threading model. May be NULL.
                          The threading model should be one of the following:
                          "Apartment", "Both", "Free".

Return Value:
    S_OK

See Also:
    NdrDllRegisterProxy  
    NdrpUnregisterClass

--*/ 
{
    HRESULT hr;
    long error;
    HKEY hKeyCLSID;
    HKEY hKeyClassID;
    HKEY hKey;
    DWORD dwDisposition;

    //create the CLSID key
    error = RegCreateKeyExW(HKEY_CLASSES_ROOT, 
                           L"CLSID",
                           0, 
                           L"REG_SZ", 
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           0,
                           &hKeyCLSID,
                           &dwDisposition);

    if(!error)
    {  
        //Create registry key for class ID 
        error = RegCreateKeyExW(hKeyCLSID, 
                                pszClassID,
                                0, 
                                L"REG_SZ", 
                                REG_OPTION_NON_VOLATILE,
                                KEY_WRITE,
                                0,
                                &hKeyClassID,
                                &dwDisposition);

        if(!error)
        {
            //Create InProcServer32 key for the proxy dll
            error = RegCreateKeyExW(hKeyClassID, 
                                   L"InProcServer32",
                                   0, 
                                   L"REG_SZ", 
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_WRITE,
                                   0,
                                   &hKey,
                                   &dwDisposition);

            if(!error)
            {
                //register the proxy DLL filename
                error = RegSetValueExW(hKey, 
                                      L"", 
                                      0, 
                                      REG_SZ,  
                                      (const unsigned char *)pszDllFileName,
                                      (lstrlenW(pszDllFileName) + 1) * sizeof(WCHAR));

                if((!error) && (pszThreadingModel != 0))
                {
                    //register the threading model for the proxy DLL.
                    error = RegSetValueExW(hKey, 
                                          L"ThreadingModel", 
                                          0, 
                                          REG_SZ, 
                                          (const unsigned char *)pszThreadingModel,
                                          (lstrlenW(pszThreadingModel) + 1) * sizeof(WCHAR));
                }

                RegCloseKey(hKey);
            }

            if((!error) && (pszClassName != 0))
            {
    	        // put the class name in an unnamed value
                error = RegSetValueExW(hKeyClassID, 
                                      L"", 
                                      0, 
                                      REG_SZ, 
                                      (const unsigned char *)pszClassName,
                                      (lstrlenW(pszClassName) + 1) * sizeof(WCHAR));
            }


            if((!error))
            {
    	        // Set the AppID
                error = RegSetValueExW(hKeyClassID, 
                                      L"AppID", 
                                      0, 
                                      REG_SZ, 
                                      (const unsigned char *)pszClassID,
                                      (lstrlenW(pszClassID) + 1) * sizeof(WCHAR));
            }
            RegCloseKey(hKeyClassID);          
        }

        RegCloseKey(hKeyCLSID);
    }

    if(!error)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(error);

    return hr;
}

STDAPI SandboxDllRegisterServer(void)
/*++

Routine Description:
    Creates registry entries for the ActiveXSandbox class.

Return Value:
    S_OK

--*/ 
{
    HRESULT hr = S_OK;

#ifndef _CHICAGO_
    WCHAR   szDllFileName[MAX_PATH];
    ULONG   length;
    HKEY hKeyCLSID;
    DWORD dwDisposition;

    if(!g_hmodOLE2)
        return E_HANDLE;

    //Get the proxy dll name.
    length = GetModuleFileName(g_hmodOLE2,
                               szDllFileName,
                               sizeof(szDllFileName));

    if(length > 0)
    {
        //Register the ActiveX Safety Provider.
        hr = RegisterClass(TEXT("{aaf8c6ce-f972-11d0-97eb-00aa00615333}"),
                               TEXT("ActiveX Safety Provider"),
                               szDllFileName,
                               TEXT("Both"));
    
        //Register the ActiveX Sandbox
        hr = RegisterClass(TEXT("{0708cc6b-8ba5-11d1-a835-00805f850fc6}"),
                           TEXT("ActiveX Sandbox"),
                           szDllFileName,
                           TEXT("Both"));

        //Register the AppID
        if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
			TEXT("AppID\\{0708cc6b-8ba5-11d1-a835-00805f850fc6}"), 
			NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, 
			&hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

	if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ, (BYTE*) TEXT("ActiveX Sandbox"), 
	    sizeof(TEXT("ActiveX Sandbox")))!= ERROR_SUCCESS) 
	{
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}
	
	if (RegSetValueEx(hKeyCLSID, TEXT("DLLSurrogate"), NULL, REG_SZ, (BYTE*) TEXT(""),  
	    sizeof(TEXT("")))!= ERROR_SUCCESS) 
	{
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}

    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

#endif // _CHICAGO_
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\smstg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	smstg.cxx
//
//  Contents:	Implementation for class to handle marshaled data as stg.
//
//  Functions:	CSafeMarshaledStg::CSafeMarshaledStg
//		CSafeMarshaledStg::~CSafeMarshaledStg
//		CSafeStgMarshaled::CSafeStgMarshaled
//		CSafeStgMarshaled::~CSafeStgMarshaled
//
//  History:	14-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
#include <ole2int.h>

#include    <xmit.hxx>
#include    <smstg.hxx>


//+-------------------------------------------------------------------------
//
//  Member:	CSafeMarshaledStg::CSafeMarshaledStg
//
//  Synopsis:	Create an IStorage from a marshaled buffer
//
//  Arguments:	[pIFD] - marshaled interface pointer
//
//  Algorithm:	If pointer is not NULL, then unmarshal the interface.
//		If the interface cannot be unmarshaled throw an error.
//
//  History:	14-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
CSafeMarshaledStg::CSafeMarshaledStg(InterfaceData *pIFD, HRESULT&hr)
    : _pstg(NULL)
{
    if (pIFD != NULL)
    {
	// Turn raw marshaled data into a stream
	CXmitRpcStream xrpc(pIFD);


	// Unmarshal data into an interface
	hr = CoUnmarshalInterface(&xrpc, IID_IStorage, (void **) &_pstg);
    }
    else
    {
	hr = S_OK;
    }
}




//+-------------------------------------------------------------------------
//
//  Member:	CSafeMarshaledStg::~CSafeMarshaledStg
//
//  Synopsis:	Release an IStorage that this class created
//
//  History:	14-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
CSafeMarshaledStg::~CSafeMarshaledStg(void)
{
    if (_pstg)
    {
	_pstg->Release();
    }
}




//+-------------------------------------------------------------------------
//
//  Member:	CSafeStgMarshaled::CSafeStgMarshaled
//
//  Synopsis:	Create a marshaled interface from an IStorage
//
//  Arguments:	[pstg] - IStorage to marshal
//
//  History:	14-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
CSafeStgMarshaled::CSafeStgMarshaled(IStorage *pstg, DWORD dwDestCtx, HRESULT& hr)
    : _pIFD(NULL)
{
    if (pstg != NULL)
    {
	// Turn raw interface into marshaled data
	CXmitRpcStream xrpc;

	if (SUCCEEDED(hr = CoMarshalInterface(&xrpc, IID_IStorage, pstg,
	    dwDestCtx, NULL, MSHLFLAGS_NORMAL)))
	{
	    // Hand of the serialized interface so we can use it
	    xrpc.AssignSerializedInterface(&_pIFD);
	}
    }
    else
    {
	hr = S_OK;
    }
}




//+-------------------------------------------------------------------------
//
//  Member:	CSafeStgMarshaled::~CSafeStgMarshaled
//
//  Synopsis:	Release marshaled data
//
//  History:	14-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
CSafeStgMarshaled::~CSafeStgMarshaled(void)
{
    if (_pIFD)
    {
	delete _pIFD;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\rot\access.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	    access.cxx
//
//  Contents:   Methods used for building a security descriptor.
//
//  History:    02-May-94 DonnaLi    Created
//              05-Nov-97 MikeW      Variable # of sids support
//
//--------------------------------------------------------------------------
extern "C"
{
#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <ntseapi.h>
#include    <windows.h>
}

#include <ole2int.h>
#include    <rpc.h>
#include    <except.hxx>

#include    <memapi.hxx>
#include    <access.hxx>

#ifndef _CHICAGO_

extern PSID psidMySid;

//+-------------------------------------------------------------------------
//
//  Member:     CAccessInfo::~CAccessInfo
//
//  Synopsis:   Clean up buffers allocated for building the security
//              descriptor
//
//  History:    08-Jun-94 DonnaLi    Created
//
//--------------------------------------------------------------------------
CAccessInfo::~CAccessInfo (
    void
    )
{
    if (_pAbsoluteSdBuffer != NULL)
    {
        PrivMemFree (_pAbsoluteSdBuffer);
    }

    if (_pDace != NULL && _pDace != (PACCESS_ALLOWED_ACE)&_aDace[0])
    {
        PrivMemFree (_pDace);
    }

}
    
//+-------------------------------------------------------------------------
//
//  Member:	    CAccessInfo::IdentifyAccess
//
//  Synopsis:   Build a security descriptor that identifies who has what
//              access
//
//  Arguments:  [fScmIsOwner]   - whether SCM is the owner
//              [AppAccessMask] - access mask for the OLE application
//              [ScmAccessMask] - access mask for the SCM
//
//  Returns:    NULL - an error has occurred
//              ~NULL - pointer to the resulting security descriptor
//
//  History:    08-Jun-94 DonnaLi    Created
//
//--------------------------------------------------------------------------
PSECURITY_DESCRIPTOR
CAccessInfo::IdentifyAccess (
    BOOL        fScmIsOwner,
    ACCESS_MASK AppAccessMask,
    ACCESS_MASK ScmAccessMask
    )
{
    PSID        sids[2];
    ACCESS_MASK masks[2];

    sids[0] = _pAppSid;
    sids[1] = psidMySid;

    masks[0] = AppAccessMask;
    masks[1] = ScmAccessMask;

    return IdentifyAccessWorker(fScmIsOwner, 2, sids, masks);
}

PSECURITY_DESCRIPTOR
CAccessInfo::IdentifyAccess (
    BOOL                fScmIsOwner,
    ACCESS_MASK         AppAccessMask,
    ACCESS_MASK         ScmAccessMask,
    PSID                pExtraSid,
    ACCESS_MASK         ExtraAccessMask
    )
{
    PSID        sids[3];
    ACCESS_MASK masks[3];

    sids[0] = _pAppSid;
    sids[1] = psidMySid;
    sids[2] = pExtraSid;

    masks[0] = AppAccessMask;
    masks[1] = ScmAccessMask;
    masks[2] = ExtraAccessMask;

    return IdentifyAccessWorker(fScmIsOwner, 3, sids, masks);
}



//+-------------------------------------------------------------------------
//
//  Member:	    CAccessInfo::IdentifyAccessWorker
//
//  Synopsis:   Build a security descriptor that identifies who has what
//              access
//
//  Arguments:  [fScmIsOwner]   -- whether SCM is the owner
//              [cSids]         -- The number of sids & access masks
//              [sids]          -- The sids
//              [masks]         -- The access masks
//
//  Returns:    NULL - an error has occurred
//              ~NULL - pointer to the resulting security descriptor
//
//  History:    08-Jun-94 DonnaLi    Created
//
//--------------------------------------------------------------------------
PSECURITY_DESCRIPTOR
CAccessInfo::IdentifyAccessWorker (
    BOOL            fScmIsOwner,
    UINT            cSids,
    PSID           *sids,
    ACCESS_MASK    *masks
    )
{
    NTSTATUS NtStatus;

    //
    // Pointer to memory dynamically allocated by this routine to hold
    // the absolute security descriptor, the DACL, the SACL, and all the ACEs.
    //

    //
    // A security descriptor is of opaque data type but
    // SECURITY_DESCRIPTOR_MIN_LENGTH is the right size.
    //

    DWORD               dwAbsoluteSdLength = SECURITY_DESCRIPTOR_MIN_LENGTH;
    PACL                lpDacl = NULL; // Pointer to DACL portion of sid buffer
    ULONG               dwSize;

    UINT                i;
    ULONG               cbSids[16];     // Arbitrarily large size
    ULONG               cbMaxSidLength;

    Win4Assert(cSids < (sizeof(cbSids) / sizeof(cbSids[0])));

    //
    // Compute the total size of the DACL and SACL ACEs and the maximum
    // size of any ACE.
    //
    
    dwSize = 0;
    cbMaxSidLength = 0;

    for (i = 0; i < cSids; i++)
    {
        cbSids[i] = RtlLengthSid(sids[i]);
        dwSize += cbSids[i];
        cbMaxSidLength = max(cbMaxSidLength, cbSids[i]);
    }

    dwSize += sizeof(ACL) + cSids * sizeof(ACCESS_ALLOWED_ACE);

    dwAbsoluteSdLength += dwSize;

    _pAbsoluteSdBuffer = (PSECURITY_DESCRIPTOR) PrivMemAlloc (
                dwAbsoluteSdLength
                );

    if (_pAbsoluteSdBuffer == NULL)
    {
        return NULL;
    }

    //
    // Initialize the Dacl and Sacl
    //

    lpDacl = (PACL)((PCHAR)_pAbsoluteSdBuffer + SECURITY_DESCRIPTOR_MIN_LENGTH);

    NtStatus = RtlCreateAcl (lpDacl, dwSize, ACL_REVISION);

    if (!NT_SUCCESS(NtStatus))
    {
        return NULL;
    }

    //
    // Get a buffer big enough for the biggest ACE.
    //

    dwSize = cbMaxSidLength + sizeof(ACCESS_ALLOWED_ACE);

    if (dwSize <= DACE_BUFFER_LENGTH)
    {
        _pDace = (PACCESS_ALLOWED_ACE)&_aDace[0];
    }
    else
    {
        _pDace = (PACCESS_ALLOWED_ACE) PrivMemAlloc (dwSize);

        if (_pDace == NULL)
        {
            return NULL;
        }
    }

    //
    // Initialize each ACE, and append it onto the end of the DACL.
    //

    for (i = 0; i < cSids; i++)
    {
        _pDace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
        _pDace->Header.AceSize = (USHORT)(cbSids[i] + sizeof(ACCESS_ALLOWED_ACE));
        _pDace->Header.AceFlags = 0;
        _pDace->Mask = masks[i];

        NtStatus = RtlCopySid (
            cbSids[i],                          //  ULONG  DestinationSidLength
            &(_pDace->SidStart),                //  PSID   DestinationSid
            sids[i]                             //  PSID   SourceSid
            );

        if (!NT_SUCCESS(NtStatus))
        {
            return NULL;
        }

        NtStatus = RtlAddAce(
            lpDacl,                                //  PACL   Acl
            ACL_REVISION,                          //  ULONG  AceRevision
            MAXULONG,                              //  ULONG  StartingAceIndex
            _pDace,                                //  PVOID  AceList
            cbSids[i] + sizeof(ACCESS_ALLOWED_ACE) //  ULONG  AceListLength
            );

        if (!NT_SUCCESS(NtStatus))
        {
            return NULL;
        }
    }

    //
    // Create the security descriptor with absolute pointers to SIDs
    // and ACLs.
    //
    // Owner = Sid of SCM
    // Group = Sid of SCM
    // Dacl  = lpDacl
    // Sacl  = nothing
    //

    NtStatus = RtlCreateSecurityDescriptor (
        _pAbsoluteSdBuffer,           // PSECURITY_DESCRIPTOR SecurityDescriptor
        SECURITY_DESCRIPTOR_REVISION  // ULONG                Revision
        );

    if (!NT_SUCCESS(NtStatus))
    {
        return NULL;
    }

    if (fScmIsOwner)
    {
        NtStatus = RtlSetOwnerSecurityDescriptor (
            _pAbsoluteSdBuffer,       // PSECURITY_DESCRIPTOR SecurityDescriptor
            psidMySid,                // PSID                 Owner
            FALSE                     // BOOLEAN              OwnerDefaulted
            );

        if (!NT_SUCCESS(NtStatus))
        {
            return NULL;
        }

        NtStatus = RtlSetGroupSecurityDescriptor (
            _pAbsoluteSdBuffer,       // PSECURITY_DESCRIPTOR SecurityDescriptor
            psidMySid,                // PSID                 Group
            FALSE                     // BOOLEAN              GroupDefaulted
            );

        if (!NT_SUCCESS(NtStatus))
        {
            return NULL;
        }
    }

    NtStatus = RtlSetDaclSecurityDescriptor (
        _pAbsoluteSdBuffer,           // PSECURITY_DESCRIPTOR SecurityDescriptor
        TRUE,                         // BOOLEAN              DaclPresent
        lpDacl,                       // PACL                 Dacl
        FALSE                         // BOOLEAN              DaclDefaulted
        );

    if (!NT_SUCCESS(NtStatus))
    {
        return NULL;
    }

    NtStatus = RtlSetSaclSecurityDescriptor (
        _pAbsoluteSdBuffer,           // PSECURITY_DESCRIPTOR SecurityDescriptor
        FALSE,                        // BOOLEAN              SaclPresent
        NULL,                         // PACL                 Sacl
        FALSE                         // BOOLEAN              SaclDefaulted
        );

    if (!NT_SUCCESS(NtStatus))
    {
        return NULL;
    }

    return _pAbsoluteSdBuffer;
}


#endif // _CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\svrholdr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       svrholdr.cxx
//
//  Contents:   Methods for classes implementing a server holder
//
    //  Note: if this code is not used for the "Server Handler" then the
    //  routines should be renamed to "Server Holder" or something.
//
//  Functions:
//              CServerHandlerHolder::CServerHandlerHolder
//              CServerHandlerHolder::~CServerHandlerHolder
//              CServerHandlerHolder::AddRef
//              CServerHandlerHolder::Release
//              CServerHandlerHolder::QueryInterface
//              CServerHandlerHolder::ReadRegistryList
//
//  History:    08-Oct-96 BChapman  Created
//
//--------------------------------------------------------------------------


#include <ole2int.h>



typedef struct tagServerHandlerIID {    // Hungarian prefix = "shi"
    IID iid;
    CLSID clsid;
} ServerHandlerIID;

typedef struct tagLiveServerHandler {   // Hungarian prefix = "lsh"
    IUnknown *punk;     // controlling unknown of the Server Handler Object.
    void *pv;           // pointer to the listed interface for that Server Handler.
    int ishil;          // index to ServerHandlerIID list (for GUID information)
} LiveServerHandler;


class CServerHandlerHolder: public IUnknown
{
    friend HRESULT STDAPICALLTYPE CoCreateServerHandlerHolder(IUnknown *,
                                                    REFCLSID,
                                                    IUnknown **);

public:
    CServerHandlerHolder(IUnknown *punkOuter);
    ~CServerHandlerHolder();

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void**ppv);

private:
    ULONG m_cRef;
    IUnknown *m_punkOuter;
    ServerHandlerIID *m_pshiList;
    ULONG m_cSHIDs;
    LiveServerHandler *m_plshList;

    HRESULT ReadRegistryList(REFCLSID rclsid);

};


//+-------------------------------------------------------------------------
//
//  Function:   CoCreateServerHandlerHolder, public
//
//  Synopsis:   Creates an internal COM object that will load and hold
//              server handlers as described in the registry.
//
//  History:    02-Oct-96   BChapman  Created
//
//--------------------------------------------------------------------------

INTERNAL CoCreateServerHandlerHolder(
        IUnknown *punkOuter,
        REFCLSID rclsid,
        IUnknown **ppSHHolder)
{
    CServerHandlerHolder *pSHH;
    HRESULT hr;

    *ppSHHolder = NULL;
    if(NULL == (pSHH = new CServerHandlerHolder(punkOuter)))
    {
        return E_OUTOFMEMORY;
    }

    if(S_OK != (hr = pSHH->ReadRegistryList(rclsid)))
    {
        return hr;
    }

    *ppSHHolder = pSHH;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////
//  CServerHandlerHolder object.
/////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//  Function:   CServerHandlerHolder (ctor)
//
//  History:    02-Oct-96   BChapman  Created
//--------------------------------------------------------------------------

CServerHandlerHolder::CServerHandlerHolder(IUnknown *punkOuter)
{
    m_punkOuter = punkOuter;
    m_cRef = 0;
    m_pshiList = NULL;
    m_plshList = NULL;
    m_cSHIDs = 0;
}

//+-------------------------------------------------------------------------
//  Function:   CServerHandlerHolder::AddRef
//
//  History:    02-Oct-96   BChapman  Created
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CServerHandlerHolder::AddRef()
{
    InterlockedIncrement((LONG*)&m_cRef);
    return m_cRef;
}

//+-------------------------------------------------------------------------
//
//  Function:   CServerHandlerHolder::Release
//
//  Synopsis:   On last release, release all the server handler.  Then
//              delete this object.
//
//  History:    02-Oct-96   BChapman  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CServerHandlerHolder::Release()
{
    ULONG i;
    ULONG cRef = m_cRef - 1;

    if(0 != InterlockedDecrement((LONG*)&m_cRef))
        return cRef;

    //
    // release all live server handlers.
    //
    for(i=0; i<m_cSHIDs; i++)
    {
        if(NULL != m_plshList[i].punk)
            m_plshList[i].punk->Release();
    }
    delete this;
    return 0;
}


//+-------------------------------------------------------------------------
//
//  Function:   CServerHandlerHolder (destructor)
//
//  Synopsis:   Free the memory the object might have.
//
//  History:    02-Oct-96   BChapman  Created
//
//--------------------------------------------------------------------------

CServerHandlerHolder::~CServerHandlerHolder()
{
    if(NULL != m_pshiList)
        PrivMemFree(m_pshiList);

    if(NULL != m_plshList)
        PrivMemFree(m_plshList);
}

//+-------------------------------------------------------------------------
//
//  Function:   CServerHandlerHolder::QueryInterface
//
//  Synopsis:   This object has two tables.
//          The first "m_pshiList" (ServerHandler IID List) is a list of
//      IID, CLSID pairs.  This is a list of all the inproc servers this
//      object can load.
//          The second table "m_plshList" (Live Server Handler List) is a
//      list of punk, pv, index_into_pshiList tuples.  This is a list of
//      the inproc server instances that are loaded.
//          We rely on the DllCache to prevent multiple requests for the
//      same DLL with different IDD's from loading it multiple times.
//
//  History:    02-Oct-96   BChapman  Created
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServerHandlerHolder::QueryInterface(REFIID riid, void **ppv)
{
    ULONG i;
    HRESULT hr;

    //
    //  First return any Live Server Handler for that IID, if we have one.
    //
    for(i=0; i<m_cSHIDs; i++)
    {
        int ishil;   // index into the ServerHandler IID List;

        if(NULL != m_plshList[i].punk)
        {
            ishil = m_plshList[i].ishil;
            if(IsEqualGUID(riid, m_pshiList[ishil].iid))
            {
                *ppv = m_plshList[i].pv;
                return S_OK;
            }
        }
    }

    //
    // Is this IID on our list of things we can load?
    //
    for(i=0; i<m_cSHIDs; i++)
    {
        if(IsEqualGUID(riid, m_pshiList[i].iid))
            break;
    }
    if(i < m_cSHIDs)
    {
        // YES.  It was found on the ServerHandler IID List.
        // So now we need to start a new Server Handler.

        IUnknown *punk;
        void *pv;

        if(S_OK != (hr = CoCreateInstance(m_pshiList[i].clsid,
                                            m_punkOuter,
                                            CLSCTX_INPROC | CLSCTX_NO_CODE_DOWNLOAD,
                                            IID_IUnknown,
                                            (void**)&punk)))
        {
            return hr;
        }
        if(S_OK != (hr = punk->QueryInterface(riid, &pv)))
        {
            punk->Release();
            return hr;
        }
        //
        // find an empty slot in the Live Server Handler List.
        //
        for(i=0; i<m_cSHIDs; i++)
        {
            if(NULL == m_plshList[i].punk)
                break;
        }
        Win4Assert(i < m_cSHIDs);
        m_plshList[i].ishil = i;
        m_plshList[i].punk = punk;
        m_plshList[i].pv = pv;

        *ppv = pv;

        return S_OK;
    }
    else
    {
        // NO.  It was NOT found on the ServerHandler IID List.
        // This is where blind delegation to all running server
        // handlers.  (why just the running servers?)

        // Decided not to do Blind delegation.
    }
    return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////
//////////////////  internal methods of CServerHandlerHolder ////////
/////////////////////////////////////////////////////////////////////

typedef struct tagSHEntry {          // Hungarian prefix = "tshe"
    ServerHandlerIID shi;
    tagSHEntry * pNext;
} TempServerHandlerEntry;

#define AllocA(type) (type*) _alloca(sizeof(type));

//+-------------------------------------------------------------------------
//
//  Function:   CServerHandlerHolder::ReadRegistryList, private
//
//  Synopsis:   Return E_READREGDB if we can't read the Key.  Bad values
//          under the key are sliently skipped.
//              Each valid value is stored in a linked list of AllocA'ed
//          elements.  After all the values are read the list is counted,
//          real heap memory is allocated and the linked list is copied
//          into a table.  The Live Server Handler table is also allocated
//          and cleared at that time.
//
//  History:    02-Oct-96   BChapman  Created
//
//--------------------------------------------------------------------------

HRESULT
CServerHandlerHolder::ReadRegistryList(REFCLSID rclsid)
{
    int err, index;
    HRESULT hr;
    HKEY hkey = 0;
    WCHAR szName[KEY_LEN];
    WCHAR szValue[KEY_LEN];
    BYTE pValue[MAX_PATH+1];
    TempServerHandlerEntry *ptsheCurrent;
    TempServerHandlerEntry *ptsheHead=NULL, *ptsheTail=NULL;

    //
    // Get an Open Key to:
    //      HKEY_CLASSES_ROOT\CLSID\{..clsid..}\ServerHandler32
    //
    if(S_OK != (hr = wRegOpenClassSubkey(rclsid, L"ServerHandler32", &hkey)))
        return hr;

    //
    // Enumerate all the Name=Value pairs under ServerHandler32.
    //
    for(index=0; ;index++)
    {
        DWORD cbName = KEY_LEN;
        DWORD cbValue = KEY_LEN;
        DWORD regtype;
        ServerHandlerIID shiScratch;

        err = RegEnumValue(hkey,        // key we are reading
                            index,      // value index number
                            szName,     // buffer to recieve the Name
                            &cbName,    // size of the name buffer
                            NULL,       // RESERVED
                            &regtype,   // [out] value type
                            pValue,     // buffer for the value
                            &cbValue);  // size of the value buffer.

        if(ERROR_NO_MORE_ITEMS == err)
            break;

        if(ERROR_SUCCESS != err)
        {   // go on to the next entry.
            continue;
        }

        if(REG_SZ != regtype)
        {   // go on to the next entry.
            continue;
        }

        //
        // On Win95 convert the value from ANSI to Unicode, on NT it is already
        // Unicode so just copy it.  RegEnumValue didn't convert the Value for
        // us because the Value argument of the Reg API is not always a string.
#ifdef _CHICAGO_
        MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, (char*)pValue, -1, szValue, KEY_LEN);
#else
        memmove(szValue, pValue, 2*(lstrlen((WCHAR*)pValue) + 1) );
#endif

        //
        //   If the IID and CLSID decode correctly into the Scratch "shi",
        // then add them to the linked list of "Temp Server Handler Entries".
        //
        if( S_OK == IIDFromString(szName, &shiScratch.iid)
            && S_OK == CLSIDFromString(szValue, &shiScratch.clsid) )
        {
            // Build a new list element.
            //
            ptsheCurrent = AllocA(TempServerHandlerEntry);
            ptsheCurrent->pNext= NULL;
            ptsheCurrent->shi = shiScratch;
            //
            // Setup the list control pointers (the first time)
            //
            if(NULL == ptsheHead)
            {
                // Build an empty "head" element
                ptsheHead = AllocA(TempServerHandlerEntry);
                ptsheTail = ptsheHead;
            }
            //
            //  Add Current element to the end.
            //
            ptsheTail->pNext = ptsheCurrent;
            ptsheTail = ptsheCurrent;
        }
    }

    m_cSHIDs = 0;
    if(NULL == ptsheHead)
    {
        RegCloseKey(hkey);
        return S_OK;
    }

    //
    // Consolidate the linked list of Entries into one alloc'ed buffer
    //

    // count the entries.
    ptsheCurrent=ptsheHead->pNext;
    while(NULL != ptsheCurrent)
    {
        ++m_cSHIDs;
        ptsheCurrent = ptsheCurrent->pNext;
    }

    // allocate the buffers for the IID list and the Live Handler List.
    m_pshiList = (ServerHandlerIID*) PrivMemAlloc(
                                    sizeof(ServerHandlerIID) * m_cSHIDs);
    m_plshList = (LiveServerHandler*) PrivMemAlloc(
                                    sizeof(LiveServerHandler) * m_cSHIDs);

    if(NULL == m_pshiList || NULL == m_plshList)
    {
        if(NULL != m_pshiList)
            PrivMemFree(m_pshiList);
        if(NULL != m_plshList)
            PrivMemFree(m_plshList);
        RegCloseKey(hkey);
        return E_OUTOFMEMORY;
    }

    ULONG i;

    // Copy the linked list into the buffer.
    ptsheCurrent=ptsheHead->pNext;
    for(i=0; i<m_cSHIDs; i++)
    {
        m_pshiList[i] = ptsheCurrent->shi;
        ptsheCurrent = ptsheCurrent->pNext;
    }

    // Clear the Live Server Handler Table.
    for(i=0; i<m_cSHIDs; i++)
    {
        m_plshList[i].ishil = 0;
        m_plshList[i].punk = NULL;
        m_plshList[i].pv = NULL;
    }

    RegCloseKey(hkey);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\cairo\cgpiex.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       cobjact.cxx
//
//  Contents:   Functions that activate objects residing in persistent storage.
//
//  Functions:  CoGetPersistentInstanceEx
//
//  History:    30jun-94  MikeSe    Created
//
//--------------------------------------------------------------------------
#include <ole2int.h>

#include    <iface.h>
#include    <objsrv.h>
#include    <compname.hxx>
#include    "resolver.hxx"
#include    "smstg.hxx"
#include    "objact.hxx"

// We use this to calculate the hash value for the path
extern DWORD CalcFileMonikerHash(LPWSTR pwszPath);

// imported function from cobject.cxx
extern BOOL UnmarshalSCMResult( HRESULT& hr, InterfaceData *pIFD,
				REFCLSID rclsid, REFIID riid, void **ppvUnk,
                                DWORD dwDllThreadModel, WCHAR *pwszDllPath,
                                void **ppvCf);

//+-------------------------------------------------------------------------
//
//  Function:   CoGetPersistentInstanceEx
//
//  Synopsis:   Returns an instantiated interface to an object whose
//      	stored state resides on disk.
//
//  Arguments:	[riid] - interface to bind object to
//		[dwCtrl] - kind of server required
//		[grfMode] - how to open the storage if it is a file.
//		[pwszName] - name of storage if it is a file.
//		[pstg] - IStorage to use for object
//		[pclsidOverride]
//		[ppvUnk] - where to put bound interface pointer
//
//  Returns:    S_OK - object bound successfully
//      MISSING
//
//  Notes:	BUGBUGBUGBUG This is all temporary stuff, providing Cairo
//		required functionality during the period when the bureaucrats
//		won't allow even trivial changes to Dayton source code. This
//		will disappear post-Daytona, when the final spec for
//		CoGetPersistentInstance is agreed.
//
//--------------------------------------------------------------------------

STDAPI CoGetPersistentInstanceEx (
    REFIID riid,
    DWORD dwCtrl,
    DWORD grfMode,
    WCHAR *pwszName,
    struct IStorage *pstg,
    CLSID * pclsidOverride,
    void **ppvUnk)
{
    TRACECALL(TRACE_ACTIVATION, "CoGetPersistentInstanceEx");
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStorage,(IUnknown **)&pstg);

    if (!IsApartmentInitialized())
        return  CO_E_NOTINITIALIZED;

    IClassFactory *pcf = NULL;
    WCHAR *pwszDllPath = NULL;
    InterfaceData *pIFD = NULL;
    IUnknown *punk = NULL;
    WCHAR awcNameBuf[MAX_PATH];
    WCHAR *pwszNameUNC = awcNameBuf;
    WCHAR awcServer[MAX_PATH];
    WCHAR *pwszServer = awcServer;
    DWORD dwDllServerType = !FreeThreading ? APT_THREADED : FREE_THREADED;
    DWORD dwHash = 0;

    HRESULT hr;

    BEGIN_BLOCK

       // Make sure input request is at least slightly logical
       if (((pstg != NULL) && (pwszName != NULL))
            || ((pstg == NULL) && (pwszName == NULL))
#ifdef WX86OLE
           || ((dwCtrl & ~(CLSCTX_SERVER | CLSCTX_INPROC_SERVERX86)) != 0))
#else
           || ((dwCtrl & ~CLSCTX_SERVER) != 0))
#endif
       {
           hr = E_INVALIDARG;
           EXIT_BLOCK;
       }

       CLSID clsid;
       if (pwszName)
       {
           // If there is a path supplied convert it to a normalized form
           // so it can be used by any process in the net.
           hr = ProcessPath(pwszName, &pwszNameUNC, &pwszServer);

           if (FAILED(hr))
           {
	       EXIT_BLOCK;
           }

           // Limit on loops for retrying to get class of object
           DWORD cGetClassRetries = 0;

           // We loop here looking for either the running object or
           // for the class of the file. We do this because there
           // are race conditions where the can be starting or stopping
           // and the class of the object might not be available because
           // of the opening mode of the object's server.
           do
           {
		// Look in the ROT first to see if we need to bother
		// looking up the class of the file.
			IUnknown *punk;
	
		if (GetObjectFromRotByPath(pwszName,
                    (IUnknown **) &punk) == S_OK)
		{
		    // Get the requested interface
		    hr = punk->QueryInterface(riid, ppvUnk);
		    punk->Release();
	
		    // Got object from ROT so we are done.
		    return hr;
		}
	
		// Try to get the class of the file
		if ( pclsidOverride != NULL )
		{
		    clsid = *pclsidOverride;
		    hr = S_OK;
		}
	        else
		    hr = GetClassFile(pwszName, &clsid);
	
	
		if (hr == STG_E_ACCESSDENIED)
		{
		    // The point here of the sleep is to try to let the
		    // operation that is holding the class id unavailable
		    // complete.
		    Sleep(GET_CLASS_RETRY_SLEEP_MS);
		    continue;
		}
	
		// Either we succeeded or something other than error
		// access denied occurred here. For all these cases
		// we break the loop.
		break;
	
           } while (cGetClassRetries++ < GET_CLASS_RETRY_MAX);

           if (FAILED(hr))
           {
		EXIT_BLOCK;
           }
       }
       else
       {
           pwszNameUNC = NULL;
           pwszServer = NULL;

	   if ( pclsidOverride == NULL )
	   {
               STATSTG statstg;

               if (FAILED(hr = pstg->Stat(&statstg, STATFLAG_NONAME)))
               {
	           EXIT_BLOCK;
               }

               clsid = statstg.clsid;
	   }
           else
	       clsid = *pclsidOverride;
       }

       GetTreatAs(clsid, clsid);

       // We cache information about in process servers so we look in the
       // cache first in hopes of saving some time.


#ifdef WX86OLE
    // if WX86 is enabled for this process we evaluate the CLSCTX flags
    // to see if we should attempt to get the X86 class before trying to
    // get the Native class.
    pcf = NULL;
    if (gcwx86.IsWx86Enabled() && (dwCtrl & CLSCTX_INPROC_SERVERX86))
    {
        pcf = (IClassFactory *)
           gdllcacheInprocSrv.GetClass(clsid,
                                       IID_IClassFactory,
                                       (pwszServer != NULL),
                                       FALSE, TRUE);
    }
    if (pcf == NULL)
    {
        pcf = (IClassFactory *)
           gdllcacheInprocSrv.GetClass(clsid,
                                       IID_IClassFactory,
                                       (pwszServer != NULL),
                                       FALSE, FALSE);
    }
#else
    pcf = (IClassFactory *)
           gdllcacheInprocSrv.GetClass(clsid,
                                       IID_IClassFactory,
                                       (pwszServer != NULL),
                                       FALSE);
#endif
       if (pcf = NULL)
       {
           // Marshal pstg since SCM can't deal with unmarshaled objects
           CSafeStgMarshaled sms(pstg, MSHCTX_LOCAL, hr);

           if (FAILED(hr))
           {
                EXIT_BLOCK;
           }

           BOOL fExitBlock;
           DWORD cLoops = 0;

           do
           {
               // Forward call to service controller
               hr = gResolver.ActivateObject( clsid, dwCtrl, grfMode,
       				     pwszNameUNC, sms, &pIFD,
				     &dwDllServerType, &pwszDllPath,
                                     pwszServer);

	       fExitBlock = UnmarshalSCMResult(hr, pIFD, clsid, riid, ppvUnk,
		    dwDllServerType, pwszDllPath, (void **) &pcf);


            // If we get something from the ROT, we need to retry until
            // we get an object. Because objects can disappear from the
            // ROT async to us, we need to retry a few times. But since
            // this theoretically could happen forever, we place an arbitrary
            // limit on the number of retries to the ROT.
            } while((hr != NOERROR) && (dwDllServerType == GOT_FROM_ROT)
                && (++cLoops < 5));

            if (fExitBlock)
            {
                EXIT_BLOCK;
            }
       }

       hr = GetObjectHelper(pcf, grfMode, pwszName, pstg, NULL, &punk);

       if (SUCCEEDED(hr))
       {
           hr = punk->QueryInterface(riid, ppvUnk);
       }

    END_BLOCK;

    if (pcf != NULL)
    {
       pcf->Release();
    }

    if (punk != NULL)
    {
       punk->Release();
    }

    // RPC stubs allocated path so we trust that it is null or valid.
    if (pwszDllPath != NULL)
    {
       MyMemFree(pwszDllPath);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   objact
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..;..\..\inc
INCLUDES=     $(INCLUDES);..\..\dcomrem
INCLUDES=     $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\cs\inc
INCLUDES=     $(INCLUDES);..\..\..\actprops
INCLUDES=     $(INCLUDES);..\..\moniker2
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)

SOURCES=      \
              ..\actvator.cxx \
              ..\dllcache.cxx \
              ..\dllhost.cxx  \
              ..\actapi.cxx   \
              ..\dllapi.cxx   \
              ..\dsapi.cxx    \
              ..\objact.cxx   \
              ..\smstg.cxx    \
              ..\sobjact.cxx  \
              ..\mainthrd.cxx \
              ..\defcxact.cxx \
              ..\immact.cxx

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\objact\sobjact.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       sobjact.cxx
//
//  Contents:   Activation Functions used by object servers.
//
//  Functions:  CoRegisterClassObject
//              CoRevokeClassObject
//              CoAddRefServerProcess
//              CoReleaseServerProcess
//              CoSuspendClassObjects
//
//  Classes:    CObjServer
//
//  History:    12-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <iface.h>
#include    <olerem.h>

#include    <cfactory.hxx>
#include    <classmon.hxx>
#include    "resolver.hxx"
#include    "smstg.hxx"
#include    "objact.hxx"
#include    "service.hxx"
#include    <sobjact.hxx>
#include    <comsrgt.hxx>
#include    "defcxact.hxx"

CObjServer *gpMTAObjServer = NULL;
CObjServer *gpNTAObjServer = NULL;
static COleStaticMutexSem g_mxsSingleThreadObjReg;

extern BOOL gAutoInputSync;
extern BOOL gEnableAgileProxies;

//+-------------------------------------------------------------------------
//
//  Function:   GetOrCreateObjServer, internal
//
//  Synopsis:   Helper function to get or create the TLS or global object server.
//              Created to allow Win95 servers to do lazy init.
//
//  Arguments:  [ppObjServer] - where to return the ObjServer pointer
//
//  History:    23-Sep-96 Murthys    Created
//
//--------------------------------------------------------------------------
HRESULT GetOrCreateObjServer(CObjServer **ppObjServer)
{
    HRESULT hr = S_OK;

    // thread safe incase we are in MultiThreaded model.
    COleStaticLock lck(g_mxsSingleThreadObjReg);

    // Make sure an instance of CObjServer exists for this thread.
    // The SCM will call back on it to activate objects.

    *ppObjServer = GetObjServer();

    if (*ppObjServer == NULL)
    {
        // no activation server for this apartment yet, go make one now.

        hr = E_OUTOFMEMORY;
        *ppObjServer = new CObjServer(hr);

        if (FAILED(hr))
        {
            delete *ppObjServer;
            *ppObjServer = NULL;
        }
        else
        {
            // If we want to service OLE1 clients, we need to create the
            // common Dde window now if it has not already been done.
            CheckInitDde(TRUE /* registering server objects */);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoRegisterClassObject, public
//
//  Synopsis:   Register a class object in the requested context
//
//  Arguments:  [rclsid] - class ID
//              [pUnk] - class object
//              [dwContext] - context to register it in
//              [flags] - single/multiple use.
//              [lpdwRegister] - registration cookie
//
//  Returns:    S_OK - object is successfully registered
//
//  Algorithm:  Validate the parmeters. The get the class factory interface.
//              Then add the class object to the list and finally notify
//              the SCM that the service is started.
//
//  History:    12-May-93 Ricksa    Created
//              26-Jul-94 AndyH     #20843 - restarting OLE in the shared WOW
//
//--------------------------------------------------------------------------
STDAPI  CoRegisterClassObject(
    REFCLSID rclsid,
    IUnknown FAR* pUnk,
    DWORD dwContext,
    DWORD flags,
    LPDWORD lpdwRegister)
{
    HRESULT hr;
    CLSID ConfClsid;
#ifdef WX86OLE
    BOOL fContextArgBad;
#endif

    OLETRACEIN((API_CoRegisterClassObject,
        PARAMFMT("rclsid= %I, pUnk= %p, dwContext= %x, flags= %x, lpdwRegister= %p"),
        &rclsid, pUnk, dwContext, flags, lpdwRegister));

    TRACECALL(TRACE_ACTIVATION, "CoRegisterClassObject");

    if (!IsApartmentInitialized())
    {
        hr = CO_E_NOTINITIALIZED;
        goto errRtn;
    }

    // Validate the out parameter
    if (!IsValidPtrOut(lpdwRegister, sizeof(DWORD)))
    {
        CairoleAssert(IsValidPtrOut(lpdwRegister, sizeof(DWORD))  &&
                      "CoRegisterClassObject invalid registration ptr");
        hr = E_INVALIDARG;
        goto errRtn;
    }
    *lpdwRegister = 0;

    // Validate the pUnk
    if (!IsValidInterface(pUnk))
    {
        CairoleAssert(IsValidInterface(pUnk)  &&
                      "CoRegisterClassObject invalid pUnk");
        hr = E_INVALIDARG;
        goto errRtn;
    }

    hr = LookForConfiguredClsid(rclsid, ConfClsid);
    if (FAILED(hr) && (hr != REGDB_E_CLASSNOTREG))
        goto errRtn;


    // Hook the pUnk
    CALLHOOKOBJECT(S_OK,ConfClsid,IID_IClassFactory,&pUnk);

    // Validate context flags
#ifdef WX86OLE
    if (gcwx86.IsWx86Linked())
    {
        fContextArgBad = (dwContext & (~(CLSCTX_ALL | CLSCTX_INPROC_SERVER16 |
                                         CLSCTX_INPROC_SERVERX86) |
                                       CLSCTX_INPROC_HANDLER |
                                       CLSCTX_INPROC_HANDLERX86 |
                                       CLSCTX_NO_CODE_DOWNLOAD));
    } else {
        fContextArgBad = (dwContext & (~(CLSCTX_ALL | CLSCTX_INPROC_SERVER16)
                       | CLSCTX_INPROC_HANDLER | CLSCTX_NO_CODE_DOWNLOAD));
    }
    if (fContextArgBad)
#else
    if ((dwContext & (~(CLSCTX_ALL | CLSCTX_INPROC_SERVER16) |
                      CLSCTX_INPROC_HANDLER | CLSCTX_NO_CODE_DOWNLOAD)) != 0)
#endif
    {
        hr = E_INVALIDARG;
        goto errRtn;
    }

    // Validate flag flags
    if (flags > (REGCLS_SUSPENDED | REGCLS_MULTI_SEPARATE | REGCLS_SURROGATE))
    {
        hr =  E_INVALIDARG;
        goto errRtn;
    }

    if ((flags & REGCLS_SURROGATE) && !(dwContext & CLSCTX_LOCAL_SERVER))
    {
        hr = E_INVALIDARG;
        goto errRtn;
    }


    if (flags & REGCLS_MULTIPLEUSE)
    {
        dwContext |= CLSCTX_INPROC_SERVER;
    }

    if (dwContext & CLSCTX_LOCAL_SERVER)
    {
        BOOL fCreated;
        CObjServer *pObjServer;
        hr = GetOrCreateObjServer(&pObjServer);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    // Put our object in the server table
    hr = CCRegisterServer(ConfClsid, pUnk, dwContext, flags, lpdwRegister);

errRtn:
    OLETRACEOUT((API_CoRegisterClassObject, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoRevokeClassObject, public
//
//  Synopsis:   Revoke a previously registered class object
//
//  Arguments:  [dwRegister] - registration key returned from CoRegister...
//
//  Returns:    S_OK - class successfully deregistered.
//
//  Algorithm:  Ask cache to deregister the class object.
//
//  History:    12-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDAPI  CoRevokeClassObject(DWORD dwRegister)
{
    OLETRACEIN((API_CoRevokeClassObject, PARAMFMT("dwRegister= %x"), dwRegister));

    TRACECALL(TRACE_ACTIVATION, "CoRevokeClassObject");

    HRESULT hr = CO_E_NOTINITIALIZED;

    if (IsApartmentInitialized())
    {
        // Try to revoke the object
        hr = CCRevoke(dwRegister);
    }

    OLETRACEOUT((API_CoRevokeClassObject, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoAddRefServerProcess, public
//
//  Synopsis:   Increments the global per-process server reference count.
//              See CDllCache::AddRefServerProcess for more detail.
//
//  History:    17-Apr-96   Rickhi  Created
//
//--------------------------------------------------------------------------
STDAPI_(ULONG)  CoAddRefServerProcess(void)
{
    return CCAddRefServerProcess();
}

//+-------------------------------------------------------------------------
//
//  Function:   CoReleaseServerProcess, public
//
//  Synopsis:   Decrements the global per-process server reference count.
//              See CDllCache::ReleaseServerProcess for more detail.
//
//  History:    17-Apr-96   Rickhi  Created
//
//--------------------------------------------------------------------------
STDAPI_(ULONG)  CoReleaseServerProcess(void)
{
    return CCReleaseServerProcess();
}

//+-------------------------------------------------------------------------
//
//  Function:   CoSuspendClassObjects, public
//
//  Synopsis:   suspends all registered LOCAL_SERVER class objects for this
//              process so that no new activation calls from the SCM will
//              be accepted.
//
//  History:    17-Apr-96   Rickhi  Created
//
//--------------------------------------------------------------------------
STDAPI CoSuspendClassObjects(void)
{
    return CCSuspendProcessClassObjects();
}

//+-------------------------------------------------------------------------
//
//  Function:   CoResumeClassObjects, public
//
//  Synopsis:   resumes all registered LOCAL_SERVER class objects for this
//              process that are currently marked as SUSPENDED, so that new
//              activation calls from the SCM will now be accepted.
//
//  History:    17-Apr-96   Rickhi  Created
//
//--------------------------------------------------------------------------
STDAPI CoResumeClassObjects(void)
{
    return CCResumeProcessClassObjects();
}

//+-------------------------------------------------------------------
//
//  Member:     ObjactThreadUninitialize
//
//  Synopsis:   Cleans up the CObjServer object.
//
//  History:    10 Apr 95   AlexMit     Created
//
//--------------------------------------------------------------------
STDAPI_(void) ObjactThreadUninitialize(void)
{
    CObjServer *pObjServer = GetObjServer();
    if (pObjServer != NULL)
    {
        delete pObjServer;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   NotifyActivation
//
//  Synopsis:   Add/Remove implicit IClassFactory::LockServer during marshal
//              and last external release of an interface pointer.
//
//  Arguments:  [fLock] - whether to Lock or Unlock
//              [pUnk]  - ptr to object interface
//
//  Returns:    TRUE  - call again during last release
//              FALSE - dont call again during last release
//
//  History:    12-May-96   RickHi  Created
//
//  Notes:  there is an inherent race condition in the IClassFactory (and
//          derived interfaces) in that between the time a client gets the
//          ICF pointer and the time they call LockServer(TRUE), a server could
//          shut down. In order to plug this hole, COM's activation code will
//          attempt to do an implicit LockServer(TRUE) on the server side of
//          CoGetClassObject during the marshaling of the class object
//          interface. Since we dont know for sure that it is IClassFactory
//          being marshaled, we QI for it here.
//
//--------------------------------------------------------------------------
INTERNAL_(BOOL) NotifyActivation(BOOL fLock, IUnknown *pUnk)
{
    ComDebOut((DEB_ACTIVATE, "NotifyActivation fLock:%x pUnk:%x\n", fLock, pUnk));

    // If the object supports IClassFactory, do an implicit LockServer(TRUE)
    // on behalf of the client when the interface is first marshaled by
    // CoGetClassObject. When the last external reference to the interface is
    // release, do an implicit LockServer(FALSE).

    IClassFactory *pICF = NULL;
    if (SUCCEEDED(pUnk->QueryInterface(IID_IClassFactory, (void **)&pICF)))
    {
        pICF->LockServer(fLock);
        pICF->Release();
        return TRUE;
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoRegisterSurrogate, public
//
//  Synopsis:   Register an ISurrogate interface for a surrogate process
//
//  Arguments:  [pSurrogate] - existing ISurrogate interface ponter
//
//  Returns:    S_OK - object is successfully registered
//
//  Algorithm:  Validate the parameter. Then set a global pointer to the
//              value of the pSurrogate parameter
//
//  History:    2-Jun-96 t-AdamE    Created
//
//--------------------------------------------------------------------------
STDAPI  CoRegisterSurrogate(ISurrogate* pSurrogate)
{
    HRESULT hr;

    OLETRACEIN((API_CoRegisterSurrogate,
        PARAMFMT("pSurrogate= %p"),
        pSurrogate));

    TRACECALL(TRACE_ACTIVATION, "CoRegisterSurrogate");

    gAutoInputSync = TRUE;
    gEnableAgileProxies = TRUE;

    if (!IsApartmentInitialized())
    {
        hr = CO_E_NOTINITIALIZED;
        goto errRtn;
    }

    // Validate the pSurrogate
    if (!IsValidInterface(pSurrogate))
    {
        CairoleAssert(IsValidInterface(pSurrogate)  &&
                      "CoRegisterSurrogate invalid pSurrogate");
        hr = E_INVALIDARG;
        goto errRtn;
    }

    hr = CCOMSurrogate::InitializeISurrogate(pSurrogate);

errRtn:
    OLETRACEOUT((API_CoRegisterSurrogate, hr));

    return hr;
}


#if 0
//+-------------------------------------------------------------------
//
//  Member:     CObjServer::CObjServer, public
//
//  Synopsis:   construction
//
//  History:    10 Apr 95    AlexMit     Created
//
//--------------------------------------------------------------------
CObjServer::CObjServer(HRESULT &hr)
{
    _hr = MarshalInternalObjRef(_objref, IID_IObjServer,
                                (IObjServer*) this, MSHLFLAGS_NOPING, NULL);
    if (SUCCEEDED(_hr))
    {
        SetObjServer(this);
    }

    hr = _hr;

    ComDebOut((DEB_ACTIVATE, "CObjServer::CObjServer _hr:%x\n", _hr));
}

//+-------------------------------------------------------------------
//
//  Member:     CObjServer::~CObjServer, public
//
//  Synopsis:   dtor for activation object
//
//  History:    19 Jun 95   Rickhi      Created
//
//--------------------------------------------------------------------
CObjServer::~CObjServer()
{
    if (SUCCEEDED(_hr))
    {
        // only do RMD if the marshall was sucessfull
        SetObjServer(NULL);
        _hr = ReleaseMarshalObjRef(_objref);
        Win4Assert(SUCCEEDED(_hr));
        FreeObjRef(_objref);
    }

    ComDebOut((DEB_ACTIVATE, "CObjServer::~CObjServer _hr:%x\n", _hr));
}

//+-------------------------------------------------------------------
//
//  Member:     CObjServer::AddRef, public
//
//  Synopsis:   we dont refcnt this object so this is a noop
//
//  History:    10 Apr 95    AlexMit     Created
//
//--------------------------------------------------------------------
ULONG CObjServer::AddRef(void)
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CObjServer::Release, public
//
//  Synopsis:   we dont refcnt this object so this is a noop
//
//  History:    10 Apr 95    AlexMit     Created
//
//--------------------------------------------------------------------
ULONG CObjServer::Release(void)
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CObjServer::QueryInterface, public
//
//  Synopsis:   returns supported interfaces
//
//  History:    10 Apr 95   AlexMit     Created
//
//--------------------------------------------------------------------
STDMETHODIMP CObjServer::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IObjServer) ||  //   more common than IUnknown
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IObjServer *) this;
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CObjServer::ObjectServerGetClassObject
//
//--------------------------------------------------------------------------
STDMETHODIMP CObjServer::ObjectServerGetClassObject(
    GUID *guidCLSID,
    IID *pIID,
    BOOL fSurrogate,
    MInterfacePointer **ppIFD,
    DWORD * pStatus)
{
    ComDebOut((DEB_ACTIVATE,
       "CObjServer::ObjectServerGetClassObject clsid:%I\n", &guidCLSID));

    *pStatus = RPC_S_OK;

    // Check access.
    if (!CheckObjactAccess())
    {
        return HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }

    HRESULT hr;
    IUnknown *pcf;

    // Get the class object
    ACTIVATION_PROPERTIES ap(*guidCLSID, (fSurrogate ? IID_IClassFactory : *pIID) ,
                             (ACTIVATION_PROPERTIES::fFOR_SCM |
                              (fSurrogate ? ACTIVATION_PROPERTIES::fSURROGATE : 0) |
                              ACTIVATION_PROPERTIES::fDO_NOT_LOAD),
                             CLSCTX_LOCAL_SERVER,
                             0,
                             NULL,
                             &pcf);
    hr = CCGetOrLoadClass(ap);

    if (SUCCEEDED(hr))
    {
        // We got the class object, create a buffer and marshal it for return.
        // Marshal it NORMAL and turn on the NotifyActivation flag so we can
        // add an implicit LockServer during marshaling to plug inherent races
        // in the IClassFactory protocol.

        hr = MarshalHelper(pcf, *pIID,
                           MSHLFLAGS_NORMAL | MSHLFLAGS_NOTIFYACTIVATION,
                           (InterfaceData**) ppIFD);
    }

    ComDebOut((DEB_ACTIVATE,
        "CObjServer::ObjectServerGetClassObject hr:%x\n", hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjServer::ObjectServerCreateInstance
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjServer::ObjectServerCreateInstance(
            /* [in] */ GUID *rclsid,
            /* [in] */ DWORD flags,
            /* [in] */ DWORD dwInterfaces,
            /* [size_is][in] */ IID *pIIDs,
            /* [size_is][out] */ MInterfacePointer **ppIFDs,
            /* [size_is][out] */ HRESULT *pResults,
            /* [out] */ DWORD * pStatus )
{
    ComDebOut((DEB_ACTIVATE,
       "CObjServer::ObjectServerCreateInstance clsid:%I\n", rclsid));

    *pStatus = RPC_S_OK;

    // Check access.
    if (!CheckObjactAccess())
    {
        return HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }

    HRESULT hr;
    IUnknown *pcf;

    // Get the class object
    ACTIVATION_PROPERTIES ap(*rclsid, IID_IClassFactory,
                             ACTIVATION_PROPERTIES::fFOR_SCM |
                             ACTIVATION_PROPERTIES::fDO_NOT_LOAD,
                             CLSCTX_LOCAL_SERVER,
                             0,
                             NULL,
                             &pcf);
    hr = CCGetOrLoadClass(ap);

    if (SUCCEEDED(hr))
    {
        // first, check if the server is willing to accept the incoming call
        // on IClassFactory. The reason we need this is that EXCEL's message
        // filter rejects calls on IID_IClassFactory if it is busy. They dont
        // know about IID_IObjServer.
        hr = HandleIncomingCall(IID_IClassFactory, 3,
                                CALLCAT_SYNCHRONOUS,
                                (void *)pcf);
        if (SUCCEEDED(hr))
        {
            // Load the object
#ifdef SERVER_HANDLER
            if (flags & CREATE_EMBEDDING_SERVER_HANDLER)
            {
                hr = GetEmbeddingServerHandlerInterfaces((IClassFactory *)pcf,
                                                    flags,
                                                    dwInterfaces,
                                                    pIIDs,
                                                    ppIFDs,
                                                    pResults,
                                                    NULL);
            }
            else
#endif // SERVER_HANDLER
            {
                hr = GetInstanceHelperMulti((IClassFactory *)pcf,
                                                dwInterfaces,
                                                pIIDs,
                                                ppIFDs,
                                                pResults,
                                                NULL);
            }
        }
        pcf->Release();
    }


    ComDebOut((DEB_ACTIVATE,
       "CObjServer::ObjectServerCreateInstance hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CObjServer::ObjectServerGetInstance
//
//--------------------------------------------------------------------------
STDMETHODIMP CObjServer::ObjectServerGetInstance(
            /* [in] */ GUID *rclsid,
            /* [in] */ DWORD grfMode,
            /* [unique][string][in] */ WCHAR *pwszPath,
            /* [unique][in] */ MInterfacePointer *pIFDstg,
            /* [in] */ DWORD Interfaces,
            /* [size_is][in] */ IID *pIIDs,
            /* [unique][in] */ MInterfacePointer *pIFDFromROT,
            /* [size_is][out] */ MInterfacePointer **ppIFDs,
            /* [size_is][out] */ HRESULT *pResults,
            /* [out] */ DWORD * pStatus )
{
    ComDebOut((DEB_ACTIVATE, "ObjectServerGetInstance clsid:%I\n", rclsid));
    HRESULT hr = S_OK;

    *pStatus = RPC_S_OK;

    // Check access.
    if (!CheckObjactAccess())
    {
        return HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }

    if (pIFDFromROT != NULL)
    {
        // If the SCM has passed us an object from the ROT, we
        // try to use that first by unmarshalling it and then
        // marshaling it normal.
        CXmitRpcStream xrpcForUnmarshal((InterfaceData*)pIFDFromROT);
        IUnknown *punk;

        hr = CoUnmarshalInterface(&xrpcForUnmarshal, IID_IUnknown,
            (void **) &punk);

        if (SUCCEEDED(hr))
        {
            hr = E_NOINTERFACE;

            for ( DWORD i = 0; i < Interfaces; i++ )
            {
                // Stream to put marshaled interface in
                CXmitRpcStream xrpc;
                HRESULT hr2;

                // use DIFFERENTMACHINE so we get the long form OBJREF
                hr2 = CoMarshalInterface(&xrpc, pIIDs[i], punk,
                    SetMarshalContextDifferentMachine(), NULL, MSHLFLAGS_NORMAL);

                if (SUCCEEDED(hr2))
                {
                    // Report OK if any interface is found.
                    hr = hr2;
                    xrpc.AssignSerializedInterface((InterfaceData **) &ppIFDs[i]);
                }
                pResults[i] = hr2;
            }
            // Don't need the unknown ptr any more
            punk->Release();

            ComDebOut((DEB_ACTIVATE, "ObjectServerGetInstance hr:%x\n", hr));
            return hr;
        }

        // Assume any errors are the result of a stale entry in the ROT
        // so we just fall into the regular code path from here.
        hr = S_OK;
    }

    CSafeMarshaledStg smstg( (InterfaceData*) pIFDstg, hr);

    if (FAILED(hr))
    {
        return hr;
    }

    // Get the class object
    IUnknown *pcf = NULL;
    ACTIVATION_PROPERTIES ap(*rclsid, IID_IClassFactory,
                             ACTIVATION_PROPERTIES::fFOR_SCM |
                             ACTIVATION_PROPERTIES::fDO_NOT_LOAD,
                             CLSCTX_LOCAL_SERVER,
                             0,
                             NULL,
                             &pcf);
    hr = CCGetOrLoadClass(ap);

    if (SUCCEEDED(hr))
    {
        // first, check if the server is willing to accept the incoming call
        // on IClassFactory. The reason we need this is that EXCEL's message
        // filter rejects calls on IID_IClassFactory if it is busy. They dont
        // know about IID_IObjServer.
        hr = HandleIncomingCall(IID_IClassFactory, 3,
                                CALLCAT_SYNCHRONOUS,
                                (void *)pcf);
        if (SUCCEEDED(hr))
        {
            // Load the object
            hr = GetObjectHelperMulti((IClassFactory *)pcf, grfMode, NULL,
                pwszPath, smstg, Interfaces, pIIDs, ppIFDs, pResults, NULL);
        }
        pcf->Release();
    }

    ComDebOut((DEB_ACTIVATE, "ObjectServerGetInstance hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CObjServer::ObjectServerLoadDll
//
//  Synopsis:   Loads the requested dll into a surrogate process which
//              implements the ISurrogate interface
//
//--------------------------------------------------------------------------
STDMETHODIMP CObjServer::ObjectServerLoadDll(
            /* [in] */ GUID *rclsid,
            /* [out] */ DWORD* pStatus)
{
    ComDebOut((DEB_ACTIVATE, "ObjectServerLoadDll clsid:%I\n", rclsid));

    *pStatus = RPC_S_OK;

    HRESULT hr = CCOMSurrogate::LoadDllServer(*rclsid);

    ComDebOut((DEB_ACTIVATE, "ObjectServerLoadDll hr:%x\n", hr));
    return hr;
}
#endif //0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\rot\caller.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	    callinfo.cxx
//
//  Contents:   Methods used for identifying the RPC caller.
//
//  History:    02-May-94 DonnaLi    Created
//
//--------------------------------------------------------------------------
#if !defined(_CHICAGO_)
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
}
#endif

#include <ole2int.h>

#include    <caller.hxx>

#if !defined(_CHICAGO_)
//+-------------------------------------------------------------------------
//
//  Member:     CCallerInfo::~CCallerInfo
//
//  Synopsis:   Clean up token handle and RPC impersonation.
//
//  History:    02-May-94 DonnaLi    Created
//
//--------------------------------------------------------------------------
CCallerInfo::~CCallerInfo (
    void
    )
{
    NTSTATUS    NtStatus;

    if (_hThreadToken != NULL)
    {
        NtStatus = NtClose (_hThreadToken);

        Win4Assert (NT_SUCCESS(NtStatus) && "CCallerInfo::~CCallerInfo");
    }

    if (_fImpersonate)
    {
        NtStatus = RpcRevertToSelf ();

        Win4Assert ((NtStatus == RPC_S_OK) && "CCallerInfo::~CCallerInfo");
    }

    if (_pTokenUser)
    {
        PrivMemFree (_pTokenUser);
    }
}
    
//+-------------------------------------------------------------------------
//
//  Member:	    CCallerInfo::IdentifyCaller
//
//  Synopsis:   Obtain TOKEN_USER information of the RPC caller
//
//  Arguments:  [fSameAsSelf] - whether the caller is in the same process
//                              as the callee
//
//  Returns:    NULL - an error has occurred
//              ~NULL - pointer to TOKEN_USER representing the RPC caller
//
//  History:    02-May-94 DonnaLi    Created
//
//--------------------------------------------------------------------------
PTOKEN_USER
CCallerInfo::IdentifyCaller (
    BOOL        fSameAsSelf
    )
{
    ULONG       ulLength;
    NTSTATUS    NtStatus;

    if (!fSameAsSelf)
    {
        NtStatus = RpcImpersonateClient (NULL);
        if (NtStatus != RPC_S_OK)
        {
            return NULL;
        }
        _fImpersonate = TRUE;

        NtStatus = NtOpenThreadToken (
            NtCurrentThread (),     //  IN  HANDLE      ThreadHandle
            TOKEN_QUERY,            //  IN  ACCESS_MASK DesiredAccess
            TRUE,                   //  IN  BOOLEAN     OpenAsSelf
            &_hThreadToken          //  OUT PHANDLE     TokenHandle
            );
    }
    else
    {
        NtStatus = NtOpenProcessToken (
            NtCurrentProcess (),    //  IN  HANDLE      ProcessHandle
            TOKEN_QUERY,            //  IN  ACCESS_MASK DesiredAccess
            &_hThreadToken          //  OUT PHANDLE     TokenHandle
            );
    }

    if (!NT_SUCCESS(NtStatus))
    {
        return NULL;
    }

    //
    //  TOKEN_QUERY access is needed to retrieve a TOKEN_USER data structure.
    //

    NtStatus = NtQueryInformationToken (
        _hThreadToken,           //  IN  HANDLE      TokenHandle,
        TokenUser,               //  IN  TOKEN_INFORMATION_CLASS 
                                 //                  TokenInformationClass
        (PVOID) _aTokenUser,     //  OUT PVOID       TokenInformation
        TOKEN_USER_BUFFER_LENGTH,                       
                                 //  IN  ULONG       TokenInformationLength
        &ulLength                //  OUT PULONG      ReturnLength
        );

    if (NtStatus == STATUS_BUFFER_TOO_SMALL)
    {
        _pTokenUser = (PTOKEN_USER) PrivMemAlloc (ulLength);

        if (_pTokenUser == NULL)
        {
        return NULL;
        }

        //
        //  TOKEN_USER data structure
        //
        //      SID_AND_ATTRIBUTES  User
        //

        NtStatus = NtQueryInformationToken (
            _hThreadToken,
            TokenUser,
            (PVOID) _pTokenUser,
            ulLength,
            &ulLength
            );
    }

    if (!NT_SUCCESS(NtStatus))
    {
        return NULL;
    }

    NtStatus = NtClose (_hThreadToken);

    if (!NT_SUCCESS(NtStatus))
    {
        return NULL;
    }

    _hThreadToken = NULL;

    if (!fSameAsSelf)
    {
        NtStatus = RpcRevertToSelf ();

        if (NtStatus != RPC_S_OK)
        {
            return NULL;
        }
        _fImpersonate = FALSE;
    }

    if (_pTokenUser != NULL)
    {
        return _pTokenUser;
    }
    else
    {
        return (PTOKEN_USER)&_aTokenUser[0];
    }
}
#endif // !defined(_CHICAGO_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\rot\crothint.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       crothint.cxx
//
//  Contents:   Implementation of CCliRotHintTable class
//
//  History:    27-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------

#if !defined(_CHICAGO_)
extern "C"
{
#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <ntlsa.h>
#include    <ntmsv1_0.h>
#include    <windows.h>
#include    <lmsname.h>
#include    <rpc.h>
#include    <stdio.h>
#include    <memory.h>
#include    <string.h>
#include    <winsvc.h>
}
#endif // !defined(_CHICAGO_)

#include    <ole2int.h>

#if !defined(_CHICAGO_)

#include <caller.hxx>
#include <crothint.hxx>


//+-------------------------------------------------------------------------
//
//  Member:     CCliRotHintTable::GetIndicator
//
//  Synopsis:   Get whether indicator for hash entry is set
//
//  Arguments:  [dwOffset] - offset we are looking for
//
//  Returns:    TRUE - entry is set
//              FALSE - entry is not set
//
//  Algorithm:  If array has not been initialized, then bind to the SCM's
//              shared memory. Then check if the offset into the table is
//              set.
//
//  History:	20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CCliRotHintTable::GetIndicator(DWORD dwOffset)
{
    if (_pbHintArray == NULL)
    {
        // Open the shared memory
        _hSm = OpenSharedFileMapping(
                    ROTHINT_NAME,
                    SCM_HASH_SIZE,
                    (void **) &_pbHintArray);

        // It is OK for this to fail because the hint table doesn't
        // really get created by the SCM until the first registration.
    }

    if (_pbHintArray != NULL)
    {
        return _pbHintArray[dwOffset];
    }

    return FALSE;
}
#endif // !defined(_CHICAGO_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\rot\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME= rot
TARGETPATH= obj
TARGETTYPE= LIBRARY

INCLUDES=   ..\..\..\common\$(DEST_TREE);..\..\..\ih;..;..\..\inc
INCLUDES=   $(INCLUDES);..\..\objact;..\..\dcomrem
INCLUDES=   $(INCLUDES);..\..\..\actprops
INCLUDES=   $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=   $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=   $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)

SOURCES=    \
            ..\access.cxx   \
            ..\caller.cxx   \
            ..\crot.cxx     \
            ..\crothint.cxx \
            ..\getif.cxx

UMTYPE=     windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\rot\crot.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       rot.cxx
//
//  Contents:   methods for implementation of ROT
//
//  Functions:
//
//
//  History:    11-Nov-92 Ricksa    Created
//              25-Mar-94 brucema   #8914  CRunningObjectTable::Register
//                                   uninited variable
//              25-Mar-94           #10736  Fixed CRotMonikerEnum::Skip to
//                                   return S_OK if skipping remainder of
//                                   enumeration
//              07-Apr-94 brucema   CRunningObjectTable::Register var init
//              24-Jun-94 BruceMa   Validate ROT items when enum'ing
//              11-Jul-94 BruceMa   Marshal moniker enumeration normal
//              28-Jul-94 BruceMa   Memory sift fix
//              09-Jan-95 BruceMa   Single thread ROT creation and enum'ing
//              30-Jan-95 Ricksa    New ROT.
//              15-May-95 BruceMa   Convert DDE ROT requests to UNC-based
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#ifndef DCOM
#include    <epid.hxx>
#endif
#include    <safeif.hxx>
#include    <rothelp.hxx>
#include    <rotdata.hxx>
#include    "crot.hxx"

// Our AppId - this may be set via CoRegisterSurrogateEx or through
// CoInitializeSecurity (if EOAC_APPID is used). If available, we can
// use this in CRunningObjectTable::Register to identify ourselves with
// the SCM rather than relying on our module name, which often isn't unique.
GUID g_AppId = GUID_NULL;


// Semaphore used to protect ROT
COleStaticMutexSem g_RotSem;

// Running object table object
extern CRunningObjectTable *pROT = NULL;


#define MEM_PUB  0          // memory allocated via CoTaskMemAlloc
#define MEM_PRIV 1          // memory allocated via CPrivMemAlloc



//+-------------------------------------------------------------------------
//
//  Member:     GetMonikerCompareBuffer, private
//
//  Synopsis:   Get a buffer appropriate for comparing
//
//  Arguments:  [pmk] - input moniker
//              [pmkeqbuf] - comparison buffer
//              [pfiletime] - time of last change (optional)
//              [pifdMoniker] - output marshaled moniker (optional)
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//  Algorithm:  First reduce the input moniker. Then get the last change
//              time if requested. Then we marshal the reduced moniker if
//              that was requested. Finally, we build the ROT moniker
//              comparison buffer.
//
//  History:    27-Nov-93 Ricksa    Created
//
//  Notes:      This is just a helper that is used to reduce code size.
//
//--------------------------------------------------------------------------
HRESULT GetMonikerCompareBuffer(
    IMoniker *pmk,
    CTmpMkEqBuf *ptmpmkeqbuf,
    FILETIME *pfiletime,
    InterfaceData **ppifdMoniker)
{
    CairoleDebugOut((DEB_ROT, "%p _IN GetMonikerCompareBuffer "
        "( %p , %p, %p , %p )\n", NULL, pmk, ptmpmkeqbuf, pfiletime,
            ppifdMoniker));

    HRESULT hr;

    do {

        CSafeBindCtx sbctx;

        CSafeMoniker smkReduced;

        hr = CreateBindCtx(0, &sbctx);

        if (hr != NOERROR)
        {
            CairoleDebugOut((DEB_ERROR,
                "GetMonikerCompareBuffer CreateBindCtx failed %lX\n", hr));
            break;
        }

        //  reduce the moniker
        hr = pmk->Reduce(sbctx, MKRREDUCE_ALL, NULL, &smkReduced);

        if (FAILED(hr))
        {
            CairoleDebugOut((DEB_ERROR,
                "GetMonikerCompareBuffer IMoniker::Reduce failed %lX\n", hr));
            break;
        }

        if ((IMoniker *) smkReduced == NULL)
        {
            smkReduced.Set(pmk);
        }

        if (pfiletime != NULL)
        {
            // Try to get the time of last change. We ignore the error
            // because this was the original behavior of OLE2.
            smkReduced->GetTimeOfLastChange(sbctx, NULL, pfiletime);
        }

        // Marshal the moniker if so requested
        if (ppifdMoniker != NULL)
        {
            // Stream to put marshaled interface in
            CXmitRpcStream xrpc;

            hr = CoMarshalInterface(&xrpc, IID_IMoniker, smkReduced,
                MSHCTX_NOSHAREDMEM, NULL, MSHLFLAGS_TABLESTRONG);

            if (hr != NOERROR)
            {
                CairoleDebugOut((DEB_ERROR,
                    "GetMonikerCompareBuffer CoMarshalInterface failed %lX\n",
                       hr));
                break;
            }

            xrpc.AssignSerializedInterface(ppifdMoniker);
        }

        hr = BuildRotData(
                sbctx,
                smkReduced,
                ptmpmkeqbuf->GetBuf(),
                ptmpmkeqbuf->GetSize(),
                ptmpmkeqbuf->GetSizeAddr());

    } while (FALSE);

    CairoleDebugOut((DEB_ROT, "%p OUT GetMonikerCompareBuffer "
        "( %lX ) [ %p ] \n", NULL, hr,
            (ppifdMoniker != NULL) ? *ppifdMoniker : NULL));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     ReleaseSCMInterfaceData
//
//  Synopsis:   Release interface data returned by the SCM
//
//  Arguments:  [pifd] - interface data to release
//
//  Algorithm:  Create an RPC stream and then pass that stream to
//              CoReleaseMarshalData to release any AddRefs and then
//              free the memory that the interface data lives in.
//
//  History:    27-Jan-95 Ricksa    Created
//
//  Notes:      This is designed specifically for processing interface
//              data returned by the SCM on Revoke from the ROT.
//
//--------------------------------------------------------------------------
void ReleaseInterfaceData(InterfaceData *pifd, DWORD dwMemType)
{
    CairoleDebugOut((DEB_ROT, "%p _IN ReleaseInterfaceData "
        "( %p )\n", NULL, pifd));

    if (pifd != NULL)
    {
        // Make our interface into a stream
        CXmitRpcStream xrpc(pifd);

        // Tell RPC to release it -- error is for debugging purposes only
        // since if this fails there isn't much we can do about it.
#if DBG == 1
        HRESULT hr =
#endif // DBG

            CoReleaseMarshalData(&xrpc);

#if DBG == 1
        if (hr != NOERROR)
        {
            CairoleDebugOut((DEB_ERROR,
            "ReleaseInterfaceData CoReleaseMarshalData failed: %lx\n", hr));
        }
#endif // DBG == 1

#ifdef DCOM
        if (dwMemType == MEM_PUB)
            CoTaskMemFree(pifd);
        else
            MIDL_user_free(pifd);
#else
        MIDL_user_free(pifd);
#endif // DCOM
    }

    CairoleDebugOut((DEB_ROT, "%p OUT ReleaseInterfaceData ", NULL));
}




//+-------------------------------------------------------------------------
//
//  Member:     CROTItem::~CROTItem
//
//  Synopsis:   Release data connected with the entry
//
//  Algorithm:  Clean up a rot entry by sending a revoke to the SCM for
//              the entry and taking the marshaled interfaces that the
//              SCM returns and releasing the data associated with them.
//
//  History:    20-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
inline CROTItem::~CROTItem(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CROTItem::~CROTItem\n", this));

    // Make sure we are in the correct apt.
    Win4Assert((_hApt == GetCurrentApartmentId())
        && "CROTItem::~CROTItem from wrong apartment");

    // This object is going away so we mark it invalid immediately
    _wItemSig = 0;

    // Place to put returned marshaled interfaces
    InterfaceData *pifdObject = NULL;
    InterfaceData *pifdName = NULL;

    HRESULT hr = gResolver.IrotRevoke(&_scmregkey, TRUE, &pifdObject, &pifdName);

    if (SUCCEEDED(hr))
    {
        if (!_fDontCallApp)
        {
            ReleaseInterfaceData(pifdObject, MEM_PRIV);
            ReleaseInterfaceData(pifdName, MEM_PRIV);
        }
    }
#if DBG == 1
    else
    {
        CairoleDebugOut((DEB_ROT, "Revoke FAILED: %lx\n", hr));
    }
#endif // DBG == 1

    CairoleDebugOut((DEB_ROT, "%p OUT CROTItem::~CROTItem\n", this));
}



//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::Create
//
//  Synopsis:   Create & initialize running object table object
//
//  Returns:    TRUE - ROT created successfully
//              FALSE - an error occurred.
//
//  Algorithm:  Create a new running ROT and check whether the creation
//              was successful.
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CRunningObjectTable::Create(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::Create\n", NULL));

    // Need to synchronize ROT creation in a multithreaded environment
    COleStaticLock lckSem(g_RotSem);

    // The ROT may have been created by now
    if (pROT == NULL)
    {
        // Create running object table
        pROT = new CRunningObjectTable();

#if DBG == 1

        if (pROT == NULL)
        {
            CairoleDebugOut((DEB_ERROR,"Couldn't allocate ROT!\n"));
        }

#endif // DBG == 1

        // Initialize the array of registrations - FALSE means we couldn't
        // allocate the memory.
        if (pROT && !pROT->_afvRotList.SetSize(ROT_DEF_SIZE, ROT_DEF_SIZE))
        {
            CairoleDebugOut((DEB_ERROR,"Couldn't allocate ROT reg array!\n"));
            delete pROT;
            pROT = NULL;
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::Create"
        "( %lX )\n", NULL, (pROT != NULL)));

    return pROT != NULL;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::~CRunningObjectTable
//
//  Synopsis:   Free ROT object
//
//  History:    11-Nov-93 Ricksa    Created
//
//  Notes:      This only occurs at process exit.
//
//--------------------------------------------------------------------------
CRunningObjectTable::~CRunningObjectTable(void)
{
    CairoleDebugOut((DEB_ROT,
        "%p _IN CRunningObjectTable::~CRunningObjectTable\n", this));

    // Get the size of the table
    int cMax = _afvRotList.GetSize();

    // Are there any entries in the table?
    if (cMax != 0)
    {
        CROTItem **pprot = (CROTItem **) _afvRotList.GetAt(0);

        // Clear out all the registrations
        for (int i = 0; i < cMax; i++)
        {
            if (pprot[i] != NULL)
            {
                delete pprot[i];
            }
        }
    }

    CairoleDebugOut((DEB_ROT,
        "%p OUT CRunningObjectTable::~CRunningObjectTable\n", this));
}




//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::QueryInterface
//
//  Synopsis:   Implements QI for the ROT object
//
//  Arguments:  [riid] - requested id
//              [ppvObj] - where to put output object.
//
//  Returns:    S_OK - interface is suppored
//              E_NOINTERFACE - requested interface is not supported
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::QueryInterface "
        "( %p , %p) \n", this, &riid, ppvObj));

    HRESULT hr = S_OK;

    *ppvObj = NULL;

    if ((IsEqualIID(riid, IID_IRunningObjectTable)) ||
        (IsEqualIID(riid, IID_IUnknown)))
    {
        *ppvObj = this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::QueryInterface "
        "( %lX ) [ %p ]\n", this, hr, *ppvObj));

    return hr;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::AddRef
//
//  Synopsis:   Add to reference count
//
//  Returns:    Current reference count
//
//  History:    11-Nov-93 Ricksa    Created
//
//  Notes:      Reference count is ignored with respect to object deletion
//              since this is a system object and does not go away until
//              CoUninitialize is called.
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRunningObjectTable::AddRef()
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::AddRef\n", this));
    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::AddRef\n", this));

    // Since this ignored we just return a non-zero indication
    return 1;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::Release
//
//  Synopsis:   Dec ref count
//
//  Returns:    Current reference count
//
//  History:    11-Nov-93 Ricksa    Created
//
//  Notes:      Reference count is ignored with respect to object deletion
//              since this is a system object and does not go away until
//              CoUninitialize is called.
//
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRunningObjectTable::Release()
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::Release\n", this));
    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::Release\n", this));

    // Since this ignored we just return a non-zero indication
    return 1;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::CleanupApartment
//
//  Synopsis:   Cleans up left-over entries from the ROT when an
//              apartment exits.
//
//  Arguments:  [hApt] - apartment to cleanup
//
//  Algorithm:  Walk through the list local registrations finding each entry
//              that has a matching apartment and remove those entries.  We
//              delete them (for WOW making sure we don't call back to the
//              app).
//
//  History:    24-Jun-94 Rickhi    Created
//              29-Jun-94 AlexT     Don't make yielding calls while holding
//                                  the mutex
//
//--------------------------------------------------------------------------
HRESULT CRunningObjectTable::CleanupApartment(HAPT hApt)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::CleanupApartment"
       "( %lX )\n", this, hApt));

    // Make sure all threads are locked out during lookup
    COleStaticLock lckSem(g_RotSem);

    // Find a spot in the array for the object
    CROTItem **pprotitm = (CROTItem **) _afvRotList.GetAt(0);

    for (int i = 0; i < _afvRotList.GetSize(); i++)
    {
        CROTItem *protitm = pprotitm[i];

        if ((protitm != NULL)
            && (protitm->GetAptId() == hApt))
        {
            // Clean up the entry
            pprotitm[i] = NULL;

            if (IsWOWThread())
            {
                //  16-bit OLE didn't clean up stale entries;  we remove
                //  them from the ROT but we don't call back to the
                //  application.  Who knows what the application might do
                //  if we called them - they already have a missing Revoke.
                protitm->DontCallApp();
            }

            delete protitm;
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::CleanupApartment"
       "( %lX )\n", this, S_OK));

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::Register
//
//  Synopsis:   Register an item in the ROT
//
//  Arguments:  [grfFlags] - whether registration keeps object alive
//              [punkObject] - object to register
//              [pmkObjectName] - moniker for object to register
//              [pdwRegister] - id for revoke
//
//  Algorithm:  Validate parameters input. Then create the moniker to register,
//              the comparison buffer and the marshaled moniker to put in the
//              ROT. Then marshal the object to put in the ROT. Create a
//              new local ROT item and reserve a space for it in our local
//              table. Send registration to the SCM and exit.
//
//  History:    11-Nov-93 Ricksa    Created
//              26-Jul-94 AndyH     #20843 - restarting OLE in the shared WOW
//              27-Jan-94 Ricksa    New ROT
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::Register(
    DWORD grfFlags,
    LPUNKNOWN punkObject,
    LPMONIKER pmkObjectName,
    DWORD FAR* pdwRegister)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::Register"
       "( %lX , %p , %p , %p )\n", this, grfFlags, punkObject, pmkObjectName,
           pdwRegister));

    COleTls Tls;
    CROTItem *protitm = NULL;
    HRESULT hr = S_OK;

    // Place to keep marshaled moniker buffer
    InterfaceData *pifdMoniker = NULL;

    // Where to put pointer to marshaled object
    InterfaceData *pifdObject = NULL;

    // Where to put the new ROT registration - set so an invalid
    // value to tell error exit whether it needs to be cleaned up
    DWORD idwPutItem = 0xFFFFFFFF;

    do {

        // If we want to service OLE1 clients, we need to create the
        // common Dde window now if it has not already been done.
        CheckInitDde(TRUE /*registering server objects*/);

        // Validate parameters
        if ((grfFlags & ~(ROTFLAGS_REGISTRATIONKEEPSALIVE | ROTFLAGS_ALLOWANYCLIENT))
            || !IsValidInterface(punkObject)
            || !IsValidInterface(pmkObjectName)
            || !IsValidPtrOut(pdwRegister, sizeof(*pdwRegister)))
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable:Register Invalid Paramter\n"));

            hr = E_INVALIDARG;

            break;
        }

        // We don't allow registry of proxies
        // We use presence of IID_IProxyManager to detect if the object is a proxy

        IProxyManager *pProxyManager;

        // if so, return invalid argument
        if (punkObject -> QueryInterface(IID_IProxyManager, (void**) &pProxyManager) == S_OK)
        {
            pProxyManager -> Release();

            CairoleDebugOut((DEB_ERROR, "CRunningObjectTable:Register Invalid Paramter - proxy passed in expecting original object\n"));

            hr = E_INVALIDARG;

            break;
        }

        *pdwRegister = 0;

        // So we can fill in last change time at registration in the SCM
        FILETIME filetime;

        // Get the moniker comparison buffer
        CTmpMkEqBuf tmeb;

        hr = GetMonikerCompareBuffer(pmkObjectName, &tmeb, &filetime,
            &pifdMoniker);

        if (FAILED(hr))
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::Register get mk compare buf failed\n"));
            break;
        }

        //
        // Get the marshaled interface
        //

        // Stream to put marshaled interface in
        CXmitRpcStream xrpc;

        // The way we marshal this object depends on the liveness
        // characteristics specified by the caller of the operation.
        hr = CoMarshalInterface(&xrpc, IID_IUnknown, punkObject,
            MSHCTX_NOSHAREDMEM, NULL,
                grfFlags & ROTFLAGS_REGISTRATIONKEEPSALIVE
                    ? MSHLFLAGS_TABLESTRONG : MSHLFLAGS_TABLEWEAK);

        if (hr != NOERROR)
        {
            // Exit if there is an error
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::Register marshal object failed\n"));
            break;
        }

        xrpc.AssignSerializedInterface(&pifdObject);

        // Create an entry for the local registration table
        protitm = new CROTItem();
        if (protitm == NULL)
        {
            // Either the allocation failed, or the constructor failed
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::Register create ROT item failed\n"));
            hr = E_OUTOFMEMORY;

            break;
        }

        // Temporary holder for registration ID
        DWORD dwRotRegId;

        // ROT Table entry as opposed to the entry we are creating
        // which is called protitm.
        CROTItem **pprotitm;

        // Put it in the table and initalize signiture.
        {
            COleStaticLock lckSem(g_RotSem);

            // We lock here so we don't accidently pass out duplicate
            // signiture. It is important to note that we need to lock
            // anyway to put the item in the array.
            _wSigRotItem++;

            protitm->SetSig(_wSigRotItem);

            // Find a spot in the array for the object
            pprotitm = (CROTItem **) _afvRotList.GetAt(0);

            for (idwPutItem = 0; (int) idwPutItem < _afvRotList.GetSize();
                idwPutItem++)
            {
                if (pprotitm[idwPutItem] == NULL)
                {
                    break;
                }
            }

            // Was the table full?
            if ((int) idwPutItem < _afvRotList.GetSize())
            {
                // No -- use an empty slot.
                pprotitm[idwPutItem] = protitm;
            }
            // Grow the array to fit the next entry.
            else if (!_afvRotList.InsertAt(idwPutItem, &protitm))
            {
                // Couldn't reallocate memory
                hr = E_OUTOFMEMORY;
                break;
            }

            // Build the registration ID
            dwRotRegId = MakeRegID(_wSigRotItem, idwPutItem);
        }

        WCHAR   wszImageName[MAX_PATH];
        WCHAR * pwszExeName = 0;

        if ( grfFlags & ROTFLAGS_ALLOWANYCLIENT )
        {
            if ( g_AppId != GUID_NULL )
            {
                // If we got an AppId (from CoRegisterSurrogateEx or
                // CoInitializeSecurity, convert it to a string and pass
                // it as our Exe name to the SCM.

                if (StringFromIID2( g_AppId, wszImageName, sizeof(wszImageName)/sizeof(WCHAR)) == 0)
                {
                    hr = E_UNEXPECTED;
                    break;
                }
                pwszExeName = wszImageName;
            }
            else
            {
                // If we don't know our AppId, get our image name and
                // let the SCM try to map this to an AppId via the Registry.

                if ( ! GetModuleFileName( NULL, wszImageName, MAX_PATH ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    break;
                }

                pwszExeName = wszImageName + lstrlenW(wszImageName) - 1;
                while ( (pwszExeName != wszImageName) && (pwszExeName[-1] != L'\\') )
                    pwszExeName--;
            }
        }

        // Notify SCM of the registration
        //
        // Note that CoGetCurrentProcess is for supporting the DDE layer
        // which needs to find objects in the same apartment only.
        //
        hr = gResolver.IrotRegister(
            tmeb.GetMkEqBuf(),
            pifdObject,
            pifdMoniker,
            &filetime,
            CoGetCurrentProcess(),
            pwszExeName,
            protitm->GetScmRegKey());

        if (SUCCEEDED(hr))
        {
            *pdwRegister = dwRotRegId;
        }

    } while(FALSE);

    if (SUCCEEDED(hr))
    {
        // We pass the marshaled interface buffers off to the SCM so
        // it actually owns the ref counting (which is why it returns
        // copies of the buffer on Revoke. However, we still have
        // copies of the buffer memore here which we have to free or
        // leak memory.
#ifdef DCOM
        CoTaskMemFree(pifdMoniker);
        CoTaskMemFree(pifdObject);
#else
        MIDL_user_free(pifdMoniker);
        MIDL_user_free(pifdObject);
#endif
    }
    else
    {
        // Clean up marshaled interfaces since the call has failed.
        ReleaseInterfaceData(pifdMoniker, MEM_PUB);
        ReleaseInterfaceData(pifdObject, MEM_PUB);

        // Error clean up.
        if (protitm != NULL)
        {
            if (idwPutItem != 0xFFFFFFFF)
            {
                // Registration failed on the SCM so clean up our local
                // registration.
                COleStaticLock lckSem(g_RotSem);

                // We have to use GetAt because the table could have grown
                CROTItem **pprotitm = (CROTItem **)
                    _afvRotList.GetAt(idwPutItem);

                pprotitm[idwPutItem] = NULL;
            }

            // Free the item for the ROT.
            delete protitm;
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::Register"
       "( %lX ) [ %lX ]\n", this, hr, *pdwRegister));

    return hr;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::Revoke
//
//  Synopsis:   Remove a previously registered item from the table.
//
//  Arguments:  [dwRegister] - registration id
//
//  Returns:    S_OK - item was revoked
//              E_INVALIDARG - dwRegister is invalid
//
//  Algorithm:  Convert local registration to SCM registration. Send revoke
//              to the SCM. Release data associated with SCM ROT entries.
//
//  History:    11-Nov-93 Ricksa    Created
//              27-Nov-95 Ricksa    New ROT
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::Revoke(DWORD dwRegister)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::Revoke"
       "( %lX )\n", this, dwRegister));

    // Default response to bad argument
    HRESULT hr = E_INVALIDARG;

    // Entry
    CROTItem *protitm;

    // Convert handle to pointer
    DWORD idwIndexToEntry;
    WORD wItemSig;
    GetSigAndIndex(dwRegister, &wItemSig, &idwIndexToEntry);

    do {

        // Lock from other processes so another simultaneous revoke
        // will not cause something strange to happen.
        COleStaticLock lckSem(g_RotSem);

        protitm = GetRotItem(idwIndexToEntry);

        if (protitm != NULL)
        {
            // Found an entry so verify its signiture
            if (protitm->ValidSig(wItemSig))
            {
                // Entry is valid so clear it out from the table
                CROTItem **pprotitm = (CROTItem **)
                    _afvRotList.GetAt(idwIndexToEntry);
                *pprotitm = NULL;
                hr = S_OK;
            }
        }

    } while(FALSE);

    // We get out of the block and unlock our list and then RPC the
    // call to the SCM so we don't hold our lock for the duration of
    // an RPC.
    if (hr == S_OK)
    {
        // Release the ROT item's memory.
        delete protitm;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::Revoke"
       "( %lX )\n", this, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::IsRunning
//
//  Synopsis:   See if object is running
//
//  Arguments:  [pmkObjectName] - name of item to search for
//
//  Returns:    S_OK - item is running
//              S_FALSE - item is not running
//
//  Algorithm:  Validate input parameters. Then build a moniker comparison
//              buffer. Then ask the ROT if there is a registration for
//              the  input moniker.
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::IsRunning(LPMONIKER pmkObjectName)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::IsRunning"
       "( %p )\n", this, pmkObjectName));

    HRESULT hr = E_INVALIDARG;

    // Validate input parameters
    if (IsValidInterface(pmkObjectName))
    {
        // Create a buffer for the comparison
        CTmpMkEqBuf tmpMkEqBuf;

        // Get comparison buffer
        if ((hr = GetMonikerCompareBuffer(pmkObjectName, &tmpMkEqBuf, NULL,
            NULL)) == NOERROR)
        {
            // Look into the hint table for the object
            if (IsInScm(tmpMkEqBuf.GetMkEqBuf()))
            {
                // Ask SCM for the object
                hr = gResolver.IrotIsRunning(tmpMkEqBuf.GetMkEqBuf());
            }
            else
            {
                // If it isn't in the hint table, there is no reason
                // to RPC to the ROT.
                hr = S_FALSE;
            }
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::IsRunning"
       "( %lX )\n", this, hr));

    return hr;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::GetObject
//
//  Synopsis:   Get an object from the ROT
//
//  Arguments:  [pmkObjectName] - name of object to search for
//              [ppunkObject] - where to put interface pointer.
//
//  Returns:    S_OK - found and returned object.
//              MK_E_UNAVAILABLE - not found
//
//  Algorithm:  Convert the local registration ID to the SCM registration
//              ID. Then send the request on to the SCM.
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::GetObject(
    LPMONIKER pmkObjectName,
    LPUNKNOWN *ppunkObject)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::GetObject "
        "( %p , %p )\n", this, pmkObjectName, ppunkObject));

    // Validate arguments
    HRESULT hr = E_INVALIDARG;

    // Validate input parameters
    if (IsValidInterface(pmkObjectName)
        && IsValidPtrOut(ppunkObject, sizeof(*ppunkObject)))
    {
        *ppunkObject = NULL;

        // Create a buffer for the comparison
        CTmpMkEqBuf tmpMkEqBuf;

        // Get comparison buffer
        if ((hr = GetMonikerCompareBuffer(pmkObjectName, &tmpMkEqBuf, NULL,
            NULL)) == NOERROR)
        {
            // Note: Process ID is 0 because we don't care about the
            // process any registration will do.
            hr = IGetObject(tmpMkEqBuf.GetMkEqBuf(), ppunkObject, 0);
        }
        else
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::GetObject couldn't get comp buf\n"));
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::GetObject"
       "( %lX ) [ %p ]\n", this, hr, *ppunkObject));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::IGetObject
//
//  Synopsis:   Internal call to get an object from the ROT
//
//  Arguments:  [pmkObjectName] - name of object to search for
//              [ppunkObject] - where to put interface pointer.
//              [dwThreadID] - thread ID for the object
//
//  Returns:    S_OK - found and returned object.
//              MK_E_UNAVAILABLE - not found
//
//  Algorithm:  Build a moniker comparison buffer. Send request to the
//              SCM. Then unmarshal the result from the SCM. If the
//              unmarshal fails, then notify the SCM that the registration
//              is invalid.
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:      This exists because OLE 1.0 compatibility requires support
//              for determining whether an object is already in the ROT
//              for the given process.
//
//              Because this is an internal call, there is no parameter
//              validation.
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::IGetObject(
    MNKEQBUF *pmkeqbuf,
    LPUNKNOWN FAR* ppunkObject,
    DWORD dwThreadID)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::IGetObject"
       "( %p , %p , %lX )\n", this, pmkeqbuf, ppunkObject, dwThreadID));

    // Validate arguments
    HRESULT hr = E_INVALIDARG;

    do {

        // Loop because there can be multiple bad entries in the SCM
        // We loop 5 because we can theoretically loop forever so we
        // want to give up after we give a good long try that should
        // most likely work.
        for (int i = 0; i < 5; i++)
        {
            // Look into the hint table for the object
            if (!IsInScm(pmkeqbuf))
            {
                // If it isn't in the hint table, there is no reason
                // to RPC to the ROT.
                hr = MK_E_UNAVAILABLE;
                break;
            }

            // Ask SCM for the object
            SCMREGKEY scmregkey;
            InterfaceData *pifdObject = NULL;

            hr = gResolver.IrotGetObject(dwThreadID, pmkeqbuf,
                &scmregkey, &pifdObject);

            if (FAILED(hr))
            {
                // SCM couldn't find it so we are done.
                break;
            }

            if (ppunkObject == NULL)
            {
                // This is really an IsRunning from DDE so we can exit
                // now.
                hr = NOERROR;

                // free the buffer allocated
                MIDL_user_free(pifdObject);

                // Exit because we are done.
                break;
            }

            // Now we have to unmarshal the object to really get the
            // object.
            CXmitRpcStream xrpc(pifdObject);

            hr = CoUnmarshalInterface(&xrpc, IID_IUnknown,
                (void **) ppunkObject);

            // Whether there was an error or not we need to dump the
            // memory that RPC allocated on our behalf.
            MIDL_user_free(pifdObject);

            if (hr == NOERROR)
            {
                // We got our object so we are done.
                break;
            }

            // Tell ROT that we couldn't unmarshal this object so the entry
            // is bad. We ignore any errors from the SCM because there isn't
            // anything we could do about it anyway.

            // Dummy parameters for revoke - we don't care about these and
            // the SCM will not return them because we are a client and
            // can't call CoReleaseMarshalData anyway.
            InterfaceData *pifdDummy1 = NULL;
            InterfaceData *pifdDummy2 = NULL;

            gResolver.IrotRevoke(&scmregkey, FALSE, &pifdDummy1, &pifdDummy2);

            // We couldn't get the object so we try again to see if there is
            // another registration that we could use.
        }

    } while(FALSE);

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::IGetObject"
       "( %lX ) [ %p ]\n", this, hr,
           ((ppunkObject == NULL) ? NULL : *ppunkObject)));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::NoteChangeTime
//
//  Synopsis:   Set the time of last change in the ROT
//
//  Arguments:  [dwRegister] - registration id of object
//              [pfiletime] - file time of change.
//
//  Returns:    S_OK - new time set
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::NoteChangeTime(
    DWORD dwRegister,
    FILETIME *pfiletime)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::NoteChangeTime"
       "( %lX , %p )\n", this, dwRegister, pfiletime));

    // Default result to bad argument.
    HRESULT hr = E_INVALIDARG;

    do {

        // Validate that parameters are valid
        if (!IsValidReadPtrIn(pfiletime, sizeof(FILETIME)))
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::NoteChangeTime invalid time param\n"));
            break;
        }

        SCMREGKEY ScmRegKey;

        {
            // Lock from other threads so a revoke  will not cause something
            // strange to happen.
            COleStaticLock lckSem(g_RotSem);

            // Convert handle to pointer
            DWORD idwIndexToEntry;
            WORD wItemSig;
            GetSigAndIndex(dwRegister, &wItemSig, &idwIndexToEntry);

            CROTItem *protitm = GetRotItem(idwIndexToEntry);

            if ((protitm == NULL) || !protitm->ValidSig(wItemSig))
            {
                // Entry is valid so clear it out from the table
                CairoleDebugOut((DEB_ERROR,
                    "CRunningObjectTable::NoteChangeTime invalid reg key\n"));
                break;
            }

            ScmRegKey = *(protitm->GetScmRegKey());
        }

        // Outside the scope of the lock, call the SCM and returns
        // it's results.
        hr = gResolver.IrotNoteChangeTime(&ScmRegKey, pfiletime);

    } while(FALSE);

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::NoteChangeTime"
       "( %lX )\n", this, hr));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::GetTimeOfLastChange
//
//  Synopsis:   Get time of last change for a given object
//
//  Arguments:  [pmkObjectName] - name of object
//              [pfiletime] - where to put the time of change
//
//  Returns:    S_OK - got time of last change.
//              MK_E_UNAVAILABLE - moniker is not in the table
//
//  History:    11-Nov-93 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::GetTimeOfLastChange(
    LPMONIKER pmkObjectName,
    FILETIME *pfiletime)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::GetTimeOfLastChange"
       "( %p , %p )\n", this, pmkObjectName, pfiletime));

    HRESULT hr = E_INVALIDARG;

    do {

        // Validate input parameters
        if (!IsValidInterface(pmkObjectName)
            || !IsValidPtrOut(pfiletime, sizeof(pfiletime)))
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::GetTimeOfLastChange invalid params\n"));
            break;
        }

        // Create a buffer for the comparison
        CTmpMkEqBuf tmpMkEqBuf;

        // Get comparison buffer
        if ((hr = GetMonikerCompareBuffer(pmkObjectName, &tmpMkEqBuf, NULL,
            NULL)) != NOERROR)
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::GetTimeOfLastChange couldn't get comp buf failed\n"));

            break;
        }

        // Look into the hint table for the object
        if (!IsInScm(tmpMkEqBuf.GetMkEqBuf()))
        {
            // If it isn't in the hint table, there is no reason
            // to RPC to the ROT.
            hr = MK_E_UNAVAILABLE;
            break;
        }

        // Ask SCM for the object
        SCMREGKEY scmregkey;
        InterfaceData *pifdObject = NULL;

        hr = gResolver.IrotGetTimeOfLastChange(tmpMkEqBuf.GetMkEqBuf(), pfiletime);

    } while(FALSE);

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::GetTimeOfLastChange"
       "( %lX )\n", this, hr));


    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::EnumRunning
//
//  Synopsis:   Get an enumerator for all objects in the ROT
//
//  Arguments:  [ppenumMoniker] - where to put enumerator interface
//
//  Returns:    S_OK - successfully built enumerator
//              E_OUTOFMEMORY - could not build enumerator
//
//  Algorithm:  Constructor an enumerator object. Then get the list of
//              all running monikers from the SCM. Finally, put that list
//              into the enumerator object.
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::EnumRunning(LPENUMMONIKER *ppenumMoniker)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::EnumRunning"
       "( %p )\n", this, ppenumMoniker));

    HRESULT hr = E_INVALIDARG;
    CRotMonikerEnum *protenumMoniker = NULL;
    MkInterfaceList *pMkIFList = NULL;

    do {

        if (!IsValidPtrOut(ppenumMoniker, sizeof(*ppenumMoniker)))
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::EnumRunning invalid params\n"));
            break;
        }

        protenumMoniker = new CRotMonikerEnum();

        if ((protenumMoniker == NULL) || !protenumMoniker->CreatedOk())
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::EnumRunning couldn't create enumerator\n"));

            hr = E_OUTOFMEMORY;

            break;
        }


        hr = gResolver.IrotEnumRunning(&pMkIFList);

        if (hr != NOERROR)
        {
            // Return the error from the SCM
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::EnumRunning call to SCM failed\n"));

            break;
        }

        hr = protenumMoniker->LoadResultFromScm(pMkIFList);

        if (hr == NOERROR)
        {
            *ppenumMoniker = protenumMoniker;
            protenumMoniker = NULL;
        }

    } while(FALSE);

    if (protenumMoniker != NULL)
    {
        // If our local pointer is not NULL then we just delete it and
        // ignore the reference count since this means an error occurred.
        delete protenumMoniker;
    }

    if (pMkIFList != NULL)
    {
        // Free all the entries
        for (DWORD i = 0; i < pMkIFList->dwSize; i++)
        {
            MIDL_user_free(pMkIFList->apIFDList[i]);
        }

        // Then free the structure itself
        MIDL_user_free(pMkIFList);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::EnumRunning"
       "( %lX ) [ %p ]\n", this, hr, *ppenumMoniker));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::GetObjectByPath
//
//  Synopsis:   Locate object in ROT by path
//
//  Arguments:  [lpstrPath] - path to locate in the rot
//              [ppunkObject] - where to put the object if requested
//              [dwThreadID] - what thread the object s/b in
//
//  Returns:    S_OK - successfully built enumerator
//              E_OUTOFMEMORY - could not build enumerator
//
//  Algorithm:  Build a buffer full of objects from the local table then
//              consult the ROT directory.
//
//  History:    30-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRunningObjectTable::IGetObjectByPath(
    LPOLESTR lpstrPath,
    LPUNKNOWN *ppunkObject,
    DWORD dwThreadID)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::IGetObjectByPath"
       "( %p , %p , %lX )\n", this, lpstrPath, ppunkObject, dwThreadID));

    HRESULT hr = S_FALSE;

    // Where we put the moniker we use for the moniker
    CSafeMoniker smk;

    if (ppunkObject)
    {
        *ppunkObject = NULL;
    }

    // Create a buffer for the comparison
    CTmpMkEqBuf tmpMkEqBuf;

    hr = CreateFileMonikerComparisonBuffer(lpstrPath, tmpMkEqBuf.GetBuf(),
        tmpMkEqBuf.GetSize(), tmpMkEqBuf.GetSizeAddr());

    if (SUCCEEDED(hr))
    {
        hr = IGetObject(tmpMkEqBuf.GetMkEqBuf(), ppunkObject, dwThreadID);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::IGetObjectByPath"
       "( %lX ) [ %p ]\n", this, hr,
           ((ppunkObject == NULL) ? NULL : *ppunkObject)));

    return hr;
}




//+-------------------------------------------------------------------------
//
//  Member:     GetRunningObjectTable
//
//  Synopsis:   Get a pointer to the ROT
//
//  Arguments:  [reserved] - reserved!
//              [pprot] - where to put interface pointer
//
//  Returns:    S_OK - got pointer
//              E_UNEXPECTED - table not initialized
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDAPI GetRunningObjectTable(DWORD reserved, LPRUNNINGOBJECTTABLE *pprot)
{
    OLETRACEIN((API_GetRunningObjectTable, PARAMFMT("reserved= %x, pprot= %p"), pprot));

    CairoleDebugOut((DEB_ROT, "%p _IN GetRunningObjectTable"
       "( %p )\n", NULL, pprot));

    HRESULT hr = CO_E_NOTINITIALIZED;

    if ((pROT == NULL) && (g_cProcessInits > 0))
    {
        // If we haven't created it, create it now.
        CRunningObjectTable::Create();
    }

    *pprot = pROT;      // will be NULL in error case

    if (pROT != NULL)
    {
        hr = S_OK;
    }

    CALLHOOKOBJECTCREATE(hr,CLSID_NULL,IID_IRunningObjectTable,(IUnknown **)pprot);

    CairoleDebugOut((DEB_ROT, "%p OUT GetRunningObjectTable"
       "( %lX ) [ %p ]\n", NULL, hr, *pprot));

    OLETRACEOUT((API_GetRunningObjectTable, hr));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Function:   CleanROTForApartment
//
//  Synopsis:   Get rid of running object table entries for the current APT.
//
//  History:    24-Jun-94 Rickhi          Created
//
//--------------------------------------------------------------------------
void CleanROTForApartment(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CleanROTForApartment"
       "\n", NULL));

    if (pROT)
    {
        pROT->CleanupApartment(GetCurrentApartmentId());
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CleanROTForApartment"
       "\n", NULL));
}

//+-------------------------------------------------------------------------
//
//  Function:   DestroyRunningObjectTable
//
//  Synopsis:   Get rid of running object table
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
void DestroyRunningObjectTable(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN DestroyRunningObjectTable"
       "\n", NULL));

    // Need to synchronize ROT destruction in a multithreaded environment
    COleStaticLock lckSem(g_RotSem);

    // It doesn't matter what the ref count is, when OLE goes, the ROT goes too.
    delete pROT;

    pROT = NULL;

#ifndef DCOM
    // Our endpoint is history. Note that this just resides here as a
    // convenient place for this to happen (and for historical reasons
    // since it used to serve some practical purpose for being here).
    epiForProcess.MakeEndpointInvalid();
#endif

    CairoleDebugOut((DEB_ROT, "%p OUT DestroyRunningObjectTable"
       "\n", NULL));
}


//+-------------------------------------------------------------------------
//
//  Member:     CMonikerPtrBuf::CMonikerPtrBuf
//
//  Synopsis:   Copy constructor for the buffer
//
//  Arguments:  [mkptrbuf] - buffer to copy
//
//  History:    20-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
CMonikerPtrBuf::CMonikerPtrBuf(CMonikerPtrBuf& mkptrbuf)
    : CMonikerBag(mkptrbuf)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CMonikerPtrBuf::CMonikerPtrBuf"
       "( %p )\n", this, &mkptrbuf));

    // Now AddRef the copied monikers so they stay around
    IMoniker **ppmk = GetArrayBase();

    for (DWORD i = 0; i < GetMax(); i++)
    {
        ppmk[i]->AddRef();
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CMonikerPtrBuf::CMonikerPtrBuf"
       "( %p )\n", this));
}




//+-------------------------------------------------------------------------
//
//  Member:     CMonikerPtrBuf::~CMonikerPtrBuf
//
//  Synopsis:   Free items
//
//  History:    23-Dec-93 Ricksa    Created
//
//  Notes:      This object assumes that it gets its monikers addref'd
//              so it is up to this object to free them.
//
//--------------------------------------------------------------------------
CMonikerPtrBuf::~CMonikerPtrBuf(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CMonikerPtrBuf::~CMonikerPtrBuf"
       "\n", this));

    DWORD dwSize = GetMax();

    if (dwSize > 0)
    {
        IMoniker **ppmk = GetArrayBase();

        for (DWORD i = 0; i < dwSize; i++)
        {
            ppmk[i]->Release();
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CMonikerPtrBuf::~CMonikerPtrBuf"
       "\n", this));
}







//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::CRotMonikerEnum
//
//  Synopsis:   Constructor for ROT moniker enumerator
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
CRotMonikerEnum::CRotMonikerEnum(void)
    : _cRefs(1), _dwOffset(0)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::CRotMonikerEnum"
       "\n", this));

    // Header does the work

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::CRotMonikerEnum"
       "\n", this));
}




//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::CRotMonikerEnum
//
//  Synopsis:   Copy constructor for ROT moniker enumerator
//
//  Arguments:  [rotenumMoniker] - Enumerator to copy from
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
CRotMonikerEnum::CRotMonikerEnum(CRotMonikerEnum& rotenumMoniker)
    : _cRefs(1), _dwOffset(rotenumMoniker._dwOffset),
        _mkptrbuf(rotenumMoniker._mkptrbuf)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::CRotMonikerEnum"
       "( %p )\n", this, &rotenumMoniker));

    // Header does the work

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::CRotMonikerEnum"
       "\n", this));
}




//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::QueryInterface
//
//  Synopsis:   QI for ROT moniker enumerator
//
//  Arguments:  [riid] - requested interface
//              [ppvObj] - where to put requested interface
//
//  Returns:    S_OK - returned interface
//              E_NOINTERFACE - requested interface is not supported
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRotMonikerEnum::QueryInterface(REFIID riid, void **ppvObj)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::QueryInterface"
       "( %p , %p )\n", this, &riid, ppvObj));

    HRESULT hr = S_OK;

    do {

        *ppvObj = NULL;

        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IEnumMoniker))
        {
            *ppvObj = (LPVOID)this;
            AddRef();
            break;
        }

        hr = E_NOINTERFACE;

    } while(FALSE);

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::QueryInterface"
       "( %lX ) [ %p ]\n", this, hr, *ppvObj));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::AddRef
//
//  Synopsis:   Add to ref count
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRotMonikerEnum::AddRef(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::AddRef"
       "\n", this));

    InterlockedIncrement((LONG *) &_cRefs);

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::AddRef"
       "( %lX )\n", this, _cRefs));

    return _cRefs;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::Release
//
//  Synopsis:   Release reference count
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRotMonikerEnum::Release(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::Release"
       "\n", this));

    LONG lRefs = InterlockedDecrement((LONG *) &_cRefs);

    if (0 == lRefs)
    {
        delete this;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::Release"
       "( %lX )\n", this, lRefs));

    return (ULONG) lRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::Next
//
//  Synopsis:   Get next number of requested monikers from the buffer
//
//  Arguments:  [celt] - number of items requested
//              [reelt] - where to put table of monikers
//              [pceltFetched] - number of monikers retrieved
//
//  Returns:    S_OK - all requested monikers successfully retrieved
//              S_FALSE - entire buffer not filled.
//
//  Algorithm:  Loop through list returning monikers.
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRotMonikerEnum::Next(
    ULONG celt,
    LPMONIKER *reelt,
    ULONG *pceltFetched)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::Next"
       "( %lX , %p , %p )\n", this, celt, reelt, pceltFetched));

    // Validate pceltFetched
    if ((celt != 1) && (pceltFetched != NULL))
    {
        *pceltFetched = 0;
    }

    // Loop loading monikers until request is satisfied or we run out
    for (ULONG i = 0; i < celt; i++)
    {
        IMoniker *pmk = _mkptrbuf.GetItem(_dwOffset++);

        if (pmk == NULL)
        {
            break;
        }

        reelt[i] = pmk;
    }

    if (pceltFetched != NULL)
    {
        *pceltFetched = i;
    }

    HRESULT hr = (i == celt) ? S_OK : S_FALSE;

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::Next"
       "( %lX  )\n", this, hr));

    return hr;

}




//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::Skip
//
//  Synopsis:   Skip designated number of monikers
//
//  Arguments:  [celt] - number to skip
//
//  Returns:    S_OK - skipped requested number
//              S_FALSE - # skipped greater than remaining
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRotMonikerEnum::Skip(ULONG celt)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::Skip"
       "( %lX )\n", this, celt));

    // Error return -- assume count to skip is larger than number of items
    HRESULT hr = S_FALSE;

    if (_dwOffset + celt <= _mkptrbuf.GetMax())
    {
        _dwOffset += celt;
        hr = S_OK;
    }
    else
    {
        _dwOffset = _mkptrbuf.GetMax();
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::Skip"
       "( %lX )\n", this, hr));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::Reset
//
//  Synopsis:   Reset the enumerator
//
//  Returns:    S_OK
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRotMonikerEnum::Reset(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::Reset"
       "\n", this));

    _dwOffset = 0;

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::Reset"
       "\n", this));

    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::Clone
//
//  Synopsis:   Make a copy of the current enumerator
//
//  Arguments:  [ppenumMoniker] - where to put copy
//
//  Returns:    S_OK - moniker successfully cloned
//              E_OUTOFMEMORY - not enough memory to clone
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRotMonikerEnum::Clone(LPENUMMONIKER FAR* ppenumMoniker)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::Clone"
       "( %p )\n", this, ppenumMoniker));

    // Error return
    HRESULT hr = S_OK;

    // Use copy constructor to create duplicate enumerator
    CRotMonikerEnum *pcrotenumMoniker = new CRotMonikerEnum(*this);

    if ((pcrotenumMoniker == NULL) || !pcrotenumMoniker->CreatedOk())
    {
        delete pcrotenumMoniker;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        *ppenumMoniker = (LPENUMMONIKER) pcrotenumMoniker;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::Clone"
       "( %lX ) [ %p ]\n", this, hr, *ppenumMoniker));
    return hr;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::LoadResultFromScm
//
//  Synopsis:   Add a list of monikers to enumerator from an object server
//
//  Arguments:  [pMkIFList] - list to use for input
//
//  Returns:    S_OK - moniker added
//              E_OUTOFMEMORY - could not add any more to buffer
//
//  History:    11-Nov-93 Ricksa    Created
//              27-Jan-95 Ricksa    New ROT
//
//  Note:
//
//--------------------------------------------------------------------------
HRESULT CRotMonikerEnum::LoadResultFromScm(MkInterfaceList *pMkIFList)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::LoadResultFromScm"
       "( %p )\n", this, pMkIFList));

    HRESULT hr = S_OK;

    for (DWORD i = 0; i < pMkIFList->dwSize; i++)
    {
        // Where to put the unmarshaled moniker
        IMoniker *pmk;

        // Unmarshal the interface from the buffer
        CXmitRpcStream xrpc(pMkIFList->apIFDList[i]);

        hr = CoUnmarshalInterface(&xrpc, IID_IMoniker, (void **) &pmk);

        if (FAILED(hr))
        {
            // Really two important possibilities for failure: (1) Out of
            // memory or (2) Somekind of communication failure during the
            // unmarshal. Out of memory means that we are pretty well dead
            // so we will return that error and ignore the others since
            // if the moniker is remotely served, it can actually have
            // gone away before we got around to unmarshaling it.
            if (hr == E_OUTOFMEMORY)
            {
                break;
            }

            continue;
        }

        // Put the moniker in the array
        _mkptrbuf.Add(pmk);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::LoadResultFromScm"
       "( %lX )\n", this, hr));

    return hr;
}





//+---------------------------------------------------------------------------
//
//  Function:   GetLocalRunningObjectForDde
//
//  Synopsis:   Searches for and optionally returns an object by path for
//              the DDE layer.
//
//  Effects:    Attempts to find an entry in the local ROT that matches
//              the provided path. If there is a hit in the table, and
//              ppunkObject is not NULL, then it also returns a pointer
//              to the object.
//
//  Arguments:  [lpstrPath] -- Path to search for
//              [ppunkObject] -- Output for the object pointer
//
//  Returns:    S_OK - Found object in local ROT
//              S_FALSE - Didn't find object in local ROT
//              OTHER - Something else happened.
//
//  History:    6-29-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetLocalRunningObjectForDde(
    LPOLESTR lpstrPath,
    LPUNKNOWN *ppunkObject)
{
    CairoleDebugOut((DEB_ROT, "%p _IN GetLocalRunningObjectForDde"
       "( %p , %p )\n", NULL, lpstrPath, ppunkObject));

    HRESULT hr = S_FALSE;

    // POSTPPC - We're getting close to RTM for NT/PPC, so we'll make this fix
    // for Chicago only for now
#ifdef _CHICAGO_
    // We create a file moniker here to ensure that the name we test against
    // the ROT is in UNC form
    LPMONIKER pMnk;
    LPBINDCTX pBc;
    LPWSTR    pwszDisplayName;

    hr = CreateFileMoniker(lpstrPath, &pMnk);
    if (FAILED(hr))
    {
        return hr;
    }
    hr = CreateBindCtx(NULL, &pBc);
    if (FAILED(hr))
    {
        pMnk->Release();
        return hr;
    }
    hr = pMnk->GetDisplayName(pBc, NULL, &pwszDisplayName);
    if (FAILED(hr))
    {
        pMnk->Release();
        pBc->Release();
        return hr;
    }

    // If there currently isn't a local ROT, then the object surely isn't
    // registered.
    if (pROT != NULL)
    {
        hr = pROT->IGetObjectByPath(pwszDisplayName, ppunkObject,
                                    CoGetCurrentProcess());
    }
    else
    {
        hr = S_FALSE;
    }

    // Cleanup
    pMnk->Release();
    pBc->Release();
    CoTaskMemFree(pwszDisplayName);


#else
    //
    // If there currently isn't a local ROT, then the object surely isn't
    // registered.
    //
    if (pROT != NULL)
    {
        hr = pROT->IGetObjectByPath(lpstrPath, ppunkObject,
                                    CoGetCurrentProcess());
    }

#endif // _CHICAGO_

    CairoleDebugOut((DEB_ROT, "%p OUT GetLocalRunningObjectForDde"
       "( %lX ) [ %p ]\n", NULL, hr,
           ((ppunkObject == NULL) ? NULL : *ppunkObject)));

    return(hr);
}





//+---------------------------------------------------------------------------
//
//  Function:   GetObjectFromRotByPath
//
//  Synopsis:   Searches for and optionally returns an object by path for
//              pbkect binding.
//
//  Effects:    Attempts to find an entry in the ROT that matches
//              the provided path. If there is a hit in the table, and
//              ppunkObject is not NULL, then it also returns a pointer
//              to the object.
//
//  Arguments:  [lpstrPath] -- Path to search for
//              [ppunkObject] -- Output for the object pointer
//
//  Returns:    S_OK - Found object in local ROT
//              S_FALSE - Didn't find object in local ROT
//              OTHER - Something else happened.
//
//  History:    30-Jan-95   Ricksa  Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetObjectFromRotByPath(
    LPOLESTR lpstrPath,
    LPUNKNOWN *ppunkObject)
{
    CairoleDebugOut((DEB_ROT, "%p _IN GetObjectFromRotByPath"
       "( %p , %p )\n", NULL, lpstrPath, ppunkObject));

    HRESULT hr = S_FALSE;

    // Is the rot in existence yet?
    if (pROT == NULL)
    {
        // No - create the ROT. Remember that pROT is real pointer to the
        // running object table. GetRunningObjectTable returns this and
        // initializes it if it is NULL. This is why we don't pay very much
        // attention to prot.
        IRunningObjectTable *prot;

        GetRunningObjectTable(0, &prot);

        // Note that we don't have to release the prot because the ROT
        // doesn't care about its reference count. Its lifetime is independent
        // of the reference count.
    }

    if (pROT != NULL)
    {
        hr = pROT->IGetObjectByPath(lpstrPath, ppunkObject, 0);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT GetObjectFromRotByPath"
       "( %lX ) [ %p ]\n", NULL, hr, *ppunkObject));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\callframe.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// CallFrame.h
//
#include "CallFrameImpl.h"

//////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef DBG

extern LPCSTR FormatCharNames[];

#endif


//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Class that understands how to read and write memory carefully, probing and checking
// as needed.
//

struct CAREFUL_MEMORY_READER_WRITER 
{
    enum 
    {                      
        m_fToUser       = TRUE,
        m_fFromUser     = TRUE,
    };

    CAREFUL_MEMORY_READER_WRITER()
    {
    }

    void SetFromUser(PVOID pv)
    {
    }

    void SetToUser(PVOID pv)
    {
    }

    BOOL InSameSpace(DWORD freeFlags = 0) const
    {
        BOOL fInSameSpace = (!!m_fFromUser == !!m_fToUser);
#ifdef DBG
        fInSameSpace = (fInSameSpace && !(freeFlags & 0x8000000)); // force other space if flag set
#endif
        return fInSameSpace;
    }

    ///////////////////////////////////////////////////////////////////
    //
    // Support for safely reading and writing (potentially) user mode addresses.
    // All of these must be called in the context of an exception handler.
    //
    ///////////////////////////////////////////////////////////////////

    template <class T> void TestWriteSrc(T* pt)            { }
    template <class T> void TestWriteDst(T* pt)            { }
    template <class T> void TestWriteSrc(T* pt, SIZE_T cb) { }
    template <class T> void TestWriteDst(T* pt, SIZE_T cb) { }

    template <class T> void TestReadSrc(T* pt)             { }
    template <class T> void TestReadDst(T* pt)             { }
    template <class T> void TestReadSrc(T* pt, SIZE_T cb)  { }
    template <class T> void TestReadDst(T* pt, SIZE_T cb)  { }

    ////////////////////

    void CopyToDst(PVOID pvLocationInDst, PVOID pvLocationInSrc, SIZE_T cb)
        // Copy a chunk of data from source frame to destination frame.
    {
        TestReadSrc (pvLocationInSrc, cb);
        TestWriteDst(pvLocationInDst, cb);
        memcpy(pvLocationInDst, pvLocationInSrc, cb);
    }

    void CopyToSrc(PVOID pvTo, PVOID pvFrom, SIZE_T cb)
    {
        TestReadDst (pvFrom, cb);
        TestWriteSrc(pvTo,   cb);
        memcpy(pvTo, pvFrom, cb);
    }
    
    ////////////////////

    template <class T>
    T DerefSrc(const T* psrc)
    {
        TestReadSrc(psrc);
        return *psrc;
    }

    template <class T>
    void DerefStoreSrc(T* pt, const T& t)
    {
        TestWriteSrc(pt);
        *pt = t;
    }
    
    template <class T>
    T DerefDst(const T* pdst)
    {
        TestReadDst(pdst);
        return *pdst;
    }

    template <class T>
    void DerefStoreDst(T* pt, const T& t)
    {
        TestWriteDst(pt);
        *pt = t;
    }

    ////////////////////

    void ZeroDst(PVOID pv, ULONG cb)
    {
        TestWriteDst(pv, cb);
        Zero(pv, cb);
    }

    template <class T> 
    void ZeroDst(T* pt)
    {
        ZeroDst(pt, sizeof(*pt));
    }

    void ZeroSrc(PVOID pv, ULONG cb)
    {
        TestWriteSrc(pv, cb);
        Zero(pv, cb);
    }

    template <class T> 
    void ZeroSrc(T* pt)
    {
        ZeroSrc(pt, sizeof(*pt));
    }

};





//////////////////////////////////////////////////////////////////////////////////////////////////

class CallFrame : 
    public ICallFrame, 
    public ICallFrameInit,
    public CAREFUL_MEMORY_READER_WRITER,
    public DedicatedAllocator<CallFrame, PagedPool>
{
  public:
    ///////////////////////////////////////////////////////////////////
    //
    // State of valid interest outside of any worker routine
    //
    ///////////////////////////////////////////////////////////////////

    BYTE* PMemberFirst() { return (BYTE*)&m_pmd; }

    // Our meta data reference
    MD_METHOD*                  m_pmd;

    // Pointer to the stack frame containing the argument data
    PVOID                       m_pvArgs;
    BOOL                        m_fIsCopy;      // Are we a copy? (that is, generated by a copy or unmarshal?)
    BOOL                        m_fIsUnmarshal; // Are we an unmarshalled call frame?

    // The return value of an invocation on us. Is REGISTER_TYPE in order that it can
    // be directly marshalled.
    REGISTER_TYPE               m_hrReturnValue;

    // Current location in the one-off block of memory we use for private buffer management
    PVOID                       m_pvMemCur;

    // If we share memory with someone, then this is the stack of the guy with whom we do
    PVOID                       m_pvArgsSrc;

    // Do our in-parameters share state with our parent frame
    BOOL                        DoWeShareMemory()   { return m_pvArgsSrc != NULL; }

#ifdef DBG
    // If true, then we definitely have made a call on this frame
    BOOL                        m_fAfterCall;
#endif

    // Our interceptor. We need to keep it alive as long as we are alive. 
    //
    Interceptor*                m_pInterceptor;


    ///////////////////////////////////////////////////////////////////
    //
    // State used to communicate with various worker routines as we
    // copy, free, etc.
    //
    ///////////////////////////////////////////////////////////////////

    BOOL                        m_fPropogatingOutParam;
    BOOL                        m_fWorkingOnInParam;
    BOOL                        m_fWorkingOnOutParam;


    // The frame that should allocate memory as we need it
    CallFrame*                  m_pAllocatorFrame;

    // Used during a Copy etc call as the guy who should get our callbacks
    ICallFrameWalker*           m_pWalkerCopy;
    ICallFrameWalker*           m_pWalkerFree;
    ICallFrameWalker*           m_pWalkerWalk;


    ///////////////////////////////////////////////////////////////////
    //
    // State used to mirror NDR runtime pStubMsg state
    //
    ///////////////////////////////////////////////////////////////////

    BYTE*                       m_StackTop;             // base pointer used for FC_TOP_LEVEL_CONFORMANCE conformance computations
    BYTE*                       m_Memory;               // base pointer used for FC_POINTER_CONFORMANCE   conformance computations

    SIZE_T                      m_MaxCount;             // Holds the max counts for a conformant array
    SIZE_T                      m_Offset;               // Holds the offsets for a varying array
    SIZE_T                      m_ActualCount;          // Holds the actual counts for a varying array
    PARRAY_INFO                 m_pArrayInfo;

    // Set limit pointer as to what we zero out during construction
    // 
    BYTE* PMemberMax() { return (BYTE*)&m_pArrayInfo + sizeof(m_pArrayInfo); }


    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    friend GenericInstantiator<CallFrame>;

    CallFrame()
    {
        m_refs              = 1;    // nb starts at one

        Zero(PMemberFirst(), PtrToUlong(PMemberMax()) - PtrToUlong(PMemberFirst()));
        
        Zero(&m_blobBuffer);
        m_fWeOwnBlobBuffer = FALSE;

        m_pvMemCur = &m_pvMem[0];

        m_fIsCopy = FALSE;

#ifdef DBG
        memset(&m_pvMem[0], 0xBB, CB_PRIVATE_BUFFER);   // init to something we'll recognize in the debugger
#endif
    }

    ~CallFrame();

    HRESULT Init() const
    {
        return S_OK;
    }

#define SetStackLocation_(pvArgs) { m_pvArgs = pvArgs; SetFromUser(m_pvArgs); }

    void Init(void* pvArgs, MD_METHOD* pmdMethod, Interceptor* pInterceptor);

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrame
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL GetInfo(CALLFRAMEINFO *pInfo);

    HRESULT STDCALL GetIIDAndMethod(IID*, ULONG*);

    HRESULT STDCALL GetNames(LPWSTR* pwszInterface, LPWSTR* pwszMethod);

    PVOID STDCALL GetStackLocation()
    {
        return m_pvArgs;
    }

    void STDCALL SetStackLocation(PVOID pvArgs)
    {
        SetStackLocation_(pvArgs);
    }

    HRESULT STDCALL GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS	mshlflags, ULONG *pcbBufferNeeded);

    HRESULT STDCALL Marshal( 
        CALLFRAME_MARSHALCONTEXT  *pmshlContext,
        MSHLFLAGS	mshlflags,	/* As in the IMarshal interface */
        PVOID pBuffer,
        ULONG cbBuffer,
        ULONG  *pcbBufferUsed,
        RPCOLEDATAREP* pdataRep,
        ULONG *prpcFlags);

    void MarshalParam(MIDL_STUB_MESSAGE& stubMsg, ULONG iParam, const PARAM_DESCRIPTION& param, const PARAM_ATTRIBUTES paramAttr, PBYTE pArg);

    HRESULT STDCALL Unmarshal         (PVOID pBuffer, ULONG cbBuffer,                       RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT*, ULONG* pcbUnmarhalled);
    HRESULT STDCALL ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx);
    
    void UnmarshalParam(MIDL_STUB_MESSAGE& stubMsg, const PARAM_DESCRIPTION& param, const PARAM_ATTRIBUTES paramAttr, PBYTE pArg);
    
    HRESULT STDCALL Free( 
        ICallFrame*        pframeArgsDest,
        ICallFrameWalker*  pWalkerFreeDest,
        ICallFrameWalker*  pWalkerCopy,
        DWORD              freeFlags,
        ICallFrameWalker*  pWalkerFree,
        DWORD              nullFlags);

    HRESULT STDCALL FreeParam(
        ULONG              iparam,
        DWORD              freeFlags,
        ICallFrameWalker*  pWalkerFree,
        DWORD              nullFlags);
    
    void STDCALL SetReturnValue(HRESULT hrReturnValue)
    {
        m_hrReturnValue = hrReturnValue;
    }
    HRESULT STDCALL GetReturnValue()
    {
        return (HRESULT)m_hrReturnValue;
    }
    HRESULT GetReturnValueFast()
    {
        return (HRESULT)m_hrReturnValue;
    }

    HRESULT STDCALL Invoke(void *pvReceiver, ...);

    HRESULT STDCALL Copy(
        CALLFRAME_COPY callControl,
        ICallFrameWalker* pWalker,
        ICallFrame** ppFrame
    );

    HRESULT STDCALL WalkFrame(DWORD walkWhat, ICallFrameWalker *pWalker);

    HRESULT STDCALL GetParamInfo(IN ULONG iparam, OUT CALLFRAMEPARAMINFO*);
    HRESULT STDCALL GetParam(ULONG iparam, VARIANT* pvar);
    HRESULT STDCALL SetParam(ULONG iparam, VARIANT* pvar);


    ///////////////////////////////////////////////////////////////////
    //
    // Xml Marshalling
    //
    ///////////////////////////////////////////////////////////////////
    HRESULT STDCALL MarshalXml( 
        CALLFRAME_MARSHALCONTEXT  *pmshlContext,
        MSHLFLAGS	mshlflags,	/* As in the IMarshal interface */
        PVOID pBuffer,
        ULONG cbBuffer,
        ULONG  *pcbBufferUsed,
        RPCOLEDATAREP* pdataRep,
        ULONG *prpcFlags);

    void MarshalParamXml(
        MIDL_STUB_MESSAGE& stubMsg,
        ULONG iParam,
        const PARAM_DESCRIPTION& param,
        const PARAM_ATTRIBUTES paramAttr,
        PBYTE pArg);

    HRESULT STDCALL UnmarshalXml(
        PVOID pBuffer,
        ULONG cbBuffer,
        RPCOLEDATAREP dataRep,
        CALLFRAME_MARSHALCONTEXT*,
        ULONG* pcbUnmarhalled);

    void UnmarshalParamXml(
        MIDL_STUB_MESSAGE& stubMsg,
        const PARAM_DESCRIPTION& param,
        const PARAM_ATTRIBUTES paramAttr,
        PBYTE pArg);
    

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrameInit
    //
    ///////////////////////////////////////////////////////////////////

    CallFrame* STDCALL GetCallFrame()
    {
        return this;
    }

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    LONG        m_refs;

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv);
    ULONG   STDCALL AddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL Release()  { long crefs = InterlockedDecrement(&m_refs); if (crefs == 0) delete this; return crefs;}

    ///////////////////////////////////////////////////////////////////
    //
    // Memory management
    //
    ///////////////////////////////////////////////////////////////////

    enum { CB_PRIVATE_BUFFER = 256 };
    //
    // We maintain inside ourselves a chunk of memory that we use in order to do very quickly
    // get memory needed in copied frames. If we run out of this memory, we start getting memory
    // from the task allocator. We also use this memory for the child stack itself, so the size
    // of this buffer effectively puts a limit on the size of a stack frame we can deal with.
    //
    BYTE  m_pvMem[CB_PRIVATE_BUFFER];
    BOOL  m_fCanUseBuffer;
    //
    // Also, during an unmarshal call, we are given a buffer into which some of the umarshalled
    // data might eventually point. We are not to free such pointers, of course. Further we might
    // actually own the buffer, and so be responsible for freeing it when we go bye bye.
    //
    BLOB  m_blobBuffer;
    BOOL  m_fWeOwnBlobBuffer;


    void* AllocBuffer(size_t cb);
    void* Alloc(size_t cb);
#ifdef DBG
    void* Alloc_(size_t cb, PVOID pvReturnAddress);
#endif

    void* Alloc(size_t cb, BOOL fForceAlloc)
    {
        // Kernel-mode CallFrames on user-mode stacks should never allocate using
        // their (kernel-mode) temporary buffer, but rather always allocate user
        // mode memory.
        //
        if (!m_fCanUseBuffer)
        {
            fForceAlloc = TRUE;
        }

        if (fForceAlloc)
        {
#ifdef DBG
            return Alloc_(cb, _ReturnAddress());
#else
            return Alloc(cb);
#endif
        }
        else
        {
            return AllocBuffer(cb);
        }
    }


    HRESULT AllocStack(size_t cb, BOOL fForceUserMode = FALSE)
    {
        ASSERT(m_pvArgs == NULL);
        //
        // Automatically determine size if we can and if asked to
        //
        if (cb == 0)
        {
            cb = m_pmd->m_cbPushedByCaller;
        }
        ASSERT(cb > 0); // should always have at least a receiver

        if (m_fIsCopy)
            Free(m_pvArgs);

        // SetStackLocation assigns to m_pvArgs.
        SetStackLocation_(AllocBuffer(cb));

        if (NULL != m_pvArgs)
        {
            m_fIsCopy = TRUE;
            Zero(m_pvArgs, cb);

            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    void  Free(void* pv);
    BOOL  WeOwn(void* pv);

    ///////////////////////////////////////////////////////////////////
    //
    // Worker routines
    //
    ///////////////////////////////////////////////////////////////////

    void           CopyWorker                (BYTE* pMemoryFrom, BYTE** ppMemoryTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);
    void           CopyConformantArrayPriv   (BYTE* pMemoryFrom, BYTE** ppMemoryTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);
    void           CopyEmbeddedPointers      (BYTE* pbFrom, BYTE* pbTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);
    PFORMAT_STRING CopyEmbeddedRepeatPointers(BYTE* pbFrom, BYTE* pbTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);

    void           FreeWorker                (BYTE* pMemoryFrom, PFORMAT_STRING pFormat, BOOL fFreePointer);
    void           FreeEmbeddedPointers      (BYTE* pMemory,     PFORMAT_STRING pFormat);
    PFORMAT_STRING FreeEmbeddedRepeatPointers(BYTE* pMemory,     PFORMAT_STRING pFormat);

    void            WalkWorker                  (BYTE* pMemory, PFORMAT_STRING pFormat);
    void            WalkConformantArrayPriv     (BYTE* pMemory, PFORMAT_STRING pFormat);
    PFORMAT_STRING  WalkEmbeddedRepeatPointers  (BYTE* pMemory, PFORMAT_STRING pFormat);
    void            WalkEmbeddedPointers        (BYTE* pMemory, PFORMAT_STRING pFormat);

    void OutInit(CallFrame*, BYTE** ppArgFrom, BYTE** ppArgTo, PFORMAT_STRING pFormat);
    void OutCopy(            BYTE*  pMemFrom,  BYTE*  pMemTo,  PFORMAT_STRING pFormat);
    void OutZero(            BYTE*  pMem,                      PFORMAT_STRING pFormat, BOOL fDst = TRUE);

//Review API Change for WIN64
#ifndef _WIN64
    ULONG ComputeConformance(BYTE* pMemory, PFORMAT_STRING pFormat,                                BOOL fProbeSrc);
#else
    ULONGLONG ComputeConformance(BYTE* pMemory, PFORMAT_STRING pFormat,                                BOOL fProbeSrc);
#endif

    void  ComputeVariance   (BYTE* pMemory, PFORMAT_STRING pFormat, ULONG* pOffset, ULONG* pCount, BOOL fProbeSrc);
    BYTE* MemoryIncrement   (BYTE* pMemory, PFORMAT_STRING pFormat,                                BOOL fProbeSrc);

    BOOL ByValue(const PARAM_ATTRIBUTES& paramAttr, PFORMAT_STRING pFormatParam,   BOOL fFromCopy) const;
    BOOL FIndirect(BYTE bPointerAttributes,         PFORMAT_STRING pFormatPointee, BOOL fFromCopy) const;
    BOOL IsSafeArray(PFORMAT_STRING pFormat) const;

    PBYTE* GetAllocatedPointer(PBYTE& pbIn)
        // Get a new pointer that will probe correctly in the destination space. pbIn
        // should be a stack variable that we might use for scratch.
    {
#ifdef KERNELMODE
        if (m_pAllocatorFrame && m_fToUser)
        {
            return (PBYTE*)m_pAllocatorFrame->Alloc(sizeof(PBYTE), TRUE);
        }
        else
#endif
        {
            return &pbIn;
        }
    }

    void FreeAllocatedPointer(PBYTE* ppb)
    {
#ifdef KERNELMODE
        if (m_pAllocatorFrame && m_fToUser)
        {
            m_pAllocatorFrame->Free(ppb);
        }
        else
#endif
        {
#ifndef _WIN64
            DEBUG(*ppb = (PBYTE)0xfefefefe);
#else
            DEBUG(*ppb = (PBYTE)0xfefefefefefefefe);
#endif
        }
    }


    BYTE* SetMemory(BYTE* pMemory)
    {
        BYTE* p = m_Memory;
        m_Memory = pMemory;
        return p;
    }
    
    CallFrame* GetFrame(CallFrame*& pFrame, PVOID pvArgs);

    OAUTIL GetHelper() const
    {
        return OAUTIL(m_fFromUser, m_fToUser, m_pWalkerCopy, m_pWalkerFree, m_pWalkerWalk, m_fWorkingOnInParam, m_fWorkingOnOutParam);
    }
    OAUTIL GetWalker() const
    {
        return OAUTIL(FALSE, FALSE, m_pWalkerCopy, m_pWalkerFree, m_pWalkerWalk, m_fWorkingOnInParam, m_fWorkingOnOutParam);
    }
    BOOL AnyWalkers() const
    {
        return m_pWalkerCopy || m_pWalkerFree || m_pWalkerWalk;
    }

    BOOL CanShareParameter(ULONG iparam) const
    {
        return m_pmd->m_rgParams[iparam].m_fCanShare;
    }

    ULONG CbParam(ULONG iparam, const PARAM_DESCRIPTION& param) const
    {
        return (iparam == m_pmd->m_numberOfParams ? m_pmd->m_cbPushedByCaller : m_pmd->m_params[iparam+1].StackOffset) - param.StackOffset;
    }
    
    void GetStackSize(ULONG* pcbArgs) const
    {
        *pcbArgs = m_pmd->m_cbPushedByCaller;
    }

    ///////////////////////////////////////////////////////////////////
    //
    // Misc
    //
    ///////////////////////////////////////////////////////////////////

    PMIDL_STUB_DESC GetStubDesc() const
    {
        PMIDL_SERVER_INFO pServerInfo = (PMIDL_SERVER_INFO) m_pmd->m_pHeader->pServerInfo;
        return pServerInfo->pStubDesc;
    }

    //////////////////////////////////////////

    BSTR SysAllocStringSrc(LPCWSTR wszSrc)
    {
		TestReadSrc(wszSrc, (ULONG)wcslen(wszSrc));
		return g_oaUtil.SysAllocString(wszSrc);
    }

	BSTR SysCopyBSTRSrc(BSTR bstrSrc)
    {
		UINT len = g_oaUtil.SysStringByteLen(bstrSrc);
		TestReadSrc(bstrSrc, len);
		return g_oaUtil.SysAllocStringByteLen((LPCSTR)bstrSrc, len);
    }

    void SysFreeStringDst(BSTR bstrDst)
    {
        if (bstrDst)
        {
            BSTR_INTERNAL* pint = BSTR_INTERNAL::From(bstrDst);
            TestWriteDst(pint, (ULONG)pint->CbAlloc());
            g_oaUtil.SysFreeString(bstrDst);
        }
    }

};

//////////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\rot\getif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       getif.cxx
//
//  Contents:   APIs used to get an interface from a window
//
//  Classes:    CEndPointAtom
//
//  Functions:  AssignEndpointProperty
//              GetInterfaceFromWindowProp
//              PrivDragDrop
//              UnmarshalDragDataObject
//
//  History:
//              29-Dec-93 Ricksa    Created
//              01-Feb-94 alexgo    fixed a bug in multiple registration
//              29-Mar-94 brucema   GetInterfaceFromWindowProp returns E_FAIL
//                                  for invalid endpoint
//              18-May-94 alexgo    fixed race condition in
//                                  RemGetInterfaceFromWindowProp
//              15-Jun-94 JohannP   added apartment support
//              28-Jul-94 BruceMa   Memory sift fix
//              30-Sep-94 Ricksa    Drag/Drop optimization
//		08-Nov-94 alexgo    added PrivDragDrop protocol
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <crot.hxx>
#include    <getif.h>
#include    <getif.hxx>
#include    <dragopt.h>
#include    <resolver.hxx>


#define ENDPOINT_PROP_NAME      L"OleEndPointID"
#define OLEDRAG_DATAOBJ_PROP	L"Drag_DataObj_Prop"


static WCHAR *apwszValidProperties[] = { OLE_DROP_TARGET_PROP,
					 CLIPBOARD_DATA_OBJECT_PROP };
const int MAX_PROPERTIES = sizeof(apwszValidProperties) / sizeof(WCHAR *);

extern ATOM g_aDropTarget;

HRESULT UnmarshalFromEndpointProperty(HWND hWnd,
				      IInterfaceFromWindowProp **ppIFWP,
				      BOOL *pfLocal);

//+-------------------------------------------------------------------------
//
//  Class:  	CInterfaceFromWindowProp
//
//  Purpose:  	Passes back interface pointers stored on windows for drag drop
//
//  Interface:  IInterfaceFromWindowProp
//
//  History:    dd-mmm-yy Author    Comment
//		14 May 95 AlexMit   Created
//
//--------------------------------------------------------------------------
class CInterfaceFromWindowProp : public IInterfaceFromWindowProp,
				 public CPrivAlloc
{
public:
    CInterfaceFromWindowProp();

    STDMETHOD (QueryInterface)   ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );

    STDMETHOD (GetInterfaceFromWindowProp)(
	HWND hWnd,
	REFIID riid,
	IUnknown **ppunk,
	WCHAR *pwszPropertyName );

    STDMETHOD (PrivDragDrop)(
        HWND  hWnd,
        InterfaceData *pIFDDataObject,
	    DWORD dop,
        DWORD grfKeyState,
        POINTL pt,
        DWORD *pdwEffect,
        DWORD dwSmId,
	    IDataObject *pRealDataObject,
	    HWND  hwndSource );

private:
    ULONG _ulRefCnt;	// Reference count
};

//+-------------------------------------------------------------------
//
//  Member:	CInterfaceFromWindowProp::CInterfaceFromWindowProp, public
//
//  Synopsis:	construction
//
//  History:	10 Apr 95    AlexMit     Created
//
//--------------------------------------------------------------------
CInterfaceFromWindowProp::CInterfaceFromWindowProp() : _ulRefCnt(1)
{
}

//+-------------------------------------------------------------------
//
//  Member:	CInterfaceFromWindowProp::AddRef, public
//
//  Synopsis:	increment reference count
//
//  History:	10 Apr 95    AlexMit     Created
//
//--------------------------------------------------------------------
ULONG CInterfaceFromWindowProp::AddRef(void)
{
    InterlockedIncrement((long *)&_ulRefCnt);
    return _ulRefCnt;
}

//+-------------------------------------------------------------------
//
//  Member:	CInterfaceFromWindowProp::Release, public
//
//  Synopsis:	decrement reference count
//
//  History:	10 Apr 95    AlexMit     Created
//
//--------------------------------------------------------------------
ULONG CInterfaceFromWindowProp::Release(void)
{
    ULONG RefCnt = _ulRefCnt-1;
    if (InterlockedDecrement((long*)&_ulRefCnt) == 0)
    {
	delete this;
	return 0;
    }

    return RefCnt;
}

//+-------------------------------------------------------------------
//
//  Member:     CInterfaceFromWindowProp::QueryInterface, public
//
//  Synopsis:   returns supported interfaces
//
//  History:	10 Apr 95   AlexMit	Created
//
//--------------------------------------------------------------------
STDMETHODIMP CInterfaceFromWindowProp::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IInterfaceFromWindowProp) ||  //   more common than IUnknown
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IInterfaceFromWindowProp *) this;
	AddRef();
	return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------------
//
//  Class:  	SDDInfo
//
//  Purpose:  	caches information across drag drop calls
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
// 		08-Jan-95 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
struct SDDInfo : public CPrivAlloc
{
    BOOL                      fLocal;
    IInterfaceFromWindowProp *pIFWP;

    SDDInfo(HWND hWnd, HRESULT& hr);
    ~SDDInfo();
};

//+-------------------------------------------------------------------------
//
//  Member:  	SDDInfo::SDDInfo
//
//  Synopsis:	constructor
//
//  Effects:
//
//  Arguments:	[hr]		-- the return result
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Jan-95 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
inline SDDInfo::SDDInfo(HWND hWnd, HRESULT& hr)
{
    hr = UnmarshalFromEndpointProperty(hWnd,
				       &pIFWP,
				       &fLocal);
}

//+-------------------------------------------------------------------------
//
//  Member:  	SDDInfo::SDDInfo
//
//  Synopsis:	destructor
//
//  Effects:
//
//  History:    dd-mmm-yy Author    Comment
// 		14 May 95 AlexMit   Destroyed
//
//--------------------------------------------------------------------------
inline SDDInfo::~SDDInfo()
{
    if (pIFWP != NULL)
    {
	pIFWP->Release();
	pIFWP = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Class:      CEndPointAtom
//
//  Purpose:    Abstract way of init/delete global atom for end point property
//
//  Interface:  GetPropPtr - get atom of appropriate type to pass to prop APIs
//
//  History:    31-Dec-93 Ricksa    Created
//
//--------------------------------------------------------------------------
class CEndPointAtom
{
public:
                        ~CEndPointAtom(void);

    LPCWSTR             GetPropPtr(void);

private:

    static ATOM		 s_AtomProp;
};

// make this static since there is only one of them and so we dont have
// to run a ctor at process intialization time.

ATOM CEndPointAtom::s_AtomProp = 0;

// Atom for endpoint property string
CEndPointAtom epatm;


//+-------------------------------------------------------------------------
//
//  Member:     CEndPointAtom::~CEndPointAtom
//
//  Synopsis:   Clean up atom at destruction of object
//
//  History:    31-Dec-93 Ricksa    Created
//
//--------------------------------------------------------------------------
inline CEndPointAtom::~CEndPointAtom(void)
{
    if (s_AtomProp != 0)
    {
	//
        //  16-bit WinWord is evil and does not call UnregisterDragDrop
        //  before terminating.  When a window is destroyed under Win95,
        //  all attached properties are removed and atoms deleted.  This
        //  causes a problem with other applications when more deletes than
        //  adds are performed.  This 'hack' will disable the deletion of
        //  the EndPointAtom under Chicago.  Not a big deal since the
        //  Explorer will keep this Atom alive anyways.
        //
#if !defined(_CHICAGO_)
	GlobalDeleteAtom(s_AtomProp);
#endif
	s_AtomProp = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CEndPointAtom::GetPropPtr
//
//  Synopsis:   Return an atom suitable for passing to prop APIs
//
//  Returns:    Endpoint string as atom or NULL.
//
//  History:    31-Dec-93 Ricksa    Created
//
//--------------------------------------------------------------------------
inline LPCWSTR CEndPointAtom::GetPropPtr(void)
{
    if (s_AtomProp == 0)
    {
	s_AtomProp = GlobalAddAtom(ENDPOINT_PROP_NAME);
    }

    return (LPCWSTR) s_AtomProp;
}

//+-------------------------------------------------------------------------
//
//  Function:   AssignEndpointProperty
//
//  Synopsis:   Assigns a end point as a property of a window
//
//  Arguments:  [hWnd] - window to assign the endpoint property
//
//  Returns:    S_OK - end point successfully added to the window
//              E_INVALIDARG - property could not be set
//
//  Algorithm:  Get the endpoint Id and assign it as a property to the
//              window.
//
//  History:
//              26-Jul-94 AndyH     #20843 - restarting OLE in the shared WOW
//              01-Feb-94 alexgo    fixed a bug to ensure that
//                                  RpcServerRegisterIf gets called only
//                                  once.
//              29-Dec-93 Ricksa    Created
//		22-Jan-95 Rickhi    marshaled interface stored in SCM
//
//--------------------------------------------------------------------------
extern "C" HRESULT AssignEndpointProperty(HWND hWnd)
{
    ComDebOut((DEB_ROT, "AssignEndpointProperty hWnd:%x\n", hWnd));

    // Create an object for this window.
    CInterfaceFromWindowProp *pIFWP = new CInterfaceFromWindowProp;
    if (pIFWP == NULL)
    {
	return E_OUTOFMEMORY;
    }

    // Marshal the interface into the OBJREF
    DWORD_PTR  dwCookie;
    OBJREF objref;
    HRESULT hr = MarshalObjRef(objref, IID_IInterfaceFromWindowProp, pIFWP,
			       MSHLFLAGS_TABLESTRONG, MSHCTX_LOCAL, NULL);

    if (SUCCEEDED(hr))
    {
	OXID_INFO oxidInfo;
	hr = FillLocalOXIDInfo(objref, oxidInfo);

        if (SUCCEEDED(hr))
        {
            // register the STDOBJREF part of the marshaled interface with the SCM
            hr = gResolver.RegisterWindowPropInterface(hWnd,
                                                       &objref.u_objref.u_standard.std,
                                                       &oxidInfo,
                                                       &dwCookie);
            if (SUCCEEDED(hr))
            {
                // Stuff the magic values in properties on the window.
                if (!SetProp(hWnd, epatm.GetPropPtr(), (void *) dwCookie))
                {
                    hr = E_INVALIDARG;
                }
            }

            // Free the resources containing the String Bindings.
            MIDL_user_free(oxidInfo.psa);
        }

        // release the resources held by the objref.
        FreeObjRef(objref);
    }

    // The stub holds the object alive until UnAssignEndpointProperty
    // is called.  Get rid of the extra reference.
    pIFWP->Release();

    ComDebOut((DEB_ROT, "AssignEndpointProperty hr:%x dwCookie:%x\n", hr, dwCookie));
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   UnAssignEndpointProperty
//
//  Synopsis:   Remove end point property
//
//  Arguments:  [hWnd] - window to remove the endpoint property
//		[dwAssignAptID] - Apartment that Assigned the Endpoint Property
//
//  Returns:    S_OK - end point successfully removed from the window
//              E_INVALIDARG - property could not be removed
//
//  Algorithm:  Remove the end point id property from the window.
//
//  History:	30-Dec-93 Ricksa    Created
//		22-Jan-95 Rickhi    marshaled interface stored in SCM
//		15-Apr-96 Rogerg    Added dwAssignThreadID.
//
//--------------------------------------------------------------------------
extern "C" HRESULT UnAssignEndpointProperty(HWND hWnd,DWORD* dwAssignAptID)
{
    ComDebOut((DEB_ROT, "UnAssignEndpointProperty hWnd:%x\n", hWnd));

    // Read the cookie value from the window property and remove the
    // property from the window.

//
// Sundown v-thief 06/98: GetProp()'s returned HANDLE can be truncated to a DWORD
//                        The returned value is an atom.
//
//
// Note: There is still a major decision to make. In scm.idl and with the fact that
//       com\dcomrem\resolver.cxx:CRpcResolver::GetWindowPropInterface() stores an HWND in 
//       dwCookie. Should we modify the interface?. 
//       In a wider scope: what is the MIDL solution for HWND in remotable or local interfaces?
//
	LPCWSTR   wszProp  = epatm.GetPropPtr();
    DWORD_PTR dwCookie = (wszProp ? (DWORD_PTR)RemoveProp(hWnd, wszProp) : 0);
    BOOL      fSuccess = (dwCookie != 0);

    // use the cookie to extract and release the STDOBJREF entry from the SCM
    OBJREF     objref;
    OXID_INFO  oxidInfo;
    memset(&oxidInfo, 0, sizeof(oxidInfo));

    HRESULT hr = gResolver.GetWindowPropInterface(hWnd, 
                                                  dwCookie,
												  TRUE, // fRevoke
												  &objref.u_objref.u_standard.std,
												  &oxidInfo);
    if (SUCCEEDED(hr))
    {
		BOOL fLocal;

		hr = CompleteObjRef(objref, oxidInfo, IID_IInterfaceFromWindowProp, &fLocal);
		
		MIDL_user_free(oxidInfo.psa);

		if (SUCCEEDED(hr))
		{
			// release the marshal data and free resources on the ObjRef
			hr = ReleaseMarshalObjRef(objref);
			FreeObjRef(objref);
		}
    }

    if (!fSuccess && SUCCEEDED(hr))
    {
        hr = E_INVALIDARG;
    }

    *dwAssignAptID = SUCCEEDED(hr) ? oxidInfo.dwTid : 0;

    ComDebOut((DEB_ROT, "UnAssignEndpointProperty hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:	UnmarshalFromEndpointProperty
//
//  Synopsis:	Get the IInterfaceFromWindowProp interface from the window
//
//  Arguments:	[hWnd] - window to get the endpoint property
//
//  Returns:    S_OK - end point successfully removed from the window
//              E_INVALIDARG - property could not be removed
//
//  Algorithm:
//
//  History:	22-Jan-95 Rickhi    Created
//
//--------------------------------------------------------------------------
HRESULT UnmarshalFromEndpointProperty(HWND hWnd,
				      IInterfaceFromWindowProp **ppIFWP,
				      BOOL *pfLocal)
{
    HRESULT hr = E_INVALIDARG;
    *ppIFWP = NULL;

    // get the magic cookie from the window

//
// Sundown v-thief 06/98: GetProp()'s returned HANDLE can be truncated to a DWORD
//                        The returned value is an atom.
//

    DWORD_PTR dwCookie = (DWORD_PTR) GetProp(hWnd, epatm.GetPropPtr());

    if (dwCookie != NULL)
    {
	// Get a proxy to the CInterfaceFromWindowProp object.  Note
	// that if this is the thread that object is on, it will just
	// return the real object.

	OBJREF	   objref;
	OXID_INFO  oxidInfo;
	memset(&oxidInfo, 0, sizeof(oxidInfo));

	hr = gResolver.GetWindowPropInterface(hWnd, 
                                              dwCookie,
					      FALSE, // fRevoke
					      &objref.u_objref.u_standard.std,
					      &oxidInfo);

	if (SUCCEEDED(hr))
	{
	    hr = CompleteObjRef(objref, oxidInfo, IID_IInterfaceFromWindowProp, pfLocal);

	    MIDL_user_free(oxidInfo.psa);

	    if (SUCCEEDED(hr))
	    {
		// unmarshal and release resouces on the ObjRef
		hr = UnmarshalObjRef(objref, (void **) ppIFWP);
		FreeObjRef(objref);
	    }
	}
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetInterfaceFromWindowProp
//
//  Synopsis:   Get an interface that is assigned to a window as a property
//
//  Arguments:  [hWnd] - window of interest
//              [riid] - interface we want back
//              [ppunk] - where to put the requested interface pointer
//              [pwszPropertyName] - name of property holding interface.
//
//  Returns:    S_OK - got the interface
//              E_INVALIDARG - no endpoint property
//
//  Algorithm:  Get the end point from the window and then convert that
//              end point to a proxy. Then call the remote
//              get interface call to get the actual interface.
//
//  History:    29-Dec-93 Ricksa    Created
//		20-Jul-94 alexgo    Optimization for same-thread case
//		22-Jan-95 Rickhi    marshaled interface stored in SCM
//
//--------------------------------------------------------------------------
extern "C" GetInterfaceFromWindowProp(
    HWND hWnd,
    REFIID riid,
    IUnknown **ppunk,
    LPOLESTR pwszPropertyName)
{
    ComDebOut((DEB_ROT,
	"GetInterfaceFromWindowProp hWnd:%x ppunk:%x riid:%I pszPropName%ws\n",
	hWnd, ppunk, &riid, pwszPropertyName));

    *ppunk = NULL;

    BOOL fLocal;
    IInterfaceFromWindowProp *pIFWP;
    HRESULT hr = UnmarshalFromEndpointProperty(hWnd, &pIFWP, &fLocal);

    if (SUCCEEDED(hr))
    {
	hr = pIFWP->GetInterfaceFromWindowProp( hWnd,
					       riid, ppunk,
					       pwszPropertyName);
	pIFWP->Release();
    }

    ComDebOut((DEB_ROT,
	"GetInterfaceFromWindowProp *ppunk:0x%p hr:%x\n", *ppunk, hr));
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Method:	CInterfaceFromWindowProp::GetInterfaceFromWindowProp, public
//
//  Synopsis:   Get information from object server ROT
//
//  Arguments:  [pData] - data for call
//
//  Returns:    S_OK - got information
//              S_FALSE - entry for moniker not found in the ROT
//              E_INVALIDARG - bad arguments
//
//  Algorithm:  Unmarshal the moniker interface. Then look up the object
//              in the ROT. If found, return the requested data.
//
//  History:    15-Dec-93 Ricksa    Created
//              18-May-94 alexgo    fixed race condition, this function now
//                                  fetches the interface from the hwnd
//
//--------------------------------------------------------------------------
STDMETHODIMP CInterfaceFromWindowProp::GetInterfaceFromWindowProp(
    HWND hWnd,
    REFIID riid,
    IUnknown **ppunk,
    WCHAR *pwszPropertyName )
{
    HRESULT hr;

    // Validate the requested property
    for (int i = 0; i < MAX_PROPERTIES; i++)
    {
        if (lstrcmpW(apwszValidProperties[i], pwszPropertyName) == 0)
        {
            break;
        }
    }

    if (i == MAX_PROPERTIES)
    {
	*ppunk = NULL;
	return E_INVALIDARG;
    }

    // Get the interface pointer from the window
    *ppunk = (IUnknown *) GetProp( hWnd, pwszPropertyName );

    // Could we get the property requested?
    if (*ppunk != NULL)
    {
	hr = S_OK;
	(*ppunk)->AddRef();
    }
    else
    {
        // No property -- this can happen when the object got shutdown
        // during the time that the client was trying to get the property.
        hr = E_FAIL;
    }
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Method:	CInterfaceFromWindowProp::PrivDragDrop, public
//
//  Synopsis: 	interprets the DragOp parameter and makes the appropriate
//		call to the drop target.
//
//  Effects:
//
//  Arguments:	[hwnd]		-- the target window
//	 	[dop]		-- the drag drop op
//		[grfKeyState] 	-- the keyboard state
//		[ptl]		-- the mouse position
//		[pdwEffects] 	-- the drag drop effects
//		[pIFDataObject]	-- interface data for the drag data object
//		[dwSmId]	-- shared memory ID for the data formats
//		[hwndSource]	-- the window handle to the drag drop source
//				   (i.e. our private dragdrop/clipboard
//				   window)
//
//  Requires: 	pIFDataObject && dwSmId must be NULL if pRealDataObj is
//		not NULL.
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//		finds the drop target and calls it according to 'dop'
//		(the drag drop op code)
//
//		for DRAGOP_ENTER:
//			create the psuedo-data object for returning enumerated
//			formats. Stuff this data object as a property on the
//			target window.  Then through to the actual drag enter
//			object.
//
// 		for DRAGOP_OVER:
//			simply call IDropTarget::DragOver
//
//		for DRAGOP_LEAVE
//			remove the data object from the target window
//			and call IUnknown->Release();  Then call IDropTarget::
//			DragLeave
//
//		for DRAGOP_DROP
//			remove the data object from the target window and
//			pass it into IDropTarget::Drop call.  Once the call
//			completes, Release the data object
//
//  History:    dd-mmm-yy Author    Comment
//		08-Nov-94 alexgo    author
//
//  Notes:
//		HACK ALERT!!  It is important that we use the same data object
//		for DragEnter and Drop calls.  Some 16bit apps (like
//		MS PowerPoint) check to see if the data object pointer value
//		is the same--if it's not, then they fail the drop call.
//
//--------------------------------------------------------------------------
STDMETHODIMP CInterfaceFromWindowProp::PrivDragDrop(
        HWND hwnd,
		InterfaceData *pIFDataObject,
		DWORD dop,
		DWORD grfKeyState,
		POINTL ptl,
	    DWORD * pdwEffects,
		DWORD dwSmId,
		IDataObject *pRealDataObject,
		HWND hwndSource )
{
    IDropTarget *pIDropTarget;
    IDataObject *pIDataObject;
    HRESULT	hr = E_FAIL;


#if DBG == 1
    if( pRealDataObject != NULL )
    {
	Assert(!pIFDataObject);
    }
#endif // DBG == 1

    pIDropTarget = (IDropTarget *)GetProp((HWND) hwnd, (LPCWSTR)g_aDropTarget);

    if (pIDropTarget != NULL)
    {
	// check the drag drop op code and do the right thing

	switch( dop )
	{
	case DRAGOP_ENTER:
	    // Create a data object for use in the Drag Enter if we
	    // weren't given one

	    if( pRealDataObject == NULL )
	    {
		InterfaceData *pIFTemp = NULL;

		Assert(pIFDataObject);

		if( pIFDataObject )
		{
		    // we need to make a copy of the interface data, as
		    // the fake data object may use it after this function
		    // returns (see ido.cpp)
	
		    pIFTemp = (InterfaceData *)PrivMemAlloc(
				    IFD_SIZE(pIFDataObject));
	
		    if( !pIFTemp )
		    {
			return E_OUTOFMEMORY;
		    }
	
		    memcpy(pIFTemp, pIFDataObject,
			    IFD_SIZE(pIFDataObject));
		}
		hr = CreateDragDataObject(pIFTemp, dwSmId,
			&pIDataObject);
	    }
	    else
	    {
		pIDataObject = pRealDataObject;
		pIDataObject->AddRef();
		hr = NOERROR;
	    }

	    if (hr == NOERROR)
	    {
		// Call through to the drop target
		hr = pIDropTarget->DragEnter(
			pIDataObject,
			grfKeyState,
			ptl,
			pdwEffects);

		// Bug#12835 Win16 set the DROPEFFECT to none on an error returned by DragEnter
                //  but continued the drag within the window
                if ( (NOERROR != hr) && IsWOWThread() )
                {
		    *pdwEffects = DROPEFFECT_NONE;
		    hr = NOERROR;
		}

		if (NOERROR == hr)
		{
		    SetProp((HWND) hwnd, OLEDRAG_DATAOBJ_PROP, pIDataObject);
		}
		else
		{
		    pIDataObject->Release();
		}
	    }

	    break;

	case DRAGOP_OVER:

	    hr = pIDropTarget->DragOver(grfKeyState, ptl, pdwEffects);

	    break;

	case DRAGOP_LEAVE:

	    pIDataObject = (IDataObject *)RemoveProp((HWND) hwnd,	
				OLEDRAG_DATAOBJ_PROP);

	    if( pIDataObject )
	    {
		pIDataObject->Release();
	    }

	    hr = pIDropTarget->DragLeave();

	    break;

	case DRAGOP_DROP:

	    pIDataObject = (IDataObject *)RemoveProp((HWND) hwnd,
				OLEDRAG_DATAOBJ_PROP);


	    if( pIDataObject )
	    {
		DWORD pidSource;
		DWORD tidSource;
		BOOL fAttached = FALSE;

		// HACK ALERT!!!  Some 16bit apps (like Word) try to
		// become the foreground window via SetActiveWindow.
		// However, if a 32bit app is the source, it is the
		// foreground *thread*; SetActiveWindow only makes the
		// window the foreground window for the current input
		// queue.
		// In order to maket this work, if we are a 16bit target
		// and the source exists in a different process (either
		// a 32bit process or a different VDM), then attach
		// our input queue to the source's input queue.
		//
		// Within one VDM the thread's queues are already attached

		if( IsWOWThread() && hwndSource != NULL )
		{
		    tidSource = GetWindowThreadProcessId((HWND)hwndSource,
					&pidSource);

		    if( pidSource != GetCurrentProcessId() )
		    {
			AttachThreadInput(GetCurrentThreadId(), tidSource,
			    TRUE);
			fAttached = TRUE;
		    }
		}

		hr = pIDropTarget->Drop( pIDataObject, grfKeyState, ptl,
			    pdwEffects);

		if( fAttached == TRUE )
		{
		    AttachThreadInput(GetCurrentThreadId(), tidSource,
			    FALSE);
		}

		pIDataObject->Release();
	    }

	    break;

	default:
	    Assert(0);
	    hr = E_UNEXPECTED;

	}

	// HACK ALERT!! Well, it turns out that 16bit OLE used
	// "CurScrollMove" for the Scroll-NoDrop cursor.  Better yet,
	// MFC *depends* on this in their drag drop implementation.
	// An MFC target doing scroll-move will actually return
	// drop effect scroll-nodrop.
	//
	// So if we are in a 16bit app as the target, munge the
	// effect to better match 16bit OLE behavior.

	if( IsWOWThread() && pdwEffects )
	{
	    // test for SCROLL-NODROP
	    if( *pdwEffects == DROPEFFECT_SCROLL )
	    {
		*pdwEffects |= DROPEFFECT_MOVE;
	    }
	}
	
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   PrivDragDrop
//
//  Synopsis:   Package up drag enter to be sent to the drop target.
//
//  Arguments:  [hWnd]- handle to the window to get target from
//		[dop] - the drag drop operation to perform
//		[IDOBuffer] - the marshalled buffer for the data object
//              [pIDataObject] - data object from source
//              [grfKeyState] - current key state
//              [ptl] - point where drop would occur
//              [pdwEffect] - proposed valid effects
//		[hwndSource] - the handle to OLE's drag drop source window
//		[phDDInfo]    -- pointer to a DragDropInfo handle, for
//				 caching rpc info about the drop target.
//			         May not be NULL, but on DragEnter,
//				 should be a pointer to NULL.
//
//  Returns:    S_OK - call succeeded
//              Other - call failed
//
//  Algorithm:  First determine if the the window is for the current thread
//              If it is, then immediately interpret the drag op. If not,
//		get the end point from the window and package up
//		the call to be dispatched to RPC.
//
//  History:    30-Sep-94 Ricksa    Created
//		08-Nov-94 alexgo    modified to use DRAGOP's
//		08-Jan-95 alexgo    added caching of RPC binding handles via
//				    DDInfo handles
//
//--------------------------------------------------------------------------
HRESULT PrivDragDrop(
    HWND hWnd,
    DRAGOP dop,
    IFBuffer IDOBuffer,
    IDataObject *pIDataObject,
    DWORD grfKeyState,
    POINTL ptl,
    DWORD *pdwEffect,
    HWND hwndSource,
    DDInfo *phDDInfo)
{
    HRESULT hr = S_FALSE;    // If the endpoint is invalid
    SDDInfo *pddinfo = *(SDDInfo **)phDDInfo;

    InterfaceData *pIFData = (InterfaceData *)IDOBuffer;

#if DBG == 1
    Assert(phDDInfo);
    if( dop == DRAGOP_ENTER )
    {
	Assert(*phDDInfo == NULL);
    }
    // we can't assert the reverse case because phDDInfo will be NULL
    // in DROPOP_OVER, etc if we are drag drop'ing to the same thread...

#endif // DBG == 1


    // If we don't have any cached information (i.e. pddinfo == NULL),
    // then get the endpoint id from the window	and construct a
    // PrivDragDrop data structure.  If the window is on the current
    // thread, the PrivDragDrop structure will end up with a pointer
    // to the CInterfaceFromWindowProp object rather then a proxy.

    if( pddinfo == NULL )
    {
	{
	    pddinfo = new SDDInfo(hWnd, hr);

	    if( pddinfo == NULL )
	    {
   		return E_OUTOFMEMORY;
	    }

	    if( hr != NOERROR )
	    {
		delete pddinfo;
		return E_FAIL;
	    }

	    *phDDInfo = (DDInfo)pddinfo;
	}
    }

    if( pddinfo != NULL )
    {
	hr = pddinfo->pIFWP->PrivDragDrop( hWnd,
			    (pddinfo->fLocal) ? NULL : pIFData,
			    dop,
	                    grfKeyState, ptl,
			    (pdwEffect) ? pdwEffect : DROPEFFECT_NONE,
			    GetCurrentThreadId(),
			    (pddinfo->fLocal) ? pIDataObject : NULL,
			    hwndSource );
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   UnmarshalDragDataObject
//
//  Synopsis:   Unmarshal the drag source's data object
//
//  Arguments:  [pvMarshaledDataObject] - pointer to interface buffer
//
//  Returns:    NULL - unmarshal failed
//              ~NULL - got the real data object on source
//
//  Algorithm:  Unmarshal interface and return whether we got an interface
//              back.
//
//  History:    30-Sep-94 Ricksa    Created
//
//  Note:       This call really exists so that the drag code over in
//              ole232/drag won't have to copy in all the marshaling stuff.
//
//--------------------------------------------------------------------------
IDataObject *UnmarshalDragDataObject(void *pvMarshaledDataObject)
{
    InterfaceData *pIFD = (InterfaceData *) pvMarshaledDataObject;

    // Convert returned interface to  a stream
    CXmitRpcStream xrpc(pIFD);

    IDataObject *pIDataObject;

    HRESULT hr = CoUnmarshalInterface(
        &xrpc,
        IID_IDataObject,
        (void **) &pIDataObject);

    return (SUCCEEDED(hr)) ? pIDataObject : NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:	GetMarshalledInterfaceBuffer
//
//  Synopsis:	marshals the given interface into an allocated buffer.  The
//		buffer is returned
//
//  Effects:
//
//  Arguments:	[refiid]	-- the iid of the interface to marshal
//		[punk]		-- the IUnknown to marshal
//		[pIFBuf]	-- where to return the buffer
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm: 	calls CoMarshalInterface(MSHFLAGS_TABLESTRONG)
//
//  History:    dd-mmm-yy Author    Comment
// 		03-Dec-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT GetMarshalledInterfaceBuffer( REFIID riid, IUnknown *punk, IFBuffer
	    *pIFBuf)
{
    HRESULT hr;

    InterfaceData *pIFD = NULL;

    CXmitRpcStream xrpc;

    hr = CoMarshalInterface(&xrpc, riid, punk, MSHCTX_NOSHAREDMEM, NULL,
	    MSHLFLAGS_TABLESTRONG);

    if( hr == NOERROR )
    {
	xrpc.AssignSerializedInterface(&pIFD);
    }

    *pIFBuf = (IFBuffer)pIFD;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:	ReleaseMarshalledInterfaceBuffer
//
//  Synopsis:	releases the buffer allocated by GetMarshalledInterfaceBuffer
//
//  Effects:
//
//  Arguments: 	[IFBuf]		-- the interface buffer to release
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm: 	calls CoReleaseMarshalData to undo the TABLE_STRONG
//		marshalling
//
//  History:    dd-mmm-yy Author    Comment
//  		03-Dec-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT ReleaseMarshalledInterfaceBuffer( IFBuffer IFBuf )
{
    HRESULT hr = E_INVALIDARG;

    if( IFBuf )
    {
	CXmitRpcStream xrpc( (InterfaceData *)IFBuf );

	hr = CoReleaseMarshalData(&xrpc);

	CoTaskMemFree((void *)IFBuf);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:  	FreeDragDropInfo
//
//  Synopsis:	frees the SPrivDragDrop structure
//
//  Effects:
//
//  Arguments:	[hDDInfo]	-- pointer to free
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		07-Jan-95 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
void FreeDragDropInfo( DDInfo hDDInfo )
{
    SDDInfo *pddinfo = (SDDInfo *)hDDInfo;

    delete pddinfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\cache.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
 Microsoft COM+ (Microsoft Confidential)

 @doc
 @module cache.H : Implements a time-out cache for callframe-related objects
 
-------------------------------------------------------------------------------
Revision History:

 @rev 0     | 09/14/2000 | mfeingol  | Created
---------------------------------------------------------------------------- */

#ifndef _CALLFRAME_CACHE_H_
#define _CALLFRAME_CACHE_H_

// Arbitrary value used as "never" marker.  One object in 2^32-1 will
// not be aged out properly before an extra addref / release cycle
// on systems that stay up longer than 49 days.
// I think we can live with this.
#define TYPEINFO_RELEASE_TIME_NEVER	(0xffffffff)

// How often we try to age out old cache entries
#define TYPEINFO_AGEOUT_FREQUENCY	(60 * 1000)

// How old an unused entry has to be to be considered "old"
#define TYPEINFO_AGEOUT_PERIOD		(60 * 1000)

//
// NOTE: The constructor here can throw an exception because it contains a
//       MAP_SHARED, which contains an XSLOCK, and... well... see concurrent.h
//
template <class T> class CALLFRAME_CACHE : public MAP_SHARED <PagedPool, MAP_KEY_GUID, T*>
{

protected:

    XSLOCK m_xslAgeOutLock;
    DWORD m_dwLastAgeOutTime;
    DWORD m_dwNumPtrsInPage;

public:

    CALLFRAME_CACHE()
	{
		SYSTEM_INFO siInfo;
		GetSystemInfo (&siInfo);

		// Initialize to the number of pointers a page can contain
		m_dwNumPtrsInPage = siInfo.dwPageSize / sizeof (void*);
		m_dwLastAgeOutTime = GetTickCount();
	}

    // you must successfully call FInit to use this class.
    // return TRUE on success, FALSE on failure.
    virtual BOOL FInit()
    {
        if (MAP_SHARED<PagedPool, MAP_KEY_GUID, T*>::FInit() == FALSE)
        {
            return FALSE;
        }
        else
        {
            return m_xslAgeOutLock.FInit();
        }
    }
    	

    void Shutdown()
    {

        iterator iCurrent, iLast;
        T* ptCacheEntry;

        // First, take an exclusive lock.
        // If this function is called, then everyone else should have shut down, but let's be safe
        LockExclusive();

        iCurrent = First();
        iLast = End();

        while (iCurrent != iLast)
        {
            ptCacheEntry = iCurrent.GetValue();

            if (ptCacheEntry->GetReleaseTime() == TYPEINFO_RELEASE_TIME_NEVER)
            {
                // This entry is actually alive. Someone probably leaked a reference on it
                T::NotifyLeaked (ptCacheEntry);
            }
            else
            {
                // Clean up the cached object
                // This removes it from the hash table
                ASSERT (ptCacheEntry->m_refs == 0);
                ptCacheEntry->DeleteSelf();
            }   

            iCurrent ++;
        }
        
        ReleaseLock();
    }

    void AgeOutEntries()
    {
        // Static used to control how many entries we can age out
        static ULONG s_ulEntries = 50;
    	
        T* ptCacheEntry;
        T** pptTimedOut;
    	
        DWORD dwCurrentTime, dwLastAgeOut, dwNextAgeOut;
        ULONG i, ulNumAgedOut, ulNumEntries;
        iterator iCurrent, iLast;

        dwCurrentTime = GetTickCount();
        dwLastAgeOut = m_dwLastAgeOutTime;
        dwNextAgeOut = dwLastAgeOut + TYPEINFO_AGEOUT_FREQUENCY;

        if (dwCurrentTime < dwNextAgeOut ||
            InterlockedCompareExchange (&m_dwLastAgeOutTime, dwCurrentTime, dwLastAgeOut) != dwLastAgeOut)
        {
            // Time isn't up yet, or someone else got here first
            return;
        }

        ulNumAgedOut = 0;

        // Synchronize access to this code- even though we'll get here once a minute at most,
        // you never know what might happen under stress
        m_xslAgeOutLock.LockExclusive();

        // Get the read lock
        LockShared();

        ulNumEntries = Size();

        // Short circuit if no entries
        if (ulNumEntries == 0)
        {
            ReleaseLock();
            m_xslAgeOutLock.ReleaseLock();
            return;
        }		

    	// Don't alloca more than the static number of entries
        if (ulNumEntries > s_ulEntries)
        {
            ulNumEntries = s_ulEntries;
        }

        // Allocate memory on the stack to contain the max number of entries we expect to release
        pptTimedOut = (T**) _alloca (ulNumEntries * sizeof (T*));

        iCurrent = First();
        iLast = End();

        while (iCurrent != iLast && ulNumAgedOut < ulNumEntries)
        {
            ptCacheEntry = iCurrent.GetValue();

            if (ptCacheEntry->CanBeAgedOut (dwCurrentTime))
            {
                pptTimedOut[ulNumAgedOut ++] = ptCacheEntry;
                ptCacheEntry->AddRef();	// Stabilizing addref
            }

            iCurrent ++;
        }

        ReleaseLock();

        // Increase the static limit for next time if we need more space for age-outs,
        // but make sure we never use more than a page of stack
        if (ulNumAgedOut == ulNumEntries && s_ulEntries < m_dwNumPtrsInPage)
        {
            s_ulEntries += 10;
        }

        if (ulNumAgedOut > 0)
        {
            // Get the write lock and age 'em out!
            LockExclusive();

            for (i = 0; i < ulNumAgedOut; i ++)
            {
                if (!pptTimedOut[i]->AttemptAgeOut (dwCurrentTime))
                {
                    // The object wasn't deleted, so decrease its refcount
                    // to balance the stabilizing addref performed above
                    pptTimedOut[i]->Release (FALSE);
                }
            }

            // else the object was destructed and we're done, so no need to balance the addref

            ReleaseLock();
        }

        m_xslAgeOutLock.ReleaseLock();
    }
    
    HRESULT FindExisting(REFIID iid, T** ppT)
    {
        HRESULT hr = S_OK;
        *ppT = NULL;
        
        LockShared();

        if (Lookup(iid, ppT))
        {
            (*ppT)->AddRef(); // give caller his own reference
            (*ppT)->SetCantBeAgedOut();
        }
        else
        {
            hr = E_NOINTERFACE;
        }

        ReleaseLock();

        return hr;
    }
};

template <class T> class CALLFRAME_CACHE_ENTRY
{

protected:

    DWORD m_dwReleaseTime;

    CALLFRAME_CACHE<T>* m_pcache;

public:

    LONG m_refs;
    GUID m_guidkey;

    CALLFRAME_CACHE_ENTRY()
    {
        m_refs = 1; // Refcount starts at 1!
        m_dwReleaseTime = TYPEINFO_RELEASE_TIME_NEVER;
        m_pcache = NULL;

        m_guidkey = GUID_NULL;
    }

    ULONG AddRef()
    {
        InterlockedIncrement(&m_refs); return m_refs;
    }

    ULONG Release (BOOL bAgeOutOldEntries = TRUE)
    {
        // Careful: if we're in the cache then we could be dug out 
        // from the cache to get more references.

        // NOTE:
        //
        // This code is WRONG if m_pcache can change out from underneath us. But it can't
        // in current usage because the cache/no-cache decision is always made as part of
        // the creation logic, which is before another independent thread can get a handle
        // on us.
        //
        // If this ceases to be true, then we can deal with it by stealing a bit from the ref count word 
        // for the 'am in cache' decistion and interlocked operations to update the ref count and this 
        // bit together.
        //

        // Global used to reduce traffic on the age-out code
    	static ULONG s_ulTimes = 0;

        if (m_pcache)
        {
            // We're in a cache. Get us out of there carefully.
            //
            LONG crefs;
            //
            for (;;)
            {
                crefs = m_refs;
                //
                if (crefs > 1)
                {
                    // There is at least one non-cache reference out there. We definitely won't
                    // be poofing if we release with that condition holding
                    //
                    if (crefs == InterlockedCompareExchange(&m_refs, (crefs - 1), crefs))
                    {
    				    return crefs - 1;
                    }
                    else
                    {
                        // Someone diddled with the ref count while we weren't looking. Go around and try again
                    }
                }
                else
                {
                    CALLFRAME_CACHE<T>* pcache = m_pcache;  ASSERT(pcache);

                    // We need the exclusive lock because otherwise we'll race with TYPEINFO_CACHE::FindExisting
                    pcache->LockExclusive();
                    //
                    crefs = InterlockedDecrement(&m_refs);
                    if (0 == crefs)
                    {
                        // The last public reference just went away, and, because the cache is locked, no
                        // more can appear. Make the entry ready to be aged out.
                        //
                        ASSERT(m_guidkey != GUID_NULL);
                        ASSERT(pcache->IncludesKey(m_guidkey));
                        //
                        m_dwReleaseTime = GetTickCount();
                    }
                    //
                    pcache->ReleaseLock();

                    // Every five times we arrive here, see if we can age anything out
                   	if (bAgeOutOldEntries && InterlockedIncrement (&s_ulTimes) % 5 == 0)
                    {
                   		pcache->AgeOutEntries();
                   	}
                    
                    //
                    return crefs;
                }
            }
        }
        else
        {
            // We are getting released, yet we have yet to ever be put into the cache. Just
            // the normal, simple case. 
            //
            long crefs = InterlockedDecrement(&m_refs); 
            if (crefs == 0)
            {
                delete this;
            }
            return crefs;
        }
    }

    void SetCantBeAgedOut()
    {
        m_dwReleaseTime = TYPEINFO_RELEASE_TIME_NEVER;
    }
    
    BOOL CanBeAgedOut (DWORD dwCurrentTime)
 	{
        DWORD dwDiff;

    	// If it's never, just say no
        if (m_dwReleaseTime == TYPEINFO_RELEASE_TIME_NEVER)
        {
    	    return FALSE;
        }

        // Handle overflows to the extent that we're able
        if (m_dwReleaseTime > dwCurrentTime)
        {
            // Tick count overflowed!
        	dwDiff = dwCurrentTime + (0xffffffff - m_dwReleaseTime);
        }
        else
        {
            // Normal difference
         	dwDiff = dwCurrentTime - m_dwReleaseTime;
        }

        // Test against hard-coded age out period
        return dwDiff > TYPEINFO_AGEOUT_PERIOD;
   	}

    BOOL AttemptAgeOut (DWORD dwCurrentTime)
    {
        // Make sure we're still ready to be aged out - should have one ref right now
        if (!CanBeAgedOut (dwCurrentTime))
    	{
    	    return FALSE;
    	}

        ASSERT (m_refs == 1);
        DeleteSelf();

        return TRUE;
    }
    
    void DeleteSelf()
    {       
        ASSERT (m_guidkey != GUID_NULL);
        ASSERT (m_pcache->IncludesKey (m_guidkey));

        m_pcache->RemoveKey (m_guidkey);
        delete this;
    }
    
    DWORD GetReleaseTime()
    {
        return m_dwReleaseTime;
    }

    HRESULT AddToCache (CALLFRAME_CACHE<T>* pcache)
    {
        // Add us into the indicated cache. We'd better not already be in one
        HRESULT hr = S_OK;

        ASSERT (pcache);
        ASSERT (NULL == m_pcache);

        ASSERT (m_guidkey != GUID_NULL);

        pcache->LockExclusive();

        // Make sure nobody beat us first
        if (pcache->IncludesKey (m_guidkey))
        {
            hr = S_FALSE;
        }
        else
        {
            if (pcache->SetAt (m_guidkey, (T*) this))
            {
                m_pcache = pcache;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        
        pcache->ReleaseLock();
        return hr;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\callframe.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// CallFrame.cpp
//
#include "stdpch.h"
#include "common.h"
#include "ndrclassic.h"
#include "invoke.h"

#if _MSC_VER >= 1200
#pragma warning (push)
#pragma warning (disable : 4509)
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Our pool of allocated call frames. We keep dead shells around so that they can quickly
// be allocated w/o taking any locks.

IFastStack<CallFrame>* DedicatedAllocator<CallFrame,PagedPool>::g_pStack;

BOOL InitCallFrame()
{
        if (DedicatedAllocator<CallFrame,PagedPool>::g_pStack = DedicatedAllocator<CallFrame,PagedPool>::CreateStack())
                return TRUE;

        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

inline CallFrame* CallFrame::GetFrame(CallFrame*& pFrame, PVOID pvArgs)
// Helper routine that instantiates a CallFrame if and only if we need it
{
    if (NULL == pFrame)
    {
        pFrame = new CallFrame;
        if (NULL == pFrame)
        {
            Throw(STATUS_NO_MEMORY);
        }
        pFrame->Init(pvArgs, m_pmd, m_pInterceptor);
        pFrame->m_StackTop = (BYTE*)pvArgs;
    }
    return pFrame;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


HRESULT CallFrame::Copy(CALLFRAME_COPY callControl, ICallFrameWalker* pWalker, ICallFrame** ppFrame)
// Create a deep copy of this call frame, either a fleeting or a durable one, as requested by the caller.
//
// Format string for a procedure is
//
//      handle_type <1>      FC_BIND_PRIMITIVE | FC_BIND_GENERIC | FC_AUTO_HANDLE | FC_CALLBACK_HANDLE | 0
//      Oi_flags    <1>         
//      [rpc_flags  <4>]     if Oi_HAS_RPCFLAGS is set
//      proc_num    <2>
//      stack_size  <2>
//      [explicit_handle_description<>] Omitted for implicit handles. Explicit handles indicated by handle_type==0.
//                                      SanityCheck verifies that there is no explicit handle.
//      ...more stuff...
//
{
    HRESULT hr = S_OK;

    //
    // Can the Dst frame share parameters with the parent frame?
    //
    const BOOL fShareMemory = (callControl == CALLFRAME_COPY_NESTED);

#ifdef DBG
    if (m_fAfterCall)
    {
        ASSERT(!m_pmd->m_info.fHasOutValues);
    }
#endif

    CallFrame* pDstFrame = NULL;

    __try
    {
        const ULONG cbStack = m_pmd->m_cbPushedByCaller;
        //
        // Create a new CallFrame to work with. This is the frame that will be the result of our copy
        //
        if (!hr)
        {
            hr = GetFrame(pDstFrame, NULL)->AllocStack(cbStack);
            pDstFrame->m_pvArgsSrc = fShareMemory ? m_pvArgs : NULL;
        }

        //
        // OK! off to the races with actually doing the work!
        //
        if (!hr)
        {
            //
            // Copy each of the in parameters beyond the 'this' pointer. The 'this' pointer isn't in the 
            // list of parameters as emitted by MIDL.
            //
            if (fShareMemory && m_pmd->m_fCanShareAllParameters)
            {
                //
                // Copy the entire stack in one fell swoop
                //
                CopyToDst(pDstFrame->m_pvArgs, m_pvArgs, cbStack);
            }
            else
            { 
                //
                // Set up state so that worker routines can find it
                //
                ASSERT(m_pAllocatorFrame == NULL);
                m_pAllocatorFrame = pDstFrame;

                ASSERT(!AnyWalkers());
                m_StackTop              = (PBYTE)m_pvArgs;
                m_pWalkerCopy           = pWalker;
                m_fPropogatingOutParam  = FALSE;

                //
                // Copy the 'this' pointer. It's what pvArgs is pointing at. The type is our iid.
                // On purpose, we don't call the walker for the receiver.
                //
                CopyToDst(pDstFrame->m_pvArgs, m_pvArgs, sizeof(void*));

                //
                // Copy each of the in parameters beyond the 'this' pointer. The 'this'
                // pointer isn't in the list of parameters as emitted by MIDL.
                //
                for (ULONG iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
                {
                    const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                    const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                    
                    PBYTE pArgFrom = (PBYTE)m_pvArgs  + param.StackOffset;
                    PBYTE pArgTo   = (PBYTE)pDstFrame->m_pvArgs  + param.StackOffset;
                    
                    if (fShareMemory && CanShareParameter(iparam))
                    {
                        //
                        // We just snarf the actual stack contents, whatever type that happens to be
                        //
                        ULONG cbParam = CbParam(iparam, param);
                        CopyToDst(pArgTo, pArgFrom, cbParam);
                        continue;
                    }
                    
                    m_fWorkingOnInParam  = paramAttr.IsIn;
                    m_fWorkingOnOutParam = paramAttr.IsOut;

                    if (!!paramAttr.IsIn)
                    {
                        //
                        // We are an [in] or an [in,out] parameter 
                        //
                        if (paramAttr.IsBasetype)
                        {
                            if (paramAttr.IsSimpleRef)
                            {
                                // The IsSimpleRef bit is set for a parameter which is a ref pointer to anything
                                // other than another pointer, and which has no allocate attributes. For such a type
                                // the parameter description's offset_to_type_description field (except for a ref 
                                // pointer to a basetype) gives the offset to the referent's type - the ref pointer is
                                // simply skipped.
                                //
                                // In the unmarshal case, what NDR does is simply refer into the incoming RPC
                                // buffer. We, here copying instead of unmarshalling, sort-of do that, but we 
                                // have to create a buffer on the fly.
                                //
                                if (fShareMemory)
                                {
                                    ASSERT(!!paramAttr.IsOut);                    // otherwise we'd catch it above
                                    //
                                    // In the sharing case, we can actually share pointers to simple out-data types. We
                                    // have to get the freeing and the NULLing logic to correspond, though.
                                    //
                                    CopyToDst(pArgTo, pArgFrom, sizeof(PVOID));
                                }
                                else
                                {
                                    ULONG cbParam = SIMPLE_TYPE_MEMSIZE(param.SimpleType.Type);
                                    void* pvParam = pDstFrame->AllocBuffer(cbParam);
                                    CopyToDst(pvParam, DerefSrc((PVOID*)pArgFrom), cbParam);
                                    DerefStoreDst((PVOID*)pArgTo, pvParam);
                                }
                            }
                            else
                            {
                                //
                                // It's just a normal, non pointer base type. Copy it over.
                                //
                                CopyBaseTypeOnStack(pArgTo, pArgFrom, param.SimpleType.Type);
                            }
                        }
                        else
                        {
                            //
                            // Else [in] or [in,out] parameter which is not a base type
                            //
                            // From NDR: "This is an initialization of [in] and [in,out] ref pointers to pointers.  
                            //            These can not be initialized to point into the rpc buffer and we want to 
                            //            avoid doing a malloc of 4 bytes!"
                            //
                            if (paramAttr.ServerAllocSize != 0 )
                            {
                                PVOID pv = pDstFrame->AllocBuffer(paramAttr.ServerAllocSize * 8); // will throw on oom
                                DerefStoreDst((PVOID*)pArgTo, pv);
                                ZeroDst(pv, paramAttr.ServerAllocSize * 8);
                            }
                            //
                            // Actually carry out the copying
                            //
                            PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                            //
                            // We don't indirect on interface pointers, even though they are listed as not by value.
                            // In the copy routine, therefore, pMemoryFrom for interface pointers points to the location
                            // at which they reside instead of being the actual value.
                            //
                            BOOL  fByValue = ByValue(paramAttr, pFormatParam, TRUE);
                            pArgFrom = fByValue ? pArgFrom : DerefSrc((PBYTE*)pArgFrom);
                            PBYTE* ppArgTo = fByValue ? &pArgTo  : (PBYTE*)pArgTo;

                            CopyWorker(pArgFrom, ppArgTo, pFormatParam, FALSE);
                        }
                    }

                    else if (!!paramAttr.IsOut)
                    {
                        //
                        // An out-only parameter. We really have to allocate
                        // space in which callee can place his result.
                        //
                        ASSERT(!paramAttr.IsReturn);
                        ULONG cbParam = 0;
                        if (paramAttr.ServerAllocSize != 0)
                        {
                            cbParam = paramAttr.ServerAllocSize * 8;
                        }
                        else if (paramAttr.IsBasetype)
                        {
                            // cbParam = SIMPLE_TYPE_MEMSIZE(param.SimpleType.Type);
                            cbParam = 8;
                        }

                        if (cbParam > 0)
                        {
                            void* pvParam = pDstFrame->AllocBuffer(cbParam);
                            ZeroDst(pvParam, cbParam);
                            DerefStoreDst((PVOID*)pArgTo, pvParam);
                        }
                        else
                        {
                            PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                            OutInit(pDstFrame, (PBYTE*)pArgFrom, (PBYTE*)pArgTo, pFormatParam);
                        }
                    }
                }
            }
        }
    }
    __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
    {
        hr = GetExceptionCode();
        if(SUCCEEDED(hr))
        {
            hr = HrNt(hr);
            if (SUCCEEDED(hr))
            {
                // Hah.  Succeeded my foot.
                // I'm not changing the HrNt function because it gets
                // used indescriminantly sometimes, so I don't want to
                // turn every success code to a failure.  But you don't
                // throw successes.
                //
                // HRESULT_FROM_WIN32.  Makes an error.
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
            }
        }
    }

    //
    // Return allocated frame to caller and / or cleanup the new frame as needed
    //
    if (!hr)
    {
        ASSERT(pDstFrame->m_refs == 1);
        *ppFrame = static_cast<ICallFrame*>(pDstFrame);
    }
    else
    {
        *ppFrame = NULL;
        delete pDstFrame;
    }

    m_pAllocatorFrame = NULL;
    m_pWalkerCopy = NULL;
    ASSERT(!AnyWalkers());        

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CallFrame::Free(ICallFrame* pframeArgsTo, ICallFrameWalker* pWalkerFreeDest, ICallFrameWalker* pWalkerCopy, 
                        DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags)
// Copy out parameters and / or free data and / or null out parameters.
//
{
    HRESULT hr = S_OK;

    __try
    {
        // Set up state so that worker routines can find it
        //
        m_StackTop = (PBYTE)m_pvArgs;
        ASSERT(!AnyWalkers());

        ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////
        //
        // Copy the out values to parent frame if requested.
        //
        if (pframeArgsTo)
        {
            pframeArgsTo->SetReturnValue((HRESULT)m_hrReturnValue);
            //
            // Find out the location of the destination stack
            //
            PVOID pvArgsTo = pframeArgsTo->GetStackLocation();
            //
            SetToUser(pvArgsTo);
            //
            // Are the Dst and parent frames in the same memory space?
            //
            const BOOL fInSameSpace = InSameSpace(freeFlags);
            //
            // Are we copying back to the guy with which we share things?
            //
            const BOOL fShareMemory = DoWeShareMemory() && m_pvArgsSrc == pvArgsTo;
            //
            // Loop through all of the parameters, looking for [in,out] or [out] parameters
            // that need to be propogated.
            //
            if (m_pmd->m_fCanShareAllParameters && fInSameSpace && fShareMemory)
            {
                // Nothing to copy up since we shared all the parameters in the first place
            }
            else 
            {
                ASSERT(m_pAllocatorFrame == NULL);
                CallFrame* pFrameTo = NULL;
                //
                //
                // Propogate parameter by parameter
                //
                for (ULONG iparam = 0; !hr && iparam < m_pmd->m_numberOfParams; iparam++)
                {
                    const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                    const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;

                    if (!paramAttr.IsOut) continue;
                    ASSERT(!paramAttr.IsReturn);

                    PBYTE pArgFrom = (PBYTE)m_pvArgs  + param.StackOffset;
                    PBYTE pArgTo   = (PBYTE)pvArgsTo  + param.StackOffset;

                    if (fInSameSpace && fShareMemory && CanShareParameter(iparam))
                    {
                        // Nothing to copy up since we shared the parameter in the first place
                    }
                    else if (paramAttr.IsBasetype)
                    {
                        if (paramAttr.IsSimpleRef)
                        {
                            // We can simply blt the parameter back on over
                            //
                            ULONG cb = SIMPLE_TYPE_MEMSIZE(param.SimpleType.Type);
                            PVOID pvFrom = DerefSrc((PVOID*)pArgFrom);
                            PVOID pvTo   = DerefDst((PVOID*)pArgTo);
                            CopyToDst(pvTo, pvFrom, cb);
                            ZeroSrc(pvFrom, cb);
                        }
                        else
                        {
                            NOTREACHED();
                        }
                    }
                    else
                    {
                        // Else is [in,out] or [out] parameter which is not a base type.
                        //
                        PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                        //
                        hr = pframeArgsTo->FreeParam(iparam, CALLFRAME_FREE_INOUT, pWalkerFreeDest, CALLFRAME_NULL_OUT | CALLFRAME_NULL_INOUT);
                        if (!!hr) 
                        {
                            break;
                        }
                        //
                        if (fInSameSpace)
                        {
                                // Create a simple walker object on the stack.
                            //
                            SSimpleWalker SimpleWalker;                        
                                // Save the current walker.
                            //
                                ICallFrameWalker* pWalkerSave = m_pWalkerWalk;                        
                                // Set the walker so our simple walker gets called.
                            //
                                m_pWalkerWalk = &SimpleWalker;                        
                            // Transfer ownership of the out parameter, zero out our source copy
                            //
                            OutCopy( DerefSrc((PBYTE*)pArgFrom), DerefDst((PBYTE*)pArgTo), pFormatParam );
                                // Replace the original walker.
                            //
                            m_pWalkerWalk = pWalkerSave;                                                        
                            //
                            // Walk any contained interface pointers, doing the copy call back on each of them
                            //
                            if (m_pmd->m_rgParams[iparam].m_fMayHaveInterfacePointers && pWalkerCopy)
                            {
                                // We don't indirect on interface pointers, even though they are listed as not by value.
                                // In the walk routine, therefore, pMemory for interface pointers points to the location
                                // at which they reside instead of being the actual value.
                                //
                                BYTE* pArg = ByValue(paramAttr, pFormatParam, FALSE) ? pArgTo : DerefDst((PBYTE*)pArgTo);
                                //
                                // Use internal methods on our helper frame to carry this out
                                //                    
                                GetFrame(pFrameTo, pvArgsTo)->m_pWalkerWalk = pWalkerCopy;
                                //
                                pFrameTo->m_fWorkingOnInParam    = paramAttr.IsIn;
                                pFrameTo->m_fWorkingOnOutParam   = paramAttr.IsOut;
                                pFrameTo->m_fPropogatingOutParam = TRUE;
                                //
                                pFrameTo->WalkWorker(pArg, pFormatParam);
                                pFrameTo->m_pWalkerWalk = NULL;
                                
                                SimpleWalker.ReleaseInterfaces();
                            }
                        }
                        else
                        {
                            // Make a deep copy of the out parameter
                            //
                            m_fWorkingOnInParam    = paramAttr.IsIn;
                            m_fWorkingOnOutParam   = paramAttr.IsOut;
                            m_fPropogatingOutParam = TRUE;
                            m_pWalkerCopy          = pWalkerCopy;
                            //
                            // We need a frame to help us out.
                            //
                            m_pAllocatorFrame = GetFrame(pFrameTo, pvArgsTo);
                            // 
                            // This guy isn't allowed to use his internal buffer; all memory he allocates must
                            // be genuinely allocated. This is because he's allocating memory that'll be eventually
                            // owned by the actual destination frame, and so can't refer to his locals.
                            //
                            m_pAllocatorFrame->m_fCanUseBuffer = FALSE;
                            //
                            // We don't copy the top level pointer; rather, we copy that at which the top level
                            // pointer points at. Cf CopyWorker, pointer cases for comparision.
                            //
                            BYTE* pMemoryFrom = DerefSrc((PBYTE*)pArgFrom);
                            PBYTE* ppMemoryTo  = (PBYTE*)pArgTo;
                            if (IsPointer(pFormatParam))
                            {
                                BYTE bPointerAttributes = pFormatParam[1];
                                if (SIMPLE_POINTER(bPointerAttributes))
                                {
                                    CopyWorker(pMemoryFrom, ppMemoryTo, pFormatParam, FALSE);     // REVIEW: Correct?
                                }
                                else
                                {
                                    PFORMAT_STRING pFormatPointee = pFormatParam + 2;
                                    pFormatPointee += *((signed short *)pFormatPointee);

                                    BOOL fMustAlloc = FIndirect(bPointerAttributes, pFormatPointee, TRUE);
                                    if (fMustAlloc)
                                    {
                                        ppMemoryTo  = DerefDst((PBYTE**)ppMemoryTo);
                                        pMemoryFrom = DerefSrc((PBYTE*)pMemoryFrom);
                                    }

                                    CopyWorker(pMemoryFrom, ppMemoryTo, (fMustAlloc ? pFormatPointee : pFormatParam), fMustAlloc);
                                }
                            }
                            else
                            {
                                CopyWorker(pMemoryFrom, ppMemoryTo, pFormatParam, FALSE);
                            }

                            //
                            // We'll free the source pointer later in the freeing phase
                            //
                            ASSERT(paramAttr.IsIn ? (freeFlags & CALLFRAME_FREE_INOUT) : (freeFlags & CALLFRAME_FREE_OUT));
                            m_pWalkerCopy = NULL;
                        }
                    }
                }

                delete pFrameTo;
            
                m_pAllocatorFrame = NULL;
            }
        }

        ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////
        //
        // Free the parameters (other than the this pointer) if we're asked to
        //
        if (freeFlags && !hr)
        {
            SetToUser(m_pvArgs); // free routines check against destination
                        
            if (DoWeShareMemory() && m_pmd->m_fCanShareAllParameters)
            {
                // All parameters are shared with someone else. So we never free them, since
                // that someone else has the responsibility of doing so, not us.
            }
            else for (ULONG iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
            {
                const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                ASSERT(!paramAttr.IsDontCallFreeInst);
                //
                if (DoWeShareMemory() && CanShareParameter(iparam))
                {
                    // This parameter is shared with someone else. So we never free it, since
                    // that someone else has the responsibility of doing so, not us.
                    continue;
                }

                // Are we in fact supposed to free this parameter?
                //
                BOOL fFreeData = 0;
                BOOL fFreeTop  = 0;

                if (!!paramAttr.IsIn)
                {
                    if (!!paramAttr.IsOut)                       
                    {
                        fFreeData   = (freeFlags & CALLFRAME_FREE_INOUT);
                        fFreeTop    = (freeFlags & CALLFRAME_FREE_TOP_INOUT);
                    }
                    else
                    {
                        fFreeData   = (freeFlags & CALLFRAME_FREE_IN);
                        fFreeTop    = fFreeData;
                    }
                }
                else if (!!paramAttr.IsOut)
                {
                    fFreeData   = (freeFlags & CALLFRAME_FREE_OUT);
                    fFreeTop    = (freeFlags & CALLFRAME_FREE_TOP_OUT);
                }
                else
                    NOTREACHED();

                if ( !(fFreeData || fFreeTop) ) continue;
                //
                // Yes we are supposed to free it. Find out where it is.
                //
                PBYTE pArg = (PBYTE)m_pvArgs + param.StackOffset;
                //
                // Remember this?
                //
                // "The IsSimpleRef bit is set for a parameter which is a ref pointer to anything
                // other than another pointer, and which has no allocate attributes. For such a type
                // the parameter description's offset_to_type_description field (except for a ref 
                // pointer to a basetype) gives the offset to the referent's type - the ref pointer is
                // simply skipped."
                //
                // This means we have to handle the freeing of the top level pointer as a special case.
                // We also have to explicitly free arrays and strings, or so NDR says (why?).
                //
                if (paramAttr.IsBasetype)
                {
                    if (paramAttr.IsSimpleRef && fFreeTop)
                    {
                        Free( *(PVOID*)pArg );
                    }
                    else
                    {
                        // Nothing to do. Just a simple parameter on the stack
                    }
                }
                else
                {
                    PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                    BOOL fByValue = ByValue(paramAttr, pFormatParam, FALSE);
                    PBYTE pMemory = fByValue ? pArg : *((PBYTE*)pArg);
                    if (pMemory) 
                    {
                        m_fWorkingOnInParam  = paramAttr.IsIn;
                        m_fWorkingOnOutParam = paramAttr.IsOut;
                        m_pWalkerFree = pWalkerFree;
                        //
                        // Carry out the freeing of the pointed to data
                        //
                        __try
                        {
                            FreeWorker(pMemory, pFormatParam, !fByValue && fFreeTop);
                            //
                            // Free the top level pointer
                            //
                            if (!fByValue && fFreeTop && (paramAttr.IsSimpleRef || IS_ARRAY_OR_STRING(*pFormatParam)))
                            {
                                // REVIEW: Why exactly do we need to do this for arrays and strings? For now we
                                //         do it just because NDR does. We DO believe it's necessary, but we just
                                //         don't exactly understand in which particular situations.
                                //
                                Free(pMemory);
                            }
                        }
                        __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
                        {
                            // Remember the bad HR, but don't do anything about it yet.
                            //
                            // It will just fall out of this loop.
                            hr = HrNt(GetExceptionCode());
                            if (SUCCEEDED(hr))
                                hr = HRESULT_FROM_WIN32(GetLastError());
                        }

                        //
                        m_pWalkerFree = NULL;
                    }
                }
            }
        }

        ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////
        //
        // NULL out parameters if requested
        //
        if (nullFlags && !hr)
        {
            SetToUser(m_pvArgs);

            for (ULONG iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
            {
                const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;

                if (!!paramAttr.IsIn)
                {
                    if (!!paramAttr.IsOut)                       
                    {
                        if (!(nullFlags & CALLFRAME_NULL_INOUT)) continue;
                    }
                    else
                        continue;
                }
                else if (!!paramAttr.IsOut)
                {
                    if (!(nullFlags & CALLFRAME_NULL_OUT)) continue;
                }

                ASSERT(!paramAttr.IsReturn);

                if (paramAttr.IsBasetype)
                {
                    if (paramAttr.IsSimpleRef)
                    {
                        // Out pointer to base type. Don't have to zero these; indeed, musn't.
                    }
                    else
                    {
                        // It's just a base type on the stack, which is never an out parameter
                    }
                }
                else
                {
                    // Else [in,out] or [out] parameter which is not a base type
                    //
                    PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                    PBYTE pArg = (PBYTE)m_pvArgs + param.StackOffset;
                    OutZero( DerefDst((PBYTE*)pArg), pFormatParam );
                }
            }
        }
    }
    __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
    {
        hr = GetExceptionCode();
        if(SUCCEEDED(hr))
        {
            hr = HrNt(hr);
            if (SUCCEEDED(hr))
            {
                // Hah.  Succeeded my foot.
                // I'm not changing the HrNt function because it gets
                // used indescriminantly sometimes, so I don't want to
                // turn every success code to a failure.  But you don't
                // throw successes.
                //
                // HRESULT_FROM_WIN32.  Makes an error.
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
            }
        }
    }

    ASSERT(!AnyWalkers());
    return hr;
}


HRESULT CallFrame::FreeParam(ULONG iparam, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags)
// Free a particular parameter to this invocation
{
    HRESULT hr = S_OK;
    
    const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
    const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
    
    if (freeFlags)
    {
        //
        // Are we in fact supposed to free this parameter?
        //
        BOOL fFreeData = 0;
        BOOL fFreeTop  = 0;
        
        if (!!paramAttr.IsIn)
        {
            if (!!paramAttr.IsOut)                       
            {
                fFreeData   = (freeFlags & CALLFRAME_FREE_INOUT);
                fFreeTop    = (freeFlags & CALLFRAME_FREE_TOP_INOUT);
            }
            else
            {
                fFreeData   = (freeFlags & CALLFRAME_FREE_IN);
                fFreeTop    = fFreeData;
            }
        }
        else if (!!paramAttr.IsOut)
        {
            fFreeData   = (freeFlags & CALLFRAME_FREE_OUT);
            fFreeTop    = (freeFlags & CALLFRAME_FREE_TOP_OUT);
        }
        else
            NOTREACHED();
        
        if (fFreeData || fFreeTop)
        {
            // Yep, we're to free it all right
            //
            PBYTE pArg = (PBYTE)m_pvArgs + param.StackOffset;
            //
            if (paramAttr.IsBasetype)
            {
                if (paramAttr.IsSimpleRef && fFreeTop)
                {
                    Free( *(PVOID*)pArg );
                }
                else
                {
                    // Nothing to do. Just a simple parameter on the stack
                }
            }
            else
            {
                PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                BOOL fByValue = ByValue(paramAttr, pFormatParam, FALSE);
                PBYTE pMemory = fByValue ? pArg : *((PBYTE*)pArg);
                if (pMemory) 
                {
                    ICallFrameWalker* pWalkerFreePrev = m_pWalkerFree;
                    m_pWalkerFree = pWalkerFree;
                    //
                    m_fWorkingOnInParam  = paramAttr.IsIn;
                    m_fWorkingOnOutParam = paramAttr.IsOut;
                    //
                    // Carry out the freeing of the pointed to data
                    //
                    __try
                    {
                        FreeWorker(pMemory, pFormatParam, !fByValue && fFreeTop);
                        //
                        // Free the top level pointer
                        //
                        if (!fByValue && fFreeTop && (paramAttr.IsSimpleRef || IS_ARRAY_OR_STRING(*pFormatParam)))
                        {
                            // REVIEW: Why exactly do we need to do this for arrays and strings? For now we
                            //         do it just because NDR does. We DO believe it's necessary, but we just
                            //         don't exactly understand in which particular situations.
                            //
                            Free(pMemory);
                        }
                        //
                        m_pWalkerFree = pWalkerFreePrev;
                    }
                    __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
                    {
                        hr = HrNt(GetExceptionCode());
                        if (SUCCEEDED(hr))
                            hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
            }
        }
    }

    if (nullFlags)
    {
        SetToUser(m_pvArgs);
        //
        do  
        {
            if (!!paramAttr.IsIn)
            {
                if (!!paramAttr.IsOut)                       
                {
                    if (!(nullFlags & CALLFRAME_NULL_INOUT)) break;
                }
                else
                    break;
            }
            else if (!!paramAttr.IsOut)
            {
                if (!(nullFlags & CALLFRAME_NULL_OUT)) break;
            }
            
            ASSERT(!paramAttr.IsReturn);
            
            if (paramAttr.IsBasetype)
            {
                if (paramAttr.IsSimpleRef)
                {
                    // Out pointer to base type. Don't have to zero these; indeed, musn't.
                }
                else
                {
                    // It's just a base type on the stack, which is never an out parameter
                }
            }
            else
            {
                // Else [in,out] or [out] parameter which is not a base type
                //
                PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                PBYTE pArg = (PBYTE)m_pvArgs + param.StackOffset;
                OutZero( DerefDst((PBYTE*)pArg), pFormatParam );
            }
        }
        while (FALSE);
    }
    
    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#if defined(_X86_)

HRESULT CallFrame::Invoke(PVOID pvReceiver, ...)
// Invoke ourselves on the given frame
{
#ifdef DBG
    if (m_fAfterCall)
    {
        ASSERT(!m_pmd->m_info.fHasOutValues);
    }
#endif

    //
    // Figure out the function which is to be invoked
    //
    typedef HRESULT (__stdcall* PFN)(void);
    PFN pfnToCall = ((HRESULT (__stdcall***)(void))pvReceiver)[0][m_pmd->m_iMethod];
    //
    // Allocate space for the callee's stack frame. We ignore stack overflow
    // exceptions that may come here, for if we're that close to the stack 
    // limit, then we'll be hitting it anyway really soon now just in the normal
    // course of calling things.
    //
    PVOID pvArgsCopy = _alloca(m_pmd->m_cbPushedByCaller);
    //
    // Copy the caller stack frame to the top of the current stack.
    // This code assumes (dangerously) that the alloca'd copy of the
    // actual arguments is at [esp].
    //
    memcpy(pvArgsCopy, m_pvArgs, m_pmd->m_cbPushedByCaller);
    //
    // Push the receiver
    //
    *((PVOID*)pvArgsCopy) = pvReceiver;
    //
    // Carry out the call!
    //
    if (m_pmd->m_optFlags.HasReturn)
        m_hrReturnValue = (*pfnToCall)();
    else
    {
        (*pfnToCall)();
        m_hrReturnValue = S_OK;
    }
#ifdef DBG
    m_fAfterCall = TRUE;
#endif
    return S_OK;
}

#endif

#if defined(_AMD64_)

HRESULT CallFrame::Invoke(PVOID pvReceiver, ...)
// Invoke ourselves on the given frame
{
#ifdef DBG
    if (m_fAfterCall)
    {
        ASSERT(!m_pmd->m_info.fHasOutValues);
    }
#endif
    //
    // Figure out the function which is to be invoked
    //
    typedef HRESULT (*const PFN)(void);
    typedef HRESULT (***INTERFACE_PFN)(void);
    PFN pfnToCall = ((INTERFACE_PFN)pvReceiver)[0][m_pmd->m_iMethod];
    //
    // Allocate space for the caller argument list. We ignore stack overflow
    // exceptions that may come here, for if we're that close to the stack 
    // limit, then we'll be hitting it anyway really soon now just in the
    // normal course of calling things.
    //
    REGISTER_TYPE *pArgumentList = (REGISTER_TYPE *)_alloca(m_pmd->m_cbPushedByCaller);
    //
    // Copy the caller argument list to the allocated area.
    //
    memcpy(pArgumentList, m_pvArgs, m_pmd->m_cbPushedByCaller);
    //
    // Insert the receiver as the first argument in the argument list.
    //
    *pArgumentList = (REGISTER_TYPE)pvReceiver;
    //
    // Carry out the call!
    //
    m_hrReturnValue = (HRESULT)::Invoke((MANAGER_FUNCTION)pfnToCall,
                                        pArgumentList,
                                        m_pmd->m_cbPushedByCaller / sizeof(REGISTER_TYPE));
    if (!m_pmd->m_optFlags.HasReturn)
    {
        m_hrReturnValue = S_OK;
    }
#ifdef DBG
    m_fAfterCall = TRUE;
#endif
    return S_OK;
}

#endif

#ifdef IA64

extern "C"
void __stdcall FillFPRegsForIA64( REGISTER_TYPE* pStack, ULONG FloatMask);

HRESULT CallFrame::Invoke(PVOID pvReceiver, ...)
// Invoke ourselves on the given frame. Invoking on the IA64 is
// a bit tricky, since we have to treat the first set of arguments
// specially.
//
// This code was taken from the MTS 1.0 context wrapper code, originally
// written by Jan Gray.
//
{
#ifdef DBG
    if (m_fAfterCall)
    {
        ASSERT(!m_pmd->m_info.fHasOutValues);
    }
#endif

    // Figure out the function which is to be invoked
    //
    typedef HRESULT (*const PFN)      (__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64);
    typedef HRESULT (***INTERFACE_PFN)(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64);
    PFN pfnToCall = ((INTERFACE_PFN)pvReceiver)[0][m_pmd->m_iMethod];

    const DWORD cqArgs = m_pmd->m_cbPushedByCaller / 8; // no. of arguments (each a quadword)

    // Initialize a[] to address the eight integer argument registers passed
    //
    __int64 *const a = (__int64*)m_pvArgs;

    // Ensure there is space for any args past the 8th arg.
    //
    DWORD cbExtra = m_pmd->m_cbPushedByCaller > 64 ? m_pmd->m_cbPushedByCaller - 64 : 0;
    pvGlobalSideEffect = alloca(cbExtra);

    // Copy args [8..] to the stack, at 0(sp), 8(sp), ... . Note we copy them in first 
    // to last order so that stack faults (if any) occur in the right order.
    //
    __int64 *const sp = (__int64*)getSP (0, 0, 0, 0, 0, 0, 0, 0);
    for (DWORD iarg = cqArgs - 1; iarg >= 8; --iarg)
        {
        sp[iarg-8] = a[iarg];
        }

        //
    // Establish F8-F15 with the original caller's fp arguments.
    //
        if (m_pmd->m_pHeaderExts)
        {
                // ASSUMPTION: If we're on Win64, this is going to be NDR_PROC_HEADER_EXTS64.
                // That seems to be what the NDR code assumes.
                PNDR_PROC_HEADER_EXTS64 exts = (PNDR_PROC_HEADER_EXTS64)m_pmd->m_pHeaderExts;
                FillFPRegsForIA64((REGISTER_TYPE *)m_pvArgs, exts->FloatArgMask);
        }

    // Call method, establishing A0-A7 with the original caller's integer arguments.
    //
    if (m_pmd->m_optFlags.HasReturn)
        m_hrReturnValue = (*pfnToCall)((__int64)pvReceiver, a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    else
        {
        (*pfnToCall)((__int64)pvReceiver, a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
        m_hrReturnValue = S_OK;
        }

#ifdef DBG
    m_fAfterCall = TRUE;
#endif
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////
//
// Invocation utilities
//

void* pvGlobalSideEffect;

void establishF8_15(double f8, double f9, double f10, double f11, 
                    double f12, double f13, double f14, double f15)
{ /* nothing to actually do */ }

#endif

///////////////////////////////////////////////////////////////////////////////////////
//
// Miscellaneous
//
///////////////////////////////////////////////////////////////////////////////////////

HRESULT CallFrame::QueryInterface(REFIID iid, void** ppv)
{
    if (iid == __uuidof(ICallFrame) || iid == __uuidof(IUnknown))
    {
        *ppv = (ICallFrame*) this;
    }
    else if (iid == __uuidof(ICallFrameInit))
    {
        *ppv = (ICallFrameInit*) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*) *ppv)->AddRef();
    return S_OK;
}


HRESULT CallFrame::GetInfo(CALLFRAMEINFO *pInfo)
{
    *pInfo = m_pmd->m_info;
    if (m_pInterceptor->m_pmdMostDerived)
    {
        pInfo->iid     = *m_pInterceptor->m_pmdMostDerived->m_pHeader->piid;
        pInfo->cMethod =  m_pInterceptor->m_pmdMostDerived->m_pHeader->DispatchTableCount;

#ifdef DBG
        //
        // Since neither of us is the actual IDispatch interceptor, we should agree
        // in our readings of derivability
        //
        ASSERT(!!pInfo->fDerivesFromIDispatch == !!m_pInterceptor->m_pmdMostDerived->m_fDerivesFromIDispatch);
#endif
    }
    return S_OK;
}

HRESULT CallFrame::GetParamInfo(ULONG iparam, CALLFRAMEPARAMINFO* pInfo)
{
    HRESULT hr = S_OK;

    if (iparam < m_pmd->m_numberOfParams)
    {
        const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
        const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;

        pInfo->fIn         = !!paramAttr.IsIn;
        pInfo->fOut        = !!paramAttr.IsOut;
        pInfo->stackOffset = param.StackOffset;
        pInfo->cbParam     = CbParam(iparam, param);
    }
    else
    {
        Zero(pInfo);
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CallFrame::GetParam(ULONG iParam, VARIANT* pvar)    
{
        HRESULT hr = S_OK;
        unsigned short vt;

        if (pvar == NULL)
                return E_POINTER;


    VariantInit(pvar);

        const PARAM_DESCRIPTION& param = m_pmd->m_params[iParam];

        BYTE* stackLocation = (BYTE*)GetStackLocation();
        stackLocation += param.StackOffset;

        // A temporary VARIANT that points into our stack.  Must be VariantCopy'd before
        // being sent back.
        VARIANT varTemp;
        VariantInit(&varTemp);

        int iMethod = m_pmd->m_info.iMethod;

        METHOD_DESCRIPTOR& descriptor = m_pInterceptor->m_ptypeinfovtbl->m_rgMethodDescs[iMethod];
        if (iParam >= (ULONG)descriptor.m_cParams)
                return DISP_E_BADPARAMCOUNT;
        vt = varTemp.vt = descriptor.m_paramVTs[iParam];

        // VT_ARRAY is not a specific type, however, everything marked with VT_ARRAY
        // needs to be handled the same way.  What it's an array *of* is not 
        // important.
        if (vt & VT_ARRAY)
        {
                // Remove the type bits.  (This leaves VT_BYREF, etc.)
                vt = (vt & ~VT_TYPEMASK);
        }

        switch (vt)
        {
        case VT_DECIMAL:
                memcpy(&varTemp.decVal, stackLocation, sizeof varTemp.decVal);
                break;
                
    case VT_VARIANT:
    {
        // The parameter at the specified stack location is a VARIANT.  We
        // allocate a VARIANT, copy the VARIANT from the stack location
        // into it, and make the VARIANT supplied by the caller a BYREF
        // that points to the one we allocate.
            
        VARIANT* pvarNew = (VARIANT*)CoTaskMemAlloc(sizeof(VARIANT));
        if (!pvarNew)
            return E_OUTOFMEMORY;
        
        VariantInit(pvarNew);
            
        VARIANT* pvarStack = (VARIANT*)stackLocation;
            
        pvarNew->vt = pvarStack->vt;
            
        memcpy(&pvarNew->lVal, &pvarStack->lVal, sizeof(VARIANT) - (sizeof(WORD) * 4));
            
        varTemp.vt |= VT_BYREF;
        varTemp.pvarVal = pvarNew;
           
        break;
    }

        case VT_I4:
        case VT_UI1:
        case VT_I2:
        case VT_R4:
        case VT_R8:
        case VT_BOOL:
        case VT_ERROR:
        case VT_CY:
        case VT_DATE:
        case VT_BSTR:
        case VT_UNKNOWN:
        case VT_DISPATCH:
        case VT_ARRAY:
        case VT_BYREF|VT_UI1:
        case VT_BYREF|VT_I2:
        case VT_BYREF|VT_I4:
        case VT_BYREF|VT_R4:
        case VT_BYREF|VT_R8:
        case VT_BYREF|VT_BOOL:
        case VT_BYREF|VT_ERROR:
        case VT_BYREF|VT_CY:
        case VT_BYREF|VT_DATE:
        case VT_BYREF|VT_BSTR:
        case VT_BYREF|VT_UNKNOWN:
        case VT_BYREF|VT_DISPATCH:
        case VT_BYREF|VT_ARRAY:
        case VT_BYREF|VT_VARIANT:
        case VT_BYREF:
        case VT_I1:
        case VT_UI2:
        case VT_UI4:
        case VT_INT:
        case VT_UINT:
        case VT_BYREF|VT_DECIMAL:
        case VT_BYREF|VT_I1:
        case VT_BYREF|VT_UI2:
        case VT_BYREF|VT_UI4:
        case VT_BYREF|VT_INT:
        case VT_BYREF|VT_UINT:
        case VT_BYREF|VT_RECORD:
        case VT_RECORD:
                // All these start at the same place within the VARIANT, I arbitrarily chose .lVal.
                memcpy(&varTemp.lVal, stackLocation, CbParam(iParam, param));
                break;
                
        default:
                return DISP_E_BADVARTYPE;
        }
        
        hr = (g_oa.get_VariantCopy())(pvar, &varTemp);
        // Don't clear varTemp... it doesn't own any of its data.
        
    return hr;
}

HRESULT CallFrame::SetParam(ULONG iParam, VARIANT* pvar)
{
    return E_NOTIMPL;
}

HRESULT CallFrame::GetIIDAndMethod(IID* piid, ULONG* piMethod)
{
    if (piid)
    {
        if (m_pInterceptor->m_pmdMostDerived)
        {
            *piid = *m_pInterceptor->m_pmdMostDerived->m_pHeader->piid;
        }
        else
        {
            *piid = *m_pmd->m_pHeader->piid;
        }
    }
    if (piMethod)   *piMethod = m_pmd->m_iMethod;
    return S_OK;
}

HRESULT CallFrame::GetNames(LPWSTR* pwszInterface, LPWSTR* pwszMethod)
{
    HRESULT hr = S_OK;

    if (pwszInterface)
    {
        hr = m_pInterceptor->GetIID((IID*)NULL, (BOOL*)NULL, (ULONG*)NULL, pwszInterface);
    }

    if (pwszMethod)
    {
        CALLFRAMEINFO info;
        hr = m_pInterceptor->GetMethodInfo(m_pmd->m_iMethod, &info, pwszMethod);
    }

    return hr;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////



inline HRESULT ProxyInitialize(CALLFRAME_MARSHALCONTEXT *pcontext, MarshallingChannel* pChannel, RPC_MESSAGE* pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, ULONG ProcNum)
// Modelled after NdrProxyInitialize
{
    HRESULT hr = S_OK;

    pStubMsg->dwStubPhase = PROXY_CALCSIZE;

    NdrClientInitializeNew(pRpcMsg, pStubMsg, pStubDescriptor, ProcNum);

    pRpcMsg->ProcNum &= ~RPC_FLAGS_VALID_BIT;

    if (pChannel)
    {
        pChannel->m_dwDestContext = pcontext->dwDestContext;
        pChannel->m_pvDestContext = pcontext->pvDestContext;

                if (pcontext->punkReserved)
                {
                        IMarshallingManager *pMgr;
                        hr = pcontext->punkReserved->QueryInterface(IID_IMarshallingManager, (void **)&pMgr);
                        if (SUCCEEDED(hr))
                        {
                                ::Set(pChannel->m_pMarshaller, pMgr);
                                pMgr->Release();
                        }
                }
                hr = S_OK;
        
        ASSERT(pChannel->m_refs == 1);
        pStubMsg->pRpcChannelBuffer = pChannel;
        pChannel->GetDestCtx(&pStubMsg->dwDestContext, &pStubMsg->pvDestContext);
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT CallFrame::GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pcontext, MSHLFLAGS mshlflags, ULONG *pcbBufferNeeded)
// Execute the sizing pass on marshalling this call frame
//
{ 
    HRESULT hr = S_OK;
    RPC_MESSAGE         rpcMsg;
    MIDL_STUB_MESSAGE   stubMsg;
    MarshallingChannel  channel;

#ifdef DBG
    ASSERT(pcontext && (pcontext->fIn ? !m_fAfterCall : TRUE));                         // not allowed to marshal in params after call has been made
#endif

    // Switch to Xml if transfer syntax is TRANSFER_SYNTAX_SOAP)  !!! BUGBUG Figure out a better way to size this !!!
    // if (pcontext->guidTransferSyntax == __uuidof(TRANSFER_SYNTAX_SOAP))
    //    {
    //    *pcbBufferNeeded = 8192;
    //    return (0);
    //    }

    hr = ProxyInitialize(pcontext, &channel, &rpcMsg, &stubMsg, GetStubDesc(), m_pmd->m_iMethod);

    if (!hr)
    {
        stubMsg.RpcMsg->RpcFlags = m_pmd->m_rpcFlags;                                   // Set Rpc flags after the call to client initialize.
        stubMsg.StackTop         = (BYTE*)m_pvArgs;
                //
                // Need to deal with things the extensions, if they exist.
                // Stolen from RPC.
                //
                if (m_pmd->m_pHeaderExts)
                {
                        stubMsg.fHasExtensions = 1;
                        stubMsg.fHasNewCorrDesc = m_pmd->m_pHeaderExts->Flags2.HasNewCorrDesc;

                        if (pcontext->fIn ? (m_pmd->m_pHeaderExts->Flags2.ClientCorrCheck)
                : (m_pmd->m_pHeaderExts->Flags2.ServerCorrCheck))
                        {
                                void *pCorrInfo = alloca(NDR_DEFAULT_CORR_CACHE_SIZE);

                                if (!pCorrInfo)
                                        RpcRaiseException (RPC_S_OUT_OF_MEMORY);
                                
                                NdrCorrelationInitialize( &stubMsg,
                                                                                  (unsigned long *)pCorrInfo,
                                                                                  NDR_DEFAULT_CORR_CACHE_SIZE,
                                                                                  0 /* flags */ );
                        }
                }

        //
        // Figure out the constant-part of the size as emitted by the compiler
        //
        stubMsg.BufferLength     = pcontext->fIn ? m_pmd->m_cbClientBuffer : m_pmd->m_cbServerBuffer; // Get the compile time computed buffer size.
        //
        // If there's more, then add that in too
        //
        if (pcontext->fIn ? m_pmd->m_optFlags.ClientMustSize : m_pmd->m_optFlags.ServerMustSize)
        {
            // Make sure that marshalling is done in the requested form
            //
            SetMarshalFlags(&stubMsg, mshlflags);

            __try // catch exceptions thrown during sizing parameters
            {
                for (ULONG iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
                {
                    const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                    const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                    //
                    m_fWorkingOnInParam  = paramAttr.IsIn;
                    m_fWorkingOnOutParam = paramAttr.IsOut;
                    //
                    if ((pcontext->fIn ? paramAttr.IsIn : paramAttr.IsOut) && paramAttr.MustSize)
                    {
                        PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                        BYTE* pArg = (BYTE*)m_pvArgs + param.StackOffset;
                        if (!paramAttr.IsByValue)
                        {
                            pArg = *(PBYTE*)pArg;
                        }
                                                NdrTypeSize(&stubMsg, pArg, pFormatParam);
                    }
                }
                //
                // Don't forget the size of the return value
                //
                if (pcontext->fIn && m_pmd->m_optFlags.HasReturn)
                {
                    const PARAM_DESCRIPTION& param   = m_pmd->m_params[m_pmd->m_numberOfParams];
                    const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                    //
                    // Compiler should always include this in the constant calculation so we
                    // should never have to actually do anything
                    //
                    ASSERT(!paramAttr.MustSize);
                }
            }
            __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
            {
               hr = GetExceptionCode();
               if(SUCCEEDED(hr))
               {
                    hr = HrNt(hr);
                    if (SUCCEEDED(hr))
                    {
                        // Hah.  Succeeded my foot.
                        // I'm not changing the HrNt function because it gets
                        // used indescriminantly sometimes, so I don't want to
                        // turn every success code to a failure.  But you don't
                        // throw successes.
                        //
                        // HRESULT_FROM_WIN32.  Makes an error.
                        hr = HRESULT_FROM_WIN32(GetExceptionCode());
                    }
                }
            }
        }
    }

    if (!hr)
        *pcbBufferNeeded = stubMsg.BufferLength;
    else
        *pcbBufferNeeded = 0;

    return hr;
}

///////////////////////////////////////////////////////////////////

inline void CallFrame::MarshalParam(MIDL_STUB_MESSAGE& stubMsg, ULONG iParam, const PARAM_DESCRIPTION& param, const PARAM_ATTRIBUTES paramAttr, PBYTE pArg)
{
    if (paramAttr.IsBasetype)
    {
        if (paramAttr.IsSimpleRef)
        {
            // Pointer to base type
            pArg = *((PBYTE*)pArg);
        }
#ifdef _ALPHA_
        else if ((param.SimpleType.Type == FC_FLOAT) && (iParam < 5))
        {
            // Special case for top-level float on Alpha. Copy the parameter from the floating point area to
            // the argument buffer. Convert double to float.
            //
            *((float *) pArg) = (float) *((double *)(pArg - 48));
        }
        else if ((param.SimpleType.Type == FC_DOUBLE) && (iParam < 5))
        {
            // Special case for top-level double on Alpha. Copy the parameter from the floating point area to
            // the argument buffer.
            //
            *((double *) pArg) = *((double *)(pArg - 48));
        }
#endif
        if (param.SimpleType.Type == FC_ENUM16)
        {
            if ( *((int *)pArg) & ~((int)0x7fff) )
                Throw(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
        }
        ALIGN (stubMsg.Buffer,       SIMPLE_TYPE_ALIGNMENT(param.SimpleType.Type));
        memcpy(stubMsg.Buffer, pArg, SIMPLE_TYPE_BUFSIZE  (param.SimpleType.Type));
        stubMsg.Buffer +=            SIMPLE_TYPE_BUFSIZE  (param.SimpleType.Type);
    }
    else
    {
        if (!paramAttr.IsByValue)
        {
            pArg = *((PBYTE*)pArg);
        }
        PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                NdrTypeMarshall(&stubMsg, pArg, pFormatParam);
    }
}

///////////////////////////////////////////////////////////////////


HRESULT CallFrame::Marshal(CALLFRAME_MARSHALCONTEXT *pcontext, MSHLFLAGS mshlflags, PVOID pBuffer, ULONG cbBuffer, ULONG *pcbBufferUsed, RPCOLEDATAREP* pdataRep, ULONG *prpcFlags)
// Marshal this call frame
{ 
    HRESULT hr = S_OK;
    RPC_MESSAGE         rpcMsg;
    MIDL_STUB_MESSAGE   stubMsg;
    MarshallingChannel  channel;

    // Switch to Xml if transfer syntax is TRANSFER_SYNTAX_SOAP
    //if (pcontext->guidTransferSyntax == __uuidof(TRANSFER_SYNTAX_SOAP))
    //    {
    //    hr = MarshalXml(pcontext, mshlflags, pBuffer, cbBuffer, pcbBufferUsed, pdataRep, prpcFlags);
    //    return (hr);
    //    }

#ifndef _WIN64
    ASSERTMSG("marshalling buffer misaligned", ((ULONG)pBuffer & 0x07) == 0);
#else
    ASSERTMSG("marshalling buffer misaligned", ((ULONGLONG)pBuffer & 0x07) == 0);
#endif

    hr = ProxyInitialize(pcontext, &channel, &rpcMsg, &stubMsg, GetStubDesc(), m_pmd->m_iMethod);
    if (!hr)
    {
        stubMsg.RpcMsg->RpcFlags = m_pmd->m_rpcFlags;
        stubMsg.StackTop         = (BYTE*)m_pvArgs;
        stubMsg.BufferLength     = cbBuffer;
        stubMsg.Buffer           = (BYTE*)pBuffer;
        stubMsg.fBufferValid     = TRUE;
        stubMsg.dwStubPhase      = pcontext->fIn ? (DWORD)PROXY_MARSHAL : (DWORD)STUB_MARSHAL;
        SetMarshalFlags(&stubMsg, mshlflags);

        stubMsg.RpcMsg->Buffer              = stubMsg.Buffer;
        stubMsg.RpcMsg->BufferLength        = stubMsg.BufferLength;
        stubMsg.RpcMsg->DataRepresentation  = NDR_LOCAL_DATA_REPRESENTATION;

                //
                // Need to deal with things the extensions, if they exist.
                // Stolen from RPC.
                //
                if (m_pmd->m_pHeaderExts)
                {
                        stubMsg.fHasExtensions = 1;
                        stubMsg.fHasNewCorrDesc = m_pmd->m_pHeaderExts->Flags2.HasNewCorrDesc;

                        if (m_pmd->m_pHeaderExts->Flags2.ClientCorrCheck)
                        {
                                void *pCorrInfo = alloca(NDR_DEFAULT_CORR_CACHE_SIZE);
                                
                                if (!pCorrInfo)
                                        RpcRaiseException (RPC_S_OUT_OF_MEMORY);
                                
                                NdrCorrelationInitialize( &stubMsg,
                                                                                  (unsigned long *)pCorrInfo,
                                                                                  NDR_DEFAULT_CORR_CACHE_SIZE,
                                                                                  0 /* flags */ );
                        }
                }
                else
                {
                        stubMsg.fHasExtensions = 0;
                        stubMsg.fHasNewCorrDesc = 0;
                }

        __try
        {
            //
            // Marshal everything that we're asked to
            //
            for (ULONG iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
            {
                const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                //
                m_fWorkingOnInParam  = paramAttr.IsIn;
                m_fWorkingOnOutParam = paramAttr.IsOut;
                //
                if (pcontext->fIn ? paramAttr.IsIn : paramAttr.IsOut)
                {
                    PBYTE pArg = (PBYTE)m_pvArgs + param.StackOffset;
                    MarshalParam(stubMsg, iparam, param, paramAttr, pArg);
                }
            }
            //
            // Marshal the return value if we have one
            //
            if (!pcontext->fIn && m_pmd->m_optFlags.HasReturn)
            {
                const PARAM_DESCRIPTION& param   = m_pmd->m_params[m_pmd->m_numberOfParams];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                PBYTE pArg                       = (BYTE*)&m_hrReturnValue;
                MarshalParam(stubMsg, iparam, param, paramAttr, pArg);
            }

        }
        __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
        {
            // 
            // REVIEW: Ideally we'd clean up the interface references (a la ReleaseMarshalData) that lie within 
            // the marshalling buffer that we've so far managed to construct. Not doing this can in theory at
            // least lead to resource leakage caused by interface references sticking around longer than they
            // need to. But the NDR library doesn't do this (see NdrClientCall2), so, for now at least, neither do we.
            //

            hr = GetExceptionCode();
            if(SUCCEEDED(hr))
            {
                hr = HrNt(hr);
                if (SUCCEEDED(hr))
                {
                    // Hah.  Succeeded my foot.
                    // I'm not changing the HrNt function because it gets
                    // used indescriminantly sometimes, so I don't want to
                    // turn every success code to a failure.  But you don't
                    // throw successes.
                    //
                    // HRESULT_FROM_WIN32.  Makes an error.
                    hr = HRESULT_FROM_WIN32(GetExceptionCode());
                }
            }
        }
    }

    if (pdataRep)   *pdataRep  = NDR_LOCAL_DATA_REPRESENTATION;
    if (prpcFlags)  *prpcFlags = m_pmd->m_rpcFlags;

    if (!hr)
    {
        if (pcbBufferUsed) *pcbBufferUsed = (ULONG)(((BYTE *)stubMsg.Buffer) - ((BYTE *)pBuffer));
    }
    else
    {
        if (pcbBufferUsed) *pcbBufferUsed = 0;
    }

    return hr;
}

///////////////////////////////////////////

inline void CallFrame::UnmarshalParam(MIDL_STUB_MESSAGE& stubMsg, const PARAM_DESCRIPTION& param, const PARAM_ATTRIBUTES paramAttr, PBYTE pArg)
{
    ASSERT(!!paramAttr.IsOut);

    if (paramAttr.IsBasetype)
    {
        if (paramAttr.IsSimpleRef)
            pArg = *(PBYTE*)pArg;

        if (param.SimpleType.Type == FC_ENUM16)
        {
            *((int *)(pArg)) = *((int *)pArg) & ((int)0x7fff);  // there's only 16 bits worth (15 bits?) in the buffer
        }

        ALIGN(stubMsg.Buffer, SIMPLE_TYPE_ALIGNMENT(param.SimpleType.Type));
        memcpy(pArg, stubMsg.Buffer, SIMPLE_TYPE_BUFSIZE(param.SimpleType.Type));
        stubMsg.Buffer += SIMPLE_TYPE_BUFSIZE(param.SimpleType.Type);
    }
    else
    {
        // REVIEW: Do the [in]-versions of [in,out] parameters get freed correctly with this
        // approach? If not, then what's different between us here and NDR? Or does NDR have
        // the same bug?
        //
        PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
        //
        // Transmit/Represent as can be passed as [out] only, thus the IsByValue check.
        //
                NdrTypeUnmarshall(
            &stubMsg, 
            param.ParamAttr.IsByValue ? &pArg : (uchar **) pArg,
            pFormatParam,
            FALSE);
    }
}

///////////////////////////////////////////

HRESULT CallFrame::Unmarshal(PVOID pBuffer, ULONG cbBuffer, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pcontext, ULONG* pcbUnmarshalled)
// Unmarshal out values in the indicated buffer into our already existing call frame
{
    HRESULT hr = S_OK;
    RPC_MESSAGE         rpcMsg;
    MIDL_STUB_MESSAGE   stubMsg;
    MarshallingChannel  channel;

    // Switch to Xml if transfer syntax is TRANSFER_SYNTAX_SOAP
    //if (pcontext->guidTransferSyntax == __uuidof(TRANSFER_SYNTAX_SOAP))
    //    {
    //    hr = UnmarshalXml(pBuffer, cbBuffer, dataRep, pcontext, pcbUnmarshalled);
    //    return (hr);
    //    }

#ifndef _WIN64
    ASSERTMSG("unmarshalling buffer misaligned", ((ULONG)pBuffer & 0x07) == 0);
#else
    ASSERTMSG("unmarshalling buffer misaligned", ((ULONGLONG)pBuffer & 0x07) == 0);
#endif
    ASSERT(m_pvArgs);
#ifdef DBG
    ASSERT(!m_fAfterCall);      // that would have init'd the out params
#endif

    hr = ProxyInitialize(pcontext, &channel, &rpcMsg, &stubMsg, GetStubDesc(), m_pmd->m_iMethod);
    if (!hr)
    {
        stubMsg.RpcMsg->RpcFlags = m_pmd->m_rpcFlags;
        stubMsg.StackTop         = (BYTE*)m_pvArgs;
        stubMsg.BufferLength     = cbBuffer;
        stubMsg.Buffer           = (BYTE*)pBuffer;
        stubMsg.BufferStart      = (BYTE*)pBuffer;
        stubMsg.BufferEnd        = ((BYTE*)pBuffer) + cbBuffer;
        stubMsg.fBufferValid     = TRUE;
        stubMsg.dwStubPhase      = PROXY_UNMARSHAL;

        stubMsg.RpcMsg->Buffer              = stubMsg.Buffer;
        stubMsg.RpcMsg->BufferLength        = stubMsg.BufferLength;
        stubMsg.RpcMsg->DataRepresentation  = dataRep;
        

                //
                // Need to deal with things the extensions, if they exist.
                // Stolen from RPC.
                //
                if (m_pmd->m_pHeaderExts)
                {
                        stubMsg.fHasExtensions = 1;
                        stubMsg.fHasNewCorrDesc = m_pmd->m_pHeaderExts->Flags2.HasNewCorrDesc;

                        if (m_pmd->m_pHeaderExts->Flags2.ServerCorrCheck)
                        {
                                void *pCorrInfo = alloca(NDR_DEFAULT_CORR_CACHE_SIZE);
                                
                                if (!pCorrInfo)
                                        RpcRaiseException (RPC_S_OUT_OF_MEMORY);
                                
                                NdrCorrelationInitialize( &stubMsg,
                                                                                  (unsigned long *)pCorrInfo,
                                                                                  NDR_DEFAULT_CORR_CACHE_SIZE,
                                                                                  0 /* flags */ );
                        }
                }
                else
                {
                        stubMsg.fHasExtensions = 0;
                        stubMsg.fHasNewCorrDesc = 0;
                }

        __try
        {
            // Do endian/floating point conversions if necessary.
            //
            if ((dataRep & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION)
            {
                NdrConvert2(&stubMsg, (PFORMAT_STRING)m_pmd->m_params, m_pmd->m_optFlags.HasReturn ? m_pmd->m_numberOfParams + 1 : m_pmd->m_numberOfParams);
            }
            //
            // Make sure that all parameters are known to be in some sort of reasonable state.
            // Caller took care of [in] and [in,out] parameters; we have to deal with outs. We
            // do this so that freeing can be sane.
            //
            for (ULONG iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
            {
                const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                //
                m_fWorkingOnInParam  = paramAttr.IsIn;
                m_fWorkingOnOutParam = paramAttr.IsOut;
                //
                if (paramAttr.IsOut && !paramAttr.IsIn && !paramAttr.IsBasetype)
                {
                    PBYTE pArg = (BYTE*)m_pvArgs + param.StackOffset;
                    PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                    NdrClientZeroOut(&stubMsg, pFormatParam, *(PBYTE*)pArg);
                }
            }
            //
            // Unmarshal the out-values proper
            //
            for (iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
            {
                const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                if (!!paramAttr.IsOut)
                {
                    PBYTE pArg = (BYTE*)m_pvArgs + param.StackOffset;
                    UnmarshalParam(stubMsg, param, paramAttr, pArg);
                }
            }
            //
            // Unmarshal the return value
            //
            if (m_pmd->m_optFlags.HasReturn)
            {
                const PARAM_DESCRIPTION& param   = m_pmd->m_params[m_pmd->m_numberOfParams];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                PBYTE pArg = (PBYTE)&m_hrReturnValue;
                UnmarshalParam(stubMsg, param, paramAttr, pArg);
            }
        }
        __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
        {
            hr = GetExceptionCode();
            if(SUCCEEDED(hr))
            {
                hr = HrNt(hr);
                if (SUCCEEDED(hr))
                {
                    // Hah.  Succeeded my foot.
                    // I'm not changing the HrNt function because it gets
                    // used indescriminantly sometimes, so I don't want to
                    // turn every success code to a failure.  But you don't
                    // throw successes.
                    //
                    // HRESULT_FROM_WIN32.  Makes an error.
                    hr = HRESULT_FROM_WIN32(GetExceptionCode());
                }
            }

            m_hrReturnValue = hr;
            //
            // REVIEW: Do we need to clean up anything here? I don't think so: the parameters
            // will be guaranteed to be in a state where a call to Free, which is the caller's
            // responsibility, will clear them up.
            //
        }
        //
        // Record how many bytes we unmarshalled. Do this even in error return cases.
        // Knowing this is important in order to be able to clean things up with ReleaseMarshalData
        //
        if (pcbUnmarshalled) *pcbUnmarshalled = PtrToUlong(stubMsg.Buffer) - PtrToUlong(pBuffer);
    }
    else
        if (pcbUnmarshalled) *pcbUnmarshalled = 0;

    //
    // We now contain valid out values.
    //
#ifdef DBG
    m_fAfterCall = TRUE;
#endif

    return hr;
}

//////////////////////////////////////////////////////

HRESULT CallFrame::ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////

HRESULT CallFrame::WalkFrame(DWORD walkWhat, ICallFrameWalker *pWalker)
// Walk the interfaces and / or denoted data of interest in this call frame
{
    HRESULT hr = S_OK;

    __try
    {
        //
        // Set state examined by walker routines
        // 
        ASSERT(!AnyWalkers());
        m_StackTop    = (BYTE*)m_pvArgs;
        m_pWalkerWalk = pWalker;
        //
        // Loop over each parameter
        //
        for (ULONG iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
        {
            const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
            const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
            //
            BOOL fWalk;
            if (!!paramAttr.IsIn)
            {
                if (!!paramAttr.IsOut)                       
                {
                    fWalk = (walkWhat & CALLFRAME_WALK_INOUT);
                }
                else
                {
                    fWalk = (walkWhat & CALLFRAME_WALK_IN);
                }
            }
            else if (!!paramAttr.IsOut)
            {
                fWalk = (walkWhat & CALLFRAME_WALK_OUT);
            }
            else
            {
                fWalk = FALSE;
                NOTREACHED();
            }
            //
            if (fWalk)
            {
                if (!m_pmd->m_rgParams[iparam].m_fMayHaveInterfacePointers)
                {
                    // Do nothing 
                }
                else
                {
                    PBYTE pArg = (PBYTE)m_pvArgs  + param.StackOffset;
                    //
                    m_fWorkingOnInParam  = paramAttr.IsIn;
                    m_fWorkingOnOutParam = paramAttr.IsOut;
                    //
                    // Parameter which is not a base type or ptr thereto
                    //
                    PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                    //
                    // We don't indirect on interface pointers, even though they are listed as not by value.
                    // In the walk routine, therefore, pMemory for interface pointers points to the location
                    // at which they reside instead of being the actual value.
                    //
                    pArg = ByValue(paramAttr, pFormatParam, FALSE) ? pArg : DerefSrc((PBYTE*)pArg);
                    
                    WalkWorker(pArg, pFormatParam);
                }
            }
        }

    }
    __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
    {
        hr = GetExceptionCode();
        if(SUCCEEDED(hr))
        {
            hr = HrNt(hr);
            if (SUCCEEDED(hr))
            {
                // Hah.  Succeeded my foot.
                // I'm not changing the HrNt function because it gets
                // used indescriminantly sometimes, so I don't want to
                // turn every success code to a failure.  But you don't
                // throw successes.
                //
                // HRESULT_FROM_WIN32.  Makes an error.
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
            }
        }
    }

    m_pWalkerWalk = NULL;
   
    ASSERT(!AnyWalkers());
    return hr;        
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////
//
// Marshalling / unmarshalling helper routines
//

HRESULT ChannelGetMarshalSizeMax(PMIDL_STUB_MESSAGE pStubMsg, ULONG *pcbMax, REFIID iid, LPUNKNOWN punk, DWORD mshlflags)
// Plumb the work through the channel if it supports it; otherwise (in user mode) just use the OLE32-exported functionality
{
    HRESULT hr = S_OK;

    ASSERT(pStubMsg->pRpcChannelBuffer);
    if (pStubMsg->pRpcChannelBuffer)
    {
        BOOL fTryLegacy = FALSE;
        IMarshallingManager* pmgr;
        hr = pStubMsg->pRpcChannelBuffer->QueryInterface(__uuidof(IMarshallingManager), (void**)&pmgr);
        if (!hr)
        {
            // The channel supports our control interface; ask it to do the work.
            //
            IMarshalSomeone* pmrshl;
            hr = pmgr->GetMarshallerFor(iid, punk, &pmrshl);
            if (!hr)
            {
                hr = pmrshl->GetMarshalSizeMax(iid, punk, pStubMsg->dwDestContext, pStubMsg->pvDestContext, mshlflags, pcbMax);

                pmrshl->Release();
            }
            else
                fTryLegacy = TRUE;

            pmgr->Release();
        }
        else
            fTryLegacy = TRUE;

        if (fTryLegacy)
        {
            // The channel does not support our new control interface. 
            //
            hr = CoGetMarshalSizeMax(pcbMax, iid, punk, pStubMsg->dwDestContext, pStubMsg->pvDestContext, mshlflags);
        }
    }
    else
        hr = E_INVALIDARG;

    return hr;
}



HRESULT ChannelMarshalInterface(PMIDL_STUB_MESSAGE pStubMsg, IStream* pstm, REFIID iid, LPUNKNOWN punk, DWORD mshlflags)
// Marshal the object, indirecting through the channel if it supports it
{
    HRESULT hr = S_OK;

    ASSERT(pStubMsg->pRpcChannelBuffer);
    if (pStubMsg->pRpcChannelBuffer)
    {
        BOOL fTryLegacy = FALSE;
        IMarshallingManager* pmgr;
        hr = pStubMsg->pRpcChannelBuffer->QueryInterface(__uuidof(IMarshallingManager), (void**)&pmgr);
        if (!hr)
        {
            // The channel supports our control interface; ask it to do the work.
            //
            IMarshalSomeone* pmrshl;
            hr = pmgr->GetMarshallerFor(iid, punk, &pmrshl);
            if (!hr)
            {
                hr = pmrshl->MarshalInterface(pstm, iid, punk, pStubMsg->dwDestContext, pStubMsg->pvDestContext, mshlflags);

                pmrshl->Release();
            }
            else
                fTryLegacy = TRUE;

            pmgr->Release();
        }
        else
            fTryLegacy = TRUE;

        if (fTryLegacy)
        {
            // The channel does not support our new control interface. 
            //
            hr = CoMarshalInterface(pstm, iid, punk, pStubMsg->dwDestContext, pStubMsg->pvDestContext, mshlflags);
        }
    }
    else
        hr = E_INVALIDARG;

    return hr;
}

HRESULT ChannelUnmarshalInterface(PMIDL_STUB_MESSAGE pStubMsg, IStream* pstm, REFIID iid, void**ppv)
{
    HRESULT hr = S_OK;

    ASSERT(pStubMsg->pRpcChannelBuffer);
    if (pStubMsg->pRpcChannelBuffer)
    {
        BOOL fTryLegacy = FALSE;
        IMarshallingManager* pmgr;
        hr = pStubMsg->pRpcChannelBuffer->QueryInterface(__uuidof(IMarshallingManager), (void**)&pmgr);
        if (!hr)
        {
            // The channel supports our control interface; ask it to do the work.
            //
            IMarshalSomeone* pmrshl;
            hr = pmgr->GetUnmarshaller(iid, &pmrshl);
            if (!hr)
            {
                hr = pmrshl->UnmarshalInterface(pstm, iid, ppv);

                pmrshl->Release();
            }
            else
                fTryLegacy = TRUE;

            pmgr->Release();
        }
        else
            fTryLegacy = TRUE;

        if (fTryLegacy)
        {
            // The channel does not support our new control interface. 
            //
            hr = CoUnmarshalInterface(pstm, iid, ppv);
        }
    }
    else
        hr = E_INVALIDARG;

    return hr;
}
    
    
PVOID NdrInternalAlloc(size_t cb)
{
#ifdef DBG
    return TracedAlloc_(cb, _ReturnAddress());
#else
    return TracedAlloc(cb);
#endif
}

void NdrInternalFree(PVOID pv)
{
    TracedFree(pv);
}

  

    
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#ifdef DBG

LPCSTR FormatCharNames[] = 
{
    "FC_ZERO", "byte", "char", "small", "usmall", "wchar", "short", "ushort",
    "long", "ulong", "float", "hyper", "double", "enum16", "enum32", "ignore", "error_status_t",
    "ref ptr", "unique ptr", "object ptr", "full ptr", "FC_STRUCT", "FC_PSTRUCT", "FC_CSTRUCT",
    "FC_CPSTRUCT", "FC_CVSTRUCT", "FC_BOGUS_STRUCT",
    "FC_CARRAY", "FC_CVARRAY", "FC_SMFARRAY", "FC_LGFARRAY", "FC_SMVARRAY", "FC_LGVARRAY", "FC_BOGUS_ARRAY",            
    "FC_C_CSTRING", "FC_C_BSTRING", "FC_C_SSTRING", "FC_C_WSTRING",
    "FC_CSTRING",   "FC_BSTRING",   "FC_SSTRING",   "FC_WSTRING",               
    "FC_ENCAPSULATED_UNION", "FC_NON_ENCAPSULATED_UNION", "FC_BYTE_COUNT_POINTER",
    "FC_TRANSMIT_AS", "FC_REPRESENT_AS", "FC_IP",
    "FC_BIND_CONTEXT", "FC_BIND_GENERIC", "FC_BIND_PRIMITIVE", "FC_AUTO_HANDLE", "FC_CALLBACK_HANDLE", "FC_PICKLE_HANDLE",
    "FC_POINTER",
    "FC_ALIGNM2", "FC_ALIGNM4", "FC_ALIGNM8", "FC_ALIGNB2", "FC_ALIGNB4", "FC_ALIGNB8",         
    "FC_STRUCTPAD1", "FC_STRUCTPAD2", "FC_STRUCTPAD3", "FC_STRUCTPAD4", "FC_STRUCTPAD5", "FC_STRUCTPAD6", "FC_STRUCTPAD7",
    "FC_STRING_SIZED", "FC_STRING_NO_SIZE",     
    "FC_NO_REPEAT", "FC_FIXED_REPEAT", "FC_VARIABLE_REPEAT", "FC_FIXED_OFFSET", "FC_VARIABLE_OFFSET",       
    "FC_PP",
    "FC_EMBEDDED_COMPLEX",

    "FC_IN_PARAM", "FC_IN_PARAM_BASETYPE", "FC_IN_PARAM_NO_FREE_INST", "FC_IN_OUT_PARAM", "FC_OUT_PARAM", "FC_RETURN_PARAM",             "FC_RETURN_PARAM_BASETYPE",

    "FC_DEREFERENCE", "FC_DIV_2", "FC_MULT_2", "FC_ADD_1", "FC_SUB_1", "FC_CALLBACK", "FC_CONSTANT_IID",

    "FC_END", "FC_PAD",

    // ** Gap before new format string types **

    "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES",
    "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", "FC_RES", 
    "FC_RES",

    // ** Gap before new format string types end **

    // 
    // Post NT 3.5 format characters.
    //

    // Hard struct

    "FC_HARD_STRUCT",            // 0xb1

    "FC_TRANSMIT_AS_PTR",        // 0xb2
    "FC_REPRESENT_AS_PTR",       // 0xb3

    "FC_END_OF_UNIVERSE",        // 0xb4

    ""
};

ULONG GetCallFrameTracing()
{
    return TRACE_ANY;
}

/*
ULONG GetTracing()
    {
    return GetCallFrameTracing();
    }
*/

#if _MSC_VER >= 1200
#pragma warning (pop)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\callframeinline.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// CallFrameInline.h
//

inline CallFrame::~CallFrame()
{
    if (m_pInterceptor) m_pInterceptor->InnerRelease();

    if (m_fIsCopy)
    {
        Free(m_pvArgs);
    }

    if (m_fWeOwnBlobBuffer)
    {
        FreeMemory(m_blobBuffer.pBlobData);
    }
}

#ifdef _IA64_

extern "C"
void __stdcall SpillFPRegsForIA64( REGISTER_TYPE* pStack, 
								   ULONG          FloatMask);
#endif

inline void CallFrame::Init(void* pvArgs, MD_METHOD* pmdMethod, Interceptor* pInterceptor)
{
    SetStackLocation_(pvArgs);
    m_pmd           = pmdMethod;
    m_fCanUseBuffer = TRUE;
    m_pInterceptor  = pInterceptor;
    m_pInterceptor->InnerAddRef();

#ifdef _IA64_
	if (m_pmd->m_pHeaderExts && pvArgs)
	{
		// ASSUMPTION: If we're on Win64, this is going to be NDR_PROC_HEADER_EXTS64.
		// That seems to be what the NDR code assumes.
		PNDR_PROC_HEADER_EXTS64 exts = (PNDR_PROC_HEADER_EXTS64)m_pmd->m_pHeaderExts;
		if (exts->FloatArgMask)
		{
			// IMPORTANT:  YOU MUST NOT USE THE FLOATING POINT ARGUMENT 
			//             REGISTERS IN BETWEEN THE FIRST INTERCEPTION 
			//             AND THIS FUNCTION CALL.
			SpillFPRegsForIA64((REGISTER_TYPE *)m_pvArgs, exts->FloatArgMask);
		}
	}
#endif
}


//////////////////////////////////////////////////////////////////////////////////

__inline void CopyBaseTypeOnStack(void* pvArgTo, void* pvArgFrom, BYTE chFromat)
{
    // All base types simply occupy a single REGISTER_TYPE slot on the stack.
    // Also, caller is responsible for probing stack before we get here.
    //
    memcpy(pvArgTo, pvArgFrom, sizeof(REGISTER_TYPE));
}


inline BOOL CallFrame::FIndirect(BYTE bPointerAttributes, PFORMAT_STRING pFormatPointee, BOOL fFromCopy) const
{
    if (POINTER_DEREF(bPointerAttributes))
    {
        // We don't indirect on interface pointers, since we need their address
        // during Walk and Free calls.
        //
        if (!fFromCopy && *pFormatPointee == FC_IP)
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
    return FALSE;
}

inline BOOL CallFrame::ByValue(const PARAM_ATTRIBUTES& paramAttr, PFORMAT_STRING pFormatParam, BOOL fFromCopy) const
// Check to see whether we should consider the given parameter as 'by value'. We differ
// from NDR in that for interface pointers, pMemory in the worker routines is the pointer to the 
// location at which the interface pointer is stored rather than the interface pointer itself.
//
// In the NDR world, 'by-value' here means, specifically, a by-value struct.
//
// See also FIndirect().
//
{
    if (paramAttr.IsByValue)
    {
        // It's by-value because MIDL told us so
        //
        return TRUE;
    }
    else if (!fFromCopy && *pFormatParam == FC_IP)
    {
        // It's an interface pointer. For copy operations we don't consider these by value, but
        // for copy operations we do.
        //
        return TRUE;
    }
/*  else if (*pFormatParam == FC_USER_MARSHAL)
    {
    // We have to force SAFEARRAY(FOO) parameters to be by-value. Why? There's apparently 
    // a bug in MIDL: [in] LPSAFEARRAY psa becomes by-value, as does a SAFEARRAY(FOO) read
    // from a type lib, but not a SAFARRAY(FOO) emitted to an _p.c file.
    //
    // REVIEW: use of SAFEARRAY(FOO) outside of a type library may be officially unsupported,
    //         since we are seeing other bugs too with that usage, like incorrect stack offsets
    //         for subsequent parameters.
    //
    return IsSafeArray(pFormatParam);
    }
*/  
    else
        return FALSE;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Memory management functions
//

inline void* CallFrame::AllocBuffer(size_t cb) // Must call w/ an exception handling frame around 
// Allocate from our private buffer if we can, otherwise use the task allocator
{ 
    BYTE* pb    = (BYTE*)m_pvMem;
    BYTE* pbCur = (BYTE*)m_pvMemCur;
    //
    // Round cb up to eight bytes in length to assure that our returned pv is always at least eight byte aligned
    //
    cb = RoundToNextMultiple((ULONG)cb, 8UL);

    if (pbCur+cb <= pb+CB_PRIVATE_BUFFER)
    {
        void* pvReturn = m_pvMemCur;
        pvReturn = (void*)((ULONG_PTR)((ULONG_PTR)pvReturn + 7) & ~7);
        m_pvMemCur = pbCur+cb;
        ASSERT(WeOwn(pvReturn));
        return pvReturn;
    }
    else
    {
        void* pvReturn = Alloc(cb);
        pvReturn = (void*)((ULONG_PTR)((ULONG_PTR)pvReturn + 7) & ~7);
        ASSERT(!WeOwn(pvReturn));
        return pvReturn;
    }
}

///////////////////////////
//
// Alloc: allocate some actual memory. Must call w/ an exception handling frame around 
//

#ifdef _DEBUG
inline void* CallFrame::Alloc(size_t cb)
{
    return Alloc_(cb, _ReturnAddress());
}

inline void* CallFrame::Alloc_(size_t cb, PVOID pvReturnAddress)
#else
    inline void* CallFrame::Alloc(size_t cb)
#endif
// Allocate from the task allocator. Throw on out of memory
{
    void* pv;
#ifdef _DEBUG
    pv = AllocateMemory_(cb, PagedPool, pvReturnAddress);
#else
    pv = AllocateMemory(cb);
#endif

#ifdef _DEBUG
    DebugTrace(TRACE_MEMORY, TAG, "0x%08x: allocated 0x%02x from task allocator", pv, cb);
#endif

    if (NULL == pv) ThrowOutOfMemory();
    return pv;
}

///////////////////////////

inline void CallFrame::Free(void* pv)
{
    if (NULL == pv || WeOwn(pv))
    {
        // Do nothing
    }
    else
    {
#ifdef _DEBUG
        DebugTrace(TRACE_MEMORY, TAG, "                                                   0x%08x: freeing to task allocator", pv);
#endif

        FreeMemory(pv);
    }
}

inline BOOL CallFrame::WeOwn(void* pv) 
// Answer as to whether the pointer here is one of our internal ones and thus 
// should not be freed by the system.
{ 
    if (m_pvMem)
    {
        if (m_pvMem <= pv   &&   pv < &((BYTE*)m_pvMem)[CB_PRIVATE_BUFFER])
        {
            return TRUE;
        }
    }
    if (m_blobBuffer.pBlobData)
    {
        if (m_blobBuffer.pBlobData <= pv   &&   pv < &m_blobBuffer.pBlobData[m_blobBuffer.cbSize])
        {
            return TRUE;
        }
    }

    return FALSE;
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void CallFrame::OutInit(CallFrame* pFrameTo, BYTE** ppArgFrom, BYTE** ppArgTo, PFORMAT_STRING pFormat)
// See also NdrOutInit in the NDR runtime. Here we are a bit different, in that
// ppArgFrom is source data which is guaranteed to be valid, but ppArgTo is destination
// data which may not yet be valid in terms of, e.g., conformance routines
//
{
    LONG cb;
    PBYTE pArgFrom;
    //
    // Check for a non-interface pointer
    //
    if (IS_BASIC_POINTER(pFormat[0]))
    {
        if (SIMPLE_POINTER(pFormat[1]))
        {
            // A pointer to a base type
            //
            cb = SIMPLE_TYPE_MEMSIZE(pFormat[2]);
            goto DoAlloc;
        }
        if (POINTER_DEREF(pFormat[1]))
        {
            // A pointer to a pointer
            //
            cb = sizeof(void*);
            goto DoAlloc;
        }
        //
        // A pointer to a complex type
        //
        pFormat += 2;
        pFormat += *(signed short *)pFormat;
    }
    
    ASSERT(pFormat[0] != FC_BIND_CONTEXT);
    //
    // Make a call to size a complex type
    // 
    pArgFrom = DerefSrc(ppArgFrom);
    cb = (LONG) (MemoryIncrement(pArgFrom, pFormat, TRUE) - pArgFrom);

 DoAlloc:

    if (cb > 0)
    {
        *ppArgTo = (BYTE*)pFrameTo->Alloc(cb);
        Zero(*ppArgTo, cb);
        //
        // We are almost done, except for an out ref to ref to ... etc.
        // If this is the case then keep allocating pointees of ref pointers.
        //
        if (pFormat[0] == FC_RP && POINTER_DEREF(pFormat[1]))
        {
            pFormat += 2;
            pFormat += *(signed short *)pFormat;
            if (pFormat[0] == FC_RP)
            {
                OutInit( pFrameTo, ppArgFrom, (BYTE**)*ppArgTo, pFormat);
            }
        }
    }
    else
        Throw(STATUS_INFO_LENGTH_MISMATCH);
}


static const IID __IID_ICallFrameWalker_ = 
{0x08B23919, 0x392D, 0x11d2, {0xB8,0xA4,0x00,0xC0,0x4F,0xB9,0x61,0x8A}};

struct SSimpleWalker : public ICallFrameWalker
{
	STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
	{
		if ( riid == IID_IUnknown || riid == __IID_ICallFrameWalker_ )
		{
			*ppv = (ICallFrameWalker*) this;
	    }
	    else
	    {
	    	*ppv = NULL;
	    	return E_NOINTERFACE;
	    }
	    return S_OK;
	}

	STDMETHOD_(ULONG, AddRef)() { return 1; }
	STDMETHOD_(ULONG, Release)() { return 1; }
    

	STDMETHOD(OnWalkInterface)( REFIID iid,                     
                                PVOID* ppvInterface,  
                                BOOL   fIn,                       
                                BOOL   fOut )
	{
		//If the interface is NULL, there's nothing for us to do.
        if (*ppvInterface == NULL)
        {
            return S_OK;
        }
        if (_cItfs < 10)
        {
            // Less than 10 interface pointers.  We can Copy the interface pointer 
            // into our primary array.
            
            _arpUnk[_cItfs++] = ((IUnknown *)*ppvInterface);
        }
        else
        {
            // More than 10 interface pointers.  We have to use our overflow array.
            
            if ( _cItfs % 10 == 0 )
            {
                // Allocate another block of memory.
                
                if ( NULL == _ppUnk )
                {
                    // Allocate first overflow array.
                    _ppUnk = (IUnknown**) AllocateMemory( sizeof( IUnknown* ) * 10 );
                }
                else
                {
                    // We've run out of room in the overflow array.  We need to grow the
                    // backup array by 10.
                    
                    // Allocate another set of 10 interface pointers.
                    IUnknown** ppTemp = (IUnknown**) AllocateMemory( sizeof( IUnknown* ) * _cItfs );

                    if (ppTemp != NULL)
					{
						// Copy existing array into new array.
						for ( ULONG i = 0; i < _cItfs - 10; i++ )
							ppTemp[i] = _ppUnk[i];
                        
						// Delete the old array.
						FreeMemory( _ppUnk );
                        
						// Set the new array.
						_ppUnk = ppTemp;
					}
					else
						return E_OUTOFMEMORY;
                }
            }
                
            // If could not alloc a backup array, fail.  Interface ptr will leak.
            if ( NULL == _ppUnk )
                return E_OUTOFMEMORY;
             
            // Copy the interface pointer into our overflow array.
            _ppUnk[_cItfs++ - 10] = ((IUnknown *)*ppvInterface);
        }
        
		return S_OK;
    }
	
	SSimpleWalker() : _cItfs( 0 ), _ppUnk( NULL ) {}
    
    void ReleaseInterfaces()
    {
        // Release everything in the primary array.
        for( ULONG i = 0; i < 10 && i < _cItfs; i++ )
            _arpUnk[i]->Release();
            
        // If we had to create a backup array, Release everything in it
        // and then free the array.
        if ( NULL != _ppUnk )
        {
            for( i = 0; i < _cItfs - 10; i++ )
                _ppUnk[i]->Release();
                
            FreeMemory( _ppUnk );
            _ppUnk = NULL;
        }
    }
    
    ULONG      _cItfs;
    IUnknown*  _arpUnk[10];
    IUnknown** _ppUnk;
};


inline void CallFrame::OutCopy(BYTE* pMemFrom, BYTE* pMemTo, PFORMAT_STRING pFormat)
// Copy an [in,out] or [out] parameter which is not a base type. Modelled after NdrClearOutParameters.
{
    // Don't blow up on NULL pointers
    //
    if (!pMemFrom || !pMemTo)
        return;

    ULONG cb;
    //
    // Look for a non-interface pointer
    //
    if (IS_BASIC_POINTER(pFormat[0]))
    {
        if (SIMPLE_POINTER(pFormat[1]))
        {
            // Pointer to a base type
            cb = SIMPLE_TYPE_MEMSIZE(pFormat[2]);
            goto DoCopy;
        }

        if (POINTER_DEREF(pFormat[1]))
        {
            // Pointer to a pointer
            cb = sizeof(PVOID);
            goto DoCopy;
        }

        pFormat += 2;
        pFormat += *(signed short *)pFormat;

        ASSERT(pFormat[0] != FC_BIND_CONTEXT);
    }

    cb = (ULONG) (MemoryIncrement(pMemFrom, pFormat, TRUE) - pMemFrom);

 DoCopy:
    
    CopyToDst(pMemTo, pMemFrom, cb);

	// Walk the parameter.
    // Note: We are walking here to collect [out] interface pointers
    //       in the parameter so we can release them.
    WalkWorker( pMemFrom, pFormat );
    
	// Zero the memory.
    ZeroSrc(pMemFrom, cb);
}


inline void CallFrame::OutZero(BYTE* pMem, PFORMAT_STRING pFormat, BOOL fDst)
// Zero an out parameter
{
    // Don't blow up on NULL pointers
    //
    if (!pMem)
        return;

    ULONG cb;
    //
    // Look for a non-interface pointer
    //
    if (IS_BASIC_POINTER(pFormat[0]))
    {
        if (SIMPLE_POINTER(pFormat[1]))
        {
            // Pointer to a base type
            cb = SIMPLE_TYPE_MEMSIZE(pFormat[2]);
            goto DoZero;
        }

        if (POINTER_DEREF(pFormat[1]))
        {
            // Pointer to a pointer
            cb = sizeof(PVOID);
            goto DoZero;
        }

        pFormat += 2;
        pFormat += *(signed short *)pFormat;

        ASSERT(pFormat[0] != FC_BIND_CONTEXT);
    }

    cb = (ULONG) (MemoryIncrement(pMem, pFormat, FALSE) - pMem);

 DoZero:

    if (fDst)
        ZeroDst(pMem, cb);
    else
        ZeroSrc(pMem, cb);
}


////////////////////////////////////////////////////////
//
// Helper walker.  This walker is used to NULL interface
// pointers on the stack.  It can also be handed another
// walker, to which it will delegate before nulling the
// pointer.  The delegate can actually call release.
//
// This object is allocated on the stack.
//
////////////////////////////////////////////////////////

struct InterfaceWalkerFree : ICallFrameWalker
{
    ICallFrameWalker* m_pWalker;

    InterfaceWalkerFree(ICallFrameWalker* p) 
    { 
        m_pWalker = p; 
        if (m_pWalker) m_pWalker->AddRef();
    }
    ~InterfaceWalkerFree()
    {
        ::Release(m_pWalker);
    }

    HRESULT STDCALL OnWalkInterface(REFIID iid, PVOID *ppvInterface, BOOL fIn, BOOL fOut)
    {
        if (m_pWalker)
        {
            m_pWalker->OnWalkInterface(iid, ppvInterface, fIn, fOut);
        }

        //
        // Null the interface pointer.
        //
        *ppvInterface = NULL;

        return S_OK;
    }
    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv)
    {
        if (iid == IID_IUnknown || iid == __uuidof(ICallFrameWalker)) *ppv = (ICallFrameWalker*)this;
        else {*ppv = NULL; return E_NOINTERFACE; }
        ((IUnknown*)*ppv)->AddRef(); return S_OK;
    }
    ULONG   STDCALL AddRef()    { return 1; }
    ULONG   STDCALL Release()   { return 1; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\com\txf\callframe\cleginterface.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
   Microsoft COM Plus (Microsoft Confidential)

   @doc
   @module CLegInterface.Cpp : Implementaion of classes for supporting interceptor
   for legacy interfaces: IDispatch, etc
 
   Description:<nl>
 
-------------------------------------------------------------------------------
Revision History:

@rev 0     | 04/30/98 | Gaganc  | Created
@rev 1     | 07/17/98 | BobAtk  | Rewrote & finished
---------------------------------------------------------------------------- */

#include "stdpch.h"
#include "common.h"
#include "ndrclassic.h"
#include "typeinfo.h"
#include "tiutil.h"
#include "CLegInterface.H"

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//
// LEGACY_FRAME
//
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

HRESULT LEGACY_FRAME::GetInfo(CALLFRAMEINFO *pInfo) 
{ 
    return m_pInterceptor->GetMethodInfo(m_iMethod, pInfo, NULL);
}

HRESULT DISPATCH_FRAME::GetIIDAndMethod(IID* piid, ULONG* piMethod) 
{ 
    if (piid)
    {
        if (m_pInterceptor->m_pmdMostDerived)
        {
            *piid = *m_pInterceptor->m_pmdMostDerived->m_pHeader->piid;
        }
        else
        {
            *piid = __uuidof(IDispatch);
        }
    }
               
    if (piMethod)   *piMethod = m_iMethod;
    return S_OK;
}


HRESULT LEGACY_FRAME::GetRemoteFrame()
// Get ourselves an engine for the wire-version of our interface
{
    HRESULT hr = S_OK;
    if (NULL == m_premoteFrame)
    {
        hr = m_pInterceptor->GetRemoteFrameFor(&m_premoteFrame, this);
        if (m_premoteFrame)
        {
            // All is well
        }
        else if (!hr)
            hr = E_OUTOFMEMORY;
    }
    return hr;
}
    
HRESULT LEGACY_FRAME::GetMemoryFrame()
// Get ourselves an engine for the in-memory-version of our interface
{
    HRESULT hr = S_OK;
    if (NULL == m_pmemoryFrame)
    {
        hr = m_pInterceptor->GetMemoryFrameFor(&m_pmemoryFrame, this);
        if (m_pmemoryFrame)
        {
            // All is well
        }
        else if (!hr)
            hr = E_OUTOFMEMORY;
    }
    return hr;
}
    

////////////////////////////////////////////////////////////////////////////////////////
//
// DISPATCH_FRAME
//

HRESULT DISPATCH_CLIENT_FRAME::ProxyPreCheck()
// Prepare our additional parameters needed to do the [call_as]-based remote call.
// Yucko-ramma, but we have to mimic what OleAut32 actually does. See also InvokeProxyPreCheck.
{
    HRESULT hr = S_OK;

    if (!m_fDoneProxyPrecheck)
    {
        m_dispParams.rgvarg       = &m_aVarArg[0];

        Zero(&m_remoteFrame);
        m_remoteFrame.rgVarRefIdx = &m_aVarRefIdx[0];
        m_remoteFrame.rgVarRef    = &m_aVarRef[0];
        m_remoteFrame.pDispParams = &m_dispParams;

        FRAME_Invoke* pframe = (FRAME_Invoke*)m_pvArgs;

        if (pframe->pDispParams == NULL || pframe->pDispParams->cNamedArgs > pframe->pDispParams->cArgs)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            m_remoteFrame.dwFlags    = pframe->wFlags;
            m_remoteFrame.dwFlags   &= (DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF);

            // Copy DISPPARAMS from stack.  Must reset rgvarg to point to our array
            // or we overwrite the one on the stack.
            m_dispParams = *pframe->pDispParams;
            m_dispParams.rgvarg = &m_aVarArg[0];

            m_remoteFrame.pVarResult =  pframe->pVarResult;
            m_remoteFrame.pExcepInfo =  pframe->pExcepInfo;
            m_remoteFrame.puArgErr   =  pframe->puArgErr;


            const UINT cArgs = pframe->pDispParams->cArgs;

            if (cArgs != 0 && pframe->pDispParams->rgvarg == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (pframe->pDispParams->cNamedArgs != 0 && pframe->pDispParams->rgdispidNamedArgs == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (pframe->pDispParams->cNamedArgs > cArgs)
            {
                hr = E_INVALIDARG;
            }
            else if (cArgs == 0) 
            {
                if (m_remoteFrame.dwFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
                {
                    hr = E_INVALIDARG;
                }
            }

            if (!hr)
            {
                if (m_remoteFrame.dwFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF)) 
                {
                    m_remoteFrame.pVarResult = NULL;    // ignore VARIANT result parameter
                }

                // count how many [in,out] parameters we have
                //
                for (UINT i = 0; i < cArgs; i++) 
                {
                    VARIANT* pvar = &pframe->pDispParams->rgvarg[i];
                    if ((V_VT(pvar) & VT_BYREF) != 0) 
                    {
                        m_remoteFrame.cVarRef++;
                    }
                }

                // Make sure we have enough space for the out array that holds pointers to VARIANT
                //
                if (cArgs > PREALLOCATE_PARAMS) 
                {
                    UINT cbBufSize = (cArgs * sizeof(VARIANT)) + (m_remoteFrame.cVarRef * (sizeof(UINT) + sizeof(VARIANT)));
                    
                    m_pBuffer = (BYTE*)TracedAlloc(cbBufSize);
                    if (m_pBuffer)
                    {
                        m_dispParams.rgvarg       = (VARIANT*) m_pBuffer;
                        m_remoteFrame.rgVarRef    = (VARIANT*) (m_dispParams.rgvarg + cArgs);
                        m_remoteFrame.rgVarRefIdx = (UINT*)    (m_remoteFrame.rgVarRef + m_remoteFrame.cVarRef);
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }

                if (!hr)
                {
                    // Initialize the derived arguments
                    //
                    VARIANT* rgVarRef    = m_remoteFrame.rgVarRef;
                    UINT*    rgVarRefIdx = m_remoteFrame.rgVarRefIdx;

                    for (i = 0; i < cArgs; i++) 
                    {
                        VARIANT* pvarFrom = &pframe->pDispParams->rgvarg[i];
                        VARIANT* pvarTo   = &m_dispParams.rgvarg[i];

                        if ((V_VT(pvarFrom) & VT_BYREF) != 0) 
                        {
                            // Marshalling as [in,out]
                            //
                            *rgVarRef++     = *pvarFrom;
                            *rgVarRefIdx++  = i;
                            V_VT(pvarTo)    = VT_EMPTY;
                        }
                        else
                        {
                            // Marshalling as [in] only
                            //
                            *pvarTo = *pvarFrom;
                        }
                    }
                    //
                    // Make sure that optional parameters are always non-NULL in order to satisfy MIDL,
                    // where they can't be declared [out, unique] like we'd like them to be
                    //
                    if (NULL == m_remoteFrame.pVarResult)
                    {
                        m_remoteFrame.pVarResult = &m_varResult;
                        m_remoteFrame.dwFlags 