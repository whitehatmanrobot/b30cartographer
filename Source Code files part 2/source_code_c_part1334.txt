top/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\inc\dynarray.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    dynarray

Abstract:

    This header file implements a Dynamic Array.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32, C++ /w Exception Handling

Notes:



--*/

#ifndef _DYNARRAY_H_
#define _DYNARRAY_H_


//
//==============================================================================
//
//  CDynamicArray
//

template <class T>
class CDynamicArray
{
public:

    //  Constructors & Destructor

    CDynamicArray(void)
    { m_Max = m_Mac = 0; m_pvList = NULL; };

    virtual ~CDynamicArray()
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(void)
    {
        if (NULL != m_pvList)
        {
            delete[] m_pvList;
            m_pvList = NULL;
            m_Max = 0;
            m_Mac = 0;
        }
    };

    void
    Empty(void)
    { m_Mac = 0; };

    T *
    Set(
        IN int nItem,
        IN T *pvItem);

    T *
    Insert(
        IN int nItem,
        IN T *pvItem);

    T *
    Add(
        IN T *pvItem);

    T * const
    Get(
        IN int nItem)
    const;

    DWORD
    Count(void) const
    { return m_Mac; };

    T ** const
    Array(void) const
    { return m_pvList; };

    //  Operators
    T * const
    operator[](int nItem) const
    { return Get(nItem); };


protected:
    //  Properties

    DWORD
        m_Max,          // Number of element slots available.
        m_Mac;          // Number of element slots used.
    T **
        m_pvList;       // The elements.


    //  Methods
};


/*++

Set:

    This routine sets an item in the collection array.  If the array isn't that
    big, it is expanded with NULL elements to become that big.

Arguments:

    nItem - Supplies the index value to be set.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    The value of the inserted value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Set(
    IN int nItem,
    IN T * pvItem)
{
    DWORD index;


    //
    // Make sure the array is big enough.
    //

    if ((DWORD)nItem >= m_Max)
    {
        int newSize = (0 == m_Max ? 4 : m_Max);
        while (nItem >= newSize)
            newSize *= 2;
        T **newList = new T*[newSize];
        if (NULL == newList)
            throw (DWORD)ERROR_OUTOFMEMORY;
        for (index = 0; index < m_Mac; index += 1)
            newList[index] = m_pvList[index];
        if (NULL != m_pvList)
            delete[] m_pvList;
        m_pvList = newList;
        m_Max = newSize;
    }


    //
    // Make sure intermediate elements are filled in.
    //

    if ((DWORD)nItem >= m_Mac)
    {
        for (index = m_Mac; index < (DWORD)nItem; index += 1)
            m_pvList[index] = NULL;
        m_Mac = (DWORD)nItem + 1;
    }


    //
    // Fill in the list element.
    //

    m_pvList[(DWORD)nItem] = pvItem;
    return pvItem;
}


/*++

Insert:

    This routine inserts an element in the array by moving all elements above it
    up one, then inserting the new element.

Arguments:

    nItem - Supplies the index value to be inserted.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    The value of the inserted value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Insert(
    IN int nItem,
    IN T * pvItem)
{
    DWORD index;
    for (index = nItem; index < m_Mac; index += 1)
        if (NULL == Set(index + 1, Get(index)))
            return NULL;    // Only the first one can fail, so no change
                            // happens on errors.
    return Set(nItem, pvItem);
}


/*++

Add:

    This method adds an element to the end of the dynamic array.

Arguments:

    pvItem - Supplies the value to be added to the list.

Return Value:

    The value of the added value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Add(
    IN T *pvItem)
{
    return Set(Count(), pvItem);
}


/*++

Get:

    This method returns the element at the given index.  If there is no element
    previously stored at that element, it returns NULL.  It does not expand the
    array.

Arguments:

    nItem - Supplies the index into the list.

Return Value:

    The value stored at that index in the list, or NULL if nothing has ever been
    stored there.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template <class T>
inline T * const
CDynamicArray<T>::Get(
    int nItem)
    const
{
    if (m_Mac <= (DWORD)nItem)
        return NULL;
    else
        return m_pvList[nItem];
}

#endif // _DYNARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\inc\scarddat.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    scarddat

Abstract:

    This header file is for backwards compatibility with existing users of
    the SSP services.  It just calls off to other header files.

Author:

    Doug Barlow (dbarlow) 7/3/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#include "scardssp.h"
#ifdef _DEBUG
#pragma message("scarddat.h is obsolete.  Use scardssp.h")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\inc\scevents.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    scEvents

Abstract:

    This header file describes the services to access the Calais Resource
    Manager special events.

Author:

    Doug Barlow (dbarlow) 7/1/1998

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _SCEVENTS_H_
#define _SCEVENTS_H_
#ifdef __cplusplus
extern "C" {
#endif

typedef HANDLE (*LPCALAISACCESSEVENT)(void);
typedef void (*LPCALAISRELEASEEVENT)(void);

#ifdef __cplusplus
}
#endif

//
// Special SCardGetStatusChange Reader Name definitions.
//

#define SCPNP_NOTIFICATION TEXT("\\\\?PnP?\\Notification")


//
//  NOTE -- The following definitions intentionally use the ANSI versions
//          of the corresponding strings.
//

inline HANDLE
CalaisAccessStartedEvent(
    void)
{
    HANDLE hReturn = NULL;

    try
    {
        HMODULE hWinScard = GetModuleHandle(TEXT("WINSCARD.DLL"));
		if (NULL != hWinScard)
		{
			LPCALAISACCESSEVENT pfCalais =
				(LPCALAISACCESSEVENT)GetProcAddress(hWinScard,
													"SCardAccessStartedEvent");
			if (NULL != pfCalais)
			{
				hReturn = (*pfCalais)();
			}
		}
    }
    catch (...)
    {
        hReturn = NULL;
    }

    return hReturn;
}

inline HANDLE
CalaisAccessNewReaderEvent(
    void)
{
    HANDLE hReturn = NULL;

    try
    {
        HMODULE hWinScard = GetModuleHandle(TEXT("WINSCARD.DLL"));
		if (NULL != hWinScard)
		{
			LPCALAISACCESSEVENT pfCalais =
				(LPCALAISACCESSEVENT)GetProcAddress(hWinScard,
													"SCardAccessNewReaderEvent");
			if (NULL != pfCalais)
			{
				hReturn = (*pfCalais)();
			}
		}
    }
    catch (...)
    {
        hReturn = NULL;
    }

    return hReturn;
}

inline void
CalaisReleaseStartedEvent(
    void)
{
    try
    {
        HMODULE hWinScard = GetModuleHandle(TEXT("WINSCARD.DLL"));
		if (NULL != hWinScard)
		{
			LPCALAISRELEASEEVENT pfCalais =
				(LPCALAISRELEASEEVENT)GetProcAddress(hWinScard,
													 "SCardReleaseStartedEvent");
			if (NULL != pfCalais)
			{
				(*pfCalais)();
			}
		}
    }
    catch (...) {}
}

inline void
CalaisReleaseNewReaderEvent(
    void)
{
    try
    {
        HMODULE hWinScard = GetModuleHandle(TEXT("WINSCARD.DLL"));
		if (NULL != hWinScard)
		{
			LPCALAISRELEASEEVENT pfCalais =
				(LPCALAISRELEASEEVENT)GetProcAddress(hWinScard,
													 "SCardReleaseNewReaderEvent");
			if (NULL != pfCalais)
			{
				(*pfCalais)();
			}
		}
    }
    catch (...) {}
}

inline void
CalaisReleaseAllEvents(
    void)
{
    try
    {
        HMODULE hWinScard = GetModuleHandle(TEXT("WINSCARD.DLL"));
		if (NULL != hWinScard)
		{
			LPCALAISRELEASEEVENT pfCalais =
				(LPCALAISRELEASEEVENT)GetProcAddress(hWinScard,
													 "SCardReleaseAllEvents");
			if (NULL != pfCalais)
			{
		        (*pfCalais)();
			}
		}
    }
    catch (...) {}
}

#endif // _SCEVENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\inc\scardmgr.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    scardmgr

Abstract:

    This header file is for backwards compatibility with existing users of
    the SSP services.  It just calls off to other header files.

Author:

    Doug Barlow (dbarlow) 7/3/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#include "scardssp.h"
#ifdef _DEBUG
#pragma message("scardmgr.h is obsolete.  Use scardssp.h")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\inc\scardlib.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SCardLib

Abstract:

    This header file incorporates the various other header files and provides
    common definitions that we are willing to share with the public.

Author:

    Doug Barlow (dbarlow) 1/15/1998

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _SCARDLIB_H_
#define _SCARDLIB_H_
#include <crtdbg.h>

#ifndef ASSERT
#if defined(_DEBUG)
#define ASSERT(x) _ASSERTE(x)
#if !defined(DBG)
#define DBG
#endif
#elif defined(DBG)
#define ASSERT(x)
#else
#define ASSERT(x)
#endif
#endif

#ifndef breakpoint
#if defined(_DEBUG)
#define breakpoint _CrtDbgBreak();
#elif defined(DBG)
#define breakpoint DebugBreak();
#else
#define breakpoint
#endif
#endif

#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const BYTE *LPCBYTE;
#endif
#ifndef _LPCVOID_DEFINED
#define _LPCVOID_DEFINED
typedef const VOID *LPCVOID;
#endif
#ifndef _LPCGUID_DEFINED
#define _LPCGUID_DEFINED
typedef const GUID *LPCGUID;
#endif
#ifndef _LPGUID_DEFINED
#define _LPGUID_DEFINED
typedef GUID *LPGUID;
#endif

#include "buffers.h"
#include "dynarray.h"
#include "Registry.h"
#include "Text.h"
#include "Handles.h"
#include "clbmisc.h"

#endif // _SCARDLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\inc\sspguid.h ===
/*++

Copyright (C) Microsoft Corporation 1999

Module Name:

    sspguid

Abstract:

    CLSID definitions from the scardssp project.

Author:

    Doug Barlow (dbarlow) 6/28/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _SSPGUID_H_
#define _SSPGUID_H_

#define IID_DEFINED

#include "scardssp_i.c"

#ifndef CLSCTX_LOCAL
#define CLSCTX_LOCAL            (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER)
#endif

#endif // _SSPGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\inc\scardsrv.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    scardsrv

Abstract:

    This header file is for backwards compatibility with existing users of
    the SSP services.  It just calls off to other header files.

Author:

    Doug Barlow (dbarlow) 7/3/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#include "scardssp.h"
#ifdef _DEBUG
#pragma message("scardsrv.h is obsolete.  Use scardssp.h")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\inc\registry.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Registry

Abstract:

    This header file defines a class to provide simple interaction to values in
    the Registry Database.

Author:

    Doug Barlow (dbarlow) 7/15/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _REGISTRY_H_
#define _REGISTRY_H_

#include <winreg.h>

#define REG_OPTION_EXISTS (~REG_LEGAL_OPTION)


//
//==============================================================================
//
//  CRegistry
//

class CRegistry
{
public:

    //  Constructors & Destructor
    CRegistry(
        HKEY hBase,
        LPCTSTR szName,
        REGSAM samDesired = KEY_ALL_ACCESS,
        DWORD dwOptions = REG_OPTION_EXISTS,
		LPSECURITY_ATTRIBUTES lpSecurityAttributes = NULL);
    CRegistry(void);
    ~CRegistry();

    //  Properties
    //  Methods
    void 
    Open(
        HKEY hBase,
        LPCTSTR szName,
        REGSAM samDesired = KEY_ALL_ACCESS,
        DWORD dwOptions = REG_OPTION_EXISTS,
		LPSECURITY_ATTRIBUTES lpSecurityAttributes = NULL);

    void Close(void);
    LONG Status(BOOL fQuiet = FALSE) const;
    void Empty(void);
    void Copy(CRegistry &regSrc);
    void DeleteKey(LPCTSTR szKey, BOOL fQuiet = FALSE) const;
    void DeleteValue(LPCTSTR szValue, BOOL fQuiet = FALSE) const;
    LPCTSTR Subkey(DWORD dwIndex);
    LPCTSTR Value(DWORD dwIndex, LPDWORD pdwType = NULL);
    void
    GetValue(
        LPCTSTR szKeyValue,
        LPTSTR *pszValue,
        LPDWORD pdwType = NULL);
    void
    GetValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwValue,
        LPDWORD pdwType = NULL)
    const;
    void
    GetValue(
        LPCTSTR szKeyValue,
        LPBYTE *ppbValue,
        LPDWORD pcbLength,
        LPDWORD pdwType = NULL);
    void
    GetValue(
        LPCTSTR szKeyValue,
        CBuffer &bfValue,
        LPDWORD pdwType = NULL);
    void
    SetValue(
        LPCTSTR szKeyValue,
        LPCTSTR szValue,
        DWORD dwType = REG_SZ)
    const;
    void
    SetValue(
        LPCTSTR szKeyValue,
        DWORD dwValue,
        DWORD dwType = REG_DWORD)
    const;
    void
    SetValue(
        LPCTSTR szKeyValue,
        LPCBYTE pbValue,
        DWORD cbLength,
        DWORD dwType = REG_BINARY)
    const;
    void
    SetAcls(
        IN SECURITY_INFORMATION SecurityInformation,
        IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
        IN BOOL fRecurse = TRUE);
    void
    SetMultiStringValue(
        LPCTSTR szKeyValue,
        LPCTSTR mszValue,
        DWORD dwType = REG_MULTI_SZ)
    const;
    LPCTSTR
    GetStringValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwType = NULL);
    DWORD
    GetNumericValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwType = NULL)
    const;
    LPCBYTE
    GetBinaryValue(
        LPCTSTR szKeyValue,
        LPDWORD pcbLength = NULL,
        LPDWORD pdwType = NULL);
    LPCTSTR
    GetMultiStringValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwType = NULL);
    DWORD
    GetValueLength(
        void)
    const;
    BOOL
    ValueExists(
        LPCTSTR szKeyValue,
        LPDWORD pcbLength = NULL,
        LPDWORD pdwType = NULL)
    const;
    DWORD
    GetDisposition(
        void)
    const;

    //  Operators
    operator HKEY(
        void)
    const
    { Status();
      return m_hKey; };

protected:
    //  Properties

    HKEY m_hKey;
    DWORD m_dwDisposition;
    CBuffer m_bfResult;
    LONG m_lSts;


    //  Methods

};


#endif // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\inc\text.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    text

Abstract:

    This header file provides a text handling class.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32

Notes:



--*/

#ifndef _TEXT_H_
#define _TEXT_H_

//#include <string.h>
//#include <mbstring.h>
#include "buffers.h"


//
//==============================================================================
//
//  CTextString
//

class CTextString
{
public:

    //  Constructors & Destructor
    CTextString()
    :   m_bfUnicode(),
        m_bfAnsi()
    { m_fFlags = fBothGood; };
    virtual ~CTextString() {};

    //  Properties
    //  Methods
    void Clear(void)
    {
        m_bfUnicode.Clear();
        m_bfAnsi.Clear();
        m_fFlags = fBothGood;
    };
    void Reset(void)
    {
        m_bfUnicode.Reset();
        m_bfAnsi.Reset();
        m_fFlags = fBothGood;
    };
    virtual DWORD Length(void);

    //  Operators
    CTextString &operator=(const CTextString &tz);
    LPCSTR operator=(LPCSTR sz);
    LPCWSTR operator=(LPCWSTR wsz);
    CTextString &operator+=(const CTextString &tz);
    LPCSTR operator+=(LPCSTR sz);
    LPCWSTR operator+=( LPCWSTR wsz);
    BOOL operator==(const CTextString &tz)
    { return (0 == Compare(tz)); };
    BOOL operator==(LPCSTR sz)
    { return (0 == Compare(sz)); };
    BOOL operator==(LPCWSTR wsz)
    { return (0 == Compare(wsz)); };
    BOOL operator!=(const CTextString &tz)
    { return (0 != Compare(tz)); };
    BOOL operator!=(LPCSTR sz)
    { return (0 != Compare(sz)); };
    BOOL operator!=(LPCWSTR wsz)
    { return (0 != Compare(wsz)); };
    BOOL operator<=(const CTextString &tz)
    { return (0 <= Compare(tz)); };
    BOOL operator<=(LPCSTR sz)
    { return (0 <= Compare(sz)); };
    BOOL operator<=(LPCWSTR wsz)
    { return (0 <= Compare(wsz)); };
    BOOL operator>=(const CTextString &tz)
    { return (0 >= Compare(tz)); };
    BOOL operator>=(LPCSTR sz)
    { return (0 >= Compare(sz)); };
    BOOL operator>=(LPCWSTR wsz)
    { return (0 >= Compare(wsz)); };
    BOOL operator<(const CTextString &tz)
    { return (0 < Compare(tz)); };
    BOOL operator<(LPCSTR sz)
    { return (0 < Compare(sz)); };
    BOOL operator<(LPCWSTR wsz)
    { return (0 < Compare(wsz)); };
    BOOL operator>(const CTextString &tz)
    { return (0 > Compare(tz)); };
    BOOL operator>(LPCSTR sz)
    { return (0 > Compare(sz)); };
    BOOL operator>(LPCWSTR wsz)
    { return (0 > Compare(wsz)); };
    operator LPCSTR(void)
    { return Ansi(); };
    operator LPCWSTR(void)
    { return Unicode(); };

protected:
    enum {
        fNoneGood = 0,
        fAnsiGood = 1,
        fUnicodeGood = 2,
        fBothGood = 3
    } m_fFlags;

    //  Properties
    CBuffer
        m_bfUnicode,
        m_bfAnsi;

    //  Methods
    LPCWSTR Unicode(void);      // Return the text as a Unicode string.
    LPCSTR Ansi(void);          // Return the text as an Ansi string.
    int Compare(const CTextString &tz);
    int Compare(LPCSTR sz);
    int Compare(LPCWSTR wsz);
    virtual DWORD Length(LPCSTR szString);
    virtual DWORD Length(LPCWSTR szString);
};


//
//==============================================================================
//
//  CTextMultistring
//

class CTextMultistring
:   public CTextString
{
public:

    //  Constructors & Destructor

    CTextMultistring()
    :   CTextString()
    {};

    //  Properties
    //  Methods
    virtual DWORD Length(void);

    //  Operators
    CTextMultistring &operator=(const CTextMultistring &tz);
    CTextMultistring &operator+=(const CTextMultistring &tz);
    LPCSTR operator=(LPCSTR sz);
    LPCWSTR operator=(LPCWSTR wsz);
    LPCSTR operator+=(LPCSTR sz);
    LPCWSTR operator+=( LPCWSTR wsz);

protected:
    //  Properties
    //  Methods
    virtual DWORD Length(LPCSTR szString);
    virtual DWORD Length(LPCWSTR szString);
};

#endif // _TEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\inc\sspsidl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       sspsidl.h
//
//--------------------------------------------------------------------------

#include "scardssp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\inc\sspserr.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SspsErr

Abstract:

    This header file describes the error codes that are generated by
    the Microsoft Smartcard Service Provider (SSP).

Author:

    Michael Gallagher (a-mgalla) 10/21/1996

Environment:

    Win32

Revision History:

    Mike Gallagher (a-mgalla) 12/19/1996

Notes:

--*/


#ifndef __SSPSERR_H__
#define __SSPSERR_H__

/////////////////////////////////////////////////////////////////////////////
//
// Includes
//

#ifndef SCARD_S_SUCCESS
#include "scarderr.h"
#endif
#ifdef _DEBUG
#pragma message("sspserr.h is obsolete.")
#endif


/////////////////////////////////////////////////////////////////////////////

#endif  // __SSPSERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\bytebuffer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ByteBuffer.h
//
//--------------------------------------------------------------------------


// ByteBuffer.h : Declaration of the CByteBuffer

#ifndef __BYTEBUFFER_H_
#define __BYTEBUFFER_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CByteBuffer
class ATL_NO_VTABLE CByteBuffer :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CByteBuffer, &CLSID_CByteBuffer>,
    public IDispatchImpl<IByteBuffer, &IID_IByteBuffer, &LIBID_SCARDSSPLib>
{
public:
    CByteBuffer()
    {
        m_pUnkMarshaler = NULL;
        m_pStreamBuf = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_BYTEBUFFER)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CByteBuffer)
    COM_INTERFACE_ENTRY(IByteBuffer)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
        if (NULL != m_pStreamBuf)
            m_pStreamBuf->Release();
    }

    LPSTREAM Stream(void)
    {
        if (NULL == m_pStreamBuf)
        {
            HRESULT hr;

            hr = CreateStreamOnHGlobal(NULL, TRUE, &m_pStreamBuf);
            if (FAILED(hr))
                throw hr;
        }
        return m_pStreamBuf;
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

// IByteBuffer
public:
    STDMETHOD(get_Stream)(
        /* [retval][out] */ LPSTREAM __RPC_FAR *ppStream);

    STDMETHOD(put_Stream)(
        /* [in] */ LPSTREAM pStream);

    STDMETHOD(Clone)(
        /* [out][in] */ LPBYTEBUFFER __RPC_FAR *ppByteBuffer);

    STDMETHOD(Commit)(
        /* [in] */ LONG grfCommitFlags);

    STDMETHOD(CopyTo)(
        /* [out][in] */ LPBYTEBUFFER __RPC_FAR *ppByteBuffer,
        /* [in] */ LONG cb,
        /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbRead = 0,
        /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbWritten = 0);

    STDMETHOD(Initialize)(
        /* [defaultvalue][in] */ LONG lSize = 1,
        /* [defaultvalue][in] */ BYTE __RPC_FAR *pData = 0);

    STDMETHOD(LockRegion)(
        /* [in] */ LONG libOffset,
        /* [in] */ LONG cb,
        /* [in] */ LONG dwLockType);

    STDMETHOD(Read)(
        /* [out][in] */ BYTE __RPC_FAR *pByte,
        /* [in] */ LONG cb,
        /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbRead = 0);

    STDMETHOD(Revert)(void);

    STDMETHOD(Seek)(
        /* [in] */ LONG dLibMove,
        /* [in] */ LONG dwOrigin,
        /* [defaultvalue][out][in] */ LONG __RPC_FAR *pLibnewPosition = 0);

    STDMETHOD(SetSize)(
        /* [in] */ LONG libNewSize);

    STDMETHOD(Stat)(
        /* [out][in] */ LPSTATSTRUCT pstatstg,
        /* [in] */ LONG grfStatFlag);

    STDMETHOD(UnlockRegion)(
        /* [in] */ LONG libOffset,
        /* [in] */ LONG cb,
        /* [in] */ LONG dwLockType);

    STDMETHOD(Write)(
        /* [out][in] */ BYTE __RPC_FAR *pByte,
        /* [in] */ LONG cb,
        /* [out][in] */ LONG __RPC_FAR *pcbWritten);

protected:
    LPSTREAM m_pStreamBuf;
};

inline CByteBuffer *
NewByteBuffer(
    void)
{
    return (CByteBuffer *)NewObject(CLSID_CByteBuffer, IID_IByteBuffer);
}

#endif //__BYTEBUFFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\conversion.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    Conversion

Abstract:

    This module contains simple conversion routines.

Author:

    Doug Barlow (dbarlow) 6/20/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include "stdafx.h"
#include "ByteBuffer.h"
#include "Conversion.h"

static BOOL
GuidFromString(
    LPCTSTR szGuid,
    LPGUID pGuid);


/*++

ConstructRequest:

    This routine builds an APDU Request.

Arguments:

    bCla supplies the Class byte

    cIns supplies the Instance byte

    bP1 supplies P1

    bP2 supplies P2

    bfData supplies the data

    wLe supplies the expected return length

    dwFlags supplies any special processing flags:

        APDU_EXTENDED_LC - Force an extended value for Lc
        APDU_EXTENDED_LE - Force an externded value for Le
        APDU_MAXIMUM_LE - Request the maximum Le value

    bfApdu receives the constructed APDU

Return Value:

    None

Throws:

    Errors are thrown as HRESULT status codes

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/26/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("ConstructRequest")

void
ConstructRequest(
    IN  BYTE bCla,
    IN  BYTE bIns,
    IN  BYTE bP1,
    IN  BYTE bP2,
    IN  CBuffer &bfData,
    IN  WORD wLe,
    IN  DWORD dwFlags,
    OUT CBuffer &bfApdu)
{
    WORD wLc;
    BOOL fExtended;
    BYTE b, rgLen[2];


    //
    // Quick prep work
    //

    if (0xffff < bfData.Length())
        throw (HRESULT)E_INVALIDARG;
    wLc = (WORD)bfData.Length();
    bfApdu.Presize(4 + 3 + 3 + wLc);    // Worst case
    fExtended = (0 != (dwFlags & APDU_EXTENDED_LENGTH))
                || (0xff < wLe)
                || (0xff < wLc);


    //
    // Fill in the buffer with the easy stuff.
    //

    bfApdu.Set(&bCla, 1);
    bfApdu.Append(&bIns, 1);
    bfApdu.Append(&bP1, 1);
    bfApdu.Append(&bP2, 1);


    //
    // Is there data to be sent?
    //

    if (0 != wLc)
    {
        if (fExtended)
        {
            LocalToNet(rgLen, wLc);
            bfApdu.Append((LPCBYTE)"", 1);      // Append a zero byte
            bfApdu.Append(rgLen, 2);
        }
        else
        {
            b = LeastSignificantByte(wLc);
            bfApdu.Append(&b, 1);
        }
        bfApdu.Append(bfData.Access(), wLc);
    }


    //
    // Do we expect data back?
    //

    if ((0 != wLe) || (0 != (dwFlags & APDU_MAXIMUM_LE)))
    {
        if (fExtended)
        {
            if (0 == wLc)
                bfApdu.Append((LPCBYTE)"", 1);  // Append a zero byte
            LocalToNet(rgLen, wLe);
            bfApdu.Append(rgLen, 2);
        }
        else
        {
            b = LeastSignificantByte(wLe);
            bfApdu.Append(&b, 1);
        }
    }
}


/*++

ParseRequest:

    This routine parses an APDU into it's components.

Arguments:

    bfApdu supplies the APDU to be parsed.

    pbCla receives the Class

    pbIns receives the Instance

    pbP1 receives P1

    pbP2 receives P2

    pbfData receives the data

    pwLc receives the supplied data length

    pwLe receives the expected length

    pdwFlags receives the construction flags

        APDU_EXTENDED_LC - There was an extended value for Lc
        APDU_EXTENDED_LE - There was an externded value for Le
        APDU_MAXIMUM_LE - There was a maximum Le value

Return Value:

    None

Throws:

    Errors are thrown as an HRESULT status code.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/26/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("ParseRequest")

void
ParseRequest(
    IN  LPCBYTE pbApdu,
    IN  DWORD cbApdu,
    OUT LPBYTE pbCla,
    OUT LPBYTE pbIns,
    OUT LPBYTE pbP1,
    OUT LPBYTE pbP2,
    OUT LPCBYTE *ppbData,
    OUT LPWORD pwLc,
    OUT LPWORD pwLe,
    OUT LPDWORD pdwFlags)
{
    DWORD dwLen = cbApdu;
    DWORD dwFlags = 0;
    WORD wLen, wLe, wLc;


    //
    // Easy stuff.
    //

    if (4 > dwLen)
        throw (HRESULT)E_INVALIDARG;
    if (NULL != pbCla)
        *pbCla = pbApdu[0];
    if (NULL != pbIns)
        *pbIns = pbApdu[1];
    if (NULL != pbP1)
        *pbP1  = pbApdu[2];
    if (NULL != pbP2)
        *pbP2  = pbApdu[3];


    //
    // Harder stuff.
    //

    if (NULL != ppbData)
        *ppbData = NULL;
    if (4 == dwLen)
    {
        // Type 1

        wLc = 0;
        wLe = 0;
    }
    else if ((0 != pbApdu[4]) || (5 == dwLen))
    {
        // Short length

        wLen = pbApdu[4];
        if (5 == dwLen)
        {
            // Type 2S
            wLc = 0;
            wLe = wLen;
            if (0 == wLen)
                dwFlags |= APDU_MAXIMUM_LE;
        }
        else if (5 == dwLen - wLen)
        {
            // Type 3S
            if (NULL != ppbData)
                *ppbData = &pbApdu[5];
            wLc = wLen;
            wLe = 0;
        }
        else if (6 == dwLen - wLen)
        {
            // Type 4S
            if (NULL != ppbData)
                *ppbData = &pbApdu[5];
            wLc = wLen;
            wLe = pbApdu[dwLen - 1];
            if (0 == wLe)
                dwFlags |= APDU_MAXIMUM_LE;
        }
        else
            throw (HRESULT)E_INVALIDARG;
    }
    else if (7 <= dwLen)
    {
        // Extended length
        dwFlags |= APDU_EXTENDED_LENGTH;
        wLen = NetToLocal(&pbApdu[5]);
        if (7 == dwLen)
        {
            // Type 2E
            wLe = wLen;
            if (0 == wLen)
                dwFlags |= APDU_MAXIMUM_LE;
        }
        else if (7 == dwLen - wLen)
        {
            // Type 3E
            if (NULL != ppbData)
                *ppbData = &pbApdu[6];
            wLc = wLen;
            wLe = 0;
        }
        else if (9 == dwLen - wLen)
        {
            // Type 4E
            if (NULL != ppbData)
                *ppbData = &pbApdu[6];
            wLc = wLen;
            wLe = NetToLocal(&pbApdu[dwLen - 2]);
            if (0 == wLe)
                dwFlags |= APDU_MAXIMUM_LE;
        }
        else
            throw (HRESULT)E_INVALIDARG;
    }
    else
        throw (HRESULT)E_INVALIDARG;

    if (NULL != pwLc)
        *pwLc = wLc;
    if (NULL != pwLe)
        *pwLe = wLe;
    if (NULL != pdwFlags)
        *pdwFlags = dwFlags;
}


/*++

ParseReply:

    This routine parses an APDU reply.

Arguments:

    bfApdu supplies the APDU reply to be parsed.

    pbSW1 receives SW1

    pbSW2 receives SW2

Return Value:

    None

Throws:

    Errors are thrown as HRESULT status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/26/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("ParseReply")

void
ParseReply(
    IN  CBuffer &bfApdu,
    OUT LPBYTE pbSW1,
    OUT LPBYTE pbSW2)
{
    DWORD dwLen = bfApdu.Length();

    if (2 > dwLen)
        throw (HRESULT)E_INVALIDARG;
    if (NULL != pbSW1)
        *pbSW1 = bfApdu[dwLen - 2];
    if (NULL != pbSW2)
        *pbSW2 = bfApdu[dwLen - 1];
}


/*++

MultiStringToSafeArray:

    This function converts a Calais Multistring to a SafeArray Structure.

Arguments:

    msz supplies the multistring to be converted.

    pprgsz supplies and/or receives the SafeArray.

Return Value:

    None

Throws:

    Errors are thrown as HRESULT error codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/20/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("MultiStringToSafeArray")

void
MultiStringToSafeArray(
    IN LPCTSTR msz,
    IN OUT LPSAFEARRAY *pprgsz)
{
    LONG ni = 0;
    DWORD csz = MStringCount(msz);
    VARTYPE vt;
    HRESULT hr;
    LPCTSTR sz;
    CTextString tz;
    LPSAFEARRAY pDelArray = NULL;

    try
    {
        if (NULL == *pprgsz)
        {
            vt = VT_BSTR;
            pDelArray = SafeArrayCreateVector(vt, 0, csz);
            if (NULL == pDelArray)
                throw (HRESULT)E_OUTOFMEMORY;
             *pprgsz= pDelArray;
        }
        else
        {
            SAFEARRAYBOUND bound;

            if (1 != SafeArrayGetDim(*pprgsz))
                throw (HRESULT)E_INVALIDARG;
            bound.cElements = csz;
            bound.lLbound = 0;
            hr = SafeArrayRedim(*pprgsz, &bound);
            if (FAILED(hr))
                throw hr;
            hr = SafeArrayGetVartype(*pprgsz, &vt);
            if (FAILED(hr))
                throw hr;
        }

        for (sz = FirstString(msz); NULL != sz; sz = NextString(sz))
        {
            tz = sz;
            switch (vt)
            {
            case VT_LPSTR:
                hr = SafeArrayPutElement(*pprgsz, &ni, (LPVOID)((LPCSTR)tz));
                break;
            case VT_LPWSTR:
                hr = SafeArrayPutElement(*pprgsz, &ni, (LPVOID)((LPCWSTR)tz));
                break;
            case VT_BSTR:
                hr = SafeArrayPutElement(*pprgsz, &ni, (LPVOID)((LPCWSTR)tz));
                break;
            default:
                hr = E_INVALIDARG;
            }

            if (FAILED(hr))
                throw hr;
            ni += 1;
        }
    }

    catch (...)
    {
        if (NULL != pDelArray)
        {
            try { *pprgsz = NULL; } catch (...) {}
            SafeArrayDestroy(pDelArray);
            throw;
        }
    }
}


/*++

GuidArrayToSafeArray:

    This function converts a vector of GUIDs into its SafeArray form.

Arguments:

    pGuids supplies the list of GUIDs

    cguids supplies the number of GUIDs in the list

    pprgguids supplies a safe array to receive the GUIDs, or if NULL, receives
        a new safe array of GUIDs.

Return Value:

    None

Throws:

    Errors are thrown as HRESULT error codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/25/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("GuidArrayToSafeArray")

void
GuidArrayToSafeArray(
    IN LPCGUID pGuids,
    IN DWORD cguids,
    IN OUT LPSAFEARRAY *pprgguids)
{
    LONG ni = 0;
    VARTYPE vt;
    HRESULT hr;
    LPSAFEARRAY pDelArray = NULL;
    CTextString tz;

    try
    {
        if (NULL == *pprgguids)
        {
            vt = VT_CLSID;
            pDelArray = SafeArrayCreateVector(vt, 0, cguids);
            if (NULL == pDelArray)
                throw (HRESULT)E_OUTOFMEMORY;
            *pprgguids = pDelArray;
        }
        else
        {
            SAFEARRAYBOUND bound;

            if (1 != SafeArrayGetDim(*pprgguids))
                throw (HRESULT)E_INVALIDARG;
            bound.cElements = cguids;
            bound.lLbound = 0;
            hr = SafeArrayRedim(*pprgguids, &bound);
            if (FAILED(hr))
                throw hr;
            hr = SafeArrayGetVartype(*pprgguids, &vt);
            if (FAILED(hr))
                throw hr;
        }

        for (ni = 0; (DWORD)ni < cguids; ni += 1)
        {
            TCHAR szGuid[40];

            StringFromGuid(&pGuids[ni], szGuid);
            tz = szGuid;

            switch (vt)
            {
            case VT_LPSTR:
                hr = SafeArrayPutElement(
                            *pprgguids,
                            &ni,
                            (LPVOID)((LPCSTR)tz));
                break;
            case VT_LPWSTR:
                hr = SafeArrayPutElement(
                            *pprgguids,
                            &ni,
                            (LPVOID)((LPCWSTR)tz));
                break;
            case VT_BSTR:
                hr = SafeArrayPutElement(
                            *pprgguids,
                            &ni,
                            (LPVOID)((LPCWSTR)tz));
                break;
            case VT_CLSID:
                hr = SafeArrayPutElement(
                            *pprgguids,
                            &ni,
                            (LPVOID)(&pGuids[ni]));
                break;
            default:
                hr = E_INVALIDARG;
            }
            if (FAILED(hr))
                throw hr;
        }
    }

    catch (...)
    {
        if (NULL != pDelArray)
        {
            try { *pprgguids = NULL; } catch (...) {}
            SafeArrayDestroy(pDelArray);
        }
        throw;
    }
}


/*++

SafeArrayToGuidArray:

    This routine converts a given SafeArray object into a list of GUIDs.

Arguments:

    prgGuids supplies the SafeArray containing the GUIDs.

    bfGuids receives a block of memory containing binary GUIDs.

    pcGuids receives the number of GUIDs in the array.

Return Value:

    None

Throws:

    Errors are thrown as HRESULT status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/25/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("SafeArrayToGuidArray")

void
SafeArrayToGuidArray(
    IN LPSAFEARRAY prgGuids,
    OUT CBuffer &bfGuids,
    OUT LPDWORD pcGuids)
{
    VARTYPE vt;
    HRESULT hr;
    LONG lLBound, lUBound, lIndex;
    LPVOID pVoid;
    CTextString tz;
    LPGUID pguid;
    LONG lOne = 1;

    if (1 != SafeArrayGetDim(prgGuids))
        throw (HRESULT)E_INVALIDARG;
    hr = SafeArrayGetLBound(prgGuids, 1, &lLBound);
    if (FAILED(hr))
        throw hr;
    hr = SafeArrayGetUBound(prgGuids, 1, &lUBound);
    if (FAILED(hr))
        throw hr;
    hr = SafeArrayGetVartype(prgGuids, &vt);
    if (FAILED(hr))
        throw hr;
    lIndex = lUBound - lLBound;
    pguid = (LPGUID)bfGuids.Resize(lIndex * sizeof(GUID));
    if (NULL != pcGuids)
        *pcGuids = (DWORD)lIndex;

    for (lIndex = lLBound; lIndex <= lUBound; lIndex += 1)
    {
        hr = SafeArrayGetElement(prgGuids, &lOne, &pVoid);
        if (FAILED(hr))
            throw hr;

        switch (vt)
        {
        case VT_LPSTR:
            tz = (LPCSTR)pVoid;
            if (!GuidFromString(tz, &pguid[lIndex - lLBound]))
                hr = E_INVALIDARG;
            break;
        case VT_LPWSTR:
            tz = (LPCWSTR)pVoid;
            if (!GuidFromString(tz, &pguid[lIndex - lLBound]))
                hr = E_INVALIDARG;
            break;
        case VT_BSTR:
            tz = (BSTR)pVoid;
            if (!GuidFromString(tz, &pguid[lIndex - lLBound]))
                hr = E_INVALIDARG;
            break;
        case VT_CLSID:
            CopyMemory(&pguid[lIndex - lLBound], pVoid, sizeof(GUID));
            break;
        default:
            hr = E_INVALIDARG;
        }

        if (FAILED(hr))
            throw hr;
    }
}


/*++

SafeArrayToMultiString:

    This routine converts a SafeArray into a multiString.

Arguments:

    prgsz supplies the SafeArray

    msz receives the MultiString

Return Value:

    None

Throws:

    Errors are thrown as HRESULT status codes

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/25/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("SafeArrayToMultiString")

void
SafeArrayToMultiString(
    IN LPSAFEARRAY prgsz,
    IN OUT CTextMultistring &msz)
{
    VARTYPE vt;
    HRESULT hr;
    LONG lLBound, lUBound, lIndex;
    LPVOID pVoid;
    CBuffer bf;

    if (1 != SafeArrayGetDim(prgsz))
        throw (HRESULT)E_INVALIDARG;
    hr = SafeArrayGetLBound(prgsz, 1, &lLBound);
    if (FAILED(hr))
        throw hr;
    hr = SafeArrayGetUBound(prgsz, 1, &lUBound);
    if (FAILED(hr))
        throw hr;
    hr = SafeArrayGetVartype(prgsz, &vt);
    if (FAILED(hr))
        throw hr;

    for (lIndex = lLBound; lIndex <= lUBound; lIndex += 1)
    {
        hr = SafeArrayGetElement(prgsz, &lIndex, &pVoid);
        if (FAILED(hr))
            throw hr;

        switch (vt)
        {
        case VT_LPSTR:
            MStrAdd(bf, (LPCSTR)pVoid);
            break;
        case VT_LPWSTR:
        case VT_BSTR:
            MStrAdd(bf, (LPCWSTR)pVoid);
            break;
        default:
            hr = E_INVALIDARG;
        }

        if (FAILED(hr))
            throw hr;
    }

    msz = (LPCTSTR)bf.Access();
}


/*++

GuidFromString:

    This routine converts a string GUID into a binary GUID.

Arguments:

    szGuid supplies the GUID in the string format.

    pGuid receives the converted GUID.

Return Value:

    TRUE - Successful conversion
    FALSE - Parsing Error

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/25/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("GuidFromString")

static BOOL
GuidFromString(
    LPCTSTR szGuid,
    LPGUID pGuid)
{

    //
    // The following placement assumes Little Endianness.
    // 1D92589A-91E4-11d1-93AA-00C04FD91402
    // 012345678901234567890123456789012345
    //           1         2         3
    //

    static const BYTE rgbPlace[sizeof(GUID)]
        = {  3,  2,  1,  0,  5,  4,  7,  6,  8,  9, 10, 11, 12, 13, 14, 15 };
    static const DWORD rgdwPunct[]
        = { 8,         13,        18,        23 };
    LPCTSTR pch = szGuid;
    BYTE bVal;
    DWORD dwI, dwJ, dwPunct = 0;

    szGuid += _tcsspn(szGuid, TEXT("{[("));
    pch = szGuid;

    for (dwI = 0; dwI < sizeof(GUID); dwI += 1)
    {
        if ((BYTE)(pch - szGuid) == rgdwPunct[dwPunct])
        {
            if (TEXT('-') != *pch)
                goto ErrorExit;
            dwPunct += 1;
            pch += 1;
        }

        bVal = 0;
        for (dwJ = 0; dwJ < 2; dwJ += 1)
        {
            bVal <<= 4;
            if ((TEXT('0') <= *pch) && (TEXT('9') >= *pch))
                bVal += *pch - TEXT('0');
            else if ((TEXT('A') <= *pch) && (TEXT('F') >= *pch))
                bVal += 10 + *pch - TEXT('A');
            else if ((TEXT('f') <= *pch) && (TEXT('f') >= *pch))
                bVal += 10 + *pch - TEXT('a');
            else
                goto ErrorExit;
            pch += 1;
        }

        ((LPBYTE)pGuid)[rgbPlace[dwI]] = bVal;
    }
    return TRUE;

ErrorExit:
    return FALSE;
}


/*++

ByteBufferToBuffer:

    This routine extracts the contents of a ByteBuffer object into a CBuffer
    for easy access.

Arguments:

    pby supplies the ByteBuffer to be read.

    bf receives the contents of pby.

Return Value:

    Number of bytes read from the stream.

Throws:

    Errors are thrown as HRESULT status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/29/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("ByteBufferToBuffer")

LONG
ByteBufferToBuffer(
    IN LPBYTEBUFFER pby,
    OUT CBuffer &bf)
{
    HRESULT hr;
    LONG nLen = 0;

    if (NULL != pby)
    {
        hr = pby->Seek(0, STREAM_SEEK_END, &nLen);
        if (FAILED(hr))
            throw hr;
        hr = pby->Seek(0, STREAM_SEEK_SET, NULL);
        if (FAILED(hr))
            throw hr;

        hr = pby->Read(
                    bf.Presize((DWORD)nLen),
                    nLen,
                    &nLen);
        if (FAILED(hr))
            throw hr;
        bf.Resize((DWORD)nLen, TRUE);
    }
    else
        bf.Reset();
    return nLen;
}


/*++

BufferToByteBuffer:

    This routine writes the contents of the supplied CBuffer object into the
    supplied IByteBuffer object, replacing any existing contents.

Arguments:

    bf supplies the data to be written into pby.

    ppby receives the contents of bf.

Return Value:

    Number of bytes written to the stream.

Throws:

    Errors are thrown as HRESULT status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/29/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("BufferToByteBuffer")

LONG
BufferToByteBuffer(
    IN  CBuffer &bf,
    OUT LPBYTEBUFFER *ppby)
{
    HRESULT hr;
    LONG lLen = 0;

    if (NULL == *ppby)
    {
        *ppby = NewByteBuffer();
        if (NULL == *ppby)
            throw (HRESULT)E_OUTOFMEMORY;
    }

    hr = (*ppby)->Initialize();
    if (FAILED(hr))
        throw hr;
    hr = (*ppby)->Write(bf.Access(), bf.Length(), &lLen);
    if (FAILED(hr))
        throw hr;
    hr = (*ppby)->Seek(0, STREAM_SEEK_SET, NULL);
    if (FAILED(hr))
        throw hr;
    return lLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\bytebuffer.cpp ===
/*++

Copyright (C) Microsoft Corporation 1999

Module Name:

    ByteBuffer

Abstract:

    The IByteBuffer interface is provided to read, write and manage stream
    objects. This object essentially is a wrapper for the IStream object.

Author:

    Doug Barlow (dbarlow) 6/16/1999

Notes:

    This is a rewrite of the original code by Mike Gallagher and Chris Dudley.

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include "stdafx.h"
#include "ByteBuffer.h"
#include "Conversion.h"
#define SetXL(xl, low, high) do { xl.LowPart = low; xl.HighPart = high; } while (0)


/////////////////////////////////////////////////////////////////////////////
// CByteBuffer

STDMETHODIMP
CByteBuffer::get_Stream(
    /* [retval][out] */ LPSTREAM __RPC_FAR *ppStream)
{
    HRESULT hReturn = S_OK;

    try
    {
        *ppStream = Stream();
        (*ppStream)->AddRef();
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP CByteBuffer::put_Stream(
    /* [in] */ LPSTREAM pStream)
{
    HRESULT hReturn = S_OK;
    LPSTREAM pOldStream = m_pStreamBuf;

    try
    {
        pStream->AddRef();
        m_pStreamBuf = pStream;
        if (NULL != pOldStream)
            pOldStream->Release();
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

Clone:

    The Clone method creates a new object with its own seek pointer that
    references the same bytes as the original IByteBuffer object.

Arguments:

    ppByteBuffer [out] When successful, points to the location of an
        IByteBuffer pointer to the new stream object. If an error occurs, this
        parameter is NULL.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    This method creates a new stream object for accessing the same bytes but
    using a separate seek pointer.  The new stream object sees the same data as
    the source stream object.  Changes written to one object are immediately
    visible in the other. Range locking is shared between the stream objects.

    The initial setting of the seek pointer in the cloned stream instance is
    the same as the current setting of the seek pointer in the original stream
    at the time of the clone operation.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Clone")

STDMETHODIMP
CByteBuffer::Clone(
    /* [out][in] */ LPBYTEBUFFER __RPC_FAR *ppByteBuffer)
{
    HRESULT hReturn = S_OK;
    CByteBuffer *pNewBuf = NULL;
    LPSTREAM pNewStream = NULL;

    try
    {
        HRESULT hr;

        *ppByteBuffer = NULL;
        pNewBuf = NewByteBuffer();
        if (NULL == pNewBuf)
            throw (HRESULT)E_OUTOFMEMORY;
        hr = Stream()->Clone(&pNewStream);
        if (FAILED(hr))
            throw hr;
        hr = pNewBuf->put_Stream(pNewStream);
        if (FAILED(hr))
            throw hr;
        pNewStream->Release();
        pNewStream = NULL;
        *ppByteBuffer = pNewBuf;
        pNewBuf = NULL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pNewBuf)
        pNewBuf->Release();
    if (NULL != pNewStream)
        pNewStream->Release();
    return hReturn;
}


/*++

Commit:

    The Commit method ensures that any changes made to an object open in
    transacted mode are reflected in the parent storage.

Arguments:

    grfCommitFlags [in] Controls how the changes for the stream object are
        committed.  See the STGC enumeration for a definition of these values.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    This method ensures that changes to a stream object opened in transacted
    mode are reflected in the parent storage.  Changes that have been made to
    the stream since it was opened or last committed are reflected to the
    parent storage object.  If the parent is opened in transacted mode, the
    parent may still revert at a later time rolling back the changes to this
    stream object.  The compound file implementation does not support opening
    streams in transacted mode, so this method has very little effect other
    than to flush memory buffers.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Commit")

STDMETHODIMP
CByteBuffer::Commit(
    /* [in] */ LONG grfCommitFlags)
{
    HRESULT hReturn = S_OK;

    try
    {
        hReturn = Stream()->Commit(grfCommitFlags);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CopyTo:

    The CopyTo method copies a specified number of bytes from the current seek
    pointer in the object to the current seek pointer in another object.

Arguments:

    pByteBuffer [in] Points to the destination stream. The stream pointed to by
        pByteBuffer can be a new stream or a clone of the source stream.

    cb [in] Specifies the number of bytes to copy from the source stream.

    pcbRead [out] Pointer to the location where this method writes the actual
        number of bytes read from the source.  You can set this pointer to NULL
        to indicate that you are not interested in this value.  In this case,
        this method does not provide the actual number of bytes read.

    pcbWritten [out] Pointer to the location where this method writes the
        actual number of bytes written to the destination.  You can set this
        pointer to NULL to indicate that you are not interested in this value.
        In this case, this method does not provide the actual number of bytes
        written.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    This method copies the specified bytes from one stream to another.  It can
    also be used to copy a stream to itself.  The seek pointer in each stream
    instance is adjusted for the number of bytes read or written.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::CopyTo")

STDMETHODIMP
CByteBuffer::CopyTo(
    /* [out][in] */ LPBYTEBUFFER __RPC_FAR *ppByteBuffer,
    /* [in] */ LONG cb,
    /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbRead,
    /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbWritten)
{
    HRESULT hReturn = S_OK;
    CByteBuffer *pMyBuffer = NULL;
    LPSTREAM pStream = NULL;

    try
    {
        HRESULT hr;
        ULARGE_INTEGER xulcb, xulRead, xulWritten;

        if (NULL == *ppByteBuffer)
        {
            *ppByteBuffer = pMyBuffer = NewByteBuffer();
            if (NULL == *ppByteBuffer)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppByteBuffer)->get_Stream(&pStream);
        if (FAILED(hr))
            throw hr;
        SetXL(xulcb, cb, 0);
        SetXL(xulRead, 0, 0);
        SetXL(xulWritten, 0, 0);
        hr = Stream()->CopyTo(pStream, xulcb, &xulRead, &xulWritten);
        if (FAILED(hr))
            throw hr;
        pStream->Release();
        pStream = NULL;
        if (NULL != pcbRead)
            *pcbRead = xulRead.LowPart;
        if (NULL != pcbWritten)
            *pcbWritten = xulWritten.LowPart;
        pMyBuffer = NULL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pMyBuffer)
    {
        pMyBuffer->Release();
        *ppByteBuffer = NULL;
    }
    if (NULL != pStream)
        pStream->Release();
    return hReturn;
}


/*++

Initialize:

    The Initialize method prepares the IByteBuffer object for use.  This method
    must be called prior to calling any other methods in the IByteBuffer
    interface.

Arguments:

    lSize - The initial size in bytes of the data the stream is to contain.

    pData - If not NULL, the initial data to write to the stream.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    When using a new IByteBuffer stream, call this method prior to using any of
    the other IByteBuffer methods.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Initialize")

STDMETHODIMP
CByteBuffer::Initialize(
    /* [defaultvalue][in] */ LONG lSize,
    /* [defaultvalue][in] */ BYTE __RPC_FAR *pData)
{
    HRESULT hReturn = S_OK;

    try
    {
        HRESULT hr;
        ULARGE_INTEGER xul;
        LARGE_INTEGER xl;

        SetXL(xul, 0, 0);
        SetXL(xl, 0, 0);

        hr = Stream()->SetSize(xul);
        if (FAILED(hr))
            throw hr;
        hr = Stream()->Seek(xl, STREAM_SEEK_SET, NULL);
        if (FAILED(hr))
            throw hr;
        if ((0 != lSize) && (NULL != pData))
        {
            hr = Stream()->Write(pData, lSize, NULL);
            if (FAILED(hr))
                throw hr;
        }
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

LockRegion:

    The LockRegion method restricts access to a specified range of bytes in the
    buffer object.

Arguments:

    libOffset [in] Integer that specifies the byte offset for the beginning of
        the range.

    cb [in] Integer that specifies the length of the range, in bytes, to be
        restricted.

    dwLockType [in] Specifies the restrictions being requested on accessing the
        range.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The byte range can extend past the current end of the stream.  Locking
    beyond the end of a stream is useful as a method of communication between
    different instances of the stream without changing data that is actually
    part of the stream.

    Three types of locking can be supported: locking to exclude other writers,
    locking to exclude other readers or writers, and locking that allows only
    one requestor to obtain a lock on the given range, which is usually an
    alias for one of the other two lock types.  A given stream instance might
    support either of the first two types, or both.  The lock type is specified
    by dwLockType, using a value from the LOCKTYPE enumeration.

    Any region locked with IByteBuffer::LockRegion must later be explicitly
    unlocked by calling IByteBuffer::UnlockRegion with exactly the same values
    for the libOffset, cb, and dwLockType parameters.  The region must be
    unlocked before the stream is released.  Two adjacent regions cannot be
    locked separately and then unlocked with a single unlock call.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::LockRegion")

STDMETHODIMP
CByteBuffer::LockRegion(
    /* [in] */ LONG libOffset,
    /* [in] */ LONG cb,
    /* [in] */ LONG dwLockType)
{
    HRESULT hReturn = S_OK;

    try
    {
        ULARGE_INTEGER xulOffset, xulcb;

        SetXL(xulOffset, libOffset, 0);
        SetXL(xulcb, cb, 0);
        hReturn = Stream()->LockRegion(xulOffset, xulcb, dwLockType);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

Read:

    The Read method reads a specified number of bytes from the buffer object
    into memory starting at the current seek pointer.

Arguments:

    pByte [out] Points to the buffer into which the stream data is read.  If an
        error occurs, this value is NULL.

    cb [in] Specifies the number of bytes of data to attempt to read from the
        stream object.

    pcbRead [out] Address of a LONG variable that receives the actual number of
        bytes read from the stream object.  You can set this pointer to NULL to
        indicate that you are not interested in this value.  In this case, this
        method does not provide the actual number of bytes read.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    This method reads bytes from this stream object into memory.  The stream
    object must be opened in STGM_READ mode.  This method adjusts the seek
    pointer by the actual number of bytes read.

    The number of bytes actually read is also returned in the pcbRead
    parameter.

    Notes to Callers

    The actual number of bytes read can be fewer than the number of bytes
    requested if an error occurs or if the end of the stream is reached during
    the read operation.

    Some implementations might return an error if the end of the stream is
    reached during the read.  You must be prepared to deal with the error
    return or S_OK return values on end of stream reads.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Read")

STDMETHODIMP
CByteBuffer::Read(
    /* [out][in] */ BYTE __RPC_FAR *pByte,
    /* [in] */ LONG cb,
    /* [defaultvalue][out][in] */ LONG __RPC_FAR *pcbRead)
{
    HRESULT hReturn = S_OK;

    try
    {
        hReturn = Stream()->Read(pByte, cb, (LPDWORD)pcbRead);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

Revert:

    The Revert method discards all changes that have been made to a transacted
    stream since the last IByteBuffer::Commit call.

Arguments:

    None.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful and the stream was reverted to its previous version.

Remarks:

    This method discards changes made to a transacted stream since the last
    commit operation.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Revert")

STDMETHODIMP
CByteBuffer::Revert(
    void)
{
    HRESULT hReturn = S_OK;

    try
    {
        hReturn = Stream()->Revert();
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

Seek:

    The Seek method changes the seek pointer to a new location relative to the
    beginning of the buffer, to the end of the buffer, or to the current seek
    pointer.

Arguments:

    dLibMove [in] Displacement to be added to the location indicated by
        dwOrigin.  If dwOrigin is STREAM_SEEK_SET, this is interpreted as an
        unsigned value rather than signed.

    dwOrigin [in] Specifies the origin for the displacement specified in
        dlibMove.  The origin can be the beginning of the file, the current
        seek pointer, or the end of the file.  See the STREAM_SEEK enumeration
        for the values.

    pLibnewPosition [out] Pointer to the location where this method writes the
        value of the new seek pointer from the beginning of the stream.  You
        can set this pointer to NULL to indicate that you are not interested in
        this value.  In this case, this method does not provide the new seek
        pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    IByteBuffer::Seek changes the seek pointer so subsequent reads and writes
    can take place at a different location in the stream object.  It is an
    error to seek before the beginning of the stream.  It is not, however, an
    error to seek past the end of the stream.  Seeking past the end of the
    stream is useful for subsequent writes, as the stream will at that time be
    extended to the seek position immediately before the write is done.

    You can also use this method to obtain the current value of the seek
    pointer by calling this method with the dwOrigin parameter set to
    STREAM_SEEK_CUR and the dlibMove parameter set to 0 so the seek pointer is
    not changed.  The current seek pointer is returned in the plibNewPosition
    parameter.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Seek")

STDMETHODIMP
CByteBuffer::Seek(
    /* [in] */ LONG dLibMove,
    /* [in] */ LONG dwOrigin,
    /* [defaultvalue][out][in] */ LONG __RPC_FAR *pLibnewPosition)
{
    HRESULT hReturn = S_OK;

    try
    {
        LARGE_INTEGER xlMove;
        ULARGE_INTEGER xulNewPos;

        SetXL(xlMove, dLibMove, 0);
        SetXL(xulNewPos, 0, 0);
        hReturn = Stream()->Seek(xlMove, dwOrigin, &xulNewPos);
        if (NULL != pLibnewPosition)
            *pLibnewPosition = xulNewPos.LowPart;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

SetSize:

    The SetSize method changes the size of the stream object.

Arguments:

    libNewSize [in] Specifies the new size of the stream as a number of bytes

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    IByteBuffer::SetSize changes the size of the stream object.  Call this
    method to preallocate space for the stream.  If the libNewSize parameter is
    larger than the current stream size, the stream is extended to the
    indicated size by filling the intervening space with bytes of undefined
    value.  This operation is similar to the IByteBuffer::Write method if the
    seek pointer is past the current end-of-stream.

    If the libNewSize parameter is smaller than the current stream, then the
    stream is truncated to the indicated size.

    The seek pointer is not affected by the change in stream size.

    Calling IByteBuffer::SetSize can be an effective way of trying to obtain a
    large chunk of contiguous space.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::SetSize")

STDMETHODIMP
CByteBuffer::SetSize(
    /* [in] */ LONG libNewSize)
{
    HRESULT hReturn = S_OK;

    try
    {
        ULARGE_INTEGER xul;

        SetXL(xul, libNewSize, 0);
        hReturn = Stream()->SetSize(xul);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

Stat:

    The Stat method retrieves statistical information from the stream object.

Arguments:

    pstatstg [out] Points to a STATSTG structure where this method places
        information about this stream object.  This data in this structure
        is meaningless if an error occurs.

    grfStatFlag [in] Ignored.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    IByteBuffer::Stat retrieves a pointer to the STATSTG structure that
    contains information about this open stream.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Stat")

STDMETHODIMP
CByteBuffer::Stat(
    /* [out][in] */ LPSTATSTRUCT pstatstg,
    /* [in] */ LONG grfStatFlag)
{
    HRESULT hReturn = S_OK;

    try
    {
        HRESULT hr;
        STATSTG stg;

        hr = Stream()->Stat(&stg, STATFLAG_NONAME);
        if (FAILED(hr))
            throw hr;
        pstatstg->type = stg.type;
        pstatstg->cbSize = stg.cbSize.LowPart;
        pstatstg->grfMode = stg.grfMode;
        pstatstg->grfLocksSupported = stg.grfLocksSupported;
        pstatstg->grfStateBits = stg.grfStateBits;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

UnlockRegion:

    The UnlockRegion method removes the access restriction on a range of bytes
    previously restricted with IByteBuffer::LockRegion.

Arguments:

    libOffset [in] Specifies the byte offset for the beginning of the range.

    cb [in] Specifies, in bytes, the length of the range to be restricted.

    dwLockType [in] Specifies the access restrictions previously placed on the
        range.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    IByteBuffer::UnlockRegion unlocks a region previously locked with the
    IByteBuffer::LockRegion method.  Locked regions must later be explicitly
    unlocked by calling IByteBuffer::UnlockRegion with exactly the same values
    for the libOffset, cb, and dwLockType parameters.  The region must be
    unlocked before the stream is released.  Two adjacent regions cannot be
    locked separately and then unlocked with a single unlock call.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::UnlockRegion")

STDMETHODIMP
CByteBuffer::UnlockRegion(
    /* [in] */ LONG libOffset,
    /* [in] */ LONG cb,
    /* [in] */ LONG dwLockType)
{
    HRESULT hReturn = S_OK;

    try
    {
        ULARGE_INTEGER xulOffset, xulcb;

        SetXL(xulOffset, libOffset, 0);
        SetXL(xulcb, cb, 0);
        hReturn = Stream()->UnlockRegion(xulOffset, xulcb, dwLockType);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

Write:

    The Write method writes a specified number from bytes into the stream
    object starting at the current seek pointer.

Arguments:

    pByte [in] Address of the buffer containing the data that is to be written
        to the stream.  A valid pointer must be provided for this parameter
        even when cb is zero.

    cb [in] The number of bytes of data to attempt to write into the stream.
        Can be zero.

    pcbWritten [out] Address of a LONG variable where this method writes the
        actual number of bytes written to the stream object.  The caller can
        set this pointer to NULL, in which case, this method does not provide
        the actual number of bytes written.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    IByteBuffer::Write writes the specified data to a stream object.  The seek
    pointer is adjusted for the number of bytes actually written.  The number
    of bytes actually written is returned in the pcbWritten parameter.  If the
    byte count is zero bytes, the write operation has no effect.

    If the seek pointer is currently past the end of the stream and the byte
    count is nonzero, this method increases the size of the stream to the seek
    pointer and writes the specified bytes starting at the seek pointer.  The
    fill bytes written to the stream are not initialized to any particular
    value.  This is the same as the end-of-file behavior in the MS-DOS FAT file
    system.

    With a zero byte count and a seek pointer past the end of the stream, this
    method does not create the fill bytes to increase the stream to the seek
    pointer.  In this case, you must call the IByteBuffer::SetSize method to
    increase the size of the stream and write the fill bytes.

    The pcbWritten parameter can have a value even if an error occurs.

    In the COM-provided implementation, stream objects are not sparse.  Any
    fill bytes are eventually allocated on the disk and assigned to the stream.

Author:

    Doug Barlow (dbarlow) 6/16/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CByteBuffer::Write")

STDMETHODIMP
CByteBuffer::Write(
    /* [out][in] */ BYTE __RPC_FAR *pByte,
    /* [in] */ LONG cb,
    /* [out][in] */ LONG __RPC_FAR *pcbWritten)
{
    HRESULT hReturn = S_OK;

    try
    {
        hReturn = Stream()->Write(pByte, cb, (LPDWORD)pcbWritten);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\conversion.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    Conversion

Abstract:

    This header file describes the format conversion services.

Author:

    Doug Barlow (dbarlow) 6/21/1999

Remarks:


Notes:


--*/

#ifndef _CONVERSION_H_
#define _CONVERSION_H_

#include <winscard.h>
#include <scardlib.h>

#define APDU_EXTENDED_LENGTH    0x01    // Force an extended value for Lc and/or Le
#define APDU_MAXIMUM_LE         0x02    // Request the maximum Le value
#define APDU_REQNAD_VALID       0x04    // The Request NaD is valid.
#define APDU_RSPNAD_VALID       0x08    // The Response NaD is valid.
#define APDU_NO_GET_RESPONSE    0x10    // Don't do automatic Get Responses
#define APDU_ALTCLA_VALID       0x20    // The Alternate CLA is valid.

extern void
ConstructRequest(
    IN  BYTE bCla,
    IN  BYTE bIns,
    IN  BYTE bP1,
    IN  BYTE bP2,
    IN  CBuffer &bfData,
    IN  WORD wLe,
    IN  DWORD dwFlags,
    OUT CBuffer &bfApdu);

extern void
ParseRequest(
    IN  LPCBYTE pbApdu,
    IN  DWORD cbApdu,
    OUT LPBYTE pbCla,
    OUT LPBYTE pbIns,
    OUT LPBYTE pbP1,
    OUT LPBYTE pbP2,
    OUT LPCBYTE *pbfData,
    OUT LPWORD pwLc,
    OUT LPWORD pwLe,
    OUT LPDWORD pdwFlags);

extern void
ParseReply(
    IN  CBuffer &bfApdu,
    OUT LPBYTE pbSW1,
    OUT LPBYTE pbSW2);

extern void
MultiStringToSafeArray(
    IN LPCTSTR msz,
    IN OUT SAFEARRAY **pprgsz);

extern void
GuidArrayToSafeArray(
    IN LPCGUID pGuids,
    IN DWORD cguids,
    IN OUT SAFEARRAY **pprgguids);

extern void
SafeArrayToGuidArray(
    IN LPSAFEARRAY prgGuids,
    OUT CBuffer &bfGuids,
    OUT LPDWORD pcGuids);

extern void
SafeArrayToGuidArray(
    IN LPSAFEARRAY prgGuids,
    OUT CBuffer &bfGuids,
    OUT LPDWORD pcGuids);

extern void
SafeArrayToMultiString(
    IN LPSAFEARRAY prgsz,
    IN OUT CTextMultistring &msz);

extern void
ApduToTpdu_T0(
    IN SCARDHANDLE hCard,
    IN const SCARD_IO_REQUEST *pPciRqst,
    IN LPCBYTE pbApdu,
    IN DWORD cbApdu,
    IN DWORD dwFlags,
    OUT CBuffer bfPciRsp,
    OUT CBuffer &bfReply,
    IN LPCBYTE pbAltCla);

extern void
ApduToTpdu_T1(
    IN SCARDHANDLE hCard,
    IN const SCARD_IO_REQUEST *pPciRqst,
    IN LPCBYTE pbApdu,
    IN DWORD cbApdu,
    IN DWORD dwFlags,
    OUT CBuffer bfPciRsp,
    OUT CBuffer &bfReply);

extern LONG
ByteBufferToBuffer(
    IN LPBYTEBUFFER pby,
    OUT CBuffer &bf);

extern LONG
BufferToByteBuffer(
    IN  CBuffer &bf,
    OUT LPBYTEBUFFER *ppby);


//
//  NOTE
//  
//      The following inline routines assume a little endian architecture,
//      and must be changed for other platforms.
//

inline WORD
NetToLocal(
    IN LPCBYTE pb)
{
    return (pb[0] << 8) + pb[1];
}

inline void
LocalToNet(
    OUT LPBYTE pb,
    IN  WORD w)
{
    pb[0] = (BYTE)((w >> 8) & 0xff);
    pb[1] = (BYTE)(w & 0xff);
}

inline BYTE
LeastSignificantByte(
    IN WORD w)
{
    return (BYTE)(w & 0xff);
}

#endif // _CONVERSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\database.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       Database.h
//
//--------------------------------------------------------------------------

// Database.h : Declaration of the CSCardDatabase

#ifndef __SCARDDATABASE_H_
#define __SCARDDATABASE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSCardDatabase
class ATL_NO_VTABLE CSCardDatabase :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSCardDatabase, &CLSID_CSCardDatabase>,
    public IDispatchImpl<ISCardDatabase, &IID_ISCardDatabase, &LIBID_SCARDSSPLib>
{
public:
    CSCardDatabase()
    {
        m_pUnkMarshaler = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SCARDDATABASE)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSCardDatabase)
    COM_INTERFACE_ENTRY(ISCardDatabase)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

// ISCardDatabase
public:
    STDMETHOD(GetProviderCardId)(
        /* [in] */ BSTR bstrCardName,
        /* [retval][out] */ LPGUID __RPC_FAR *ppguidProviderId);

    STDMETHOD(ListCardInterfaces)(
        /* [in] */ BSTR bstrCardName,
        /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppInterfaceGuids);

    STDMETHOD(ListCards)(
        /* [defaultvalue][in] */ LPBYTEBUFFER pAtr,
        /* [defaultvalue][in] */ LPSAFEARRAY pInterfaceGuids,
        /* [defaultvalue][lcid][in] */ long localeId,
        /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppCardNames);

    STDMETHOD(ListReaderGroups)(
        /* [defaultvalue][lcid][in] */ long localeId,
        /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppReaderGroups);

    STDMETHOD(ListReaders)(
        /* [defaultvalue][lcid][in] */ long localeId,
        /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppReaders);
};

inline CSCardDatabase *
NewSCardDatabase(
    void)
{
    return (CSCardDatabase *)NewObject(
                                    CLSID_CSCardDatabase,
                                    IID_ISCardDatabase);
}

#endif //__SCARDDATABASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\database.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    Database

Abstract:

    The ISCardDatabase interface provides the methods for performing the smart
    card resource manager's database operations.  These operations include
    listing known smart cards, readers, and reader groups, plus retrieving the
    interfaces supported by a smart card and its primary service provider.

Author:

    Doug Barlow (dbarlow) 6/21/1999

Notes:

    The identifier of the primary service provider is a COM GUID that can be
    used to instantiate and use the COM objects for a specific card.

    This is a rewrite of the original code by Mike Gallagher and Chris Dudley.

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include "stdafx.h"
#include "Conversion.h"
#include "Database.h"

/////////////////////////////////////////////////////////////////////////////
// CSCardDatabase


/*++

GetProviderCardId:

    The GetProviderCardId method retrieves the identifier (GUID) of the primary
    service provider for the specified smart card.

Arguments:

    bstrCardName [in] Name of the smart card.

    ppguidProviderId [out, retval] Pointer to the primary service provider's
        identifier (GUID) if successful; NULL if operation failed.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    To retrieve all known smart cards, readers and reader groups call ListCard,
    ListReaders, and ListReaderGroups respectively.

    For a list of all the methods provided by the ISCardDatabase interface, see
    ISCardDatabase.

    In addition to the COM error codes listed above, this interface may return
    a smart card error code if a smart card function was called to complete the
    request. For information on smart card error codes, see Error Codes.

Author:

    Doug Barlow (dbarlow) 6/21/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardDatabase::GetProviderCardId")

STDMETHODIMP
CSCardDatabase::GetProviderCardId(
    /* [in] */ BSTR bstrCardName,
    /* [retval][out] */ LPGUID __RPC_FAR *ppguidProviderId)
{
    HRESULT hReturn = S_OK;

    try
    {
        DWORD dwSts;
        CTextString tzCard;

        tzCard = bstrCardName;
        dwSts = SCardGetProviderId(
                    NULL,
                    tzCard,
                    *ppguidProviderId);
        hReturn = HRESULT_FROM_WIN32(dwSts);
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardDatabase::ListCardInterfaces:

    The ListCardInterfaces method retrieves the identifiers (GUIDs) of all the
    interfaces supported for the specified smart card.

Arguments:

    bstrCardName [in] Name of the smart card.

    ppInterfaceGuids [out, retval] Pointer to the interface GUIDs if
        successful; NULL if operation failed.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    To retrieve the primary service provider of the smart card, call
    GetProviderCardId.

    To retrieve all known smart cards, readers, and reader groups call
    ListCard, ListReaders, and ListReaderGroups respectively.

    For a list of all the methods provided by the ISCardDatabase interface, see
    ISCardDatabase.

    In addition to the COM error codes listed above, this interface may return
    a smart card error code if a smart card function was called to complete the
    request. For information on smart card error codes, see Error Codes.

Author:

    Doug Barlow (dbarlow) 6/21/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardDatabase::ListCardInterfaces")

STDMETHODIMP
CSCardDatabase::ListCardInterfaces(
    /* [in] */ BSTR bstrCardName,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppInterfaceGuids)
{
    HRESULT hReturn = S_OK;
    LPGUID pGuids = NULL;

    try
    {
        DWORD dwSts;
        DWORD cguid = SCARD_AUTOALLOCATE;
        CTextString tzCard;

        tzCard = bstrCardName;
        dwSts = SCardListInterfaces(
                    NULL,
                    tzCard,
                    (LPGUID)&pGuids,
                    &cguid);
        if (SCARD_S_SUCCESS == dwSts)
        {
            GuidArrayToSafeArray(pGuids, cguid, ppInterfaceGuids);
        }
        hReturn = HRESULT_FROM_WIN32(dwSts);
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pGuids)
        SCardFreeMemory(NULL, pGuids);
    return hReturn;
}


/*++

CSCardDatabase::ListCards:

    The ListCards method retrieves all of the smart card names that match the
    specified interface identifiers (GUIDs), the specified ATR string, or both.

Arguments:

    pAtr [in, defaultvalue(NULL) ] Pointer to a smart card ATR string. The ATR
        string must be packaged into an IByteBuffer.

    pInterfaceGuids [in, defaultvalue(NULL)] Pointer to a SAFEARRAY of COM
        interface identifiers (GUIDs) in BSTR format.

    localeId [in, lcid, defaultvalue(0x0409)] Language localization identifier.

    ppCardNames [out, retval] Pointer to a SAFEARRAY of BSTRs that contains the
        names of the smart cards that satisfied the search parameters if
        successful; NULL if the operation failed.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    To retrieve all known readers or reader groups, call ListReaders or
    ListReaderGroups respectively.

    To retrieve the primary service provider or the interfaces of a specific
    card GetProviderCardId or ListCardInterfaces respectively.

    For a list of all the methods provided by the ISCardDatabase interface, see
    ISCardDatabase.

    In addition to the COM error codes listed above, this interface may return
    a smart card error code if a smart card function was called to complete the
    request. For information on smart card error codes, see Error Codes.

Author:

    Doug Barlow (dbarlow) 6/21/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardDatabase::ListCards")

STDMETHODIMP
CSCardDatabase::ListCards(
    /* [defaultvalue][in] */ LPBYTEBUFFER pAtr,
    /* [defaultvalue][in] */ LPSAFEARRAY pInterfaceGuids,
    /* [defaultvalue][lcid][in] */ long localeId,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppCardNames)
{
    HRESULT hReturn = S_OK;
    LPTSTR szCards = NULL;

    try
    {
        LONG lSts;
        CBuffer bfGuids, bfAtr(36);
        LPCGUID pGuids = NULL;
        LPCBYTE pbAtr = NULL;
        DWORD cguids = 0;
        DWORD dwLen;

        if (NULL != pInterfaceGuids)
        {
            SafeArrayToGuidArray(pInterfaceGuids, bfGuids, &cguids);
            pGuids = (LPCGUID)bfGuids.Access();
        }

        ByteBufferToBuffer(pAtr, bfAtr);

        dwLen = SCARD_AUTOALLOCATE;
        lSts = SCardListCards(
                    NULL,
                    pbAtr,
                    pGuids,
                    cguids,
                    (LPTSTR)&szCards,
                    &dwLen);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);

        MultiStringToSafeArray(szCards, ppCardNames);
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != szCards)
        SCardFreeMemory(NULL, szCards);
    return hReturn;
}


/*++

CSCardDatabase::ListReaderGroups:

    The ListReaderGroups method retrieves the names of the reader groups
    registered in the smart card database.

Arguments:

    localeId [in, lcid, defaultvalue(0x0409)] Language localization ID.

    ppReaderGroups [out, retval] Pointer to a SAFEARRAY of BSTRs that contains
        the names of the smart card reader groups that satisfied the search
        parameters if successful; NULL if the operation failed.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/21/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardDatabase::ListReaderGroups")

STDMETHODIMP
CSCardDatabase::ListReaderGroups(
    /* [defaultvalue][lcid][in] */ long localeId,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppReaderGroups)
{
    HRESULT hReturn = S_OK;
    LPTSTR szGroups = NULL;

    try
    {
        LONG lSts;
        DWORD dwLen;

        dwLen = SCARD_AUTOALLOCATE;
        lSts = SCardListReaderGroups(NULL, (LPTSTR)&szGroups, &dwLen);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        MultiStringToSafeArray(szGroups, ppReaderGroups);
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != szGroups)
        SCardFreeMemory(NULL, szGroups);
    return hReturn;
}


/*++

CSCardDatabase::ListReaders:

    The ListReaders method retrieves the names of the smart card readers
    registered in the smart card database.

Arguments:

    localeId [in, lcid, defaultvalue(0x0409)] Language localization ID.

    ppReaders [out, retval] Pointer to a SAFEARRAY of BSTRs that contains the
        names of the smart card readers if successful; NULL if the operation
        failed.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/21/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardDatabase::ListReaders")

STDMETHODIMP
CSCardDatabase::ListReaders(
    /* [defaultvalue][lcid][in] */ long localeId,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppReaders)
{
    HRESULT hReturn = S_OK;
    LPTSTR szReaders = NULL;

    try
    {
        LONG lSts;
        DWORD dwLen;

        dwLen = SCARD_AUTOALLOCATE;
        lSts = SCardListReaders(NULL, NULL, (LPTSTR)&szReaders, &dwLen);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        MultiStringToSafeArray(szReaders, ppReaders);
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != szReaders)
        SCardFreeMemory(NULL, szReaders);
    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\dlldatax.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dlldatax.c
//
//--------------------------------------------------------------------------

// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400 //for WinNT 4.0 or Win95 with DCOM
#endif
#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "scardssp_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\iso7816.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ISO7816.h
//
//--------------------------------------------------------------------------

// ISO7816.h : Declaration of the CSCardISO7816

#ifndef __SCARDISO7816_H_
#define __SCARDISO7816_H_

#include "resource.h"       // main symbols
#include "scardcmd.h"

/////////////////////////////////////////////////////////////////////////////
// CSCardISO7816
class ATL_NO_VTABLE CSCardISO7816 :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSCardISO7816, &CLSID_CSCardISO7816>,
    public IDispatchImpl<ISCardISO7816, &IID_ISCardISO7816, &LIBID_SCARDSSPLib>
{
public:
    CSCardISO7816()
    {
        m_pUnkMarshaler = NULL;
        m_bCla = 0;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SCARDISO7816)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSCardISO7816)
    COM_INTERFACE_ENTRY(ISCardISO7816)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

protected:
    BYTE m_bCla;

// ISCardISO7816
public:
    STDMETHOD(AppendRecord)(
        /* [in] */ BYTE byRefCtrl,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(EraseBinary)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(ExternalAuthenticate)(
        /* [in] */ BYTE byAlgorithmRef,
        /* [in] */ BYTE bySecretRef,
        /* [in] */ LPBYTEBUFFER pChallenge,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(GetChallenge)(
        /* [in] */ LONG lBytesExpected,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(GetData)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LONG lBytesToGet,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(GetResponse)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LONG lDataLength,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(InternalAuthenticate)(
        /* [in] */ BYTE byAlgorithmRef,
        /* [in] */ BYTE bySecretRef,
        /* [in] */ LPBYTEBUFFER pChallenge,
        /* [in] */ LONG lReplyBytes,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(ManageChannel)(
        /* [in] */ BYTE byChannelState,
        /* [in] */ BYTE byChannel,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(PutData)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(ReadBinary)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LONG lBytesToRead,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(ReadRecord)(
        /* [in] */ BYTE byRecordId,
        /* [in] */ BYTE byRefCtrl,
        /* [in] */ LONG lBytesToRead,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(SelectFile)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LPBYTEBUFFER pData,
        /* [in] */ LONG lBytesToRead,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(SetDefaultClassId)(
        /* [in] */ BYTE byClass);

    STDMETHOD(UpdateBinary)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(UpdateRecord)(
        /* [in] */ BYTE byRecordId,
        /* [in] */ BYTE byRefCtrl,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(Verify)(
        /* [in] */ BYTE byRefCtrl,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(WriteBinary)(
        /* [in] */ BYTE byP1,
        /* [in] */ BYTE byP2,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(WriteRecord)(
        /* [in] */ BYTE byRecordId,
        /* [in] */ BYTE byRefCtrl,
        /* [in] */ LPBYTEBUFFER pData,
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);
};

inline CSCardISO7816 *
NewSCardISO7816(
    void)
{
    return (CSCardISO7816 *)NewObject(CLSID_CSCardISO7816, IID_ISCardISO7816);
}

#endif //__SCARDISO7816_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\locate.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       Locate.h
//
//--------------------------------------------------------------------------

// Locate.h : Declaration of the CSCardLocate

#ifndef __SCARDLOCATE_H_
#define __SCARDLOCATE_H_

#include <winscard.h>
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSCardLocate
class ATL_NO_VTABLE CSCardLocate :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSCardLocate, &CLSID_CSCardLocate>,
    public IDispatchImpl<ISCardLocate, &IID_ISCardLocate, &LIBID_SCARDSSPLib>
{
public:
    CSCardLocate()
    :   m_mtzGroupNames(),
        m_mtzCardNames(),
        m_bfInterfaces(),
        m_bfRdr(MAX_PATH),
        m_bfCard(MAX_PATH),
        m_tzTitle()
    {
        m_pUnkMarshaler = NULL;
        m_lFlags = 0;
        ZeroMemory(&m_subCardInfo, sizeof(SCARDINFO));
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SCARDLOCATE)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSCardLocate)
    COM_INTERFACE_ENTRY(ISCardLocate)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

protected:
    SCARDINFO m_subCardInfo;
    CTextMultistring m_mtzGroupNames;
    CTextMultistring m_mtzCardNames;
    CBuffer m_bfInterfaces;
    CBuffer m_bfRdr;
    CBuffer m_bfCard;
    CTextString m_tzTitle;
    LONG m_lFlags;

// ISCardLocate
public:
    STDMETHOD(ConfigureCardGuidSearch)(
        /* [in] */ LPSAFEARRAY pCardGuids,
        /* [defaultvalue][in] */ LPSAFEARRAY pGroupNames = 0,
        /* [defaultvalue][in] */ BSTR bstrTitle = L"",
        /* [defaultvalue][in] */ LONG lFlags = 1);

    STDMETHOD(ConfigureCardNameSearch)(
        /* [in] */ LPSAFEARRAY pCardNames,
        /* [defaultvalue][in] */ LPSAFEARRAY pGroupNames = 0,
        /* [defaultvalue][in] */ BSTR bstrTitle = L"",
        /* [defaultvalue][in] */ LONG lFlags = 1);

    STDMETHOD(FindCard)(
        /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
        /* [defaultvalue][in] */ SCARD_PROTOCOLS Protocols,
        /* [defaultvalue][in] */ LONG lFlags,
        /* [retval][out] */ LPSCARDINFO __RPC_FAR *ppCardInfo);
};

inline LPSCARDLOCATE
NewSCardLocate(
    void)
{
    return (LPSCARDLOCATE)NewObject(CLSID_CSCardLocate, IID_ISCardLocate);
}


#endif //__SCARDLOCATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\iso7816.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    ISO7816

Abstract:

    The ISCardISO7816 interface provides methods for implementing ISO 7816-4
    functionality.  With the exception of ISCardISO7816::SetDefaultClassId,
    these methods create an APDU command that is encapsulated in a ISCardCmd
    object.

    The ISO 7816-4 specification defines standard commands available on smart
    cards.  The specification also defines how a smart card Application
    Protocol Data Unit (APDU) command should be constructed and sent to the
    smart card for execution.  This interface automates the building process.

    The following example shows a typical use of the ISCardISO7816 interface.
    In this case, the ISCardISO7816 interface is used to build an APDU command.

    To submit a transaction to a specific card

    1)  Create an ISCardISO7816 and ISCardCmd interface.  The ISCardCmd
        interface is used to encapsulate the APDU.
    2)  Call the appropriate method of the ISCardISO7816 interface, passing the
        required parameters and the ISCardCmd interface pointer.
    3)  The ISO 7816-4 APDU command will be built and encapsulated in the
        ISCardCmd interface.
    4)  Release the ISCardISO7816 and ISCardCmd interfaces.

    Note

    In the method reference pages, if a bit sequence in a table is not defined,
    assume that bit sequence is reserved for future use or proprietary to a
    specific vendor).

Author:

    Doug Barlow (dbarlow) 6/24/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "stdafx.h"
#include "ISO7816.h"

/////////////////////////////////////////////////////////////////////////////
// CSCardISO7816


/*++

CSCardISO7816::AppendRecord:

    The AppendRecord method constructs an APDU command that either appends a
    record to the end of a linear-structured elementary file (EF) or writes
    record number 1 in an cyclic-structured elementary file.

Arguments:

    byRefCtrl [in, defaultvalue(NULL_BYTE)] Identifies the elementary file to
        be appended:

        Meaning     8 7 6 5 4 3 2 1
        Current EF  0 0 0 0 0 0 0 0
        Short EF ID x x x x x 0 0 0
        Reserved    x x x x x x x x

    pData [in] Pointer to the data to be appended to the file:

        Tn (1 byte)
        Ln (1 or 3 bytes)
        data (Ln bytes)

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    read.

    If another elementary file is selected at the time of issuing this command,
    it may be processed without identification of the currently selected file.

    Elementary files without a record structure cannot be read.  The
    encapsulated command aborts if applied to an elementary file without a
    record structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::AppendRecord")

STDMETHODIMP
CSCardISO7816::AppendRecord(
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,     // CLA
                            0xe2,       // INS
                            0,          // P1
                            byRefCtrl,  // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::EraseBinary:

    The EraseBinary method constructs an APDU command that sequentially sets
    part of the content of an elementary file to its logical erased state,
    starting from a given offset.

Arguments:

    byP1, byP2 [in] RFU position.

        If         Then
        b8=1 in P1  b7 and b6 of P1 are set to 0 (RFU bits), b5 to b1 of P1 are
                    a short EF identifier and P2 is the offset of the first
                    byte to be erased (in data units) from the beginning of the
                    file.
        b8=0 in P1  then P1 || P2 is the offset of the first byte to be erased
        (in data units) from the beginning of the file.

        If the data field is present, it codes the offset of the first data
        unit not to be erased.  This offset shall be higher than the one coded
        in P1-P2.  When the data field is empty, the command erases up to the
        end of the file.

    pData [in, defaultvalue(NULL)] Pointer to the data that specifies the erase
        range; may be NULL.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being processed.

    When the command contains a valid short elementary identifier, it sets the
    file as current elementary file.

    Elementary files without a transparent structure cannot be erased.  The
    encapsulated command aborts if applied to an elementary file without a
    transparent structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::EraseBinary")

STDMETHODIMP
CSCardISO7816::EraseBinary(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0x0e,   // INS
                            byP1,   // P1
                            byP2,   // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::ExternalAuthenticate:

    The ExternalAuthenticate method constructs an APDU command that
    conditionally updates security status, verifying the identity of the
    computer when the smart card does not trust it.

    The command uses the result (yes or no) of the computation by the card
    (based on a challenge previously issued by the card  for example, by the
    INS_GET_CHALLENGE command), a key (possibly secret) stored in the card, and
    authentication data transmitted by the interface device.

Arguments:

    byAlgorithmRef [in, defaultvalue(NULL_BYTE)] Reference of the algorithm in
        the card.  If this value is zero, this indicates that no information is
        given.  The reference of the algorithm is known either before issuing
        the command or is provided in the data field.

    bySecretRef [in, defaultvalue(NULL_BYTE)] Reference of the secret:

        Meaning         8 7 6 5 4 3 2 1
        No Info         0 0 0 0 0 0 0 0
        Global ref      0 - - - - - - -
        Specific ref    1 - - - - - - -
        RFU             - x x - - - - -
        Secret          - - - x x x x x

        No Info = No information is given. The reference of the secret is known
            either before issuing the command or is provided in the data field.

        Global ref = Global reference data (an MF specific key).

        Specific ref = Specific reference data (a DF specific key).

        RFU = 00 (other values are RFU).

        Secret = Number of the secret.

    pChallenge [in, defaultvalue(NULL)] Pointer to the authentication-related
        data; may be NULL.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    For the encapsulated command to be successful, the last challenge obtained
    from the card must be valid.

    Unsuccessful comparisons may be recorded in the card (for example, to limit
    the number of further attempts of the use of the reference data).

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::ExternalAuthenticate")

STDMETHODIMP
CSCardISO7816::ExternalAuthenticate(
    /* [in] */ BYTE byAlgorithmRef,
    /* [in] */ BYTE bySecretRef,
    /* [in] */ LPBYTEBUFFER pChallenge,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,         // CLA
                            0x82,           // INS
                            byAlgorithmRef, // P1
                            bySecretRef,    // P2
                            pChallenge,     // data
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::GetChallenge:

    The GetChallenge method constructs an APDU command that issue a challenge
    (for example, a random number) for use in a security-related procedure.

Arguments:

    lBytesExpected [in, defaultvalue(0)] Maximum length of the expected response.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation. If ppCmd was set to NULL, a smart card ISCardCmd object
        is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The challenge is valid at least for the next command.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::GetChallenge")

STDMETHODIMP
CSCardISO7816::GetChallenge(
    /* [in] */ LONG lBytesExpected,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0x84,   // INS
                            0x00,   // P1
                            0x00,   // P2
                            NULL,
                            &lBytesExpected);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::GetData:

    The GetData method constructs an APDU command that retrieves either a
    single primitive data object or a set of data objects (contained in a
    constructed data object), depending on the type of file selected.

Arguments:

    byP1, byP2 [in] Parameters:

        Value           Meaning
        0000 - 003F     RFU
        0040 - 00FF     BER-TLV tag (1 byte) in P2
        0100 - 01FF     Application data (proprietary coding)
        0200 - 02FF     SIMPLE-TLV tag in P2
        0300 - 03FF     RFU
        0400 - 04FF     BER-TLV tag (2 bytes) in P1-P2

    lBytesToGet [in, defaultvalue(0)] Number of bytes expected in the response.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being read.  Security conditions are dependent on the policy of the card,
    and may be manipulated through ExternalAuthenticate, InternalAuthenticate,
    ISCardAuth, etc.

    To select a file, call SelectFile.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::GetData")

STDMETHODIMP
CSCardISO7816::GetData(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LONG lBytesToGet,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0xca,   // INS
                            byP1,   // P1
                            byP2,   // P2
                            NULL,
                            &lBytesToGet);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::GetResponse:

    The GetResponse method constructs an APDU command that transmits APDU
    commands (or part of an APDU command) which otherwise could not be
    transmitted by the available protocols.

Arguments:

    byP1, byP2 [in, defaultvalue(0)] Per the ISO 7816-4, P1 and P2 should be 0
        (RFU).

    lDataLength [in, defaultvalue(0)] Length of data transmitted.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::GetResponse")

STDMETHODIMP
CSCardISO7816::GetResponse(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LONG lDataLength,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0xc0,   // INS
                            0x00,   // P1
                            0x00,   // P2
                            NULL,
                            &lDataLength);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::InternalAuthenticate:

    The InternalAuthenticate method constructs an APDU command that initiates
    the computation of the authentication data by the card using the challenge
    data sent from the interface device and a relevant secret (for example, a
    key) stored in the card.

    When the relevant secret is attached to the MF, the command may be used to
    authenticate the card as a whole.

    When the relevant secret is attached to another DF, the command may be used
    to authenticate that DF.

Arguments:

    byAlgorithmRef [in, defaultvalue(NULL_BYTE)] Reference of the algorithm in
        the card.  If this value is zero, this indicates that no information is
        given.  The reference of the algorithm is known either before issuing
        the command or is provided in the data field.

    bySecretRef [in, defaultvalue(NULL_BYTE)] Reference of the secret:

        Meaning         8 7 6 5 4 3 2 1
        No Info         0 0 0 0 0 0 0 0
        Global ref      0 - - - - - - -
        Specific ref    1 - - - - - - -
        RFU             - x x - - - - -
        Secret          - - - x x x x x

        No Info = No information is given.

        Global ref = Global reference data (an MF specific key).

        Specific ref = Specific reference data (a DF specific key).

        RFU = 00 (other values are RFU).

        Secret = Number of the secret.

    pChallenge [in] Pointer to the authentication-related data (for example,
        challenge).

    lReplyBytes [in, defaultvalue(0)] Maximum number of bytes expected in
        response.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The successful execution of the command may be subject to successful
    completion of prior commands (for example, VERIFY or SELECT FILE) or
    selections (for example, the relevant secret).

    If a key and an algorithm are currently selected when issuing the command,
    then the command may implicitly use the key and the algorithm.

    The number of times the command is issued may be recorded in the card to
    limit the number of further attempts of using the relevant secret or the
    algorithm.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::InternalAuthenticate")

STDMETHODIMP
CSCardISO7816::InternalAuthenticate(
    /* [in] */ BYTE byAlgorithmRef,
    /* [in] */ BYTE bySecretRef,
    /* [in] */ LPBYTEBUFFER pChallenge,
    /* [in] */ LONG lReplyBytes,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,         // CLA
                            0x88,           // INS
                            byAlgorithmRef, // P1
                            bySecretRef,    // P2
                            pChallenge,
                            &lReplyBytes);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::ManageChannel:

    The ManageChannel method constructs an APDU command that opens and closes
    logical channels.

    The open function opens a new logical channel other than the basic one.
    Options are provided for the card to assign a logical channel number, or
    for the logical channel number to be supplied to the card.

    The close function explicitly closes a logical channel other than the basic
    one.  After the successful closing, the logical channel shall be available
    for re-use.

Arguments:

    byChannelState [in, defaultvalue(ISO_CLOSE_LOGICAL_CHANNEL)] Bit b8 of P1
        is used to indicate the open function or the close function; if b8 is 0
        then MANAGE CHANNEL shall open a logical channel and if b8 is 1 then
        MANAGE CHANNEL shall close a logical channel:

        P1 = '00' to open

        P1 = '80' to close

        Other values are RFU

    byChannel [in, defaultvalue(ISO_LOGICAL_CHANNEL_0)] For the open function
        (P1 = '00'), the bits b1 and b2 of P2 are used to code the logical
        channel number in the same manner as in the class byte, the other bits
        of P2 are RFU.  When b1 and b2 of P2 are NULL, then the card will
        assign a logical channel number that will be returned in bits b1 and
        b2 of the data field.

        When b1 and/or b2 of P2 are not NULL, they code a logical channel
        number other than the basic one; then the card will open the externally
        assigned logical channel number.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    When the open function is successfully performed from the basic logical
    channel, the MF shall be implicitly selected as the current DF and the
    security status of the new logical channel should be the same as the basic
    logical channel after ATR.  The security status of the new logical channel
    should be separate from that of any other logical channel.

    When the open function is successfully performed from a logical channel,
    which is not the basic one, the current DF of the logical channel that
    issued the command will be selected as the current DF.  In addition, the
    security status for the new logical channel should be the same as the
    security status of the logical channel from which the open function was
    performed.

    After a successful close function, the security status related to this
    logical channel is lost.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::ManageChannel")

STDMETHODIMP
CSCardISO7816::ManageChannel(
    /* [in] */ BYTE byChannelState,
    /* [in] */ BYTE byChannel,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;
        LONG lLe = 1;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,         // CLA
                            0x70,           // INS
                            byChannelState, // P1
                            byChannel,      // P2
                            NULL,
                            0 == (byChannelState | byChannel)
                            ? &lLe
                            : NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::PutData:

    The PutData method constructs an APDU command that stores a single
    primitive data object or the set of data objects contained in a constructed
    data object, depending on the file selected.

    How the objects are stored (writing once and/or updating and/or appending)
    depends on the definition or the nature of the data objects.

Arguments:

    byP1, byP2 [in] Coding of P1-P2:

        Value           Meaning
        0000 - 003F     RFU
        0040 - 00FF     BER-TLV tag (1 byte) in P2
        0100 - 01FF     Application data (proprietary coding)
        0200 - 02FF     SIMPLE-TLV tag in P2
        0300 - 03FF     RFU
        0400 - 04FF     BER-TLV tag (2 bytes) in P1-P2

    pData [in] Pointer to a byte buffer that contains the parameters and data to be
        written.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The command can be performed only if the security status satisfies the
    security conditions defined by the application within the context for the
    function.

    Store Application Data
        When the value of P1-P2 lies in the range from 0100 to 01FF, the value
        of P1-P2 shall be an identifier reserved for card internal tests and
        for proprietary services meaningful within a given application context.

    Store Data Objects
        When the value P1-P2 lies in the range from 0040 to 00FF, the value of
        P2 shall be a BER-TLV tag on a single byte.  The value of 00FF is
        reserved for indicating that the data field carries BER-TLV data
        objects.

        When the value of P1-P2 lies in the range 0200 to 02FF, the value of P2
        shall be a SIMPLE-TLV tag.  The value 0200 is RFU.  The value 02FF is
        reserved for indicating that the data field carries SIMPLE-TLV data
        objects.

        When the value of P1-P2 lies in the range from 4000 to FFFF, the value
        of P1-P2 shall be a BER-TLV tag on two bytes.  The values 4000 to FFFF
        are RFU.

        When a primitive data object is provided, the data field of the command
        message shall contain the value of the corresponding primitive data
        object.

        When a constructed data object is provided, the data field of the
        command message shall contain the value of the constructed data object
        (that is, data objects including their tag, length, and value).

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::PutData")

STDMETHODIMP
CSCardISO7816::PutData(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0xda,   // INS
                            byP1,   // P1
                            byP2,   // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::ReadBinary:

    The ReadBinary method constructs an APDU command that acquires a response
    message that gives that part of the contents of a transparent-structured
    elementary file.

Arguments:

    byP1, byP2 [in] The P1-P2 field, offset to the first byte to be read from
        the beginning of the file.

        If b8=1 in P1, then b7 and b6 of P1 are set to 0 (RFU bits), b5 to b1
        of P1 are a short EF identifier and P2 is the offset of the first byte
        to be read in data units from the beginning of the file.

        If b8=0 in P1, then P1||P2 is the offset of the first byte to be read
        in data units from the beginning of the file.

    lBytesToRead [in, defaultvalue(0)] Number of bytes to read from the
    transparent EF.  If the Le field contains only zeroes, then within the
    limit of 256 for short length or 65536 for extended length, all the bytes
    until the end of the file should be read.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being processed.

    When the command contains a valid short elementary identifier, it sets the
    file as current elementary file.

    Elementary files without a transparent structure cannot be erased.  The
    encapsulated command aborts if applied to an elementary file without a
    transparent structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::ReadBinary")

STDMETHODIMP
CSCardISO7816::ReadBinary(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LONG lBytesToRead,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0xb0,   // INS
                            byP1,   // P1
                            byP2,   // P2
                            NULL,
                            &lBytesToRead);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::ReadRecord:

    The ReadRecord method constructs an APDU command that reads either the
    contents of the specified record(s) or the beginning part of one record of
    an elementary file.

Arguments:

    byRecordId [in, defaultvalue(NULL_BYTE)] Record number or ID of the first
        record to be read (00 indicates the current record).

    byRefCtrl [in] Coding of the reference control:

        Meaning     8 7 6 5 4 3 2 1
        Current EF  0 0 0 0 0 - - -
        Short EF ID x x x x x - - -
        RFU         1 1 1 1 1 - - -
        Record      - - - - - 1 x x
        Read Record - - - - - 1 0 0
        Up to Last  - - - - - 1 0 1
        Up to P1    - - - - - 1 1 0
        RFU         - - - - - 1 1 1
        Record ID   - - - - - 0 x x
        First Occur - - - - - 0 0 0
        Last Occur  - - - - - 0 0 1
        Next Occur  - - - - - 0 1 0
        Previous    - - - - - 0 1 1
        Secret      - - - x x x x x

        Current EF = Currently selected EF.

        Short EF ID = Short EF identifier.

        Record # = Usage of record number in P1.

        Read Record = Read record P1.

        Up to Last = Read all records from P1 up to the last.

        Up to P1 = Read all records from the last up to P1.

        Record ID = Usage of record ID in P1.

        First Occur = Read first occurrence.

        Last Occur = Read last occurrence.

        Next Occur = Read next occurrence.

        Previous = Read previous occurrence.

    lBytesToRead [in, defaultvalue(0)] Number of bytes to read from the
        transparent EF.  If the Le field contains only zeroes, then depending
        on b3b2b1 of P2 and within the limit of 256 for short length or 65536
        for extended length, the command should read completely either the
        single requested record or the requested sequence of records.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being read.

    If another elementary file is currently selected at the time of issuing
    this command, it may be processed without identification of the currently
    selected file.

    When the command contains a valid short elementary identifier, it sets the
    file as current elementary file.

    Elementary files without a record structure cannot be read.  The
    encapsulated command aborts if applied to an elementary file without a
    record structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::ReadRecord")

STDMETHODIMP
CSCardISO7816::ReadRecord(
    /* [in] */ BYTE byRecordId,
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LONG lBytesToRead,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,     // CLA
                            0xb2,       // INS
                            byRecordId, // P1
                            byRefCtrl,  // P2
                            NULL,
                            &lBytesToRead);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::SelectFile:

    The SelectFile method constructs an APDU command that sets a current
    elementary file within a logical channel.  Subsequent commands may
    implicitly refer to the current file through the logical channel.

    Selecting a directory (DF) within the card filestore  which may be the
    root (MF) of the filestore  makes it the current DF.  After such a
    selection, an implicit current elementary file may be referred to through
    that logical channel.

    Selecting an elementary file sets the selected file and its parent as
    current files.

    After the answer to reset, the MF is implicitly selected through the basic
    logical channel, unless specified differently in the historical bytes or in
    the initial data string.

Arguments:

    byP1, byP2 [in] Selection control.

        P1 (upper byte in word):
            Meaning                 8 7 6 5 4 3 2 1
            Select File ID          0 0 0 0 0 0 x x
            EF, DF, or MF           0 0 0 0 0 0 0 0
            child DF                0 0 0 0 0 0 0 1
            EF under DF             0 0 0 0 0 0 1 0
            parent DF of current DF 0 0 0 0 0 0 1 1

            Select by DF Name       0 0 0 0 0 1 x x
            DFname                  0 0 0 0 0 1 0 0
            RFU                     0 0 0 0 0 1 0 1
            RFU                     0 0 0 0 0 1 1 0
            RFU                     0 0 0 0 0 1 1 1

            Select by path          0 0 0 0 1 0 x x
            from MF                 0 0 0 0 1 0 0 0
            current DF              0 0 0 0 1 0 0 1
            RFU                     0 0 0 0 1 0 1 0
            RFU                     0 0 0 0 1 0 1 1

            When P1=00, the card knows either because of a specific coding of
            the file ID or because of the context of execution of the command
            if the file to select is the MF, a DF, or an EF.

            When P1-P2=0000, if a file ID is provided, then it shall be unique
            in the following environments:

                the immediate children of the current DF
                the parent DF
                the immediate children of the parent DF

            If P1-P2=0000 and if the data field is empty or equal to 3F00, then
            select the MF.

            When P1=04, the data field is a DF name, possibly right truncated.

            When supported, successive such commands with the same data field
            shall select DFs whose names match with the data field (that is,
            start with the command data field).  If the card accepts the
            command with an empty data field, then all or a subset of the DFs
            can be successively selected.

        P2 (lower byte of word):
            Meaning         8 7 6 5 4 3 2 1
            First occur     0 0 0 0 - - 0 0
            Last occur      0 0 0 0 - - 0 1
            Next occur      0 0 0 0 - - 1 0
            Previous occur  0 0 0 0 - - 1 1

            File Control    0 0 0 0 x x - -
            Return FCI      0 0 0 0 0 0 - -
            Return FCP      0 0 0 0 0 1 - -
            Return FMD      0 0 0 0 1 0 - -

    pData [in, defaultvalue(NULL)] Data for operation if needed; else, NULL.
        Types of data that are passed in this parameter include:

        file ID
        path from the MF
        path from the current DF
        DF name

    lBytesToRead [in, defaultvalue(0)] Empty (that is, 0) or maximum length of
        data expected in response.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    Unless otherwise specified, the correct execution of the encapsulated
    command modifies the security status according to the following rules:

    *   When the current elementary file is changed, or when there is no
        current elementary file, the security status specific to a former
        current elementary file is lost.

    *   When the current filestore directory (DF) is descendant of, or
        identical to the former current DF, the security status specific to the
        former current DF is lost.  The security status common to all common
        ancestors of the previous and new current DF is maintained.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::SelectFile")

STDMETHODIMP
CSCardISO7816::SelectFile(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [in] */ LONG lBytesToRead,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0xa4,   // INS
                            byP1,   // P1
                            byP2,   // P2
                            pData,
                            0 == lBytesToRead ? NULL : &lBytesToRead);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::SetDefaultClassId:

    The SetDefaultClassId method assigns a standard class identifier byte that
    will be used in all operations when constructing an ISO 7816-4 command
    APDU.  By default, the standard class identifier byte is 0x00.

Arguments:

    byClass [in] Class ID byte.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::SetDefaultClassId")

STDMETHODIMP
CSCardISO7816::SetDefaultClassId(
    /* [in] */ BYTE byClass)
{
    m_bCla = byClass;
    return S_OK;
}


/*++

CSCardISO7816::UpdateBinary:

    The UpdateBinary method constructs an APDU command that updates the bits
    present in an elementary file with the bits given in the APDU command.

Arguments:

    byP1, byP2 [in] Offset to the write (update) location into the binary from
        the start of the binary.

        If b8=1 in P1, then b7 and b6 of P1 are set to 0 (RFU bits), b5 to b1
        of P1 are a short EF identifier and P2 is the offset of the first byte
        to be updated in data units from the beginning of the file.

        If b8=0 in P1, then P1 || P2 is the offset of the first byte to be
        updated in data units from the beginning of the file.

    pData [in] Pointer to the string of data units to be updated.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being processed.

    When the command contains a valid short elementary identifier, it sets the
    file as current elementary file.

    Elementary files without a transparent structure cannot be erased.  The
    encapsulated command aborts if applied to an elementary file without a
    transparent structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::UpdateBinary")

STDMETHODIMP
CSCardISO7816::UpdateBinary(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0xd6,   // INS
                            byP1,   // P1
                            byP2,   // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::UpdateRecord:

    The UpdateRecord method constructs an APDU command that updates a specific
    record with the bits given in the APDU command.

    Note    When using current record addressing, the command sets the record
            pointer on the successfully updated record.

Arguments:

    byRecordId [in, defaultvalue(NULL_BYTE)] P1 value:

        P1 = 00 designates the current record
        P1 != '00' is the number of the specified record

    byRefCtrl [in, defaultvalue(NULL_BYTE)] Coding of the reference control P2:

        Meaning         8 7 6 5 4 3 2 1
        Current EF      0 0 0 0 0 - - -
        Short EF ID     x x x x x - - -
        First Record    - - - - - 0 0 0
        Last Record     - - - - - 0 0 1
        Next Record     - - - - - 0 1 0
        Previous Record - - - - - 0 1 1
        Record # in P1  - - - - - 1 0 0

    pData [in] Pointer to the record to be updated.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being processed.

    When the command contains a valid short elementary identifier, it sets the
    file as current elementary file.  If another elementary file is currently
    selected at the time of issuing this command, this command may be processed
    without identification of the currently selected file.

    If the constructed command applies to a linear-fixed or cyclic-structured
    elementary file, it will abort if the record length is different from the
    length of the existing record.

    If the command applies to a linear-variable structured elementary file, it
    may be carried out when the record length is different from the length of
    the existing record.

    The "previous" option of the command (P2=xxxxx011), applied to a cyclic
    file, has the same behavior as a command constructed by AppendRecord.

    Elementary files without a record structure cannot be read.  The
    constructed command aborts if applied to an elementary file without record
    structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::UpdateRecord")

STDMETHODIMP
CSCardISO7816::UpdateRecord(
    /* [in] */ BYTE byRecordId,
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,     // CLA
                            0xdc,       // INS
                            byRecordId, // P1
                            byRefCtrl,  // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::Verify:

    The Verify method constructs an APDU command that initiates the comparison
    (in the card) of the verification data sent from the interface device with
    the reference data stored in the card (for example, password).

Arguments:

    byRefCtrl [in, defaultvalue(NULL_BYTE)] Quantifier of the reference data;
        coding of the reference control P2:

        Meaning         8 7 6 5 4 3 2 1
        No Info         0 0 0 0 0 0 0 0
        Global Ref      0 - - - - - - -
        Specific Ref    1 - - - - - - -
        RFU             - x x - - - - -
        Ref Data #      - - - x x x x x

        An example of Global Ref would be a password.

        An example of Specific Ref is DF specific password.

        P2=00 is reserved to indicate that no particular qualifier is used in
        those cards where the verify command references the secret data
        unambiguously.

        The reference data number may be for example a password number or a
        short EF identifier.

        When the body is empty, the command may be used either to retrieve the
        number 'X' of further allowed retries (SW1-SW2=63CX) or to check
        whether the verification is not required (SW1-SW2=9000).

    pData [in, defaultvalue(NULL)] Pointer to the verification data, or can be
        NULL.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation. If ppCmd was set to NULL, a smart card ISCardCmd object
        is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The security status may be modified as a result of a comparison.
    Unsuccessful comparisons may be recorded in the card (for example, to limit
    the number of further attempts of the use of the reference data).

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::Verify")

STDMETHODIMP
CSCardISO7816::Verify(
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,     // CLA
                            0x20,       // INS
                            0x00,       // P1
                            byRefCtrl,  // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::WriteBinary:

    The WriteBinary method constructs an APDU command that writes binary values
    into an elementary file.

    Depending upon the file attributes, the command performs one of the
    following operations:

    *   The logical OR of the bits already present in the card with the bits
        given in the command APDU (logical erased state of the bits of the file
        is 0).

    *   The logical AND of the bits already present in the card with the bits
        given in the command APDU (logical erased state of the bits of the file
        is 1).

    *   The one-time write in the card of the bits given in the command APDU.

    When no indication is given in the data coding byte, the logical OR
    behavior applies.

Arguments:

    byP1, byP2 [in] Offset to the write location from the beginning of the
        binary file (EF).

        If b8=1 in P1, then b7 and b6 of P1 are set to 0 (RFU bits), b5 to b1
        of P1 are a short EF identifier and P2 is the offset of the first byte
        to be written in data units from the beginning of the file.

        If b8=0 in P1, then P1||P2 is the offset of the first byte to be
        written in data units from the beginning of the file.

    pData [in] Pointer to the string of data units to be written.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being processed.

    When the command contains a valid short elementary identifier, it sets the
    file as current elementary file.

    Once a write binary operation has been applied to a data unit of a one-time
    write EF, any further write operation referring to this data unit will be
    aborted if the content of the data unit or the logical erased state
    indicator (if any) attached to this data unit is different from the logical
    erased state.

    Elementary files without a transparent structure cannot be written to.  The
    encapsulated command aborts if applied to an elementary file without a
    transparent structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::WriteBinary")

STDMETHODIMP
CSCardISO7816::WriteBinary(
    /* [in] */ BYTE byP1,
    /* [in] */ BYTE byP2,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla, // CLA
                            0xd0,   // INS
                            byP1,   // P1
                            byP2,   // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardISO7816::WriteRecord:

    The WriteRecord method constructs an APDU command that initiates one of the
    following operations:

    *   The write once of a record.

    *   The logical OR of the data bytes of a record already present in the
        card with the data bytes of the record given in the command APDU.

    *   The logical AND of the data bytes of a record already present in the
        card with the data bytes of the record given in the command APDU.

    When no indication is given in the data coding byte, the logical OR behavior applies.

    Note:  When using current record addressing, the command sets the record
    pointer on the successfully updated record.

Arguments:

    byRecordId [in, defaultvalue(NULL_BYTE)] Record identification. This is the
        P1 value:

        P1 = '00' designates the current record.

        P1 != '00' is the number of the specified record.

    byRefCtrl [in, defaultvalue(NULL_BYTE)] Coding of the reference control P2:

        Meaning         8 7 6 5 4 3 2 1
        Current EF      0 0 0 0 0 - - -
        Short EF ID     x x x x x - - -
        First Record    - - - - - 0 0 0
        Last Record     - - - - - 0 0 1
        Next Record     - - - - - 0 1 0
        Previous Record - - - - - 0 1 1
        Record # in P1  - - - - - 1 0 0

    pData [in] Pointer to the record to be written.

    ppCmd [in, out] On input, a pointer to an ISCardCmd interface object or
        NULL.  On return, it is filled with the APDU command constructed by
        this operation.  If ppCmd was set to NULL, a smart card ISCardCmd
        object is internally created and returned via the ppCmd pointer.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The encapsulated command can only be performed if the security status of
    the smart card satisfies the security attributes of the elementary file
    being processed.

    When the command contains a valid short elementary identifier, it sets the
    file as current elementary file.  If another elementary file is currently
    selected at the time of issuing this command, this command may be processed
    without identification of the currently selected file.

    If the encapsulated command applies to a linear-fixed or cyclic-structured
    elementary file, it will abort if the record length is different from the
    length of the existing record.  If it applies to a linear-variable
    structured elementary file, it may be carried out when the record length is
    different from the length of the existing record.

    If P2=xxxxx011 and the elementary file is cyclic file, this command has the
    same behavior a command constructed using AppendRecord.

    Elementary files without a record structure cannot be written to.  The
    constructed command aborts if applied to an elementary file without a
    record structure.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardISO7816::WriteRecord")

STDMETHODIMP
CSCardISO7816::WriteRecord(
    /* [in] */ BYTE byRecordId,
    /* [in] */ BYTE byRefCtrl,
    /* [in] */ LPBYTEBUFFER pData,
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn;

    try
    {
        HRESULT hr;

        if (NULL == *ppCmd)
        {
            *ppCmd = NewSCardCmd();
            if (NULL == *ppCmd)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        hr = (*ppCmd)->BuildCmd(
                            m_bCla,     // CLA
                            0xd2,       // INS
                            byRecordId, // P1
                            byRefCtrl,  // P2
                            pData,
                            NULL);
        hReturn = hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\locate.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    Locate

Abstract:

    The ISCardeLocate interface provides services for locating a smart card by
    its name.

    This interface can display the smart card user interface if it is required.

    The following example shows a typical use of the ISCardLocate interface.
    The ISCardLocate interface is used to build the an ADPU.

    To locate a specific card using its name

    1)  Create an ISCardLocate interface.
    2)  Call ConfigureCardNameSearch to search for a smart card name.
    3)  Call FindCard to search for the smart card.
    4)  Interpret the results.
    5)  Release the ISCardLocate interface.

Author:

    Doug Barlow (dbarlow) 6/24/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "stdafx.h"
#include "Conversion.h"
#include "Locate.h"

/////////////////////////////////////////////////////////////////////////////
// CSCardLocate

#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardLocate::ConfigureCardGuidSearch")

STDMETHODIMP
CSCardLocate::ConfigureCardGuidSearch(
    /* [in] */ LPSAFEARRAY pCardGuids,
    /* [defaultvalue][in] */ LPSAFEARRAY pGroupNames,
    /* [defaultvalue][in] */ BSTR bstrTitle,
    /* [defaultvalue][in] */ LONG lFlags)
{
    HRESULT hReturn = S_OK;

    try
    {
        // TODO: Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardLocate::ConfigureCardNameSearch:

    The ConfigureCardNameSearch method specifies the card names to be used in
    the search for the smart card.

Arguments:

    pCardNames [in] Pointer to an OLE Automation safe array of card names in
        BSTR form.

    pGroupNames [in, defaultvalue(NULL )] Pointer to an OLE Automation safe
        array of names of card/reader groups in BSTR form to add to the search.

    bstrTitle [in, defaultvalue("")] Search common control dialog title.

    lFlags [in, defaultvalue(1)] Specifies when user interface is displayed:

    Flag                Meaning
    SC_DLG_MINIMAL_UI   Displays the dialog only if the card being searched for
                        by the calling application is not located and available
                        for use in a reader.  This allows the card to be found,
                        connected (either through internal dialog mechanism or
                        the user callback functions), and returned to the
                        calling application.
    SC_DLG_NO_UI        Causes no UI display, regardless of the search outcome.
    SC_DLG_FORCE_UI     Causes UI display regardless of the search outcome.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardLocate::ConfigureCardNameSearch")

STDMETHODIMP
CSCardLocate::ConfigureCardNameSearch(
    /* [in] */ LPSAFEARRAY pCardNames,
    /* [defaultvalue][in] */ LPSAFEARRAY pGroupNames,
    /* [defaultvalue][in] */ BSTR bstrTitle,
    /* [defaultvalue][in] */ LONG lFlags)
{
    HRESULT hReturn = S_OK;

    try
    {
        if (NULL != pCardNames)
            SafeArrayToMultiString(pCardNames, m_mtzCardNames);
        if (NULL != pGroupNames)
            SafeArrayToMultiString(pGroupNames, m_mtzGroupNames);
        if (NULL != bstrTitle)
            m_tzTitle = bstrTitle;
        m_lFlags = lFlags;
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardLocate::FindCard:

    The FindCard method searches for the smart card and opens a valid
    connection to it.

Arguments:

    ShareMode [in, defaultvalue(EXCLUSIVE)] Mode in which to share or not share
        the smart card when a connection is opened to it.

        Values      Description
        EXCLUSIVE   No one else use this connection to the smart card.
        SHARED      Other applications can use this connection.

    Protocols [in, defaultvalue(T0)] Protocol to use when connecting to the
        card.

        T0
        T1
        Raw
        T0|T1

    lFlags [in, defaultvalue(SC_DLG_NO_UI)] Specifies when user interface is
        displayed:

        Flag                Meaning
        SC_DLG_MINIMAL_UI   Displays the dialog only if the card being searched
                            for by the calling application is not located and
                            available for use in a reader.  This allows the
                            card to be found, connected (either through
                            internal dialog mechanism or the user callback
                            functions), and returned to the calling
                            application.
        SC_DLG_NO_UI        Causes no UI display, regardless of the search
                            outcome.
        SC_DLG_FORCE_UI     Causes UI display regardless of the search outcome.

    ppCardInfo [out, retval] Pointer to a data structure that contains/returns
        information about the opened smart card, if successful.  Will be NULL
        if operation has failed.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    To set the search criteria of the search, call ConfigureCardNameSearch to
    specify a smart card's card names or call ConfigureCardGuidSearch to
    specify a smart card's interfaces.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardLocate::FindCard")

STDMETHODIMP
CSCardLocate::FindCard(
    /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
    /* [defaultvalue][in] */ SCARD_PROTOCOLS Protocols,
    /* [defaultvalue][in] */ LONG lFlags,
    /* [retval][out] */ LPSCARDINFO __RPC_FAR *ppCardInfo)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;
        OPENCARDNAME cardInfo;

        ZeroMemory(&cardInfo, sizeof(cardInfo));
        cardInfo.dwShareMode = ShareMode;
        cardInfo.dwPreferredProtocols = Protocols;
        cardInfo.dwFlags = lFlags | m_lFlags;

        if ((NULL != ppCardInfo) && (NULL != *ppCardInfo))
        {
            if (NULL != (*ppCardInfo)->hContext)
                cardInfo.hSCardContext = (*ppCardInfo)->hContext;
            cardInfo.dwPreferredProtocols = (*ppCardInfo)->ActiveProtocol;
            cardInfo.dwShareMode = (*ppCardInfo)->ShareMode;
            cardInfo.hwndOwner = (HWND)(*ppCardInfo)->hwndOwner;
            cardInfo.lpfnConnect = (LPOCNCONNPROC)(*ppCardInfo)->lpfnConnectProc;
            cardInfo.lpfnCheck = (LPOCNCHKPROC)(*ppCardInfo)->lpfnCheckProc;
            cardInfo.lpfnDisconnect = (LPOCNDSCPROC)(*ppCardInfo)->lpfnDisconnectProc;
        }

        if (0 == cardInfo.dwPreferredProtocols)
            cardInfo.dwPreferredProtocols = SCARD_PROTOCOL_Tx;
        if (0 == cardInfo.dwShareMode)
            cardInfo.dwShareMode = SCARD_SHARE_EXCLUSIVE;

        cardInfo.dwStructSize = sizeof(OPENCARDNAME);
        cardInfo.lpstrGroupNames = (LPTSTR)((LPCTSTR)m_mtzGroupNames);
        cardInfo.nMaxGroupNames = m_mtzGroupNames.Length();
        cardInfo.lpstrCardNames = (LPTSTR)((LPCTSTR)m_mtzCardNames);
        cardInfo.nMaxCardNames = m_mtzCardNames.Length();
        cardInfo.rgguidInterfaces = (LPCGUID)m_bfInterfaces.Access();
        cardInfo.cguidInterfaces = m_bfInterfaces.Length();
        cardInfo.lpstrRdr = (LPTSTR)m_bfRdr.Access();
        cardInfo.nMaxRdr = m_bfRdr.Space() / sizeof(TCHAR);
        cardInfo.lpstrCard = (LPTSTR)m_bfCard.Access();
        cardInfo.nMaxCard = m_bfCard.Space() / sizeof(TCHAR);
        cardInfo.lpstrTitle = (LPCTSTR)m_tzTitle;

        lSts = GetOpenCardName(&cardInfo);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);

        m_bfRdr.Resize(cardInfo.nMaxRdr * sizeof(TCHAR), TRUE);
        m_bfCard.Resize(cardInfo.nMaxCard * sizeof(TCHAR), TRUE);

        if (NULL != ppCardInfo)
        {
            if (NULL == *ppCardInfo)
            {
                *ppCardInfo = &m_subCardInfo;
                (*ppCardInfo)->ShareMode = (SCARD_SHARE_MODES)cardInfo.dwShareMode;
            }

            if (NULL == cardInfo.hCardHandle)
            {
                lSts = SCardConnect(
                            cardInfo.hSCardContext,
                            cardInfo.lpstrRdr,
                            cardInfo.dwShareMode,
                            cardInfo.dwPreferredProtocols,
                            &cardInfo.hCardHandle,
                            &cardInfo.dwActiveProtocol);
                if (SCARD_S_SUCCESS != lSts)
                    throw (HRESULT)HRESULT_FROM_WIN32(lSts);
            }
            (*ppCardInfo)->hCard = cardInfo.hCardHandle;
            (*ppCardInfo)->hContext = cardInfo.hSCardContext;
            (*ppCardInfo)->ActiveProtocol = (SCARD_PROTOCOLS)cardInfo.dwActiveProtocol;
        }
    }

    catch (DWORD dwError)
    {
        hReturn = HRESULT_FROM_WIN32(dwError);
    }
    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\dlldatax.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dlldatax.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_DLLDATAX_H__9AEC1AFF_19F1_11D3_A11F_00C04F79F800__INCLUDED_)
#define AFX_DLLDATAX_H__9AEC1AFF_19F1_11D3_A11F_00C04F79F800__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__9AEC1AFF_19F1_11D3_A11F_00C04F79F800__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\proto_t1.cpp ===
/*++

Copyright (C) Microsoft Corporation 1999

Module Name:

    Proto_T1

Abstract:

    This module provides the mapping from an APDU to a T=1 TPDU.

Author:

    Doug Barlow (dbarlow) 6/28/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "stdafx.h"
#include "Conversion.h"

static DWORD l_dwDefaultIOMax = 0;


/*++

ApduToTpdu_T1:

    This routine takes an APDU, converts it to a T=1 TPDU, and performs the
    exchange to the specified card.

Arguments:

    hCard supplies a handle to the card to be used in the exchange.

    pbPciRqst supplies the PCI Request structure
    
    cbPciRqst supplies the length of pbPciRqst, in bytes
    
    pbApdu supplies the APDU to be sent to the card.
    
    cbApdu supplies the length of the APDU in pbApdu.

    dwFlags supplies any special flags used to modify the operation.

    bfPciRsp receives the response PCI.

    bfReply receives the response from the card.

Return Value:

    None

Throws:

    Errors are thrown as HRESULT status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/28/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("ApduToTpdu_T1")

void
ApduToTpdu_T1(
    IN SCARDHANDLE hCard,
    IN const SCARD_IO_REQUEST *pPciRqst,
    IN LPCBYTE pbApdu,
    IN DWORD cbApdu,
    IN DWORD dwFlags,
    OUT CBuffer bfPciRsp,
    OUT CBuffer &bfReply)
{
    LONG lSts;
    DWORD dwLen, dwXmitFlags;
    WORD wLe;


    //
    // Figure out how big the receive buffers should be.
    //

    bfPciRsp.Set((LPCBYTE)pPciRqst, pPciRqst->cbPciLength);
    ParseRequest(
        pbApdu, 
        cbApdu, 
        NULL, 
        NULL, 
        NULL, 
        NULL, 
        NULL, 
        NULL, 
        &wLe, 
        &dwXmitFlags);
    if ((0 == wLe) && (0 != (dwXmitFlags & APDU_MAXIMUM_LE)))
    {
        if (0 == l_dwDefaultIOMax)
        {
            try
            {
                CRegistry regCalais(
                    HKEY_LOCAL_MACHINE,
                    TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais"),
                    KEY_READ);
            
                l_dwDefaultIOMax = regCalais.GetNumericValue(
                    TEXT("MaxDefaultBuffer"));
            }
            catch (...) 
            {
                l_dwDefaultIOMax = 264;
            }
        }
        wLe = (WORD)l_dwDefaultIOMax;
    }
    bfReply.Presize(wLe + 2);


    //
    // Perform the I/O
    
    dwLen = bfReply.Space();
    lSts = SCardTransmit(
                hCard,
                pPciRqst,
                pbApdu,
                cbApdu,
                (LPSCARD_IO_REQUEST)bfPciRsp.Access(),
                bfReply.Access(),
                &dwLen);
    if (SCARD_S_SUCCESS != lSts)
        throw (HRESULT)HRESULT_FROM_WIN32(lSts);
    bfReply.Resize(dwLen, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\proto_t0.cpp ===
/*++

Copyright (C) Microsoft Corporation 1999

Module Name:

    Proto_T0

Abstract:

    This module provides the mapping from an APDU to a T=0 TPDU.

Author:

    Doug Barlow (dbarlow) 6/28/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "stdafx.h"
#include "Conversion.h"


/*++

ApduToTpdu_T0:

    This routine takes an APDU, converts it to a T=0 TPDU, and performs the
    exchange to the specified card.

Arguments:

    hCard supplies a handle to the card to be used in the exchange.

    pbPciRqst supplies the PCI Request structure

    cbPciRqst supplies the length of pbPciRqst, in bytes

    pbApdu supplies the APDU to be sent to the card.

    cbApdu supplies the length of the APDU in pbApdu.

    dwFlags supplies any special flags used to modify the operation.

    bfPciRsp receives the response PCI.

    bfReply receives the response from the card.

Return Value:

    None

Throws:

    Errors are thrown as HRESULT status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/28/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("ApduToTpdu_T0")

void
ApduToTpdu_T0(
    IN SCARDHANDLE hCard,
    IN const SCARD_IO_REQUEST *pPciRqst,
    IN LPCBYTE pbApdu,
    IN DWORD cbApdu,
    IN DWORD dwFlags,
    OUT CBuffer bfPciRsp,
    OUT CBuffer &bfReply,
    IN LPCBYTE pbAltCla)
{
    LONG lSts;
    DWORD dwLen, dwXmitFlags;
    WORD wLen, wLc, wLe, wSts;
    CBuffer bfXmit(264), bfRecv(264);
    BYTE rgb[4];
    BYTE b;
    LPCBYTE pbData;


    //
    // Prepare for conversion.
    //

    bfReply.Reset();
    bfPciRsp.Set((LPCBYTE)pPciRqst, pPciRqst->cbPciLength);
    ParseRequest(
        pbApdu,
        cbApdu,
        NULL,
        NULL,
        NULL,
        NULL,
        &pbData,
        &wLc,
        &wLe,
        &dwXmitFlags);


    //
    // Send the data.
    //

    if (0 == wLc)
    {

        //
        // Le goes into P3
        //

        bfXmit.Set(pbApdu, 4); // CLA, INS, P1, P2
        if (0 == (dwXmitFlags & APDU_MAXIMUM_LE))
            wLen = __min(255, wLe);
        else
            wLen = 0;
        b = LeastSignificantByte(wLen);
        bfXmit.Append(&b, 1);

        dwLen = bfRecv.Space();
        lSts = SCardTransmit(
                    hCard,
                    pPciRqst,
                    bfXmit.Access(),
                    bfXmit.Length(),
                    (LPSCARD_IO_REQUEST)bfPciRsp.Access(),
                    bfRecv.Access(),
                    &dwLen);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        bfRecv.Resize(dwLen, TRUE);
        if (2 > dwLen)
        {
            bfReply.Set(bfRecv.Access(), bfRecv.Length());
            goto EndProtocol;
        }
        ASSERT(0x10000 > dwLen);
        wLe -= (WORD)(dwLen - 2);
        wSts = NetToLocal(bfRecv.Access(dwLen - 2));
    }
    else if (256 > wLc)
    {

        //
        // Send the data in the short form.
        //

        bfXmit.Set(pbApdu, 4); // CLA, INS, P1, P2
        b = LeastSignificantByte(wLc);
        bfXmit.Append(&b, 1);
        bfXmit.Append(pbData, wLc);

        dwLen = bfRecv.Space();
        lSts = SCardTransmit(
                    hCard,
                    pPciRqst,
                    bfXmit.Access(),
                    bfXmit.Length(),
                    (LPSCARD_IO_REQUEST)bfPciRsp.Access(),
                    bfRecv.Access(),
                    &dwLen);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        bfRecv.Resize(dwLen, TRUE);
        if (2 > dwLen)
        {
            bfReply.Set(bfRecv.Access(), bfRecv.Length());
            goto EndProtocol;
        }
        wSts = NetToLocal(bfRecv.Access(dwLen - 2));
    }
    else
    {
        WORD wSent;


        //
        // Send the data in the enveloped form.
        //

        rgb[0] = (NULL != pbAltCla) ? *pbAltCla : *pbApdu;  // CLA
        rgb[1] = 0xc2;      // envelope INS
        rgb[2] = 0;         // P1
        rgb[3] = 0;         // P2
        wSent = 0;
        while (wLc > wSent)
        {
            wLen = __min(255, wLc - wSent);
            bfXmit.Set(rgb, 4);
            bfXmit.Append(&pbData[wSent], wLen);
            b = LeastSignificantByte(wLen);
            bfXmit.Append(&b, 1);
            wSent -= wLen;

            dwLen = bfRecv.Space();
            lSts = SCardTransmit(
                        hCard,
                        pPciRqst,
                        bfXmit.Access(),
                        bfXmit.Length(),
                        (LPSCARD_IO_REQUEST)bfPciRsp.Access(),
                        bfRecv.Access(),
                        &dwLen);
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
            bfRecv.Resize(dwLen, TRUE);
            if (2 != dwLen)
            {
                bfReply.Set(bfRecv.Access(), bfRecv.Length());
                goto EndProtocol;
            }
            wSts = NetToLocal(bfRecv.Access());
            if ((wSent < wLc) && (0x9000 != wSts))
            {
                bfReply.Set(bfRecv.Access(), bfRecv.Length());
                goto EndProtocol;
            }
        }
    }


    //
    // At this point, the first received buffer is in bfRecv.  What do we
    // have to do to bring in any more data?
    //

    rgb[0] = (NULL != pbAltCla) ? *pbAltCla : *pbApdu;  // CLA
    rgb[1] = 0xc0;      // Get Response INS
    rgb[2] = 0;         // P1
    rgb[3] = 0;         // P2

    for (;;)
    {
        ASSERT(2 <= bfRecv.Length());
        BYTE bSw1 = *bfRecv.Access(bfRecv.Length() - 2);
        BYTE bSw2 = *bfRecv.Access(bfRecv.Length() - 1);

        switch (bSw1)
        {
        case 0x6c:  // Wrong length
            wLe = bSw2;
            break;
        case 0x61:  // More data
            bfReply.Append(bfRecv.Access(), bfRecv.Length() - 2);
            if (0 == wLe)
                wLe = bSw2;
            else
                wLe = __min(wLe, bSw2);
            break;
        case 0x90:  // Success?
            if (((0 == wLe) && (0 == (APDU_MAXIMUM_LE & dwFlags)))
                || (0x00 != bSw2))
            {
                bfReply.Append(bfRecv.Access(), bfRecv.Length());
                goto EndProtocol;
            }
            if (2 < bfRecv.Length())    // Shouldn't be
                bfReply.Append(bfRecv.Access(), bfRecv.Length() - 2);
            break;
        default:    // We're done.
            bfReply.Append(bfRecv.Access(), bfRecv.Length());
            goto EndProtocol;
        }


        //
        // We need to request additional data.
        //

        bfXmit.Set(rgb, 4);
        b = LeastSignificantByte(wLe);
        bfXmit.Append(&b, 1);
        dwLen = bfRecv.Space();
        lSts = SCardTransmit(
                    hCard,
                    pPciRqst,
                    bfXmit.Access(),
                    bfXmit.Length(),
                    (LPSCARD_IO_REQUEST)bfPciRsp.Access(),
                    bfRecv.Access(),
                    &dwLen);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        bfRecv.Resize(dwLen, TRUE);
        wLe -= b;
    }


EndProtocol:

    //
    // We've completed the protocol exchange.  The data is ready to be
    // returned to the caller.
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scardssp.rc
//
#define IDS_PROJNAME                    100
#define IDR_BYTEBUFFER                  101
#define IDR_SCARDTYPECONV               102
#define IDR_SCARDCMD                    103
#define IDR_SCARDISO7816                104
#define IDR_SCARD                       105
#define IDR_SCARDDATABASE               106
#define IDR_SCARDLOCATE                 107

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\scard.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       SCard.h
//
//--------------------------------------------------------------------------

// SCard.h : Declaration of the CSCard

#ifndef __SCARD_H_
#define __SCARD_H_

#include "resource.h"       // main symbols
#include <winscard.h>

/////////////////////////////////////////////////////////////////////////////
// CSCard
class ATL_NO_VTABLE CSCard :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSCard, &CLSID_CSCard>,
    public IDispatchImpl<ISCard, &IID_ISCard, &LIBID_SCARDSSPLib>
{
public:
    CSCard()
    {
        m_pUnkMarshaler = NULL;
        m_hContext = NULL;
        m_hMyContext = NULL;
        m_hCard = NULL;
        m_hMyCard = NULL;
        m_dwProtocol = 0;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SCARD)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSCard)
    COM_INTERFACE_ENTRY(ISCard)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        if (NULL != m_hMyCard)
            SCardDisconnect(m_hMyCard, SCARD_RESET_CARD);
        if (NULL != m_hMyContext)
            SCardReleaseContext(m_hMyContext);
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

protected:
    SCARDCONTEXT m_hContext;
    SCARDCONTEXT m_hMyContext;
    SCARDHANDLE m_hCard;
    SCARDHANDLE m_hMyCard;
    DWORD m_dwProtocol;

    SCARDCONTEXT Context(void)
    {
        LONG lSts;

        if (NULL == m_hContext)
        {
            ASSERT(NULL == m_hMyContext);
            lSts = SCardEstablishContext(
                        SCARD_SCOPE_USER,
                        NULL,
                        NULL,
                        &m_hMyContext);
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
            m_hContext = m_hMyContext;
        }
        return m_hContext;
    }


// ISCard
public:
    STDMETHOD(get_Atr)(
        /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppAtr);

    STDMETHOD(get_CardHandle)(
        /* [retval][out] */ HSCARD __RPC_FAR *pHandle);

    STDMETHOD(get_Context)(
        /* [retval][out] */ HSCARDCONTEXT __RPC_FAR *pContext);

    STDMETHOD(get_Protocol)(
        /* [retval][out] */ SCARD_PROTOCOLS __RPC_FAR *pProtocol);

    STDMETHOD(get_Status)(
        /* [retval][out] */ SCARD_STATES __RPC_FAR *pStatus);

    STDMETHOD(AttachByHandle)(
        /* [in] */ HSCARD hCard);

    STDMETHOD(AttachByReader)(
        /* [in] */ BSTR bstrReaderName,
        /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode = EXCLUSIVE,
        /* [defaultvalue][in] */ SCARD_PROTOCOLS PrefProtocol = T0);

    STDMETHOD(Detach)(
        /* [defaultvalue][in] */ SCARD_DISPOSITIONS Disposition = LEAVE);

    STDMETHOD(LockSCard)(
            void);

    STDMETHOD(ReAttach)(
        /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode = EXCLUSIVE,
        /* [defaultvalue][in] */ SCARD_DISPOSITIONS InitState = LEAVE);

    STDMETHOD(Transaction)(
        /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd);

    STDMETHOD(UnlockSCard)(
        /* [defaultvalue][in] */ SCARD_DISPOSITIONS Disposition = LEAVE);
};

inline CSCard *
NewSCard(
    void)
{
    return (CSCard *)NewObject(CLSID_CSCard, IID_ISCard);
}

#endif //__SCARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\scard.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    SCard

Abstract:

    The ISCard interface lets you open and manage a connection to a smart card.
    Each connection to a card requires a single, corresponding instance of the
    ISCard interface.

    The smart card resource manager must be available whenever an instance of
    ISCard is created.  If this service is unavailable, creation of the
    interface will fail.

    The following example shows a typical use of the ISCard interface.  The
    ISCard interface is used to connect to the smart card, submit a
    transaction, and release the smart card.

    To submit a transaction to a specific card

    1)  Create an ISCard interface.
    2)  Attach to a smart card by specifying a smart card reader or by using a
        previously established, valid handle.
    3)  Create transaction commands with ISCardCmd, and ISCardISO7816 smart
        card interfaces.
    4)  Use ISCard to submit the transaction commands for processing by the
        smart card.
    5)  Use ISCard to release the smart card.
    6)  Release the ISCard interface.

Author:

    Doug Barlow (dbarlow) 6/24/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "stdafx.h"
#include "ByteBuffer.h"
#include "SCard.h"
#include "Conversion.h"

/////////////////////////////////////////////////////////////////////////////
// CSCard

/*++

CSCard::get_Atr:

    The get_Atr method retrieves an ATR string of the smart card.

Arguments:

    ppAtr [out, retval] Pointer to a byte buffer in the form of an IStream that
        will contain the ATR string on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::get_Atr")

STDMETHODIMP
CSCard::get_Atr(
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppAtr)
{
    HRESULT hReturn = S_OK;
    CByteBuffer *pMyBuffer = NULL;

    try
    {
        CBuffer bfAtr(36);
        LONG lSts;
        DWORD dwLen = 0;

        if (NULL == *ppAtr)
        {
            *ppAtr = pMyBuffer = NewByteBuffer();
            if (NULL == pMyBuffer)
                throw (HRESULT)E_OUTOFMEMORY;
        }
        if (NULL != m_hCard)
        {
            dwLen = bfAtr.Space();
            lSts = SCardStatus(
                m_hCard,
                NULL, 0, // Reader name
                NULL,    // State
                NULL,    // Protocol
                bfAtr.Access(),
                &dwLen);
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
            bfAtr.Resize(dwLen);
        }
        BufferToByteBuffer(bfAtr, ppAtr);
        pMyBuffer = NULL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pMyBuffer)
    {
        pMyBuffer->Release();
        *ppAtr = NULL;
    }
    return hReturn;
}


/*++

CSCard::get_CardHandle:

    The get_CardHandle method retrieves the handle for a connected smart card.
    Returns (*pHandle) == NULL if not connected.

Arguments:

    pHandle [out, retval] Pointer to the card handle on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::get_CardHandle")

STDMETHODIMP
CSCard::get_CardHandle(
    /* [retval][out] */ HSCARD __RPC_FAR *pHandle)
{
    HRESULT hReturn = S_OK;

    try
    {
        *pHandle = m_hCard;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::get_Context:

    The get_Context method retrieves the current resource manager context
    handle. Returns (*pContext) == NULL if no context has been established.

Arguments:

    pContext [out, retval] Pointer to the context handle on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    The resource manager context is set by calling the smart card function
    SCardEstablishContext.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::get_Context")

STDMETHODIMP
CSCard::get_Context(
    /* [retval][out] */ HSCARDCONTEXT __RPC_FAR *pContext)
{
    HRESULT hReturn = S_OK;

    try
    {
        *pContext = Context();
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::get_Protocol:

    The get_Protocol retrieves the identifier of the protocol currently in use
    on the smart card.

Arguments:

    pProtocol [out, retval] Pointer to the protocol identifier.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::get_Protocol")

STDMETHODIMP
CSCard::get_Protocol(
    /* [retval][out] */ SCARD_PROTOCOLS __RPC_FAR *pProtocol)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;

        if (NULL != m_hCard)
        {
            lSts = SCardStatus(
                        m_hCard,
                        NULL, 0,            // Reader name
                        NULL,               // State
                        (LPDWORD)pProtocol, // Protocol
                        NULL, 0);           // ATR
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        }
        else
            *pProtocol = (SCARD_PROTOCOLS)SCARD_PROTOCOL_UNDEFINED;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::get_Status:

    The get_Status method retrieves the current state of the smart card.

Arguments:

    pStatus [out, retval] Pointer to the state variable.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::get_Status")

STDMETHODIMP
CSCard::get_Status(
    /* [retval][out] */ SCARD_STATES __RPC_FAR *pStatus)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;

        if (NULL != m_hCard)
        {
            lSts = SCardStatus(
                m_hCard,
                NULL, 0,            // Reader name
                (LPDWORD)pStatus,   // State
                NULL,               // Protocol
                NULL, 0);           // ATR
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        }
        else
            *pStatus = (SCARD_STATES)SCARD_UNKNOWN;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::AttachByHandle:

    The AttachByHandle method attaches this object to an open and configured
    smart card handle.

Arguments:

    hCard [in] Handle to an open connection to a smart card.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::AttachByHandle")

STDMETHODIMP
CSCard::AttachByHandle(
    /* [in] */ HSCARD hCard)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;

        if (NULL != m_hMyCard)
        {
            lSts = SCardDisconnect(m_hMyCard, SCARD_RESET_CARD);
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
            m_hMyCard = NULL;
        }
        m_dwProtocol = 0;
        m_hCard = hCard;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::AttachByReader:

    The AttachByReader method opens the smart card in the named reader.

Arguments:

    bstrReaderName [in] Pointer to the name of the smart card reader.

    ShareMode [in, defaultvalue(EXCLUSIVE)] Mode in which to claim access to
        the smart card.

        Values      Description
        EXCLUSIVE   No one else use this connection to the smart card.
        SHARED      Other applications can use this connection.

    PrefProtocol [in, defaultvalue(T0)] Preferred protocol values:

        T0
        T1
        Raw
        T0|T1

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::AttachByReader")

STDMETHODIMP
CSCard::AttachByReader(
    /* [in] */ BSTR bstrReaderName,
    /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
    /* [defaultvalue][in] */ SCARD_PROTOCOLS PrefProtocol)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;
        DWORD dwProto;
        CTextString tzReader;

        tzReader = bstrReaderName;
        if (NULL != m_hMyCard)
        {
            lSts = SCardDisconnect(m_hMyCard, SCARD_RESET_CARD);
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
            m_hMyCard = NULL;
        }
        m_dwProtocol = 0;

        lSts = SCardConnect(
                    Context(),
                    tzReader,
                    (DWORD)ShareMode,
                    (DWORD)PrefProtocol,
                    &m_hMyCard,
                    &dwProto);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        m_hCard = m_hMyCard;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::Detach:

    The Detach method closes the open connection to the smart card.

Arguments:

    Disposition [in, defaultvalue(LEAVE)] Indicates what should be done with
        the card in the connected reader.

        Values  Description
        LEAVE   Leaves the smart card in the current state.
        RESET   Resets the smart card to some known state.
        UNPOWER Removes power from the smart card.
        EJECT   Ejects the smart card if the reader has eject capabilities.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::Detach")

STDMETHODIMP
CSCard::Detach(
    /* [defaultvalue][in] */ SCARD_DISPOSITIONS Disposition)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;

        m_dwProtocol = 0;
        lSts = SCardDisconnect(m_hCard, (DWORD)Disposition);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        m_hCard = m_hMyCard = NULL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::LockSCard:

    The LockSCard method claims exclusive access to the smart card.

Arguments:

    None

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::LockSCard")

STDMETHODIMP
CSCard::LockSCard(
    void)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;

        lSts = SCardBeginTransaction(m_hCard);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::ReAttach:

    The ReAttach method resets, or reinitializes, the smart card.

Arguments:

    ShareMode [in, defaultvalue(EXCLUSIVE)] Mode in which to share or
        exclusively own the connection to the smart card.

        Values      Description
        EXCLUSIVE   No one else use this connection to the smart card.
        SHARED      Other applications can use this connection.

    InitState [in, defaultvalue(LEAVE)] Indicates what to do with the card.

        Values  Description
        LEAVE   Leaves the smart card in the current state.
        RESET   Resets the smart card to some known state.
        UNPOWER Removes power from the smart card.
        EJECT   Ejects the smart card if the reader has eject capabilities.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::ReAttach")

STDMETHODIMP
CSCard::ReAttach(
    /* [defaultvalue][in] */ SCARD_SHARE_MODES ShareMode,
    /* [defaultvalue][in] */ SCARD_DISPOSITIONS InitState)
{
    HRESULT hReturn = S_OK;

    try
    {
        DWORD dwProto;
        LONG lSts;

        m_dwProtocol = 0;
        lSts = SCardReconnect(
                    m_hCard,
                    (DWORD)ShareMode,
                    SCARD_PROTOCOL_Tx,
                    (DWORD)InitState,
                    &dwProto);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCard::Transaction:

    The Transaction method executes a write and read operation on the smart
    card command (APDU) object.  The reply string from the smart card for the
    command string defined in the card that was sent to the smart card will be
    accessible after this function returns.

Arguments:

    ppCmd [in, out] Pointer to the smart card command object.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::Transaction")

STDMETHODIMP
CSCard::Transaction(
    /* [out][in] */ LPSCARDCMD __RPC_FAR *ppCmd)
{
    HRESULT hReturn = S_OK;
    CByteBuffer *pbyApdu = NewByteBuffer();

    try
    {
        HRESULT hr;
        LONG lSts;
        DWORD dwFlags = 0;
        CBuffer bfResponse, bfPciRqst, bfPciRsp, bfApdu;


        //
        // Get the protocol.
        //

        if (0 == m_dwProtocol)
        {
            lSts = SCardStatus(
                m_hCard,
                NULL, 0,            // Reader name
                NULL,               // State
                &m_dwProtocol,      // Protocol
                NULL, 0);           // ATR
            if (SCARD_S_SUCCESS != lSts)
                throw (HRESULT)HRESULT_FROM_WIN32(lSts);
        }
        ASSERT(0 != m_dwProtocol);


        //
        // Get The APDU
        //

        if (NULL == pbyApdu)
            throw (HRESULT)E_OUTOFMEMORY;
        hr = (*ppCmd)->get_Apdu((LPBYTEBUFFER *)&pbyApdu);
        if (FAILED(hr))
            throw hr;
        ByteBufferToBuffer(pbyApdu, bfApdu);


        //
        // Convert it to a TPDU.
        //

        switch (m_dwProtocol)
        {
        case SCARD_PROTOCOL_T0:
        {
            BYTE bAltCla;
            LPBYTE pbAltCla = NULL;

            if (SUCCEEDED((*ppCmd)->get_AlternateClassId(&bAltCla)))
                pbAltCla = &bAltCla;

            ApduToTpdu_T0(
                m_hCard,
                SCARD_PCI_T0,
                bfApdu.Access(),
                bfApdu.Length(),
                dwFlags,
                bfPciRsp,
                bfResponse,
                pbAltCla);
            break;
        }

        case SCARD_PROTOCOL_T1:
        {
            BYTE bNad;
            LPBYTE pbCur, pbEnd;
            DWORD dwI;

            bfPciRqst.Set((LPBYTE)SCARD_PCI_T1, sizeof(SCARD_IO_REQUEST));
            if (SUCCEEDED((*ppCmd)->get_Nad(&bNad)))
            {
                bfPciRqst.Presize(bfPciRqst.Length() + sizeof(DWORD), TRUE);
                bfPciRqst.Append((LPBYTE)"\0x81\0x01", 2);
                bfPciRqst.Append(&bNad, 1);
            }
            dwI = 0;
            bfPciRqst.Append(
                (LPBYTE)&dwI,
                bfPciRqst.Length() % sizeof(DWORD));
            ((LPSCARD_IO_REQUEST)bfPciRqst.Access())->cbPciLength = bfPciRqst.Length();

            ApduToTpdu_T1(
                m_hCard,
                (LPSCARD_IO_REQUEST)bfPciRqst.Access(),
                bfApdu.Access(),
                bfApdu.Length(),
                dwFlags,
                bfPciRsp,
                bfResponse);

            pbEnd = bfPciRsp.Access();
            pbCur = pbEnd + sizeof(SCARD_PCI_T1);
            pbEnd += bfPciRsp.Length();
            while (pbCur < pbEnd)
            {
                switch (*pbCur++)
                {
                case 0x00:
                    break;
                case 0x81:
                    bNad = *(++pbCur);
                    hr = (*ppCmd)->put_ReplyNad(bNad);
                    break;
                default:
                    pbCur += *pbCur + 1;
                }
            }
            break;
        }
        default:
            throw (HRESULT)SCARD_E_CARD_UNSUPPORTED;
        }


        //
        // Write the response back to the ISCardCommand object.
        //

        BufferToByteBuffer(bfResponse, (LPBYTEBUFFER *)&pbyApdu);
        hr = (*ppCmd)->put_ApduReply(pbyApdu);
        if (FAILED(hr))
            throw hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pbyApdu)
        pbyApdu->Release();
    return hReturn;
}


/*++

CSCard::UnlockSCard:

    The UnlockSCard method releases exclusive access to the smart card.

Arguments:

    Disposition [in, defaultvalue(LEAVE)] Indicates what should be done with
        the card in the connected reader.

        Values  Description
        LEAVE   Leaves the smart card in the current state.
        RESET   Resets the smart card to some known state.
        UNPOWER Removes power from the smart card.
        EJECT   Ejects the smart card if the reader has eject capabilities.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCard::UnlockSCard")

STDMETHODIMP
CSCard::UnlockSCard(
    /* [defaultvalue][in] */ SCARD_DISPOSITIONS Disposition)
{
    HRESULT hReturn = S_OK;

    try
    {
        LONG lSts;

        lSts = SCardEndTransaction(m_hCard, (DWORD)Disposition);
        if (SCARD_S_SUCCESS != lSts)
            throw (HRESULT)HRESULT_FROM_WIN32(lSts);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\scardcmd.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    SCardCmd

Abstract:

    The ISCardCmd interface provides the methods needed to construct and manage
    a smart card Application Protocol Data Unit (APDU ).  This interface
    encapsulates two buffers:

    The APDU buffer contains the command sequence that will be sent to the
    card.

    The APDUReply buffer contains data returned from the card after execution
    of the APDU command (this data is also referred to as the return ADPU).

    The following example shows a typical use of the ISCardCmd interface.  The
    ISCardCmd interface is used to build the an ADPU.

    To submit a transaction to a specific card

    1)  Create an ISCard interface and connect to a smart card.
    2)  Create an ISCardCmd interface.
    3)  Build a smart card APDU command using the ISCardISO7816 interface or
        one of ISCardCmd's build methods).
    4)  Execute the command on the smart card by calling the appropriate ISCard
        interface method.
    5)  Evaluate the returned response.
    6)  Repeat the procedure as needed.
    7)  Release the ISCardCmd interface and others as needed.

Author:

    Doug Barlow (dbarlow) 6/24/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "stdafx.h"
#include "scardssp.h"
#include "ByteBuffer.h"
#include "SCardCmd.h"
#include "Conversion.h"


/////////////////////////////////////////////////////////////////////////////
// CSCardCmd

/*++

CSCardCmd::get_Apdu:

    The get_Apdu method retrieves the raw APDU.

Arguments:

    ppApdu [out, retval] Pointer to the byte buffer mapped through an IStream
        that contains the APDU message on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    To copy the APDU from an IByteBuffer (IStream) object into the APDU
    wrapped in this interface object, call put_Apdu.

    To determine the length of the APDU, call get_ApduLength.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_Apdu")

STDMETHODIMP
CSCardCmd::get_Apdu(
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppApdu)
{
    HRESULT hReturn = S_OK;
    CByteBuffer *pMyBuffer = NULL;

    try
    {
        CBuffer bfApdu(m_bfRequestData.Length() + 4 + 3 + 3);

        if (NULL == *ppApdu)
        {
            *ppApdu = pMyBuffer = NewByteBuffer();
            if (NULL == pMyBuffer)
                throw (HRESULT)E_OUTOFMEMORY;
        }

        ConstructRequest(
            m_bCla,
            m_bIns,
            m_bP1,
            m_bP2,
            m_bfRequestData,
            m_wLe,
            m_dwFlags,
            bfApdu);
        BufferToByteBuffer(bfApdu, ppApdu);
        pMyBuffer = NULL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pMyBuffer)
    {
        pMyBuffer->Release();
        *ppApdu = NULL;
    }
    return hReturn;
}


/*++

CSCardCmd::put_Apdu:

    The put_Apdu method copies the APDU from the IByteBuffer (IStream) object
    into the APDU wrapped in this interface object.

Arguments:

    pApdu [in] Pointer to the ISO 7816-4 APDU to be copied in.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    To retrieve the raw APDU from the byte buffer mapped through an IStream
    that contains the APDU message, call get_Apdu.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_Apdu")

STDMETHODIMP
CSCardCmd::put_Apdu(
    /* [in] */ LPBYTEBUFFER pApdu)
{
    HRESULT hReturn = S_OK;

    try
    {
        CBuffer bfApdu;
        LPCBYTE pbData;
        WORD wLc;

        ByteBufferToBuffer(pApdu, bfApdu);
        ParseRequest(
            bfApdu.Access(),
            bfApdu.Length(),
            &m_bCla,
            &m_bIns,
            &m_bP1,
            &m_bP2,
            &pbData,
            &wLc,
            &m_wLe,
            &m_dwFlags);
        m_bfRequestData.Set(pbData, wLc);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_ApduLength:

    The get_ApduLength method determines the length (in bytes) of the APDU.

Arguments:

    plSize [out, retval] Pointer to the length of the APDU.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

    To retrieve the raw APDU from the byte buffer mapped through an IStream
    that contains the APDU message, call get_Apdu.

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_ApduLength")

STDMETHODIMP
CSCardCmd::get_ApduLength(
    /* [retval][out] */ LONG __RPC_FAR *plSize)
{
    HRESULT hReturn = S_OK;

    try
    {
        CBuffer bfApdu;

        ConstructRequest(
            m_bCla,
            m_bIns,
            m_bP1,
            m_bP2,
            m_bfRequestData,
            m_wLe,
            m_dwFlags,
            bfApdu);
        *plSize = (LONG)bfApdu.Length();
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_ApduReply:

    The get_ApduReply retrieves the reply APDU, placing it in a specific byte
    buffer.  The reply may be NULL if no transaction has been performed on the
    command APDU.

Arguments:

    ppReplyApdu [out, retval] Pointer to the byte buffer (mapped through an
        IStream) that contains the APDU reply message on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_ApduReply")

STDMETHODIMP
CSCardCmd::get_ApduReply(
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppReplyApdu)
{
    HRESULT hReturn = S_OK;
    LPBYTEBUFFER pMyBuffer = NULL;

    try
    {
        if (NULL == *ppReplyApdu)
        {
            *ppReplyApdu = pMyBuffer = NewByteBuffer();
            if (NULL == pMyBuffer)
                throw (HRESULT)E_OUTOFMEMORY;
        }
        BufferToByteBuffer(m_bfResponseApdu, ppReplyApdu);
        pMyBuffer = NULL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pMyBuffer)
    {
        pMyBuffer->Release();
        *ppReplyApdu = NULL;
    }
    return hReturn;
}


/*++

CSCardCmd::put_ApduReply:

    The put_ApduReply method sets a new reply APDU.

Arguments:

    pReplyApdu [in] Pointer to the byte buffer (mapped through an IStream) that
        contains the replay APDU message on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_ApduReply")

STDMETHODIMP
CSCardCmd::put_ApduReply(
    /* [in] */ LPBYTEBUFFER pReplyApdu)
{
    HRESULT hReturn = S_OK;

    try
    {
        ByteBufferToBuffer(pReplyApdu, m_bfResponseApdu);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_ApduReplyLength:

    The get_ApduReplyLength method determines the length (in bytes) of the
    reply APDU.

Arguments:

    plSize [out, retval] Pointer to the size of the reply APDU message.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_ApduReplyLength")

STDMETHODIMP
CSCardCmd::get_ApduReplyLength(
    /* [retval][out] */ LONG __RPC_FAR *plSize)
{
    HRESULT hReturn = S_OK;

    try
    {
        *plSize = (LONG)m_bfResponseApdu.Length();
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


STDMETHODIMP
CSCardCmd::put_ApduReplyLength(
    /* [in] */ LONG lSize)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bfResponseApdu.Resize((DWORD)lSize, TRUE);
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_ClassId:

    The get_ClassId method retrieves the class identifier from the APDU.

Arguments:

    pbyClass [out, retval] Pointer to the byte that represents the class
        identifier.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_ClassId")

STDMETHODIMP
CSCardCmd::get_ClassId(
    /* [retval][out] */ BYTE __RPC_FAR *pbyClass)
{
    HRESULT hReturn = S_OK;

    try
    {
        *pbyClass = m_bCla;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::put_ClassId:

    The put_ClassId method sets a new class identifier in the APDU.

Arguments:

byClass [in, defaultvalue(0)] The byte that represents the class identifier.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_ClassId")

STDMETHODIMP
CSCardCmd::put_ClassId(
    /* [defaultvalue][in] */ BYTE byClass)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bCla = byClass;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_Data:

    The get_Data method retrieves the data field from the APDU, placing it in a
    byte buffer object.

Arguments:

    ppData [out, retval] Pointer to the byte buffer object (IStream) that holds
        the APDU's data field on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_Data")

STDMETHODIMP
CSCardCmd::get_Data(
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppData)
{
    HRESULT hReturn = S_OK;
    CByteBuffer *pMyBuffer = NULL;

    try
    {
        if (NULL == *ppData)
        {
            *ppData = pMyBuffer = NewByteBuffer();
            if (NULL == pMyBuffer)
                throw (HRESULT)E_OUTOFMEMORY;
        }
        BufferToByteBuffer(m_bfRequestData, ppData);
        pMyBuffer = NULL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    if (NULL != pMyBuffer)
    {
        pMyBuffer->Release();
        *ppData = NULL;
    }
    return hReturn;
}


/*++

CSCardCmd::put_Data:

    The put_Data method sets the data field in the APDU.

Arguments:

    pData [in] Pointer to the byte buffer object (IStream) to be copied into
        the APDU's data field.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_Data")

STDMETHODIMP
CSCardCmd::put_Data(
    /* [in] */ LPBYTEBUFFER pData)
{
    HRESULT hReturn = S_OK;

    try
    {
        ByteBufferToBuffer(pData, m_bfRequestData);
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_InstructionId:

    The get_InstructionId method retrieves the instruction identifier byte from
    the APDU.

Arguments:

    pbyIns [out, retval] Pointer to the byte that is the instruction ID from
        the APDU on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_InstructionId")

STDMETHODIMP
CSCardCmd::get_InstructionId(
    /* [retval][out] */ BYTE __RPC_FAR *pbyIns)
{
    HRESULT hReturn = S_OK;

    try
    {
        *pbyIns = m_bIns;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::put_InstructionId:

    The put_InstructionId sets the given instruction identifier in the APDU.

Arguments:

    byIns [in] The byte that is the instruction identifier.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_InstructionId")

STDMETHODIMP
CSCardCmd::put_InstructionId(
    /* [in] */ BYTE byIns)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bIns = byIns;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


STDMETHODIMP
CSCardCmd::get_LeField(
    /* [retval][out] */ LONG __RPC_FAR *plSize)
{
    HRESULT hReturn = S_OK;

    try
    {
        *plSize = m_wLe;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_P1:

    The get_P1 method retrieves the first parameter (P1) byte from the APDU.

Arguments:

    pbyP1 [out, retval] Pointer to the P1 byte in the APDU on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_P1")

STDMETHODIMP
CSCardCmd::get_P1(
    /* [retval][out] */ BYTE __RPC_FAR *pbyP1)
{
    HRESULT hReturn = S_OK;

    try
    {
        *pbyP1 = m_bP1;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::put_P1:

    The put_P1 method sets the first parameter (P1) byte of the APDU.

Arguments:

    byP1 [in] The byte that is the P1 field.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_P1")

STDMETHODIMP
CSCardCmd::put_P1(
    /* [in] */ BYTE byP1)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bP1 = byP1;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_P2:

    The get_P2 method retrieves the second parameter (P2) byte from the APDU

Arguments:

    pbyP2 [out, retval] Pointer to the byte that is the P2 from the APDU on
        return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_P2")

STDMETHODIMP
CSCardCmd::get_P2(
    /* [retval][out] */ BYTE __RPC_FAR *pbyP2)
{
    HRESULT hReturn = S_OK;

    try
    {
        *pbyP2 = m_bP2;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::put_P2:

    The put_P2 method sets the second parameter (P2) byte in the APDU.

Arguments:

    byP2 [in] The byte that is the P2 field.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_P2")

STDMETHODIMP
CSCardCmd::put_P2(
    /* [in] */ BYTE byP2)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bP2 = byP2;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_P3:

    The get_P3 method retrieves the third parameter (P3) byte from the APDU.
    This read-only byte value represents the size of the data portion of the
    APDU.

Arguments:

    pbyP3 [out, retval] Pointer to the byte that is the P3 from the APDU on
        return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_P3")

STDMETHODIMP
CSCardCmd::get_P3(
    /* [retval][out] */ BYTE __RPC_FAR *pbyP3)
{
    HRESULT hReturn = S_OK;

    try
    {
        *pbyP3 = (BYTE)m_bfRequestData.Length();
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_ReplyStatus:

    The get_ReplyStatus method retrieves the reply APDU's message status word.

Arguments:

    pwStatus [out, retval] Pointer to the word that is the status on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_ReplyStatus")

STDMETHODIMP
CSCardCmd::get_ReplyStatus(
    /* [retval][out] */ LPWORD pwStatus)
{
    HRESULT hReturn = S_OK;

    try
    {
        DWORD dwLen = m_bfResponseApdu.Length();

        if (2 <= dwLen)
            *pwStatus = NetToLocal(m_bfResponseApdu.Access(dwLen - 2));
        else
            *pwStatus = 0;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::put_ReplyStatus:

    The put_ReplyStatus sets a new reply APDU's message status word.

Arguments:

    wStatus [in] The word that is the status.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_ReplyStatus")

STDMETHODIMP
CSCardCmd::put_ReplyStatus(
    /* [in] */ WORD wStatus)
{
    HRESULT hReturn = S_OK;

    try
    {
        DWORD dwLen = m_bfResponseApdu.Length();

        if (2 <= dwLen)
            CopyMemory(m_bfResponseApdu.Access(dwLen - 2), &wStatus, 2);
        else
            m_bfResponseApdu.Set((LPCBYTE)&wStatus, 2);
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_ReplyStatusSW1:

    The get_ReplyStatusSW1 method retrieves the reply APDU's SW1 status byte.

Arguments:

    pbySW1 [out, retval] Pointer to the byte that contains the value of the SW1
        byte on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_ReplyStatusSW1")

STDMETHODIMP
CSCardCmd::get_ReplyStatusSW1(
    /* [retval][out] */ BYTE __RPC_FAR *pbySW1)
{
    HRESULT hReturn = S_OK;

    try
    {
        DWORD dwLen = m_bfResponseApdu.Length();

        if (2 <= dwLen)
            *pbySW1 = *m_bfResponseApdu.Access(dwLen - 2);
        else
            *pbySW1 = 0;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_ReplyStatusSW2:

    The get_ReplyStatusSW2 method retrieves the reply APDU's SW2 status byte.

Arguments:

    pbySW2 [out, retval] Pointer to the byte that contains the value of the SW2
        byte on return.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_ReplyStatusSW2")

STDMETHODIMP
CSCardCmd::get_ReplyStatusSW2(
    /* [retval][out] */ BYTE __RPC_FAR *pbySW2)
{
    HRESULT hReturn = S_OK;

    try
    {
        DWORD dwLen = m_bfResponseApdu.Length();

        if (2 <= dwLen)
            *pbySW2 = *m_bfResponseApdu.Access(dwLen - 1);
        else
            *pbySW2 = 0;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_Type")

STDMETHODIMP
CSCardCmd::get_Type(
    /* [retval][out] */ ISO_APDU_TYPE __RPC_FAR *pType)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?todo?
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardCmd::get_Nad(
    /* [retval][out] */ BYTE __RPC_FAR *pbNad)
{
    HRESULT hReturn = S_OK;

    try
    {
        if (0 != (m_dwFlags & APDU_REQNAD_VALID))
            *pbNad = m_bRequestNad;
        else
            hReturn = E_ACCESSDENIED;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardCmd::put_Nad(
    /* [in] */ BYTE bNad)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bRequestNad = bNad;
        m_dwFlags |= APDU_REQNAD_VALID;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardCmd::get_ReplyNad(
    /* [retval][out] */ BYTE __RPC_FAR *pbNad)
{
    HRESULT hReturn = S_OK;

    try
    {
        if (0 != (APDU_RSPNAD_VALID & m_dwFlags))
            *pbNad = m_bResponseNad;
        else
            hReturn = E_ACCESSDENIED;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardCmd::put_ReplyNad(
    /* [in] */ BYTE bNad)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bResponseNad = bNad;
        m_dwFlags |= APDU_RSPNAD_VALID;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::get_AlternateClassId:

    The get_AlternateClassId method retrieves the alternate class identifier
    from the APDU.  The Alternate Class Id is used for automatically generated
    GetResponse and Envelope commands when T=0 is used.

Arguments:

    pbyClass [out, retval] Pointer to the byte that represents the alternate
        class identifier.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::get_AlternateClassId")

STDMETHODIMP
CSCardCmd::get_AlternateClassId(
    /* [retval][out] */ BYTE __RPC_FAR *pbyClass)
{
    HRESULT hReturn = S_OK;

    try
    {
        if (0 != (m_dwFlags & APDU_ALTCLA_VALID))
            *pbyClass = m_bAltCla;
        else
            hReturn = E_ACCESSDENIED;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::put_AlternateClassId:

    The put_AlternateClassId method sets a new alternate class identifier in
    the APDU.  The Alternate Class Id is used for automatically generated
    GetResponse and Envelope commands when T=0 is used.  If no alternate class
    identifier is set, then the CLA of the original command is used.

Arguments:

    byClass [in, defaultvalue(0)] The byte that represents the alternate class
        identifier.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::put_AlternateClassId")

STDMETHODIMP
CSCardCmd::put_AlternateClassId(
    /* [defaultvalue][in] */ BYTE byClass)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bAltCla = byClass;
        m_dwFlags |= APDU_ALTCLA_VALID;
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::BuildCmd:

    The BuildCmd method constructs a valid command APDU for transmission to a
    smart card.

Arguments:

    byClassId [in] Command class identifier.

    byInsId [in] Command instruction identifier.

    byP1 [in, defaultvalue(0)] Command's first parameter.

    byP2 [in, defaultvalue(0)] Command's second parameter.

    pbyData [in, defaultvalue(NULL)] Pointer to the data portion of the
        command.

    p1Le [in, defaultvalue(NULL)] Pointer to a LONG integer containing the
        expected length of the returned data.

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::BuildCmd")

STDMETHODIMP
CSCardCmd::BuildCmd(
    /* [in] */ BYTE byClassId,
    /* [in] */ BYTE byInsId,
    /* [defaultvalue][in] */ BYTE byP1,
    /* [defaultvalue][in] */ BYTE byP2,
    /* [defaultvalue][in] */ LPBYTEBUFFER pbyData,
    /* [defaultvalue][in] */ LONG __RPC_FAR *plLe)
{
    HRESULT hReturn = S_OK;

    try
    {
        ByteBufferToBuffer(pbyData, m_bfRequestData);
        m_bCla = byClassId;
        m_bIns = byInsId;
        m_bP1  = byP1;
        m_bP2  = byP2;
        m_dwFlags = 0;

        if (NULL != plLe)
        {
            switch (*plLe)
            {
            case 0x10000:
                m_dwFlags |= APDU_EXTENDED_LENGTH;
                // Fall through intentionally
            case 0x100:
            case 0:
                m_dwFlags |= APDU_MAXIMUM_LE;
                m_wLe = 0;
                break;
            default:
                if (0x10000 < *plLe)
                    throw (HRESULT)E_INVALIDARG;
                if (0x100 < *plLe)
                    m_dwFlags |= APDU_EXTENDED_LENGTH;
                m_wLe = (WORD)(*plLe);
            }
        }
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::Clear:

    The Clear method clears the APDU and reply APDU message buffers.

Arguments:

    None

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::Clear")

STDMETHODIMP
CSCardCmd::Clear(
    void)
{
    HRESULT hReturn = S_OK;

    try
    {
        m_bfRequestData.Reset();
        m_bfResponseApdu.Reset();
    }

    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}


/*++

CSCardCmd::Encapsulate:

    The Encapsulate method encapsulates the given command APDU into another
    command APDU for transmission to a smart card.

Arguments:

    pApdu [in] Pointer to the APDU to be encapsulated.

    ApduType [in] Specifies the ISO 7816-4 case for T0 transmissions.  Possible
        values are:

        ISO_CASE_1
        ISO_CASE_2
        ISO_CASE_3
        ISO_CASE_4

Return Value:

    The return value is an HRESULT. A value of S_OK indicates the call was
    successful.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/24/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CSCardCmd::Encapsulate")

STDMETHODIMP
CSCardCmd::Encapsulate(
    /* [in] */ LPBYTEBUFFER pApdu,
    /* [in] */ ISO_APDU_TYPE ApduType)
{
    HRESULT hReturn = S_OK;

    try
    {
        WORD wLe;
        DWORD dwFlags;


        //
        // Get the APDU to be encapsulated.
        //

        ByteBufferToBuffer(pApdu, m_bfRequestData);


        //
        // Parse it.
        //

        ParseRequest(
            m_bfRequestData.Access(),
            m_bfRequestData.Length(),
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            &wLe,
            &dwFlags);


        m_bIns = 0xc2;
        m_bP1  = 0x00;
        m_bP2  = 0x00;
        m_wLe  = wLe;
        m_dwFlags = dwFlags;

        // ?todo? -- support ApduType
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\scardssp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       scardssp.cpp
//
//--------------------------------------------------------------------------

// scardssp.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for scardssp.idl by adding the following
//      files to the Outputs.
//          scardssp_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f scardsspps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <sspguid.h>
#include "dlldatax.h"

#include "ByteBuffer.h"
#include "TypeConv.h"
#include "SCardCmd.h"
#include "ISO7816.h"
#include "SCard.h"
#include "Database.h"
#include "Locate.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_CByteBuffer, CByteBuffer)
OBJECT_ENTRY(CLSID_CSCardTypeConv, CSCardTypeConv)
OBJECT_ENTRY(CLSID_CSCardCmd, CSCardCmd)
OBJECT_ENTRY(CLSID_CSCardISO7816, CSCardISO7816)
OBJECT_ENTRY(CLSID_CSCard, CSCard)
OBJECT_ENTRY(CLSID_CSCardDatabase, CSCardDatabase)
OBJECT_ENTRY(CLSID_CSCardLocate, CSCardLocate)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance/* , &LIBID_SCARDSSPLib */);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(/* TRUE */);
}


/////////////////////////////////////////////////////////////////////////////
// Quick Generation of our own objects.

LPUNKNOWN
NewObject(
    REFCLSID rclsid,
    REFIID riid)
{
    HRESULT hr;
    IClassFactory *pCF = NULL;
    LPUNKNOWN pUnk = NULL;

    try
    {
        hr = DllGetClassObject(rclsid, IID_IClassFactory, (LPVOID *)&pCF);
        if (FAILED(hr))
            throw hr;
        hr = pCF->CreateInstance(NULL, riid, (LPVOID *)&pUnk);
        if (FAILED(hr))
            throw hr;
        pCF->Release();
    }
    catch (...)
    {
        if (NULL != pCF)
            pCF->Release();
        throw;
    }
    return pUnk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       StdAfx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\scardcmd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       SCardCmd.h
//
//--------------------------------------------------------------------------

// SCardCmd.h : Declaration of the CSCardCmd

#ifndef __SCARDCMD_H_
#define __SCARDCMD_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSCardCmd
class ATL_NO_VTABLE CSCardCmd :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSCardCmd, &CLSID_CSCardCmd>,
    public IDispatchImpl<ISCardCmd, &IID_ISCardCmd, &LIBID_SCARDSSPLib>
{
public:
    CSCardCmd()
    :   m_bfRequestData(),
        m_bfResponseApdu()
    {
        m_pUnkMarshaler = NULL;
        m_bCla = 0;
        m_bIns = 0;
        m_bP1 = 0;
        m_bP2 = 0;
        m_wLe = 0;
        m_dwFlags = 0;
        m_bRequestNad = 0;
        m_bResponseNad = 0;
        m_bAltCla = 0;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SCARDCMD)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSCardCmd)
    COM_INTERFACE_ENTRY(ISCardCmd)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

protected:
    BYTE m_bCla;
    BYTE m_bIns;
    BYTE m_bP1;
    BYTE m_bP2;
    CBuffer m_bfRequestData;
    CBuffer m_bfResponseApdu;
    WORD m_wLe;
    DWORD m_dwFlags;
    BYTE m_bRequestNad;
    BYTE m_bResponseNad;
    BYTE m_bAltCla;

// ISCardCmd
public:
    STDMETHOD(get_Apdu)(
        /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppApdu);

    STDMETHOD(put_Apdu)(
        /* [in] */ LPBYTEBUFFER pApdu);

    STDMETHOD(get_ApduLength)(
        /* [retval][out] */ LONG __RPC_FAR *plSize);

    STDMETHOD(get_ApduReply)(
        /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppReplyApdu);

    STDMETHOD(put_ApduReply)(
        /* [in] */ LPBYTEBUFFER pReplyApdu);

    STDMETHOD(get_ApduReplyLength)(
        /* [retval][out] */ LONG __RPC_FAR *plSize);

    STDMETHOD(put_ApduReplyLength)(
        /* [in] */ LONG lSize);

    STDMETHOD(get_ClassId)(
        /* [retval][out] */ BYTE __RPC_FAR *pbyClass);

    STDMETHOD(put_ClassId)(
        /* [defaultvalue][in] */ BYTE byClass = 0);

    STDMETHOD(get_Data)(
        /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppData);

    STDMETHOD(put_Data)(
        /* [in] */ LPBYTEBUFFER pData);

    STDMETHOD(get_InstructionId)(
        /* [retval][out] */ BYTE __RPC_FAR *pbyIns);

    STDMETHOD(put_InstructionId)(
        /* [in] */ BYTE byIns);

    STDMETHOD(get_LeField)(
        /* [retval][out] */ LONG __RPC_FAR *plSize);

    STDMETHOD(get_P1)(
        /* [retval][out] */ BYTE __RPC_FAR *pbyP1);

    STDMETHOD(put_P1)(
        /* [in] */ BYTE byP1);

    STDMETHOD(get_P2)(
        /* [retval][out] */ BYTE __RPC_FAR *pbyP2);

    STDMETHOD(put_P2)(
        /* [in] */ BYTE byP2);

    STDMETHOD(get_P3)(
        /* [retval][out] */ BYTE __RPC_FAR *pbyP3);

    STDMETHOD(get_ReplyStatus)(
        /* [retval][out] */ LPWORD pwStatus);

    STDMETHOD(put_ReplyStatus)(
        /* [in] */ WORD wStatus);

    STDMETHOD(get_ReplyStatusSW1)(
        /* [retval][out] */ BYTE __RPC_FAR *pbySW1);

    STDMETHOD(get_ReplyStatusSW2)(
        /* [retval][out] */ BYTE __RPC_FAR *pbySW2);

    STDMETHOD(get_Type)(
        /* [retval][out] */ ISO_APDU_TYPE __RPC_FAR *pType);

    STDMETHOD(get_Nad)(
        /* [retval][out] */ BYTE __RPC_FAR *pbNad);

    STDMETHOD(put_Nad)(
        /* [in] */ BYTE bNad);

    STDMETHOD(get_ReplyNad)(
        /* [retval][out] */ BYTE __RPC_FAR *pbNad);

    STDMETHOD(put_ReplyNad)(
        /* [in] */ BYTE bNad);

    STDMETHOD(BuildCmd)(
        /* [in] */ BYTE byClassId,
        /* [in] */ BYTE byInsId,
        /* [defaultvalue][in] */ BYTE byP1 = 0,
        /* [defaultvalue][in] */ BYTE byP2 = 0,
        /* [defaultvalue][in] */ LPBYTEBUFFER pbyData = 0,
        /* [defaultvalue][in] */ LONG __RPC_FAR *plLe = 0);

    STDMETHOD(Clear)(
        void);

    STDMETHOD(Encapsulate)(
        /* [in] */ LPBYTEBUFFER pApdu,
        /* [in] */ ISO_APDU_TYPE ApduType);

    STDMETHOD(get_AlternateClassId)(
        /* [retval][out] */ BYTE __RPC_FAR *pbyClass);

    STDMETHOD(put_AlternateClassId)(
        /* [in] */ BYTE byClass = 0);
};

inline CSCardCmd *
NewSCardCmd(
    void)
{
    return (CSCardCmd *)NewObject(CLSID_CSCardCmd, IID_ISCardCmd);
}

#endif //__SCARDCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       StdAfx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__9AEC1AF7_19F1_11D3_A11F_00C04F79F800__INCLUDED_)
#define AFX_STDAFX_H__9AEC1AF7_19F1_11D3_A11F_00C04F79F800__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <ole2.h>
#include <oleauto.h>
#include <unknwn.h>

#ifdef _DEBUG

#include <crtdbg.h>
#define ASSERT(x) _ASSERTE(x)
#define breakpoint _CrtDbgBreak()
// #define breakpoint

#elif defined(DBG)

#include <stdio.h>
inline void
LocalAssert(
    LPCTSTR szExpr,
    LPCTSTR szFile,
    DWORD dwLine)
{
    TCHAR szBuffer[MAX_PATH * 2];
    _stprintf(szBuffer, TEXT("ASSERT FAIL: '%s' in %s at %d.\n"), szExpr, szFile, dwLine);
    OutputDebugString(szBuffer);
}
#define ASSERT(x) if (!(x)) do { \
        LocalAssert(TEXT(#x), TEXT(__FILE__), __LINE__); \
        _CrtDbgBreak(); } while (0)
#define breakpoint _CrtDbgBreak()

#else

#define ASSERT(x)
#define breakpoint

#endif

#include <noncom.h>
#include <winscard.h>
#include <scardlib.h>
#include <scardssp.h>

extern LPUNKNOWN NewObject(REFCLSID rclsid, REFIID riid);

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9AEC1AF7_19F1_11D3_A11F_00C04F79F800__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\typeconv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       TypeConv.cpp
//
//--------------------------------------------------------------------------

// TypeConv.cpp : Implementation of CSCardTypeConv
#include "stdafx.h"
#include "ByteBuffer.h"
#include "TypeConv.h"

/////////////////////////////////////////////////////////////////////////////
// CSCardTypeConv

STDMETHODIMP
CSCardTypeConv::ConvertByteArrayToByteBuffer(
    /* [in] */ LPBYTE pbyArray,
    /* [in] */ DWORD dwArraySize,
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuffer)
{
    HRESULT hReturn = S_OK;

    try
    {
        HRESULT hr;

        if (NULL == *ppbyBuffer)
        {
            *ppbyBuffer = NewByteBuffer();
            if (NULL == *ppbyBuffer)
                throw (HRESULT)E_OUTOFMEMORY;
        }
        hr = (*ppbyBuffer)->Initialize();
        if (FAILED(hr))
            throw hr;
        hr = (*ppbyBuffer)->Write(pbyArray, dwArraySize, NULL);
        if (FAILED(hr))
            throw hr;
        hr = (*ppbyBuffer)->Seek(0, STREAM_SEEK_SET, NULL);
        if (FAILED(hr))
            throw hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::ConvertByteBufferToByteArray(
    /* [in] */ LPBYTEBUFFER pbyBuffer,
    /* [retval][out] */ LPBYTEARRAY __RPC_FAR *ppArray)
{
    HRESULT hReturn = S_OK;

    try
    {
        HRESULT hr;
        LONG nLen;
        BOOL fSts;
        DWORD dwSts;

        hr = pbyBuffer->Seek(0, STREAM_SEEK_END, &nLen);
        if (FAILED(hr))
            throw hr;
        hr = pbyBuffer->Seek(0, STREAM_SEEK_SET, NULL);
        if (FAILED(hr))
            throw hr;

        if (NULL == (*ppArray)->hMem)
            (*ppArray)->hMem = GlobalAlloc(GMEM_MOVEABLE, nLen);
        else
        {
            fSts = GlobalUnlock((*ppArray)->hMem);
            if (!fSts)
            {
                dwSts = GetLastError();
                if (NO_ERROR != dwSts)
                    throw (HRESULT)HRESULT_FROM_WIN32(dwSts);
            }
            else
                throw (HRESULT)E_HANDLE;
            (*ppArray)->hMem = GlobalReAlloc((*ppArray)->hMem, nLen, 0);
        }
        if (NULL == (*ppArray)->hMem)
            throw (HRESULT)HRESULT_FROM_WIN32(GetLastError());
        (*ppArray)->pbyData = (LPBYTE)GlobalLock((*ppArray)->hMem);
        (*ppArray)->dwSize = nLen;
        if (NULL == (*ppArray)->pbyData)
            throw (HRESULT)HRESULT_FROM_WIN32(GetLastError());

        hr = pbyBuffer->Read(
                    (*ppArray)->pbyData,
                    nLen,
                    &nLen);
        if (FAILED(hr))
            throw hr;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::ConvertByteBufferToSafeArray(
    /* [in] */ LPBYTEBUFFER pbyBuffer,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppbyArray)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?TODO? Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::ConvertSafeArrayToByteBuffer(
    /* [in] */ LPSAFEARRAY pbyArray,
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuff)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?TODO? Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::CreateByteArray(
    /* [in] */ DWORD dwAllocSize,
    /* [retval][out] */ LPBYTE __RPC_FAR *ppbyArray)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?TODO? Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::CreateByteBuffer(
    /* [in] */ DWORD dwAllocSize,
    /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuff)
{
    HRESULT hReturn = S_OK;

    try
    {
        *ppbyBuff = NewByteBuffer();
        if (NULL == *ppbyBuff)
            throw (HRESULT)E_OUTOFMEMORY;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::CreateSafeArray(
    /* [in] */ UINT nAllocSize,
    /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppArray)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?TODO? Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::FreeIStreamMemoryPtr(
    /* [in] */ LPSTREAM pStrm,
    /* [in] */ LPBYTE pMem)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?TODO? Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::GetAtIStreamMemory(
    /* [in] */ LPSTREAM pStrm,
    /* [retval][out] */ LPBYTEARRAY __RPC_FAR *ppMem)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?TODO? Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}

STDMETHODIMP
CSCardTypeConv::SizeOfIStream(
    /* [in] */ LPSTREAM pStrm,
    /* [retval][out] */ ULARGE_INTEGER __RPC_FAR *puliSize)
{
    HRESULT hReturn = S_OK;

    try
    {
        // ?TODO? Add your implementation code here
        breakpoint;
        hReturn = E_NOTIMPL;
    }

    catch (HRESULT hError)
    {
        hReturn = hError;
    }
    catch (...)
    {
        hReturn = E_INVALIDARG;
    }

    return hReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\newssp\scardssp\typeconv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       TypeConv.h
//
//--------------------------------------------------------------------------

// TypeConv.h : Declaration of the CSCardTypeConv

#ifndef __SCARDTYPECONV_H_
#define __SCARDTYPECONV_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSCardTypeConv
class ATL_NO_VTABLE CSCardTypeConv :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSCardTypeConv, &CLSID_CSCardTypeConv>,
    public IDispatchImpl<ISCardTypeConv, &IID_ISCardTypeConv, &LIBID_SCARDSSPLib>
{
public:
    CSCardTypeConv()
    {
        m_pUnkMarshaler = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SCARDTYPECONV)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSCardTypeConv)
    COM_INTERFACE_ENTRY(ISCardTypeConv)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

// ISCardTypeConv
public:
    STDMETHOD(ConvertByteArrayToByteBuffer)(
        /* [in] */ LPBYTE pbyArray,
        /* [in] */ DWORD dwArraySize,
        /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuffer);

    STDMETHOD(ConvertByteBufferToByteArray)(
        /* [in] */ LPBYTEBUFFER pbyBuffer,
        /* [retval][out] */ LPBYTEARRAY __RPC_FAR *ppArray);

    STDMETHOD(ConvertByteBufferToSafeArray)(
        /* [in] */ LPBYTEBUFFER pbyBuffer,
        /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppbyArray);

    STDMETHOD(ConvertSafeArrayToByteBuffer)(
        /* [in] */ LPSAFEARRAY pbyArray,
        /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuff);

    STDMETHOD(CreateByteArray)(
        /* [in] */ DWORD dwAllocSize,
        /* [retval][out] */ LPBYTE __RPC_FAR *ppbyArray);

    STDMETHOD(CreateByteBuffer)(
        /* [in] */ DWORD dwAllocSize,
        /* [retval][out] */ LPBYTEBUFFER __RPC_FAR *ppbyBuff);

    STDMETHOD(CreateSafeArray)(
        /* [in] */ UINT nAllocSize,
        /* [retval][out] */ LPSAFEARRAY __RPC_FAR *ppArray);

    STDMETHOD(FreeIStreamMemoryPtr)(
        /* [in] */ LPSTREAM pStrm,
        /* [in] */ LPBYTE pMem);

    STDMETHOD(GetAtIStreamMemory)(
        /* [in] */ LPSTREAM pStrm,
        /* [retval][out] */ LPBYTEARRAY __RPC_FAR *ppMem);

    STDMETHOD(SizeOfIStream)(
        /* [in] */ LPSTREAM pStrm,
        /* [retval][out] */ ULARGE_INTEGER __RPC_FAR *puliSize);
};

inline CSCardTypeConv *
NewSCardTypeConv(
    void)
{
    return (CSCardTypeConv *)NewObject(CLSID_CSCardTypeConv, IID_ISCardTypeConv);
}

#endif //__SCARDTYPECONV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\sclogon\unicodes.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    unicodes

Abstract:

    This header file describes the CUnicodeString class, useful for converting
    string types.

Author:

    Doug Barlow (dbarlow) 11/6/1997

Environment:

    Win32, C++

Notes:

    ?Notes?

--*/

#ifndef _UNICODES_H_
#define _UNICODES_H_

//
//==============================================================================
//
//  CUnicodeString
//

class CUnicodeString
{
public:

    //  Constructors & Destructor
    CUnicodeString(void);
    CUnicodeString(LPCSTR sz);
    CUnicodeString(LPCWSTR wsz);
    CUnicodeString(PUNICODE_STRING pus);
    ~CUnicodeString();

    //  Properties
    //  Methods
    LPCSTR  Set(LPCSTR sz);
    LPCWSTR Set(LPCWSTR wsz);
    PUNICODE_STRING Set(PUNICODE_STRING pus);
    BOOL Valid(void)
    {
        if (m_fFlags == fNoneGood)
        {
            return(FALSE);
        }
        else
        {
            return(TRUE);
        }
    }

    //  Operators
    LPCSTR operator=(LPCSTR sz)
    { return Set(sz); };
    LPCWSTR operator=(LPCWSTR wsz)
    { return Set(wsz); };
    PUNICODE_STRING operator=(PUNICODE_STRING pus)
    { return Set(pus);};
    operator LPCSTR(void)
    { return Ansi(); };
    operator LPCWSTR(void)
    { return Unicode(); };
    operator PUNICODE_STRING(void);

protected:
    //  Properties
    UNICODE_STRING m_us;
    LPSTR m_szAnsi;
    LPWSTR m_wszUnicode;
    enum {
        fNoneGood = 0,
        fAnsiGood = 1,
        fUnicodeGood = 2,
        fBothGood = 3
    } m_fFlags;

    //  Methods
    LPCWSTR Unicode(void);      // Return the text as a Unicode string.
    LPCSTR Ansi(void);          // Return the text as an Ansi string.
};

#endif // _UNICODES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\sclogon\unicodes.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    unicodes

Abstract:

    This module implements the CUnicodeString class.  This class allows a string
    to automatically convert between PUNICODE_STRING, LPCSTR, and LPCWSTR.

Author:

    Doug Barlow (dbarlow) 11/6/1997

Environment:

    Win32, C++

Notes:

    ?Notes?

--*/

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif
#include <windows.h>
#include <wincrypt.h>
#include <crtdbg.h>
#include "scLogon.h"
#include "unicodes.h"


//
// Piddly routines.
//

CUnicodeString::CUnicodeString(
    void)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
}

CUnicodeString::CUnicodeString(
    LPCSTR sz)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(sz);
}

CUnicodeString::CUnicodeString(
    LPCWSTR wsz)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(wsz);
}

CUnicodeString::CUnicodeString(
    PUNICODE_STRING pus)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(pus);
}

CUnicodeString::~CUnicodeString()
{
    if (NULL != m_szAnsi)
    {
        memset(m_szAnsi, 0, lstrlenA(m_szAnsi));
        LocalFree(m_szAnsi);
    }
    if (NULL != m_wszUnicode)
    {
        memset(m_wszUnicode, 0, lstrlenW(m_wszUnicode)*sizeof(WCHAR));
        LocalFree(m_wszUnicode);
    }
}

PUNICODE_STRING
CUnicodeString::Set(
    PUNICODE_STRING pus)
{
    if (NULL != m_szAnsi)
    {
        LocalFree(m_szAnsi);
        m_szAnsi = NULL;
    }
    if (NULL != m_wszUnicode)
    {
        LocalFree(m_wszUnicode);
        m_wszUnicode = NULL;
    }
    m_fFlags = fNoneGood;
    if (pus != NULL)
    {
        m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, pus->Length + sizeof(WCHAR));
        if (m_wszUnicode != NULL)
        {
            CopyMemory(
                m_wszUnicode,
                pus->Buffer,
                pus->Length
                );
            m_wszUnicode[pus->Length/sizeof(WCHAR)] = L'\0';
            m_fFlags = fUnicodeGood;
        }
    }
    return pus;
}


/*++

Set:

    These methods initialize the object to a given string.

Arguments:

    sz - Supplies an ANSI string with which to initialize the object.

    wsz - Supplies a UNICODE string with which to initialize the object.

    pus - Supplies a pointer to a UNICODE_STRING structure from which to
        initialize the object.

Return Value:

    The same value as was provided.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCSTR
CUnicodeString::Set(
    LPCSTR sz)
{
    if (NULL != m_wszUnicode)
    {
        LocalFree(m_wszUnicode);
        m_wszUnicode = NULL;
    }
    if (NULL != m_szAnsi)
        LocalFree(m_szAnsi);
    m_fFlags = fNoneGood;

    m_szAnsi = (LPSTR)LocalAlloc(LPTR, (lstrlenA(sz) + 1) * sizeof(CHAR));
    if (NULL != m_szAnsi)
    {
        lstrcpyA(m_szAnsi, sz);
        m_fFlags = fAnsiGood;
    }
    return m_szAnsi;
}

LPCWSTR
CUnicodeString::Set(
    LPCWSTR wsz)
{
    if (NULL != m_szAnsi)
    {
        LocalFree(m_szAnsi);
        m_szAnsi = NULL;
    }
    if (NULL != m_wszUnicode)
        LocalFree(m_wszUnicode);
    m_fFlags = fNoneGood;
    m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, (lstrlenW(wsz) + 1) * sizeof(WCHAR));
    if (m_wszUnicode != NULL)
    {
        lstrcpyW(m_wszUnicode, wsz);
        m_fFlags = fUnicodeGood;
    }
    return m_wszUnicode;
}

CUnicodeString::operator PUNICODE_STRING(
    void)
{
    m_us.Buffer = (LPWSTR)Unicode();
    m_us.Length = m_us.MaximumLength = (USHORT)(lstrlenW(m_us.Buffer) * sizeof(WCHAR));
    return &m_us;
}


/*++

Unicode:

    This method ensures that the object has a valaid internal UNICODE
    representation.

Arguments:

    None

Return Value:

    The represented string, in UNICODE format.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCWSTR
CUnicodeString::Unicode(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fAnsiGood:
        // The ANSI value is good.  Convert it to Unicode.
        _ASSERTE(NULL != m_szAnsi);
        length =
            MultiByteToWideChar(
                GetACP(),
                MB_PRECOMPOSED,
                m_szAnsi,
                -1,
                NULL,
                0);
        if (NULL != m_wszUnicode)
        {
            LocalFree(m_wszUnicode);
        }
        if (0 != length)
        {
            m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, (length + 1) * sizeof(WCHAR));
            if (m_wszUnicode == NULL)
            {
                break;
            }
            length =
                MultiByteToWideChar(
                    GetACP(),
                    MB_PRECOMPOSED,
                    m_szAnsi,
                    -1,
                    m_wszUnicode,
                    length);
            m_wszUnicode[length] = 0;
        }
        else
        {
            m_wszUnicode = NULL;
        }
        m_fFlags = fBothGood;
        break;

    case fUnicodeGood:
    case fBothGood:
        // The Unicode value is good.  Just return that.
        break;

    case fNoneGood:
    default:
        // Internal error.
        _ASSERT(FALSE);
        break;
    }
    return m_wszUnicode;
}


/*++

Ansi:

    This method ensures that the object has a valaid internal ANSI
    representation.

Arguments:

    None

Return Value:

    The represented string, in ANSI format.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCSTR
CUnicodeString::Ansi(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fUnicodeGood:
        // The Unicode buffer is good.  Convert it to ANSI.
        length =
            WideCharToMultiByte(
                GetACP(),
                0,
                m_wszUnicode,
                -1,
                NULL,
                0,
                NULL,
                NULL);
        if (NULL != m_szAnsi)
        {
            LocalFree(m_szAnsi);
        }

        if (0 != length)
        {
            m_szAnsi = (LPSTR)LocalAlloc(LPTR, (length + 1) * sizeof(CHAR));
            if (m_szAnsi == NULL)
            {
                break;
            }
            length =
                WideCharToMultiByte(
                    GetACP(),
                    0,
                    m_wszUnicode,
                    -1,
                    m_szAnsi,
                    length,
                    NULL,
                    NULL);
            m_szAnsi[length] = 0;
        }
        else
        {
            m_szAnsi = NULL;
        }
        m_fFlags = fBothGood;
        break;

    case fAnsiGood:
    case fBothGood:
        // The ANSI buffer is good.  We'll return that.
        break;

    case fNoneGood:
    default:
        // An internal error.
        _ASSERT(FALSE);
        break;
    }
    return m_szAnsi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\sclogon2\unicodes.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    unicodes

Abstract:

    This module implements the CUnicodeString class.  This class allows a string
    to automatically convert between PUNICODE_STRING, LPCSTR, and LPCWSTR.

Author:

    Doug Barlow (dbarlow) 11/6/1997

Environment:

    Win32, C++

Notes:

    ?Notes?

--*/

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif
#include <windows.h>
#include <wincrypt.h>
#include <crtdbg.h>
#include "scLogon.h"
#include "unicodes.h"


//
// Piddly routines.
//

CUnicodeString::CUnicodeString(
    void)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
}

CUnicodeString::CUnicodeString(
    LPCSTR sz)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(sz);
}

CUnicodeString::CUnicodeString(
    LPCWSTR wsz)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(wsz);
}

CUnicodeString::CUnicodeString(
    PUNICODE_STRING pus)
{
    m_szAnsi = NULL;
    m_wszUnicode = NULL;
    m_fFlags = fBothGood;
    Set(pus);
}

CUnicodeString::~CUnicodeString()
{
    if (NULL != m_szAnsi)
    {
        memset(m_szAnsi, 0, lstrlenA(m_szAnsi));
        LocalFree(m_szAnsi);
    }
    if (NULL != m_wszUnicode)
    {
        memset(m_wszUnicode, 0, lstrlenW(m_wszUnicode)*sizeof(WCHAR));
        LocalFree(m_wszUnicode);
    }
}

PUNICODE_STRING
CUnicodeString::Set(
    PUNICODE_STRING pus)
{
    if (NULL != m_szAnsi)
    {
        LocalFree(m_szAnsi);
        m_szAnsi = NULL;
    }
    if (NULL != m_wszUnicode)
    {
        LocalFree(m_wszUnicode);
        m_wszUnicode = NULL;
    }
    m_fFlags = fNoneGood;
    if (pus != NULL)
    {
        m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, pus->Length + sizeof(WCHAR));
        if (m_wszUnicode != NULL)
        {
            CopyMemory(
                m_wszUnicode,
                pus->Buffer,
                pus->Length
                );
            m_wszUnicode[pus->Length/sizeof(WCHAR)] = L'\0';
            m_fFlags = fUnicodeGood;
        }
    }
    return pus;
}


/*++

Set:

    These methods initialize the object to a given string.

Arguments:

    sz - Supplies an ANSI string with which to initialize the object.

    wsz - Supplies a UNICODE string with which to initialize the object.

    pus - Supplies a pointer to a UNICODE_STRING structure from which to
        initialize the object.

Return Value:

    The same value as was provided.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCSTR
CUnicodeString::Set(
    LPCSTR sz)
{
    if (NULL != m_wszUnicode)
    {
        LocalFree(m_wszUnicode);
        m_wszUnicode = NULL;
    }
    if (NULL != m_szAnsi)
        LocalFree(m_szAnsi);
    m_fFlags = fNoneGood;

    m_szAnsi = (LPSTR)LocalAlloc(LPTR, (lstrlenA(sz) + 1) * sizeof(CHAR));
    if (NULL != m_szAnsi)
    {
        lstrcpyA(m_szAnsi, sz);
        m_fFlags = fAnsiGood;
    }
    return m_szAnsi;
}

LPCWSTR
CUnicodeString::Set(
    LPCWSTR wsz)
{
    if (NULL != m_szAnsi)
    {
        LocalFree(m_szAnsi);
        m_szAnsi = NULL;
    }
    if (NULL != m_wszUnicode)
        LocalFree(m_wszUnicode);
    m_fFlags = fNoneGood;
    m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, (lstrlenW(wsz) + 1) * sizeof(WCHAR));
    if (m_wszUnicode != NULL)
    {
        lstrcpyW(m_wszUnicode, wsz);
        m_fFlags = fUnicodeGood;
    }
    return m_wszUnicode;
}

CUnicodeString::operator PUNICODE_STRING(
    void)
{
    m_us.Buffer = (LPWSTR)Unicode();
    m_us.Length = m_us.MaximumLength = (USHORT)(lstrlenW(m_us.Buffer) * sizeof(WCHAR));
    return &m_us;
}


/*++

Unicode:

    This method ensures that the object has a valaid internal UNICODE
    representation.

Arguments:

    None

Return Value:

    The represented string, in UNICODE format.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCWSTR
CUnicodeString::Unicode(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fAnsiGood:
        // The ANSI value is good.  Convert it to Unicode.
        _ASSERTE(NULL != m_szAnsi);
        length =
            MultiByteToWideChar(
                GetACP(),
                MB_PRECOMPOSED,
                m_szAnsi,
                -1,
                NULL,
                0);
        if (NULL != m_wszUnicode)
        {
            LocalFree(m_wszUnicode);
        }
        if (0 != length)
        {
            m_wszUnicode = (LPWSTR)LocalAlloc(LPTR, (length + 1) * sizeof(WCHAR));
            if (m_wszUnicode == NULL)
            {
                break;
            }
            length =
                MultiByteToWideChar(
                    GetACP(),
                    MB_PRECOMPOSED,
                    m_szAnsi,
                    -1,
                    m_wszUnicode,
                    length);
            m_wszUnicode[length] = 0;
        }
        else
        {
            m_wszUnicode = NULL;
        }
        m_fFlags = fBothGood;
        break;

    case fUnicodeGood:
    case fBothGood:
        // The Unicode value is good.  Just return that.
        break;

    case fNoneGood:
    default:
        // Internal error.
        _ASSERT(FALSE);
        break;
    }
    return m_wszUnicode;
}


/*++

Ansi:

    This method ensures that the object has a valaid internal ANSI
    representation.

Arguments:

    None

Return Value:

    The represented string, in ANSI format.

Author:

    Doug Barlow (dbarlow) 11/6/1997

--*/

LPCSTR
CUnicodeString::Ansi(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fUnicodeGood:
        // The Unicode buffer is good.  Convert it to ANSI.
        length =
            WideCharToMultiByte(
                GetACP(),
                0,
                m_wszUnicode,
                -1,
                NULL,
                0,
                NULL,
                NULL);
        if (NULL != m_szAnsi)
        {
            LocalFree(m_szAnsi);
        }

        if (0 != length)
        {
            m_szAnsi = (LPSTR)LocalAlloc(LPTR, (length + 1) * sizeof(CHAR));
            if (m_szAnsi == NULL)
            {
                break;
            }
            length =
                WideCharToMultiByte(
                    GetACP(),
                    0,
                    m_wszUnicode,
                    -1,
                    m_szAnsi,
                    length,
                    NULL,
                    NULL);
            m_szAnsi[length] = 0;
        }
        else
        {
            m_szAnsi = NULL;
        }
        m_fFlags = fBothGood;
        break;

    case fAnsiGood:
    case fBothGood:
        // The ANSI buffer is good.  We'll return that.
        break;

    case fNoneGood:
    default:
        // An internal error.
        _ASSERT(FALSE);
        break;
    }
    return m_szAnsi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\sclogon\sclogon.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ScLogon

Abstract:

    This module provides helper functions for use by winlogon (GINA, Kerberos)

Author:

    Amanda Matlosz (amatlosz) 10/22/1997

Environment:

    Win32, C++ w/ Exceptions

Notes:

        03-11-98 Wrap calls to GetLastError() to workaround bug where LastErr gets
                        clobbered.  Added event logging to make logon smoother.

                04-02-98 Removed all references to WinVerifyTrust; this is something
                                                Kerberos itself is responsible for.
--*/

/////////////////////////////////////////////////////////////////////////////
//
// Includes

#if !defined(_AMD64_) && !defined(_X86_) && !defined(_IA64_)
#define _X86_ 1
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#ifndef UNICODE
#define UNICODE
#endif
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}

#include <windows.h>
#include <winscard.h>
#include <wincrypt.h>
#include <softpub.h>
#include <stddef.h>
#include <crtdbg.h>
#include "sclogon.h"
#include "unicodes.h"
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <tchar.h>

#ifndef KP_KEYEXCHANGE_PIN
#define KP_KEYEXCHANGE_PIN 32
#else
#if 32 != KP_KEYEXCHANGE_PIN
#error Invalid KP_KEYEXCHANGE_PIN assumption
#endif
#endif
#ifndef CRYPT_SILENT
#define CRYPT_SILENT 0x40
#else
#if 0x40 != CRYPT_SILENT
#error Duplicate CRYPT_SILENT definition
#endif
#endif
#ifndef SCARD_PROVIDER_CSP
#define SCARD_PROVIDER_CSP 2
#else
#if 2 != SCARD_PROVIDER_CSP
#error Invalid SCARD_PROVIDER_CSP definition
#endif
#endif

#if defined(DBG) || defined(DEBUG)
BOOL SCDebug = TRUE;
#define DebugPrint(a) _DebugPrint a
void
__cdecl
_DebugPrint(
    LPCSTR szFormat,
    ...
    )
{
    if (SCDebug) {
        CHAR szBuffer[512];
        va_list ap;

        va_start(ap, szFormat);
        vsprintf(szBuffer, szFormat, ap);
        OutputDebugStringA(szBuffer);
    }
}
#else
#define DebugPrint(a)
#endif

// TODO: The following logging is still proving useful.
// TODO: leave in for B3: integrate more tightly w/ winlogon/kerberos ??
#include <sclmsg.h>

// A Global class used to maintain internal state.
class CSCLogonInit
{
public:
    // Runs at image creation
    CSCLogonInit(
        BOOL *pfResult)
    {
        m_hCrypt = NULL;
        *pfResult = TRUE;
    };

    // Runs at image termination
    ~CSCLogonInit()
    {
        Release();
    };

    // Cleans up current state.
    void
    Release(
        void)
    {
        if (NULL != m_hCrypt)
        {
            CryptReleaseContext(m_hCrypt, 0);
            m_hCrypt = NULL;
        }
    }

    // Relinquish control of the crypto context.
    HCRYPTPROV
    RelinquishCryptCtx(
        LogonInfo* pLogon)
    {
        HCRYPTPROV hProv;

        hProv = CryptCtx(pLogon);
        m_hCrypt = NULL;
        return hProv;
    };

    // Get the crypto context, creating it if it's not there.
    HCRYPTPROV
    CryptCtx(
        LogonInfo* pLogon)
    {
        HCRYPTPROV hProv;
        LPCTSTR szRdr = NULL;
        LPCTSTR szCntr = NULL;
        LPTSTR szFQCN = NULL;
        LONG lLen = 0;

        if (NULL == m_hCrypt)
        {
            BOOL fSts;

            // Prepare FullyQualifiedContainerName for CryptAcCntx call

            szRdr = GetReaderName((LPBYTE)pLogon);
            szCntr = GetContainerName((LPBYTE)pLogon);

            lLen = (lstrlen(szRdr) + lstrlen(szCntr) + 10)*sizeof(TCHAR);
            szFQCN = (LPTSTR)LocalAlloc(LPTR, lLen);
            if (NULL != szFQCN)
            {
                wsprintf(szFQCN, TEXT("\\\\.\\%s\\%s"), szRdr, szCntr);

                fSts = CryptAcquireContext(
                    &m_hCrypt,
                    szFQCN,
                    GetCSPName((LPBYTE)pLogon),
                    PROV_RSA_FULL,  // ?TODO? from pbLogonInfo
                    CRYPT_SILENT | CRYPT_MACHINE_KEYSET
                    );

                LocalFree(szFQCN);
            }
            else
            {
                fSts = FALSE;
            }
        }
        hProv = m_hCrypt;
        return hProv;
    }

protected:
    HCRYPTPROV m_hCrypt;
};

// For tracing errors in ScHelper*

NTSTATUS LogEvent(NTSTATUS NtErr, DWORD dwEventID)
{
    DWORD dwErr;
    //
    // Convert the error back to a Win32 error
    //
    switch (NtErr)
    {
    case STATUS_INVALID_PARAMETER:
        dwErr = ERROR_INVALID_DATA;
        break;

    case STATUS_SMARTCARD_SUBSYSTEM_FAILURE:
            // A Cryptxxx API just failed
        dwErr = GetLastError();
        switch (dwErr)
        {
        case SCARD_W_WRONG_CHV:
        case SCARD_E_INVALID_CHV:
            NtErr = STATUS_SMARTCARD_WRONG_PIN;
            break;

        case SCARD_W_CHV_BLOCKED:
            NtErr = STATUS_SMARTCARD_CARD_BLOCKED;
            break;

        case SCARD_W_REMOVED_CARD:
        case SCARD_E_NO_SMARTCARD:
            NtErr = STATUS_SMARTCARD_NO_CARD;
            break;

        case NTE_BAD_KEYSET:
        case NTE_KEYSET_NOT_DEF:
            NtErr = STATUS_SMARTCARD_NO_KEY_CONTAINER;
            break;

        case SCARD_E_NO_SUCH_CERTIFICATE:
        case SCARD_E_CERTIFICATE_UNAVAILABLE:
            NtErr = STATUS_SMARTCARD_NO_CERTIFICATE;
            break;

        case NTE_NO_KEY:
            NtErr = STATUS_SMARTCARD_NO_KEYSET;
            break;

        case SCARD_E_TIMEOUT:
        case SCARD_F_COMM_ERROR:
        case SCARD_E_COMM_DATA_LOST:
            NtErr = STATUS_SMARTCARD_IO_ERROR;
            break;

        //default:
            // Nothing, leave NtErr unchanged
        }
        break;

    case STATUS_INSUFFICIENT_RESOURCES:
    case STATUS_NO_MEMORY:
        dwErr = ERROR_OUTOFMEMORY;
        break;

    case STATUS_BUFFER_TOO_SMALL:
        dwErr = SEC_E_BUFFER_TOO_SMALL;
        break;

    default:
        dwErr = SCARD_E_UNEXPECTED;
    }

    if (0 == dwErr)
    {
        return NtErr;
    }

    //
    // Initialize log as necessary
    //
    HKEY    hKey;
    DWORD   disp;

    long err = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Services\\EventLog\\Application\\Smart Card Logon"),
        0,
        TEXT(""),
        REG_OPTION_NON_VOLATILE,
        KEY_WRITE,
        NULL,
        &hKey,
        &disp
        );

    if (ERROR_SUCCESS != err)
    {
        return NtErr;
    }

    if (disp == REG_CREATED_NEW_KEY)
    {
        PBYTE l_szModulePath = (PBYTE)TEXT("%SystemRoot%\\System32\\scarddlg.dll");
        ULONG l_uLen = (_tcslen((LPCTSTR)l_szModulePath) + 1)*sizeof(TCHAR);

        RegSetValueEx(
            hKey,
            TEXT("EventMessageFile"),
            0,
            REG_EXPAND_SZ,
            l_szModulePath,
            l_uLen
            );

        disp = (DWORD)(
            EVENTLOG_ERROR_TYPE |
            EVENTLOG_WARNING_TYPE |
            EVENTLOG_INFORMATION_TYPE
            );

        RegSetValueEx(
            hKey,
            TEXT("TypesSupported"),
            0,
            REG_DWORD,
            (PBYTE) &disp,
            sizeof(DWORD)
            );
    }

    RegCloseKey(hKey);

    HANDLE hEventSource = RegisterEventSource(
        NULL,
        TEXT("Smart Card Logon")
        );

    if (NULL != hEventSource)
    {
        DWORD dwLen = 0;
        LPTSTR szErrorString = NULL;
        TCHAR szBuffer[2+8+1];  // Enough for "0x????????"

        dwLen = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwErr,
                LANG_NEUTRAL,
                (LPTSTR)&szErrorString,
                0,
                NULL);

        if (dwLen == 0)
        {
            _stprintf(szBuffer, _T("0x%08lX"), dwErr);
            szErrorString = szBuffer;
        }

        ReportEvent(
            hEventSource,
            EVENTLOG_ERROR_TYPE,
            0,              // event category
            dwEventID,      // event identifier // resourceID for the messagetable entry...
            NULL,           // user security identifier (optional)
            1,              // number of strings to merge with message
            sizeof(long),   // size of binary data, in bytes
            (LPCTSTR*)&szErrorString,   // array of strings to merge with message
            (LPVOID)&dwErr   // address of binary data
            );

        DeregisterEventSource(hEventSource);

        if ((NULL != szErrorString) && (szErrorString != szBuffer))
        {
            LocalFree((LPVOID)szErrorString);
        }

    }

    return NtErr;
}


//////////////////////////////////////////////////////////////////////////////
//
// Structs



//////////////////////////////////////////////////////////////////////////////
//
// Functions
//

// Internal helpers: called by the ScLogon APIs to perform certain tedious work

/*++

GetReaderName:
GetCardName:
GetContainerName:
GetCSPName:

  : Intended for accessing the LogonInformation glob

Author:

        Amanda Matlosz

Note:

  Some of these are made available to outside callers; see sclogon.h

--*/

extern "C"
PBYTE
WINAPI
ScBuildLogonInfo(
    LPCTSTR szCard,
    LPCTSTR szReader,
    LPCTSTR szContainer,
    LPCTSTR szCSP)
{
    // No assumptions are made regarding the values of the incoming parameters;
    // At this point, it is legal for them all to be empty.
    // It is also possible that NULL values are being passed in -- if this is the case,
    // they must be replaced with empty strings.

    LPCTSTR szCardI = TEXT("");
    LPCTSTR szReaderI = TEXT("");
    LPCTSTR szContainerI = TEXT("");
    LPCTSTR szCSPI = TEXT("");

    if (NULL != szCard)
    {
        szCardI = szCard;
    }
    if (NULL != szReader)
    {
        szReaderI = szReader;
    }
    if (NULL != szContainer)
    {
        szContainerI = szContainer;
    }
    if (NULL != szCSP)
    {
        szCSPI = szCSP;
    }


    //
    // Build the LogonInfo glob using strings (or empty strings)
    //

    DWORD cbLi = offsetof(LogonInfo, bBuffer)
                 + (lstrlen(szCardI) + 1) * sizeof(TCHAR)
                 + (lstrlen(szReaderI) + 1) * sizeof(TCHAR)
                 + (lstrlen(szContainerI) + 1) * sizeof(TCHAR)
                 + (lstrlen(szCSPI) + 1) * sizeof(TCHAR);
    LogonInfo* pLI = (LogonInfo*)LocalAlloc(LPTR, cbLi);

    if (NULL == pLI)
    {
        return NULL;
    }

    pLI->ContextInformation = NULL;
    pLI->dwLogonInfoLen = cbLi;
    LPTSTR pBuffer = pLI->bBuffer;

    pLI->nCardNameOffset = 0;
    lstrcpy(pBuffer, szCardI);
    pBuffer += (lstrlen(szCardI)+1);

    pLI->nReaderNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szReaderI);
    pBuffer += (lstrlen(szReaderI)+1);

    pLI->nContainerNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szContainerI);
    pBuffer += (lstrlen(szContainerI)+1);

    pLI->nCSPNameOffset = (ULONG) (pBuffer-pLI->bBuffer);
    lstrcpy(pBuffer, szCSPI);
    pBuffer += (lstrlen(szCSPI)+1);

    _ASSERTE(cbLi == (DWORD)((LPBYTE)pBuffer - (LPBYTE)pLI));
    return (PBYTE)pLI;
}


LPCTSTR WINAPI GetReaderName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nReaderNameOffset];
};

LPCTSTR WINAPI GetCardName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nCardNameOffset];
};

LPCTSTR WINAPI GetContainerName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nContainerNameOffset];
};

LPCTSTR WINAPI GetCSPName(PBYTE pbLogonInfo)
{
    LogonInfo* pLI = (LogonInfo*)pbLogonInfo;

    if (NULL == pLI)
    {
        return NULL;
    }
    return &pLI->bBuffer[pLI->nCSPNameOffset];
};

/*++
BuildCertContext:

  Generates a certificate context with (static) keyprov info suitable for
  CertStore-based operations.

        If the PIN is provided, it is assumed the hProv (if provided) has not had the
        PIN parameter set...



Arguments:

    hProv -- must be a valid HCRYPTPROV

    pucPIN -- may be empty; used to set the PIN for hProv

    pbCert -- assumed to be a valid certificate; must not be NULL
    dwCertLen

    CertificateContext -- pointer to a pointer to the resultant CertContext

Return Value:

        NTSTATUS indicating STATUS_SUCCESS or error (see winerror.h or scarderr.h)

Author:

        Amanda Matlosz

Note:

--*/
NTSTATUS
BuildCertContext(
    IN HCRYPTPROV hProv,
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbCert,
    IN DWORD dwCertLen,
    OUT PCCERT_CONTEXT *CertificateContext
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    BOOL fSts = FALSE;

    CRYPT_KEY_PROV_INFO KeyProvInfo;
    LPSTR szContainerName = NULL;
    LPSTR szProvName = NULL;
    CUnicodeString wszContainerName, wszProvName;
    DWORD cbContainerName, cbProvName;

    //
    // Check params
    //
    if ((NULL == hProv) || (NULL == pbCert || 0 == dwCertLen))
    {
        ASSERT(FALSE);
        lResult = STATUS_INVALID_PARAMETER;
        goto ErrorExit;
    }

    //
    // Convert the certificate into a Cert Context.
    //
    *CertificateContext = CertCreateCertificateContext(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    pbCert,
                    dwCertLen);
    if (NULL == *CertificateContext)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    //  Associate cryptprovider w/ the private key property of this cert
    //

    //  ... need the container name

    fSts = CryptGetProvParam(
            hProv,
            PP_CONTAINER,
            NULL,     // out
            &cbContainerName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    szContainerName = (LPSTR)LocalAlloc(LPTR, cbContainerName);
    if (NULL == szContainerName)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    fSts = CryptGetProvParam(
            hProv,
            PP_CONTAINER,
            (PBYTE)szContainerName,     // out
            &cbContainerName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    wszContainerName = szContainerName;

    //  ... need the provider name

    fSts = CryptGetProvParam(
            hProv,
            PP_NAME,
            NULL,     // out
            &cbProvName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    szProvName = (LPSTR)LocalAlloc(LPTR, cbProvName);
    if (NULL == szProvName)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    fSts = CryptGetProvParam(
            hProv,
            PP_NAME,
            (PBYTE)szProvName,     // out
            &cbProvName,   // in/out
            0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }
    wszProvName = szProvName;

    //
    // Set the cert context properties to reflect the prov info
    //

    KeyProvInfo.pwszContainerName = (LPWSTR)(LPCWSTR)wszContainerName;
    KeyProvInfo.pwszProvName = (LPWSTR)(LPCWSTR)wszProvName;
    KeyProvInfo.dwProvType = PROV_RSA_FULL;
    KeyProvInfo.dwFlags = CERT_SET_KEY_CONTEXT_PROP_ID;
    KeyProvInfo.cProvParam = 0;
    KeyProvInfo.rgProvParam = NULL;
    KeyProvInfo.dwKeySpec = AT_KEYEXCHANGE;
    KeyProvInfo.dwFlags |= CERT_SET_KEY_CONTEXT_PROP_ID;

    fSts = CertSetCertificateContextProperty(
                *CertificateContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                0,
                (void *)&KeyProvInfo);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;

        // the cert's been incorrectly created -- scrap it.
        CertFreeCertificateContext(*CertificateContext);
        *CertificateContext = NULL;

        goto ErrorExit;
    }

    CERT_KEY_CONTEXT certKeyContext;
    certKeyContext.cbSize = sizeof(CERT_KEY_CONTEXT);
    certKeyContext.hCryptProv = hProv;
    certKeyContext.dwKeySpec = KeyProvInfo.dwKeySpec;

    fSts = CertSetCertificateContextProperty(
                *CertificateContext,
                CERT_KEY_CONTEXT_PROP_ID,
                0,
                (void *)&certKeyContext);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;

        // the cert's been incorrectly created -- scrap it.
        CertFreeCertificateContext(*CertificateContext);
        *CertificateContext = NULL;

        goto ErrorExit;
    }

ErrorExit:

    if(NULL != szContainerName)
    {
        LocalFree(szContainerName);
        szContainerName = NULL;
    }
    if(NULL != szProvName)
    {
        LocalFree(szProvName);
        szProvName = NULL;
    }

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_BUILDCC);
    }

    return lResult;
}


///////////////////////////////////////////////////////////////////////////////
//
// ScLogon APIs
//


/*++

ScHelperInitializeContext:

        Prepares contextual information to be used by LSA while handling this
        smart card session.

Arguments:

        None.

Return Value:

        None

Author:

        Richard Ward

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperInitializeContext(
    IN OUT PBYTE pbLogonInfo,
    IN ULONG cbLogonInfo
    )
{
    ULONG AllowedSize;

    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    if ((cbLogonInfo < sizeof(ULONG)) ||
        (cbLogonInfo != pLI->dwLogonInfoLen))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    AllowedSize = (cbLogonInfo - sizeof(LogonInfo) ) / sizeof(TCHAR) + sizeof(DWORD) ;
    //
    // Verify the other fields of the logon info
    //
    if ((pLI->nCardNameOffset > pLI->nReaderNameOffset) ||
        (pLI->bBuffer[pLI->nReaderNameOffset-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if ((pLI->nReaderNameOffset > pLI->nContainerNameOffset) ||
        (pLI->bBuffer[pLI->nContainerNameOffset-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if ((pLI->nContainerNameOffset > pLI->nCSPNameOffset) ||
        (pLI->bBuffer[pLI->nCSPNameOffset-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if ((pLI->nCSPNameOffset > AllowedSize) ||
        (pLI->bBuffer[AllowedSize-1] != TEXT('\0')))
    {
        return(STATUS_INVALID_PARAMETER);
    }


    _ASSERTE(pLI->ContextInformation == NULL);

    BOOL fResult = 0;
    pLI->ContextInformation = new CSCLogonInit(&fResult);
    if (pLI->ContextInformation == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    else
    {
        if (!fResult)
        {
            delete pLI->ContextInformation;
            pLI->ContextInformation = NULL;
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    return(STATUS_SUCCESS);
}

/*++

ScHelperRelease:

        Releases contextual information used by LSA while handling this
        smart card session.

Arguments:

        None.

Return Value:

        None

Author:

        Richard Ward

Note:

        Used by LSA.

--*/
VOID WINAPI
ScHelperRelease(
    IN OUT PBYTE pbLogonInfo
    )
{
    _ASSERTE(NULL != pbLogonInfo);
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;

    if (LogonInit != NULL)
    {
        LogonInit->Release();
        delete LogonInit;
        pLI->ContextInformation = NULL;
    }
}


/*++

ScHelperGetCertFromLogonInfo:

        Returns a CertificateContext for the cert on the card specified by the
        LogonInfo.  Creates the cert context by calling BuildCertContext,
        which generates a certificate context with (static) keyprov info
        suitable for CertStore-based operations.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        None

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperGetCertFromLogonInfo(
    IN PBYTE pbLogonInfo,
    IN PUNICODE_STRING pucPIN,
    OUT PCCERT_CONTEXT *CertificateContext
    )
{
    _ASSERTE(NULL != pbLogonInfo);
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    BOOL fSts;
    NTSTATUS lResult = STATUS_SUCCESS;
    PCCERT_CONTEXT pCertCtx = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    LPBYTE pbCert = NULL;
    DWORD cbCertLen;

    //
    // Make sure we've got a Crypto Provider up and running.
    //
    hProv = LogonInit->RelinquishCryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // Get the key handle.
    //
    fSts = CryptGetUserKey(
                hProv,
                AT_KEYEXCHANGE,
                &hKey);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // Upload the certificate.
    //

    fSts = CryptGetKeyParam(
                hKey,
                KP_CERTIFICATE,
                NULL,
                &cbCertLen,
                0);
    if (!fSts)
    {
        DWORD dwGLE = GetLastError();

        if (ERROR_MORE_DATA != dwGLE)
        {
            if (NTE_NOT_FOUND == dwGLE)
            {
                SetLastError(SCARD_E_NO_SUCH_CERTIFICATE);
            }
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }
    
    pbCert = (LPBYTE)LocalAlloc(LPTR, cbCertLen);
    if (NULL == pbCert)
    {
        lResult = STATUS_NO_MEMORY;
        goto ErrorExit;
    }
    fSts = CryptGetKeyParam(
                hKey,
                KP_CERTIFICATE,
                pbCert,
                &cbCertLen,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    lResult = BuildCertContext(
        hProv,
        pucPIN,
        pbCert,
        cbCertLen,
        &pCertCtx);
    if (NT_SUCCESS(lResult))
    {
        // The cert context will take care of the crypt context now.
        hProv = NULL;
    }

    //
    // Clean up and return.
    //

ErrorExit:
    *CertificateContext = pCertCtx;

        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_GETCERT);
    }

    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if (NULL != pbCert)
    {
        LocalFree(pbCert);
    }

    return lResult;
}

/*++

ScHelperGetProvParam:

        This API wraps the CryptGetProvParam routine for use with a smart card.
Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.


        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.

        The other parameters are identical to CryptGetProvParam


Return Value:

    A STATUS_SUCECSS for success, or an error
--*/

NTSTATUS WINAPI
ScHelperGetProvParam(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    DWORD dwParam,
    BYTE*pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags
    )
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    BOOL fSts;


    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        return LogEvent(STATUS_SMARTCARD_SUBSYSTEM_FAILURE, (DWORD)EVENT_ID_GETPROVPARAM);
    }

    fSts = CryptGetProvParam(
            hProv,
            dwParam,
            pbData,
            pdwDataLen,
            dwFlags
            );

    if (!fSts)
    {
        if (GetLastError() == ERROR_NO_MORE_ITEMS)
        {
            return (STATUS_NO_MORE_ENTRIES);
        }
        else
        {
            return LogEvent(STATUS_SMARTCARD_SUBSYSTEM_FAILURE, (DWORD)EVENT_ID_GETPROVPARAM);
        }
    }
    
    return(STATUS_SUCCESS);    
}


/*++

ScHelperVerifyCard:

        This API provides an easy way to verify the integrity of the card
        identified by pbLogonInfo (ie, that it has the private key associated
        w/ the public key contained in the certificate it returned via
        ScHelperGetCertFromLogonInfo) and, in so doing, authenticates the user
                to the card.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system default
                store.

        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.


Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.
--*/

NTSTATUS WINAPI
ScHelperVerifyCard(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo
    )
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    PBYTE pbBlob = NULL;
    ULONG ulBlobLen = 32;
    PBYTE pbSignature = NULL;
    ULONG ulSigLen = 0;
    BOOL fSts;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // Generate a random key blob as the message to sign
    //

    pbBlob = (LPBYTE)LocalAlloc(LPTR, ulBlobLen);
    if (NULL == pbBlob)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    fSts = CryptGenRandom(hProv, ulBlobLen, pbBlob);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // The card signs a hash of the message...
    //

    lResult = ScHelperSignMessage(
                pucPIN,
                pbLogonInfo,
                NULL,
                CALG_MD5,
                pbBlob,
                ulBlobLen,
                pbSignature,
                &ulSigLen);

    if (STATUS_BUFFER_TOO_SMALL != lResult)
    {
        goto ErrorExit;
    }

    pbSignature = (LPBYTE)LocalAlloc(LPTR, ulSigLen);

    if (NULL == pbSignature)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    lResult = ScHelperSignMessage(
                pucPIN,
                pbLogonInfo,
                NULL,
                CALG_MD5,
                pbBlob,
                ulBlobLen,
                pbSignature,
                &ulSigLen);

    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }

    //
    // Verify the signature is correct
    //

    lResult = ScHelperVerifyMessage(
                pbLogonInfo,
                NULL,
                CertificateContext,
                CALG_MD5,
                pbBlob,
                ulBlobLen,
                pbSignature,
                ulSigLen);

    //
    // Clean up and return.
    //

ErrorExit:

        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_VERIFYCARD);
    }

    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    if (NULL != pbSignature)
    {
        LocalFree(pbSignature);
    }
    if (NULL != pbBlob)
    {
            LocalFree(pbBlob);
    }

    return lResult;
}


NTSTATUS WINAPI
ScHelperGenRandBits(
    IN PBYTE pbLogonInfo,
    IN OUT ScHelper_RandomCredBits* psc_rcb
)
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    BOOL fSts = FALSE;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    memset(psc_rcb, 0, sizeof(*psc_rcb));
    fSts = CryptGenRandom(hProv, 32, psc_rcb->bR1);

    if (fSts)
    {
        fSts = CryptGenRandom(hProv, 32, psc_rcb->bR2);
    }

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
    }

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_GENRANDBITS);
    }

    return lResult;
}


/*++

ScHelperCreateCredKeys:

    This routine (called by ScHelperVerifyCardAndCreds and
    ScHelperEncryptCredentials) munges a R1 and R2 to derive symmetric keys
    for encrypting and decrypting KDC creds, and or genearting an HMAC.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.

        psc_rcb supplies the R1 and R2, previously generated by a call to
                ScHelperGenRandBits.

        phHmacKey recieves the generated HMAC key.

        phRc4Key receives the generated RC4 key.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to EncryptedData to receive only the
    required size of the EncryptedData buffer.

Author:

    Amanda Matlosz (amatlosz) 6/23/1999

--*/

NTSTATUS WINAPI
ScHelperCreateCredKeys(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    IN ScHelper_RandomCredBits* psc_rcb,
    IN OUT HCRYPTKEY* phHmacKey,
    IN OUT HCRYPTKEY* phRc4Key,
    IN OUT HCRYPTPROV* phProv
)
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    HCRYPTPROV hProv = NULL;
    PBYTE pbR1Sig = NULL;
    DWORD dwR1SigLen = 0;
    HCRYPTHASH hKHash = NULL;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CUnicodeString szPin(pucPIN);
    BOOL fSts = FALSE;
    *phProv = NULL;

    // check params

    if (NULL == psc_rcb || NULL == phHmacKey || NULL == phRc4Key)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    // Get hProv for smart card

    if (NULL != pucPIN)
    {
		if (!szPin.Valid())
		{
			return(STATUS_INSUFFICIENT_RESOURCES);
		}
	}

    CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
    hProv = LogonInit->CryptCtx(pLI);
    if (NULL == hProv)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // Sign R1 w/ smart card

    fSts = CryptCreateHash(
        hProv,
        CALG_SHA1,
        NULL,
        NULL,
        &hHash);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
                hHash,
                psc_rcb->bR1,
                32, // TODO: const
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // Declare the PIN.
    //

    if (NULL != pucPIN)
    {
        fSts = CryptSetProvParam(
                hProv,
                PP_KEYEXCHANGE_PIN,
                (LPBYTE)((LPCSTR)szPin),
                0);
        if (!fSts)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    fSts = CryptSignHash(
        hHash,
        AT_KEYEXCHANGE,
        NULL,
        0,
        NULL,
        &dwR1SigLen);
//  if (fSts || ERROR_MORE_DATA != GetLastError())
    if (0 >= dwR1SigLen)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    pbR1Sig = (LPBYTE)LocalAlloc(LPTR, dwR1SigLen);

    if (NULL == pbR1Sig)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    fSts = CryptSignHash(
        hHash,
        AT_KEYEXCHANGE,
        NULL,
        0,
        pbR1Sig,
        &dwR1SigLen);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // TODO: sigR1 is the key to hash R2 with;
    // for now, just hash 'em together; use generic CSP
    fSts = CryptAcquireContext(
        phProv,
        NULL,
        NULL,
        PROV_RSA_FULL,
        CRYPT_VERIFYCONTEXT
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptCreateHash(
        *phProv,
        CALG_SHA1,
        NULL,
        NULL,
        &hKHash
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
        hKHash,
        pbR1Sig,
        dwR1SigLen,
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
        hKHash,
        psc_rcb->bR2,
        32, // TODO: use a const
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // create the rc4 key for the cred&hmac encryption

    fSts = CryptDeriveKey(
        *phProv,
        CALG_RC4, // stream cipher,
        hKHash,
        NULL,
        phRc4Key
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    // create the key for the HMAC from the hash of R1&2

    fSts = CryptDeriveKey(
        *phProv,
        CALG_RC2,
        hKHash,
        NULL,
        phHmacKey
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

ErrorExit:

    //
    // cleanup
    //

    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }

    if (NULL != hKHash)
    {
        CryptDestroyHash(hKHash);
    }

    if (NULL != pbR1Sig)
    {
        LocalFree(pbR1Sig);
    }

    return lResult;
}


NTSTATUS WINAPI
ScHelperCreateCredHMAC(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hHmacKey,
    IN PBYTE CleartextData,
    IN ULONG CleartextDataSize,
    IN OUT PBYTE* ppbHmac,
    IN OUT DWORD* pdwHmacLen
)
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHMAC = NULL;
    HMAC_INFO hmac_info;
    BOOL fSts = FALSE;

    fSts = CryptCreateHash(
        hProv,
        CALG_HMAC,
        hHmacKey,
        NULL,
        &hHMAC
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    memset(&hmac_info, 0, sizeof(HMAC_INFO));
    hmac_info.HashAlgid = CALG_SHA1;

    fSts = CryptSetHashParam(
        hHMAC,
        HP_HMAC_INFO,
        (PBYTE)&hmac_info,
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptHashData(
        hHMAC,
        CleartextData,
        CleartextDataSize,
        NULL);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CryptGetHashParam(
        hHMAC,
        HP_HASHVAL,
        *ppbHmac,
        pdwHmacLen,
        NULL
        );
    if (0 >= *pdwHmacLen)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    *ppbHmac = (PBYTE)LocalAlloc(LPTR, *pdwHmacLen);

    if (NULL == *ppbHmac)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    fSts = CryptGetHashParam(
        hHMAC,
        HP_HASHVAL,
        *ppbHmac,
        pdwHmacLen,
        NULL
        );
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

ErrorExit:

    if (NULL != hHMAC)
    {
        CryptDestroyHash(hHMAC);
    }

    return lResult;
}

/*++

ScHelperVerifyCardAndCreds:

    This routine combines Card Verification and Credential Decryption.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system
                default store.

        pbLogonInfo supplies the information required to identify the card, csp,
                etc.  It cannot be NULL.

        EncryptedData receives the encrypted credential blob.

        EncryptedDataSize supplies the size of the EncryptedData buffer in
            bytes, and receives the actual size of the encrypted blob.

        CleartextData supplies a credential blob to be encrypted.

        CleartextDataSize supplies the size of the blob, in bytes.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to EncryptedData to receive only the
    required size of the EncryptedData buffer.

Author:

    Doug Barlow (dbarlow) 5/24/1999

--*/

NTSTATUS WINAPI
ScHelperVerifyCardAndCreds(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo,
    IN PBYTE EncryptedData,
    IN ULONG EncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;

    // Verify the Card

    lResult = ScHelperVerifyCard(
                pucPIN,
                CertificateContext,
                hCertStore,
                pbLogonInfo);

    // Decrypt the Creds

    if (NT_SUCCESS(lResult))
    {
        lResult = ScHelperDecryptCredentials(
                pucPIN,
                CertificateContext,
                hCertStore,
                pbLogonInfo,
                EncryptedData,
                EncryptedDataSize,
                CleartextData,
                CleartextDataSize);
    }

    return lResult;
}




/*++

ScHelperDecryptCredentials:

    This routine decrypts an encrypted credential blob.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system
                default store.

        EncryptedData supplies the encrypted credential blob.

        EncryptedDataSize supplies the length of the encrypted credential blob,
            in bytes.

        CleartextData receives the decrypted credential blob.

        CleartextDataSize supplies the length of the CleartextData buffer, and
            receives the actual length of returned decrypted credential blob.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to CleartextData to receive only the
    required size of the buffer in CleartextDataSize.


Author:

    Doug Barlow (dbarlow) 5/24/1999

--*/

NTSTATUS WINAPI
ScHelperDecryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo,
    IN PBYTE EncryptedData,
    IN ULONG EncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize)
{
    NTSTATUS lResult = STATUS_SUCCESS;
    PBYTE pbCredBlob = NULL;
    DWORD dwCredBlobSize = 0;
    PBYTE pbHmac = NULL;        // the HMAC stored with the cred blob
    DWORD dwHmacSize = NULL;    // size of HMAC stored with cred blob
    PBYTE pbNewHmac = NULL;     // HMAC generated from cred blob for verify
    DWORD dwNewHmacSize = 0;    // size of gen'd HMAC
    PBYTE pb = NULL;
    DWORD dw = 0;
    PBYTE pbPlainCred = NULL;
    DWORD dwPlainCredSize = 0;
    HCRYPTKEY hHmacKey = NULL;
    HCRYPTKEY hRc4Key = NULL;
    HCRYPTPROV hGenProv = NULL;
    BOOL fSts = FALSE;


    // pull the SCH_RCB out of the EncryptedData blob
    ScHelper_RandomCredBits* psch_rcb = (ScHelper_RandomCredBits*)EncryptedData;
    // and build a private copy of the blob itself
    dwCredBlobSize = EncryptedDataSize - sizeof(ScHelper_RandomCredBits);
    pbCredBlob = (PBYTE)LocalAlloc(LPTR, dwCredBlobSize);
    if (NULL == pbCredBlob)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    pb = EncryptedData + sizeof(ScHelper_RandomCredBits);
    CopyMemory(pbCredBlob, pb, dwCredBlobSize);


    //
    // Fetch the keys we need to decrypt & verify the cred blob
    //

    lResult = ScHelperCreateCredKeys(
                pucPIN,
                pbLogonInfo,
                psch_rcb,
                &hHmacKey,
                &hRc4Key,
                &hGenProv
                );
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    //
    // Decrypt the cred blob
    //

    fSts = CryptDecrypt(
        hRc4Key,
        NULL,
        TRUE,
        NULL,
        pbCredBlob,
        &dwCredBlobSize);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    //
    // pull the HMAC out & verify it
    //

    dwHmacSize = (DWORD)*pbCredBlob;
    pbHmac = pbCredBlob + sizeof(DWORD);
    pbPlainCred = pbCredBlob + dwHmacSize + sizeof(DWORD);
    dwPlainCredSize = dwCredBlobSize - dwHmacSize - sizeof(DWORD);


    lResult = ScHelperCreateCredHMAC(
        hGenProv,
        hHmacKey,
        pbPlainCred,
        dwPlainCredSize,
        &pbNewHmac,
        &dwNewHmacSize);
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
    if (dwNewHmacSize == dwHmacSize)
    {
        for (dw = 0;
            (dw < dwNewHmacSize) && ((BYTE)*(pbHmac+dw)==(BYTE)*(pbNewHmac+dw));
            dw++);
        if (dwNewHmacSize == dw)
        {
            // verification succeeded!
            lResult = STATUS_SUCCESS;
        }
    }
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    //
    // return the decrypted blob or just its length, as necessary
    //

    if ((NULL != CleartextData) && (0 < *CleartextDataSize))
    {
        if (*CleartextDataSize >= dwPlainCredSize)
        {
            CopyMemory(CleartextData, pbPlainCred, dwPlainCredSize);
        }
        else
            lResult = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        lResult = STATUS_BUFFER_TOO_SMALL;
    }
    *CleartextDataSize = dwPlainCredSize;

    //
    // Cleanup and return
    //
ErrorExit:

    if (NULL != pbNewHmac)
    {
        LocalFree(pbNewHmac);
    }

    if (NULL != hHmacKey)
    {
        CryptDestroyKey(hHmacKey);
    }

    if (NULL != hRc4Key)
    {
        CryptDestroyKey(hRc4Key);
    }

    if (NULL != hGenProv)
    {
        CryptReleaseContext(hGenProv, NULL);
    }

    return lResult;
}


/*++

ScHelperEncryptCredentials:

    This routine encrypts a credential blob.

Arguments:

        pucPIN supplies a Unicode string containing the card's PIN.

        CertificateContext supplies the cert context received via
                ScHelperGetCertFromLogonInfo.

        hCertStore supplies the handle of a cert store which contains a CTL to
                use during certificate verification, or NULL to use the system
                default store.

        CleartextData supplies the cleartext credential blob.

        CleartextDataSize supplies the length of the cleartext credential blob,
            in bytes.

        EncryptedData receives the encrypted credential blob.

        EncryptedDataSize supplies the length of the EncryptedData buffer, and
            receives the actual length of returned encrypted credential blob.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    STATUS_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Remarks:

    You may supply a value of NULL to EncryptedData to receive only the
    required size of the buffer in EncryptedDataSize.


Author:

    Doug Barlow (dbarlow) 5/24/1999

--*/


NTSTATUS WINAPI
ScHelperEncryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN ScHelper_RandomCredBits* psch_rcb,
    IN PBYTE pbLogonInfo,
    IN PBYTE CleartextData,
    IN ULONG CleartextDataSize,
    OUT OPTIONAL PBYTE EncryptedData,
    OUT PULONG EncryptedDataSize)
{
    NTSTATUS lResult = STATUS_SUCCESS;

    HCRYPTPROV hProv = NULL;
    BOOL fSts;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    ULONG SignedEncryptedCredSize = 0;
    PBYTE SignedEncryptedCred = NULL; // encrypted cred&sig, !including R1+R2
    HCRYPTKEY hHmacKey = NULL;
    HCRYPTKEY hRc4Key = NULL;
    PBYTE pbHmac = NULL;
    DWORD dwHmacLen = 0;
    PBYTE pbCredsAndHmac  = NULL;
    DWORD dwCredsAndHmacLen = 0;
    DWORD dwEncryptedCredSize = 0;
    PBYTE pb = NULL;

    // parameter checking?


    //
    // do stuff to determine size required for SignedEncryptedCred
    //

    lResult = ScHelperCreateCredKeys(
                pucPIN,
                pbLogonInfo,
                psch_rcb,
                &hHmacKey,
                &hRc4Key,
                &hProv
                );
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }

    // HMAC creds
    lResult = ScHelperCreateCredHMAC(
        hProv,
        hHmacKey,
        CleartextData,
        CleartextDataSize,
        &pbHmac,
        &dwHmacLen);
    if (!NT_SUCCESS(lResult))
    {
        goto ErrorExit;
    }


    // make a buffer with creds and HMAC

    pbCredsAndHmac = NULL;
    dwCredsAndHmacLen = dwHmacLen + CleartextDataSize + sizeof(DWORD);
    pbCredsAndHmac = (PBYTE)LocalAlloc(LPTR, dwCredsAndHmacLen);
    if (NULL == pbCredsAndHmac)
    {
        lResult = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }
    pb = pbCredsAndHmac;
    CopyMemory(pb, &dwHmacLen, sizeof(DWORD));
    pb += sizeof(DWORD);
    CopyMemory(pb, pbHmac, dwHmacLen);
    pb += dwHmacLen;
    CopyMemory(pb, CleartextData, CleartextDataSize);

    // Encrypt creds+HMAC
    dwEncryptedCredSize = dwCredsAndHmacLen;

    // After CryptEncrypt, dwCredsAndHmacLen describes the length of the data
    // to encrypt and dwEncryptedCredSize describes the req'd buffer length

    // TODO: VERIFY THE HANDLING OF dwEncryptedCredSize and dwCresAndHmacLen

    fSts = CryptEncrypt(
        hRc4Key,
        NULL,
        TRUE,
        NULL,
        pbCredsAndHmac,
        &dwEncryptedCredSize,
        dwCredsAndHmacLen
        );
    if (!fSts)
    {
        if (GetLastError() != ERROR_MORE_DATA)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;    
        }                
    }

    //
    // Create the final blob for return, or inform user of size, as necessary
    //

    if ((NULL != EncryptedData) && (0 < *EncryptedDataSize))
    {

        if (*EncryptedDataSize >= dwEncryptedCredSize + sizeof(ScHelper_RandomCredBits))
        {
            // the user gave us enough space for the whole thing.

            // if the previous CryptEncrypt failed with ERROR_MORE_DATA
            // we can now do something about it...
            if (!fSts)
            {
                // resize pbCredsAndHmac
                LocalFree(pbCredsAndHmac);
                pbCredsAndHmac = (PBYTE)LocalAlloc(LPTR, dwCredsAndHmacLen);
                if (NULL == pbCredsAndHmac)
                {
                    lResult = STATUS_INSUFFICIENT_RESOURCES;
                    goto ErrorExit;
                }
                // reset pbCredsAndHmac
                pb = pbCredsAndHmac;
                CopyMemory(pb, &dwHmacLen, sizeof(DWORD));
                pb += sizeof(DWORD);
                CopyMemory(pb, pbHmac, dwHmacLen);
                pb += dwHmacLen;
                CopyMemory(pb, CleartextData, CleartextDataSize);
                // re-encrypt CredsAndHmac
                fSts = CryptEncrypt(
                    hRc4Key,
                    NULL,
                    TRUE,
                    NULL,
                    pbCredsAndHmac,
                    &dwCredsAndHmacLen, // length of data
                    dwEncryptedCredSize // length of buffer
                    );
                if (!fSts)
                {
                    lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                    goto ErrorExit;
                }
            }

            pb = EncryptedData;

            CopyMemory(pb, (PBYTE)psch_rcb, sizeof(ScHelper_RandomCredBits));
            pb += sizeof(ScHelper_RandomCredBits);
            CopyMemory(pb, pbCredsAndHmac, dwCredsAndHmacLen);

        }
        else
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
    }
    else
    {
        lResult = STATUS_BUFFER_TOO_SMALL;
    }
    *EncryptedDataSize = dwEncryptedCredSize + sizeof(ScHelper_RandomCredBits);

ErrorExit:

    // clean up!

    if (NULL != pbCredsAndHmac)
    {
        LocalFree(pbCredsAndHmac);
    }

    if (NULL != pbHmac)
    {
        LocalFree(pbHmac);
    }

    if (NULL != hRc4Key)
    {
        CryptDestroyKey(hRc4Key);
    }

    if (NULL != hHmacKey)
    {
        CryptDestroyKey(hHmacKey);
    }

    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, NULL);
    }

    return lResult;
}


/*++

ScHelperSignMessage:

        ScHelperSignMessage() needs the logoninfo and PIN in order to find the card
        that will do the signing...

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperSignMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT PBYTE Signature,
    OUT PULONG SignatureLength
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTHASH hHash = NULL;
    HCRYPTPROV hProv = NULL;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CUnicodeString szPin(pucPIN);
    BOOL fSts;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
		if (NULL != pucPIN)
		{
			if (!szPin.Valid())
			{
				return(STATUS_INSUFFICIENT_RESOURCES);
			}
		}


        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    //
    // We'll need a hash handle, too.
    //

    fSts = CryptCreateHash(
            hProv,
            Algorithm,
            NULL, // HCRYPTKEY (used for keyed algs, like block ciphers
            0,  // reserved for future use
            &hHash);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // Hash the input data.
    //

    fSts = CryptHashData(
                hHash,
                Buffer,
                BufferLength,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;        
        goto ErrorExit;
    }


    if (!ARGUMENT_PRESENT(Provider))
    {
        //
        // Declare the PIN.
        //

        if (NULL != pucPIN)
        {
            fSts = CryptSetProvParam(
                    hProv,
                    PP_KEYEXCHANGE_PIN,
                    (LPBYTE)((LPCSTR)szPin),
                    0);
            if (!fSts)
            {
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;  
                goto ErrorExit;
            }
        }
    }

    //
    // OK, sign it with the exchange key from the smart card or the supplied signature key. ????
    //

    fSts = CryptSignHash(
                hHash,
                AT_KEYEXCHANGE,
                NULL,
                0,
                Signature,
                SignatureLength);
    if (!fSts)
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
    }

    //
    // All done, clean up and return.
    //

ErrorExit:
        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_SIGNMSG_NOSC:EVENT_ID_SIGNMSG)
            );
    }

    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }

    return lResult;
}


/*++

ScHelperVerifyMessage:

// ScHelperVerifyMessage() returns STATUS_SUCCESS if the signature provided is
// the hash of the buffer encrypted by the owner of the cert.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperVerifyMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    IN PBYTE Signature,
    IN ULONG SignatureLength
    )
{
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    HCRYPTHASH hHash = NULL;
    PCERT_PUBLIC_KEY_INFO pInfo = NULL;
    BOOL fSts;
    NTSTATUS lResult = STATUS_SUCCESS;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;


    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }

    //
    // Convert the certificate handle into a Public Key handle.
    //

    fSts = CryptImportPublicKeyInfo(
                hProv,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &CertificateContext->pCertInfo->SubjectPublicKeyInfo,
                &hKey);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // We'll need a hash handle, too.
    //

    fSts = CryptCreateHash(
                hProv,
                Algorithm,
                NULL, // HCRYPTKEY (used for keyed algs, like block ciphers
                0,  // reserved for future use
                &hHash);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // Hash the input data.
    //

    fSts = CryptHashData(
                hHash,
                Buffer,
                BufferLength,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // So is this signature any good?
    //

    fSts = CryptVerifySignature(
                hHash,
                Signature,
                SignatureLength,
                hKey,
                NULL,
                0);
    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }


    //
    // All done, clean up and return.
    //

ErrorExit:
        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_VERIFYMSG_NOSC:EVENT_ID_VERIFYMSG)
            );
    }

    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }

    return lResult;
}

/*++

ScHelperSignPkcsMessage:

        ScHelperSignMessage() needs the logoninfo and PIN in order to find the card
        that will do the signing...

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperSignPkcsMessage(
    IN OPTIONAL PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT Certificate,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN DWORD dwSignMessageFlags,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE SignedBuffer,
    OUT OPTIONAL PULONG SignedBufferLength
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    BOOL fSts;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CRYPT_SIGN_MESSAGE_PARA Parameter = {0};
    CUnicodeString szPin(pucPIN);
    const BYTE * BufferArray = Buffer;

    if (NULL != pucPIN)
    {
		if (!szPin.Valid())
		{
			return(STATUS_INSUFFICIENT_RESOURCES);
		}
	}

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }

        //
        // Declare the PIN.
        //

        if (NULL != pucPIN)
        {
            fSts = CryptSetProvParam(
                    hProv,
                    PP_KEYEXCHANGE_PIN,
                    (LPBYTE)((LPCSTR)szPin),
                    0);
            if (!fSts)
            {
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                goto ErrorExit;
            }
        }
    }


    //
    // Sign the message
    //

    Parameter.cbSize = sizeof(CRYPT_SIGN_MESSAGE_PARA);
    Parameter.dwMsgEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    Parameter.pSigningCert = Certificate;
    Parameter.HashAlgorithm = *Algorithm;
    Parameter.cMsgCert = 1;
    Parameter.rgpMsgCert = &Certificate;
    Parameter.dwFlags = dwSignMessageFlags;


    fSts = CryptSignMessage(
            &Parameter,
            FALSE,              // no detached signature
            1,                  // one buffer to sign
            &BufferArray,
            &BufferLength,
            SignedBuffer,
            SignedBufferLength);

    if (!fSts)
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        goto ErrorExit;
    }


    //
    // All done, clean up and return.
    //

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_SIGNMSG);
    }

    return lResult;
}


/*++

ScHelperVerifyPkcsMessage:

// ScHelperVerifyMessage() returns STATUS_SUCCESS if the signature provided is
// the hash of the buffer encrypted by the owner of the cert.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

        Amanda Matlosz

Note:

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperVerifyPkcsMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE DecodedBuffer,
    OUT OPTIONAL PULONG DecodedBufferLength,
    OUT OPTIONAL PCCERT_CONTEXT * CertificateContext
    )
{
    CRYPT_VERIFY_MESSAGE_PARA Parameter = {0};
    BOOL fSts;
    NTSTATUS lResult = STATUS_SUCCESS;

    Parameter.cbSize = sizeof(CRYPT_VERIFY_MESSAGE_PARA);
    Parameter.dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    Parameter.hCryptProv = NULL;

    //
    // Indicate that we want to get the certificate from the message
    // cert store.
    //

    Parameter.pfnGetSignerCertificate = NULL;
    fSts = CryptVerifyMessageSignature(
                &Parameter,
                0,              // only check first signer
                Buffer,
                BufferLength,
                DecodedBuffer,
                DecodedBufferLength,
                CertificateContext
                );

    if (!fSts)
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        goto ErrorExit;
    }


    //
    // All done, clean up and return.
    //

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(lResult, (DWORD)EVENT_ID_VERIFYMSG);

    }

    return lResult;
}

/*++

ScHelperEncryptMessage:

    Encrypts a message with the public key associated w/ the provided
        certificate.  The resultant encoding is PKCS-7 compliant.

Arguments:

        pucPIN may need the PIN to get a cert off certain SCs

Return Value:

        "success" or "failure"

Author:

    Amanda Matlosz (AMatlosz) 1-06-98

Note:

        Either pbLogonInfo or Provided must be set; if both are set,
        Provider is used.

        Algorithm expects a CRYPT_ALGORITHM_IDENTIFIER cai;
        If there are no parameters to the alg, cai.Parameters.cbData *must* be 0;

        CALG_RC4, no parameters:
                cai.pszObjId = szOID_RSA_RC4;
                cai.Parameters.cbData = 0;

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperEncryptMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN PBYTE Buffer,                        // The data to encrypt
    IN ULONG BufferLength,                  // The length of that data
    OUT PBYTE CipherText,                   // Receives the formatted CipherText
    IN PULONG pCipherLength                 // Supplies size of CipherText buffer
    )                                       // Receives length of actual CipherText
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    BOOL fSts;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CRYPT_ENCRYPT_MESSAGE_PARA EncryptPara;
    DWORD cbEncryptParaSize = 0;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }
    }


    //
    // Encrypt the message
    //

    cbEncryptParaSize = sizeof(EncryptPara);
    memset(&EncryptPara, 0, cbEncryptParaSize);
    EncryptPara.cbSize = cbEncryptParaSize;
    EncryptPara.dwMsgEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    EncryptPara.hCryptProv = hProv;
    EncryptPara.ContentEncryptionAlgorithm = *Algorithm;

    fSts = CryptEncryptMessage(
            &EncryptPara,
            1,
            &CertificateContext,
            Buffer,
            BufferLength,
            CipherText,
            pCipherLength);

    if (!fSts)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

ErrorExit:

    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_ENCMSG_NOSC:EVENT_ID_ENCMSG)
            );
    }

    return lResult;
}


/*++

ScHelperDecryptMessage :

    Deciphers a PKCS-7 encoded message with the private key associated
        w/ the provided certificate.

Arguments:

        Either pbLogonInfo or Provider must be set; if both are set,
        Provider is used.


Return Value:

        "success" or "failure"

Author:

    Amanda Matlosz (AMatlosz) 1-06-98

Note:

        ** CertificateContext subtleties: **

        CryptDecryptMessage takes as a parameter a pointer to a certificate store;
        it will use the first appropriate certificate context it finds in that
        store to perform the decryption.  In order to make this call, we create a
        CertificateStore in memory, and add the provided CertificateContext to it.

        CertAddCertificateContextToStore actually places a copy of the certificate
        context in the store.  In so doing, it strips off any properties that are
        not permanent -- if a HCRYPTPROV is associated with the KeyContext of the
        source CertificateContext, it will NOT be associated with the KeyContext
        of the cert context in the store.

        Although this is appropriate behavior in most cases, we need that property
        to be kept intact when dealing with Smart Card CSPs (to avoid surprise
        "Insert PIN" dialogs), so after adding the CertificateContext to the store,
        we turn around and get the CERT_KEY_CONTEXT_PROP_ID from the source
        certcontext and (re)set it on the certcontext in the memory store.

        ** Algorithm notes: **

        Algorithm expects a CRYPT_ALGORITHM_IDENTIFIER cai;
        If there are no parameters to the alg, cai.Parameters.cbData *must* be 0;

        for example: CALG_RC4, no parameters:
                cai.pszObjId = szOID_RSA_RC4;
                cai.Parameters.cbData = 0;

        Used by LSA.

--*/
NTSTATUS WINAPI
ScHelperDecryptMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PBYTE CipherText,        // Supplies formatted CipherText
    IN ULONG CipherLength,      // Supplies the length of the CiperText
    OUT PBYTE ClearText,        // Receives decrypted message
    IN OUT PULONG pClearLength  // Supplies length of buffer, receives actual length
    )
{
    NTSTATUS lResult = STATUS_SUCCESS;
    HCRYPTPROV hProv = NULL;
    PCCERT_CONTEXT pStoreCertContext = NULL;
    HCERTSTORE hCertStore = NULL;
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    CUnicodeString szPin(pucPIN);
    CERT_KEY_CONTEXT CertKeyContext;
    DWORD cbData = sizeof(CERT_KEY_CONTEXT); // PhilH swears this will not grow!
    BOOL fSts;

    //
    // Make sure we've got a Crypto Provider up and running.
    //

    if (ARGUMENT_PRESENT(Provider))
    {
        hProv = Provider;
    }
    else
    {
		if (NULL != pucPIN)
		{
			if (!szPin.Valid())
			{
				return(STATUS_INSUFFICIENT_RESOURCES);
			}
		}


        CSCLogonInit * LogonInit = (CSCLogonInit *) pLI->ContextInformation;
        hProv = LogonInit->CryptCtx(pLI);
        if (NULL == hProv)
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto ErrorExit;
        }

        //
        // Declare the PIN.
        //

        if (NULL != pucPIN )
        {
            fSts = CryptSetProvParam(
                    hProv,
                    PP_KEYEXCHANGE_PIN,
                    (LPBYTE)((LPCSTR)szPin),
                    0);
            if (!fSts)
            {
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                goto ErrorExit;
            }
        }
    }

    //
    // Open a temporary certstore to hold this certcontext
    //

    hCertStore = CertOpenStore(
                            CERT_STORE_PROV_MEMORY,
                            0, // not applicable
                            hProv,
                            CERT_STORE_NO_CRYPT_RELEASE_FLAG, // auto-release hProv NOT OK
                            NULL);

    if (NULL == hCertStore)
    {
        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto ErrorExit;
    }

    fSts = CertAddCertificateContextToStore(
            hCertStore,
            CertificateContext,
            CERT_STORE_ADD_ALWAYS,
            &pStoreCertContext);

    //
    // NOW WE NEED TO RESET THE KEY CONTEXT PROPERTY ON THIS CERTCONTEXT
        // IN THE MEMORY STORE (see function header/notes) AS APPROPRIATE
        //
        // ie, IFF the certcontext we were give has the key_context property,
        // reset it (and fail if the resetting doesn't work)
        //
    fSts = CertGetCertificateContextProperty(
                CertificateContext,
                CERT_KEY_CONTEXT_PROP_ID,
                (void *)&CertKeyContext,
                &cbData);

        if (TRUE == fSts)
        {
                fSts = CertSetCertificateContextProperty(
                                        pStoreCertContext,
                                        CERT_KEY_CONTEXT_PROP_ID,
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG, // no auto-release hProv!
                                        (void *)&CertKeyContext);

                if (!fSts)
                {
                        lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                        goto ErrorExit;
                }
        }

    //
    // Decrypt the message
    //

    CRYPT_DECRYPT_MESSAGE_PARA DecryptPara;
    DecryptPara.cbSize = sizeof(DecryptPara);
    DecryptPara.dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
    DecryptPara.cCertStore = 1;
    DecryptPara.rghCertStore = &hCertStore;

    fSts = CryptDecryptMessage(
            &DecryptPara,
            CipherText,
            CipherLength,
            ClearText,
            pClearLength,
            NULL);

    if (!fSts)
    {
        if (GetLastError() == ERROR_MORE_DATA)
        {
            lResult = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        goto ErrorExit;
    }

ErrorExit:

        // Do this early so GetLastError is not clobbered
    if (!NT_SUCCESS(lResult))
    {
        lResult = LogEvent(
            lResult,
            (DWORD)((ARGUMENT_PRESENT(Provider))?EVENT_ID_DECMSG_NOSC:EVENT_ID_DECMSG)
            );
    }

    if (hCertStore != NULL)
    {
        fSts = CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
        if (!fSts)
        {
            if (!NT_SUCCESS(lResult))
                lResult = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
    }

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\sclogon2\sclogon2.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ScLogon2

Abstract:

    

Author:

    reidk

Environment:

    Win32, C++ w/ Exceptions

--*/

/////////////////////////////////////////////////////////////////////////////
//
// Includes

#if !defined(_X86_) && !defined(_AMD64_) && !defined(_IA64_)
#define _X86_ 1
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#ifndef UNICODE
#define UNICODE
#endif
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}

#include <windows.h>
#include <winscard.h>
#include <wincrypt.h>
#include <softpub.h>
#include <stddef.h>
#include <crtdbg.h>
#include "sclogon.h"
#include "sclogon2.h"
#include "unicodes.h"
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <tchar.h>

#include "sclgnrpc.h"

//
// from secpkg.h
//
typedef NTSTATUS (NTAPI LSA_IMPERSONATE_CLIENT) (VOID);
typedef LSA_IMPERSONATE_CLIENT * PLSA_IMPERSONATE_CLIENT;



DWORD 
GetTSSessionID(void) 
{

    bool                    fRet                    = false;
    PLIST_ENTRY             Module;
    PLDR_DATA_TABLE_ENTRY   Entry;
    BOOL                    fRunningInLsa           = false;
    HMODULE                 hLsa                    = NULL;
    PLSA_IMPERSONATE_CLIENT pLsaImpersonateClient   = NULL;
    bool                    bImpersonating          = false;
    bool                    bRunningInLsa           = false;
    HANDLE                  hThreadToken            = INVALID_HANDLE_VALUE;
    DWORD                   dwTSSessionID           = 0;
    DWORD                   dwSize;

    //
    // Make sure we are running in LSA
    //
    Module = NtCurrentPeb()->Ldr->InLoadOrderModuleList.Flink;
    Entry = CONTAINING_RECORD(Module,
                                LDR_DATA_TABLE_ENTRY,
                                InLoadOrderLinks);

    bRunningInLsa = (0 == _wcsicmp(Entry->BaseDllName.Buffer, L"lsass.exe"));

    if (bRunningInLsa)
    {
        //
        // If we running in Lsa, then we need to call the special LssImpersonateClient
        //
        hLsa = GetModuleHandleW(L"lsasrv.dll");
        if (hLsa == NULL)
        {
            DbgPrint("failed to get lsa module handle\n");
            goto Return;
        }

        pLsaImpersonateClient = (PLSA_IMPERSONATE_CLIENT) GetProcAddress(hLsa, "LsaIImpersonateClient");
        if (pLsaImpersonateClient == NULL)
        {
            DbgPrint("failed to get proc address\n");
            goto Return;
        }

        if (pLsaImpersonateClient() != STATUS_SUCCESS)
        {
            DbgPrint("failed to impersonate\n");
            goto Return;
        }
        bImpersonating = true;        
    }
    else
    {
        return (0);
    }


    //
    // see if the calling thread token has a TS session ID...
    // if so, then we are being called on behalf of a process in a TS session
    //
    if (!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY,
                FALSE,
                &hThreadToken))
    {
        DbgPrint("OpenThreadToken failed\n");
        goto Return;
    }

    if (!GetTokenInformation(
                hThreadToken,
                TokenSessionId,
                &dwTSSessionID,
                sizeof(dwTSSessionID),
                &dwSize))
    {
        DbgPrint("GetTokenInformation failed\n");
        goto Return;
    }

Return:

    if (hThreadToken != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hThreadToken);
    }

    if (bImpersonating)
    {
        RevertToSelf();
    }

    return (dwTSSessionID);
}

void
_TeardownRPCConnection(
    RPC_BINDING_HANDLE    *phRPCBinding)
{
    __try
    {
        RpcBindingFree(phRPCBinding);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DbgPrint("Exception occurred during RpcBindingFree - %lx\n", _exception_code());
    }  
}


NTSTATUS 
_SetupRPCConnection(
    RPC_BINDING_HANDLE    *phRPCBinding)
{
    LPWSTR                      pStringBinding          = NULL;
    NTSTATUS                    status                  = STATUS_SUCCESS;
    RPC_STATUS                  rpcStatus               = RPC_S_OK;
    static                      BOOL fDone              = FALSE;
    DWORD                       dwTSSessionID           = 0;
    WCHAR                       wszLocalEndpoint[256];
    LPWSTR                      pwszLocalEndpoint       = NULL;  
    RPC_SECURITY_QOS            RpcSecurityQOS;
    SID_IDENTIFIER_AUTHORITY    SIDAuth                 = SECURITY_NT_AUTHORITY;
    PSID                        pSID                    = NULL;
    WCHAR                       szName[64]; // SYSTEM
    DWORD                       cbName                  = 64;
    WCHAR                       szDomainName[256]; // max domain is 255
    DWORD                       cbDomainName            = 256;
    SID_NAME_USE                Use;


    dwTSSessionID = GetTSSessionID();

    if (dwTSSessionID != 0)
    {
        wsprintfW(
            wszLocalEndpoint, 
            SZ_ENDPOINT_NAME_FORMAT,
            SCLOGONRPC_LOCAL_ENDPOINT,
            dwTSSessionID);

        pwszLocalEndpoint = wszLocalEndpoint;
    }
    else
    {
        pwszLocalEndpoint = SCLOGONRPC_LOCAL_ENDPOINT;
    }

    //
    // get a binding handle
    //
    if (RPC_S_OK != (rpcStatus = RpcStringBindingComposeW(
                            NULL,
                            SCLOGONRPC_LOCAL_PROT_SEQ,
                            NULL, //LPC - no machine name
                            pwszLocalEndpoint,
                            0,
                            &pStringBinding)))
    {
        DbgPrint("RpcStringBindingComposeW failed\n");

        status = I_RpcMapWin32Status(rpcStatus);
        //
        // if I_RpcMapWin32Status() can't map the error code it returns
        // the same error back, so check for that
        //
        if (status == rpcStatus)
        {
            status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        goto Return;
    }

    if (RPC_S_OK != (rpcStatus = RpcBindingFromStringBindingW(
                            pStringBinding,
                            phRPCBinding)))
    {
        DbgPrint("RpcBindingFromStringBindingW failed\n");
        status = I_RpcMapWin32Status(rpcStatus);
        //
        // if I_RpcMapWin32Status() can't map the error code it returns
        // the same error back, so check for that
        //
        if (status == rpcStatus)
        {
            status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        goto Return;
    }

    if (RPC_S_OK != (rpcStatus = RpcEpResolveBinding(
                            *phRPCBinding,
                            IRPCSCLogon_v1_0_c_ifspec)))
    {
        DbgPrint("RpcEpResolveBinding failed\n");
        status = I_RpcMapWin32Status(rpcStatus);
        //
        // if I_RpcMapWin32Status() can't map the error code it returns
        // the same error back, so check for that
        //
        if (status == rpcStatus)
        {
            status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        }
        _TeardownRPCConnection(phRPCBinding);
        goto Return;
    }

    //
    // Set the autorization so that we will only call a Local System process
    //
    memset(&RpcSecurityQOS, 0, sizeof(RpcSecurityQOS));
    RpcSecurityQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    RpcSecurityQOS.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    RpcSecurityQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    RpcSecurityQOS.ImpersonationType = RPC_C_IMP_LEVEL_DELEGATE; //RPC_C_IMP_LEVEL_DEFAULT; //RPC_C_IMP_LEVEL_IMPERSONATE

   if (AllocateAndInitializeSid(&SIDAuth, 1,
                                 SECURITY_LOCAL_SYSTEM_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &pSID) == 0) 
    {
        DbgPrint("AllocateAndInitializeSid failed\n"); 
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto Return;
    }

    if (LookupAccountSid(NULL, 
                         pSID, 
                         szName, 
                         &cbName, 
                         szDomainName, 
                         &cbDomainName, 
                         &Use) == 0) 
    { 
        DbgPrint("LookupAccountSid failed\n");
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        goto Return;
    }

    if (RPC_S_OK != (rpcStatus = RpcBindingSetAuthInfoEx(
                            *phRPCBinding,
                            szName,
                            RPC_C_AUTHN_LEVEL_PKT_PRIVACY, //RPC_C_AUTHN_LEVEL_CONNECT
                            RPC_C_AUTHN_WINNT,
                            NULL,
                            0,
                            &RpcSecurityQOS)))
    {
        DbgPrint("RpcBindingSetAuthInfoEx failed\n");
        status = I_RpcMapWin32Status(rpcStatus);
        goto Return;
    }

Return:
    if (pStringBinding != NULL)
    {
        RpcStringFreeW(&pStringBinding);
    }

    if (pSID != NULL) 
    {
        FreeSid( pSID );
    }

    return (status);
}


typedef struct _SCLOGON_PIPE
{
    RPC_BINDING_HANDLE  hRPCBinding;
    BINDING_CONTEXT     BindingContext;
} SCLOGON_PIPE;


///////////////////////////////////////////////////////////////////////////////
//
// ScLogon APIs
//


//***************************************************************************************
//
// __ScHelperInitializeContext:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperInitializeContext(
    IN OUT PBYTE pbLogonInfo,
    IN ULONG cbLogonInfo
    )
{
    SCLOGON_PIPE    *pSCLogonPipe;
    NTSTATUS        status                  = STATUS_SUCCESS;
    BOOL            fRPCBindingInitialized  = FALSE;
    LogonInfo       *pLI                    = (LogonInfo *)pbLogonInfo;
    
    if ((cbLogonInfo < sizeof(ULONG)) ||
        (cbLogonInfo != pLI->dwLogonInfoLen))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    
    pLI->ContextInformation = malloc(sizeof(SCLOGON_PIPE));
    if (pLI->ContextInformation == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pSCLogonPipe = (SCLOGON_PIPE *) pLI->ContextInformation;

    status = _SetupRPCConnection(&(pSCLogonPipe->hRPCBinding));
    if (!NT_SUCCESS(status))
    {
        goto ErrorReturn;
    }
    fRPCBindingInitialized = TRUE;

    pSCLogonPipe->BindingContext = NULL;

    __try
    {
        status = RPC_ScHelperInitializeContext(
                    pSCLogonPipe->hRPCBinding,
                    cbLogonInfo,
                    pbLogonInfo,
                    &(pSCLogonPipe->BindingContext)); 
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE; 
        DbgPrint("Exception occurred during RPC_ScHelperInitializeContext - %lx\n", _exception_code());
    }

    if (!NT_SUCCESS(status))
    {
        goto ErrorReturn;
    }
    
Return:
    
    return (status);

ErrorReturn:

    if (pSCLogonPipe != NULL)
    {
        if (fRPCBindingInitialized)
        {
            _TeardownRPCConnection(&(pSCLogonPipe->hRPCBinding));
        }
        
        free(pSCLogonPipe);
    }

    goto Return;
}


//***************************************************************************************
//
// __ScHelperRelease:
//
//***************************************************************************************
VOID WINAPI
__ScHelperRelease(
    IN OUT PBYTE pbLogonInfo
    )
{
    _ASSERTE(NULL != pbLogonInfo);
    LogonInfo *pLI = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE * pSCLogonPipe = (SCLOGON_PIPE *) pLI->ContextInformation;
    BOOL fReleaseFailed = TRUE;

    if (pSCLogonPipe != NULL)
    {
        __try
        {
            RPC_ScHelperRelease(
                pSCLogonPipe->hRPCBinding,
                &(pSCLogonPipe->BindingContext));  

            fReleaseFailed = FALSE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            DbgPrint("Exception occurred during RPC_ScHelperRelease - %lx\n", _exception_code());
        }

        //
        // RPC_ScHelperRelease will throw an exception if the winlogon process it is trying
        // to talk to has gone away.  If that is the case, then we need to manually free
        // the BINDING_CONTEXT since it won't get free'd by RPC.  
        //
        // NOTE: RPC will free the BINDING_CONTEXT when the server sets it to NULL, which
        // does happen if the RPC_ScHelperRelease function executes
        //
        if (fReleaseFailed)
        {
            __try
            {
                RpcSsDestroyClientContext(&(pSCLogonPipe->BindingContext));     
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                DbgPrint("Exception occurred during RpcSsDestroyClientContext - %lx\n", _exception_code());
            }            
        }
               
        _TeardownRPCConnection(&(pSCLogonPipe->hRPCBinding));
        
        free(pSCLogonPipe);
        pLI->ContextInformation = NULL;
    }
}


//***************************************************************************************
//
// __ScHelperGetCertFromLogonInfo:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperGetCertFromLogonInfo(
    IN PBYTE pbLogonInfo,
    IN PUNICODE_STRING pucPIN,
    OUT PCCERT_CONTEXT *CertificateContext
    )
{
    _ASSERTE(NULL != pbLogonInfo);
    
    LogonInfo       *pLI            = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe   = (SCLOGON_PIPE *) pLI->ContextInformation;
    NTSTATUS        status          = STATUS_SUCCESS;
    PCCERT_CONTEXT  pCertCtx        = NULL;
    OUT_BUFFER1     CertBytes;
    CUnicodeString  szPIN(pucPIN);

    memset(&CertBytes, 0, sizeof(CertBytes));

    //
    // Make sure pin got initialized correctly in constructor
    //
    if (NULL != pucPIN)
    {
                if (!szPIN.Valid())
                {
            status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Return;
                }
        }

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperGetCertFromLogonInfo( 
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    (LPCWSTR)szPIN,
                    &CertBytes);      
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
        DbgPrint("Exception occurred during RPC_ScHelperGetCertFromLogonInfo - %lx\n", _exception_code());
    }
    
    if (!NT_SUCCESS(status))
    {
        goto Return;
    }
    
    //
    // Create the return CertContext based on the bytes returned
    //
    pCertCtx = CertCreateCertificateContext(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    CertBytes.pb,
                    CertBytes.cb);
    if (pCertCtx == NULL)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
    }

Return:

    if (CertBytes.pb != NULL)
    {
        MIDL_user_free(CertBytes.pb);
    }
    
    *CertificateContext = pCertCtx;

    return (status);  
}


//***************************************************************************************
//
// __ScHelperGetProvParam:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperGetProvParam(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags
    )
{
    _ASSERTE(NULL != pbLogonInfo);
    
    LogonInfo       *pLI            = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe   = (SCLOGON_PIPE *) pLI->ContextInformation;
    NTSTATUS        status          = STATUS_SUCCESS;
    CUnicodeString  szPIN(pucPIN);
    OUT_BUFFER1     Data;

    memset(&Data, 0, sizeof(Data));

    //
    // Make sure pin got initialized correctly in constructor
    //
    if (NULL != pucPIN)
    {
                if (!szPIN.Valid())
                {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Return;
                }
        }

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperGetProvParam( 
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    (LPCWSTR)szPIN,
                    dwParam,
                    pdwDataLen,
                    &Data,
                    dwFlags);      
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        if ((_exception_code() == RPC_S_CALL_FAILED_DNE) ||
            (_exception_code() == RPC_S_SERVER_UNAVAILABLE))
        {
                // Special case to trigger the balloon when the session
                // went away (transfer of credentials case)
            status = STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED; 
        }
        else
        {
            status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE; 
        }
        DbgPrint("Exception occurred during RPC_ScHelperGetProvParam - %lx\n", _exception_code());
    }
    
    if (!NT_SUCCESS(status))
    {
        goto Return;
    }

    //
    // if Data.cb is not 0, then the called is getting back data
    //
    if (Data.cb != 0)
    {
        memcpy(pbData, Data.pb, Data.cb);
    }
    
Return:
    
    if (Data.pb != NULL)
    {
        MIDL_user_free(Data.pb);
    }

    return (status);
}


//***************************************************************************************
//
// __ScHelperGenRandBits:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperGenRandBits(
    IN PBYTE pbLogonInfo,
    IN OUT ScHelper_RandomCredBits* psc_rcb
)
{
    _ASSERTE(NULL != pbLogonInfo);

    NTSTATUS        status          = STATUS_SUCCESS;
    LogonInfo       *pLI            = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe   = (SCLOGON_PIPE *) pLI->ContextInformation;
    
    __try
    {
        status = RPC_ScHelperGenRandBits( 
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    psc_rcb->bR1,
                    psc_rcb->bR2);     
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE; 
        DbgPrint("Exception occurred during RPC_ScHelperGenRandBits - %lx\n", _exception_code());
    }

    return (status);
}


//***************************************************************************************
//
// __ScHelperVerifyCardAndCreds:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperVerifyCardAndCreds(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN PBYTE pbLogonInfo,
    IN PBYTE EncryptedData,
    IN ULONG EncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize
    )
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo       *pLI            = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe   = (SCLOGON_PIPE *) pLI->ContextInformation;
    NTSTATUS        status          = STATUS_SUCCESS;
    CUnicodeString  szPIN(pucPIN);
    OUT_BUFFER2     CleartextDataBuffer;

    memset(&CleartextDataBuffer, 0, sizeof(CleartextDataBuffer));

    //
    // Make sure pin got initialized correctly in constructor
    //
    if (NULL != pucPIN)
    {
                if (!szPIN.Valid())
                {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Return;
                }
        }

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperVerifyCardAndCreds( 
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    (LPCWSTR)szPIN,
                    EncryptedDataSize,
                    EncryptedData,
                    CleartextDataSize,
                    &CleartextDataBuffer);   
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE; 
        DbgPrint("Exception occurred during RPC_ScHelperVerifyCardAndCreds - %lx\n", _exception_code());
    }
    
    if (!NT_SUCCESS(status))
    {
        goto Return;
    }

    //
    // if CleartextData.cb is not 0, then the called is getting back data
    //
    if (CleartextDataBuffer.cb != 0)
    {
        memcpy(CleartextData, CleartextDataBuffer.pb, CleartextDataBuffer.cb);
    }

Return:
    
    if (CleartextDataBuffer.pb != NULL)
    {
        MIDL_user_free(CleartextDataBuffer.pb);
    }
    
    return (status);
}


//***************************************************************************************
//
// __ScHelperEncryptCredentials:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperEncryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN ScHelper_RandomCredBits* psch_rcb,
    IN PBYTE pbLogonInfo,
    IN PBYTE CleartextData,
    IN ULONG CleartextDataSize,
    OUT OPTIONAL PBYTE EncryptedData,
    OUT PULONG EncryptedDataSize)
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo       *pLI            = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe   = (SCLOGON_PIPE *) pLI->ContextInformation;
    NTSTATUS        status          = STATUS_SUCCESS;
    CUnicodeString  szPIN(pucPIN);
    OUT_BUFFER2     EncryptedDataBuffer;

    memset(&EncryptedDataBuffer, 0, sizeof(EncryptedDataBuffer));

    //
    // Make sure pin got initialized correctly in constructor
    //
    if (NULL != pucPIN)
    {
                if (!szPIN.Valid())
                {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Return;
                }
        }

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperEncryptCredentials( 
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    (LPCWSTR)szPIN,
                    psch_rcb->bR1,
                    psch_rcb->bR2,
                    CleartextDataSize,
                    CleartextData,
                    EncryptedDataSize,
                    &EncryptedDataBuffer);  
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE; 
        DbgPrint("Exception occurred during RPC_ScHelperEncryptCredentials - %lx\n", _exception_code());
    }
    
    if (!NT_SUCCESS(status))
    {
        goto Return;
    }

    //
    // if EncryptedDataBuffer.cb is not 0, then the called is getting back data
    //
    if (EncryptedDataBuffer.cb != 0)
    {
        memcpy(EncryptedData, EncryptedDataBuffer.pb, EncryptedDataBuffer.cb);
    }

Return:
    
    if (EncryptedDataBuffer.pb != NULL)
    {
        MIDL_user_free(EncryptedDataBuffer.pb);
    }
    
    return (status);
}


//***************************************************************************************
//
// __ScHelperSignMessage:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperSignMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT PBYTE Signature,
    OUT PULONG SignatureLength
    )
{
    if (Provider != NULL)
    {
        return (ScHelperSignMessage(
                    pucPIN,
                    pbLogonInfo,
                    Provider,
                    Algorithm,
                    Buffer,
                    BufferLength,
                    Signature,
                    SignatureLength));   
    }

    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo       *pLI            = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe   = (SCLOGON_PIPE *) pLI->ContextInformation;
    NTSTATUS        status          = STATUS_SUCCESS;
    CUnicodeString  szPIN(pucPIN);
    OUT_BUFFER2     SignatureBuffer;

    memset(&SignatureBuffer, 0, sizeof(SignatureBuffer));

    //
    // Make sure pin got initialized correctly in constructor
    //
    if (NULL != pucPIN)
    {
                if (!szPIN.Valid())
                {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Return;
                }
        }

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperSignMessage( 
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    (LPCWSTR)szPIN,
                    Algorithm,
                    BufferLength,
                    Buffer,
                    SignatureLength,
                    &SignatureBuffer);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE; 
        DbgPrint("Exception occurred during RPC_ScHelperSignMessage - %lx\n", _exception_code());
    }
    
    if (!NT_SUCCESS(status))
    {
        goto Return;
    }

    //
    // if SignatureBuffer.cb is not 0, then the called is getting back data
    //
    if (SignatureBuffer.cb != 0)
    {
        memcpy(Signature, SignatureBuffer.pb, SignatureBuffer.cb);
    }

Return:
    
    if (SignatureBuffer.pb != NULL)
    {
        MIDL_user_free(SignatureBuffer.pb);
    }

    return (status);
}


//***************************************************************************************
//
// __ScHelperVerifyMessage:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperVerifyMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN PCCERT_CONTEXT CertificateContext,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    IN PBYTE Signature,
    IN ULONG SignatureLength
    )
{
    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo       *pLI            = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe   = (SCLOGON_PIPE *) pLI->ContextInformation;
    NTSTATUS        status          = STATUS_SUCCESS;
  
    __try
    {
        status = RPC_ScHelperVerifyMessage(
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    Algorithm,
                    BufferLength,
                    Buffer,     
                    SignatureLength,
                    Signature);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE; 
        DbgPrint("Exception occurred during RPC_ScHelperVerifyMessage - %lx\n", _exception_code());
    }

    return (status);
}


//***************************************************************************************
//
// __ScHelperSignPkcsMessage:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperSignPkcsMessage(
    IN OPTIONAL PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT Certificate,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN DWORD dwSignMessageFlags,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE SignedBuffer,
    OUT OPTIONAL PULONG SignedBufferLength
    )
{
    if (Provider != NULL)
    {
        return (ScHelperSignPkcsMessage(
                    pucPIN,
                    pbLogonInfo,
                    Provider,
                    Certificate,
                    Algorithm,
                    dwSignMessageFlags,
                    Buffer,
                    BufferLength,
                    SignedBuffer,
                    SignedBufferLength));
    }

    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo       *pLI            = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe   = (SCLOGON_PIPE *) pLI->ContextInformation;
    NTSTATUS        status          = STATUS_SUCCESS;
    CUnicodeString  szPIN(pucPIN);
    OUT_BUFFER2     SignedBufferBuffer;

    memset(&SignedBufferBuffer, 0, sizeof(SignedBufferBuffer));

    //
    // Make sure pin got initialized correctly in constructor
    //
    if (NULL != pucPIN)
    {
                if (!szPIN.Valid())
                {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Return;
                }
        }

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperSignPkcsMessage( 
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    (LPCWSTR)szPIN,
                    Algorithm->pszObjId,
                    Algorithm->Parameters.cbData,
                    Algorithm->Parameters.pbData,
                    dwSignMessageFlags,
                    BufferLength,
                    Buffer,
                    SignedBufferLength,
                    &SignedBufferBuffer);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE; 
        DbgPrint("Exception occurred during RPC_ScHelperSignPkcsMessage - %lx\n", _exception_code());
    }
    
    if (!NT_SUCCESS(status))
    {
        goto Return;
    }

    //
    // if SignedBufferBuffer.cb is not 0, then the called is getting back data
    //
    if (SignedBufferBuffer.cb != 0)
    {
        memcpy(SignedBuffer, SignedBufferBuffer.pb, SignedBufferBuffer.cb);
    }

Return:
    
    if (SignedBufferBuffer.pb != NULL)
    {
        MIDL_user_free(SignedBufferBuffer.pb);
    }
    
    return (status);
}


//***************************************************************************************
//
// __ScHelperVerifyPkcsMessage:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperVerifyPkcsMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE DecodedBuffer,
    OUT OPTIONAL PULONG DecodedBufferLength,
    OUT OPTIONAL PCCERT_CONTEXT * CertificateContext
    )
{
    if (Provider != NULL)
    {
        return (ScHelperVerifyPkcsMessage(
                    pbLogonInfo,
                    Provider,
                    Buffer,
                    BufferLength,
                    DecodedBuffer,
                    DecodedBufferLength,
                    CertificateContext));
    }

    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo       *pLI                        = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe               = (SCLOGON_PIPE *) pLI->ContextInformation;
    NTSTATUS        status                      = STATUS_SUCCESS;
    PCCERT_CONTEXT  pCertCtx                    = NULL;
    OUT_BUFFER2     DecodedBufferBuffer;
    OUT_BUFFER1     CertBytes;
    BOOL            fCertificateContextRequested = (CertificateContext != NULL);
 
    memset(&DecodedBufferBuffer, 0, sizeof(DecodedBufferBuffer));
    memset(&CertBytes, 0, sizeof(CertBytes));

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperVerifyPkcsMessage( 
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    BufferLength,
                    Buffer,
                    DecodedBufferLength,
                    &DecodedBufferBuffer,
                    fCertificateContextRequested,
                    &CertBytes);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE; 
        DbgPrint("Exception occurred during RPC_ScHelperVerifyPkcsMessage - %lx\n", _exception_code());
    }
    
    if (!NT_SUCCESS(status))
    {
        goto Return;
    }

    //
    // Create the return CertContext based on the bytes returned
    //
    if (fCertificateContextRequested)
    {
        pCertCtx = CertCreateCertificateContext(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        CertBytes.pb,
                        CertBytes.cb);
        if (pCertCtx == NULL)
        {
            status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
            goto Return;
        }
    }

    //
    // if DecodedBufferBuffer.cb is not 0, then the called is getting back data
    //
    if (DecodedBufferBuffer.cb != 0)
    {
        memcpy(DecodedBuffer, DecodedBufferBuffer.pb, DecodedBufferBuffer.cb);
    }

Return:
    
    if (fCertificateContextRequested)
    {
        *CertificateContext = pCertCtx;
    }

    if (DecodedBufferBuffer.pb != NULL)
    {
        MIDL_user_free(DecodedBufferBuffer.pb);
    }

    if (CertBytes.pb != NULL)
    {
        MIDL_user_free(CertBytes.pb);
    }
    
    return (status);
}



//***************************************************************************************
//
// __ScHelperDecryptMessage:
//
//***************************************************************************************
NTSTATUS WINAPI
__ScHelperDecryptMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PBYTE CipherText,        // Supplies formatted CipherText
    IN ULONG CipherLength,      // Supplies the length of the CiperText
    OUT PBYTE ClearText,        // Receives decrypted message
    IN OUT PULONG pClearLength  // Supplies length of buffer, receives actual length
    )
{
    if (Provider != NULL)
    {
        return (ScHelperDecryptMessage(
                    pucPIN,
                    pbLogonInfo,
                    Provider,
                    CertificateContext,
                    CipherText,
                    CipherLength,     
                    ClearText,       
                    pClearLength));
    }

    _ASSERTE(NULL != pbLogonInfo);

    LogonInfo       *pLI            = (LogonInfo *)pbLogonInfo;
    SCLOGON_PIPE    *pSCLogonPipe   = (SCLOGON_PIPE *) pLI->ContextInformation;
    NTSTATUS        status          = STATUS_SUCCESS;
    CUnicodeString  szPIN(pucPIN);
    OUT_BUFFER2     ClearTextBuffer;
 
    memset(&ClearTextBuffer, 0, sizeof(ClearTextBuffer));

    //
    // Make sure pin got initialized correctly in constructor
    //
    if (NULL != pucPIN)
    {
                if (!szPIN.Valid())
                {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Return;
                }
        }

    //
    // Make the call
    //
    __try
    {
        status = RPC_ScHelperDecryptMessage( 
                    pSCLogonPipe->hRPCBinding,
                    pSCLogonPipe->BindingContext,
                    (LPCWSTR)szPIN,
                    CipherLength,
                    CipherText,
                    pClearLength,
                    &ClearTextBuffer);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = STATUS_SMARTCARD_SUBSYSTEM_FAILURE; 
        DbgPrint("Exception occurred during RPC_ScHelperDecryptMessage - %lx\n", _exception_code());
    }
    
    if (!NT_SUCCESS(status))
    {
        goto Return;
    }

    //
    // if ClearTextBuffer.cb is not 0, then the called is getting back data
    //
    if (ClearTextBuffer.cb != 0)
    {
        memcpy(ClearText, ClearTextBuffer.pb, ClearTextBuffer.cb);
    }

Return:
    
    if (ClearTextBuffer.pb != NULL)
    {
        MIDL_user_free(ClearTextBuffer.pb);
    }
    
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\sclogon2\unicodes.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    unicodes

Abstract:

    This header file describes the CUnicodeString class, useful for converting
    string types.

Author:

    Doug Barlow (dbarlow) 11/6/1997

Environment:

    Win32, C++

Notes:

    ?Notes?

--*/

#ifndef _UNICODES_H_
#define _UNICODES_H_

//
//==============================================================================
//
//  CUnicodeString
//

class CUnicodeString
{
public:

    //  Constructors & Destructor
    CUnicodeString(void);
    CUnicodeString(LPCSTR sz);
    CUnicodeString(LPCWSTR wsz);
    CUnicodeString(PUNICODE_STRING pus);
    ~CUnicodeString();

    //  Properties
    //  Methods
    LPCSTR  Set(LPCSTR sz);
    LPCWSTR Set(LPCWSTR wsz);
    PUNICODE_STRING Set(PUNICODE_STRING pus);
    BOOL Valid(void)
    {
        if (m_fFlags == fNoneGood)
        {
            return(FALSE);
        }
        else
        {
            return(TRUE);
        }
    }

    //  Operators
    LPCSTR operator=(LPCSTR sz)
    { return Set(sz); };
    LPCWSTR operator=(LPCWSTR wsz)
    { return Set(wsz); };
    PUNICODE_STRING operator=(PUNICODE_STRING pus)
    { return Set(pus);};
    operator LPCSTR(void)
    { return Ansi(); };
    operator LPCWSTR(void)
    { return Unicode(); };
    operator PUNICODE_STRING(void);

protected:
    //  Properties
    UNICODE_STRING m_us;
    LPSTR m_szAnsi;
    LPWSTR m_wszUnicode;
    enum {
        fNoneGood = 0,
        fAnsiGood = 1,
        fUnicodeGood = 2,
        fBothGood = 3
    } m_fFlags;

    //  Methods
    LPCWSTR Unicode(void);      // Return the text as a Unicode string.
    LPCSTR Ansi(void);          // Return the text as an Ansi string.
};

#endif // _UNICODES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\client\context.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Context

Abstract:

    This module implements the CSCardUserContext and CSCardSubcontext classes.
    These classes are responsible for establishing and maintaining the
    connection to the Calais Server application, and for tracking the context
    under which related operations are performed.

Author:

    Doug Barlow (dbarlow) 11/21/1996

Environment:

    Win32, C++ w/ Excpetions

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "client.h"
#ifdef DBG
#include <stdio.h>
#endif


//
//==============================================================================
//
//  CSCardUserContext
//

/*++

CSCardUserContext:

    This is the default constructor for the user context.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/22/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::CSCardUserContext")

CSCardUserContext::CSCardUserContext(
    IN DWORD dwScope)
:   m_csUsrCtxLock(CSID_USER_CONTEXT),
    m_hContextHeap(DBGT("User Context Heap Handle")),
    m_rgpSubContexts()
{
    m_dwScope = dwScope;
    m_hRedirContext = NULL;
}


/*++

CSCardUserContext::~CSCardUserContext:

    This is the destructor for a User Context.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/22/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::~CSCardUserContext")

CSCardUserContext::~CSCardUserContext()
{
    DWORD dwIndex;
    CSCardSubcontext *pSubCtx;

    LockSection(&m_csUsrCtxLock, DBGT("Destructing User Level Context"));
    for (dwIndex = m_rgpSubContexts.Count(); 0 < dwIndex;)
    {
        {
            pSubCtx = m_rgpSubContexts[--dwIndex];
            if (NULL != pSubCtx)
                m_rgpSubContexts.Set(dwIndex, NULL);
        }
        if (NULL != pSubCtx)
            delete pSubCtx;
    }
    m_rgpSubContexts.Empty();

    if (m_hContextHeap.IsValid())
        HeapDestroy(m_hContextHeap.Relinquish());
}


/*++

EstablishContext:

    This method establishes the context by connecting to the Calais Server
    application.

Arguments:

    dwScope supplies an indication of the scope of the context.  Possible values
        are:

        SCARD_SCOPE_USER - The context is a user context, and any database
            operations are performed within the domain of the user.

        SCARD_SCOPE_TERMINAL - The context is that of the current terminal, and
            any database operations are performed within the domain of that
            terminal.  (The calling application must have appropriate access
            permissions for any database actions.)

        SCARD_SCOPE_SYSTEM - The context is the system context, and any database
            operations are performed within the domain of the system.  (The
            calling application must have appropriate access permissions for any
            database actions.)

Return Value:

    None

Throws:

    Error conditions are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 11/21/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::EstablishContext")

void
CSCardUserContext::EstablishContext(
    void)
{

    //
    // Make sure we can access the server.
    //

    CSCardSubcontext *pSubCtx = AcquireSubcontext();
    ASSERT(NULL != pSubCtx);
    if (NULL == pSubCtx)
        throw (DWORD)SCARD_E_NO_MEMORY;
    pSubCtx->ReleaseSubcontext();
}


/*++

ReleaseContext:

    This method requests the ReleaseContext service on behalf of the client.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::ReleaseContext")

void
CSCardUserContext::ReleaseContext(
    void)
{
    DWORD dwIndex;
    CSCardSubcontext *pSubCtx;
    LockSection(&m_csUsrCtxLock, DBGT("Releasing subcontexts"));

    for (dwIndex = m_rgpSubContexts.Count(); 0 < dwIndex;)
    {
        pSubCtx = m_rgpSubContexts[--dwIndex];
        if (NULL != pSubCtx)
        {
            m_rgpSubContexts.Set(dwIndex, NULL);
            if (NULL != pSubCtx->m_hReaderHandle)
            {
                try
                {
                    g_phlReaders->Close(pSubCtx->m_hReaderHandle);
                }
                catch (...) {}
            }
            try
            {
                pSubCtx->ReleaseContext();
            }
            catch (...) {}
            delete pSubCtx;
        }
    }
}


/*++

AllocateMemory:

    Allocate memory for the user through this user context.

Arguments:

    cbLength supplies the length of the buffer to be allocated, in bytes.

Return Value:

    The address of the allocated buffer, or NULL if an error occurred.

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/21/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::AllocateMemory")

LPVOID
CSCardUserContext::AllocateMemory(
    DWORD cbLength)
{
    LockSection(&m_csUsrCtxLock, DBGT("Locking memory heap"));

    if (!m_hContextHeap.IsValid())
    {
        m_hContextHeap = HeapCreate(0, 0, 0);
        if (!m_hContextHeap.IsValid())
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to create context heap: "),
                m_hContextHeap.GetLastError());
            goto ErrorExit;
        }
    }

    if (cbLength)
    {
        return HeapAlloc(
                m_hContextHeap,
                HEAP_ZERO_MEMORY,
                cbLength);
    }

ErrorExit:
    return NULL;
}


/*++

FreeMemory:

    Free memory for the user through this user context.

Arguments:

    pvBuffer supplies the address of the previously allocated buffer.

Return Value:

    None.

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/21/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::FreeMemory")

DWORD
CSCardUserContext::FreeMemory(
    LPCVOID pvBuffer)
{
    BOOL fSts;
    LockSection(&m_csUsrCtxLock, DBGT("Freeing heap memory"));

    ASSERT(m_hContextHeap.IsValid());
    fSts = HeapFree(m_hContextHeap, 0, (LPVOID)pvBuffer);
    return fSts ? ERROR_SUCCESS : GetLastError();
}


/*++

AcquireSubcontext:

    A User Context manages one or more underlying subcontexts.  Subcontexts
    exist to facilitate multiple operations simoultaneously.  This method
    obtains a subcontext for temporary use.

Arguments:

    None

Return Value:

    The address of the newly created subcontext object.

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

    Subcontexts are managed by the main context, so when the main context is
    closed, all the subcontexts are closed too.

Author:

    Doug Barlow (dbarlow) 9/4/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::AcquireSubcontext")

CSCardSubcontext *
CSCardUserContext::AcquireSubcontext(
    BOOL fAndAllocate)
{
    CSCardSubcontext *pSubCtx = NULL;
    LockSection(&m_csUsrCtxLock, DBGT("Acquiring a subcontext"));

    try
    {
        DWORD dwIndex;

        //
        // See if we've got an unused subcontext laying around.
        //

        for (dwIndex = m_rgpSubContexts.Count(); 0 < dwIndex;)
        {
            pSubCtx = m_rgpSubContexts[--dwIndex];
            if (NULL != pSubCtx)
            {
                LockSection2(&pSubCtx->m_csSubCtxLock, DBGT("Reusing subcontext"));
                if (fAndAllocate)
                {
                    if (CSCardSubcontext::Idle == pSubCtx->m_nInUse)
                    {
                        ASSERT(pSubCtx->m_hCancelEvent.IsValid());
                        pSubCtx->Allocate();
                        pSubCtx->SetBusy();
                        break;
                    }
                }
                else
                {
                    if (CSCardSubcontext::Busy > pSubCtx->m_nInUse)
                    {
                        ASSERT(pSubCtx->m_hCancelEvent.IsValid());
                        pSubCtx->SetBusy();
                        break;
                    }
                }
                pSubCtx = NULL;
            }
        }


        //
        // If not, make a new one.
        //

        if (NULL == pSubCtx)
        {
            pSubCtx = new CSCardSubcontext;
            if (NULL == pSubCtx)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Client can't allocate a new subcontext"));
                return NULL; // SCARD_E_NO_MEMORY;
            }
            if (pSubCtx->InitFailed())
            {
                delete pSubCtx;
                pSubCtx = NULL;
                return NULL; // SCARD_E_NO_MEMORY;
            }
            if (fAndAllocate)
                pSubCtx->Allocate();
            pSubCtx->SetBusy();
            pSubCtx->EstablishContext(m_dwScope);
            m_rgpSubContexts.Add(pSubCtx);
            pSubCtx->m_pParentCtx = this;
        }


        //
        // Make sure the cancel event is clear.
        //

        ASSERT(pSubCtx->m_hCancelEvent.IsValid());
        if (!ResetEvent(pSubCtx->m_hCancelEvent))
        {
            DWORD dwErr = GetLastError();
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Subcontext Allocate Failed to clear cancel event:  %1"),
                dwErr);
        }


        //
        // All done.  Return to caller.
        //

        ASSERT(pSubCtx->m_pParentCtx == this);
    }

    catch (...)
    {
        if (NULL != pSubCtx)
        {
            if (NULL == pSubCtx->m_pParentCtx)
                delete pSubCtx;
            else
            {
                if (fAndAllocate)
                    pSubCtx->Deallocate();
                pSubCtx->ReleaseSubcontext();
            }
        }
        throw;
    }

    return pSubCtx;
}


/*++

IsValidContext:

    This method requests the ReleaseContext service on behalf of the client.

Arguments:

    None

Return Value:

    None

Throws:

    If the call cannot be completed, a DWORD status code is thrown.

Remarks:

    If the context is determined to not be valid, it is automatically released.

Author:

    Doug Barlow (dbarlow) 11/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::IsValidContext")

BOOL
CSCardUserContext::IsValidContext(
    void)
{
    DWORD dwIndex;
    BOOL fIsValid = TRUE;
    CSCardSubcontext *pSubCtx;
    LockSection(&m_csUsrCtxLock, DBGT("Valid context check"));

    for (dwIndex = m_rgpSubContexts.Count(); 0 < dwIndex;)
    {
        pSubCtx = m_rgpSubContexts[--dwIndex];
        if (NULL != pSubCtx)
        {
            CSCardSubcontext::State nState;

            {
                LockSection2(
                    &pSubCtx->m_csSubCtxLock,
                    DBGT("IsValidContext Checking validity state"));
                nState = pSubCtx->m_nInUse;
            }

            switch (nState)
            {
            case CSCardSubcontext::Idle:
            case CSCardSubcontext::Allocated:
                try
                {
                    CSubctxLock ctxLock(pSubCtx);
                    pSubCtx->IsValidContext();
                    fIsValid = TRUE;
                }
                catch (...)
                {
                    m_rgpSubContexts.Set(dwIndex, NULL);
                    delete pSubCtx;
                    fIsValid = FALSE;
                }
                break;
            case CSCardSubcontext::Busy:
                // Don't bother it.
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Subcontext state is invalid"));
                throw (DWORD)SCARD_F_INTERNAL_ERROR;
            }
        }
    }

    return fIsValid;
}


/*++

LocateCards:

    This method requests the LocateCards service on behalf of the client.

Arguments:

    mszReaders supplies the names of readers to look in, as a multistring.

    mszCards supplies the names of the cards to search for, as a multi-string.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.  Reader names are taken from the
        mszReaders parameter, not from here.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::LocateCards")

void
CSCardUserContext::LocateCards(
    IN LPCTSTR mszReaders,
    IN LPSCARD_ATRMASK rgAtrMasks,
    IN DWORD cAtrs,
    IN OUT LPSCARD_READERSTATE rgReaderStates,
    IN DWORD cReaders)
{
    CSCardSubcontext *pSubCtx = NULL;

    try
    {
        pSubCtx = AcquireSubcontext();
        if (NULL == pSubCtx)
            throw (DWORD)SCARD_E_NO_MEMORY;
        pSubCtx->LocateCards(
            mszReaders,
            rgAtrMasks,
            cAtrs,
            rgReaderStates,
            cReaders);
        pSubCtx->ReleaseSubcontext();
    }
    catch (...)
    {
        if (NULL != pSubCtx)
            pSubCtx->ReleaseSubcontext();
        throw;
    }
}


/*++

GetStatusChange:

    This method requests the GetStatusChange service on behalf of the client.

Arguments:

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    None

Remarks:

    We don't have to clean up the cancel event, since this is a one-time usage
    of this sub-context.  Typically, if the subcontext were to be continued
    to be used, we'd have to make sure the cancel event got cleared eventually.

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::GetStatusChange")

void
CSCardUserContext::GetStatusChange(
    IN LPCTSTR mszReaders,
    IN OUT LPSCARD_READERSTATE rgReaderStates,
    IN DWORD cReaders,
    IN DWORD dwTimeout)
{
    CSCardSubcontext *pSubCtx = NULL;

    try
    {
        pSubCtx = AcquireSubcontext(TRUE);
        if (NULL == pSubCtx)
            throw (DWORD) SCARD_E_NO_MEMORY;
        pSubCtx->GetStatusChange(
                    mszReaders,
                    rgReaderStates,
                    cReaders,
                    dwTimeout);
        pSubCtx->Deallocate();
        pSubCtx->ReleaseSubcontext();
    }
    catch (DWORD dwStatus)
    {
        DWORD dwError;

        dwError = dwStatus;

        if (NULL != pSubCtx)
        {
            pSubCtx->Deallocate();
            pSubCtx->ReleaseSubcontext();
        }

            // Catch & convert the Cancel I threw myself
        if ((SCARD_E_CANCELLED == dwError) && (IsBad()))
        {
            dwError = SCARD_E_SYSTEM_CANCELLED;
        }

        throw dwError;
    }
    catch (...)
    {
        if (NULL != pSubCtx)
        {
            pSubCtx->Deallocate();
            pSubCtx->ReleaseSubcontext();
        }
        throw;
    }
}


/*++

Cancel:

    This method requests the Cancel service on behalf of the client.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::Cancel")

void
CSCardUserContext::Cancel(
    void)
{
    DWORD dwIndex;
    CSCardSubcontext *pSubCtx;
    LockSection(&m_csUsrCtxLock, DBGT("Cancelling outstanding operations"));

    for (dwIndex = m_rgpSubContexts.Count(); 0 < dwIndex;)
    {
        pSubCtx = m_rgpSubContexts[--dwIndex];
        if (NULL != pSubCtx)
            pSubCtx->Cancel();
    }
}


/*++

StripInactiveReaders:

    This routine scans the supplied list of readers, and shortens it to exclude
    any readers that aren't currently active.

Arguments:

    bfReaders supplies a list of readers by friendly name.  This list is pruned
        to remove all names that refer to inactive readers.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

    All the listed readers must be introduced.  This routine does not filter
    undefined readers.

Author:

    Doug Barlow (dbarlow) 5/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardUserContext::StripInactiveReaders")

void
CSCardUserContext::StripInactiveReaders(
    IN OUT CBuffer &bfReaders)
{
    CSCardSubcontext *pSubCtx = NULL;

    try
    {
        pSubCtx = AcquireSubcontext();
        if (NULL == pSubCtx)
            throw (DWORD) SCARD_E_NO_MEMORY;
        pSubCtx->StripInactiveReaders(bfReaders);
        pSubCtx->ReleaseSubcontext();
    }
    catch (...)
    {
        if (NULL != pSubCtx)
            pSubCtx->ReleaseSubcontext();
        throw;
    }
}


//
//==============================================================================
//
//  CSCardSubcontext
//

/*++

CONSTRUCTOR and DESTRUCTOR:

    These are the simple constructor and destructor for the CSCardSubcontext
    class.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/8/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::CSCardSubcontext")

CSCardSubcontext::CSCardSubcontext(void)
:   m_csSubCtxLock(CSID_SUBCONTEXT),
    m_hBusy(DBGT("Subcontext busy mutex")),
    m_hCancelEvent(DBGT("Subcontext cancel event"))
{
    DWORD dwSts;

    m_hReaderHandle = NULL;
    m_pParentCtx = NULL;
    m_pChannel = NULL;
    m_nInUse = Idle;
    m_nLastState = Invalid;
    m_hBusy = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (!m_hBusy.IsValid())
    {
        dwSts = m_hBusy.GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Failed to create busy event flag: %1"),
            dwSts);
        throw dwSts;
    }

    CSecurityDescriptor acl;

    acl.InitializeFromProcessToken();
    acl.AllowOwner(
        EVENT_ALL_ACCESS);
    acl.Allow(
        &acl.SID_LocalService,
        EVENT_ALL_ACCESS);

    m_hCancelEvent = CreateEvent(acl, TRUE, FALSE, NULL);
    if (!m_hCancelEvent.IsValid())
    {
        dwSts = m_hCancelEvent.GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Card context cannot create cancel event:  %1"),
            dwSts);
        throw dwSts;
    }
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::~CSCardSubcontext")
CSCardSubcontext::~CSCardSubcontext()
{
    if (NULL != m_pChannel)
        delete m_pChannel;
    if (m_hBusy.IsValid())
        m_hBusy.Close();
    if (m_hCancelEvent.IsValid())
        m_hCancelEvent.Close();
}


/*++

Allocate:

    This method raises the state of the subcontext to 'Allocated'.  This means
    it is in use as an SCARDHANDLE.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/23/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::Allocate")

void
CSCardSubcontext::Allocate(
    void)
{
    LockSection(&m_csSubCtxLock, DBGT("Mark subcontext as allocated"));
    ASSERT(Idle == m_nInUse);
    ASSERT(Invalid == m_nLastState);
    m_nInUse = Allocated;
}


/*++

Deallocate:

    This method releases the subcontext from the allocated state.
    If the device is still busy, it sets things up to be deallocated
    when it is released.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/23/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::Deallocate")

void
CSCardSubcontext::Deallocate(
    void)
{
    LockSection(&m_csSubCtxLock, DBGT("Deallocate subcontext"));

    switch (m_nInUse)
    {
    case Idle:
        ASSERT(FALSE);  // Why are we here?
        break;
    case Allocated:
        m_nInUse = Idle;
        m_nLastState = Invalid;
        break;
    case Busy:
        ASSERT(Allocated == m_nLastState);
        m_nLastState = Idle;
        break;
    default:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Subcontext deallocation state corruption detected."));
        throw (DWORD)SCARD_F_INTERNAL_ERROR;
    }
}


/*++

SetBusy:

    This method marks the subcontext as busy.

Arguments:

    None

Return Value:

    None

Throws:

    None (It tries to limp along)

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 11/10/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::SetBusy")

void
CSCardSubcontext::SetBusy(
    void)
{
    LockSection(&m_csSubCtxLock, DBGT("Mark subcontext busy"));

    ASSERT(Busy != m_nInUse);
    ASSERT(Invalid == m_nLastState);
    ASSERT(m_hBusy.IsValid());
    m_nLastState = m_nInUse;
    m_nInUse = Busy;
    ASSERT(m_nLastState < m_nInUse);
    ASSERT(Invalid != m_nLastState);
    if (!ResetEvent(m_hBusy))
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Failed to mark context busy: %1"),
            GetLastError());
}


/*++

SendRequest:

    This method sends the given Communications Object to the server application.

Arguments:

    pCom supplies the Communications Object to be sent.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/16/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::SendRequest")

void
CSCardSubcontext::SendRequest(
    CComObject *pCom)
{
    ASSERT(Busy == m_nInUse);
    try
    {
        DWORD dwSts = pCom->Send(m_pChannel);
        if (ERROR_SUCCESS != dwSts)
            throw dwSts;
    }
    catch (DWORD dwErr)
    {
        switch (dwErr)
        {
        case ERROR_NO_DATA:
        case ERROR_PIPE_NOT_CONNECTED:
        case ERROR_BAD_PIPE:
        case ERROR_BROKEN_PIPE:
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
            break;
        default:
            throw;
        }
    }
}


/*++

EstablishContext:

    This method establishes the context by connecting to the Calais Server
    application.

Arguments:

    dwScope supplies an indication of the scope of the context.  Possible values
        are:

        SCARD_SCOPE_USER - The context is a user context, and any database
            operations are performed within the domain of the user.

        SCARD_SCOPE_TERMINAL - The context is that of the current terminal, and
            any database operations are performed within the domain of that
            terminal.  (The calling application must have appropriate access
            permissions for any database actions.)

        SCARD_SCOPE_SYSTEM - The context is the system context, and any database
            operations are performed within the domain of the system.  (The
            calling application must have appropriate access permissions for any
            database actions.)

Return Value:

    None

Throws:

    Error conditions are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 11/21/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::EstablishContext")

void
CSCardSubcontext::EstablishContext(
    IN DWORD dwScope)
{
    CComChannel *pCom = NULL;
    DWORD dwVersion = CALAIS_COMM_CURRENT;

    try
    {
        CComInitiator comInit;
        ComEstablishContext comEstablishContext;
        ComEstablishContext::CObjEstablishContext_request *pReq;
        ComEstablishContext::CObjEstablishContext_response *pRsp;
        LPCTSTR szCancelEvent;
        DWORD dwSts;

        ASSERT(Busy == m_nInUse);
        pCom = comInit.Initiate(
                    CalaisString(CALSTR_COMMPIPENAME),
                    &dwVersion);
        ASSERT(dwVersion == CALAIS_COMM_CURRENT);

        pReq = comEstablishContext.InitRequest(0);
        pReq->dwProcId = GetCurrentProcessId();
        pReq->hptrCancelEvent = (HANDLE_PTR) m_hCancelEvent.Value();

        comEstablishContext.Send(pCom);
        comEstablishContext.InitResponse(0);
        pRsp = comEstablishContext.Receive(pCom);
        if (SCARD_S_SUCCESS != pRsp->dwStatus)
            throw pRsp->dwStatus;

        szCancelEvent = (LPCTSTR)comEstablishContext.Parse(
                            pRsp->dscCancelEvent);
        if (0 != *szCancelEvent)
        {
            CHandleObject hCancelEvent(DBGT("Cancel Event storage from CSCardSubcontext::EstablishContext"));


            //
            // The Resource Manager doesn't have access to our event handles.
            // It's proposed a global event to use instead.  Switch over.
            //

            hCancelEvent = OpenEvent(
                                EVENT_MODIFY_STATE | SYNCHRONIZE,
                                FALSE,
                                szCancelEvent);
            if (!hCancelEvent.IsValid())
            {
                dwSts = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to open alternate cancel event: %1"),
                    dwSts);
                throw dwSts;
            }
            ASSERT(m_hCancelEvent.IsValid());
            m_hCancelEvent.Close();
            m_hCancelEvent = hCancelEvent.Relinquish();
        }

        m_pChannel = pCom;
    }

    catch (...)
    {
        if (NULL != pCom)
            delete pCom;
        throw;
    }
}


/*++

ReleaseSubcontext:

    This method releases the subcontext for use by other requests.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/22/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::ReleaseSubcontext")

void
CSCardSubcontext::ReleaseSubcontext(
    void)
{
    LockSection(&m_csSubCtxLock, DBGT("Mark subcontext available"));

    ASSERT(Idle != m_nInUse);
    ASSERT(Busy != m_nLastState);
    ASSERT(Invalid != m_nLastState);
    ASSERT(m_nInUse > m_nLastState);
    ASSERT(m_hBusy.IsValid());
    m_nInUse = m_nLastState;
    ASSERT(Busy != m_nInUse);
    m_nLastState = Invalid;
    if (!SetEvent(m_hBusy))
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Failed to mark context Available: %1"),
            GetLastError());
}


/*++

ReleaseContext:

    This method requests the ReleaseContext service on behalf of the client.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::ReleaseContext")

void
CSCardSubcontext::ReleaseContext(
    void)
{
    ComReleaseContext comRel;
    ComReleaseContext::CObjReleaseContext_request *pReq;
    ComReleaseContext::CObjReleaseContext_response *pRsp;

    if (WaitForSingleObject(m_hBusy, 0) != WAIT_TIMEOUT)    // Subcontext not busy
    {
        CSubctxLock csCtxLock(this);

        pReq = comRel.InitRequest(0);
        SendRequest(&comRel);

        comRel.InitResponse(0);
        pRsp = comRel.Receive(m_pChannel);
        if (SCARD_S_SUCCESS != pRsp->dwStatus)
            throw pRsp->dwStatus;
    }
}


/*++

WaitForAvailable:

    This method waits for a given connection to go not busy, then locks it.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/22/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::WaitForAvailable")

void
CSCardSubcontext::WaitForAvailable(
    void)
{
    DWORD dwSts;
    BOOL fNotDone = TRUE;

    ASSERT(m_hBusy.IsValid());

    while (fNotDone)
    {
        {
            LockSection(&m_csSubCtxLock, DBGT("Checking availability"));

            switch (m_nInUse)
            {
            case Idle:
                ASSERT(Invalid == m_nLastState);
                // Fall through intentionally
            case Allocated:
                ASSERT(Allocated != m_nLastState);
                SetBusy();
                fNotDone = FALSE;
                continue;
                break;
            case Busy:
                ASSERT(Busy > m_nLastState);
                ASSERT(Invalid != m_nLastState);
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Subcontext availability state is corrupted."));
                throw (DWORD)SCARD_F_INTERNAL_ERROR;
            }
        }

        dwSts = WaitForSingleObject(m_hBusy, CALAIS_LOCK_TIMEOUT);
        switch (dwSts)
        {
        case WAIT_ABANDONED:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Wait for context busy received wait abandoned."));
            break;
        case WAIT_OBJECT_0:
            break;
        case WAIT_TIMEOUT:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Wait for context busy timed out."),
                GetLastError());
            break;
        case WAIT_FAILED:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Wait for context busy failed: %1"),
                GetLastError());
            break;
        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Wait for context busy received invalid return: %1"),
                GetLastError());
        }
    }
}


/*++

IsValidContext:

    This method requests the ReleaseContext service on behalf of the client.

Arguments:

    None

Return Value:

    None

Throws:

    If the call cannot be completed, a DWORD status code is thrown.

Remarks:

    If the context is determined to not be valid, it is automatically released.

Author:

    Doug Barlow (dbarlow) 11/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::IsValidContext")

void
CSCardSubcontext::IsValidContext(
    void)
{
    ComIsValidContext comObj;
    ComIsValidContext::CObjIsValidContext_request *pReq;
    ComIsValidContext::CObjIsValidContext_response *pRsp;

    pReq = comObj.InitRequest(0);
    SendRequest(&comObj);
    comObj.InitResponse(0);
    pRsp = comObj.Receive(m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
}


/*++

LocateCards:

    This method requests the LocateCards service on behalf of the client.

Arguments:

    mszReaders supplies the names of readers to look in, as a multistring.

    mszCards supplies the names of the cards to search for, as a multi-string.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.  Reader names are taken from the
        mszReaders parameter, not from here.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::LocateCards")

void
CSCardSubcontext::LocateCards(
    IN LPCTSTR mszReaders,
    IN LPSCARD_ATRMASK rgAtrMasks,
    IN DWORD cAtrs,
    IN OUT LPSCARD_READERSTATE rgReaderStates,
    IN DWORD cReaders)
{
    ComLocateCards comObj;
    ComLocateCards::CObjLocateCards_request *pReq;
    ComLocateCards::CObjLocateCards_response *pRsp;
    CBuffer bfReaders;
    CBuffer bfStatus;
    CBuffer bfAtrs;
    CBuffer bfMasks;
    CBuffer bfXlate1(36); // Rough guess of name & ATR lengths
    LPDWORD rgdwStatus;
    DWORD dwIndex, dwChkLen;
    BYTE cbAtrLen;
    DWORD dwAtrLen;
    LPCBYTE pbAtr;
    LPCTSTR szReader;

    if (0 == cReaders)
        return;
    if (0 == *mszReaders)
        throw (DWORD)SCARD_E_UNKNOWN_READER;
    bfStatus.Resize(sizeof(DWORD) * cReaders);
    rgdwStatus = (LPDWORD)bfStatus.Access();


    //
    // List the smartcard ATRs and masks we're interested in.
    //

    for (dwIndex = 0;
         dwIndex < cAtrs;
         dwIndex++)
    {
        bfAtrs.Presize(bfAtrs.Length() + rgAtrMasks[dwIndex].cbAtr + 1, TRUE);
        bfMasks.Presize(bfMasks.Length() + rgAtrMasks[dwIndex].cbAtr + 1, TRUE);

        ASSERT(33 >= rgAtrMasks[dwIndex].cbAtr);    // Biggest an ATR can be.
        cbAtrLen = (BYTE)rgAtrMasks[dwIndex].cbAtr;
        bfAtrs.Append(&cbAtrLen, 1);
        bfAtrs.Append(rgAtrMasks[dwIndex].rgbAtr, cbAtrLen);

        bfMasks.Append(&cbAtrLen, 1);
        bfMasks.Append(rgAtrMasks[dwIndex].rgbMask, cbAtrLen);
    }


    //
    // List the reader devices we're interested in.
    //

    for (szReader = FirstString(mszReaders), dwIndex = 0;
         NULL != szReader;
         szReader = NextString(szReader), dwIndex += 1)
    {
        ASSERT(cReaders > dwIndex);
        BOOL fSts = GetReaderInfo(
                    Scope(),
                    szReader,
                    NULL,
                    &bfXlate1);
        if (!fSts)
            throw (DWORD)SCARD_E_UNKNOWN_READER;
        bfReaders.Append(
            bfXlate1.Access(),
            bfXlate1.Length());
        rgdwStatus[dwIndex] = rgReaderStates[dwIndex].dwCurrentState;
    }
    ASSERT(cReaders == dwIndex);
    bfReaders.Append((LPCBYTE)TEXT("\000"), sizeof(TCHAR));


    //
    // Put it all into the request.
    //

    pReq = comObj.InitRequest(
                bfAtrs.Length() + bfMasks.Length() + bfReaders.Length()
                + bfStatus.Length() + 4 * sizeof(DWORD));
    pReq = (ComLocateCards::CObjLocateCards_request *)comObj.Append(
                pReq->dscAtrs, bfAtrs.Access(), bfAtrs.Length());
    pReq = (ComLocateCards::CObjLocateCards_request *)comObj.Append(
                pReq->dscAtrMasks, bfMasks.Access(), bfMasks.Length());
    pReq = (ComLocateCards::CObjLocateCards_request *)comObj.Append(
                pReq->dscReaders, bfReaders.Access(), bfReaders.Length());
    pReq = (ComLocateCards::CObjLocateCards_request *)comObj.Append(
                pReq->dscReaderStates, bfStatus.Access(), bfStatus.Length());


    //
    // Send in the request.
    //

    SendRequest(&comObj);
    comObj.InitResponse(cReaders * sizeof(DWORD));
    pRsp = comObj.Receive(m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;


    //
    // Parse the response.
    //

    rgdwStatus = (LPDWORD)comObj.Parse(pRsp->dscReaderStates, &dwChkLen);
    if (dwChkLen != cReaders * sizeof(DWORD))
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Client locate cards array size mismatch"));
        throw (DWORD)SCARD_F_COMM_ERROR;
    }
    pbAtr = (LPCBYTE)comObj.Parse(pRsp->dscAtrs, &dwChkLen);

    for (dwIndex = 0; dwIndex < cReaders; dwIndex += 1)
    {
        rgReaderStates[dwIndex].dwEventState = rgdwStatus[dwIndex];
        dwAtrLen = *pbAtr++;
        ASSERT(33 >= dwAtrLen);
        if (dwAtrLen >= dwChkLen)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Client locate cards ATR size mismatch"));
            throw (DWORD)SCARD_F_COMM_ERROR;
        }
        ZeroMemory(
            rgReaderStates[dwIndex].rgbAtr,
            sizeof(SCARD_READERSTATE) - FIELD_OFFSET(SCARD_READERSTATE, rgbAtr));
        CopyMemory(rgReaderStates[dwIndex].rgbAtr, pbAtr, dwAtrLen);
        rgReaderStates[dwIndex].cbAtr = dwAtrLen;
        dwChkLen -= dwAtrLen + 1;
        pbAtr += dwAtrLen;
    }
}


/*++

GetStatusChange:

    This method requests the GetStatusChange service on behalf of the client.

Arguments:

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    None

Remarks:

    We don't have to clean up the cancel event, since this is a one-time usage
    of this sub-context.  Typically, if the subcontext were to be continued
    to be used, we'd have to make sure the cancel event got cleared eventually.

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::GetStatusChange")

void
CSCardSubcontext::GetStatusChange(
    IN LPCTSTR mszReaders,
    IN OUT LPSCARD_READERSTATE rgReaderStates,
    IN DWORD cReaders,
    IN DWORD dwTimeout)
{
    ComGetStatusChange comObj;
    ComGetStatusChange::CObjGetStatusChange_request *pReq;
    ComGetStatusChange::CObjGetStatusChange_response *pRsp;
    CBuffer bfReaders;
    CBuffer bfStatus;
    LPDWORD rgdwStatus;
    CBuffer bfXlate(16);    // Rough guess of device name length
    DWORD dwIndex, dwChkLen;
    BOOL fSts;
    LPCBYTE pbAtr;
    DWORD dwAtrLen;
    LPCTSTR szReader;

    if (0 == cReaders)
        return;
    bfStatus.Resize(sizeof(DWORD) * cReaders);
    rgdwStatus = (LPDWORD)bfStatus.Access();
    if (0 == *mszReaders)
        throw (DWORD)SCARD_E_UNKNOWN_READER;


    //
    // List the reader devices we're interested in.
    //

    for (szReader = FirstString(mszReaders), dwIndex = 0;
         NULL != szReader;
         szReader = NextString(szReader), dwIndex += 1)
    {
        ASSERT(cReaders > dwIndex);
        fSts = GetReaderInfo(
                    Scope(),
                    szReader,
                    NULL,
                    &bfXlate);
        if (fSts)
        {
            bfReaders.Append(
                bfXlate.Access(),
                bfXlate.Length());
        }
        else if (0 == _tcsncicmp(
                            CalaisString(CALSTR_SPECIALREADERHEADER),
                            szReader,
                            _tcslen(CalaisString(CALSTR_SPECIALREADERHEADER))))
        {
            bfReaders.Append(
                (LPCBYTE)szReader,
                (_tcslen(szReader) + 1) * sizeof(TCHAR));
        }
        else
            throw (DWORD)SCARD_E_UNKNOWN_READER;
        rgdwStatus[dwIndex] = rgReaderStates[dwIndex].dwCurrentState;
    }
    ASSERT(cReaders == dwIndex);
    bfReaders.Append((LPCBYTE)TEXT("\000"), sizeof(TCHAR));


    //
    // Put it all into the request.
    //

    pReq = comObj.InitRequest(
        bfReaders.Length() + bfStatus.Length()
        + 2 * sizeof(DWORD));
    pReq->dwTimeout = dwTimeout;
    pReq = (ComGetStatusChange::CObjGetStatusChange_request *)
            comObj.Append(
                pReq->dscReaders,
                bfReaders.Access(),
                bfReaders.Length());
    pReq = (ComGetStatusChange::CObjGetStatusChange_request *)
            comObj.Append(
                pReq->dscReaderStates,
                bfStatus.Access(),
                bfStatus.Length());

    SendRequest(&comObj);
    comObj.InitResponse(cReaders * sizeof(DWORD));
    pRsp = comObj.Receive(m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;

    rgdwStatus = (LPDWORD)comObj.Parse(pRsp->dscReaderStates, &dwChkLen);
    if (dwChkLen != cReaders * sizeof(DWORD))
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Client locate cards array size mismatch"));
        throw (DWORD)SCARD_F_COMM_ERROR;
    }
    pbAtr = (LPCBYTE)comObj.Parse(pRsp->dscAtrs, &dwChkLen);
    for (dwIndex = 0; dwIndex < cReaders; dwIndex += 1)
    {
        rgReaderStates[dwIndex].dwEventState = rgdwStatus[dwIndex];
        dwAtrLen = *pbAtr++;
        ASSERT(33 >= dwAtrLen);
        if (dwAtrLen >= dwChkLen)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Client locate cards ATR size mismatch"));
            throw (DWORD)SCARD_F_COMM_ERROR;
        }
        ZeroMemory(
            rgReaderStates[dwIndex].rgbAtr,
            sizeof(SCARD_READERSTATE) - FIELD_OFFSET(SCARD_READERSTATE, rgbAtr));
        CopyMemory(rgReaderStates[dwIndex].rgbAtr, pbAtr, dwAtrLen);
        rgReaderStates[dwIndex].cbAtr = dwAtrLen;
        dwChkLen -= dwAtrLen + 1;
        pbAtr += dwAtrLen;
    }
}


/*++

Cancel:

    This method requests the Cancel service on behalf of the client.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::Cancel")

void
CSCardSubcontext::Cancel(
    void)
{
    ASSERT(m_hCancelEvent.IsValid());
    if (!SetEvent(m_hCancelEvent))
        CalaisWarning(
        __SUBROUTINE__,
        DBGT("Cancel request Failed to set context cancel event: %1"),
        GetLastError());
}


/*++

StripInactiveReaders:

    This routine scans the supplied list of readers, and shortens it to exclude
    any readers that aren't currently active.

Arguments:

    bfReaders supplies a list of readers by friendly name.  This list is pruned
        to remove all names that refer to inactive readers.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

    All the listed readers must be introduced.  This routine does not filter
    undefined readers.

Author:

    Doug Barlow (dbarlow) 5/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CSCardSubcontext::StripInactiveReaders")

void
CSCardSubcontext::StripInactiveReaders(
    IN OUT CBuffer &bfReaders)
{
    ComListReaders comObj;
    ComListReaders::CObjListReaders_request *pReq;
    ComListReaders::CObjListReaders_response *pRsp;
    CBuffer bfDeviceName, bfDevices;
    LPCTSTR szReader;
    BOOL fSts;
    LPBOOL pfDeviceActive;
    DWORD dwReaderCount;


    //
    // Build the corresponding list of device names.
    //

    if (0 == *(LPCTSTR)bfReaders.Access())
        throw (DWORD)SCARD_E_NO_READERS_AVAILABLE;
    for (szReader = FirstString((LPCTSTR)bfReaders.Access());
         NULL != szReader;
         szReader = NextString(szReader))
    {
        fSts = GetReaderInfo(Scope(), szReader, NULL, &bfDeviceName);
        if (!fSts)
            throw (DWORD)SCARD_E_UNKNOWN_READER;
        MStrAdd(bfDevices, (LPCTSTR)bfDeviceName.Access());
    }


    //
    // Ask the resource manager which ones are active.
    //

    pReq = comObj.InitRequest(bfDevices.Length());
    pReq = (ComListReaders::CObjListReaders_request *)comObj.Append(
                pReq->dscReaders, bfDevices.Access(), bfDevices.Length());

    SendRequest(&comObj);
    comObj.InitResponse(0);
    pRsp = comObj.Receive(m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;

    pfDeviceActive = (LPBOOL)comObj.Parse(pRsp->dscReaders, &dwReaderCount);
    dwReaderCount /= sizeof(BOOL);
    ASSERT(dwReaderCount == MStringCount((LPCTSTR)bfReaders.Access()));


    //
    // Filter the inactive ones out of the original set.
    //

    bfDevices.Reset();
    for (szReader = FirstString((LPCTSTR)bfReaders.Access());
         NULL != szReader;
         szReader = NextString(szReader))
    {
        if (*pfDeviceActive++)
            MStrAdd(bfDevices, szReader);
    }


    //
    // Replace the original buffer.
    //

    bfReaders = bfDevices;
}


//
//==============================================================================
//
//  CReaderContext
//

#define INVALID_SCARDHANDLE_VALUE (INTERCHANGEHANDLE)(-1)


/*++

CReaderContext:
~CReaderContext:

    These are the constructor and destructor for a client reader context object.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/7/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::CReaderContext")

CReaderContext::CReaderContext(
    void)
{
    m_dwActiveProtocol = SCARD_PROTOCOL_UNDEFINED;
    m_pCtx = NULL;
    m_hCard = (INTERCHANGEHANDLE)INVALID_SCARDHANDLE_VALUE;
    m_hRedirCard = NULL;
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::~CReaderContext")
CReaderContext::~CReaderContext()
{
    try
    {
        if (NULL != m_pCtx)
        {
            Context()->Deallocate();
            Context()->ReleaseSubcontext();
            m_pCtx = NULL;
        }
    }
    catch (...) {}
}


/*++

Connect:

    This method requests the Connect service on behalf of the client.

Arguments:

    pCtx supplies the Context under which the reader is opened.

    szReaderName supplies the name of the reader to connect to.

    dwShareMode supplies the form of sharing to be invoked.

    dwPreferredProtocols supplies the acceptable protocols.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::Connect")

void
CReaderContext::Connect(
    CSCardSubcontext *pCtx,
    LPCTSTR szReaderName,
    DWORD dwShareMode,
    DWORD dwPreferredProtocols)
{
    ComConnect comObj;
    ComConnect::CObjConnect_request *pReq;
    ComConnect::CObjConnect_response *pRsp;
    BOOL fSts;
    CBuffer bfDevice;

    ASSERT(SCARD_PROTOCOL_UNDEFINED == m_dwActiveProtocol);
    ASSERT(NULL == m_pCtx);
    if (0 == *szReaderName)
        throw (DWORD)SCARD_E_UNKNOWN_READER;
    fSts = GetReaderInfo(
                pCtx->Scope(),
                szReaderName,
                NULL,
                &bfDevice);
    if (!fSts)
        throw (DWORD)SCARD_E_UNKNOWN_READER;

    pReq = comObj.InitRequest(bfDevice.Length() + sizeof(DWORD));
    pReq->dwShareMode = dwShareMode;
    pReq->dwPreferredProtocols = dwPreferredProtocols;
    pReq = (ComConnect::CObjConnect_request *)comObj.Append(
                pReq->dscReader, bfDevice.Access(), bfDevice.Length());
    pCtx->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(pCtx->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
    m_hCard = pRsp->hCard;
    m_dwActiveProtocol = pRsp->dwActiveProtocol;
    m_pCtx = pCtx;
}


/*++

Reconnect:

    This method requests the Reconnect service on behalf of the client.

Arguments:

    dwShareMode supplies the form of sharing to be invoked.

    dwPreferredProtocols supplies the acceptable protocols.

    dwInitialization supplies the card initialization required.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::Reconnect")

void
CReaderContext::Reconnect(
    DWORD dwShareMode,
    DWORD dwPreferredProtocols,
    DWORD dwInitialization)
{
    ComReconnect comObj;
    ComReconnect::CObjReconnect_request *pReq;
    ComReconnect::CObjReconnect_response *pRsp;
    CSubctxLock ctxLock(Context());

    pReq = comObj.InitRequest(0);
    pReq->hCard = m_hCard;
    pReq->dwShareMode = dwShareMode;
    pReq->dwPreferredProtocols = dwPreferredProtocols;
    pReq->dwInitialization = dwInitialization;
    Context()->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
    m_dwActiveProtocol = pRsp->dwActiveProtocol;
}


/*++

Disconnect:

    This method requests the Disconnect service on behalf of the client.

Arguments:

    dwDisposition - Supplies an indication of what should be done with the card
        in the connected reader.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::Disconnect")

LONG
CReaderContext::Disconnect(
    DWORD dwDisposition)
{
    ComDisconnect comObj;
    ComDisconnect::CObjDisconnect_request *pReq;
    ComDisconnect::CObjDisconnect_response *pRsp = NULL;
    CSubctxLock ctxLock(Context());

    try
    {
        pReq = comObj.InitRequest(0);
        pReq->hCard = m_hCard;
        pReq->dwDisposition = dwDisposition;
        Context()->SendRequest(&comObj);

        comObj.InitResponse(0);
        pRsp = comObj.Receive(Context()->m_pChannel);
    }
    catch (...) {}
    if (NULL != m_pCtx)
    {
        Context()->Deallocate();
        m_pCtx = NULL;
    }
    m_dwActiveProtocol = SCARD_PROTOCOL_UNDEFINED;
    m_hCard = INVALID_SCARDHANDLE_VALUE;
    return (NULL != pRsp) ? pRsp->dwStatus : SCARD_E_SERVICE_STOPPED;
}


/*++

BeginTransaction:

    This method requests the BeginTransaction service on behalf of the client.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::BeginTransaction")

void
CReaderContext::BeginTransaction(
    void)
{
    ComBeginTransaction comObj;
    ComBeginTransaction::CObjBeginTransaction_request *pReq;
    ComBeginTransaction::CObjBeginTransaction_response *pRsp;
    CSubctxLock ctxLock(Context());

    pReq = comObj.InitRequest(0);
    pReq->hCard = m_hCard;
    Context()->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
}


/*++

EndTransaction:

    This method requests the EndTransaction service on behalf of the client.

Arguments:

    dwDisposition supplies the disposition of the card.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::EndTransaction")

void
CReaderContext::EndTransaction(
    DWORD dwDisposition)
{
    DWORD dw;

    if (dwDisposition == SCARD_LEAVE_CARD_FORCE)
    {
        if (INVALID_SCARDHANDLE_VALUE == m_hCard)
        {
            return;
        }

        dw = SCARD_LEAVE_CARD;
    }
    else
    {
        dw = dwDisposition;
    }
    
    ComEndTransaction comObj;
    ComEndTransaction::CObjEndTransaction_request *pReq;
    ComEndTransaction::CObjEndTransaction_response *pRsp;
    CSubctxLock ctxLock(Context());

    pReq = comObj.InitRequest(0);
    pReq->hCard = m_hCard;
    pReq->dwDisposition = dw;
    Context()->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
}


/*++

Status:

    This method requests the Status service on behalf of the client.

Arguments:

    pdwState - This receives the current state of the reader.  Upon success, it
        receives one of the following state indicators:

        SCARD_ABSENT - This value implies there is no card in the reader.

        SCARD_PRESENT - This value implies there is a card is present in the
            reader, but that it has not been moved into position for use.

        SCARD_SWALLOWED - This value implies there is a card in the reader in
            position for use.  The card is not powered.

        SCARD_POWERED - This value implies there is power is being provided to
            the card, but the Reader Driver is unaware of the mode of the card.

        SCARD_NEGOTIABLEMODE - This value implies the card has been reset and is
            awaiting PTS negotiation.

        SCARD_SPECIFICMODE - This value implies the card has been reset and
            specific communication protocols have been established.

    pdwProtocol - This receives the current protocol, if any.  Possible returned
        values are listed below.  Other values may be added in the future.  The
        returned value is only meaningful if the returned state is
        SCARD_SPECIFICMODE.

        SCARD_PROTOCOL_RAW - The Raw Transfer Protocol is in use.

        SCARD_PROTOCOL_T0 - The ISO 7816/3 T=0 Protocol is in use.

        SCARD_PROTOCOL_T1 - The ISO 7816/3 T=1 Protocol is in use.

    bfAtr - This receives the current ATR, if any.

    bfReaderNames - This receives the list of friendly names assigned to the
        connected reader, as a MultiString.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 11/14/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::Status")

void
CReaderContext::Status(
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT CBuffer &bfAtr,
    OUT CBuffer &bfReaderNames)
{
    ComStatus comObj;
    ComStatus::CObjStatus_request *pReq;
    ComStatus::CObjStatus_response *pRsp;
    CBuffer bfSysName;
    LPCBYTE pbAtr;
    DWORD cbAtr;
    LPCTSTR szSysName;

    CSubctxLock ctxLock(Context());
    pReq = comObj.InitRequest(0);
    pReq->hCard = m_hCard;
    Context()->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
    *pdwState = pRsp->dwState;
    *pdwProtocol = pRsp->dwProtocol;
    pbAtr = (LPCBYTE)comObj.Parse(pRsp->dscAtr, &cbAtr);
    szSysName = (LPCTSTR)comObj.Parse(pRsp->dscSysName);
    bfAtr.Set(pbAtr, cbAtr);
    ListReaderNames(
        Context()->Scope(),
        szSysName,
        bfReaderNames);
}


/*++

Transmit:

    This method requests the Transmit service on behalf of the client.

Arguments:

    pioSendPci - This supplies the protocol header structure for the
        instruction.

    pbSendBuffer - This supplies the actual data to be written to the card in
        conjunction with the command.

    cbSendLength - This supplies the length of the pbDataBuffer parameter, in
        bytes.

    pioRecvPci - This receives the return protocol header structure from the
        instruction.

    bfRecvData - This receives any data returned from the card in conjunction
        with the command.

    cbProposedLength - This supplies a maximum length for the received data.
        If this value is zero, then the server uses the default max length.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::Transmit")

void
CReaderContext::Transmit(
    IN  LPCSCARD_IO_REQUEST pioSendPci,
    IN  LPCBYTE pbSendBuffer,
    IN  DWORD cbSendLength,
    OUT LPSCARD_IO_REQUEST pioRecvPci,
    OUT CBuffer &bfRecvData,
    IN  DWORD cbProposedLength)
{
    static const SCARD_IO_REQUEST ioNullPci = { 0, sizeof(SCARD_IO_REQUEST) };
    ComTransmit comObj;
    ComTransmit::CObjTransmit_request *pReq;
    ComTransmit::CObjTransmit_response *pRsp;
    LPSCARD_IO_REQUEST pioIoreq;
    DWORD cbIoreq, cbData;
    LPCBYTE pbData;
    CSubctxLock ctxLock(Context());

    if (NULL == pioSendPci)
        pioSendPci = &ioNullPci;
    pReq = comObj.InitRequest(pioSendPci->cbPciLength + cbSendLength
                                + 2 * sizeof(DWORD)
                                + 2 * sizeof(DWORD));
    pReq->hCard = m_hCard;
    pReq->dwPciLength = (NULL == pioRecvPci)
                        ? sizeof(SCARD_IO_REQUEST)
                        : pioRecvPci->cbPciLength;
    pReq->dwRecvLength = cbProposedLength;
    pReq = (ComTransmit::CObjTransmit_request *)comObj.Append(
                                            pReq->dscSendPci,
                                            (LPCBYTE)pioSendPci,
                                            pioSendPci->cbPciLength);
    pReq = (ComTransmit::CObjTransmit_request *)comObj.Append(
                                            pReq->dscSendBuffer,
                                            pbSendBuffer,
                                            cbSendLength);
    Context()->SendRequest(&comObj);

    comObj.InitResponse(pReq->dwPciLength + pReq->dwRecvLength
                        + 2 * sizeof(DWORD));
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
    pioIoreq = (LPSCARD_IO_REQUEST)comObj.Parse(pRsp->dscRecvPci, &cbIoreq);
    ASSERT(cbIoreq == pioIoreq->cbPciLength);
    if (NULL != pioRecvPci)
    {
        if (cbIoreq > pioRecvPci->cbPciLength)
            throw (DWORD)SCARD_E_PCI_TOO_SMALL;
        CopyMemory(pioRecvPci, pioIoreq, cbIoreq);
    }
    pbData = (LPCBYTE)comObj.Parse(pRsp->dscRecvBuffer, &cbData);
    bfRecvData.Set(pbData, cbData);
}


/*++

Control:

    This method requests the Control service on behalf of the client.

Arguments:

    dwControlCode - This supplies the control code for the operation. This value
        identifies the specific operation to be performed.

    pvInBuffer - This supplies a pointer to a buffer that contains the data
        required to perform the operation.  This parameter can be NULL if the
        dwControlCode parameter specifies an operation that does not require
        input data.

    cbInBufferSize - This supplies the size, in bytes, of the buffer pointed to
        by pvInBuffer.

    bfOutBuffer - This buffer receives the operation's output data.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::Control")

void
CReaderContext::Control(
    IN DWORD dwControlCode,
    IN LPCVOID pvInBuffer,
    IN DWORD cbInBufferSize,
    OUT CBuffer &bfOutBuffer)
{
    ComControl comObj;
    ComControl::CObjControl_request *pReq;
    ComControl::CObjControl_response *pRsp;
    LPCBYTE pbData;
    DWORD cbData;
    CSubctxLock ctxLock(Context());

    pReq = comObj.InitRequest(cbInBufferSize + sizeof(DWORD));
    pReq->hCard = m_hCard;
    pReq->dwControlCode = dwControlCode;
    pReq->dwOutLength = bfOutBuffer.Space();
    pReq = (ComControl::CObjControl_request *)
        comObj.Append(pReq->dscInBuffer, (LPCBYTE)pvInBuffer, cbInBufferSize);
    Context()->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
    pbData = (LPCBYTE)comObj.Parse(pRsp->dscOutBuffer, &cbData);
    bfOutBuffer.Set(pbData, cbData);
}


/*++

GetAttrib:

    This method requests the GetAttrib service on behalf of the client.

Arguments:

    dwAttrId - This supplies the identifier for the attribute to get.

    bfAttr - This buffer receives the attribute corresponding to the attribute
        id supplied in the dwAttrId parameter.

    cbProposedLength - This supplies a maximum length for the received data.
        If this value is zero, then the server uses the default max length.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::GetAttrib")

void
CReaderContext::GetAttrib(
    IN DWORD dwAttrId,
    OUT CBuffer &bfAttr,
    DWORD cbProposedLen)
{
    ComGetAttrib comObj;
    ComGetAttrib::CObjGetAttrib_request *pReq;
    ComGetAttrib::CObjGetAttrib_response *pRsp;
    LPCBYTE pbData;
    DWORD cbData;
    CSubctxLock ctxLock(Context());

    pReq = comObj.InitRequest(0);
    pReq->hCard = m_hCard;
    pReq->dwAttrId = dwAttrId;
    pReq->dwOutLength = cbProposedLen;
    Context()->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
    pbData = (LPCBYTE)comObj.Parse(pRsp->dscAttr, &cbData);
    bfAttr.Set(pbData, cbData);
}


/*++

SetAttrib:

    This method requests the SetAttrib service on behalf of the client.

Arguments:

    dwAttrId - This supplies the identifier for the attribute to get.

    pbAttr - This buffer supplies the attribute corresponding to the attribute
        id supplied in the dwAttrId parameter.

    cbAttrLength - This supplies the length of the attribute value in pbAttr
        buffer in bytes.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderContext::SetAttrib")

void
CReaderContext::SetAttrib(
    IN DWORD dwAttrId,
    IN LPCBYTE pbAttr,
    IN DWORD cbAttrLen)
{
    ComSetAttrib comObj;
    ComSetAttrib::CObjSetAttrib_request *pReq;
    ComSetAttrib::CObjSetAttrib_response *pRsp;
    CSubctxLock ctxLock(Context());

    pReq = comObj.InitRequest(0);
    pReq->hCard = m_hCard;
    pReq->dwAttrId = dwAttrId;
    pReq = (ComSetAttrib::CObjSetAttrib_request *)
            comObj.Append(pReq->dscAttr, pbAttr, cbAttrLen);
    Context()->SendRequest(&comObj);

    comObj.InitResponse(0);
    pRsp = comObj.Receive(Context()->m_pChannel);
    if (SCARD_S_SUCCESS != pRsp->dwStatus)
        throw pRsp->dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\client\client.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    client

Abstract:

    This header file collects the definitions for the Calais Client DLL.

Author:

    Doug Barlow (dbarlow) 11/21/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _CLIENT_H_
#define _CLIENT_H_

#define WINSCARDDATA
#include <WinSCard.h>
#include <calmsgs.h>
#include <CalCom.h>

#ifndef FACILITY_SCARD
#define FACILITY_SCARD 16
#endif
// #define ErrorCode(x) (0x80000000 | (FACILITY_SCARD << 16) + (x))
// #define WarnCode(x)  (0x80000000 | (FACILITY_SCARD << 16) + (x))
// #define InfoCode(x)  (0x40000000 | (FACILITY_SCARD << 16) + (x))
// #define SuccessCode(x)            ((FACILITY_SCARD << 16) + (x))
#define CONTEXT_HANDLE_ID 0xcd
#define READER_HANDLE_ID  0xea

#define SCARD_LEAVE_CARD_FORCE 0xff

extern CHandleList
    * g_phlContexts,
    * g_phlReaders;
extern const WCHAR
    g_wszBlank[];

class CSCardUserContext;
class CSCardSubcontext;
class CReaderContext;

extern void
PlaceResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPBYTE pbOutput,
    LPDWORD pcbLength);
extern void
PlaceResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPSTR szOutput,
    LPDWORD pcchLength);
extern void
PlaceResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPWSTR szOutput,
    LPDWORD pcchLength);
extern void
PlaceMultiResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPSTR mszOutput,
    LPDWORD pcchLength);
extern void
PlaceMultiResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPWSTR mszOutput,
    LPDWORD pcchLength);


//
//==============================================================================
//
//  CReaderContext
//

class CReaderContext
:   public CHandle
{
public:
    //  Constructors & Destructor
    CReaderContext();
    ~CReaderContext();

    //  Properties
    //  Methods
    DWORD Protocol(void) const
    { return m_dwActiveProtocol; };
    CSCardSubcontext *Context(void) const
    { ASSERT(NULL != m_pCtx);
      return m_pCtx; };

    void Connect(
            CSCardSubcontext *pCtx,
            LPCTSTR szReaderName,
            DWORD dwShareMode,
            DWORD dwPreferredProtocols);
    void Reconnect(
            DWORD dwShareMode,
            DWORD dwPreferredProtocols,
            DWORD dwInitialization);
    LONG Disconnect(
            DWORD dwDisposition);
    void BeginTransaction(
            void);
    void EndTransaction(
            DWORD dwDisposition);
    void Status(
            OUT LPDWORD pdwState,
            OUT LPDWORD pdwProtocol,
            OUT CBuffer &bfAtr,
            OUT CBuffer &bfReaderNames);
    void Transmit(
            IN  LPCSCARD_IO_REQUEST pioSendPci,
            IN LPCBYTE pbSendBuffer,
            IN DWORD cbSendLength,
            OUT LPSCARD_IO_REQUEST pioRecvPci,
            OUT CBuffer &bfRecvData,
            IN  DWORD cbProposedLength = 0);
    void Read(
            IN OUT LPSCARD_IO_REQUEST pioRequest,
            IN DWORD dwMaxLength,
            OUT CBuffer &bfData);
    void Write(
            IN OUT LPSCARD_IO_REQUEST pioRequest,
            IN LPCBYTE pbDataBuffer,
            IN DWORD cbDataLength);
    void Control(
            IN DWORD dwControlCode,
            IN LPCVOID pvInBuffer,
            IN DWORD cbInBufferSize,
            OUT CBuffer &bfOutBuffer);
    void GetAttrib(
            IN DWORD dwAttrId,
            OUT CBuffer &bfAttr,
            IN DWORD dwProposedLen = 0);
    void SetAttrib(
            IN DWORD dwAttrId,
            IN LPCBYTE pbAttr,
            IN DWORD cbAttrLen);

    void SetRedirCard(SCARDHANDLE hCard)
    { m_hRedirCard = hCard;};
    SCARDHANDLE GetRedirCard() const
    {return m_hRedirCard;};

    //  Operators

protected:
    //  Properties
    CSCardSubcontext *m_pCtx;
    INTERCHANGEHANDLE m_hCard;
    DWORD m_dwActiveProtocol;
    SCARDHANDLE m_hRedirCard;

    //  Methods
};


//
//==============================================================================
//
//  CSCardUserContext
//

class CSCardUserContext
:   public CHandle
{
public:
    //  Constructors & Destructor

    CSCardUserContext(DWORD dwScope);
    virtual ~CSCardUserContext();

    //  Properties

    //  Methods
    void EstablishContext(void);
    void ReleaseContext(void);
    LPVOID AllocateMemory(DWORD cbLength);
    DWORD FreeMemory(LPCVOID pvBuffer);
    DWORD Scope(void) const
    { return m_dwScope; };
    HANDLE HeapHandle(void) const
    { return m_hContextHeap; };
    CSCardSubcontext *AcquireSubcontext(BOOL fAndAllocate = FALSE);
    void LocateCards(
            IN LPCTSTR mszReaders,
            IN LPSCARD_ATRMASK rgAtrMasks,
            IN DWORD cAtrs,
            LPSCARD_READERSTATE rgReaderStates,
            DWORD cReaders);
    void GetStatusChange(
            IN LPCTSTR mszReaders,
            LPSCARD_READERSTATE rgReaderStates,
            DWORD cReaders,
            DWORD dwTimeout);
    void Cancel(void);
    void StripInactiveReaders(IN OUT CBuffer &bfReaders);
    BOOL IsValidContext(void);
    BOOL InitFailed(void) 
    { return m_csUsrCtxLock.InitFailed(); }

    void SetRedirContext(SCARDCONTEXT hRedirContext)
    { m_hRedirContext = hRedirContext;};
    SCARDCONTEXT GetRedirContext() const
    {return m_hRedirContext;};

    //  Operators
    BOOL fCallUnregister;

protected:
    //  Properties
    DWORD m_dwScope;
    CHandleObject m_hContextHeap;
    CDynamicArray<CSCardSubcontext> m_rgpSubContexts;
    CCriticalSectionObject m_csUsrCtxLock;
    SCARDCONTEXT m_hRedirContext;
    
    //  Methods

private:
    //  Properties
    //  Methods

    // Friends
    // friend class CReaderContext;
    // friend class CSCardSubcontext;
};


//
//==============================================================================
//
//  CSCardSubcontext
//

class CSCardSubcontext
{
public:
    typedef enum { Invalid, Idle, Allocated, Busy } State;

    //  Constructors & Destructor

    CSCardSubcontext();
    virtual ~CSCardSubcontext();

    //  Properties
    SCARDHANDLE m_hReaderHandle;

    //  Methods
    DWORD Scope(void) const
        { return m_pParentCtx->Scope(); };
    CSCardUserContext *Parent(void) const
        { return m_pParentCtx; };
    void SendRequest(CComObject *pCom);
    void EstablishContext(IN DWORD dwScope);
    void ReleaseContext(void);
    void ReleaseSubcontext(void);
    void LocateCards(
            IN LPCTSTR mszReaders,
            IN LPSCARD_ATRMASK rgAtrMasks,
            IN DWORD cAtrs,
            LPSCARD_READERSTATE rgReaderStates,
            DWORD cReaders);
    void GetStatusChange(
            IN LPCTSTR mszReaders,
            LPSCARD_READERSTATE rgReaderStates,
            DWORD cReaders,
            DWORD dwTimeout);
    void Cancel(void);
    void StripInactiveReaders(IN OUT CBuffer &bfReaders);
    void IsValidContext(void);
    void SetBusy(void);
    void WaitForAvailable(void);
    void Allocate(void);
    void Deallocate(void);
    BOOL InitFailed(void) 
    { return m_csSubCtxLock.InitFailed(); }

    //  Operators

protected:
    //  Properties
    State m_nInUse;
    State m_nLastState;
    CHandleObject m_hBusy; // Set => available, reset => busy.
    CHandleObject m_hCancelEvent;
    CSCardUserContext *m_pParentCtx;
    CComChannel *m_pChannel;
    CCriticalSectionObject m_csSubCtxLock;

    //  Methods

private:
    //  Properties
    //  Methods
    // Friends
    friend class CReaderContext;
    friend class CSCardUserContext;
};



//
//==============================================================================
//
//  CSubctxLock
//

class CSubctxLock
{
public:

    //  Constructors & Destructor
    CSubctxLock(CSCardSubcontext *pSubCtx)
    {
        m_pSubCtx = NULL;
        pSubCtx->WaitForAvailable();
        m_pSubCtx = pSubCtx;
    };

    ~CSubctxLock()
    {
        if (NULL != m_pSubCtx)
            m_pSubCtx->ReleaseSubcontext();
    };

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties
    CSCardSubcontext *m_pSubCtx;
    //  Methods
};

#endif // _CLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\client\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    makefile.inc.

!ENDIF

$(O)\scardmsg.mc: $(PROJECT_ROOT)\published\scard\scarderr.mc scardmsg.mch
    copy $(PROJECT_ROOT)\published\scard\scarderr.mc + scardmsg.mch $@

$(O)\scardmsg.h $(O)\scardmsg.rc $(O)\msg00001.bin: $(O)\scardmsg.mc
    mc -r .\$(O) -h .\$(O) $(O)\scardmsg.mc

winscard.rc: $(O)\scardmsg.h $(O)\scardmsg.rc $(O)\msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\client\redirect.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    redirect

Abstract:

    This header file collects the definitions for TS redirection.

Author:

    Louis Thomas (louisth) 4/4/2000

Environment:

    Win32, C++ w/ Exceptions

--*/

#ifndef _REDIRECT_H_
#define _REDIRECT_H_


//--------------------------------------------------------------------
// function prototypes
bool LoadRedirectionDll(void);
bool RedirectDisabled(void);
void SetRedirectDisabledValue(void);

BOOL WINAPI RedirDllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved);

#define TS_REDIRECT_DISABLED    (RedirectDisabled())
#define TS_REDIRECT_READY       ((g_bRedirectReady || LoadRedirectionDll()) && !TS_REDIRECT_DISABLED)
#define TS_REDIRECT_MODE        (0 != GetSystemMetrics(SM_REMOTESESSION))

//--------------------------------------------------------------------
// variables
extern bool  g_bRedirectReady;

extern WINSCARDAPI LONG (WINAPI * pfnSCardEstablishContext)(IN DWORD dwScope, IN LPCVOID pvReserved1, IN LPCVOID pvReserved2, OUT LPSCARDCONTEXT phContext);
extern WINSCARDAPI LONG (WINAPI * pfnSCardReleaseContext)(IN SCARDCONTEXT hContext);
extern WINSCARDAPI LONG (WINAPI * pfnSCardIsValidContext)(IN SCARDCONTEXT hContext);
extern WINSCARDAPI LONG (WINAPI * pfnSCardListReaderGroupsA)(IN SCARDCONTEXT hContext, OUT LPSTR mszGroups, IN OUT LPDWORD pcchGroups);
extern WINSCARDAPI LONG (WINAPI * pfnSCardListReaderGroupsW)(IN SCARDCONTEXT hContext, OUT LPWSTR mszGroups, IN OUT LPDWORD pcchGroups);
extern WINSCARDAPI LONG (WINAPI * pfnSCardListReadersA)(IN SCARDCONTEXT hContext, IN LPCSTR mszGroups, OUT LPSTR mszReaders, IN OUT LPDWORD pcchReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardListReadersW)(IN SCARDCONTEXT hContext, IN LPCWSTR mszGroups, OUT LPWSTR mszReaders, IN OUT LPDWORD pcchReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName, IN LPCSTR szDeviceName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName, IN LPCWSTR szDeviceName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardAddReaderToGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName, IN LPCSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardAddReaderToGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName, IN LPCWSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardRemoveReaderFromGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName, IN LPCSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardRemoveReaderFromGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName, IN LPCWSTR szGroupName);
extern WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsA)(IN SCARDCONTEXT hContext, IN LPCSTR mszCards, IN OUT LPSCARD_READERSTATE_A rgReaderStates, IN DWORD cReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsW)(IN SCARDCONTEXT hContext, IN LPCWSTR mszCards, IN OUT LPSCARD_READERSTATE_W rgReaderStates, IN DWORD cReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardGetStatusChangeA)(IN SCARDCONTEXT hContext, IN DWORD dwTimeout, IN OUT LPSCARD_READERSTATE_A rgReaderStates, IN DWORD cReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardGetStatusChangeW)(IN SCARDCONTEXT hContext, IN DWORD dwTimeout, IN OUT LPSCARD_READERSTATE_W rgReaderStates, IN DWORD cReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardCancel)(IN SCARDCONTEXT hContext);
extern WINSCARDAPI LONG (WINAPI * pfnSCardConnectA)(IN SCARDCONTEXT hContext, IN LPCSTR szReader, IN DWORD dwShareMode, IN DWORD dwPreferredProtocols, OUT LPSCARDHANDLE phCard, OUT LPDWORD pdwActiveProtocol);
extern WINSCARDAPI LONG (WINAPI * pfnSCardConnectW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReader, IN DWORD dwShareMode, IN DWORD dwPreferredProtocols, OUT LPSCARDHANDLE phCard, OUT LPDWORD pdwActiveProtocol);
extern WINSCARDAPI LONG (WINAPI * pfnSCardReconnect)(IN SCARDHANDLE hCard, IN DWORD dwShareMode, IN DWORD dwPreferredProtocols, IN DWORD dwInitialization, OUT LPDWORD pdwActiveProtocol);
extern WINSCARDAPI LONG (WINAPI * pfnSCardDisconnect)(IN SCARDHANDLE hCard, IN DWORD dwDisposition);
extern WINSCARDAPI LONG (WINAPI * pfnSCardBeginTransaction)(IN SCARDHANDLE hCard);
extern WINSCARDAPI LONG (WINAPI * pfnSCardEndTransaction)(IN SCARDHANDLE hCard, IN DWORD dwDisposition);
extern WINSCARDAPI LONG (WINAPI * pfnSCardState)(IN SCARDHANDLE hCard, OUT LPDWORD pdwState, OUT LPDWORD pdwProtocol, OUT LPBYTE pbAtr, IN OUT LPDWORD pcbAtrLen);
extern WINSCARDAPI LONG (WINAPI * pfnSCardStatusA)(IN SCARDHANDLE hCard, OUT LPSTR mszReaderNames, IN OUT LPDWORD pcchReaderLen, OUT LPDWORD pdwState, OUT LPDWORD pdwProtocol, OUT LPBYTE pbAtr, IN OUT LPDWORD pcbAtrLen);
extern WINSCARDAPI LONG (WINAPI * pfnSCardStatusW)(IN SCARDHANDLE hCard, OUT LPWSTR mszReaderNames, IN OUT LPDWORD pcchReaderLen, OUT LPDWORD pdwState, OUT LPDWORD pdwProtocol, OUT LPBYTE pbAtr, IN OUT LPDWORD pcbAtrLen);
extern WINSCARDAPI LONG (WINAPI * pfnSCardTransmit)(IN SCARDHANDLE hCard, IN LPCSCARD_IO_REQUEST pioSendPci, IN LPCBYTE pbSendBuffer, IN DWORD cbSendLength, IN OUT LPSCARD_IO_REQUEST pioRecvPci, OUT LPBYTE pbRecvBuffer, IN OUT LPDWORD pcbRecvLength);
extern WINSCARDAPI LONG (WINAPI * pfnSCardControl)(IN SCARDHANDLE hCard, IN DWORD dwControlCode,IN LPCVOID pvInBuffer, IN DWORD cbInBufferSize, OUT LPVOID pvOutBuffer, IN DWORD cbOutBufferSize, OUT LPDWORD pcbBytesReturned);
extern WINSCARDAPI LONG (WINAPI * pfnSCardGetAttrib)(IN SCARDHANDLE hCard, IN DWORD dwAttrId, OUT LPBYTE pbAttr, IN OUT LPDWORD pcbAttrLen);
extern WINSCARDAPI LONG (WINAPI * pfnSCardSetAttrib)(IN SCARDHANDLE hCard, IN DWORD dwAttrId, IN LPCBYTE pbAttr, IN DWORD cbAttrLen);
extern WINSCARDAPI HANDLE (WINAPI * pfnSCardAccessStartedEvent)(void);
extern WINSCARDAPI void   (WINAPI * pfnSCardReleaseStartedEvent)(void);
extern WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsByATRA)(IN SCARDCONTEXT hContext, IN LPSCARD_ATRMASK rgAtrMasks, IN DWORD cAtrs, IN OUT LPSCARD_READERSTATEA rgReaderStates, IN DWORD cReaders);
extern WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsByATRW)(IN SCARDCONTEXT hContext, IN LPSCARD_ATRMASK rgAtrMasks, IN DWORD cAtrs, IN OUT LPSCARD_READERSTATEW rgReaderStates, IN DWORD cReaders);


#endif //_REDIRECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\client\redirect.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Redirect

Abstract:

    This module supplies implementation to redirect the SCard* API calls
    so that they can be removed over a terminal services virtual channel.

Author:

    Louis Thomas (louisth) 4/4/2000

Environment:

    Win32, C++ w/ Exceptions

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <stdio.h>

#include "client.h"
#include "redirect.h"
#include "scardmsg.h"

#define REG_TERMINALSERVER_KEY  L"Software\\Policies\\Microsoft\\Windows NT\\Terminal Services"
#define REG_DISABLE_VALUE       L"fEnableSmartCard"

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

//====================================================================
// TS Redirection pointers
//====================================================================
bool g_bRedirectReady=false;
CRITICAL_SECTION g_csLoadingRedirect;

bool g_bRedirectDisabled=false;
CRITICAL_SECTION g_csCheckingDisabled;
bool g_bDisableChecked=false;
HANDLE g_hRegNotifyChange=NULL;

WINSCARDAPI LONG (WINAPI * pfnSCardEstablishContext)(IN DWORD dwScope, IN LPCVOID pvReserved1, IN LPCVOID pvReserved2, OUT LPSCARDCONTEXT phContext)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardReleaseContext)(IN SCARDCONTEXT hContext)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardIsValidContext)(IN SCARDCONTEXT hContext)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardListReaderGroupsA)(IN SCARDCONTEXT hContext, OUT LPSTR mszGroups, IN OUT LPDWORD pcchGroups)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardListReaderGroupsW)(IN SCARDCONTEXT hContext, OUT LPWSTR mszGroups, IN OUT LPDWORD pcchGroups)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardListReadersA)(IN SCARDCONTEXT hContext, IN LPCSTR mszGroups, OUT LPSTR mszReaders, IN OUT LPDWORD pcchReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardListReadersW)(IN SCARDCONTEXT hContext, IN LPCWSTR mszGroups, OUT LPWSTR mszReaders, IN OUT LPDWORD pcchReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName, IN LPCSTR szDeviceName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardIntroduceReaderW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName, IN LPCWSTR szDeviceName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardForgetReaderW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardAddReaderToGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName, IN LPCSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardAddReaderToGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName, IN LPCWSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardRemoveReaderFromGroupA)(IN SCARDCONTEXT hContext, IN LPCSTR szReaderName, IN LPCSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardRemoveReaderFromGroupW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReaderName, IN LPCWSTR szGroupName)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsA)(IN SCARDCONTEXT hContext, IN LPCSTR mszCards, IN OUT LPSCARD_READERSTATE_A rgReaderStates, IN DWORD cReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsW)(IN SCARDCONTEXT hContext, IN LPCWSTR mszCards, IN OUT LPSCARD_READERSTATE_W rgReaderStates, IN DWORD cReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardGetStatusChangeA)(IN SCARDCONTEXT hContext, IN DWORD dwTimeout, IN OUT LPSCARD_READERSTATE_A rgReaderStates, IN DWORD cReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardGetStatusChangeW)(IN SCARDCONTEXT hContext, IN DWORD dwTimeout, IN OUT LPSCARD_READERSTATE_W rgReaderStates, IN DWORD cReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardCancel)(IN SCARDCONTEXT hContext)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardConnectA)(IN SCARDCONTEXT hContext, IN LPCSTR szReader, IN DWORD dwShareMode, IN DWORD dwPreferredProtocols, OUT LPSCARDHANDLE phCard, OUT LPDWORD pdwActiveProtocol)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardConnectW)(IN SCARDCONTEXT hContext, IN LPCWSTR szReader, IN DWORD dwShareMode, IN DWORD dwPreferredProtocols, OUT LPSCARDHANDLE phCard, OUT LPDWORD pdwActiveProtocol)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardReconnect)(IN SCARDHANDLE hCard, IN DWORD dwShareMode, IN DWORD dwPreferredProtocols, IN DWORD dwInitialization, OUT LPDWORD pdwActiveProtocol)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardDisconnect)(IN SCARDHANDLE hCard, IN DWORD dwDisposition)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardBeginTransaction)(IN SCARDHANDLE hCard)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardEndTransaction)(IN SCARDHANDLE hCard, IN DWORD dwDisposition)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardState)(IN SCARDHANDLE hCard, OUT LPDWORD pdwState, OUT LPDWORD pdwProtocol, OUT LPBYTE pbAtr, IN OUT LPDWORD pcbAtrLen)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardStatusA)(IN SCARDHANDLE hCard, OUT LPSTR mszReaderNames, IN OUT LPDWORD pcchReaderLen, OUT LPDWORD pdwState, OUT LPDWORD pdwProtocol, OUT LPBYTE pbAtr, IN OUT LPDWORD pcbAtrLen)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardStatusW)(IN SCARDHANDLE hCard, OUT LPWSTR mszReaderNames, IN OUT LPDWORD pcchReaderLen, OUT LPDWORD pdwState, OUT LPDWORD pdwProtocol, OUT LPBYTE pbAtr, IN OUT LPDWORD pcbAtrLen)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardTransmit)(IN SCARDHANDLE hCard, IN LPCSCARD_IO_REQUEST pioSendPci, IN LPCBYTE pbSendBuffer, IN DWORD cbSendLength, IN OUT LPSCARD_IO_REQUEST pioRecvPci, OUT LPBYTE pbRecvBuffer, IN OUT LPDWORD pcbRecvLength)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardControl)(IN SCARDHANDLE hCard, IN DWORD dwControlCode,IN LPCVOID pvInBuffer, IN DWORD cbInBufferSize, OUT LPVOID pvOutBuffer, IN DWORD cbOutBufferSize, OUT LPDWORD pcbBytesReturned)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardGetAttrib)(IN SCARDHANDLE hCard, IN DWORD dwAttrId, OUT LPBYTE pbAttr, IN OUT LPDWORD pcbAttrLen)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardSetAttrib)(IN SCARDHANDLE hCard, IN DWORD dwAttrId, IN LPCBYTE pbAttr, IN DWORD cbAttrLen)=NULL;
WINSCARDAPI HANDLE (WINAPI * pfnSCardAccessStartedEvent)(void)=NULL;
WINSCARDAPI void   (WINAPI * pfnSCardReleaseStartedEvent)(void)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsByATRA)(IN SCARDCONTEXT hContext, IN LPSCARD_ATRMASK rgAtrMasks, IN DWORD cAtrs, IN OUT LPSCARD_READERSTATEA rgReaderStates, IN DWORD cReaders)=NULL;
WINSCARDAPI LONG (WINAPI * pfnSCardLocateCardsByATRW)(IN SCARDCONTEXT hContext, IN LPSCARD_ATRMASK rgAtrMasks, IN DWORD cAtrs, IN OUT LPSCARD_READERSTATEW rgReaderStates, IN DWORD cReaders)=NULL;


//====================================================================

struct NeededEntrypoint {
    void ** ppfn;
    CHAR * szFnName;
};

static NeededEntrypoint neProcList[]={
    { (void **)&pfnSCardEstablishContext, "SCardEstablishContext" },
    { (void **)&pfnSCardReleaseContext, "SCardReleaseContext" },
    { (void **)&pfnSCardIsValidContext, "SCardIsValidContext" },
    { (void **)&pfnSCardListReaderGroupsA, "SCardListReaderGroupsA" },
    { (void **)&pfnSCardListReaderGroupsW, "SCardListReaderGroupsW" },
    { (void **)&pfnSCardListReadersA, "SCardListReadersA" },
    { (void **)&pfnSCardListReadersW, "SCardListReadersW" },
    { (void **)&pfnSCardIntroduceReaderGroupA, "SCardIntroduceReaderGroupA" },
    { (void **)&pfnSCardIntroduceReaderGroupW, "SCardIntroduceReaderGroupW" },
    { (void **)&pfnSCardForgetReaderGroupA, "SCardForgetReaderGroupA" },
    { (void **)&pfnSCardForgetReaderGroupW, "SCardForgetReaderGroupW" },
    { (void **)&pfnSCardIntroduceReaderA, "SCardIntroduceReaderA" },
    { (void **)&pfnSCardIntroduceReaderW, "SCardIntroduceReaderW" },
    { (void **)&pfnSCardForgetReaderA, "SCardForgetReaderA" },
    { (void **)&pfnSCardForgetReaderW, "SCardForgetReaderW" },
    { (void **)&pfnSCardAddReaderToGroupA, "SCardAddReaderToGroupA" },
    { (void **)&pfnSCardAddReaderToGroupW, "SCardAddReaderToGroupW" },
    { (void **)&pfnSCardRemoveReaderFromGroupA, "SCardRemoveReaderFromGroupA" },
    { (void **)&pfnSCardRemoveReaderFromGroupW, "SCardRemoveReaderFromGroupW" },
    { (void **)&pfnSCardLocateCardsA, "SCardLocateCardsA" },
    { (void **)&pfnSCardLocateCardsW, "SCardLocateCardsW" },
    { (void **)&pfnSCardGetStatusChangeA, "SCardGetStatusChangeA" },
    { (void **)&pfnSCardGetStatusChangeW, "SCardGetStatusChangeW" },
    { (void **)&pfnSCardCancel, "SCardCancel" },
    { (void **)&pfnSCardConnectA, "SCardConnectA" },
    { (void **)&pfnSCardConnectW, "SCardConnectW" },
    { (void **)&pfnSCardReconnect, "SCardReconnect" },
    { (void **)&pfnSCardDisconnect, "SCardDisconnect" },
    { (void **)&pfnSCardBeginTransaction, "SCardBeginTransaction" },
    { (void **)&pfnSCardEndTransaction, "SCardEndTransaction" },
    { (void **)&pfnSCardState, "SCardState" },
    { (void **)&pfnSCardStatusA, "SCardStatusA" },
    { (void **)&pfnSCardStatusW, "SCardStatusW" },
    { (void **)&pfnSCardTransmit, "SCardTransmit" },
    { (void **)&pfnSCardControl, "SCardControl" },
    { (void **)&pfnSCardGetAttrib, "SCardGetAttrib" },
    { (void **)&pfnSCardSetAttrib, "SCardSetAttrib" },
    { (void **)&pfnSCardAccessStartedEvent, "SCardAccessStartedEvent" },
    { (void **)&pfnSCardReleaseStartedEvent, "SCardReleaseStartedEvent" },
    { (void **)&pfnSCardLocateCardsByATRA, "SCardLocateCardsByATRA" },
    { (void **)&pfnSCardLocateCardsByATRW, "SCardLocateCardsByATRW" }
};


////////////////////////////////////////////////////////////////////////////////
//
//  TS redirection support routines
//
//      The following services are used to redirect smart card API calls to
//      a different DLL, that will then marshal the calls over a terminal 
//      services virtual channel
//

//--------------------------------------------------------------------
void TsRdrLogEvent(WORD wType, DWORD dwEventID, unsigned int nStrings, const TCHAR ** rgtszStrings) {
    HANDLE hEventLog=RegisterEventSource(NULL, CalaisString(CALSTR_PRIMARYSERVICE));
    if (NULL!=hEventLog) {
        ReportEvent(hEventLog, wType, 0/*category*/, dwEventID, NULL, (WORD)nStrings, 0, rgtszStrings, NULL);
        DeregisterEventSource(hEventLog);
    }
}
//--------------------------------------------------------------------
HRESULT GetSystemErrorString(HRESULT hrIn, TCHAR ** ptszError) {
    HRESULT hr=S_OK;
    DWORD dwResult;
    TCHAR * rgParams[2]={
        NULL,
        (TCHAR *)(UINT_PTR)hrIn
    };

    // must be cleaned up
    TCHAR * tszErrorMessage=NULL;
    TCHAR * tszFullErrorMessage=NULL;

    // initialize input params
    *ptszError=NULL;

    // get the message from the system
    dwResult=FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
        NULL/*ignored*/, hrIn, 0/*language*/, (TCHAR *)&tszErrorMessage, 0/*min-size*/, NULL/*valist*/);
    if (0==dwResult) {
        if (ERROR_MR_MID_NOT_FOUND==GetLastError()) {
            rgParams[0]=_T("");
        } else {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
    } else {
        rgParams[0]=tszErrorMessage;

        // trim off \r\n if it exists
        if (L'\r'==tszErrorMessage[_tcslen(tszErrorMessage)-2]) {
            tszErrorMessage[_tcslen(tszErrorMessage)-2]=_T('\0');
        }
    }

    // add the error number
    dwResult=FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY, 
        _T("%1 (0x%2!08X!)"), 0, 0/*language*/, (TCHAR *)&tszFullErrorMessage, 0/*min-size*/, (va_list *)rgParams);
    if (0==dwResult) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto error;
    }

    // success
    *ptszError=tszFullErrorMessage;
    tszFullErrorMessage=NULL;
    hr=S_OK;
error:
    if (NULL!=tszErrorMessage) {
        LocalFree(tszErrorMessage);
    }
    if (NULL!=tszFullErrorMessage) {
        LocalFree(tszFullErrorMessage);
    }
    return hr;
}


//--------------------------------------------------------------------
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("DllMain")
BOOL WINAPI RedirDllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {

    bool fInitialized=false;

    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        
        // If we need to load the redirector DLL we will do this on the 
        // first smartcard call to be redirected.  So, create a critical 
        // section to be used when loading the redirector.
        __try {
            InitializeCriticalSection(&g_csLoadingRedirect);
            fInitialized = true;
            InitializeCriticalSection(&g_csCheckingDisabled);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            
            if (fInitialized)
            {
                DeleteCriticalSection(&g_csLoadingRedirect);         
            }
            return FALSE;
        }
        
        break;

    case DLL_PROCESS_DETACH:

        DeleteCriticalSection(&g_csLoadingRedirect);
        DeleteCriticalSection(&g_csCheckingDisabled);

        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return TRUE;
}

//--------------------------------------------------------------------
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("LoadRedirectionDll")
bool LoadRedirectionDll(void) {
    DWORD dwErr=ERROR_SUCCESS;
    unsigned int nIndex;

    // must be cleaned up
    bool bEnteredCritSec=false;
    bool bLogError=false;
    bool bRet=true;
    HMODULE hmRedirector=NULL;

    // make sure we are the only one trying to load the dll
    __try {
        EnterCriticalSection(&g_csLoadingRedirect);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        // give up
        dwErr=ERROR_NOT_ENOUGH_MEMORY;
        CalaisWarning(__SUBROUTINE__, DBGT("EnterCriticalSection failed."));
        goto error;
    }
    bEnteredCritSec=true;

    // now, our state may have changed. Check one more time
    if (true==g_bRedirectReady) {
        CalaisInfo(__SUBROUTINE__, DBGT("Redirection dll already loaded."));
        goto done;
    }

    // load the dll
    hmRedirector=LoadLibrary(TEXT("scredir.dll"));
    if (NULL==hmRedirector) {
        dwErr=GetLastError();
        TCHAR * tszError;
        if (S_OK==GetSystemErrorString(HRESULT_FROM_WIN32(dwErr), &tszError)) {
            const TCHAR * rgtszStrings[]={TEXT("scredir.dll"), tszError};
            CalaisDebug((DBGT("Logging error: The redirection DLL '%s' could not be loaded. The error was: %s\n"), TEXT("scredir.dll"), tszError));
            TsRdrLogEvent(EVENTLOG_ERROR_TYPE, MSG_TSREDIR_DLL_LOAD_FAIL, 2, rgtszStrings);
            LocalFree(tszError);
        }
        bLogError=false;
        goto error;
    }

    // get the pointers
    for (nIndex=0; nIndex<ARRAYSIZE(neProcList); nIndex++) {
        *neProcList[nIndex].ppfn=GetProcAddress(hmRedirector, neProcList[nIndex].szFnName);
        if (NULL==*neProcList[nIndex].ppfn) {
            dwErr=GetLastError();
            TCHAR * tszError;
            if (S_OK==GetSystemErrorString(HRESULT_FROM_WIN32(dwErr), &tszError)) {
                const TCHAR * rgtszStrings[]={neProcList[nIndex].szFnName, TEXT("scredir.dll"), tszError};
                CalaisDebug((DBGT("Logging error: The entry point '%s' could not be found in the redirection DLL '%s'. The error was: %s\n"), neProcList[nIndex].szFnName, TEXT("scredir.dll"), tszError));
                TsRdrLogEvent(EVENTLOG_ERROR_TYPE, MSG_TSREDIR_MISSING_ENTRY_POINT, 3, rgtszStrings);
                LocalFree(tszError);
            }
            bLogError=false;
            goto error;
        }
    }

    g_bRedirectReady=true;

done:
    hmRedirector=NULL; // don't unload library
error:
    if (NULL!=hmRedirector) {
        FreeLibrary(hmRedirector);
    }
    if (bEnteredCritSec) {
        LeaveCriticalSection(&g_csLoadingRedirect);
    }
    if (ERROR_SUCCESS!=dwErr) {
        
        bRet=false;

        if (bLogError) {
            TCHAR * tszError;
            if (S_OK==GetSystemErrorString(HRESULT_FROM_WIN32(dwErr), &tszError)) {
                const TCHAR * rgtszStrings[]={tszError};
                CalaisDebug((DBGT("Logging error: An unexpected error occurred trying to determine the redirection dll. The error was: %s\n"), tszError));
                TsRdrLogEvent(EVENTLOG_ERROR_TYPE, MSG_TSREDIR_UNEXPECTED, 1, rgtszStrings);
                LocalFree(tszError);
            }
        }

        SetLastError(dwErr);
    }
    return bRet;
}

#define NAME_VALUE_SIZE 20

void
SetRedirectDisabledValue(void)
{
    HKEY    hKey;
    DWORD   dwDisposition;
    WCHAR   wszValueName[NAME_VALUE_SIZE];
    DWORD   dwValueNameSize = NAME_VALUE_SIZE;
    DWORD   dwType;
    DWORD   dwValue;
    DWORD   dwValueSize = sizeof(DWORD);
    DWORD   dwIndex;
    LONG    lRet;

    //
    // See if the reg key exists, if so, then see if the fEnableSmartCard value exists
    //
    if (RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            REG_TERMINALSERVER_KEY,
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE, 
            KEY_READ, 
            NULL,
            &hKey, 
            &dwDisposition) == ERROR_SUCCESS)
    {
        dwIndex = 0;

        lRet = RegEnumValueW(
                    hKey,
                    dwIndex,
                    wszValueName,
                    &dwValueNameSize,
                    NULL,
                    &dwType,
                    (BYTE *) &dwValue,
                    &dwValueSize);

        while ((lRet == ERROR_SUCCESS) || (lRet == ERROR_MORE_DATA))
        {
            if ((lRet == ERROR_SUCCESS) &&
                (dwType == REG_DWORD)   &&
                (_wcsicmp(wszValueName, REG_DISABLE_VALUE) == 0))
            {
                g_bRedirectDisabled = (dwValue == 0);
                break;
            }
            else
            {
                dwValueNameSize = NAME_VALUE_SIZE;
                dwValueSize = sizeof(DWORD);
                dwIndex++;
                lRet = RegEnumValueW(
                            hKey,
                            dwIndex,
                            wszValueName,
                            &dwValueNameSize,
                            NULL,
                            &dwType,
                            (BYTE *) &dwValue,
                            &dwValueSize);
            }            
        }

        RegCloseKey(hKey);
    }
}


bool 
RedirectDisabled(void)
{
    if (g_bDisableChecked)
    {
        return (g_bRedirectDisabled);
    }

    // the disabled reg setting hashn't been checked yet, so check it.
    // make sure only one thread does it
    __try {
        EnterCriticalSection(&g_csCheckingDisabled);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        // give up
        CalaisWarning(__SUBROUTINE__, DBGT("EnterCriticalSection failed."));
        return (false);
    }

    //
    // Now that we are in the CritSec, check again
    //
    if (g_bDisableChecked)
    {
        LeaveCriticalSection(&g_csCheckingDisabled);
        return (g_bRedirectDisabled);
    }

    SetRedirectDisabledValue();
    
    //
    // register for registry change notifications
    //

    g_bDisableChecked = true;

    LeaveCriticalSection(&g_csCheckingDisabled);

    return (g_bRedirectDisabled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\client\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by winscard.rc
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\client\winscard.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    WinSCard

Abstract:

    This module supplies the API for the Calais Smartcard Service Manager.

    The Calais Service Manager does the work of coordinating the protocols,
    readers, drivers, and smartcards on behalf of the application.  The
    following services are provided as part of a library to simplify access to
    the Service Manager.  These routines are the documented, exposed APIs.
    These routines merely package the requests and forward them to the Calais
    Service Manager, allowing the actual implementation of Calais to vary over
    time.

    At no time does the API library make security decisions.  All
    security-related functions must be performed by the Service Manager, running
    in its own address space, or in the operating system kernel.  However, some
    utility routines may be implemented in the API library for speed, as long as
    they do not involve security decisions.


Author:

    Doug Barlow (dbarlow) 10/23/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <wtsapi32.h>
#include "client.h"
#include "redirect.h"

const SCARD_IO_REQUEST
    g_rgSCardT0Pci  = { SCARD_PROTOCOL_T0,  sizeof(SCARD_IO_REQUEST) },
    g_rgSCardT1Pci  = { SCARD_PROTOCOL_T1,  sizeof(SCARD_IO_REQUEST) },
    g_rgSCardRawPci = { SCARD_PROTOCOL_RAW, sizeof(SCARD_IO_REQUEST) };
CHandleList
    * g_phlContexts = NULL,
    * g_phlReaders = NULL;
const WCHAR g_wszBlank[] = L"\000";

HINSTANCE           g_hInst;
HWND                g_hSessionChangeWnd                         = NULL;
CRITICAL_SECTION    g_RegisterForSessionChangeNoticationsCS;
BOOL                g_fRegisteredForSessionChangeNotications    = FALSE;
BOOL                g_fTimerRegistered                          = FALSE;
DWORD               g_dwTimerCallbacksMade;
DWORD               g_dwClientCount                             = 0;
const TCHAR         szSessionChangeNotificationWndClass[]       = TEXT("WinscardSessionChangeWndClass");

CRITICAL_SECTION    g_SafeCreateHandleCS;
CRITICAL_SECTION    g_SetStartedEventCS;
CRITICAL_SECTION    g_RegisterForStoppedEventCS;
HANDLE              g_hWaitForStartedCallbackHandle             = NULL;
HANDLE              g_hUnifiedStartedEvent                      = NULL;
HANDLE              g_hWaitForStoppedCallbackHandle             = NULL;

CRITICAL_SECTION    g_TermSrvEnabledCS;
BOOL                g_fTermSrvEnableChecked                     = FALSE;
BOOL                g_bTermSrvEnabled                           = FALSE;


BOOL SetStartedEventWhenSCardSubsytemIsStarted(BOOL fUseLocal);


//
////////////////////////////////////////////////////////////////////////////////
//
//  Mark all current held contexts bad
//
WINSCARDAPI void WINAPI
MarkContextsAsBad(BOOL fCancel)
{
    try {
        g_phlContexts->MarkContentAsBad(fCancel);
        g_phlReaders->MarkContentAsBad(FALSE);
    }
    catch (...)
    {
    }
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  DllMain
//
BOOL WINAPI 
DllMain(
    HMODULE hInstDLL, 
    DWORD fdwReason, 
    LPVOID lpvReserved)
{
    DWORD dw;
    BOOL f;

    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:

        g_hInst = hInstDLL;

        try 
        {
            dw = 0;;
            InitializeCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
            dw++;
            InitializeCriticalSection(&g_SafeCreateHandleCS);
            dw++;
            InitializeCriticalSection(&g_SetStartedEventCS);
            dw++;
            InitializeCriticalSection(&g_TermSrvEnabledCS);
            dw++;
            InitializeCriticalSection(&g_RegisterForStoppedEventCS);
        } 
        catch(...) 
        {     
            if (dw >= 1)
            {
                DeleteCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
            }
            if (dw >= 2)
            {
                DeleteCriticalSection(&g_SafeCreateHandleCS);
            }
            if (dw >= 3)
            {
                DeleteCriticalSection(&g_SetStartedEventCS);
            }
            if (dw >= 4)
            {
                DeleteCriticalSection(&g_TermSrvEnabledCS);
            }
            return FALSE;
        }

        g_phlContexts = new CHandleList(CONTEXT_HANDLE_ID);
        g_phlReaders = new CHandleList(READER_HANDLE_ID);

        if ((NULL == g_phlContexts) || (NULL == g_phlReaders))
        {
            if (g_phlContexts)
            {
                DeleteCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
                DeleteCriticalSection(&g_SafeCreateHandleCS);
                DeleteCriticalSection(&g_SetStartedEventCS);
                DeleteCriticalSection(&g_TermSrvEnabledCS);
                DeleteCriticalSection(&g_RegisterForStoppedEventCS);
                delete g_phlContexts;
                g_phlContexts = NULL;
            }
            return FALSE;
        }
        
        if (g_phlContexts->InitFailed() || g_phlReaders->InitFailed())
        {
            DeleteCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
            DeleteCriticalSection(&g_SafeCreateHandleCS);
            DeleteCriticalSection(&g_SetStartedEventCS);
            DeleteCriticalSection(&g_TermSrvEnabledCS);
            DeleteCriticalSection(&g_RegisterForStoppedEventCS);
            return FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:

        //
        // The third parameter, lpvReserved, passed to DllMain
        // is NULL for FreeLibrary and non-NULL for ProcessExit.
        // Only clean up for FreeLibrary
        //
        if (lpvReserved == NULL)
        {
            //
            // Clean up the registered waits if they are still outstanding
            //
            HANDLE hCallbackToUnregister;

            hCallbackToUnregister = InterlockedExchangePointer(
                                        &g_hWaitForStartedCallbackHandle, 
                                        NULL);

            if (hCallbackToUnregister != NULL)
            {
                UnregisterWaitEx(hCallbackToUnregister, INVALID_HANDLE_VALUE);
            } 

            hCallbackToUnregister = InterlockedExchangePointer(
                                        &g_hWaitForStoppedCallbackHandle, 
                                        NULL);

            if (hCallbackToUnregister != NULL)
            {
                UnregisterWaitEx(hCallbackToUnregister, INVALID_HANDLE_VALUE);
            } 

            //
            // Cleanup CritSecs.
            //
            DeleteCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
            DeleteCriticalSection(&g_SafeCreateHandleCS);
            DeleteCriticalSection(&g_SetStartedEventCS);
            DeleteCriticalSection(&g_TermSrvEnabledCS);
            DeleteCriticalSection(&g_RegisterForStoppedEventCS);

            try {
                if (g_phlReaders)
                {
                    CHandle * pReader = g_phlReaders->GetFirst();

                    while (pReader != NULL)
                    {
                        try 
                        {
                            ((CReaderContext *) pReader)->EndTransaction(SCARD_LEAVE_CARD_FORCE);
                        }
                        catch (...){}

                        pReader = g_phlReaders->GetNext(pReader);
                    }

                    delete g_phlReaders;
                }
                    
                if (g_phlContexts)
                    delete g_phlContexts;
            }
            catch (...)
            {
            }

            ReleaseStartedEvent();
            ReleaseStoppedEvent();
            
            if (g_hSessionChangeWnd != NULL)
            {
                DestroyWindow(g_hSessionChangeWnd);
            }

            if (g_hUnifiedStartedEvent != NULL)
            {
                CloseHandle(g_hUnifiedStartedEvent);
            }
        }
        break;
    }

    return (RedirDllMain(hInstDLL, fdwReason, lpvReserved));
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  SessionChangeNotificationWndProc
//
INT_PTR CALLBACK
SessionChangeNotificationWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    switch (msg)
    {

    case WM_TIMER:
    {
        __try 
        {
            EnterCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
        } 
        __except(EXCEPTION_EXECUTE_HANDLER) 
        {            
            break;
        }

        if (!g_fRegisteredForSessionChangeNotications)
        {
            if (WTSRegisterSessionNotification(g_hSessionChangeWnd, NOTIFY_FOR_THIS_SESSION))
            {    
                g_fRegisteredForSessionChangeNotications = TRUE;
                KillTimer(g_hSessionChangeWnd, 1); // 1 is the timer id
                g_fTimerRegistered = FALSE;
                //OutputDebugString("WINSCARD: SessionChangeNotificationWndProc -  WTSRegisterSessionNotification SUCCEEDED!!\n");
            }  
            else if (++g_dwTimerCallbacksMade >= 60) // 60 attemps at 5 seconds each will be five minutes
            {
                KillTimer(g_hSessionChangeWnd, 1); // 1 is the timer id
                g_fTimerRegistered = FALSE;
                //OutputDebugString("WINSCARD: SessionChangeNotificationWndProc -  Bailing out!!\n");   
            }
                    
        }  
        else
        {
            //OutputDebugString("WINSCARD: SessionChangeNotificationWndProc -  Timer callback, but already registered!!\n");
            KillTimer(g_hSessionChangeWnd, 1); // 1 is the timer id
            g_fTimerRegistered = FALSE;
        }

        LeaveCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
        break;
    }

    case WM_WTSSESSION_CHANGE:
    {
        if ((wParam == WTS_CONSOLE_DISCONNECT) ||
            (wParam == WTS_REMOTE_DISCONNECT))
        {
            //
            // If there is an outstanding wait, it may be waiting on the wrong event,
            // so cancel the wait here.  When there is a connect event the 
            // SetStartedEventWhenSCardSubsytemIsStarted() API will be called again
            // to wait on the correct event
            //
            HANDLE hCallbackToUnregister;

            hCallbackToUnregister = InterlockedExchangePointer(
                                        &g_hWaitForStartedCallbackHandle, 
                                        NULL);

            if (hCallbackToUnregister != NULL)
            {
                UnregisterWaitEx(hCallbackToUnregister, INVALID_HANDLE_VALUE);
            }

            //
            // Make sure the unified started event isn't set since we 
            // are now in a disconnected state
            //
            //OutputDebugString("WINSCARD: Disconnect\n");
            ResetEvent(g_hUnifiedStartedEvent);
            MarkContextsAsBad(TRUE);   
        }
        else if ((wParam == WTS_CONSOLE_CONNECT) ||
                 (wParam == WTS_REMOTE_CONNECT))
        {
            //OutputDebugString("WINSCARD: Reconnect\n");
            SetRedirectDisabledValue();
            SetStartedEventWhenSCardSubsytemIsStarted(FALSE);
        }

        break;
    }

    case WM_QUIT:
    case WM_ENDSESSION:
    {
        if (g_fTimerRegistered)
        {
            KillTimer(g_hSessionChangeWnd, 1); 
            g_fTimerRegistered = FALSE;
        }
        break;
    }

    default:

        break;
    }

    return (DefWindowProc (hwnd, msg, wParam, lParam));
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  CreateHiddenWindow
//
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CreateHiddenWindow")

BOOL
CreateHiddenWindow()
{
    BOOL        fRet = TRUE;
    WNDCLASS    wndclass;

    if (g_hSessionChangeWnd != NULL)
    {
        return TRUE;
    }

    memset(&wndclass, 0, sizeof(WNDCLASS));
    wndclass.lpfnWndProc   = (WNDPROC) SessionChangeNotificationWndProc;
    wndclass.hInstance     = g_hInst;
    wndclass.lpszClassName = szSessionChangeNotificationWndClass;

    if ((0 == RegisterClass(&wndclass)) &&
        (GetLastError() != ERROR_CLASS_ALREADY_EXISTS))
    {
        CalaisWarning(__SUBROUTINE__, DBGT("Client failed to RegisterClass"));
        fRet = FALSE;
    }
    else
    {
        g_hSessionChangeWnd = CreateWindow(
                szSessionChangeNotificationWndClass,    // class name
                NULL,                                   // title
                0,                                      // dwStyle
                0,                                      // x
                0,                                      // y
                0,                                      // width
                0,                                      // height
                HWND_MESSAGE,                           // parent wnd
                (HMENU) NULL,                           // menu
                g_hInst,                                // instance
                NULL                                    // params
                );

        if (g_hSessionChangeWnd == NULL)
        {
            CalaisWarning(__SUBROUTINE__, DBGT("Client failed to CreateWindow"));
            fRet = FALSE;
        }
    }

    return fRet;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  RegisterForSessionChangeNotifications
//
BOOL
RegisterForSessionChangeNotifications()
{
    BOOL fRet = TRUE;

    //
    // Make sure we only register for session change notifications once
    //
    __try 
    {
        EnterCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {            
        return FALSE;
    }

    g_dwClientCount++;   
    
    //
    // Create the window that recieves the session change notifications
    //
    if (!CreateHiddenWindow())
    {
        //OutputDebugString("WINSCARD: RegisterForSessionChangeNotifications - CreateHiddenWindow failed!!\n");
        goto ErrorReturn;
    }

    //
    // Register the window with the WTS subsystem
    //
    if (!g_fRegisteredForSessionChangeNotications)
    {
        if (WTSRegisterSessionNotification(g_hSessionChangeWnd, NOTIFY_FOR_THIS_SESSION))
        {        
            g_fRegisteredForSessionChangeNotications = TRUE;           
        }
        else
        {
            //OutputDebugString("WINSCARD: RegisterForSessionChangeNotifications - WTSRegisterSessionNotification failed!!\n");

            //
            // Since the WTSRegisterSessionNotification call failed, TermSrv probably
            // isn't ready, so just register for a timer callback and try to register
            // again later
            //
            if (SetTimer(g_hSessionChangeWnd, 1, 5000, NULL) == 0) // 1 is is the timer id
            {
                //OutputDebugString("WINSCARD: RegisterForSessionChangeNotifications - SetTimer failed!!\n");
                goto ErrorReturn;  
            }
            else
            {
                g_fTimerRegistered = TRUE;
                g_dwTimerCallbacksMade = 0;
            }
        }        
    }    

Return:

    LeaveCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
    return fRet;

ErrorReturn:

    g_dwClientCount--;
    fRet = FALSE;
    goto Return;
}

//
////////////////////////////////////////////////////////////////////////////////
//
//  UnRegisterForSessionChangeNotifications
//
BOOL
UnRegisterForSessionChangeNotifications()
{
    BOOL fRet = TRUE;

    //
    // Make sure we only unregister if there are no more clients
    //
    __try 
    {
        EnterCriticalSection(&g_RegisterForSessionChangeNoticationsCS);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {            
        return FALSE;
    }
    
    if (g_dwClientCount == 0)
    {
        fRet = FALSE;
        goto Return;
    }
    else if (g_dwClientCount == 1)
    {
        g_dwClientCount = 0;
        if (g_fRegisteredForSessionChangeNotications)
        {
            //OutputDebugString("WINSCARD: WTSUnRegisterSessionNotification!!\n");
            WTSUnRegisterSessionNotification(g_hSessionChangeWnd);   
        }

        g_fRegisteredForSessionChangeNotications = FALSE;  
    }
    else
    {
        g_dwClientCount--;
    }

Return:

    LeaveCriticalSection(&g_RegisterForSessionChangeNoticationsCS);

    return fRet;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  SetStartedEventAfterTestingConnectedState
//
BOOL
SetStartedEventAfterTestingConnectedState()
{
    BOOL                    fRet            = TRUE;
    WTS_CONNECTSTATE_CLASS  *pConnectState  = NULL;
    BOOL                    fConnected      = FALSE;
    DWORD                   dw;
    BOOL                    fUnregister     = FALSE;
    
    //
    // Register for connect/disconnect notifications from the WTS subsystem
    //
    if (!RegisterForSessionChangeNotifications())
    {        
        //OutputDebugString("WINSCARD: SetStartedEventAfterTestingConnectedState - RegisterForSessionChangeNotifications failed!!\n");
        goto ErrorReturn;
    }

    fUnregister = TRUE;
    
    //
    // Detect whether we are in a connected state or not
    //
    if (!WTSQuerySessionInformation(
            WTS_CURRENT_SERVER_HANDLE,
            WTS_CURRENT_SESSION,
            WTSConnectState, 
            (LPTSTR *) &pConnectState,
            &dw))
    {
        //OutputDebugString("WINSCARD: SetStartedEventAfterTestingConnectedState - WTSQuerySessionInformation failed!!\n");
        
        //
        // Since that failed, TermSrv is probably not started, so just go local
        //
        if (!SetStartedEventWhenSCardSubsytemIsStarted(TRUE))
        {
            goto ErrorReturn;
        }

        goto Return;
    }

    fConnected = (  (*pConnectState == WTSActive) ||
                    (*pConnectState == WTSConnected));

    WTSFreeMemory(pConnectState);

    //
    // If we are connected, then call SetStartedEventWhenSCardSubsytemIsStarted
    // which will detect whether we are in local or redirect mode and subsequently
    // wait on the appropriate smart card subsystem (the local or the remote).
    // Otherwise, we are not connected, so do nothing since 
    // SetStartedEventWhenSCardSubsytemIsStarted will be called once when we get 
    // a connnected notification from the WTS subsystem
    //
    if (fConnected)
    {
        //OutputDebugString("WINSCARD: SetStartedEventAfterTestingConnectedState - Connected!!\n");
        if (!SetStartedEventWhenSCardSubsytemIsStarted(FALSE))
        {
            goto ErrorReturn;
        }
    }
    else
    {
        //OutputDebugString("WINSCARD: SetStartedEventAfterTestingConnectedState - NOT Connected!!\n");
    }

Return:
    return fRet;

ErrorReturn:

    if (fUnregister)
    {
        UnRegisterForSessionChangeNotifications();    
    }

    fRet = FALSE;
    goto Return;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  TermSrvEnabled
//
BOOL
TermSrvEnabled()
{
    BOOL                    fRet             = TRUE;
    SC_HANDLE               schSCM           = NULL;
    SC_HANDLE               schService       = NULL;
    LPQUERY_SERVICE_CONFIG  pServiceConfig   = NULL;
    DWORD                   cbServiceConfig  = 0;

    //
    // Make sure we only do this once
    //
    __try 
    {
        EnterCriticalSection(&g_TermSrvEnabledCS);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {            
        return FALSE;
    }

    if (g_fTermSrvEnableChecked)
    {        
        goto Return;
    }

    //OutputDebugString("WINSCARD: TermSrvEnabled!!\n");

    //
    // Open the service control manager
    //
    schSCM = OpenSCManagerW( NULL, NULL, SC_MANAGER_CONNECT );
    if(schSCM == NULL)
    {
        //OutputDebugString("WINSCARD: TermSrvEnabled - OpenSCManagerW failed!!\n");
        goto Return;
    }

    //
    // open the "Terminal Services" service so we can query it's configuration
    //
    schService = OpenServiceW(schSCM, L"TermService", SERVICE_QUERY_CONFIG);

    if (schService == NULL)
    {
        //OutputDebugString("WINSCARD: TermSrvEnabled - OpenServiceW failed!!\n");
        goto Return;   
    }
  
    //
    // Get and check the services configuration
    //
    QueryServiceConfig(schService, NULL, 0, &cbServiceConfig);
    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
    {
        pServiceConfig = (LPQUERY_SERVICE_CONFIG) HeapAlloc(
                                                    GetProcessHeap(),
                                                    HEAP_ZERO_MEMORY,
                                                    cbServiceConfig);
        if (pServiceConfig == NULL)
        {
            goto Return; 
        }

        if (QueryServiceConfig(schService, pServiceConfig, cbServiceConfig, &cbServiceConfig)) 
        {
            if(pServiceConfig->dwStartType == SERVICE_DISABLED) 
            {
                g_fTermSrvEnableChecked = TRUE;
                goto Return;
            }           
        }
        else
        {
            //OutputDebugString("WINSCARD: TermSrvEnabled - QueryServiceConfig failed - 2!!\n");
            goto Return;
        }      
    }
    else
    {
        //OutputDebugString("WINSCARD: TermSrvEnabled - QueryServiceConfig failed!!\n");
        goto Return;
    }

    //OutputDebugString("WINSCARD: TermSrvEnabled - ENABLED!!\n");
    g_fTermSrvEnableChecked = TRUE;
    g_bTermSrvEnabled = TRUE;

Return:

    LeaveCriticalSection(&g_TermSrvEnabledCS);
    
    if (pServiceConfig != NULL)
    {
        HeapFree(GetProcessHeap(), 0, pServiceConfig);
    }

    if (schService != NULL)
    {
        CloseServiceHandle(schService);
    }

    if (schSCM != NULL)
    {
        CloseServiceHandle(schSCM);
    }

    return g_bTermSrvEnabled;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  SafeCreateEvent
//
BOOL
SafeCreateEvent(
    HANDLE *phEvent)
{
    BOOL fRet = TRUE;

    __try 
    {
        EnterCriticalSection(&g_SafeCreateHandleCS);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {            
        return (FALSE);
    }

    if (*phEvent != NULL)
    {
        goto Return;
    }

    *phEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (*phEvent == NULL)
    {
        fRet = FALSE;
    }

Return:
    LeaveCriticalSection(&g_SafeCreateHandleCS);
    return (fRet);
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  SmartCardSubsystemStoppedCallback and RegisterForStoppedCallback
//
VOID CALLBACK SmartCardSubsystemStoppedCallback(
  PVOID     lpParameter,        
  BOOLEAN   TimerOrWaitFired  
)
{
    HANDLE hCallbackToUnregister;

    //OutputDebugString("WINSCARD: SmartCardSubsystemStoppedCallback - resetting event \n");
    ResetEvent(g_hUnifiedStartedEvent);

    SetStartedEventWhenSCardSubsytemIsStarted(TRUE);

    hCallbackToUnregister = InterlockedExchangePointer(
                                &g_hWaitForStoppedCallbackHandle, 
                                NULL);

    if (hCallbackToUnregister != NULL)
    {
        UnregisterWait(hCallbackToUnregister);
    }  
}

BOOL
RegisterForStoppedCallback()
{
    BOOL    fRet        = TRUE;
    BOOL    fEnteredCS  = FALSE;
    HANDLE  h           = NULL;
    
    h = AccessStoppedEvent();
    if (h == NULL)
    {
        goto ErrorReturn;    
    }

    __try 
    {
        EnterCriticalSection(&g_RegisterForStoppedEventCS);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {            
        goto ErrorReturn;
    }

    fEnteredCS = TRUE;

    if (g_hWaitForStoppedCallbackHandle != NULL)
    {
        goto Return;
    }

    if (!RegisterWaitForSingleObject(
            &g_hWaitForStoppedCallbackHandle,
            h,
            SmartCardSubsystemStoppedCallback,
            0,
            INFINITE,
            WT_EXECUTEONLYONCE))
    {
        goto ErrorReturn;
    }    

Return:

    if (fEnteredCS)
    {
        LeaveCriticalSection(&g_RegisterForStoppedEventCS);    
    }
    
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto Return;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  SmartCardSubsystemStartedCallback
//
//  This callback is fired when the smart card subsystem sets its started event.
//  NOTE: Both local and remote scard subsystems being started will fire this 
//  same callback
// 
VOID CALLBACK SmartCardSubsystemStartedCallback(
  PVOID     lpParameter,        
  BOOLEAN   TimerOrWaitFired  
)
{
    BOOL fLocal = (lpParameter == (PVOID) 1);
    HANDLE hCallbackToUnregister;

    //OutputDebugString("WINSCARD: SmartCardSubsystemStartedCallback - setting event \n");
    SetEvent(g_hUnifiedStartedEvent);

    if (fLocal)
    {
        RegisterForStoppedCallback();                   
    }

    hCallbackToUnregister = InterlockedExchangePointer(
                                &g_hWaitForStartedCallbackHandle, 
                                NULL);

    if (hCallbackToUnregister != NULL)
    {
        UnregisterWait(hCallbackToUnregister);
    }  
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  SetStartedEventWhenSCardSubsytemIsStarted
//
BOOL
SetStartedEventWhenSCardSubsytemIsStarted(
    BOOL fUseLocal)
{
    HANDLE  h               = NULL;
    BOOL    fRet            = TRUE;
    BOOL    fEnteredCritSec = FALSE;
    BOOL    fLocal          = FALSE;

    //
    // If termsrv is enabled and we are in redirect mode then get the 
    // started event that corresponds to the remoted scard subsystem being
    // available, otherwise, get the started event of the local scard 
    // resource manager
    //
    if (!fUseLocal && TermSrvEnabled() && TS_REDIRECT_MODE) 
    {
        //OutputDebugString("WINSCARD: SetStartedEventWhenSCardSubsytemIsStarted REDIRECT\n");
        //
        // if redirect is disabled, then just get out
        //
        if (TS_REDIRECT_DISABLED)
        {
            goto Return;
        }

        if (TS_REDIRECT_READY)
        {
            h = pfnSCardAccessStartedEvent();
        }
        else
        {
            goto ErrorReturn;
        }
    }
    else
    {
        //OutputDebugString("WINSCARD: SetStartedEventWhenSCardSubsytemIsStarted LOCAL\n");
        h = AccessStartedEvent();
        fLocal = TRUE;
    }

    if (h == NULL)
    {
        goto ErrorReturn;
    }

    //
    // If the event is already set, then just set the event returned
    // to the caller and return
    //
    if (WAIT_OBJECT_0 == WaitForSingleObject(h, 0))
    {
        //OutputDebugString("WINSCARD: SetStartedEventWhenSCardSubsytemIsStarted SETTING EVENT\n");
        SetEvent(g_hUnifiedStartedEvent);
        
        if (fLocal)
        {
            RegisterForStoppedCallback();                   
        }

        goto Return;
    }

    //
    // The event wasn't set so we need to register a callback which
    // fires when the scard subsystem is started.
    //
    // Make sure only one callback is registered.
    //
    __try 
    {
        EnterCriticalSection(&g_SetStartedEventCS);
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {            
        goto ErrorReturn;
    }

    fEnteredCritSec = TRUE;

    //
    // There is already a callback registered, so just get out
    //
    if (g_hWaitForStartedCallbackHandle != NULL)
    {
        goto Return;
    }

    //
    // Register for the callback.  The callback is fired when the smart
    // card resource manager event is set (either the remote or the local
    // subsystem event, based on whether this is a redirected session or not).
    //
    if (!RegisterWaitForSingleObject(
            &g_hWaitForStartedCallbackHandle,
            h,
            SmartCardSubsystemStartedCallback,
            (fLocal ? ((PVOID) 1) : ((PVOID) 0)), // tell the callback whether this is local or not
            INFINITE,
            WT_EXECUTEONLYONCE))
    {
        goto ErrorReturn;
    }

Return:
    if (fEnteredCritSec)
    {
        LeaveCriticalSection(&g_SetStartedEventCS);
    }

    return (fRet);

ErrorReturn:
    fRet = FALSE;
    goto Return;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Service Manager Access Services
//
//      The following services are used to manage user and terminal contexts for
//      smartcards.
//

/*++

SCardEstablishContext:

    This service establishes a context within which communication to the Service
    Manager is performed.

Arguments:

    dwScope supplies the scope under which this context acts.  Possible values
        are:

        SCARD_SCOPE_USER - The context is a user context, and any database
            operations are performed within the domain of the user.

        SCARD_SCOPE_TERMINAL - The context is that of the current terminal, and
            any database operations are performed within the domain of that
            terminal.  (The calling application must have appropriate access
            permissions for any database actions.)

        SCARD_SCOPE_SYSTEM - The context is the system context, and any database
            operations are performed within the domain of the system.  (The
            calling application must have appropriate access permissions for any
            database actions.)

    pvReserved1 is reserved for future use, and must be NULL.  [Reserved to
        allow a suitably privileged management application to act on behalf of
        another user.]

    PvReserved2 is reserved for future use, and must be NULL.  [Reserved to
        allow a suitably privileged management application to act on behalf of
        another terminal.]

    phContext receives a handle to the established context, to be supplied to
        other routines attempting to do work within the context.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardEstablishContext")

WINSCARDAPI LONG WINAPI
SCardEstablishContext(
    IN DWORD dwScope,
    IN LPCVOID pvReserved1,
    IN LPCVOID pvReserved2,
    OUT LPSCARDCONTEXT phContext)
{
    LONG nReturn = SCARD_S_SUCCESS;
    CSCardUserContext *pCtx = NULL;
    
    try
    {
        if (NULL != pvReserved1)
            throw (DWORD)SCARD_E_INVALID_VALUE;
        if (NULL != pvReserved2)
            throw (DWORD)SCARD_E_INVALID_VALUE;
        if ((SCARD_SCOPE_USER != dwScope)
            // && (SCARD_SCOPE_TERMINAL != dwScope) // Maybe NT V5+?
            && (SCARD_SCOPE_SYSTEM != dwScope))
            throw (DWORD)SCARD_E_INVALID_VALUE;
        *phContext = 0;     // Make sure it's valid.       
        
        pCtx = new CSCardUserContext(dwScope);
        if (NULL == pCtx)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Client can't allocate a new context"));
            throw (DWORD)SCARD_E_NO_MEMORY;
        }
        if (pCtx->InitFailed())
        {
            delete pCtx;
            pCtx = NULL;
            return SCARD_E_NO_MEMORY;
        }

        //
        // If TermSrv is enabled then register for session change notifications.  
        // Don't fail if we can't do this, since it may not be fatal
        //
        if (TermSrvEnabled() && RegisterForSessionChangeNotifications())
        {
            pCtx->fCallUnregister = TRUE;  
        }
        else
        {
            pCtx->fCallUnregister = FALSE;
        }

        if (TS_REDIRECT_MODE)
        {
            HANDLE hHeap;
            SCARDCONTEXT hContext = NULL;
            HANDLE hEvent = NULL;

            //
            // if redirect is disabled, then just get out
            //
            if (TS_REDIRECT_DISABLED)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }

            if (SafeCreateEvent(&g_hUnifiedStartedEvent))
            {
                hEvent = g_hUnifiedStartedEvent;
            }

            pCtx->AllocateMemory(0);
            hHeap = pCtx->HeapHandle();
            if (NULL == hHeap)
                throw GetLastError();

            if (!TS_REDIRECT_READY)
            {
                throw GetLastError();
            }
            nReturn  = pfnSCardEstablishContext(dwScope, (LPCVOID)hHeap, (LPCVOID) hEvent, &hContext);
            if (SCARD_S_SUCCESS != nReturn)
                throw (DWORD)nReturn;

            pCtx->SetRedirContext(hContext);
        }
        else
        {
            pCtx->EstablishContext();
        }

        *phContext = g_phlContexts->Add(pCtx);
    }

    catch (DWORD dwStatus)
    {
        if (NULL != pCtx)
            delete pCtx;
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        if (NULL != pCtx)
            delete pCtx;
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardIsValidContext:

    This routine verifies that the context to the Service Manager is intact.
    It is possible that if someone stops the Resource Manager Service, that
    existing handles can be rendered useless, resulting in an
    SCARD_E_SERVICE_STOPPED error.  This routine simply tests to see if the
    context is valid by pinging the server.  It's used internally to validate
    handles, and appears useful for external tools.

Arguments:

    hContext supplies the handle to the context previously established via the
        SCardEstablishContext service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.  Specific interesting error codes are:

    SCARD_E_SERVICE_STOPPED - The Resource Manager Service has been ended.

    SCARD_E_INVALID_HANDLE - The supplied handle isn't valid.

Author:

    Doug Barlow (dbarlow) 11/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardIsValidContext")

WINSCARDAPI LONG WINAPI
SCardIsValidContext(
    IN SCARDCONTEXT hContext)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        SCARDCONTEXT hRedirContext = pCtx->GetRedirContext();

        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }

        if (NULL != hRedirContext) {
            nReturn = pfnSCardIsValidContext(hRedirContext);
        }
        else
        {
            try
            {
                if (!pCtx->IsValidContext())
                    throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            catch (...)
            {
                SCardReleaseContext(hContext);
                throw;
            }
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardReleaseContext:

    This routine closes an established context to the Service Manager, and frees
    any resources allocated under that context.

Arguments:

    hContext supplies the handle to the context previously established via the
        SCardEstablishContext service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardReleaseContext")

WINSCARDAPI LONG WINAPI
SCardReleaseContext(
    IN SCARDCONTEXT hContext)
{
    LONG nReturn = SCARD_S_SUCCESS;
    CSCardUserContext *pCtx = NULL;

    try
    {
        pCtx = (CSCardUserContext *)g_phlContexts->Close(hContext);
        SCARDCONTEXT hRedirContext = pCtx->GetRedirContext();

        if (pCtx->fCallUnregister)
        {
            UnRegisterForSessionChangeNotifications();
        }  

        if (NULL != hRedirContext) {
            nReturn  = pfnSCardReleaseContext(hRedirContext);
        }
        else
        {
            try
            {
                pCtx->Cancel();
                pCtx->ReleaseContext();
            }
            catch (...) {}
        }
        delete pCtx;
        pCtx = NULL;             
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Service Manager Support Routines
//
//      The following services are supplied to simplify the use of the Service
//      Manager API.
//

/*++

SCardFreeMemory:

    This routine releases memory that has been returned from the Service Manager
    API via the use of the SCARD_AUTOALLOCATE length designator.

Arguments:

    hContext - This is the reference value returned from the
        SCardEstablishContext service.

    pvMem - This supplies the memory block to be released.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardFreeMemory")

WINSCARDAPI LONG WINAPI
SCardFreeMemory(
    IN SCARDCONTEXT hContext,
    IN LPCVOID pvMem)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        if ((NULL != pvMem) && ((LPVOID)g_wszBlank != pvMem))
        {
            if (NULL == hContext)
                HeapFree(GetProcessHeap(), 0, (LPVOID)pvMem);
            else
            {
                CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
                nReturn = (LONG)pCtx->FreeMemory(pvMem);
            }
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Services
//
//      The following services supply means for tracking cards within readers.
//

/*++

SCardCancel:

    This service is used to terminate any and all outstanding actions within the
    context.  The caller supplies the context handle under which outstanding
    requests will be canceled.  Not all requests are cancelable; only those
    which require waiting for external action by the smartcard or user.  Any
    such outstanding action requests will terminate with a status indication
    that the action was canceled.  This is especially useful to force
    outstanding SCardGetStatusChange calls to terminate.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardCancel")

WINSCARDAPI LONG WINAPI
SCardCancel(
    IN SCARDCONTEXT hContext)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        SCARDCONTEXT hRedirContext = pCtx->GetRedirContext();

        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }

        if (NULL != hRedirContext) {
            return pfnSCardCancel(hRedirContext);
        }
        else
            pCtx->Cancel();
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Card/Reader Access Services
//
//      The following services provide means for establishing communication with
//      the card.
//

/*++

SCardReconnect:

    This service re-establishes an existing connection from the calling
    application to the smartcard.  This service is used to move a card handle
    from direct access to general access (see Section 4), or to acknowledge and
    clear an error condition that is preventing further access to the card.

Arguments:

    hCard - This supplies the reference value obtained from a previous call to
        the SCardConnect or SCardOpenReader service.

    DwShareMode supplies a flag indicating whether or not other applications may
        form connections to this card.  Possible values are:

        SCARD_SHARE_SHARED - This application is willing to share this card with
            other applications.

        SCARD_SHARE_EXCLUSIVE - This application is not willing to share this
            card with other applications.

    DwPreferredProtocols supplies a bit mask of acceptable protocols for this
        connection.  Possible values, which may be combined via the OR
        operation, are:

        SCARD_PROTOCOL_T0 - T=0 is an acceptable protocol.

        SCARD_PROTOCOL_T1 - T=1 is an acceptable protocol.

    DwInitialization supplies an indication as to the form of initialization
        that should be performed on the card.  Possible values are:

        SCARD_LEAVE_CARD - Don't do anything special on reconnect

        SCARD_RESET_CARD - Reset the card (Warm Reset)

        SCARD_UNPOWER_CARD - Power down the card and reset it (Cold Reset)

    pdwActiveProtocol receives a flag indicating the established active
        protocol.  Possible values are:

        SCARD_PROTOCOL_T0 - T=0 is the active protocol.

        SCARD_PROTOCOL_T1 - T=1 is the active protocol.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardReconnect")

WINSCARDAPI LONG WINAPI
SCardReconnect(
    IN SCARDHANDLE hCard,
    IN DWORD dwShareMode,
    IN DWORD dwPreferredProtocols,
    IN DWORD dwInitialization,
    OUT LPDWORD pdwActiveProtocol)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);

        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }

        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardReconnect(pRdr->GetRedirCard(), dwShareMode, dwPreferredProtocols, dwInitialization, pdwActiveProtocol);
        }
        else
        {
            pRdr->Reconnect(
                    dwShareMode,
                    dwPreferredProtocols,
                    dwInitialization);
            if (NULL != pdwActiveProtocol)
                *pdwActiveProtocol = pRdr->Protocol();
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardDisconnect:

    This service terminates a previously opened connection between the calling
    application and the smartcard in the target reader.

Arguments:

    hCard - This supplies the reference value obtained from a previous call to
        the SCardConnect or SCardOpenReader service.

    dwDisposition - Supplies an indication of what should be done with the card
        in the connected reader.  Possible values are:

        SCARD_LEAVE_CARD - Don't do anything special on close

        SCARD_RESET_CARD - Reset the card on close

        SCARD_UNPOWER_CARD - Power down the card on close

        SCARD_EJECT_CARD - Eject the card on close

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents a warning condition.  The connection is terminated regardless of
    the return code.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardDisconnect")

WINSCARDAPI LONG WINAPI
SCardDisconnect(
    IN SCARDHANDLE hCard,
    IN DWORD dwDisposition)
{
    CReaderContext *pRdr = NULL;
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        pRdr = (CReaderContext *)g_phlReaders->Close(hCard);

        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardDisconnect(pRdr->GetRedirCard(), dwDisposition);
        }
        else
        {
            ASSERT(pRdr->Context()->m_hReaderHandle == hCard);
            pRdr->Context()->m_hReaderHandle = NULL;
            nReturn = pRdr->Disconnect(dwDisposition);
        }

        delete pRdr;
    }

    catch (DWORD dwStatus)
    {
        if (NULL != pRdr)
            delete pRdr;
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        if (NULL != pRdr)
            delete pRdr;
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardBeginTransaction:

    This service temporarily blocks other applications from accessing the
    smartcard, in order for this application to perform an operation that
    requires multiple interactions.

Arguments:

    hCard - This supplies the reference value obtained from a previous call to
        the SCardConnect or SCardOpenReader service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardBeginTransaction")

WINSCARDAPI LONG WINAPI
SCardBeginTransaction(
    IN SCARDHANDLE hCard)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardBeginTransaction(pRdr->GetRedirCard());
        }
        else
            pRdr->BeginTransaction();
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardEndTransaction:

    This service completes a previously declared transaction, allowing other
    applications to resume interactions with the card.

Arguments:

    hCard - This supplies the reference value obtained from a previous call to
        the SCardConnect or SCardOpenReader service.

    dwDisposition - Supplies an indication of what should be done with the card
        in the connected reader.  Possible values are:

        SCARD_LEAVE_CARD - Don't do anything special on close

        SCARD_RESET_CARD - Reset the card on close

        SCARD_UNPOWER_CARD - Power down the card on close

        SCARD_EJECT_CARD - Eject the card on close

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardEndTransaction")

WINSCARDAPI LONG WINAPI
SCardEndTransaction(
    IN SCARDHANDLE hCard,
    IN DWORD dwDisposition)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardEndTransaction(pRdr->GetRedirCard(), dwDisposition);
        }
        else
            pRdr->EndTransaction(dwDisposition);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardState:

    This routine provides the current state of the reader.  It may be used at
    any time following a successful call to SCardConnect or SCardOpenReader, and
    prior to a successful call to SCardDisconnect.  It does not effect the state
    of the reader or driver.

Arguments:

    hCard - This is the reference value returned from the SCardConnect or
        SCardOpenReader service.

    pdwState - This receives the current state of the reader.  Upon success, it
        receives one of the following state indicators:

        SCARD_ABSENT - This value implies there is no card in the reader.

        SCARD_PRESENT - This value implies there is a card is present in the
            reader, but that it has not been moved into position for use.

        SCARD_SWALLOWED - This value implies there is a card in the reader in
            position for use.  The card is not powered.

        SCARD_POWERED - This value implies there is power is being provided to
            the card, but the Reader Driver is unaware of the mode of the card.

        SCARD_NEGOTIABLEMODE - This value implies the card has been reset and is
            awaiting PTS negotiation.

        SCARD_SPECIFICMODE - This value implies the card has been reset and
            specific communication protocols have been established.

    pdwProtocol - This receives the current protocol, if any.  Possible returned
        values are listed below.  Other values may be added in the future.  The
        returned value is only meaningful if the returned state is
        SCARD_SPECIFICMODE.

        SCARD_PROTOCOL_RAW - The Raw Transfer Protocol is in use.

        SCARD_PROTOCOL_T0 - The ISO 7816/3 T=0 Protocol is in use.

        SCARD_PROTOCOL_T1 - The ISO 7816/3 T=1 Protocol is in use.

    pbAtr - This parameter points to a 32-byte buffer which receives the ATR
        string from the currently inserted card, if available.

    pbcAtrLen - This points to a DWORD which supplies the length of the pbAtr
        buffer, and receives the actual number of bytes in the ATR string.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardState")

WINSCARDAPI LONG WINAPI
SCardState(
    IN SCARDHANDLE hCard,
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT LPBYTE pbAtr,
    IN OUT LPDWORD pcbAtrLen)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardState(pRdr->GetRedirCard(), pdwState, pdwProtocol, pbAtr, pcbAtrLen);
        }
        else
        {
            CBuffer bfAtr, bfRdr;
            DWORD dwLocalState, dwLocalProtocol;

            pRdr->Status(&dwLocalState, &dwLocalProtocol, bfAtr, bfRdr);
            if (NULL != pdwState)
                *pdwState = dwLocalState;
            if (NULL != pdwProtocol)
                *pdwProtocol = dwLocalProtocol;
            if (NULL != pcbAtrLen)
                PlaceResult(pRdr->Context()->Parent(), bfAtr, pbAtr, pcbAtrLen);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardTransmit:

    This routine sends a service request to the smartcard, and expects to
    receive data back from the card.

Arguments:

    hCard - This is the reference value returned from the SCardConnect service.

    pioSendPci - This supplies the protocol header structure for the
        instruction.  This buffer is in the format of a SCARD_IO_REQUEST
        structure, followed by the specific protocol control information.

    pbSendBuffer - This supplies the actual data to be written to the card in
        conjunction with the command.

    cbSendLength - This supplies the length of the pbSendBuffer parameter, in
        bytes.

    pioRecvPci - This supplies the protocol header structure for the
        instruction, followed by a buffer in which to receive any returned
        protocol control information specific to the protocol in use.  This
        parameter may be NULL if no returned PCI is desired.

    pbRecvBuffer - This receives any data returned from the card in conjunction
        with the command.

    pcbRecvLength - This supplies the length of the pbRecvBuffer parameter, in
        bytes, and receives the actual number of bytes received from the
        smartcard.  If the buffer length is specified as SCARD_AUTOALLOCATE,
        then pbAttrBuffer is converted to a pointer to a byte pointer, and
        receives the address of a block of memory containing the returned data.
        This block of memory must be deallocated via the SCardFreeMemory()
        service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 2/6/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardTransmit")

WINSCARDAPI LONG WINAPI
SCardTransmit(
    IN SCARDHANDLE hCard,
    IN LPCSCARD_IO_REQUEST pioSendPci,
    IN LPCBYTE pbSendBuffer,
    IN DWORD cbSendLength,
    IN OUT LPSCARD_IO_REQUEST pioRecvPci,
    OUT LPBYTE pbRecvBuffer,
    IN OUT LPDWORD pcbRecvLength)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardTransmit(pRdr->GetRedirCard(), pioSendPci, pbSendBuffer, cbSendLength, pioRecvPci, pbRecvBuffer, pcbRecvLength);
        }
        else
        {
            CBuffer bfData(*pcbRecvLength);
            DWORD dwLen = 0;

            if (NULL != pcbRecvLength)
            {
                if (SCARD_AUTOALLOCATE != *pcbRecvLength)
                    dwLen = *pcbRecvLength;
            }

            pRdr->Transmit(
                    pioSendPci,
                    pbSendBuffer,
                    cbSendLength,
                    pioRecvPci,
                    bfData,
                    dwLen);
            PlaceResult(
                pRdr->Context()->Parent(),
                bfData,
                pbRecvBuffer,
                pcbRecvLength);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Control Routines
//
//      The following services provide for direct, low-level manipulation of the
//      reader by the calling application allowing it control over the
//      attributes of the communications with the card.
//

/*++

SCardControl:

    This routine provides for direct application control of the reader, should
    it be necessary.  It may be used at any time following a successful call to
    SCardConnect or SCardOpenReader, and prior to a successful call to
    SCardDisconnect.  The effect on the state of the reader is dependent on the
    control code.

Arguments:

    hCard - This is the reference value returned from the SCardConnect or
        SCardOpenReader service.

    dwControlCode - This supplies the control code for the operation. This value
        identifies the specific operation to be performed.

    pvInBuffer - This supplies a pointer to a buffer that contains the data
        required to perform the operation.  This parameter can be NULL if the
        dwControlCode parameter specifies an operation that does not require
        input data.

    cbInBufferSize - This supplies the size, in bytes, of the buffer pointed to
        by pvInBuffer.

    pvOutBuffer - This buffer receives the operation's output data.  This
        parameter can be NULL if the dwControlCode parameter specifies an
        operation that does not produce output data.

    cbOutBufferSize - This supplies the size, in bytes, of the buffer pointed to
        by pvOutBuffer.

    pcbBytesReturned - This receives the size, in bytes, of the data stored into
        the buffer pointed to by pvOutBuffer.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardControl")

WINSCARDAPI LONG WINAPI
SCardControl(
    IN SCARDHANDLE hCard,
    IN DWORD dwControlCode,
    IN LPCVOID pvInBuffer,
    IN DWORD cbInBufferSize,
    OUT LPVOID pvOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardControl(pRdr->GetRedirCard(), dwControlCode, pvInBuffer, cbInBufferSize, pvOutBuffer, cbOutBufferSize, pcbBytesReturned);
        }
        else
        {
            CBuffer bfResponse(cbOutBufferSize);
            *pcbBytesReturned = cbOutBufferSize;
            pRdr->Control(dwControlCode, pvInBuffer, cbInBufferSize, bfResponse);
            PlaceResult(
                pRdr->Context()->Parent(),
                bfResponse,
                (LPBYTE)pvOutBuffer,
                pcbBytesReturned);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardGetAttrib:

    This routine gets the current communications attributes for the given
    handle.  It does not effect the state of the reader, driver, or card.

Arguments:

    hCard - This is the reference value returned from the SCardConnect or
        SCardOpenReader service.

    dwAttrId - This supplies the identifier for the attribute to get.

    pbAttr - This buffer receives the attribute corresponding to the attribute
        id supplied in the dwAttrId parameter.  If this value is NULL, the
        supplied buffer length in pcbAttrLength is ignored, the length of the
        buffer that would have been returned had this parameter not been null is
        written to pcbAttrLength, and a success code is returned.

    pcbAttrLength - This supplies the length of the pbAttr buffer in bytes, and
        receives the actual length of the received attribute.  If the buffer
        length is specified as SCARD_AUTOALLOCATE, then pbAttrBuffer is
        converted to a pointer to a byte pointer, and receives the address of a
        block of memory containing the attribute.  This block of memory must be
        deallocated via the SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

    Note that strings are always returned as ANSI characters, per PC/SC
    standards.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardGetAttrib")

WINSCARDAPI LONG WINAPI
SCardGetAttrib(
    IN SCARDHANDLE hCard,
    IN DWORD dwAttrId,
    OUT LPBYTE pbAttr,
    IN OUT LPDWORD pcbAttrLen)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardGetAttrib(pRdr->GetRedirCard(), dwAttrId, pbAttr, pcbAttrLen);
        }
        else
        {
            CBuffer bfAttrib;
            DWORD dwLen = 0;

            if (NULL != pcbAttrLen)
            {
                if (SCARD_AUTOALLOCATE != *pcbAttrLen)
                    dwLen = *pcbAttrLen;
            }

            switch (dwAttrId)
            {
            case SCARD_ATTR_DEVICE_FRIENDLY_NAME_A:
            {
                CBuffer bfSysName, bfNames;
                CTextMultistring mtzNames;
                pRdr->GetAttrib(SCARD_ATTR_DEVICE_SYSTEM_NAME, bfSysName, MAX_PATH);
                ListReaderNames(
                    pRdr->Context()->Scope(),
                    bfSysName,
                    bfNames);
                mtzNames = (LPCTSTR)bfNames.Access();
                bfAttrib.Set(
                    (LPCBYTE)((LPCSTR)mtzNames),
                    (mtzNames.Length()) * sizeof(CHAR));
                break;
            }
            case SCARD_ATTR_DEVICE_FRIENDLY_NAME_W:
            {
                CBuffer bfSysName, bfNames;
                CTextMultistring mtzNames;
                pRdr->GetAttrib(SCARD_ATTR_DEVICE_SYSTEM_NAME, bfSysName, MAX_PATH);
                ListReaderNames(
                    pRdr->Context()->Scope(),
                    bfSysName,
                    bfNames);
                mtzNames = (LPCTSTR)bfNames.Access();
                bfAttrib.Set(
                    (LPCBYTE)((LPCWSTR)mtzNames),
                    (mtzNames.Length()) * sizeof(WCHAR));
                break;
            }
            case SCARD_ATTR_DEVICE_SYSTEM_NAME_A:
            {
                CBuffer bfSysName;
                CTextString szSysName;
                pRdr->GetAttrib(SCARD_ATTR_DEVICE_SYSTEM_NAME, bfSysName, dwLen);
                szSysName = (LPCTSTR)bfSysName.Access();
                bfAttrib.Set(
                    (LPCBYTE)((LPCSTR)szSysName),
                    (szSysName.Length() + 1) * sizeof(CHAR));
                break;
            }
            case SCARD_ATTR_DEVICE_SYSTEM_NAME_W:
            {
                CBuffer bfSysName;
                CTextString szSysName;
                pRdr->GetAttrib(SCARD_ATTR_DEVICE_SYSTEM_NAME, bfSysName, dwLen);
                szSysName = (LPCTSTR)bfSysName.Access();
                bfAttrib.Set(
                    (LPCBYTE)((LPCWSTR)szSysName),
                    (szSysName.Length() + 1) * sizeof(WCHAR));
                break;
            }
            default:
                pRdr->GetAttrib(dwAttrId, bfAttrib, dwLen);
            }
            PlaceResult(pRdr->Context()->Parent(), bfAttrib, pbAttr, pcbAttrLen);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardSetAttrib:

    This routine sets the current communications attributes for the given
    handle.  It does not effect the state of the reader, driver, or card.  Not
    all attributes are settable at all times, as many of the attributes are
    directly under control of the transport protocol.  These attributes are
    offered only as a suggestion to the reader -- the reader may ignore any
    attributes it feels are inappropriate.

Arguments:

    hCard - This is the reference value returned from the SCardOpenReader
        service.

    dwAttrId - This supplies the identifier for the attribute to get.

    pbAttr - This buffer supplies the attribute corresponding to the attribute
        id supplied in the dwAttrId parameter.

    cbAttrLength - This supplies the length of the attribute value in pbAttr
        buffer in bytes.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardSetAttrib")

WINSCARDAPI LONG WINAPI
SCardSetAttrib(
    IN SCARDHANDLE hCard,
    IN DWORD dwAttrId,
    IN LPCBYTE pbAttr,
    IN DWORD cbAttrLen)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (NULL != pRdr->GetRedirCard()) {
            nReturn = pfnSCardSetAttrib(pRdr->GetRedirCard(), dwAttrId, pbAttr, cbAttrLen);
        }
        else
            pRdr->SetAttrib(dwAttrId, pbAttr, cbAttrLen);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  SCard Service Information
//
//      The following services are used to manage the Calais Service itself.
//      These routines are not documented to users, and are not guaranteed
//      to exist in future releases.
//

/*++

SCardAccessStartedEvent:

    This function obtains a local handle to the Calais Resource Manager Start
    event.  The handle must be released via the SCardReleaseStartedEvent
    service.

Arguments:

    None

Return Value:

    The Handle, or NULL if an error occurs.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardAccessStartedEvent")

WINSCARDAPI HANDLE WINAPI
SCardAccessStartedEvent(
    void)
{
    HANDLE                  hRet                = NULL;
    
    //
    // Create the event that is passed back to the caller... 
    // if it hasn't already been created
    //
    if (SafeCreateEvent(&g_hUnifiedStartedEvent))
    {
        hRet = g_hUnifiedStartedEvent;

        if (hRet == NULL)
        {
            goto ErrorReturn;
        }
    }

    if (TermSrvEnabled())
    {
        //
        // 
        //
        if (!SetStartedEventAfterTestingConnectedState())
        {
            goto ErrorReturn;                       
        }                     
    }
    else
    {
        //
        // TermSrv is disabled, so go ahead and call the 
        // SetStartedEventWhenSCardSubsytemIsStarted function which will make sure 
        // the event which is returned to the caller will be set when the LOCAL 
        // smart card subsystem becomes available. 
        //
        if (!SetStartedEventWhenSCardSubsytemIsStarted(TRUE))
        {
            goto ErrorReturn;
        }
    }
    
Return:
    return (hRet);

ErrorReturn:
    hRet = NULL;
    goto Return;
}


/*++

SCardAccessNewReaderEvent:

    This function obtains a local handle to the Calais Resource Manager's New
    Reader event.  The handle must be released via the
    SCardReleaseNewReaderEvent service.

Arguments:

    None

Return Value:

    The Handle, or NULL if an error occurs.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardAccessNewReaderEvent")

WINSCARDAPI HANDLE WINAPI
SCardAccessNewReaderEvent(
    void)
{
    return AccessNewReaderEvent();
}


/*++

SCardReleaseStartedEvent:

    This function releases a previously accessed handle to the Calais
    Resource Manager Start event.  The handle must be obtained via the
    SCardAccessStartedEvent service.

Arguments:

    None

Return Value:

    None.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardReleaseStartedEvent")

WINSCARDAPI void WINAPI
SCardReleaseStartedEvent(
    void)
{
    if (TermSrvEnabled())
    {
        UnRegisterForSessionChangeNotifications();
    }    
}


/*++

SCardReleaseNewReaderEvent:

    This function releases a previously accessed handle to the Calais
    Resource Manager New Reader event.  The handle must be obtained via the
    SCardAccessNewReaderEvent service.

Arguments:

    None

Return Value:

    None.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardReleaseNewReaderEvent")

WINSCARDAPI void WINAPI
SCardReleaseNewReaderEvent(
    void)
{
    ReleaseNewReaderEvent();
}


/*++

SCardReleaseAllEvents:

    This is a catch-all routine that releases all known special event handles.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

Author:

    Doug Barlow (dbarlow) 7/6/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardReleaseAllEvents")

WINSCARDAPI void WINAPI
SCardReleaseAllEvents(
    void)
{
    ReleaseAllEvents();
}


//
///////////////////////////////////////////////////////////////////////////////
//
//  Utility Routines
//

/*++

PlaceResult:

    This set of routines places the result of an operation into the user's
    output buffer, supporting SCARD_AUTO_ALLOCATE, invalid buffer sizes, etc.

Arguments:

    pCtx supplies the context under which this operation is being performed.

    bfResult supplies the result to be returned to the user.

    pbOutput receives the result for the user, as a byte stream.

    szOutput receives the result as an ANSI or UNICODE string.

    pcbLength supplies the length of the user's output buffer in bytes, and
        receives how much of it was used.

    pcchLength supplies the length of the user's output buffer in characters,
        and receives how much of it was used.

Return Value:

    None

Throws:

    Error conditions are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/7/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("PlaceResult")

void
PlaceResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPBYTE pbOutput,
    LPDWORD pcbLength)
{
    LPBYTE pbForUser = NULL;
    LPBYTE pbOutBuff = pbOutput;

    try
    {
        if (NULL == pbOutput)
            *pcbLength = 0;
        switch (*pcbLength)
        {
        case 0: // They just want the length.
            *pcbLength = bfResult.Length();
            break;

        case SCARD_AUTOALLOCATE:
            if (0 < bfResult.Length())
            {
                if (NULL == pCtx)
                {
                    pbForUser = (LPBYTE)HeapAlloc(
                                            GetProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            bfResult.Length());
                }
                else
                    pbForUser = (LPBYTE)pCtx->AllocateMemory(bfResult.Length());

                if (NULL == pbForUser)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Client can't get return memory"));
                    throw (DWORD)SCARD_E_NO_MEMORY;
                }

                *(LPBYTE *)pbOutput = pbForUser;
                pbOutBuff = pbForUser;
                // Fall through intentionally
            }
            else
            {
                *pcbLength = 0;
                *(LPBYTE *)pbOutput = (LPBYTE)g_wszBlank;
                break;      // Do terminate the case now.
            }

        default:
            if (*pcbLength < bfResult.Length())
            {
                *pcbLength = bfResult.Length();
                throw (DWORD)SCARD_E_INSUFFICIENT_BUFFER;
            }
            CopyMemory(pbOutBuff, bfResult.Access(), bfResult.Length());
            *pcbLength = bfResult.Length();
            break;
        }
    }

    catch (...)
    {
        if (NULL != pbForUser)
        {
            if (NULL == pCtx)
                HeapFree(GetProcessHeap(), 0, pbForUser);
            else
                pCtx->FreeMemory(pbForUser);
        }
        throw;
    }
}

#include <setupapi.h>

//
// On a system that installs a smart card reader for the very first time
// the smart card subsystem must be started manually, but only this first time.
// After that, it is started automatically whenever the system boots
//
DWORD
APIENTRY
ClassInstall32(
    IN DI_FUNCTION      dif,
    IN HDEVINFO         hdi,
    IN PSP_DEVINFO_DATA pdevData)       OPTIONAL
{
    if (dif == DIF_INSTALLDEVICE)
    {
        StartCalaisService();
    }
    return ERROR_DI_DO_DEFAULT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\client\winscarda.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    WinSCard

Abstract:

    This module supplies the ANSI versions of the API for the Calais Smartcard
    Service Manager.

    The Calais Service Manager does the work of coordinating the protocols,
    readers, drivers, and smartcards on behalf of the application.  The
    following services are provided as part of a library to simplify access to
    the Service Manager.  These routines are the documented, exposed APIs.
    These routines merely package the requests and forward them to the Calais
    Service Manager, allowing the actual implementation of Calais to vary over
    time.

    At no time does the API library make security decisions.  All
    security-related functions must be performed by the Service Manager, running
    in its own address space, or in the operating system kernel.  However, some
    utility routines may be implemented in the API library for speed, as long as
    they do not involve security decisions.


Author:

    Doug Barlow (dbarlow) 10/23/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "client.h"
#include "redirect.h"


//
////////////////////////////////////////////////////////////////////////////////
//
//  Calais Database Query Services
//
//      These services all are oriented towards reading the Calais database.
//      They provide the option for listing a Smartcard Context (see Section
//      4.1.1), but do not require one.  Note that without a context, some or
//      all information may be inaccessable due to security restrictions.
//

/*++

SCardListReaderGroups:

    This service provides the list of named card reader groups that have
    previously been defined to the system.  The group 'SCard$DefaultReaders' is
    only returned if it contains at least one reader.  The group
    'SCard$AllReaders' is not returned, as it implicitly exists.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    mszGroups receives a multi-string listing the reader groups defined to this
        system and available to the current user on the current terminal.  If
        this value is NULL, the supplied buffer length in pcchGroups is ignored,
        the length of the buffer that would have been returned had this
        parameter not been null is written to pcchGroups, and a success code is
        returned.

    pcchGroups supplies the length of the mszGroups buffer in characters, and
        receives the actual length of the multi-string structure, including all
        trailing Null characters.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then szGroups is converted to a pointer to a string
        pointer, and receives the address of a block of memory containing the
        multi-string structure.  This block of memory must be deallocated via
        the SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListReaderGroupsA")

WINSCARDAPI LONG WINAPI
SCardListReaderGroupsA(
    IN SCARDCONTEXT hContext,
    OUT LPSTR mszGroups,
    IN OUT LPDWORD pcchGroups)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfGroups;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardListReaderGroupsA(hRedirContext, mszGroups, pcchGroups);
        }
        else
        {
            ListReaderGroups(dwScope, bfGroups);
            PlaceMultiResult(pCtx, bfGroups, mszGroups, pcchGroups);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardListReaders:

    This service provides the list of readers within a set of named reader
    groups, eliminating duplicates.  The caller supplies a multistring listing
    the name of a set of pre-defined group of readers, and receives the list of
    smartcard readers within the named groups.  Unrecognized group names are
    ignored.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    mszGroups supplies the names of the reader groups defined to the system, as
        a multi-string.  A NULL value is used to indicate that all readers in
        the system be listed (i.e., the SCard$AllReaders group).

    mszReaders receives a multi-string listing the card readers within the
        supplied reader groups.  If this value is NULL, the supplied buffer
        length in pcchReaders is ignored, the length of the buffer that would
        have been returned had this parameter not been null is written to
        pcchReaders, and a success code is returned.

    pcchReaders supplies the length of the mszReaders buffer in characters, and
        receives the actual length of the multi-string structure, including all
        trailing Null characters.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then mszReaders is converted to a pointer to a
        string pointer, and receives the address of a block of memory containing
        the multi-string structure.  This block of memory must be deallocated
        via the SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListReadersA")

WINSCARDAPI LONG WINAPI
SCardListReadersA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR mszGroups,
    OUT LPSTR mszReaders,
    IN OUT LPDWORD pcchReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfReaders;
        CTextMultistring mtzGroups;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardListReadersA(hRedirContext, mszGroups, mszReaders, pcchReaders);
        }
        else
        {
            mtzGroups = mszGroups;
            ListReaders(dwScope, mtzGroups, bfReaders);
            if (NULL != pCtx)
                pCtx->StripInactiveReaders(bfReaders);
            PlaceMultiResult(pCtx, bfReaders, mszReaders, pcchReaders);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardListCards:

    This service provides a list of named cards previously introduced to the
    system by this user which match an optionally supplied ATR string.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    pbAtr supplies the address of an ATR string to compare to known cards, or
        NULL if all card names are to be returned.

    rgguidInterfaces supplies an array of GUIDs, or the value NULL.  When an
        array is supplied, a card name will be returned only if this set of
        GUIDs is a (possibly improper) subset of the set of GUIDs supported by
        the card.

    cguidInterfaceCount supplies the number of entries in the rgguidInterfaces
        array.  If rgguidInterfaces is NULL, then this value is ignored.

  mszCards receives a multi-string listing the smartcards introduced to the
        system by this user which match the supplied ATR string.  If this value
        is NULL, the supplied buffer length in pcchCards is ignored, the length
        of the buffer that would have been returned had this parameter not been
        null is written to pcchCards, and a success code is returned.

    pcchCards supplies the length of the mszCards buffer in characters, and
        receives the actual length of the multi-string structure, including all
        trailing Null characters.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then mszCards is converted to a pointer to a string
        pointer, and receives the address of a block of memory containing the
        multi-string structure.  This block of memory must be deallocated via he
        SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListCardsA")

WINSCARDAPI LONG WINAPI
SCardListCardsA(
    IN SCARDCONTEXT hContext,
    IN LPCBYTE pbAtr,
    IN LPCGUID rgquidInterfaces,
    IN DWORD cguidInterfaceCount,
    OUT LPSTR mszCards,
    IN OUT LPDWORD pcchCards)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfCards;
        CSCardUserContext *pCtx = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        ListCards(
            dwScope,
            pbAtr,
            rgquidInterfaces,
            cguidInterfaceCount,
            bfCards);
        PlaceMultiResult(pCtx, bfCards, mszCards, pcchCards);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardListInterfaces:

    This service provides a list of interfaces known to be supplied by a given
    card.  The caller supplies the name of a smartcard previously introduced to
    the system, and receives the list of interfaces supported by the card.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    szCard supplies the name of the card defined to the system.

    pguidInterfaces receives an array of GUIDs indicating the interfaces
        supported by the named smartcard.  If this value is NULL, the supplied
        array length in pcguidInterfaces is ignored, the size of the array that
        would have been returned had this parameter not been null is written to
        pcguidInterfaces, and a success code is returned.

    pcguidInterfaces supplies the size of the pguidInterfaces array, and
        receives the actual size of the returned array.  If the array size is
        specified as SCARD_AUTOALLOCATE, then pguidInterfaces is converted to a
        pointer to a GUID pointer, and receives the address of a block of memory
        containing the array.  This block of memory must be deallocated via he
        SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListInterfacesA")

WINSCARDAPI LONG WINAPI
SCardListInterfacesA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCard,
    OUT LPGUID pguidInterfaces,
    IN OUT LPDWORD pcguidInterfaces)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        BOOL fSts;
        CTextString tzCard;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        DWORD cbInterfaces;
        CBuffer bfInterfaces;
        CSCardUserContext *pCtx = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }

        tzCard = szCard;
        fSts = GetCardInfo(
                    dwScope,
                    tzCard,
                    NULL,
                    NULL,
                    &bfInterfaces,
                    NULL);
        if (!fSts)
            throw (DWORD)SCARD_E_UNKNOWN_CARD;
        if (SCARD_AUTOALLOCATE == *pcguidInterfaces)
            cbInterfaces = SCARD_AUTOALLOCATE;
        else
            cbInterfaces = *pcguidInterfaces * sizeof(GUID);
        PlaceResult(
            pCtx,
            bfInterfaces,
            (LPBYTE)pguidInterfaces,
            &cbInterfaces);
        *pcguidInterfaces = cbInterfaces / sizeof(GUID);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardGetProviderId:

    This service returns the GUID of the Primary Service Provider for the given
    card.  The caller supplies the name of a smartcard previously introduced to
    the system, and receives the registered Primary Service Provider GUID, if
    any.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    szCard supplies the name of the card defined to the system.

    pguidInterfaces receives the GUID of the Primary Service Provider of the
        indicated card.  This provider may be activated via COM, and will supply
        access to other services in the card.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardGetProviderIdA")

WINSCARDAPI LONG WINAPI
SCardGetProviderIdA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCard,
    OUT LPGUID pguidProviderId)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        BOOL fSts;
        CTextString tzCard;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfProvider;

        if (NULL != hContext)
        {
            CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }

        tzCard = szCard;
        fSts = GetCardInfo(
                    dwScope,
                    tzCard,
                    NULL,
                    NULL,
                    NULL,
                    &bfProvider);
        if (!fSts)
            throw (DWORD)SCARD_E_UNKNOWN_CARD;
        if (sizeof(GUID) != bfProvider.Length())
            throw (DWORD)SCARD_E_INVALID_TARGET;
        CopyMemory(pguidProviderId, bfProvider.Access(), bfProvider.Length());
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardGetCardTypeProviderName:

    This service returns the value of a given Provider Name, by Id number, for
    the identified card type.  The caller supplies the name of a smartcard
    previously introduced to the system, and receives the registered Service
    Provider of that type, if any, as a string.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    szCardName supplies the name of the card type with which this provider name
        is associated.

    dwProviderId supplies the identifier for the provider associated with this
        card type.  Possible values are:

        SCARD_PROVIDER_SSP - The Primary SSP identifier, as a GUID string.
        SCARD_PROVIDER_CSP - The CSP name.

        Other values < 0x80000000 are reserved for use by Microsoft.  Values
        over 0x80000000 are available for use by the smart card vendors, and
        are card-specific.

    szProvider receives the string identifying the provider.

    pcchProvider supplies the length of the szProvider buffer in characters,
        and receives the actual length of the returned string, including the
        trailing null character.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then szProvider is converted to a pointer to a
        string pointer, and receives the address of a block of memory
        containing the string.  This block of memory must be deallocated via
        the SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Throws:

    Errors as DWORD status codes

Author:

    Doug Barlow (dbarlow) 1/19/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardGetCardTypeProviderNameA")

WINSCARDAPI LONG WINAPI
SCardGetCardTypeProviderNameA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCardName,
    IN DWORD dwProviderId,
    OUT LPSTR szProvider,
    IN OUT LPDWORD pcchProvider)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CTextString tzCardName;
        CBuffer bfProvider;
        CSCardUserContext *pCtx = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        GetCardTypeProviderName(
            dwScope,
            tzCardName,
            dwProviderId,
            bfProvider);
        PlaceResult(pCtx, bfProvider, szProvider, pcchProvider);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Calais Database Management Services
//
//      The following services provide for managing the Calais Database.  These
//      services actually update the database, and require a smartcard context.
//

/*++

SCardIntroduceReaderGroup:

    This service provides means for introducing a new smartcard reader group to
    Calais.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szGroupName supplies the friendly name to be assigned to the new reader
        group.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardIntroduceReaderGroupA")

WINSCARDAPI LONG WINAPI
SCardIntroduceReaderGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardIntroduceReaderGroupA(hRedirContext, szGroupName);
        }
        else
        {
            tzGroupName = szGroupName;
            IntroduceReaderGroup(
                dwScope,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardForgetReaderGroup:

    This service provides means for removing a previously defined smartcard
    reader group from the Calais Subsystem.  This service automatically clears
    all readers from the group before forgetting it.  It does not affect the
    existence of the readers in the database.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szGroupName supplies the friendly name of the reader group to be
        forgotten.  The Calais-defined default reader groups may not be
        forgotten.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardForgetReaderGroupA")

WINSCARDAPI LONG WINAPI
SCardForgetReaderGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardForgetReaderGroupA(hRedirContext, szGroupName);
        }
        else
        {
            tzGroupName = szGroupName;
            ForgetReaderGroup(
                dwScope,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardIntroduceReader:

    This service provides means for introducing an existing smartcard reader
    device to Calais.  Once introduced, Calais will assume responsibility for
    managing access to that reader.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name to be assigned to the reader.

    SzDeviceName supplies the system name of the smartcard reader device.
        (Example: "VendorX ModelY Z".)

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardIntroduceReaderA")

WINSCARDAPI LONG WINAPI
SCardIntroduceReaderA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName,
    IN LPCSTR szDeviceName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CTextString tzDeviceName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardIntroduceReaderA(hRedirContext, szReaderName, szDeviceName);
        }
        else
        {
            tzReaderName = szReaderName;
            tzDeviceName = szDeviceName;
            IntroduceReader(
                dwScope,
                tzReaderName,
                tzDeviceName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardForgetReader:

    This service provides means for removing previously defined smartcard
    readers from control by the Calais Subsystem.  It is automatically removed
    from any groups it may have been added to.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name of the reader to be forgotten.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardForgetReaderA")

WINSCARDAPI LONG WINAPI
SCardForgetReaderA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardForgetReaderA(hRedirContext, szReaderName);
        }
        else
        {
            tzReaderName = szReaderName;
            ForgetReader(
                dwScope,
                tzReaderName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardAddReaderToGroup:

    This service provides means for adding existing an reader into an existing
    reader group.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name of the reader to be added.

    szGroupName supplies the friendly name of the group to which the reader
        should be added.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardAddReaderToGroupA")

WINSCARDAPI LONG WINAPI
SCardAddReaderToGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName,
    IN LPCSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardAddReaderToGroupA(hRedirContext, szReaderName, szGroupName);
        }
        else
        {
            tzReaderName = szReaderName;
            tzGroupName = szGroupName;
            AddReaderToGroup(
                dwScope,
                tzReaderName,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardRemoveReaderFromGroup:

    This service provides means for removing an existing reader from an existing
    reader group.  It does not affect the existence of either the reader or the
    group in the Calais database.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name of the reader to be removed.

    szGroupName supplies the friendly name of the group to which the reader
        should be removed.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardRemoveReaderFromGroupA")

WINSCARDAPI LONG WINAPI
SCardRemoveReaderFromGroupA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReaderName,
    IN LPCSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardRemoveReaderFromGroupA(hRedirContext, szReaderName, szGroupName);
        }
        else
        {
            tzReaderName = szReaderName;
            tzGroupName = szGroupName;
            RemoveReaderFromGroup(
                dwScope,
                tzReaderName,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardIntroduceCardType:

    This service provides means for introducing new smartcards to the Calais
    Subsystem for the active user.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szCardName supplies the name by which the user can recognize this card.

    PguidPrimaryProvider supplies a pointer to a GUID used to identify the
        Primary Service Provider for the card.

    rgguidInterfaces supplies an array of GUIDs identifying the smartcard
        interfaces supported by this card.

    dwInterfaceCount supplies the number of GUIDs in the pguidInterfaces array.

    pbAtr supplies a string against which card ATRs will be compared to
        determine a possible match for this card.  The length of this string is
        determined by normal ATR parsing.

    pbAtrMask supplies an optional bitmask to use when comparing the ATRs of
        smartcards to the ATR supplied in pbAtr.  If this value is non-NULL, it
        must point to a string of bytes the same length as the ATR string
        supplied in pbAtr.  Then when a given ATR A is compared to the ATR
        supplied in pbAtr B, it matches if and only if A & M = B, where M is the
        supplied mask, and & represents bitwise logical AND.

    cbAtrLen supplies the length of the ATR and Mask.  This value may be zero
        if the lentgh is obvious from the ATR.  However, it may be required if
        there is a Mask value that obscures the actual ATR.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardIntroduceCardTypeA")

WINSCARDAPI LONG WINAPI
SCardIntroduceCardTypeA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCardName,
    IN LPCGUID pguidPrimaryProvider,
    IN LPCGUID rgguidInterfaces,
    IN DWORD dwInterfaceCount,
    IN LPCBYTE pbAtr,
    IN LPCBYTE pbAtrMask,
    IN DWORD cbAtrLen)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzCardName;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;

        if (NULL != hContext)
        {
            CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        IntroduceCard(
            dwScope,
            tzCardName,
            pguidPrimaryProvider,
            rgguidInterfaces,
            dwInterfaceCount,
            pbAtr,
            pbAtrMask,
            cbAtrLen);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardSetCardTypeProviderName:

    This service provides means for adding additional service providers to a
    specified card type.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szCardName supplies the name of the card type with which this provider
        name is to be associated.

    dwProviderId supplies the identifier for the provider to be associated with
        this card type.  Possible values are:

        SCARD_PROVIDER_SSP - The Primary SSP identifier, as a GUID string.
        SCARD_PROVIDER_CSP - The CSP name.

        Other values < 0x80000000 are reserved for use by Microsoft.  Values
        over 0x80000000 are available for use by the smart card vendors, and
        are card-specific.

    szProvider supplies the string identifying the provider.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 1/19/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardSetCardTypeProviderNameA")

WINSCARDAPI LONG WINAPI
SCardSetCardTypeProviderNameA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCardName,
    IN DWORD dwProviderId,
    IN LPCSTR szProvider)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzCardName;
        CTextString tzProvider;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;

        if (NULL != hContext)
        {
            CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        tzProvider = szProvider;
        SetCardTypeProviderName(
            dwScope,
            tzCardName,
            dwProviderId,
            tzProvider);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardForgetCardType:

    This service provides means for removing previously defined smartcards from
    the Calais Subsystem.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szCardName supplies the friendly name of the card to be forgotten.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardForgetCardTypeA")

WINSCARDAPI LONG WINAPI
SCardForgetCardTypeA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szCardName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzCardName;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;

        if (NULL != hContext)
        {
            CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        ForgetCard(
            dwScope,
            tzCardName);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Services
//
//      The following services supply means for tracking cards within readers.
//

/*++

SCardLocateCards:

    This service searches the readers listed in the lpReaderStates parameter for
    any containing a card with an ATR string matching one of the card supplied
    names.  This service returns immediately with the result.  If no matching
    cards are found, the calling application may use the SCardGetStatusChange
    service to wait for card availability changes.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    mszCards supplies the names of the cards to search for, as a multi-string.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardLocateCardsA")

WINSCARDAPI LONG WINAPI
SCardLocateCardsA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR mszCards,
    IN OUT LPSCARD_READERSTATE_A rgReaderStates,
    IN DWORD cReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;
    LPSCARD_ATRMASK rgAtrMasks = NULL;

    try
    {
        LPCTSTR szCard;
        DWORD dwIndex;
        DWORD dwScope;
        CBuffer bfXlate1(36), bfXlate2(36); // Rough guess of name & ATR lengths
        BOOL fSts;

        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        dwScope = pCtx->Scope();

        if (0 == *mszCards)
            throw (DWORD)SCARD_E_INVALID_VALUE;

        rgAtrMasks = new SCARD_ATRMASK[MStringCount(mszCards)];
        if (rgAtrMasks == NULL)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("WinSCard Client has no memory"));
            throw (DWORD)SCARD_E_NO_MEMORY;
        }

        dwIndex = 0;
        for (szCard = FirstString(mszCards);
             NULL != szCard;
             szCard = NextString(szCard))
        {
            fSts = GetCardInfo(
                        dwScope,
                        szCard,
                        &bfXlate1,  // ATR
                        &bfXlate2,  // Mask
                        NULL,
                        NULL);
            if (!fSts)
                throw (DWORD)SCARD_E_UNKNOWN_CARD;

            ASSERT(33 >= bfXlate1.Length());    // Biggest an ATR can be.
            rgAtrMasks[dwIndex].cbAtr = bfXlate1.Length();
            memcpy(rgAtrMasks[dwIndex].rgbAtr, bfXlate1.Access(), rgAtrMasks[dwIndex].cbAtr);

            ASSERT(rgAtrMasks[dwIndex].cbAtr == bfXlate2.Length());
            memcpy(rgAtrMasks[dwIndex].rgbMask, bfXlate2.Access(), rgAtrMasks[dwIndex].cbAtr);

            dwIndex ++;
        }

        nReturn = SCardLocateCardsByATRA(
                    hContext,
                    rgAtrMasks,
                    dwIndex,
                    rgReaderStates,
                    cReaders);

            // If the remote client does not implement the new API
            // retry with the old one. it might succeed if its DB is good enough
        if ((nReturn == ERROR_CALL_NOT_IMPLEMENTED) && (pCtx->GetRedirContext()))
        {
            nReturn = pfnSCardLocateCardsA(pCtx->GetRedirContext(), mszCards, rgReaderStates, cReaders);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    if (rgAtrMasks != NULL)
    {
        try
        {
            delete[] rgAtrMasks;
        }
        catch (...)
        {
        }
    }

    return nReturn;
}


/*++

SCardLocateCardsByATR:

    This service searches the readers listed in the lpReaderStates parameter for
    any containing a card with an ATR string matching one of the supplied ATRs
    This service returns immediately with the result.  If no matching
    cards are found, the calling application may use the SCardGetStatusChange
    service to wait for card availability changes.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    rgAtrMasks supplies the ATRs to search for, as an array of structs.
    
    cAtrs supplies the number of elements in the rgAtrMasks array.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardLocateCardsByATRA")

WINSCARDAPI LONG WINAPI
SCardLocateCardsByATRA(
    IN SCARDCONTEXT hContext,
    IN LPSCARD_ATRMASK rgAtrMasks,
    IN DWORD cAtrs,
    IN OUT LPSCARD_READERSTATE_A rgReaderStates,
    IN DWORD cReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (pCtx->GetRedirContext())
        {
            nReturn = pfnSCardLocateCardsByATRA(pCtx->GetRedirContext(), rgAtrMasks, cAtrs, rgReaderStates, cReaders);
        }
        else
        {
            CBuffer bfReaders;
            DWORD dwIndex;

            for (dwIndex = 0; dwIndex < cReaders; dwIndex += 1)
                MStrAdd(bfReaders, rgReaderStates[dwIndex].szReader);

            pCtx->LocateCards(
                    bfReaders,
                    rgAtrMasks,
                    cAtrs,
                    (LPSCARD_READERSTATE)rgReaderStates,
                    cReaders);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardGetStatusChange:

    This service is used to block execution until such time as the current
    availability of cards in a given set of readers changes.  The caller
    supplies a list of readers to be monitored via an SCARD_READERSTATE array,
    and the maximum amount of time, in seconds, that it is willing to wait for
    an action to occur on one of the listed readers.  Zero in this parameter
    indicates that no timeout is specified.  The service returns when there is a
    change in availability, having filled in the dwEventState fields of the
    rgReaderStates parameter appropriately.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    dwTimeOut supplies the maximum amount of time to wait for an action, in
        seconds.  A zero value implies that the wait will never timeout.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the wait, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardGetStatusChangeA")

WINSCARDAPI LONG WINAPI
SCardGetStatusChangeA(
    IN SCARDCONTEXT hContext,
    IN DWORD dwTimeout,
    IN OUT LPSCARD_READERSTATE_A rgReaderStates,
    IN DWORD cReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }

        if (pCtx->GetRedirContext())
        {
            nReturn = pfnSCardGetStatusChangeA(pCtx->GetRedirContext(), dwTimeout, rgReaderStates, cReaders);
        }
        else
        {
            CBuffer bfReaders;
            DWORD dwIndex;

            for (dwIndex = 0; dwIndex < cReaders; dwIndex += 1)
                MStrAdd(bfReaders, rgReaderStates[dwIndex].szReader);
            pCtx->GetStatusChange(
                        bfReaders,
                        (LPSCARD_READERSTATE)rgReaderStates,
                        cReaders,
                        dwTimeout);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Card/Reader Access Services
//
//      The following services provide means for establishing communication with
//      the card.
//

/*++

SCardConnect:

    This service establishes a connection from the calling application to the
    smartcard in the designated reader.  If no card exists in the specified
    reader, an error is returned.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    szReader supplies the name of the reader containing the target card.

    DwShareMode supplies a flag indicating whether or not other applications may
        form connections to this card.  Possible values are:

        SCARD_SHARE_SHARED - This application is willing to share this card with
            other applications.

        SCARD_SHARE_EXCLUSIVE - This application is not willing to share this
            card with other applications.

        SCARD_SHARE_DIRECT - This application is taking control of the reader.

    DwPreferredProtocols supplies a bit mask of acceptable protocols for this
        connection.  Possible values, which may be combined via the OR
        operation, are:

        SCARD_PROTOCOL_T0 - T=0 is an acceptable protocol.

        SCARD_PROTOCOL_T1 - T=1 is an acceptable protocol.

    phCard receives a handle identifying the connection to the smartcard in the
        designated reader.

    pdwActiveProtocol receives a flag indicating the established active
        protocol.  Possible values are:

        SCARD_PROTOCOL_T0 - T=0 is the active protocol.

        SCARD_PROTOCOL_T1 - T=1 is the active protocol.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardConnectA")

WINSCARDAPI LONG WINAPI
SCardConnectA(
    IN SCARDCONTEXT hContext,
    IN LPCSTR szReader,
    IN DWORD dwShareMode,
    IN DWORD dwPreferredProtocols,
    OUT LPSCARDHANDLE phCard,
    OUT LPDWORD pdwActiveProtocol)
{
    LONG nReturn = SCARD_S_SUCCESS;
    CReaderContext *pRdr = NULL;
    CSCardSubcontext *pSubCtx = NULL;

    try
    {
        *phCard = NULL;     // Touch it to be sure it's real.
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        CTextString tzReader;

        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        tzReader = szReader;
        pRdr = new CReaderContext;
        if (NULL == pRdr)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("WinSCard Client has no memory"));
            throw (DWORD)SCARD_E_NO_MEMORY;
        }

        SCARDCONTEXT hRedirContext = pCtx->GetRedirContext();
        if (hRedirContext)
        {
            SCARDHANDLE hCard = g_phlReaders->Add(pRdr);    // do it first to avoid out of memory condition
            nReturn = pfnSCardConnectA(hRedirContext, szReader, dwShareMode, dwPreferredProtocols, phCard, pdwActiveProtocol);
            if (nReturn == SCARD_S_SUCCESS)
            {
                pRdr->SetRedirCard(*phCard);
                *phCard = hCard;
            }
            else
            {
                g_phlReaders->Close(hCard);
                delete pRdr;
            }
        }
        else
        {
            pSubCtx = pCtx->AcquireSubcontext(TRUE);
            pRdr->Connect(
                    pSubCtx,
                    tzReader,
                    dwShareMode,
                    dwPreferredProtocols);
            pSubCtx = NULL;
            pRdr->Context()->ReleaseSubcontext();
            if (NULL != pdwActiveProtocol)
                *pdwActiveProtocol = pRdr->Protocol();
            pRdr->Context()->m_hReaderHandle = g_phlReaders->Add(pRdr);
            *phCard = pRdr->Context()->m_hReaderHandle;
        }
    }

    catch (DWORD dwStatus)
    {
        if (NULL != pSubCtx)
        {
            pSubCtx->Deallocate();
            pSubCtx->ReleaseSubcontext();
        }
        if (NULL != pRdr)
            delete pRdr;
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        if (NULL != pSubCtx)
        {
            pSubCtx->Deallocate();
            pSubCtx->ReleaseSubcontext();
        }
        if (NULL != pRdr)
            delete pRdr;
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardStatus:

    This routine provides the current status of the reader.  It may be used at
    any time following a successful call to SCardConnect or SCardOpenReader, and
    prior to a successful call to SCardDisconnect.  It does not effect the state
    of the reader or driver.

Arguments:

    hCard - This is the reference value returned from the SCardConnect or
        SCardOpenReader service.

    mszReaderNames - This receives a list of friendly names by which the
        currently connected reader is known.  This list is returned as a
        multistring.

    pcchReaderLen - This supplies the length of the mszReader buffer, in
        characters, and receives the actual returned length of the reader
        friendly name list, in characters, including the trailing NULL
        characters.

    pdwState - This receives the current state of the reader.  Upon success, it
        receives one of the following state indicators:

        SCARD_ABSENT - This value implies there is no card in the reader.

        SCARD_PRESENT - This value implies there is a card is present in the
            reader, but that it has not been moved into position for use.

        SCARD_SWALLOWED - This value implies there is a card in the reader in
            position for use.  The card is not powered.

        SCARD_POWERED - This value implies there is power is being provided to
            the card, but the Reader Driver is unaware of the mode of the card.

        SCARD_NEGOTIABLEMODE - This value implies the card has been reset and is
            awaiting PTS negotiation.

        SCARD_SPECIFICMODE - This value implies the card has been reset and
            specific communication protocols have been established.

    pdwProtocol - This receives the current protocol, if any.  Possible returned
        values are listed below.  Other values may be added in the future.  The
        returned value is only meaningful if the returned state is
        SCARD_SPECIFICMODE.

        SCARD_PROTOCOL_RAW - The Raw Transfer Protocol is in use.

        SCARD_PROTOCOL_T0 - The ISO 7816/3 T=0 Protocol is in use.

        SCARD_PROTOCOL_T1 - The ISO 7816/3 T=1 Protocol is in use.

    pbAtr - This parameter points to a 32-byte buffer which receives the ATR
        string from the currently inserted card, if available.

    pbcAtrLen - This points to a DWORD which supplies the length of the pbAtr
        buffer, and receives the actual number of bytes in the ATR string.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardStatusA")

WINSCARDAPI LONG WINAPI
SCardStatusA(
    IN SCARDHANDLE hCard,
    OUT LPSTR mszReaderNames,
    IN OUT LPDWORD pcchReaderLen,
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT LPBYTE pbAtr,
    IN OUT LPDWORD pcbAtrLen)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (pRdr->GetRedirCard())
        {
            nReturn = pfnSCardStatusA(pRdr->GetRedirCard(), mszReaderNames, pcchReaderLen, pdwState, pdwProtocol, pbAtr, pcbAtrLen);
        }
        else
        {
            CBuffer bfAtr, bfReader;
            DWORD dwLocalState, dwLocalProtocol;

            pRdr->Status(&dwLocalState, &dwLocalProtocol, bfAtr, bfReader);
            if (NULL != pdwState)
                *pdwState = dwLocalState;
            if (NULL != pdwProtocol)
                *pdwProtocol = dwLocalProtocol;
            if (NULL != pcchReaderLen)
                PlaceMultiResult(
                    pRdr->Context()->Parent(),
                    bfReader,
                    mszReaderNames,
                    pcchReaderLen);
            if (NULL != pcbAtrLen)
                PlaceResult(pRdr->Context()->Parent(), bfAtr, pbAtr, pcbAtrLen);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
///////////////////////////////////////////////////////////////////////////////
//
//  Utility Routines
//

/*++

PlaceResult:

    This set of routines places the result of an operation into the user's
    output buffer, supporting SCARD_AUTO_ALLOCATE, invalid buffer sizes, etc.

Arguments:

    pCtx supplies the context under which this operation is being performed.

    bfResult supplies the result to be returned to the user.

    pbOutput receives the result for the user, as a byte stream.

    szOutput receives the result as an ANSI or UNICODE string.

    pcbLength supplies the length of the user's output buffer in bytes, and
        receives how much of it was used.

    pcchLength supplies the length of the user's output buffer in characters,
        and receives how much of it was used.

Return Value:

    None

Throws:

    Error conditions are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/7/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("PlaceResult")

void
PlaceResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPSTR szOutput,
    LPDWORD pcchLength)
{
    LPSTR szForUser = NULL;
    LPSTR szOutBuf = szOutput;
    DWORD cchSrcLength = bfResult.Length() / sizeof(TCHAR);

    try
    {
        if (NULL == szOutput)
            *pcchLength = 0;
        switch (*pcchLength)
        {
        case 0: // They just want the length.
            *pcchLength = cchSrcLength;
            break;

        case SCARD_AUTOALLOCATE:
            if (0 < cchSrcLength)
            {
                if (NULL == pCtx)
                {
                    szForUser = (LPSTR)HeapAlloc(
                                            GetProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            cchSrcLength * sizeof(CHAR));
                }
                else
                    szForUser = (LPSTR)pCtx->AllocateMemory(
                                        cchSrcLength * sizeof(CHAR));

                if (NULL == szForUser)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Client can't get return memory"));
                    throw (DWORD)SCARD_E_NO_MEMORY;
                }

                *(LPSTR *)szOutput = szForUser;
                szOutBuf = szForUser;
                // Fall through intentionally
            }
            else
            {
                *pcchLength = cchSrcLength;
                *(LPSTR *)szOutput = (LPSTR)g_wszBlank;
                break;      // Do terminate the case now.
            }

        default:
            if (*pcchLength < cchSrcLength)
            {
                *pcchLength = cchSrcLength;
                throw (DWORD)SCARD_E_INSUFFICIENT_BUFFER;
            }
            MoveToAnsiString(
                szOutBuf,
                (LPCTSTR)bfResult.Access(),
                cchSrcLength);
            *pcchLength = cchSrcLength;
            break;
        }
    }

    catch (...)
    {
        if (NULL != szForUser)
        {
            if (NULL == pCtx)
                HeapFree(GetProcessHeap(), 0, szForUser);
            else
                pCtx->FreeMemory(szForUser);
        }
        throw;
    }
}


/*++

PlaceMultiResult:

    This set of routines places a Multistring result of an operation into the
    user's output buffer, supporting SCARD_AUTO_ALLOCATE, invalid buffer sizes,
    etc.

Arguments:

    pCtx supplies the context under which this operation is being performed.

    bfResult supplies the TCHAR multistring result to be returned to the user.

    mszOutput receives the result as an ANSI or UNICODE multistring.

    pcchLength supplies the length of the user's output buffer in characters,
        and receives how much of it was used.

Return Value:

    None

Throws:

    Error conditions are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/7/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("PlaceMultiResult")

void
PlaceMultiResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPSTR mszOutput,
    LPDWORD pcchLength)
{
    LPSTR mszForUser = NULL;
    LPSTR mszOutBuf = mszOutput;
    DWORD cchSrcLength = bfResult.Length() / sizeof(TCHAR);

    try
    {
        if (NULL == mszOutput)
            *pcchLength = 0;
        switch (*pcchLength)
        {
        case 0: // They just want the length.
            *pcchLength = cchSrcLength;
            break;

        case SCARD_AUTOALLOCATE:
            if (0 < cchSrcLength)
            {
                if (NULL == pCtx)
                {
                    mszForUser = (LPSTR)HeapAlloc(
                                            GetProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            cchSrcLength * sizeof(CHAR));
                }
                else
                    mszForUser = (LPSTR)pCtx->AllocateMemory(
                                        cchSrcLength * sizeof(CHAR));

                if (NULL == mszForUser)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Client can't get return memory"));
                    throw (DWORD)SCARD_E_NO_MEMORY;
                }
                
                *(LPSTR *)mszOutput = mszForUser;
                mszOutBuf = mszForUser;
                // Fall through intentionally
            }
            else
            {
                *pcchLength = cchSrcLength;
                *(LPSTR *)mszOutput = (LPSTR)g_wszBlank;
                break;      // Do terminate the case now.
            }

        default:
            if (*pcchLength < cchSrcLength)
            {
                *pcchLength = cchSrcLength;
                throw (DWORD)SCARD_E_INSUFFICIENT_BUFFER;
            }
            MoveToAnsiMultiString(
                mszOutBuf,
                (LPCTSTR)bfResult.Access(),
                cchSrcLength);
            *pcchLength = cchSrcLength;
            break;
        }
    }

    catch (...)
    {
        if (NULL != mszForUser)
        {
            if (NULL == pCtx)
                HeapFree(GetProcessHeap(), 0, mszForUser);
            else
                pCtx->FreeMemory(mszForUser);
        }
        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\client\winscardw.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    WinSCard

Abstract:

    This module supplies the UNICODE version of the API for the Calais Smartcard
    Service Manager.

    The Calais Service Manager does the work of coordinating the protocols,
    readers, drivers, and smartcards on behalf of the application.  The
    following services are provided as part of a library to simplify access to
    the Service Manager.  These routines are the documented, exposed APIs.
    These routines merely package the requests and forward them to the Calais
    Service Manager, allowing the actual implementation of Calais to vary over
    time.

    At no time does the API library make security decisions.  All
    security-related functions must be performed by the Service Manager, running
    in its own address space, or in the operating system kernel.  However, some
    utility routines may be implemented in the API library for speed, as long as
    they do not involve security decisions.


Author:

    Doug Barlow (dbarlow) 10/23/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "client.h"
#include "redirect.h"


//
////////////////////////////////////////////////////////////////////////////////
//
//  Calais Database Query Services
//
//      These services all are oriented towards reading the Calais database.
//      They provide the option for listing a Smartcard Context (see Section
//      4.1.1), but do not require one.  Note that without a context, some or
//      all information may be inaccessable due to security restrictions.
//

/*++

SCardListReaderGroups:

    This service provides the list of named card reader groups that have
    previously been defined to the system.  The group 'SCard$DefaultReaders' is
    only returned if it contains at least one reader.  The group
    'SCard$AllReaders' is not returned, as it implicitly exists.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    mszGroups receives a multi-string listing the reader groups defined to this
        system and available to the current user on the current terminal.  If
        this value is NULL, the supplied buffer length in pcchGroups is ignored,
        the length of the buffer that would have been returned had this
        parameter not been null is written to pcchGroups, and a success code is
        returned.

    pcchGroups supplies the length of the mszGroups buffer in characters, and
        receives the actual length of the multi-string structure, including all
        trailing Null characters.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then szGroups is converted to a pointer to a string
        pointer, and receives the address of a block of memory containing the
        multi-string structure.  This block of memory must be deallocated via
        the SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListReaderGroupsW")

WINSCARDAPI LONG WINAPI
SCardListReaderGroupsW(
    IN SCARDCONTEXT hContext,
    OUT LPWSTR mszGroups,
    IN OUT LPDWORD pcchGroups)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfGroups;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardListReaderGroupsW(hRedirContext, mszGroups, pcchGroups);
        }
        else
        {
            ListReaderGroups(dwScope, bfGroups);
            PlaceMultiResult(pCtx, bfGroups, mszGroups, pcchGroups);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardListReaders:

    This service provides the list of readers within a set of named reader
    groups, eliminating duplicates.  The caller supplies a multistring listing
    the name of a set of pre-defined group of readers, and receives the list of
    smartcard readers within the named groups.  Unrecognized group names are
    ignored.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    mszGroups supplies the names of the reader groups defined to the system, as
        a multi-string.  A NULL value is used to indicate that all readers in
        the system be listed (i.e., the SCard$AllReaders group).

    mszReaders receives a multi-string listing the card readers within the
        supplied reader groups.  If this value is NULL, the supplied buffer
        length in pcchReaders is ignored, the length of the buffer that would
        have been returned had this parameter not been null is written to
        pcchReaders, and a success code is returned.

    pcchReaders supplies the length of the mszReaders buffer in characters, and
        receives the actual length of the multi-string structure, including all
        trailing Null characters.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then mszReaders is converted to a pointer to a
        string pointer, and receives the address of a block of memory containing
        the multi-string structure.  This block of memory must be deallocated
        via the SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListReadersW")

WINSCARDAPI LONG WINAPI
SCardListReadersW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR mszGroups,
    OUT LPWSTR mszReaders,
    IN OUT LPDWORD pcchReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfReaders;
        CTextMultistring mtzGroups;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn  = pfnSCardListReadersW(hRedirContext, mszGroups, mszReaders, pcchReaders);
        }
        else
        {
            mtzGroups = mszGroups;
            ListReaders(dwScope, mtzGroups, bfReaders);
            if (NULL != pCtx)
                pCtx->StripInactiveReaders(bfReaders);
            PlaceMultiResult(pCtx, bfReaders, mszReaders, pcchReaders);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardListCards:

    This service provides a list of named cards previously introduced to the
    system by this user which match an optionally supplied ATR string.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    pbAtr supplies the address of an ATR string to compare to known cards, or
        NULL if all card names are to be returned.

    rgguidInterfaces supplies an array of GUIDs, or the value NULL.  When an
        array is supplied, a card name will be returned only if this set of
        GUIDs is a (possibly improper) subset of the set of GUIDs supported by
        the card.

    cguidInterfaceCount supplies the number of entries in the rgguidInterfaces
        array.  If rgguidInterfaces is NULL, then this value is ignored.

  mszCards receives a multi-string listing the smartcards introduced to the
        system by this user which match the supplied ATR string.  If this value
        is NULL, the supplied buffer length in pcchCards is ignored, the length
        of the buffer that would have been returned had this parameter not been
        null is written to pcchCards, and a success code is returned.

    pcchCards supplies the length of the mszCards buffer in characters, and
        receives the actual length of the multi-string structure, including all
        trailing Null characters.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then mszCards is converted to a pointer to a string
        pointer, and receives the address of a block of memory containing the
        multi-string structure.  This block of memory must be deallocated via he
        SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListCardsW")

WINSCARDAPI LONG WINAPI
SCardListCardsW(
    IN SCARDCONTEXT hContext,
    IN LPCBYTE pbAtr,
    IN LPCGUID rgquidInterfaces,
    IN DWORD cguidInterfaceCount,
    OUT LPWSTR mszCards,
    IN OUT LPDWORD pcchCards)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfCards;
        CSCardUserContext *pCtx = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        ListCards(
            dwScope,
            pbAtr,
            rgquidInterfaces,
            cguidInterfaceCount,
            bfCards);
        PlaceMultiResult(pCtx, bfCards, mszCards, pcchCards);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardListInterfaces:

    This service provides a list of interfaces known to be supplied by a given
    card.  The caller supplies the name of a smartcard previously introduced to
    the system, and receives the list of interfaces supported by the card.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    szCard supplies the name of the card defined to the system.

    pguidInterfaces receives an array of GUIDs indicating the interfaces
        supported by the named smartcard.  If this value is NULL, the supplied
        array length in pcguidInterfaces is ignored, the size of the array that
        would have been returned had this parameter not been null is written to
        pcguidInterfaces, and a success code is returned.

    pcguidInterfaces supplies the size of the pguidInterfaces array, and
        receives the actual size of the returned array.  If the array size is
        specified as SCARD_AUTOALLOCATE, then pguidInterfaces is converted to a
        pointer to a GUID pointer, and receives the address of a block of memory
        containing the array.  This block of memory must be deallocated via he
        SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardListInterfacesW")

WINSCARDAPI LONG WINAPI
SCardListInterfacesW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCard,
    OUT LPGUID pguidInterfaces,
    IN OUT LPDWORD pcguidInterfaces)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        BOOL fSts;
        CTextString tzCard;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        DWORD cbInterfaces;
        CBuffer bfInterfaces;
        CSCardUserContext *pCtx = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }

        tzCard = szCard;
        fSts = GetCardInfo(
                    dwScope,
                    tzCard,
                    NULL,
                    NULL,
                    &bfInterfaces,
                    NULL);
        if (!fSts)
            throw (DWORD)SCARD_E_UNKNOWN_CARD;
        if (SCARD_AUTOALLOCATE == *pcguidInterfaces)
            cbInterfaces = SCARD_AUTOALLOCATE;
        else
            cbInterfaces = *pcguidInterfaces * sizeof(GUID);
        PlaceResult(
            pCtx,
            bfInterfaces,
            (LPBYTE)pguidInterfaces,
            &cbInterfaces);
        *pcguidInterfaces = cbInterfaces / sizeof(GUID);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardGetProviderId:

    This service returns the GUID of the Primary Service Provider for the given
    card.  The caller supplies the name of a smartcard previously introduced to
    the system, and receives the registered Primary Service Provider GUID, if
    any.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    szCard supplies the name of the card defined to the system.

    pguidInterfaces receives the GUID of the Primary Service Provider of the
        indicated card.  This provider may be activated via COM, and will supply
        access to other services in the card.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardGetProviderIdW")

WINSCARDAPI LONG WINAPI
SCardGetProviderIdW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCard,
    OUT LPGUID pguidProviderId)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        BOOL fSts;
        CTextString tzCard;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CBuffer bfProvider;

        if (NULL != hContext)
        {
            CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }

        tzCard = szCard;
        fSts = GetCardInfo(
                    dwScope,
                    tzCard,
                    NULL,
                    NULL,
                    NULL,
                    &bfProvider);
        if (!fSts)
            throw (DWORD)SCARD_E_UNKNOWN_CARD;
        if (sizeof(GUID) != bfProvider.Length())
            throw (DWORD)SCARD_E_INVALID_TARGET;
        CopyMemory(pguidProviderId, bfProvider.Access(), bfProvider.Length());
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardGetCardTypeProviderName:

    This service returns the value of a given Provider Name, by Id number, for
    the identified card type.  The caller supplies the name of a smartcard
    previously introduced to the system, and receives the registered Service
    Provider of that type, if any, as a string.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service, or is
        NULL if this query is not directed towards a specific context.

    szCardName supplies the name of the card type with which this provider name
        is associated.

    dwProviderId supplies the identifier for the provider associated with this
        card type.  Possible values are:

        SCARD_PROVIDER_SSP - The Primary SSP identifier, as a GUID string.
        SCARD_PROVIDER_CSP - The CSP name.

        Other values < 0x80000000 are reserved for use by Microsoft.  Values
        over 0x80000000 are available for use by the smart card vendors, and
        are card-specific.

    szProvider receives the string identifying the provider.

    pcchProvider supplies the length of the szProvider buffer in characters,
        and receives the actual length of the returned string, including the
        trailing null character.  If the buffer length is specified as
        SCARD_AUTOALLOCATE, then szProvider is converted to a pointer to a
        string pointer, and receives the address of a block of memory
        containing the string.  This block of memory must be deallocated via
        the SCardFreeMemory() service.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Throws:

    Errors as DWORD status codes

Author:

    Doug Barlow (dbarlow) 1/19/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardGetCardTypeProviderNameW")

WINSCARDAPI LONG WINAPI
SCardGetCardTypeProviderNameW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCardName,
    IN DWORD dwProviderId,
    OUT LPWSTR szProvider,
    IN OUT LPDWORD pcchProvider)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        CTextString tzCardName;
        CBuffer bfProvider;
        CSCardUserContext *pCtx = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        GetCardTypeProviderName(
            dwScope,
            tzCardName,
            dwProviderId,
            bfProvider);
        PlaceResult(pCtx, bfProvider, szProvider, pcchProvider);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Calais Database Management Services
//
//      The following services provide for managing the Calais Database.  These
//      services actually update the database, and require a smartcard context.
//

/*++

SCardIntroduceReaderGroup:

    This service provides means for introducing a new smartcard reader group to
    Calais.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szGroupName supplies the friendly name to be assigned to the new reader
        group.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardIntroduceReaderGroupW")

WINSCARDAPI LONG WINAPI
SCardIntroduceReaderGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardIntroduceReaderGroupW(hRedirContext, szGroupName);
        }
        else
        {
            tzGroupName = szGroupName;
            IntroduceReaderGroup(
                dwScope,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardForgetReaderGroup:

    This service provides means for removing a previously defined smartcard
    reader group from the Calais Subsystem.  This service automatically clears
    all readers from the group before forgetting it.  It does not affect the
    existence of the readers in the database.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szGroupName supplies the friendly name of the reader group to be
        forgotten.  The Calais-defined default reader groups may not be
        forgotten.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardForgetReaderGroupW")

WINSCARDAPI LONG WINAPI
SCardForgetReaderGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardForgetReaderGroupW(hRedirContext, szGroupName);
        }
        else
        {
            tzGroupName = szGroupName;
            ForgetReaderGroup(
                dwScope,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardIntroduceReader:

    This service provides means for introducing an existing smartcard reader
    device to Calais.  Once introduced, Calais will assume responsibility for
    managing access to that reader.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name to be assigned to the reader.

    SzDeviceName supplies the system name of the smartcard reader device.
        (Example: "VendorX ModelY Z".)

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardIntroduceReaderW")

WINSCARDAPI LONG WINAPI
SCardIntroduceReaderW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName,
    IN LPCWSTR szDeviceName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CTextString tzDeviceName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardIntroduceReaderW(hRedirContext, szReaderName, szDeviceName);
        }
        else
        {
            tzReaderName = szReaderName;
            tzDeviceName = szDeviceName;
            IntroduceReader(
                dwScope,
                tzReaderName,
                tzDeviceName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardForgetReader:

    This service provides means for removing previously defined smartcard
    readers from control by the Calais Subsystem.  It is automatically removed
    from any groups it may have been added to.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name of the reader to be forgotten.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardForgetReaderW")

WINSCARDAPI LONG WINAPI
SCardForgetReaderW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardForgetReaderW(hRedirContext, szReaderName);
        }
        else
        {
            tzReaderName = szReaderName;
            ForgetReader(
                dwScope,
                tzReaderName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardAddReaderToGroup:

    This service provides means for adding existing an reader into an existing
    reader group.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name of the reader to be added.

    szGroupName supplies the friendly name of the group to which the reader
        should be added.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardAddReaderToGroupW")

WINSCARDAPI LONG WINAPI
SCardAddReaderToGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName,
    IN LPCWSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardAddReaderToGroupW(hRedirContext, szReaderName, szGroupName);
        }
        else
        {
            tzReaderName = szReaderName;
            tzGroupName = szGroupName;
            AddReaderToGroup(
                dwScope,
                tzReaderName,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardRemoveReaderFromGroup:

    This service provides means for removing an existing reader from an existing
    reader group.  It does not affect the existence of either the reader or the
    group in the Calais database.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szReaderName supplies the friendly name of the reader to be removed.

    szGroupName supplies the friendly name of the group to which the reader
        should be removed.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardRemoveReaderFromGroupW")

WINSCARDAPI LONG WINAPI
SCardRemoveReaderFromGroupW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReaderName,
    IN LPCWSTR szGroupName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzReaderName;
        CTextString tzGroupName;
        CSCardUserContext *pCtx = NULL;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;
        SCARDCONTEXT hRedirContext = NULL;

        if (NULL != hContext)
        {
            pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            if (pCtx->IsBad())
            {
                throw (DWORD)SCARD_E_SERVICE_STOPPED;
            }
            dwScope = pCtx->Scope();
            hRedirContext = pCtx->GetRedirContext();
        }
        if (hRedirContext || TS_REDIRECT_MODE) {
            if (!TS_REDIRECT_READY)
            {
                throw (DWORD)SCARD_E_NO_SERVICE;
            }
            nReturn = pfnSCardRemoveReaderFromGroupW(hRedirContext, szReaderName, szGroupName);
        }
        else
        {
            tzReaderName = szReaderName;
            tzGroupName = szGroupName;
            RemoveReaderFromGroup(
                dwScope,
                tzReaderName,
                tzGroupName);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardIntroduceCardType:

    This service provides means for introducing new smartcards to the Calais
    Subsystem for the active user.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szCardName supplies the name by which the user can recognize this card.

    PguidPrimaryProvider supplies a pointer to a GUID used to identify the
        Primary Service Provider for the card.

    rgguidInterfaces supplies an array of GUIDs identifying the smartcard
        interfaces supported by this card.

    dwInterfaceCount supplies the number of GUIDs in the pguidInterfaces array.

    pbAtr supplies a string against which card ATRs will be compared to
        determine a possible match for this card.  The length of this string is
        determined by normal ATR parsing.

    pbAtrMask supplies an optional bitmask to use when comparing the ATRs of
        smartcards to the ATR supplied in pbAtr.  If this value is non-NULL, it
        must point to a string of bytes the same length as the ATR string
        supplied in pbAtr.  Then when a given ATR A is compared to the ATR
        supplied in pbAtr B, it matches if and only if A & M = B, where M is the
        supplied mask, and & represents bitwise logical AND.

    cbAtrLen supplies the length of the ATR and Mask.  This value may be zero
        if the lentgh is obvious from the ATR.  However, it may be required if
        there is a Mask value that obscures the actual ATR.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardIntroduceCardTypeW")

WINSCARDAPI LONG WINAPI
SCardIntroduceCardTypeW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCardName,
    IN LPCGUID pguidPrimaryProvider,
    IN LPCGUID rgguidInterfaces,
    IN DWORD dwInterfaceCount,
    IN LPCBYTE pbAtr,
    IN LPCBYTE pbAtrMask,
    IN DWORD cbAtrLen)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzCardName;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;

        if (NULL != hContext)
        {
            CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        IntroduceCard(
            dwScope,
            tzCardName,
            pguidPrimaryProvider,
            rgguidInterfaces,
            dwInterfaceCount,
            pbAtr,
            pbAtrMask,
            cbAtrLen);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardSetCardTypeProviderName:

    This service provides means for adding additional service providers to a
    specified card type.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szCardName supplies the name of the card type with which this provider
        name is to be associated.

    dwProviderId supplies the identifier for the provider to be associated with
        this card type.  Possible values are:

        SCARD_PROVIDER_SSP - The Primary SSP identifier, as a GUID string.
        SCARD_PROVIDER_CSP - The CSP name.

        Other values < 0x80000000 are reserved for use by Microsoft.  Values
        over 0x80000000 are available for use by the smart card vendors, and
        are card-specific.

    szProvider supplies the string identifying the provider.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 1/19/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardSetCardTypeProviderNameW")

WINSCARDAPI LONG WINAPI
SCardSetCardTypeProviderNameW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCardName,
    IN DWORD dwProviderId,
    IN LPCWSTR szProvider)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzCardName;
        CTextString tzProvider;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;

        if (NULL != hContext)
        {
           CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        tzProvider = szProvider;
        SetCardTypeProviderName(
            dwScope,
            tzCardName,
            dwProviderId,
            tzProvider);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardForgetCardType:

    This service provides means for removing previously defined smartcards from
    the Calais Subsystem.

Arguments:

    hContext supplies the handle identifying the Service Manager Context, which
        must have been previously established via the SCardEstablishContext()
        service.

    szCardName supplies the friendly name of the card to be forgotten.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardForgetCardTypeW")

WINSCARDAPI LONG WINAPI
SCardForgetCardTypeW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szCardName)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CTextString tzCardName;
        DWORD dwScope = SCARD_SCOPE_SYSTEM;

        if (NULL != hContext)
        {
            CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
            dwScope = pCtx->Scope();
        }
        tzCardName = szCardName;
        ForgetCard(
            dwScope,
            tzCardName);
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Services
//
//      The following services supply means for tracking cards within readers.
//

/*++

SCardLocateCards:

    This service searches the readers listed in the lpReaderStates parameter for
    any containing a card with an ATR string matching one of the card supplied
    names.  This service returns immediately with the result.  If no matching
    cards are found, the calling application may use the SCardGetStatusChange
    service to wait for card availability changes.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    mszCards supplies the names of the cards to search for, as a multi-string.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardLocateCardsW")

WINSCARDAPI LONG WINAPI
SCardLocateCardsW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR mszCards,
    IN OUT LPSCARD_READERSTATE_W rgReaderStates,
    IN DWORD cReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;
    LPSCARD_ATRMASK rgAtrMasks = NULL;

    try
    {
        LPCSTR szCard;
        CTextMultistring mtzCards;
        DWORD dwIndex;
        DWORD dwScope;
        CBuffer bfXlate1(36), bfXlate2(36); // Rough guess of name & ATR lengths
        BOOL fSts;

        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        dwScope = pCtx->Scope();

        if (0 == *mszCards)
            throw (DWORD)SCARD_E_INVALID_VALUE;

        mtzCards = mszCards;

        rgAtrMasks = new SCARD_ATRMASK[MStringCount(mtzCards)];
        if (rgAtrMasks == NULL)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("WinSCard Client has no memory"));
            throw (DWORD)SCARD_E_NO_MEMORY;
        }

        dwIndex = 0;
        for (szCard = FirstString(mtzCards);
             NULL != szCard;
             szCard = NextString(szCard))
        {
            fSts = GetCardInfo(
                        dwScope,
                        szCard,
                        &bfXlate1,  // ATR
                        &bfXlate2,  // Mask
                        NULL,
                        NULL);
            if (!fSts)
                throw (DWORD)SCARD_E_UNKNOWN_CARD;

            ASSERT(33 >= bfXlate1.Length());    // Biggest an ATR can be.
            rgAtrMasks[dwIndex].cbAtr = bfXlate1.Length();
            memcpy(rgAtrMasks[dwIndex].rgbAtr, bfXlate1.Access(), rgAtrMasks[dwIndex].cbAtr);

            ASSERT(rgAtrMasks[dwIndex].cbAtr == bfXlate2.Length());
            memcpy(rgAtrMasks[dwIndex].rgbMask, bfXlate2.Access(), rgAtrMasks[dwIndex].cbAtr);

            dwIndex ++;
        }

        nReturn = SCardLocateCardsByATRW(
                    hContext,
                    rgAtrMasks,
                    dwIndex,
                    rgReaderStates,
                    cReaders);

            // If the remote client does not implement the new API
            // retry with the old one. it might succeed if its DB is good enough
        if ((nReturn == ERROR_CALL_NOT_IMPLEMENTED) && (pCtx->GetRedirContext()))
        {
            nReturn = pfnSCardLocateCardsW(pCtx->GetRedirContext(), mszCards, rgReaderStates, cReaders);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    if (rgAtrMasks != NULL)
    {
        try
        {
            delete[] rgAtrMasks;
        }
        catch (...)
        {
        }
    }

    return nReturn;
}


/*++

SCardLocateCardsByATR:

    This service searches the readers listed in the lpReaderStates parameter for
    any containing a card with an ATR string matching one of the supplied ATRs
    This service returns immediately with the result.  If no matching
    cards are found, the calling application may use the SCardGetStatusChange
    service to wait for card availability changes.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    rgAtrMasks supplies the ATRs to search for, as an array of structs.
    
    cAtrs supplies the number of elements in the rgAtrMasks array.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the search, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardLocateCardsByATRW")

WINSCARDAPI LONG WINAPI
SCardLocateCardsByATRW(
    IN SCARDCONTEXT hContext,
    IN LPSCARD_ATRMASK rgAtrMasks,
    IN DWORD cAtrs,
    IN OUT LPSCARD_READERSTATE_W rgReaderStates,
    IN DWORD cReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (pCtx->GetRedirContext())
        {
            nReturn = pfnSCardLocateCardsByATRW(pCtx->GetRedirContext(), rgAtrMasks, cAtrs, rgReaderStates, cReaders);
        }
        else
        {
            CBuffer bfReaders;
            DWORD dwIndex;

            for (dwIndex = 0; dwIndex < cReaders; dwIndex += 1)
                MStrAdd(bfReaders, rgReaderStates[dwIndex].szReader);

            pCtx->LocateCards(
                    bfReaders,
                    rgAtrMasks,
                    cAtrs,
                    (LPSCARD_READERSTATE)rgReaderStates,
                    cReaders);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardGetStatusChange:

    This service is used to block execution until such time as the current
    availability of cards in a given set of readers changes.  The caller
    supplies a list of readers to be monitored via an SCARD_READERSTATE array,
    and the maximum amount of time, in seconds, that it is willing to wait for
    an action to occur on one of the listed readers.  Zero in this parameter
    indicates that no timeout is specified.  The service returns when there is a
    change in availability, having filled in the dwEventState fields of the
    rgReaderStates parameter appropriately.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    dwTimeOut supplies the maximum amount of time to wait for an action, in
        seconds.  A zero value implies that the wait will never timeout.

    rgReaderStates supplies an array of SCARD_READERSTATE structures controlling
        the wait, and receives the result.

    cReaders supplies the number of elements in the rgReaderStates array.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardGetStatusChangeW")

WINSCARDAPI LONG WINAPI
SCardGetStatusChangeW(
    IN SCARDCONTEXT hContext,
    IN DWORD dwTimeout,
    IN OUT LPSCARD_READERSTATE_W rgReaderStates,
    IN DWORD cReaders)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);

        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (pCtx->GetRedirContext())
        {
            nReturn = pfnSCardGetStatusChangeW(pCtx->GetRedirContext(), dwTimeout, rgReaderStates, cReaders);
        }
        else
        {
            CBuffer bfReaders;
            DWORD dwIndex;

            for (dwIndex = 0; dwIndex < cReaders; dwIndex += 1)
                MStrAdd(bfReaders, rgReaderStates[dwIndex].szReader);
            pCtx->GetStatusChange(
                        bfReaders,
                        (LPSCARD_READERSTATE)rgReaderStates,
                        cReaders,
                        dwTimeout);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  Card/Reader Access Services
//
//      The following services provide means for establishing communication with
//      the card.
//

/*++

SCardConnect:

    This service establishes a connection from the calling application to the
    smartcard in the designated reader.  If no card exists in the specified
    reader, an error is returned.

Arguments:

    hContext supplies the handle identifying the Service Manager Context
        established previously via the SCardEstablishContext() service.

    szReader supplies the name of the reader containing the target card.

    DwShareMode supplies a flag indicating whether or not other applications may
        form connections to this card.  Possible values are:

        SCARD_SHARE_SHARED - This application is willing to share this card with
            other applications.

        SCARD_SHARE_EXCLUSIVE - This application is not willing to share this
            card with other applications.

        SCARD_SHARE_DIRECT - This application is taking control of the reader.

    DwPreferredProtocols supplies a bit mask of acceptable protocols for this
        connection.  Possible values, which may be combined via the OR
        operation, are:

        SCARD_PROTOCOL_T0 - T=0 is an acceptable protocol.

        SCARD_PROTOCOL_T1 - T=1 is an acceptable protocol.

    phCard receives a handle identifying the connection to the smartcard in the
        designated reader.

    pdwActiveProtocol receives a flag indicating the established active
        protocol.  Possible values are:

        SCARD_PROTOCOL_T0 - T=0 is the active protocol.

        SCARD_PROTOCOL_T1 - T=1 is the active protocol.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardConnectW")

WINSCARDAPI LONG WINAPI
SCardConnectW(
    IN SCARDCONTEXT hContext,
    IN LPCWSTR szReader,
    IN DWORD dwShareMode,
    IN DWORD dwPreferredProtocols,
    OUT LPSCARDHANDLE phCard,
    OUT LPDWORD pdwActiveProtocol)
{
    LONG nReturn = SCARD_S_SUCCESS;
    CReaderContext *pRdr = NULL;
    CSCardSubcontext *pSubCtx = NULL;

    try
    {
        *phCard = NULL;     // Touch it to be sure it's real.
        CSCardUserContext *pCtx = (CSCardUserContext *)((*g_phlContexts)[hContext]);
        CTextString tzReader;

        if (pCtx->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        tzReader = szReader;
        pRdr = new CReaderContext;
        if (NULL == pRdr)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("WinSCard Client has no memory"));
            throw (DWORD)SCARD_E_NO_MEMORY;
        }

        SCARDCONTEXT hRedirContext = pCtx->GetRedirContext();
        if (hRedirContext)
        {
            SCARDHANDLE hCard = g_phlReaders->Add(pRdr);    // do it first to avoid out of memory condition
            nReturn = pfnSCardConnectW(hRedirContext, szReader, dwShareMode, dwPreferredProtocols, phCard, pdwActiveProtocol);
            if (nReturn == SCARD_S_SUCCESS)
            {
                pRdr->SetRedirCard(*phCard);
                *phCard = hCard;
            }
            else
            {
                g_phlReaders->Close(hCard);
                delete pRdr;
            }
        }
        else
        {
            pSubCtx = pCtx->AcquireSubcontext(TRUE);
            pRdr->Connect(
                    pSubCtx,
                    tzReader,
                    dwShareMode,
                    dwPreferredProtocols);
            pSubCtx = NULL;
            pRdr->Context()->ReleaseSubcontext();
            if (NULL != pdwActiveProtocol)
                *pdwActiveProtocol = pRdr->Protocol();
            pRdr->Context()->m_hReaderHandle = g_phlReaders->Add(pRdr);
            *phCard = pRdr->Context()->m_hReaderHandle;
        }
    }

    catch (DWORD dwStatus)
    {
        if (NULL != pSubCtx)
        {
            pSubCtx->Deallocate();
            pSubCtx->ReleaseSubcontext();
        }
        if (NULL != pRdr)
            delete pRdr;
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        if (NULL != pSubCtx)
        {
            pSubCtx->Deallocate();
            pSubCtx->ReleaseSubcontext();
        }
        if (NULL != pRdr)
            delete pRdr;
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


/*++

SCardStatus:

    This routine provides the current status of the reader.  It may be used at
    any time following a successful call to SCardConnect or SCardOpenReader, and
    prior to a successful call to SCardDisconnect.  It does not effect the state
    of the reader or driver.

Arguments:

    hCard - This is the reference value returned from the SCardConnect or
        SCardOpenReader service.

    mszReaderNames - This receives a list of friendly names by which the
        currently connected reader is known.  This list is returned as a
        multistring.

    pcchReaderLen - This supplies the length of the mszReader buffer, in
        characters, and receives the actual returned length of the reader
        friendly name list, in characters, including the trailing NULL
        characters.

    pdwState - This receives the current state of the reader.  Upon success, it
        receives one of the following state indicators:

        SCARD_ABSENT - This value implies there is no card in the reader.

        SCARD_PRESENT - This value implies there is a card is present in the
            reader, but that it has not been moved into position for use.

        SCARD_SWALLOWED - This value implies there is a card in the reader in
            position for use.  The card is not powered.

        SCARD_POWERED - This value implies there is power is being provided to
            the card, but the Reader Driver is unaware of the mode of the card.

        SCARD_NEGOTIABLEMODE - This value implies the card has been reset and is
            awaiting PTS negotiation.

        SCARD_SPECIFICMODE - This value implies the card has been reset and
            specific communication protocols have been established.

    pdwProtocol - This receives the current protocol, if any.  Possible returned
        values are listed below.  Other values may be added in the future.  The
        returned value is only meaningful if the returned state is
        SCARD_SPECIFICMODE.

        SCARD_PROTOCOL_RAW - The Raw Transfer Protocol is in use.

        SCARD_PROTOCOL_T0 - The ISO 7816/3 T=0 Protocol is in use.

        SCARD_PROTOCOL_T1 - The ISO 7816/3 T=1 Protocol is in use.

    pbAtr - This parameter points to a 32-byte buffer which receives the ATR
        string from the currently inserted card, if available.

    pbcAtrLen - This points to a DWORD which supplies the length of the pbAtr
        buffer, and receives the actual number of bytes in the ATR string.

Return Value:

    A 32-bit value indicating whether or not the service completed successfully.
    SCARD_S_SUCCESS is returned on successful completion.  Otherwise, the value
    represents an error condition.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("SCardStatusW")

WINSCARDAPI LONG WINAPI
SCardStatusW(
    IN SCARDHANDLE hCard,
    OUT LPWSTR mszReaderNames,
    IN OUT LPDWORD pcchReaderLen,
    OUT LPDWORD pdwState,
    OUT LPDWORD pdwProtocol,
    OUT LPBYTE pbAtr,
    IN OUT LPDWORD pcbAtrLen)
{
    LONG nReturn = SCARD_S_SUCCESS;

    try
    {
        CReaderContext *pRdr = (CReaderContext *)((*g_phlReaders)[hCard]);
        if (pRdr->IsBad())
        {
            throw (DWORD)SCARD_E_SERVICE_STOPPED;
        }
        if (pRdr->GetRedirCard())
        {
            nReturn = pfnSCardStatusW(pRdr->GetRedirCard(), mszReaderNames, pcchReaderLen, pdwState, pdwProtocol, pbAtr, pcbAtrLen);
        }
        else
        {
            CBuffer bfAtr, bfReader;
            DWORD dwLocalState, dwLocalProtocol;

            pRdr->Status(&dwLocalState, &dwLocalProtocol, bfAtr, bfReader);
            if (NULL != pdwState)
                *pdwState = dwLocalState;
            if (NULL != pdwProtocol)
                *pdwProtocol = dwLocalProtocol;
            if (NULL != pcchReaderLen)
                PlaceMultiResult(
                    pRdr->Context()->Parent(),
                    bfReader,
                    mszReaderNames,
                    pcchReaderLen);
            if (NULL != pcbAtrLen)
                PlaceResult(pRdr->Context()->Parent(), bfAtr, pbAtr, pcbAtrLen);
        }
    }

    catch (DWORD dwStatus)
    {
        nReturn = (LONG)dwStatus;
    }

    catch (...)
    {
        nReturn = SCARD_E_INVALID_PARAMETER;
    }

    return nReturn;
}


//
///////////////////////////////////////////////////////////////////////////////
//
//  Utility Routines
//

/*++

PlaceResult:

    This set of routines places the result of an operation into the user's
    output buffer, supporting SCARD_AUTO_ALLOCATE, invalid buffer sizes, etc.

Arguments:

    pCtx supplies the context under which this operation is being performed.

    bfResult supplies the result to be returned to the user.

    pbOutput receives the result for the user, as a byte stream.

    szOutput receives the result as an ANSI or UNICODE string.

    pcbLength supplies the length of the user's output buffer in bytes, and
        receives how much of it was used.

    pcchLength supplies the length of the user's output buffer in characters,
        and receives how much of it was used.

Return Value:

    None

Throws:

    Error conditions are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/7/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("PlaceResult")

void
PlaceResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPWSTR szOutput,
    LPDWORD pcchLength)
{
    LPWSTR szForUser = NULL;
    LPWSTR szOutBuf = szOutput;
    DWORD cchSrcLength = bfResult.Length() / sizeof(TCHAR);

    try
    {
        if (NULL == szOutput)
            *pcchLength = 0;
        switch (*pcchLength)
        {
        case 0: // They just want the length.
            *pcchLength = cchSrcLength;
            break;

        case SCARD_AUTOALLOCATE:
            if (0 < cchSrcLength)
            {
                if (NULL == pCtx)
                {
                    szForUser = (LPWSTR)HeapAlloc(
                                            GetProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            cchSrcLength * sizeof(WCHAR));
                }
                else
                    szForUser = (LPWSTR)pCtx->AllocateMemory(
                                        cchSrcLength * sizeof(WCHAR));

                if (NULL == szForUser)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Client can't get return memory"));
                    throw (DWORD)SCARD_E_NO_MEMORY;
                }
                
                *(LPWSTR *)szOutput = szForUser;
                szOutBuf = szForUser;
                // Fall through intentionally
            }
            else
            {
                *pcchLength = cchSrcLength;
                *(LPWSTR *)szOutput = (LPWSTR)g_wszBlank;
                break;      // Do terminate the case now.
            }

        default:
            if (*pcchLength < cchSrcLength)
            {
                *pcchLength = cchSrcLength;
                throw (DWORD)SCARD_E_INSUFFICIENT_BUFFER;
            }
            MoveToUnicodeString(
                szOutBuf,
                (LPCTSTR)bfResult.Access(),
                cchSrcLength);
            *pcchLength = cchSrcLength;
            break;
        }
    }

    catch (...)
    {
        if (NULL != szForUser)
        {
            if (NULL == pCtx)
                HeapFree(GetProcessHeap(), 0, szForUser);
            else
                pCtx->FreeMemory(szForUser);
        }
        throw;
    }
}


/*++

PlaceMultiResult:

    This set of routines places a Multistring result of an operation into the
    user's output buffer, supporting SCARD_AUTO_ALLOCATE, invalid buffer sizes,
    etc.

Arguments:

    pCtx supplies the context under which this operation is being performed.

    bfResult supplies the TCHAR multistring result to be returned to the user.

    mszOutput receives the result as an ANSI or UNICODE multistring.

    pcchLength supplies the length of the user's output buffer in characters,
        and receives how much of it was used.

Return Value:

    None

Throws:

    Error conditions are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/7/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("PlaceMultiResult")

void
PlaceMultiResult(
    CSCardUserContext *pCtx,
    CBuffer &bfResult,
    LPWSTR mszOutput,
    LPDWORD pcchLength)
{
    LPWSTR mszForUser = NULL;
    LPWSTR mszOutBuf = mszOutput;
    DWORD cchSrcLength = bfResult.Length() / sizeof(TCHAR);

    try
    {
        if (NULL == mszOutput)
            *pcchLength = 0;
        switch (*pcchLength)
        {
        case 0: // They just want the length.
            *pcchLength = cchSrcLength;
            break;

        case SCARD_AUTOALLOCATE:
            if (0 < cchSrcLength)
            {
                if (NULL == pCtx)
                {
                    mszForUser = (LPWSTR)HeapAlloc(
                                            GetProcessHeap(),
                                            HEAP_ZERO_MEMORY,
                                            cchSrcLength * sizeof(WCHAR));
                }
                else
                    mszForUser = (LPWSTR)pCtx->AllocateMemory(
                                        cchSrcLength * sizeof(WCHAR));

                if (NULL == mszForUser)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Client can't get return memory"));
                    throw (DWORD)SCARD_E_NO_MEMORY;
                }
                
                *(LPWSTR *)mszOutput = mszForUser;
                mszOutBuf = mszForUser;
                // Fall through intentionally
            }
            else
            {
                *pcchLength = cchSrcLength;
                *(LPWSTR *)mszOutput = (LPWSTR)g_wszBlank;
                break;      // Do terminate the case now.
            }

        default:
            if (*pcchLength < cchSrcLength)
            {
                *pcchLength = cchSrcLength;
                throw (DWORD)SCARD_E_INSUFFICIENT_BUFFER;
            }
            MoveToUnicodeMultiString(
                mszOutBuf,
                (LPCTSTR)bfResult.Access(),
                cchSrcLength);
            *pcchLength = cchSrcLength;
            break;
        }
    }

    catch (...)
    {
        if (NULL != mszForUser)
        {
            if (NULL == pCtx)
                HeapFree(GetProcessHeap(), 0, mszForUser);
            else
                pCtx->FreeMemory(mszForUser);
        }
        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\comms\comchanl.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ComChanl

Abstract:

    This module implements the CComChannel Communications Class

Author:

    Doug Barlow (dbarlow) 10/30/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    None

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <WinSCard.h>
#include <CalMsgs.h>
#include <CalCom.h>


//
//==============================================================================
//
//  CComChannel
//

/*++

CComChannel:

    This is the standard constructor and destructor for the Comm Channel
    class.  They just call the clean and clear functions, respectively.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/30/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComChannel::CComChannel")

CComChannel::CComChannel(
    HANDLE hPipe)
:   m_hPipe(DBGT("CComChannel connection pipe")),
    m_hProc(DBGT("CComChannel process handle")),
    m_hOvrWait(DBGT("CComChannel overlapped I/O event"))
{
    m_hPipe = hPipe;
    ZeroMemory(&m_ovrlp, sizeof(m_ovrlp));
    m_ovrlp.hEvent = m_hOvrWait = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!m_hOvrWait.IsValid())
    {
        DWORD dwErr = m_hOvrWait.GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Comm Responder failed to create overlapped event: %1"),
            dwErr);
        throw dwErr;
    }
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComChannel::~CComChannel")
CComChannel::~CComChannel()
{
    if (m_hPipe.IsValid())
        m_hPipe.Close();
    if (m_hProc.IsValid())
        m_hProc.Close();
    if (m_hOvrWait.IsValid())
        m_hOvrWait.Close();
}


/*++

Send:

    Send data over the communications channel.

Arguments:

    pvData supplies the data to be written.
    cbLen supplies the length of the data, in bytes.

Return Value:

    A DWORD status code.

Throws:

    None.

Author:

    Doug Barlow (dbarlow) 11/4/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComChannel::Send")

DWORD
CComChannel::Send(
    LPCVOID pvData,
    DWORD cbLen)
{
    BOOL fSts;
    DWORD dwLen, dwOffset = 0;
    DWORD dwSts = SCARD_S_SUCCESS;

    while (0 < cbLen)
    {
        fSts = WriteFile(
            m_hPipe,
            &((LPBYTE)pvData)[dwOffset],
            cbLen,
            &dwLen,
            &m_ovrlp);
        if (!fSts)
        {
            BOOL fErrorProcessed;
            dwSts = GetLastError();

            do
            {
                fErrorProcessed = TRUE;
                switch (dwSts)
                {
                //
                // Postpone processing
                case ERROR_IO_PENDING:
                    fErrorProcessed = FALSE;
                    WaitForever(
                        m_ovrlp.hEvent,
                        REASONABLE_TIME,
                        DBGT("Comm Channel response write"),
                        (DWORD)0);
                    fSts = GetOverlappedResult(
                                m_hPipe,
                                &m_ovrlp,
                                &dwLen,
                                TRUE);
                    dwSts = fSts ? ERROR_SUCCESS : GetLastError();
                    break;

                //
                // Success after a wait event.
                case ERROR_SUCCESS:
                    break;

                //
                // Some other error.
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Comm Channel could not write to pipe:  %1"),
                        dwSts);
                    goto ErrorExit;
                }
            } while (!fErrorProcessed);
        }
        cbLen -= dwLen;
    }

ErrorExit:
    return dwSts;
}


/*++

Receive:

    This method receives a given number of bytes from the communications
    channel.

Arguments:

    pvData receives the incoming bytes.
    cbLen supplies the length of the data expected.

Return Value:

    None

Throws:

    Transmission errors as a DWORD.

Author:

    Doug Barlow (dbarlow) 11/4/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComChannel::Receive")

void
CComChannel::Receive(
    LPVOID pvData,
    DWORD cbLen)
{
    BOOL fSts;
    DWORD dwLen, dwOffset = 0;

    while (0 < cbLen)
    {
        fSts = ReadFile(
                m_hPipe,
                &((LPBYTE)pvData)[dwOffset],
                cbLen,
                &dwLen,
                &m_ovrlp);
        if (!fSts)
        {
            BOOL fErrorProcessed;
            DWORD dwSts = GetLastError();
            DWORD dwWait;

            do
            {
                fErrorProcessed = TRUE;
                switch (dwSts)
                {
                //
                // Postpone processing
                case ERROR_IO_PENDING:
                    dwWait = WaitForAnyObject(
                                    INFINITE,
                                    m_ovrlp.hEvent,
                                    g_hCalaisShutdown,  // Make sure this is last
                                    NULL);
                    switch (dwWait)
                    {
                    case 1:
                        fErrorProcessed = FALSE;
                        fSts = GetOverlappedResult(
                                    m_hPipe,
                                    &m_ovrlp,
                                    &dwLen,
                                    TRUE);
                        dwSts = fSts ? ERROR_SUCCESS : GetLastError();
                        break;
                    case 2:
                        throw (DWORD)SCARD_P_SHUTDOWN;
                        break;
                    default:
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Wait for comm pipe receive returned invalid value"));
                        throw (DWORD)SCARD_F_INTERNAL_ERROR;
                    }
                    break;

                //
                // Success after a wait event.
                case ERROR_SUCCESS:
                    break;

                //
                // The client exited.
                case ERROR_BROKEN_PIPE:
                case ERROR_INVALID_HANDLE:
                    throw (DWORD)ERROR_BROKEN_PIPE;
                    break;

                //
                // Some other error.
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Comm Channel could not read from pipe:  %1"),
                        dwSts);
                    throw dwSts;
                }
            } while (!fErrorProcessed);
        }

        ASSERT(dwLen <= cbLen);
        cbLen -= dwLen;
        dwOffset += dwLen;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\comms\cominitr.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ComInitr

Abstract:

    This module implements the methods for the Communications Initiation Class.

Author:

    Doug Barlow (dbarlow) 10/30/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:



--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <limits.h>
#include <WinSCard.h>
#include <CalMsgs.h>
#include <CalCom.h>
#include <stdlib.h>
#include <aclapi.h>

HANDLE g_hCalaisShutdown = NULL;    // This is used by the Send and Receive
                                    // methods of the CComChannel.  It stays
                                    // NULL.

//
//==============================================================================
//
//  CComInitiator
//

/*++

Initiate:

    This method creates a communications channel object to the supplied target.

Arguments:

    szName supplies the full file name of the target with which to initiate a
        connection.

Return Value:

    None

Throws:

    DWORDs representing any error conditions encountered.

Author:

    Doug Barlow (dbarlow) 10/30/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComInitiator::Initiate")

CComChannel *
CComInitiator::Initiate(
    LPCTSTR szName,
    LPDWORD pdwVersion)
const
{
    LPCTSTR szPipeHdr = CalaisString(CALSTR_PIPEDEVICEHEADER);
    CComChannel *pChannel = NULL;
    CHandleObject hComPipe(DBGT("Comm Pipe Handle from CComInitiator::Initiate"));

    try
    {
        BOOL fSts;
        DWORD dwSts;
        DWORD cbPipeHeader = lstrlen(szPipeHdr) * sizeof(TCHAR);
        CBuffer bfPipeName;
        DWORD dwLen;
        HANDLE hStarted;
        DWORD nPipeNo;
        HKEY hCurrentKey;
        TCHAR szPipeNo[sizeof(nPipeNo)*2 + 1];    // Twice as many hex digits + zero
        DWORD cbData;
        DWORD ValueType;

        //
        // Build the pipe name.
        //

        dwLen = lstrlen(szName) * sizeof(TCHAR);
        bfPipeName.Presize(cbPipeHeader + dwLen + sizeof(szPipeNo));


        //
        // Build our Connect Request block.
        //

        CComChannel::CONNECT_REQMSG creq;
        CComChannel::CONNECT_RSPMSG crsp;

        hStarted = AccessStartedEvent();
        if ((NULL == hStarted) ||
            (WAIT_OBJECT_0 != WaitForSingleObject(hStarted, 0)))
        {
            throw (DWORD)SCARD_E_NO_SERVICE;
        }

        //
        // Open the Current key.
        //
        dwSts = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                        _T("SOFTWARE\\Microsoft\\Cryptography\\Calais\\Current"),
                       0,                       // options (ignored)
                       KEY_QUERY_VALUE,
                       &hCurrentKey
                       );
        if (ERROR_SUCCESS != dwSts)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Comm Initiator could not access the Current key:  %1"),
                dwSts);
            throw dwSts;
        }

        cbData = sizeof(nPipeNo);
        dwSts = RegQueryValueEx(
                    hCurrentKey,
                    NULL,                // Use key's unnamed value
                    0,
                    &ValueType,
                    (LPBYTE) &nPipeNo,
                    &cbData);

        RegCloseKey(hCurrentKey);

        if (dwSts != ERROR_SUCCESS || ValueType != REG_DWORD)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Comm Initiator failed to query the Current value:  %1"),
                dwSts);
            throw dwSts;
        }

        _itot(nPipeNo, szPipeNo, 16);

        bfPipeName.Set((LPCBYTE)szPipeHdr, cbPipeHeader);
        bfPipeName.Append((LPCBYTE)szName, dwLen);
        bfPipeName.Append((LPCBYTE)szPipeNo, sizeof(szPipeNo));

        {
            PSID pPipeOwnerSid;
            PSID pLocalServiceSid = NULL;
            PSECURITY_DESCRIPTOR pSD = NULL;
            SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

RetryGetInfo:
            dwSts = GetNamedSecurityInfo(
                (LPTSTR)(LPCTSTR)bfPipeName,
                SE_FILE_OBJECT,
                OWNER_SECURITY_INFORMATION,
                &pPipeOwnerSid,
                NULL,
                NULL,
                NULL,
                &pSD);
            if (ERROR_SUCCESS != dwSts)
            {
                if (ERROR_PIPE_BUSY == dwSts)
                {
                    fSts = WaitNamedPipe((LPCTSTR)bfPipeName, NMPWAIT_USE_DEFAULT_WAIT);
                    if (!fSts)
                    {
                        dwSts = GetLastError();
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Comm Initiator could not wait for a communication pipe:  %1"),
                            dwSts);
                        throw dwSts;
                    }
                    goto RetryGetInfo;
                }
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Comm Initiator could not get the security info:  %1"),
                    dwSts);
                throw dwSts;
            }

            if (!AllocateAndInitializeSid(
                &NtAuthority, 1, SECURITY_LOCAL_SERVICE_RID,
                0, 0, 0, 0, 0, 0, 0,
                &pLocalServiceSid))
            {
                dwSts = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Comm Initiator could not create SID:  %1"),
                    dwSts);
            }
            else
            {
                if (!EqualSid(pLocalServiceSid, pPipeOwnerSid))
                {
                    dwSts = GetLastError();
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Comm Initiator could not verify the owner of the pipe:  %1"),
                        dwSts);
                }

                FreeSid(pLocalServiceSid);
            }

            LocalFree(pSD);
            if (ERROR_SUCCESS != dwSts)
            {
                throw dwSts;
            }
        }

RetryCreate:
        hComPipe = CreateFile(
                        (LPCTSTR)bfPipeName,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (!hComPipe.IsValid())
        {
            dwSts = hComPipe.GetLastError();
            switch (dwSts)
            {

            //
            // The resource manager isn't started.
            case ERROR_FILE_NOT_FOUND:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Comm Initiator could not create communication pipe:  %1"),
                    dwSts);
                throw (DWORD)SCARD_E_NO_SERVICE;
                break;

            //
            // The pipe is busy.
            case ERROR_PIPE_BUSY:
                fSts = WaitNamedPipe((LPCTSTR)bfPipeName, NMPWAIT_USE_DEFAULT_WAIT);
                if (!fSts)
                {
                    dwSts = GetLastError();
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Comm Initiator could not wait for a communication pipe:  %1"),
                        dwSts);
                    throw dwSts;
                }
                goto RetryCreate;
                break;

            //
            // A hard error.
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Comm Initiator could not create communication pipe:  %1"),
                    dwSts);
                throw dwSts;
            }
        }

        creq.dwSync = 0;
        creq.dwVersion = *pdwVersion;


        //
        // Establish the communication.
        //

        pChannel = new CComChannel(hComPipe);
        if (NULL == pChannel)
        {
            dwSts = SCARD_E_NO_MEMORY;
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Com Initiator could not allocate a Comm Channel:  %1"),
                dwSts);
            throw dwSts;
        }
        hComPipe.Relinquish();
        pChannel->Send(&creq, sizeof(creq));
        pChannel->Receive(&crsp, sizeof(crsp));
        if (ERROR_SUCCESS != crsp.dwStatus)
            throw crsp.dwStatus;


        //
        // Check the response.
        // In future versions, we may have to negotiate a version.
        //

        if (crsp.dwVersion != *pdwVersion)
            throw (DWORD)SCARD_F_COMM_ERROR;
        *pdwVersion = crsp.dwVersion;
    }

    catch (...)
    {
        if (NULL != pChannel)
            delete pChannel;
        if (hComPipe.IsValid())
            hComPipe.Close();
        throw;
    }

    return pChannel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\comms\comobjs.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    comObjs

Abstract:

    This file provides the implementation for the communcation objects used in
    Calais.  A communications object (CComObject and it's derivatives) is
    capable of transmitting itself across a CComChannel.

Author:

    Doug Barlow (dbarlow) 11/6/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <WinSCard.h>
#include <CalMsgs.h>
#include <CalCom.h>

const DWORD
    CComObject::AUTOCOUNT = 0,              // Force computing string length.
    CComObject::MULTISTRING = (DWORD)(-1);  // Force computing multistring len.


//
//==============================================================================
//
//  CComObject and derivatives.
//

/*++

CComObject:

    This is the base constructor for a CComObject.  These objects assume that
    they are not in charge of anything past their own internal buffers.
    Therefore they won't close handles, etc, when destructing.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/13/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::CComObject")

CComObject::CComObject(
    void)
:   m_bfRequest(),
    m_bfResponse()
{
    m_pbfActive = NULL;
}


/*++

ReceiveComObject:

    This is a static member routine that creates the proper CComObject child
    object for the data coming in on a CComChannel.

Arguments:

    pChannel supplies a pointer to the CComChannel on which the transfer
        structure will come in.

Return Value:

    The newly created CComObject child object.  This object must be cleaned up
    via the delete command.

Throws:

    ?exceptions?

Author:

    Doug Barlow (dbarlow) 11/13/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::ReceiveComObject")

CComObject *
CComObject::ReceiveComObject(
    CComChannel *pChannel)
{
    CComObject *pCom = NULL;
    DWORD dwMinSize = (DWORD)(-1);

    try
    {
        DWORD rgdwInData[2];


        //
        // See what's coming.
        //

        pChannel->Receive(rgdwInData, sizeof(rgdwInData));
        if (sizeof(rgdwInData) > rgdwInData[1])
            throw (DWORD)SCARD_F_COMM_ERROR;

        switch (rgdwInData[0])  // dwCommndId
        {
        case EstablishContext_request:
            dwMinSize = sizeof(ComEstablishContext::CObjEstablishContext_request);
            pCom = new ComEstablishContext;
            break;
        case EstablishContext_response:
            dwMinSize = sizeof(ComEstablishContext::CObjEstablishContext_response);
            pCom = new ComEstablishContext;
            break;
        case ReleaseContext_request:
            dwMinSize = sizeof(ComReleaseContext::CObjReleaseContext_request);
            pCom = new ComReleaseContext;
            break;
        case ReleaseContext_response:
            dwMinSize = sizeof(ComReleaseContext::CObjReleaseContext_response);
            pCom = new ComReleaseContext;
            break;
        case IsValidContext_request:
            dwMinSize = sizeof(ComIsValidContext::CObjIsValidContext_request);
            pCom = new ComIsValidContext;
            break;
        case IsValidContext_response:
            dwMinSize = sizeof(ComIsValidContext::CObjIsValidContext_response);
            pCom = new ComIsValidContext;
            break;
        case ListReaders_request:
            dwMinSize = sizeof(ComListReaders::CObjListReaders_request);
            pCom = new ComListReaders;
            break;
        case ListReaders_response:
            dwMinSize = sizeof(ComListReaders::CObjListReaders_response);
            pCom = new ComListReaders;
            break;
#if 0
        case ListReaderGroups_request:
            dwMinSize = sizeof(ComListReaderGroups::CObjListReaderGroups_request);
            pCom = new ComListReaderGroups;
            break;
        case ListReaderGroups_response:
            dwMinSize = sizeof(ComListReaderGroups::CObjListReaderGroups_response);
            pCom = new ComListReaderGroups;
            break;
        case ListCards_request:
            dwMinSize = sizeof(ComListCards::CObjListCards_request);
            pCom = new ComListCards;
            break;
        case ListCards_response:
            dwMinSize = sizeof(ComListCards::CObjListCards_response);
            pCom = new ComListCards;
            break;
        case ListInterfaces_request:
            dwMinSize = sizeof(ComListInterfaces::CObjListInterfaces_request);
            pCom = new ComListInterfaces;
            break;
        case ListInterfaces_response:
            dwMinSize = sizeof(ComListInterfaces::CObjListInterfaces_response);
            pCom = new ComListInterfaces;
            break;
        case GetProviderId_request:
            dwMinSize = sizeof(ComGetProviderId::CObjGetProviderId_request);
            pCom = new ComGetProviderId;
            break;
        case GetProviderId_response:
            dwMinSize = sizeof(ComGetProviderId::CObjGetProviderId_response);
            pCom = new ComGetProviderId;
            break;
        case IntroduceReaderGroup_request:
            dwMinSize = sizeof(ComIntroduceReaderGroup::CObjIntroduceReaderGroup_request);
            pCom = new ComIntroduceReaderGroup;
            break;
        case IntroduceReaderGroup_response:
            dwMinSize = sizeof(ComIntroduceReaderGroup::CObjIntroduceReaderGroup_response);
            pCom = new ComIntroduceReaderGroup;
            break;
        case ForgetReaderGroup_request:
            dwMinSize = sizeof(ComForgetReaderGroup::CObjForgetReaderGroup_request);
            pCom = new ComForgetReaderGroup;
            break;
        case ForgetReaderGroup_response:
            dwMinSize = sizeof(ComForgetReaderGroup::CObjForgetReaderGroup_response);
            pCom = new ComForgetReaderGroup;
            break;
        case IntroduceReader_request:
            dwMinSize = sizeof(ComIntroduceReader::CObjIntroduceReader_request);
            pCom = new ComIntroduceReader;
            break;
        case IntroduceReader_response:
            dwMinSize = sizeof(ComIntroduceReader::CObjIntroduceReader_response);
            pCom = new ComIntroduceReader;
            break;
        case ForgetReader_request:
            dwMinSize = sizeof(ComForgetReader::CObjForgetReader_request);
            pCom = new ComForgetReader;
            break;
        case ForgetReader_response:
            dwMinSize = sizeof(ComForgetReader::CObjForgetReader_response);
            pCom = new ComForgetReader;
            break;
        case AddReaderToGroup_request:
            dwMinSize = sizeof(ComAddReaderToGroup::CObjAddReaderToGroup_request);
            pCom = new ComAddReaderToGroup;
            break;
        case AddReaderToGroup_response:
            dwMinSize = sizeof(ComAddReaderToGroup::CObjAddReaderToGroup_response);
            pCom = new ComAddReaderToGroup;
            break;
        case RemoveReaderFromGroup_request:
            dwMinSize = sizeof(ComRemoveReaderFromGroup::CObjRemoveReaderFromGroup_request);
            pCom = new ComRemoveReaderFromGroup;
            break;
        case RemoveReaderFromGroup_response:
            dwMinSize = sizeof(ComRemoveReaderFromGroup::CObjRemoveReaderFromGroup_response);
            pCom = new ComRemoveReaderFromGroup;
            break;
        case IntroduceCardType_request:
            dwMinSize = sizeof(ComIntroduceCardType::CObjIntroduceCardType_request);
            pCom = new ComIntroduceCardType;
            break;
        case IntroduceCardType_response:
            dwMinSize = sizeof(ComIntroduceCardType::CObjIntroduceCardType_response);
            pCom = new ComIntroduceCardType;
            break;
        case ForgetCardType_request:
            dwMinSize = sizeof(ComForgetCardType::CObjForgetCardType_request);
            pCom = new ComForgetCardType;
            break;
        case ForgetCardType_response:
            dwMinSize = sizeof(ComForgetCardType::CObjForgetCardType_response);
            pCom = new ComForgetCardType;
            break;
        case FreeMemory_request:
            dwMinSize = sizeof(ComFreeMemory::CObjFreeMemory_request);
            pCom = new ComFreeMemory;
            break;
        case FreeMemory_response:
            dwMinSize = sizeof(ComFreeMemory::CObjFreeMemory_response);
            pCom = new ComFreeMemory;
            break;
        case Cancel_request:
            dwMinSize = sizeof(ComCancel::CObjCancel_request);
            pCom = new ComCancel;
            break;
        case Cancel_response:
            dwMinSize = sizeof(ComCancel::CObjCancel_response);
            pCom = new ComCancel;
            break;
#endif
        case LocateCards_request:
            dwMinSize = sizeof(ComLocateCards::CObjLocateCards_request);
            pCom = new ComLocateCards;
            break;
        case LocateCards_response:
            dwMinSize = sizeof(ComLocateCards::CObjLocateCards_response);
            pCom = new ComLocateCards;
            break;
        case GetStatusChange_request:
            dwMinSize = sizeof(ComGetStatusChange::CObjGetStatusChange_request);
            pCom = new ComGetStatusChange;
            break;
        case GetStatusChange_response:
            dwMinSize = sizeof(ComGetStatusChange::CObjGetStatusChange_response);
            pCom = new ComGetStatusChange;
            break;
        case Connect_request:
            dwMinSize = sizeof(ComConnect::CObjConnect_request);
            pCom = new ComConnect;
            break;
        case Connect_response:
            dwMinSize = sizeof(ComConnect::CObjConnect_response);
            pCom = new ComConnect;
            break;
        case Reconnect_request:
            dwMinSize = sizeof(ComReconnect::CObjReconnect_request);
            pCom = new ComReconnect;
            break;
        case Reconnect_response:
            dwMinSize = sizeof(ComReconnect::CObjReconnect_response);
            pCom = new ComReconnect;
            break;
        case Disconnect_request:
            dwMinSize = sizeof(ComDisconnect::CObjDisconnect_request);
            pCom = new ComDisconnect;
            break;
        case Disconnect_response:
            dwMinSize = sizeof(ComDisconnect::CObjDisconnect_response);
            pCom = new ComDisconnect;
            break;
        case BeginTransaction_request:
            dwMinSize = sizeof(ComBeginTransaction::CObjBeginTransaction_request);
            pCom = new ComBeginTransaction;
            break;
        case BeginTransaction_response:
            dwMinSize = sizeof(ComBeginTransaction::CObjBeginTransaction_response);
            pCom = new ComBeginTransaction;
            break;
        case EndTransaction_request:
            dwMinSize = sizeof(ComEndTransaction::CObjEndTransaction_request);
            pCom = new ComEndTransaction;
            break;
        case EndTransaction_response:
            dwMinSize = sizeof(ComEndTransaction::CObjEndTransaction_response);
            pCom = new ComEndTransaction;
            break;
        case Status_request:
            dwMinSize = sizeof(ComStatus::CObjStatus_request);
            pCom = new ComStatus;
            break;
        case Status_response:
            dwMinSize = sizeof(ComStatus::CObjStatus_response);
            pCom = new ComStatus;
            break;
        case Transmit_request:
            dwMinSize = sizeof(ComTransmit::CObjTransmit_request);
            pCom = new ComTransmit;
            break;
        case Transmit_response:
            dwMinSize = sizeof(ComTransmit::CObjTransmit_response);
            pCom = new ComTransmit;
            break;
        case OpenReader_request:
            dwMinSize = sizeof(ComOpenReader::CObjOpenReader_request);
            pCom = new ComOpenReader;
            break;
        case OpenReader_response:
            dwMinSize = sizeof(ComOpenReader::CObjOpenReader_response);
            pCom = new ComOpenReader;
            break;
        case Control_request:
            dwMinSize = sizeof(ComControl::CObjControl_request);
            pCom = new ComControl;
            break;
        case Control_response:
            dwMinSize = sizeof(ComControl::CObjControl_response);
            pCom = new ComControl;
            break;
        case GetAttrib_request:
            dwMinSize = sizeof(ComGetAttrib::CObjGetAttrib_request);
            pCom = new ComGetAttrib;
            break;
        case GetAttrib_response:
            dwMinSize = sizeof(ComGetAttrib::CObjGetAttrib_response);
            pCom = new ComGetAttrib;
            break;
        case SetAttrib_request:
            dwMinSize = sizeof(ComSetAttrib::CObjSetAttrib_request);
            pCom = new ComSetAttrib;
            break;
        case SetAttrib_response:
            dwMinSize = sizeof(ComSetAttrib::CObjSetAttrib_response);
            pCom = new ComSetAttrib;
            break;
        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Invalid Comm Object Id on pipe"));
            throw (DWORD)SCARD_F_COMM_ERROR;
        }

        if (NULL == pCom)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("No memory for incoming comm object"));
            throw (DWORD)SCARD_E_NO_MEMORY;
        }
        if (dwMinSize > rgdwInData[1])
            throw (DWORD)SCARD_F_COMM_ERROR;
        if (0 == (rgdwInData[0] & 0x01))    // Request or response?
            pCom->m_pbfActive = &pCom->m_bfRequest;
        else
            pCom->m_pbfActive = &pCom->m_bfResponse;


        //
        // Pull it in.
        //

        pCom->m_pbfActive->Resize(rgdwInData[1]);
        CopyMemory(
            pCom->m_pbfActive->Access(),
            rgdwInData,
            sizeof(rgdwInData));
        pChannel->Receive(
            pCom->m_pbfActive->Access(sizeof(rgdwInData)),
            rgdwInData[1] - sizeof(rgdwInData));
#ifdef DBG
        WriteApiLog(pCom->m_pbfActive->Access(), pCom->m_pbfActive->Length());
        for (DWORD ix = 0; ix < rgdwInData[1] / sizeof(DWORD); ix += 1)
        {
            ASSERT(0xcdcdcdcd != *(LPDWORD)pCom->m_pbfActive->Access(
                                                    ix * sizeof(DWORD)));
        }
#endif
    }

    catch (...)
    {
        if (NULL != pCom)
            delete pCom;
        throw;
    }

    return pCom;
}


/*++

Receive:

    This function receives a specific com object.

Arguments:

    pChannel supplies a pointer to the CComChannel on which the transfer
        structure will come in.

Return Value:

    None

Throws:

    ?exceptions?

Author:

    Doug Barlow (dbarlow) 11/18/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::Receive")

CComObject::CObjGeneric_response *
CComObject::Receive(
    CComChannel *pChannel)
{
    DWORD rgdwInData[2];
    CComObject::CObjGeneric_response *pRsp
        = (CComObject::CObjGeneric_response *)Data();

    pChannel->Receive(rgdwInData, sizeof(rgdwInData));
    if (rgdwInData[0] != pRsp->dwCommandId)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Comm Object receive object mismatch"));
        throw (DWORD)SCARD_F_COMM_ERROR;
    }
    if (rgdwInData[1] < sizeof(CComObject::CObjGeneric_response))
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Comm Object receive object invalid"));
        throw (DWORD)SCARD_F_COMM_ERROR;
    }
    ASSERT(m_pbfActive == ((0 == (rgdwInData[0] & 0x01)
                            ? &m_bfRequest
                            : &m_bfResponse)));


    //
    // Pull it in.
    //

    m_pbfActive->Resize(rgdwInData[1]);
    CopyMemory(
        m_pbfActive->Access(),
        rgdwInData,
        sizeof(rgdwInData));
    pChannel->Receive(
        m_pbfActive->Access(sizeof(rgdwInData)),
        rgdwInData[1] - sizeof(rgdwInData));
#ifdef DBG
    for (DWORD ix = 0; ix < rgdwInData[1] / sizeof(DWORD); ix += 1)
    {
        ASSERT(0xcdcdcdcd != *(LPDWORD)m_pbfActive->Access(ix * sizeof(DWORD)));
    }
    WriteApiLog(m_pbfActive->Access(), m_pbfActive->Length());
#endif
    return (CComObject::CObjGeneric_response *)m_pbfActive->Access();
}


/*++

Send:

    This function sends the ComObject over the given Comm Channel.

Arguments:

    pChannel supplies a pointer to the CComChannel on which the transfer
        structure will be sent.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:



Author:

    Doug Barlow (dbarlow) 8/5/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::Send")

DWORD
CComObject::Send(
    CComChannel *pChannel)
{
#ifdef DBG
    ComObjCheck;
    WriteApiLog(Data(), Length());
#endif
    return pChannel->Send(Data(), Length());
}


/*++

InitStruct:

    This method implements simple base class preparation to build request and
    response structures.

Arguments:

    dwCommandId supplies the command identifier.
    dwDataOffset supplies the size of the structure to be inserted.

Return Value:

    None

Throws:

    ?exceptions?

Author:

    Doug Barlow (dbarlow) 11/13/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::InitStruct")

void
CComObject::InitStruct(
    DWORD dwCommandId,
    DWORD dwDataOffset,
    DWORD dwExtra)
{
    if (0 == (dwCommandId & 0x01))
        m_pbfActive = &m_bfRequest;
    else
        m_pbfActive = &m_bfResponse;
    ASSERT(NULL != m_pbfActive);
    ASSERT(0 == dwDataOffset % sizeof(DWORD));
    CObjGeneric_request *pReq =
        (CObjGeneric_request *)m_pbfActive->Presize(dwDataOffset + dwExtra);
    m_pbfActive->Resize(dwDataOffset, TRUE);
    pReq->dwCommandId = dwCommandId;
    pReq->dwTotalLength = dwDataOffset;
    pReq->dwDataOffset = dwDataOffset;
}


/*++

Append:

    These methods append data to the transfer structure, updating the Total
    Length.  Note that this action may affect the address of the structure being
    appended to.  This routine returns the address of that structure, in case it
    changes.

Arguments:

    dsc supplies the descriptor to fill in with the offset and length.

    szString supplies the data to be appended as a string value.

    cchLen supplies the length of the data to be appended in characters, or one
        of the following special flags:

        AUTOCOUNT - The string's size should be determined via lstrlen.

        MULTISTRING - The string's size should be determined via mstrlen;

Return Value:

    The address of the updated structure, which may have moved in memory.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/13/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::Append")

LPBYTE
CComObject::Append(
    CComObject::Desc &dsc,
    LPCTSTR szString,
    DWORD cchLen)
{
    DWORD dwLen;
    switch (cchLen)
    {
    case AUTOCOUNT:
        dwLen = lstrlen(szString) + 1;  // Include trailing null char.
        break;
    case MULTISTRING:
        dwLen = MStrLen(szString);      // It includes trailing null char.
        break;
    default:
        dwLen = cchLen;
    }
    dwLen *= sizeof(TCHAR);
    return Append(dsc, (LPCBYTE)szString, dwLen);
}

LPBYTE
CComObject::Append(
    CComObject::Desc &dsc,
    LPCBYTE pbData,
    DWORD cbLength)
{
    static const DWORD dwZero = 0;
    DWORD
        dwDataLength,
        dwPadLen;
    CObjGeneric_request *pData;

    ComObjCheck;

    dwPadLen = sizeof(DWORD) - cbLength % sizeof(DWORD);
    if (sizeof(DWORD) == dwPadLen)
        dwPadLen = 0;
    dwDataLength = m_pbfActive->Length() + cbLength + dwPadLen;
    dsc.dwOffset = m_pbfActive->Length();
    dsc.dwLength = cbLength;

    // Now we might change the address of dsc.
    m_pbfActive->Presize(dwDataLength, TRUE);
    m_pbfActive->Append(pbData, cbLength);
    m_pbfActive->Append((LPCBYTE)&dwZero, dwPadLen);
    pData = (CObjGeneric_request *)m_pbfActive->Access();
    pData->dwTotalLength = dwDataLength;
    return m_pbfActive->Access();
}


/*++

Parse:

    This routine converts a given descriptor in the current communications
    object buffer back into a pointer and optional length.

Arguments:

    dsc supplies the descriptor of the current communications object to be
        parsed.
    pcbLen receives the length, in bytes, of the value referenced by the
        descriptor.  If this parameter is NULL, no length value is returned.

Return Value:

    The address of the value referenced by the descriptor.

Throws:

    ?exceptions?

Author:

    Doug Barlow (dbarlow) 12/11/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::Parse")

LPCVOID
CComObject::Parse(
    Desc &dsc,
    LPDWORD pcbLen)
{
    CObjGeneric_request *pGen;

    ComObjCheck;
    pGen = (CObjGeneric_request *)m_pbfActive->Access();

    ASSERT((LPCVOID)&dsc > (LPCVOID)m_pbfActive->Access());
    ASSERT((LPCVOID)&dsc
           < (LPCVOID)m_pbfActive->Access(m_pbfActive->Length() - 1));
    ASSERT((LPCVOID)&dsc
           < (LPCVOID)m_pbfActive->Access(pGen->dwDataOffset - 1));

    if (dsc.dwOffset + dsc.dwLength > m_pbfActive->Length())
        throw (DWORD)SCARD_F_COMM_ERROR;
    if (NULL != pcbLen)
        *pcbLen = dsc.dwLength;
    return m_pbfActive->Access(dsc.dwOffset);
}


#ifdef DBG
/*++

dbgCheck:

    This routine validates the internal structure of a CComObject.

Arguments:

    None

Return Value:

    None

Throws:

    None, but it will assert if something is wrong.

Author:

    Doug Barlow (dbarlow) 12/11/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComObject::dbgCheck")

void
CComObject::dbgCheck(
    void)
const
{
    DWORD
        dwCommandId,
        dwDataLength,
        dwDataOffset;
    CObjGeneric_request *pData;

    ASSERT(EstablishContext_request == 0);
    ASSERT(NULL != m_pbfActive);
    ASSERT(3 * sizeof(DWORD) <= m_pbfActive->Length());
    pData = (CObjGeneric_request *)m_pbfActive->Access();
    dwCommandId = pData->dwCommandId;
    dwDataLength = pData->dwTotalLength;
    dwDataOffset = pData->dwDataOffset;
    ASSERT(dwDataLength == m_pbfActive->Length());
    ASSERT(dwDataOffset <= dwDataLength);
    ASSERT(0 == dwDataOffset % sizeof(DWORD));
    ASSERT(0 == dwDataLength % sizeof(DWORD));
    ASSERT(m_pbfActive
            == ((0 == (dwCommandId & 0x01))
                ? &m_bfRequest
                : &m_bfResponse));
}

typedef struct
{
    SYSTEMTIME stLogTime;
    DWORD dwProcId;
    DWORD dwThreadId;
} LogStamp;

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("WriteApiLog")
void
WriteApiLog(
    LPCVOID pvData,
    DWORD cbLength)
{
    static HANDLE hLogMutex = NULL;
    BOOL fGotMutex = FALSE;
    HANDLE hLogFile = INVALID_HANDLE_VALUE;

    try
    {
        hLogFile = CreateFile(
                        CalaisString(CALSTR_APITRACEFILENAME),
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
        if (INVALID_HANDLE_VALUE != hLogFile)
        {
            LogStamp stamp;
            DWORD dwLen;
            DWORD dwSts;
            BOOL fSts;

            if (NULL == hLogMutex)
            {
                CSecurityDescriptor acl;

                acl.Initialize();
                acl.Allow(
                    &acl.SID_World,
                    SEMAPHORE_ALL_ACCESS);
                hLogMutex = CreateMutex(
                                acl,
                                FALSE,
                                TEXT("Microsoft Smart Card Logging synchronization"));
            }

            dwSts = WaitForAnObject(hLogMutex, 1000);  // One second max.
            if (ERROR_SUCCESS == dwSts)
            {
                fGotMutex = TRUE;
                dwLen = SetFilePointer(hLogFile, 0, NULL, FILE_END);
                ASSERT(-1 != dwLen);
                GetLocalTime(&stamp.stLogTime);
                stamp.dwProcId = GetCurrentProcessId();
                stamp.dwThreadId = GetCurrentThreadId();
                fSts = WriteFile(
                    hLogFile,
                    &stamp,
                    sizeof(stamp),
                    &dwLen,
                    NULL);
                ASSERT(fSts);
                fSts = WriteFile(
                    hLogFile,
                    pvData,
                    cbLength,
                    &dwLen,
                    NULL);
                ASSERT(fSts);
                ASSERT(dwLen == cbLength);
            }
        }
    }
    catch (...) {}

    if (fGotMutex)
        ReleaseMutex(hLogMutex);
    if (INVALID_HANDLE_VALUE != hLogFile)
        CloseHandle(hLogFile);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\comms\calmsgs.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    CalMsgs

Abstract:

    This module provides Message logging services.

Author:

    Doug Barlow (dbarlow) 5/29/1997

Environment:

    Win32, C++

Notes:

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <tchar.h>
#include <WinSCard.h>
#include <CalMsgs.h>
#include <CalaisLb.h>
#include <CalCom.h>
#include <scarderr.h>
#ifdef DBG
#include <stdio.h>
#include <stdarg.h>
#endif

#ifndef FACILITY_SCARD
#define FACILITY_SCARD 16
#endif
// #define ErrorCode(x) (0xc0000000 | (FACILITY_SCARD << 16) + (x))
// #define WarnCode(x)  (0x80000000 | (FACILITY_SCARD << 16) + (x))
// #define InfoCode(x)  (0x40000000 | (FACILITY_SCARD << 16) + (x))
// #define SuccessCode(x)            ((FACILITY_SCARD << 16) + (x))

#if defined(_DEBUG)
BOOL g_fDebug        = FALSE;
BOOL g_fGuiWarnings  = TRUE;
WORD g_wGuiSeverity  = EVENTLOG_WARNING_TYPE | EVENTLOG_ERROR_TYPE;
WORD g_wLogSeverity  = 0x03;
#ifndef DBG
#define DBG
#endif
#elif defined(DBG)
BOOL g_fDebug        = FALSE;
BOOL g_fGuiWarnings  = FALSE;
WORD g_wGuiSeverity  = EVENTLOG_ERROR_TYPE;
WORD g_wLogSeverity  = EVENTLOG_WARNING_TYPE | EVENTLOG_ERROR_TYPE;
#else
WORD g_wLogSeverity  = EVENTLOG_ERROR_TYPE;
#endif
static LPCTSTR l_szServiceName = TEXT("SCard Client");
static HANDLE l_hEventLogger = NULL;
static BOOL l_fServer = FALSE;
static const TCHAR l_szDefaultMessage[] = TEXT("SCARDSVR!CalaisMessageLog error logging is broken: %1");


//
// Common global strings.
//

const LPCTSTR g_rgszDefaultStrings[]
    = {
    /* CALSTR_CALAISEXECUTABLE          */  TEXT("%windir%\\system32\\SCardSvr.exe"),
    /* CALSTR_PRIMARYSERVICE            */  TEXT("SCardSvr"),
    /* CALSTR_LEGACYSERVICE             */  TEXT("SCardDrv"),
    /* CALSTR_CALAISREGISTRYKEY         */  TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais"),
    /* CALSTR_READERREGISTRYKEY         */  TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\Readers"),
    /* CALSTR_SMARTCARDREGISTRYKEY      */  TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCards"),
    /* CALSTR_READERREGISTRYSUBKEY      */  TEXT("Readers"),
    /* CALSTR_DEVICEREGISTRYSUBKEY      */  TEXT("Device"),
    /* CALSTR_GROUPSREGISTRYSUBKEY      */  TEXT("Groups"),
    /* CALSTR_ATRREGISTRYSUBKEY         */  TEXT("ATR"),
    /* CALSTR_ATRMASKREGISTRYSUBKEY     */  TEXT("ATRMask"),
    /* CALSTR_INTERFACESREGISTRYSUBKEY  */  TEXT("Supported Interfaces"),
    /* CALSTR_PRIMARYPROVIDERSUBKEY     */  TEXT("Primary Provider"),
    /* CALSTR_CRYPTOPROVIDERSUBKEY      */  TEXT("Crypto Provider"),
    /* CALSTR_SERVICESREGISTRYKEY       */  TEXT("SYSTEM\\CurrentControlSet\\Services"),
    /* CALSTR_EVENTLOGREGISTRYKEY       */  TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog"),
    /* CALSTR_SYSTEMREGISTRYSUBKEY      */  TEXT("System"),
    /* CALSTR_EVENTMESSAGEFILESUBKEY    */  TEXT("EventMessageFile"),
    /* CALSTR_TYPESSUPPORTEDSUBKEY      */  TEXT("TypesSupported"),
    /* CALSTR_PNPDEVICEREGISTRYKEY      */  TEXT("SYSTEM\\CurrentControlSet\\Control\\DeviceClasses\\{50dd5230-ba8a-11d1-bf5d-0000f805f530}"),
    /* CALSTR_SYMBOLICLINKSUBKEY        */  TEXT("SymbolicLink"),
    /* CALSTR_VXDPATHREGISTRYKEY        */  TEXT("System\\CurrentControlSet\\Services\\VxD\\Smclib\\Devices"),
    /* CALSTR_LEGACYDEPENDONGROUP       */  TEXT("+Smart Card Reader"),
    /* CALSTR_NEWREADEREVENTNAME        */  TEXT("Global\\Microsoft Smart Card Resource Manager New Reader"),
    /* CALSTR_STARTEDEVENTNAME          */  TEXT("Global\\Microsoft Smart Card Resource Manager Started"),
    /* CALSTR_CANCELEVENTPREFIX         */  TEXT("Global\\Microsoft Smart Card Cancel Event for %1!d!"),
    /* CALSTR_COMMPIPENAME              */  TEXT("Microsoft Smart Card Resource Manager"),
    /* CALSTR_LEGACYDEVICEHEADER        */  TEXT("\\\\.\\"),
    /* CALSTR_LEGACYDEVICENAME          */  TEXT("SCReader"),
    /* CALSTR_MAXLEGACYDEVICES          */  TEXT("MaxLegacyDevices"),
    /* CALSTR_MAXDEFAULTBUFFER          */  TEXT("MaxDefaultBuffer"),
    /* CALSTR_PIPEDEVICEHEADER          */  TEXT("\\\\.\\pipe\\"),
    /* CALSTR_SERVICEDEPENDENCIES       */  TEXT("PlugPlay\000"),
    /* CALSTR_SPECIALREADERHEADER       */  TEXT("\\\\?PNP?\\"),
    /* CALSTR_ACTIVEREADERCOUNTREADER   */  TEXT("NOTIFICATION"),
    /* CALSTR_CERTPROPREGISTRY          */  TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify"),
    /* CALSTR_CERTPROPKEY               */  TEXT("ScCertProp"),
    /* CALSTR_DLLNAME                   */  TEXT("DLLName"),
    /* CALSTR_LOGON                     */  TEXT("Logon"),
    /* CALSTR_LOGOFF                    */  TEXT("Logoff"),
    /* CALSTR_LOCK                      */  TEXT("Lock"),
    /* CALSTR_UNLOCK                    */  TEXT("Unlock"),
    /* CALSTR_ENABLED                   */  TEXT("Enabled"),
    /* CALSTR_IMPERSONATE               */  TEXT("Impersonate"),
    /* CALSTR_ASYNCHRONOUS              */  TEXT("Asynchronous"),
    /* CALSTR_CERTPROPDLL               */  TEXT("WlNotify.dll"),
    /* CALSTR_CERTPROPSTART             */  TEXT("SCardStartCertProp"),
    /* CALSTR_CERTPROPSTOP              */  TEXT("SCardStopCertProp"),
    /* CALSTR_CERTPROPSUSPEND           */  TEXT("SCardSuspendCertProp"),
    /* CALSTR_CERTPROPRESUME            */  TEXT("SCardResumeCertProp"),
    /* CALSTR_SMARTCARDINSERTION        */  TEXT("SmartcardInsertion"),
    /* CALSTR_SMARTCARDREMOVAL          */  TEXT("SmartcardRemoval"),
    /* CALSTR_APPEVENTS                 */  TEXT("AppEvents"),
    /* CALSTR_EVENTLABELS               */  TEXT("EventLabels"),
    /* CALSTR_DOT_DEFAULT               */  TEXT(".Default"),
    /* CALSTR_DOT_CURRENT               */  TEXT(".Current"),
    /* CALSTR_SOUNDSREGISTRY            */  TEXT("Schemes\\Apps\\.Default"),
    /* CALSTR_LOGONREGISTRY             */  TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
    /* CALSTR_LOGONREMOVEOPTION         */  TEXT("ScRemoveOption"),
    /* CALSTR_STOPPEDEVENTNAME          */  TEXT("Global\\Microsoft Smart Card Resource Manager Stopped"),

// Unused
//  /* CALSTR_TEMPLATEREGISTRYKEY       */  TEXT("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCard Templates"),
//  /* CALSTR_OEMCONFIGREGISTRYSUBKEY   */  TEXT("OEM Configuration"),

// Debug only
    /* CALSTR_DEBUGSERVICE              */  TEXT("SCardDbg"),
    /* CALSTR_DEBUGREGISTRYSUBKEY       */  TEXT("Debug"),
    
#ifdef DBG
    /* CALSTR_DEBUGLOGSUBKEY            */  TEXT("Debug"),
    /* CALSTR_GUIWARNINGSUBKEY          */  TEXT("GuiWarnings"),
    /* CALSTR_LOGSEVERITYSUBKEY         */  TEXT("LogSeverity"),
    /* CALSTR_GUISEVERITYSUBKEY         */  TEXT("GuiSeverity"),
    /* CALSTR_APITRACEFILENAME          */  TEXT("C:\\SCard.log"),
    /* CALSTR_DRIVERTRACEFILENAME       */  TEXT("C:\\Calais.log"),
    /* CALSTR_MESSAGETAG                */  TEXT(" *MESSAGE* "),
    /* CALSTR_INFOMESSAGETAG            */  TEXT(" *INFO* "),
    /* CALSTR_WARNINGMESSAGETAG         */  TEXT(" *WARNING* "),
    /* CALSTR_ERRORMESSAGETAG           */  TEXT(" *ERROR* "),
    /* CALSTR_DEBUGSERVICEDISPLAY       */  TEXT("Smart Card Debug"),
    /* CALSTR_DEBUGSERVICEDESC          */  TEXT("Start this service first to debug Smart card service startup"),
#endif
    NULL };


/*++

CalaisMessageLog:

    This function and it's derivatives provide convienent error logging
    capabilities.  On NT, errors are logged to the Event Log file.  Otherwise,
    the errors are placed in a message box for the user.

Arguments:

    wSeverity - Supplies the severity of the event.  Possible values are:

        EVENTLOG_SUCCESS - A success event is to be logged.
        EVENTLOG_ERROR_TYPE - An Error event is to be logged.
        EVENTLOG_WARNING_TYPE - A Warning event is to be logged.
        EVENTLOG_INFORMATION_TYPE - An Informational event is to be logged.

    dwMessageId - Message Id from the resource file.

    szMessageStr - Message, supplied as a string.

    cbBinaryData - Size, in bytes, of any binary data to include with the log.

    pvBinaryData - Pointer to binary data to include with the log, or NULL.

    rgszParams - An array of pointers to strings to be included as parameters.
        The last pointer must be NULL.

    szParam<n> - A string parameter to include with the message

    dwParam<n> - A DWORD value to include with the message.


Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 5/9/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisMessageLog")

void
CalaisMessageLog(
    DEBUG_TEXT szSubroutine,
    WORD wSeverity,
    DWORD dwMessageId,
    LPCTSTR *rgszParams,
    LPCVOID pvBinaryData,
    DWORD cbBinaryData)
{
    LPTSTR szMessage = (LPTSTR)l_szDefaultMessage;
    DWORD cchMessage, dwLen;
    LCID SaveLCID;
    BOOL fSts;

    if (0 != (wSeverity & g_wLogSeverity))
    {
        WORD cszParams = 0;

        if (NULL != rgszParams)
        {
            while (NULL != rgszParams[cszParams])
                cszParams += 1;
        }

        if (EVENTLOG_INFORMATION_TYPE > wSeverity)
        {
            if (l_fServer && (NULL == l_hEventLogger))
            {
                l_hEventLogger = RegisterEventSource(
                                        NULL,
                                        CalaisString(CALSTR_PRIMARYSERVICE));

            }
            if (NULL != l_hEventLogger)
            {
                fSts = ReportEvent(
                            l_hEventLogger,
                            wSeverity,
                            0,
                            dwMessageId,
                            NULL,
                            cszParams,
                            cbBinaryData,
                            rgszParams,
                            (LPVOID)pvBinaryData);
            }
        }

#ifdef DBG
        // Don't pass specific lang id to FormatMessage, as it fails if there's
        // no msg in that language.  Instead, set the thread locale, which will
        // get FormatMessage to use a search algorithm to find a message of the
        // appropriate language, or use a reasonable fallback msg if there's
        // none.

        SaveLCID = GetThreadLocale();
        SetThreadLocale(LOCALE_SYSTEM_DEFAULT);

        cchMessage = FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        GetModuleHandle(TEXT("winscard.dll")),  // NULL on server
                        dwMessageId,
                        0,
                        (LPTSTR)&szMessage,
                        0,
                        (va_list *)rgszParams);
        SetThreadLocale(SaveLCID);
        dwLen = lstrlen(szMessage);
        if (0 < dwLen)
        {
            dwLen -= 1;
            while (!_istgraph(szMessage[dwLen]))
            {
                szMessage[dwLen] = 0;
                if (0 == dwLen)
                    break;
                dwLen -= 1;
            }
        }

        {
            CTextString tzOutMessage;

            tzOutMessage = l_szServiceName;
            tzOutMessage += TEXT("!");
            tzOutMessage += szSubroutine;
            if (0 != (EVENTLOG_ERROR_TYPE & wSeverity))
                tzOutMessage += CalaisString(CALSTR_ERRORMESSAGETAG);
            else if (0 != (EVENTLOG_WARNING_TYPE & wSeverity))
                tzOutMessage += CalaisString(CALSTR_WARNINGMESSAGETAG);
            else if (0 != (EVENTLOG_INFORMATION_TYPE & wSeverity))
                tzOutMessage += CalaisString(CALSTR_INFOMESSAGETAG);
            else
                tzOutMessage += CalaisString(CALSTR_MESSAGETAG);
            if ((0 == cchMessage) || (NULL == szMessage))
                tzOutMessage += CErrorString(GetLastError());
            else
                tzOutMessage += szMessage;
            tzOutMessage += TEXT("\n");
#ifdef _DEBUG
            _putts(tzOutMessage);
#else
            OutputDebugString(tzOutMessage);
#endif
        }
        if ((g_fGuiWarnings) && (0 != (g_wGuiSeverity & wSeverity)))
        {
            int nAction;
            DWORD dwIcon;

            if (0 != (EVENTLOG_ERROR_TYPE & wSeverity))
                dwIcon = MB_ICONERROR;
            else if (0 != (EVENTLOG_WARNING_TYPE & wSeverity))
                dwIcon = MB_ICONWARNING;
            else if (0 != (EVENTLOG_INFORMATION_TYPE & wSeverity))
                dwIcon = MB_ICONINFORMATION;
            else
                dwIcon = 0;
            if ((0 == cchMessage) || (NULL == szMessage))
            {
                nAction = MessageBox(
                                NULL,
                                CErrorString(GetLastError()),
                                l_szDefaultMessage,
                                MB_SYSTEMMODAL
                                | MB_OKCANCEL
                                | dwIcon);
            }
            else
            {
                nAction = MessageBox(
                                NULL,
                                szMessage,
                                l_szServiceName,
                                MB_SYSTEMMODAL
                                | MB_OKCANCEL
                                | dwIcon);
            }
            if (IDCANCEL == nAction)
            {
                breakpoint;
            }
        }
        if ((NULL != szMessage) && (l_szDefaultMessage != szMessage))
            LocalFree((LPVOID)szMessage);
#endif

    }
}

#ifdef DBG
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisMessageLog")

void
CalaisMessageLog(
    DEBUG_TEXT szSubroutine,
    WORD wSeverity,
    LPCTSTR szMessageStr,
    LPCTSTR *rgszParams,
    LPCVOID pvBinaryData,
    DWORD cbBinaryData)
{
    if (0 != (wSeverity & g_wLogSeverity))
    {
        LPCTSTR szMessage = l_szDefaultMessage;
        DWORD cchMessage;
        LPCTSTR szArgs[2];

        cchMessage = FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_STRING
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        szMessageStr,
                        0,
                        0,
                        (LPTSTR)&szMessage,
                        0,
                        (va_list *)rgszParams);
        szArgs[0] = szMessage;
        szArgs[1] = NULL;
        CalaisMessageLog(
            szSubroutine,
            wSeverity,
            1,  // "%1"
            szArgs,
            pvBinaryData,
            cbBinaryData);
        if ((NULL != szMessage) && (l_szDefaultMessage != szMessage))
            LocalFree((LPVOID)szMessage);
    }
}


/*++
CalaisError:
CalaisWarning:
CalaisInfo:

    The following routines supply convienent access to the error logging
    services, above.

Arguments:

    dwMessageId - Supplies a message Id code to use to obtain the message from
        the current image's message resource.

    szMessage - Supplies the message as a string.

    dwErrorCode - Supples an error code to be converted into a string as the
        parameter %1.

    szParam<n> - Supplies an optional parameter for the message as %<n>.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 5/29/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisInfo")

void
CalaisInfo(
    DEBUG_TEXT szSubroutine,
    LPCTSTR szMessage,
    LPCTSTR szParam1,
    LPCTSTR szParam2,
    LPCTSTR szParam3)
{
    LPCTSTR rgszParams[4];

    rgszParams[0] = szParam1;
    rgszParams[1] = szParam2;
    rgszParams[2] = szParam3;
    rgszParams[3] = NULL;
    CalaisMessageLog(
        szSubroutine,
        EVENTLOG_INFORMATION_TYPE,
        szMessage,
        rgszParams);
}

void
CalaisInfo(
    DEBUG_TEXT szSubroutine,
    LPCTSTR szMessage,
    DWORD dwErrorCode,
    LPCTSTR szParam2,
    LPCTSTR szParam3)
{
    LPCTSTR rgszParams[4];
    CErrorString szErrStr(dwErrorCode);

    rgszParams[0] = szErrStr.Value();
    rgszParams[1] = szParam2;
    rgszParams[2] = szParam3;
    rgszParams[3] = NULL;
    CalaisMessageLog(
        szSubroutine,
        EVENTLOG_INFORMATION_TYPE,
        szMessage,
        rgszParams);
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisWarning")

void
CalaisWarning(
    DEBUG_TEXT szSubroutine,
    LPCTSTR szMessage,
    LPCTSTR szParam1,
    LPCTSTR szParam2,
    LPCTSTR szParam3)
{
    LPCTSTR rgszParams[4];

    rgszParams[0] = szParam1;
    rgszParams[1] = szParam2;
    rgszParams[2] = szParam3;
    rgszParams[3] = NULL;
    CalaisMessageLog(
        szSubroutine,
        EVENTLOG_WARNING_TYPE,
        szMessage,
        rgszParams);
}

void
CalaisWarning(
    DEBUG_TEXT szSubroutine,
    LPCTSTR szMessage,
    DWORD dwErrorCode,
    LPCTSTR szParam2,
    LPCTSTR szParam3)
{
    LPCTSTR rgszParams[4];
    CErrorString szErrStr(dwErrorCode);

    rgszParams[0] = szErrStr.Value();
    rgszParams[1] = szParam2;
    rgszParams[2] = szParam3;
    rgszParams[3] = NULL;
    CalaisMessageLog(
        szSubroutine,
        EVENTLOG_WARNING_TYPE,
        szMessage,
        rgszParams);
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisError")

void
CalaisError(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    LPCTSTR szParam1,
    LPCTSTR szParam2,
    DWORD dwLineNo)
{
    LPCTSTR rgszParams[4];
    TCHAR szLineNo[32];

    _stprintf(szLineNo, TEXT("%d"), dwLineNo);
    rgszParams[0] = szParam1;
    rgszParams[1] = szParam2;
    rgszParams[2] = szLineNo;
    rgszParams[3] = NULL;
    CalaisMessageLog(
        szSubroutine,
        EVENTLOG_ERROR_TYPE,
        szMessage,
        rgszParams);
}

#endif
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisError")

void
CalaisError(
    DEBUG_TEXT szSubroutine,
    DWORD dwMessageId,
    DWORD dwErrorCode,
    LPCTSTR szParam2,
    LPCTSTR szParam3)
{
    LPCTSTR rgszParams[4];
    CErrorString szErrStr(dwErrorCode);

    rgszParams[0] = szErrStr.Value();
    rgszParams[1] = szParam2;
    rgszParams[2] = szParam3;
    rgszParams[3] = NULL;
    CalaisMessageLog(
        szSubroutine,
        EVENTLOG_ERROR_TYPE,
        dwMessageId,
        rgszParams);
}

void
CalaisError(
    DEBUG_TEXT szSubroutine,
    DWORD dwMessageId,
    LPCTSTR szParam1,
    LPCTSTR szParam2,
    LPCTSTR szParam3)
{
    LPCTSTR rgszParams[4];

    rgszParams[0] = szParam1;
    rgszParams[1] = szParam2;
    rgszParams[2] = szParam3;
    rgszParams[3] = NULL;
    CalaisMessageLog(
        szSubroutine,
        EVENTLOG_ERROR_TYPE,
        dwMessageId,
        rgszParams);
}


/*++

CalaisMessageInit:

    This routine prepares the error logging system.

Arguments:

    szTitle supplies the title of the module for logging purposes.

    hEventLogger supplies a handle to an event logging service.  This parameter
        may be NULL.

    fServer supplies an indicator as to whether or not this process is a
        service which should try really hard to log errors.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 5/29/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisMessageInit")

void
CalaisMessageInit(
    LPCTSTR szTitle,
    HANDLE hEventLogger,
    BOOL fServer)
{
    ASSERT(NULL == l_hEventLogger);
    l_szServiceName = szTitle;
    l_hEventLogger = hEventLogger;
    l_fServer = fServer;
#ifdef DBG
    try
    {
        DWORD dwValue;
        CRegistry regSc(
                    HKEY_LOCAL_MACHINE,
                    CalaisString(CALSTR_CALAISREGISTRYKEY),
                    KEY_READ);
        CRegistry regDebug(
                    regSc,
                    CalaisString(CALSTR_DEBUGREGISTRYSUBKEY),
                    KEY_READ);
        regDebug.GetValue(CalaisString(CALSTR_DEBUGLOGSUBKEY), &dwValue);
        g_fDebug = (0 != dwValue);
        regDebug.GetValue(CalaisString(CALSTR_LOGSEVERITYSUBKEY), &dwValue);
        g_wLogSeverity = (WORD)dwValue;
        regDebug.GetValue(CalaisString(CALSTR_GUIWARNINGSUBKEY), &dwValue);
        g_fGuiWarnings = (0 != dwValue);
        regDebug.GetValue(CalaisString(CALSTR_GUISEVERITYSUBKEY), &dwValue);
        g_wGuiSeverity = (WORD)dwValue;
    }
    catch (...) {}
#endif
}


/*++

CalaisMessageClose:

    This routine closes out any error loging in progress, and cleans up.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 5/29/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisMessageClose")

void
CalaisMessageClose(
    void)
{
    if (NULL != l_hEventLogger)
        DeregisterEventSource(l_hEventLogger);
    l_hEventLogger = NULL;
    l_szServiceName = NULL;
}


/*++

CalaisString:

    This routine converts a string identifier into a string.

Arguments:

    dwStringId supplies the identifier for the string.

Return Value:

    The target string value.

Remarks:

    String Ids larger than CALSTR_RESOURCELIMIT are assumed to be resources.

Author:

    Doug Barlow (dbarlow) 4/8/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisString")

LPCTSTR
CalaisString(
    DWORD dwStringId)
{
    static LPTSTR rgszResources[]
        = { NULL, NULL, NULL, NULL, NULL, NULL };   // 6 is all we have for now...
    LPCTSTR szReturn;
    int nStrLen;
    DWORD dwResId = (dwStringId % CALSTR_RESOURCELIMIT) - 1;

    if (CALSTR_RESOURCELIMIT > dwStringId)
    {

        //
        // This is a straight internal text string.
        //

        szReturn = g_rgszDefaultStrings[(dwStringId) - 1];
    }
    else if (dwResId > (sizeof(rgszResources) / sizeof(LPCTSTR)))
    {

        //
        // Make sure the request isn't out of our range.
        //

        ASSERT(FALSE);  // Make that 6 bigger.
        szReturn = TEXT("<Resource out of Range>");
    }
    else if (NULL != rgszResources[dwResId])
    {

        //
        // Have we already loaded that resource?  If so, return
        // it from the cache.
        //

        szReturn = rgszResources[dwResId];
    }
    else
    {
        TCHAR szString[MAX_PATH];


        //
        // OK, we've got to load the resource into the cache.
        //

        nStrLen = LoadString(
                        NULL,
                        dwStringId - CALSTR_RESOURCELIMIT,
                        szString,
                        sizeof(szString));
        if (0 < nStrLen)
        {
            rgszResources[dwResId]
                = (LPTSTR)HeapAlloc(
                            GetProcessHeap(),
                            0,
                            (nStrLen + 1) * sizeof(TCHAR));
            if (NULL != rgszResources[dwResId])
            {
                lstrcpy(rgszResources[dwResId], szString);
                szReturn = rgszResources[dwResId];
            }
            else
                szReturn = TEXT("<Resource Load Error>");
        }
        else
            szReturn = TEXT("<Unavailable Resource>");
    }

    return szReturn;
}


//
//==============================================================================
//
//  Hard core debugging routines.
//

#ifdef DBG
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisSetDebug")
void
CalaisSetDebug(
    BOOLEAN Debug
    )
{
    g_fDebug = Debug;
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("_CalaisDebug")
void
_CalaisDebug(
    LPCTSTR szFormat,
    ...
    )
{
    TCHAR szBuffer[512];
    va_list ap;

    if (g_fDebug == FALSE) {

        return;
    }

    va_start(ap, szFormat);
    _vstprintf(szBuffer, szFormat, ap);
#ifdef _DEBUG
    _putts(szBuffer);
#else
    OutputDebugString(szBuffer);
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\comms\locks.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    locks

Abstract:

    This module provides the implementations of the lock objects used in Calais.

Author:

    Doug Barlow (dbarlow) 6/2/1998

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <stdarg.h>
#include <WinSCard.h>
#include <CalMsgs.h>
#include <calcom.h>

//
//==============================================================================
//
//  CAccessLock
//

/*++

CONSTRUCTOR:

    A CAccessLock provides a multiple-reader, single writer lock on a structure.

Arguments:

    dwTimeout supplies a reasonable timeout value for any lock.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::CAccessLock")

CAccessLock::CAccessLock(
    DWORD dwTimeout)
    :   m_csLock(CSID_ACCESSCONTROL),
    m_hSignalNoReaders(DBGT("CAccessLock No Readers Event")),
    m_hSignalNoWriters(DBGT("CAccessLock No Writers Event"))
#ifdef DBG
        , m_rgdwReaders()
#endif
{
    m_hSignalNoReaders = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (!m_hSignalNoReaders.IsValid())
    {
        DWORD dwSts = m_hSignalNoReaders.GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Access Lock Object cannot create the No Readers signal:  %1"),
            dwSts);
        throw dwSts; // Force a shutdown.
    }
    m_hSignalNoWriters = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (!m_hSignalNoWriters.IsValid())
    {
        DWORD dwSts = m_hSignalNoWriters.GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Access Lock Object cannot create the No Writers signal:  %1"),
            dwSts);
        throw dwSts; // Force a shutdown.
    }
    m_dwOwner = 0;
    m_dwReadCount = m_dwWriteCount = 0;
    m_dwTimeout = dwTimeout;
}


/*++

DESTRUCTOR:

    This cleans up after a CAccessLock.

Arguments:

    None

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::~CAccessLock")

CAccessLock::~CAccessLock()
{
    if (InitFailed())
        return;

    {
        CLockWrite rwLock(this);
        m_csLock.Enter(
            __SUBROUTINE__,
            DBGT("Closing down the CAccessLock"));
    }
#ifdef DBG
    {
        ASSERT(0 == m_dwReadCount);
        for (DWORD ix = m_rgdwReaders.Count(); ix > 0;)
        {
            ix -= 1;
            ASSERT(0 == m_rgdwReaders[ix]);
        }
    }
#endif
    if (m_hSignalNoReaders.IsValid())
        m_hSignalNoReaders.Close();
    if (m_hSignalNoWriters.IsValid())
        m_hSignalNoWriters.Close();
}


/*++

Wait:

    Wait for the usage signal to trigger.

Arguments:

    hSignal supplies the handle to use for the wait.

Return Value:

    None

Throws:

    None

Remarks:

    This routine blocks until the usage signal fires.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::Wait")

void
CAccessLock::Wait(
    HANDLE hSignal)
{
    WaitForever(
        hSignal,
        m_dwTimeout,
        DBGT("Waiting for Read/Write Lock signal (owner %2): %1"),
        m_dwOwner);
}


/*++

Signal:

    This routine signals the usage signal that the structure is available.

Arguments:

    hSignal supplies the handle to be signaled.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::Signal")

void
CAccessLock::Signal(
    HANDLE hSignal)
{
    if (!SetEvent(hSignal))
    {
        DWORD dwSts = GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Access Lock Object cannot set its signal:  %1"),
            dwSts);
        throw dwSts;
    }
}


/*++

Unsignal:

    This method is used to notify other threads that the lock has been taken.

Arguments:

    hSignal supplies the handle to be reset.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::Unsignal")

void
CAccessLock::Unsignal(
    HANDLE hSignal)
{
    if (!ResetEvent(hSignal))
    {
        DWORD dwSts = GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Access Lock Object cannot reset its signal:  %1"),
            dwSts);
        throw dwSts;
    }
}


#ifdef DBG
/*
    Trivial Internal consistency check routines.
*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::NotReadLocked")

BOOL
CAccessLock::NotReadLocked(
    void)
{
    LockSection(&m_csLock, DBGT("Verifying Lock State"));
    BOOL fReturn = TRUE;

    for (DWORD ix = m_rgdwReaders.Count(); ix > 0;)
    {
        ix -= 1;
        if (GetCurrentThreadId() == m_rgdwReaders[ix])
        {
            fReturn = FALSE;
            break;
        }
    }
    return fReturn;
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::IsReadLocked")

BOOL
CAccessLock::IsReadLocked(
    void)
{
    return !NotReadLocked();
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::NotWriteLocked")

BOOL
CAccessLock::NotWriteLocked(
    void)
{
    LockSection(&m_csLock, DBGT("Verifying Lock state"));
    return (GetCurrentThreadId() != m_dwOwner);
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CAccessLock::IsWriteLocked")

BOOL
CAccessLock::IsWriteLocked(
    void)
{
    LockSection(&m_csLock, DBGT("Verifying Lock state"));
    return (GetCurrentThreadId() == m_dwOwner);
}
#endif


//
//==============================================================================
//
//  CLockRead
//

/*++

CONSTRUCTOR:

    This is the constructor for a CLockRead object.  The existence of this
    object forms a sharable read lock on the supplied CAccessLock object.

Arguments:

    pLock supplies the CAccessLock object against which a read request is to
        be posted.

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CLockRead::CLockRead")

CLockRead::CLockRead(
    CAccessLock *pLock)
{
    m_pLock = pLock;


    //
    // Quick check to see if we're already a writer.
    //

    {
        LockSection(&m_pLock->m_csLock, DBGT("Make sure we're not the writer"));
        if (m_pLock->m_dwOwner == GetCurrentThreadId())
        {
            ASSERT(0 < m_pLock->m_dwWriteCount);
            m_pLock->m_dwReadCount += 1;
            ASSERT(0 < m_pLock->m_dwReadCount);
#ifdef DBG
            DWORD dwCurrentThread = GetCurrentThreadId();
            for (DWORD ix = 0; 0 != m_pLock->m_rgdwReaders[ix]; ix += 1);
                // Empty loop body
            m_pLock->m_rgdwReaders.Set(ix, dwCurrentThread);
#endif
            m_pLock->UnsignalNoReaders();
            return;
        }
    }


    //
    // We're not a writer.  Acquire the read lock.
    //

    for (;;)
    {
        m_pLock->WaitOnWriters();
        {
            LockSection(&m_pLock->m_csLock, DBGT("Get the read lock"));
            if ((0 == m_pLock->m_dwWriteCount)
                || (m_pLock->m_dwOwner == GetCurrentThreadId()))
            {
                m_pLock->m_dwReadCount += 1;
                ASSERT(0 < m_pLock->m_dwReadCount);
#ifdef DBG
                DWORD dwCurrentThread = GetCurrentThreadId();
                for (DWORD ix = 0; 0 != m_pLock->m_rgdwReaders[ix]; ix += 1);
                    // Empty loop body
                m_pLock->m_rgdwReaders.Set(ix, dwCurrentThread);
#endif
                m_pLock->UnsignalNoReaders();
                break;
            }
        }
    }
}


/*++

DESTRUCTOR:

    The CLockRead destructor frees the outstanding read lock on the CAccessLock
    object.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CLockRead::~CLockRead")

CLockRead::~CLockRead()
{
    if (InitFailed())
        return;

    LockSection(&m_pLock->m_csLock, DBGT("Releasing the read lock"));
    ASSERT(0 < m_pLock->m_dwReadCount);
    m_pLock->m_dwReadCount -= 1;
#ifdef DBG
    DWORD dwCurrentThread = GetCurrentThreadId();
    for (DWORD ix = m_pLock->m_rgdwReaders.Count(); ix > 0;)
    {
        ix -= 1;
        if (dwCurrentThread == m_pLock->m_rgdwReaders[ix])
        {
            m_pLock->m_rgdwReaders.Set(ix, 0);
            break;
        }
        ASSERT(0 < ix);
    }
#endif
    if (0 == m_pLock->m_dwReadCount)
        m_pLock->SignalNoReaders();
}


//
//==============================================================================
//
//  CLockWrite
//

/*++

CONSTRUCTOR:

    This is the constructor for a CLockWrite object.  The existence of this
    object forms a unshared write lock on the supplied CAccessLock object.

Arguments:

    pLock supplies the CAccessLock object against which a write request is to
        be posted.

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CLockWrite::CLockWrite")

CLockWrite::CLockWrite(
    CAccessLock *pLock)
{
    m_pLock = pLock;


    //
    // Quick check to see if we're already a writer.
    //

    {
        LockSection(&m_pLock->m_csLock, DBGT("See if we're already a writer"));
        if (m_pLock->m_dwOwner == GetCurrentThreadId())
        {
            ASSERT(0 < m_pLock->m_dwWriteCount);
            m_pLock->m_dwWriteCount += 1;
            return;
        }
    }


    //
    // We're not a writer.  Acquire the write lock.
    //

    for (;;)
    {
        m_pLock->WaitOnWriters();
        {
            LockSection(&m_pLock->m_csLock, DBGT("Get the Write lock"));
            if (0 == m_pLock->m_dwWriteCount)
            {
                ASSERT(m_pLock->NotReadLocked());
                ASSERT(0 == m_pLock->m_dwOwner);
                m_pLock->m_dwWriteCount += 1;
                m_pLock->m_dwOwner = GetCurrentThreadId();
                m_pLock->UnsignalNoWriters();
                break;
            }
        }
    }

    for (;;)
    {
        m_pLock->WaitOnReaders();
        {
            LockSection(&m_pLock->m_csLock, DBGT("See if we got the read lock"));
            if (0 == m_pLock->m_dwReadCount)
                break;
#ifdef DBG
            else
            {
                DWORD dwIndex;
                for (dwIndex = m_pLock->m_rgdwReaders.Count(); dwIndex > 0;)
                {
                     dwIndex -= 1;
                    if (0 != m_pLock->m_rgdwReaders[dwIndex])
                        break;
                    ASSERT(0 < dwIndex); // No one will ever respond!
                }
            }
#endif
        }
    }
}


/*++

DESTRUCTOR:

    The CLockWrite destructor frees the outstanding write lock on the
    CAccessLock object.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CLockWrite::~CLockWrite")

CLockWrite::~CLockWrite()
{
    if (InitFailed())
        return;

    LockSection(&m_pLock->m_csLock, DBGT("Releasing the write lock"));
    ASSERT(0 == m_pLock->m_dwReadCount);
    ASSERT(0 < m_pLock->m_dwWriteCount);
    ASSERT(m_pLock->m_dwOwner == GetCurrentThreadId());
    m_pLock->m_dwWriteCount -= 1;
    if (0 == m_pLock->m_dwWriteCount)
    {
        m_pLock->m_dwOwner = 0;
        m_pLock->SignalNoWriters();
    }
}


//
//==============================================================================
//
//  CMutex
//

/*++

CONSTRUCTOR:

    The constructor for a CMutex object.  A CMutex allows threads to synchronize
    on it.  It differs from a regular mutex in that it is possible for one
    thread to take this mutex away from another thread.

Arguments:

    None

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::CMutex")

CMutex::CMutex(
    void)
:   m_csAccessLock(CSID_MUTEX),
    m_hAvailableEvent(DBGT("CMutex Availability event"))

{
    m_dwOwnerThreadId = 0;
    m_dwGrabCount = 0;
    m_dwValidityCount = 0;
    m_hAvailableEvent = CreateEvent(NULL, FALSE, TRUE, NULL);
    if (!m_hAvailableEvent.IsValid())
    {
        DWORD dwErr = m_hAvailableEvent.GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Mutex Object cannot create its signal:  %1"),
            dwErr);
    }
}


/*++

DESTRUCTOR:

    This cleans up the mutex object.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::~CMutex")

CMutex::~CMutex()
{
    if (InitFailed())
        return;

    Invalidate();
    if (m_hAvailableEvent.IsValid())
        m_hAvailableEvent.Close();
}


/*++

Grab:

    Get a hold of the Mutex, blocking other threads that also need it.

Arguments:

    None

Return Value:

    none

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::Grab")

void
CMutex::Grab(
    void)
{
    DWORD dwValid;

    {
        LockSection(&m_csAccessLock, DBGT("See if we have the mutex already"));
        if (GetCurrentThreadId() == m_dwOwnerThreadId)
        {
            ASSERT(0 < m_dwGrabCount);
            m_dwGrabCount += 1;
            return;
        }
        dwValid = m_dwValidityCount;
    }
    WaitForever(
        m_hAvailableEvent,
        REASONABLE_TIME,
        DBGT("Waiting to grab CMutex (owner %2): %1"),
        m_dwOwnerThreadId);
    LockSection(&m_csAccessLock, DBGT("Grab the Mutex"));
    if (dwValid == m_dwValidityCount)
    {
        ASSERT(0 == m_dwGrabCount);
        ASSERT(0 == m_dwOwnerThreadId);
        m_dwOwnerThreadId = GetCurrentThreadId();
        m_dwGrabCount = 1;
    }
    else
    {
        if (!SetEvent(m_hAvailableEvent))
        {
            DWORD dwErr = GetLastError();
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Mutex Object cannot set its signal:  %1"),
                dwErr);
            throw dwErr;
        }
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Attempt to grab reader a failed -- grab invalidated"));
        throw (DWORD)SCARD_E_READER_UNAVAILABLE; // ?SCARD_E_SYSTEM_CANCELLED?
    }
}


/*++

Share:

    This method is called when the owning thread no longer requires the mutex.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::Share")

BOOL
CMutex::Share(
    void)
{
    BOOL fRtn = FALSE;

    LockSection(&m_csAccessLock, DBGT("Release the mutex"));
    if (m_dwOwnerThreadId == GetCurrentThreadId())
    {
        ASSERT(0 < m_dwGrabCount);
        m_dwGrabCount -= 1;
        if (0 == m_dwGrabCount)
        {
            m_dwOwnerThreadId = 0;
            if (!SetEvent(m_hAvailableEvent))
            {
                DWORD dwErr = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Mutex Object cannot set its signal:  %1"),
                    dwErr);
            }
        }
        fRtn = TRUE;
    }

    return fRtn;
}


/*++

Invalidate:

    This method causes any owning thread to lose the mutex, making it available
    for others.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

    This routine waits until it can access the originally supplied HANDLE before
    stealing the mutex.  That way, the owning thread can make critical areas
    where the mutex is guaranteed to not be taken away.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::Invalidate")

void
CMutex::Invalidate(
    void)
{
    LockSection(&m_csAccessLock, DBGT("Invalidate any outstanding grabs"));
    m_dwValidityCount += 1;
    m_dwOwnerThreadId = 0;
    m_dwGrabCount = 0;
    if (!SetEvent(m_hAvailableEvent))
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Mutex Object cannot set its signal:  %1"),
            GetLastError());
    }
}


/*++

Take:

    This method causes any owning thread to lose the mutex, reassigning the
    mutex to the current calling thread.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

    This routine waits until it can access the originally supplied HANDLE before
    stealing the mutex.  That way, the owning thread can make critical areas
    where the mutex is guaranteed to not be taken away.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::Take")

void
CMutex::Take(
    void)
{
    LockSection(&m_csAccessLock, DBGT("Take the mutex"));
    if (!ResetEvent(m_hAvailableEvent))
    {
        DWORD dwErr = GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Mutex Object cannot reset its signal:  %1"),
            dwErr);
    }
    m_dwValidityCount += 1;
    m_dwOwnerThreadId = GetCurrentThreadId();
    m_dwGrabCount = 1;
}


/*++
    Simple state checking services
--*/

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::IsGrabbed")
BOOL
CMutex::IsGrabbed(
    void)
{
    LockSection(&m_csAccessLock, DBGT("Is the mutex owned?"));
    return (m_dwOwnerThreadId != 0);
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::IsGrabbedBy")
BOOL
CMutex::IsGrabbedBy(
    DWORD dwThreadId)
{
    LockSection(&m_csAccessLock, DBGT("Check mutex ownership"));
    return (m_dwOwnerThreadId == dwThreadId);
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMutex::IsGrabbedByMe")
BOOL
CMutex::IsGrabbedByMe(
    void)
{
    return IsGrabbedBy(GetCurrentThreadId());
}


//
//==============================================================================
//
//  CMultiEvent
//


/*++

CONSTRUCTOR:

    This is the constructor for a CMultiEvent object.  A MultiEvent object is
    used for events that need a single event, but which listeners may not be
    quick to watch for.  It has an array of events, and sets them round robin,
    so that a waiter politely waits for their particular event.

Arguments:

    None

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMultiEvent::CMultiEvent")

CMultiEvent::CMultiEvent(
    void)
:   m_csLock(CSID_MULTIEVENT)
{
    for (DWORD ix = 0; ix < sizeof(m_rghEvents) / sizeof(HANDLE); ix += 1)
        m_rghEvents[ix] = NULL;
    for (ix = 0; ix < sizeof(m_rghEvents) / sizeof(HANDLE); ix += 1)
    {
        m_rghEvents[ix] = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL == m_rghEvents[ix])
            throw GetLastError();
    }
    m_dwEventIndex = 0;
}


/*++

DESTRUCTOR:

    This method cleans up after a CMultiEvent object is no longer needed.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMultiEvent::~CMultiEvent")

CMultiEvent::~CMultiEvent()
{
    for (DWORD ix = 0; ix < sizeof(m_rghEvents) / sizeof(HANDLE); ix += 1)
    {
        if (NULL != m_rghEvents[ix])
        {
            if (!CloseHandle(m_rghEvents[ix]))
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to close MultiEvent handle: %1"),
                    GetLastError());
        }
    }
}


/*++

WaitHandle:

    This method returns the handle of the current event, suitable for waiting
    on.

Arguments:

    None

Return Value:

    The value of the handle which can be waited on.

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMultiEvent::WaitHandle")

HANDLE
CMultiEvent::WaitHandle(
    void)
{
    LockSection(&m_csLock, DBGT("Obtaining the current wait handle"));
    return m_rghEvents[m_dwEventIndex];
}


/*++

Signal:

    This method signals the current handle, and moves onto the next handle in
    the array.  This way it can leave the current handle set for a significant
    time period, but still provide new waiters with reason to block.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CMultiEvent::Signal")

void
CMultiEvent::Signal(
    void)
{
    LockSection(&m_csLock, DBGT("Signal the current event"));
    if (!SetEvent(m_rghEvents[m_dwEventIndex]))
        throw GetLastError();
    m_dwEventIndex += 1;
    m_dwEventIndex %= sizeof(m_rghEvents) / sizeof(HANDLE);
    if (!ResetEvent(m_rghEvents[m_dwEventIndex]))
        throw GetLastError();
}


/*++

WaitForAnObject:

    This routine performs object waiting services.  It really doesn't have
    anything to do with locking except that there are so many error conditions
    to check for that it's more convenient to have it off in its own routine.

Arguments:

    hWaitOn supplies the handle to wait on.

    dwTimeout supplies the wait timeout value.

Return Value:

    The error code, if any

Throws:

    None

Author:

    Doug Barlow (dbarlow) 6/19/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("WaitForAnObject")

DWORD
WaitForAnObject(
    HANDLE hWaitOn,
    DWORD dwTimeout)
{
    DWORD dwReturn = SCARD_S_SUCCESS;
    DWORD dwSts;

    ASSERT(INVALID_HANDLE_VALUE != hWaitOn);
    ASSERT(NULL != hWaitOn);
    dwSts = WaitForSingleObject(hWaitOn, dwTimeout);
    switch (dwSts)
    {
    case WAIT_FAILED:
        dwSts = GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Wait for object failed:  %1"),
            dwSts);
        dwReturn = dwSts;
        break;
    case WAIT_TIMEOUT:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Wait for object timed out"));
        dwReturn = SCARD_F_WAITED_TOO_LONG;
        break;
    case WAIT_ABANDONED:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Wait for object received wait abandoned"));
        // That's OK, we still got it.
        break;

    case WAIT_OBJECT_0:
        break;

    default:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Wait for object got invalid response"));
        dwReturn = SCARD_F_INTERNAL_ERROR;
    }

    return dwReturn;
}


/*++

WaitForObjects:

    This routine is a utility to allow waiting for multiple objects.  It returns
    the index of the object that completed.

Arguments:

    dwTimeout supplies the timeout value, in milliseconds, or INFINITE.

    hObject and following supply the list of objects to wait for.  This list
        must be NULL terminated.

Return Value:

    The number of the object completed.  1 implies the first one, 2 implies the
    second one, etc.

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 6/17/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("WaitForAnyObject")

DWORD
WaitForAnyObject(
    DWORD dwTimeout,
    ...)
{
    va_list ap;
    HANDLE h, rgh[4];
    DWORD dwIndex = 0, dwWait, dwErr;

    va_start(ap, dwTimeout);
    for (h = va_arg(ap, HANDLE); NULL != h; h = va_arg(ap, HANDLE))
    {
        ASSERT(dwIndex < sizeof(rgh) / sizeof(HANDLE));
        ASSERT(INVALID_HANDLE_VALUE != h);
        if (INVALID_HANDLE_VALUE != h)
            rgh[dwIndex++] = h;
    }
    va_end(ap);

    ASSERT(0 < dwIndex);
    if (0 < dwIndex)
        dwWait = WaitForMultipleObjects(dwIndex, rgh, FALSE, dwTimeout);
    else
    {
        dwWait = WAIT_FAILED;
        SetLastError(ERROR_INVALID_EVENT_COUNT);
        // That's a good symbolic name, but a lousy user message.
    }

    switch (dwWait)
    {
    case WAIT_FAILED:
        dwErr = GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("WaitForObjects failed its wait:  %1"),
            dwErr);
        throw dwErr;
        break;

    case WAIT_TIMEOUT:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("WaitForObjects timed out on its wait"));
        throw (DWORD)ERROR_TIMEOUT;
        break;

    default:
        C_ASSERT(WAIT_OBJECT_0 == 0);
        ASSERT(WAIT_OBJECT_0 < WAIT_ABANDONED_0);
        if ((dwWait >= WAIT_ABANDONED_0)
            && (dwWait < (WAIT_ABANDONED_0 + WAIT_ABANDONED_0 - WAIT_OBJECT_0)))
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("WaitForObjects received a Wait Abandoned warning"));
            dwIndex = dwWait - WAIT_ABANDONED_0 + 1;
        }
        else if (dwWait < WAIT_ABANDONED_0)
        {
            dwIndex = dwWait - WAIT_OBJECT_0 + 1;
        }
        else
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("WaitForObjects received unknown error code: %1"),
                dwWait);
            throw dwWait;
        }
    }

    return dwIndex;
}


#ifdef DBG
//
//  Critical Section Support.
//
//  The following Classes aid in debugging Critical Section Conflicts.
//

static const TCHAR l_szUnowned[] = TEXT("<Unowned>");
CDynamicArray<CCriticalSectionObject> *CCriticalSectionObject::mg_prgCSObjects = NULL;
CRITICAL_SECTION CCriticalSectionObject::mg_csArrayLock;
static const LPCTSTR l_rgszLockList[]
    = { DBGT("Service Status Critical Section"),        // CSID_SERVICE_STATUS
        DBGT("Lock for Calais control commands."),      // CSID_CONTROL_LOCK
        DBGT("Lock for server thread enumeration."),    // CSID_SERVER_THREADS
        DBGT("MultiEvent Critical Access Section"),     // CSID_MULTIEVENT
        DBGT("Mutex critical access section"),          // CSID_MUTEX
        DBGT("Access Lock control"),                    // CSID_ACCESSCONTROL
        DBGT("Lock for tracing output."),               // CSID_TRACEOUTPUT
        NULL };


//
//==============================================================================
//
//  CCriticalSectionObject
//

/*++

CONSTRUCTOR:

    This method builds the critical section object and coordinates its tracking.

Arguments:

    szDescription supplies a description of what this critical section object
        is used for.  This aids identification.

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/19/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::CCriticalSectionObject")

CCriticalSectionObject::CCriticalSectionObject(
    DWORD dwCsid)
{
    m_fInitFailed = TRUE;
    try {
        // Preallocate the event used by the EnterCriticalSection
        // function to prevent an exception from being thrown in
        // CCriticalSectionObject::Enter
        if (! InitializeCriticalSectionAndSpinCount(
                &m_csLock, 0x80000000))
            return;
    }
    catch (HRESULT hr) {
        return;
    }

    m_dwCsid = dwCsid;
    m_bfOwner.Set((LPCBYTE)l_szUnowned, sizeof(l_szUnowned));
    m_bfComment.Set((LPCBYTE)DBGT(""), sizeof(TCHAR));
    m_dwOwnerThread = 0;
    m_dwRecursion = 0;
    if (NULL == mg_prgCSObjects)
    {
        try {
            if (! InitializeCriticalSectionAndSpinCount(
                    &mg_csArrayLock, 0x80000000)) {
                DeleteCriticalSection(&m_csLock);
                return;
            }
        }
        catch (HRESULT hr) {
            DeleteCriticalSection(&m_csLock);
            return;
        }

        CCritSect csLock(&mg_csArrayLock);
        mg_prgCSObjects = new CDynamicArray<CCriticalSectionObject>;
        ASSERT(NULL != mg_prgCSObjects);
        m_dwArrayEntry = 0;
        mg_prgCSObjects->Set(m_dwArrayEntry, this);
    }
    else
    {
        CCritSect csLock(&mg_csArrayLock);
        for (m_dwArrayEntry = 0;
             NULL != (*mg_prgCSObjects)[m_dwArrayEntry];
             m_dwArrayEntry += 1)
            ;   // Empty loop body
        mg_prgCSObjects->Set(m_dwArrayEntry, this);
    }
    m_fInitFailed = FALSE;
}


/*++

DESTRUCTOR:

    This method cleans up the critical section object.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/19/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::~CCriticalSectionObject")

CCriticalSectionObject::~CCriticalSectionObject()
{
    if (m_fInitFailed)
        return;

    if (0 == m_dwOwnerThread)
    {
        ASSERT(0 == m_dwRecursion);
    }
    else
    {
        ASSERT(IsOwnedByMe());
        ASSERT(1 == m_dwRecursion);
        LeaveCriticalSection(&m_csLock);
    }
    {
        CCritSect csLock(&mg_csArrayLock);
        ASSERT(this == (*mg_prgCSObjects)[m_dwArrayEntry]);
        mg_prgCSObjects->Set(m_dwArrayEntry, NULL);
    }
    DeleteCriticalSection(&m_csLock);
}


/*++

Enter:

    This method enters a critical section, and tracks the owner.

Arguments:

    szOwner supplies the name of the calling subroutine.

    szComment supplies an additional comment to help distinguish between
        multiple calls within a subroutine.

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/19/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::Enter")

void
CCriticalSectionObject::Enter(
    LPCTSTR szOwner,
    LPCTSTR szComment)
{
    if (m_fInitFailed)
        throw (DWORD)SCARD_E_NO_MEMORY;

    {
        CCritSect csLock(&mg_csArrayLock);
        CCriticalSectionObject *pCs;

        for (DWORD dwI = mg_prgCSObjects->Count(); 0 < dwI;)
        {
            pCs = (*mg_prgCSObjects)[--dwI];
            if (m_dwArrayEntry == dwI)
            {
                ASSERT(this == pCs);
                continue;
            }
            if (NULL != pCs)
            {
                if (pCs->IsOwnedByMe()
                    && (m_dwCsid <= pCs->m_dwCsid))
                {
                    CalaisError(
                        __SUBROUTINE__,
                        DBGT("Potential Critical Section deadlock: Owner of %1 attempting to access %2"),
                        pCs->Description(),
                        Description());
                }
            }
        }
    }
    EnterCriticalSection(&m_csLock);
    if (0 == m_dwRecursion)
    {
        ASSERT(0 == m_dwOwnerThread);
        m_dwOwnerThread = GetCurrentThreadId();
        m_bfOwner.Set(
            (LPCBYTE)szOwner,
            (lstrlen(szOwner) + 1) * sizeof(TCHAR));
        m_bfComment.Set(
            (LPCBYTE)szComment,
            (lstrlen(szComment) + 1) * sizeof(TCHAR));
    }
    else
    {
        ASSERT(GetCurrentThreadId() == m_dwOwnerThread);
        CalaisDebug((
            DBGT("Critical Section '%s' already owned by %s (%s)\nCalled from %s (%s)\n"),
            Description(),
            Owner(),
            Comment(),
            szOwner,
            szComment));
    }
    m_dwRecursion += 1;
    ASSERT(0 < m_dwRecursion);
}


/*++

Leave:

    This method exits a critical section.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/19/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::Leave")

void
CCriticalSectionObject::Leave(
    void)
{
    ASSERT(0 < m_dwRecursion);
    m_dwRecursion -= 1;
    if (0 == m_dwRecursion)
    {
        m_bfOwner.Set((LPCBYTE)l_szUnowned, sizeof(l_szUnowned));
        m_bfComment.Set((LPCBYTE)DBGT(""), sizeof(TCHAR));
        m_dwOwnerThread = 0;
    }
    LeaveCriticalSection(&m_csLock);
}


/*++

Description:

    Translate the Critical Section Id number to a descriptive string.

Arguments:

    None

Return Value:

    The descriptive string corresponding to this critical section type.

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/22/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::Description")

LPCTSTR
CCriticalSectionObject::Description(
    void)
const
{
    return l_rgszLockList[m_dwCsid];
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\comms\scevents.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    scEvents

Abstract:

    This module provides access to the Calais subsystem internal events.
    Currently two events are defined:

    Microsoft Smart Card Resource Manager Started - This event is set when the
        resource manager starts up.

    Microsoft Smart Card Resource Manager New Reader - This event is set when
        the resource manager adds a new reader via Plug 'n Play.

Author:

    Doug Barlow (dbarlow) 7/1/1998

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <winscard.h>
#include <CalMsgs.h>
#include <calcom.h>

static HANDLE
    l_hStartedEvent = NULL,
    l_hNewReaderEvent = NULL,
    l_hStoppedEvent = NULL;


/*++

AccessStartedEvent:

    This function obtains a local handle to the Calais Resource Manager Start
    event.  The handle must be released via the ReleaseStartedEvent
    service.

Arguments:

    None

Return Value:

    The Handle, or NULL if an error occurs.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AccessStartedEvent")

HANDLE
AccessStartedEvent(
    void)
{
    if (NULL == l_hStartedEvent)
    {
        try
        {
            CSecurityDescriptor acl;
            acl.Initialize();
            acl.Allow(
                &acl.SID_LocalService,
                EVENT_ALL_ACCESS);
            acl.Allow(
                &acl.SID_Local,
                SYNCHRONIZE);
            acl.Allow(
                &acl.SID_System,
                SYNCHRONIZE);
            l_hStartedEvent =
                CreateEvent(
                    acl,        // pointer to security attributes
                    TRUE,       // flag for manual-reset event
                    FALSE,      // flag for initial state
                    CalaisString(CALSTR_STARTEDEVENTNAME)); // event-object name
            if (NULL == l_hStartedEvent)
            {
                l_hStartedEvent = OpenEvent(SYNCHRONIZE, FALSE, CalaisString(CALSTR_STARTEDEVENTNAME));
            }
        }
        catch (...)
        {
            ASSERT(NULL == l_hStartedEvent);
        }
    }
    return l_hStartedEvent;
}



/*++

AccessStoppedEvent:

    This function obtains a local handle to the Calais Resource Manager Stopped
    event.  

Arguments:

    None

Return Value:

    The Handle, or NULL if an error occurs.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:


--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AccessStoppedEvent")

HANDLE
AccessStoppedEvent(
    void)
{
    if (NULL == l_hStoppedEvent)
    {
        try
        {
            CSecurityDescriptor acl;
            acl.Initialize();
            acl.Allow(
                &acl.SID_LocalService,
                EVENT_ALL_ACCESS);
            acl.Allow(
                &acl.SID_Local,
                SYNCHRONIZE);
            acl.Allow(
                &acl.SID_System,
                SYNCHRONIZE);
            l_hStoppedEvent =
                CreateEvent(
                    acl,        // pointer to security attributes
                    TRUE,       // flag for manual-reset event
                    FALSE,      // flag for initial state
                    CalaisString(CALSTR_STOPPEDEVENTNAME)); // event-object name
            if (NULL == l_hStoppedEvent)
            {
                l_hStoppedEvent = OpenEvent(SYNCHRONIZE, FALSE, CalaisString(CALSTR_STOPPEDEVENTNAME));
            }
        }
        catch (...)
        {
            ASSERT(NULL == l_hStoppedEvent);
        }
    }
    return l_hStoppedEvent;
}



/*++

AccessNewReaderEvent:

    This function obtains a local handle to the Calais Resource Manager's New
    Reader event.  The handle must be released via the
    ReleaseNewReaderEvent service.

Arguments:

    None

Return Value:

    The Handle, or NULL if an error occurs.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AccessNewReaderEvent")

HANDLE
AccessNewReaderEvent(
    void)
{
    if (NULL == l_hNewReaderEvent)
    {
        try
        {
            CSecurityDescriptor acl;
            acl.Initialize();
            acl.Allow(
                &acl.SID_LocalService,
                EVENT_ALL_ACCESS);
            acl.Allow(
                &acl.SID_Local,
                SYNCHRONIZE);
            acl.Allow(
                &acl.SID_System,
                SYNCHRONIZE);
            l_hNewReaderEvent
                = CreateEvent(
                    acl,        // pointer to security attributes
                    TRUE,       // flag for manual-reset event
                    FALSE,      // flag for initial state
                    CalaisString(CALSTR_NEWREADEREVENTNAME)); // pointer to event-object name
        }
        catch (...)
        {
            ASSERT(NULL == l_hNewReaderEvent);
        }

    }
    return l_hNewReaderEvent;
}



/*++

ReleaseStartedEvent:

    This function releases a previously accessed handle to the Calais
    Resource Manager Start event.  The handle must be obtained via the
    AccessStartedEvent service.

Arguments:

    None

Return Value:

    None.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("ReleaseStartedEvent")

void
ReleaseStartedEvent(
    void)
{
    if (NULL != l_hStartedEvent)
    {
        CloseHandle(l_hStartedEvent);
        l_hStartedEvent = NULL;
    }
}


/*++

ReleaseStoppedEvent:

    This function releases a previously accessed handle to the Calais
    Resource Manager Stopped event.  The handle must be obtained via the
    AccessStoppedEvent service.

Arguments:

    None

Return Value:

    None.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.


--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("ReleaseStoppedEvent")

void
ReleaseStoppedEvent(
    void)
{
    if (NULL != l_hStoppedEvent)
    {
        CloseHandle(l_hStoppedEvent);
        l_hStoppedEvent = NULL;
    }
}


/*++

ReleaseNewReaderEvent:

    This function releases a previously accessed handle to the Calais
    Resource Manager New Reader event.  The handle must be obtained via the
    AccessNewReaderEvent service.

Arguments:

    None

Return Value:

    None.

Throws:

    None

Remarks:

    Programs other than the resource manager should only wait on these flags.

Author:

    Doug Barlow (dbarlow) 7/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("ReleaseNewReaderEvent")

void
ReleaseNewReaderEvent(
    void)
{
    if (NULL != l_hNewReaderEvent)
    {
        CloseHandle(l_hNewReaderEvent);
        l_hNewReaderEvent = NULL;
    }
}


/*++

ReleaseAllEvents:

    This is a catch-all routine that releases all known special event handles.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

Author:

    Doug Barlow (dbarlow) 7/6/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("ReleaseAllEvents")

void
ReleaseAllEvents(
    void)
{
    ReleaseNewReaderEvent();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\comms\startsvr.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    StartSvc

Abstract:

    This module provides a Starter service for Calais.

Author:

    Doug Barlow (dbarlow) 2/10/1997

Environment:

    Win32, C++

Notes:



--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <winscard.h>
#include <CalMsgs.h>
#include <CalaisLb.h>


/*++

StartCalaisService:

    This function starts the Calais service.

Arguments:

    None

Return Value:

    a DWORD status code.  ERROR_SUCCESS implies success.

Throws:

    None.

Author:

    Doug Barlow (dbarlow) 2/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("StartCalaisService")

DWORD
StartCalaisService(
    void)
{
    // return ERROR_SERVICE_DISABLED;
    SC_HANDLE schService = NULL;
    SC_HANDLE schSCManager = NULL;
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwGiveUpCount;
    DWORD dwSts;
    BOOL fSts;

    try
    {
        SERVICE_STATUS ssStatus;    // current status of the service

        schSCManager = OpenSCManager(
                            NULL,           // machine (NULL == local)
                            NULL,           // database (NULL == default)
                            GENERIC_READ);  // access required
        dwSts = NULL == schSCManager ? GetLastError() : ERROR_SUCCESS;
        if (NULL == schSCManager)
            throw dwSts;

        schService = OpenService(
                        schSCManager,
                        CalaisString(CALSTR_PRIMARYSERVICE),
                        SERVICE_QUERY_STATUS | SERVICE_START);
        dwSts = NULL == schService ? GetLastError() : ERROR_SUCCESS;
        if (NULL == schService)
            throw dwSts;

        // try to start the service
        fSts = StartService(schService, 0, NULL);
        dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
        if (!fSts)
        {
            dwSts = GetLastError();
            switch (dwSts)
            {
            case ERROR_SERVICE_ALREADY_RUNNING:
                break;
            default:
                throw dwSts;
            }
        }
        dwGiveUpCount = 60;
        Sleep(1000);

        for (;;)
        {
            fSts = QueryServiceStatus(schService, &ssStatus);
            dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
            if (!fSts)
                break;

            if (ssStatus.dwCurrentState == SERVICE_START_PENDING)
            {
                if (0 < --dwGiveUpCount)
                    Sleep(1000);
                else
                    throw (DWORD)SCARD_E_NO_SERVICE;
            }
            else
                break;
        }

        if (ssStatus.dwCurrentState != SERVICE_RUNNING)
            throw GetLastError();

        fSts = CloseServiceHandle(schService);
        dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
        schService = NULL;

        fSts = CloseServiceHandle(schSCManager);
        dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
        schSCManager = NULL;
    }

    catch (DWORD dwErr)
    {
        if (NULL != schService)
        {
            fSts = CloseServiceHandle(schService);
            dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
        }
        if (NULL != schSCManager)
        {
            fSts = CloseServiceHandle(schSCManager);
            dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
        }
        dwReturn = dwErr;
    }

    catch (...)
    {
        if (NULL != schService)
        {
            fSts = CloseServiceHandle(schService);
            dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
        }
        if (NULL != schSCManager)
        {
            fSts = CloseServiceHandle(schSCManager);
            dwSts = !fSts ? GetLastError() : ERROR_SUCCESS;
        }
        dwReturn = ERROR_INVALID_PARAMETER;
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\comms\comrspnd.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ComRspnd

Abstract:

    This module implements the Calais Communication Responder class.

Author:

    Doug Barlow (dbarlow) 10/30/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:



--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <WinSCard.h>
#include <CalMsgs.h>
#include <CalCom.h>
#include <stdlib.h>

#define CALCOM_PIPE_TIMEOUT 5000


//
//==============================================================================
//
//  CComResponder
//

/*++

CComResponder:

    This is the standard constructor and destructor for the Comm Responder
    class.  They just call the clean and clear functions, respectively.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/30/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComResponder::CComResponder")

CComResponder::CComResponder(
    void)
:   m_bfPipeName(),
    m_aclPipe(),
    m_hComPipe(DBGT("CComResponder's Comm Pipe")),
    m_hAccessMutex(DBGT("CComResponder's Access Mutex")),
    m_hOvrWait(DBGT("CComResponder Overlapped I/O completion event"))
{
    Clean();
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComResponder::~CComResponder")
CComResponder::~CComResponder()
{
    Clear();
}


/*++

Clean:

    This method sets the object to its default state.  It does not perform any
    tear down -- use Clear for that.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/30/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComResponder::Clean")

void
CComResponder::Clean(
    void)
{
    ZeroMemory(&m_ovrlp, sizeof(m_ovrlp));
    m_bfPipeName.Reset();
}


/*++

Clear:

    This method performs object tear-down and returns it to its initial state.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/30/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComResponder::Clear")

void
CComResponder::Clear(
    void)
{
    if (m_hAccessMutex.IsValid())
    {
        WaitForever(
            m_hAccessMutex,
            CALAIS_LOCK_TIMEOUT,
            DBGT("Waiting for final Service Thread quiescence: %1"),
            (LPCTSTR)NULL);
        m_hAccessMutex.Close();
    }

    if (m_hComPipe.IsValid())
    {
        if (!DisconnectNamedPipe(m_hComPipe))
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Comm Responder could not disconnect Comm pipe:  %1"),
                GetLastError());
        }

        m_hComPipe.Close();
    }

    if (m_hOvrWait.IsValid())
        m_hOvrWait.Close();
    Clean();
}


/*++

Create:

    This method Establishes the named target.  Close or the destructor takes it
    away.

Arguments:

    szName supplies the name of the communication object to connect to.

Return Value:

    None

Throws:

    DWORDs containing the error code, should an error be encountered.

Author:

    Doug Barlow (dbarlow) 10/30/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComResponder::Create")

void
CComResponder::Create(
    LPCTSTR szName)
{
    LPCTSTR szPipeHdr = CalaisString(CALSTR_PIPEDEVICEHEADER);
    static DWORD s_nPipeNo = 0;
    static HKEY s_hCurrentKey = NULL;
    TCHAR szPipeNo[sizeof(s_nPipeNo)*2 + 1];    // Twice as many hex digits + zero

    try
    {
        DWORD cbPipeHeader = lstrlen(szPipeHdr) * sizeof(TCHAR);
        DWORD dwLen;
        DWORD dwError;

        dwLen = lstrlen(szName) * sizeof(TCHAR);
        m_bfPipeName.Presize(cbPipeHeader + dwLen + sizeof(szPipeNo));

        if (s_hCurrentKey == NULL)
        {
            HKEY  hKey;

            //
            // Open the key to the Calais tree.
            //
            dwError = RegOpenKeyEx(
                           HKEY_LOCAL_MACHINE,
                           CalaisString(CALSTR_CALAISREGISTRYKEY),
                           0,                       // options (ignored)
                           KEY_WRITE,               // KEY_SET_VALUE | KEY_CREATE_SUB_KEY
                           &hKey
                           );
            if (ERROR_SUCCESS != dwError)
            {
                CalaisError(__SUBROUTINE__, 104, dwError);
                throw dwError;
            }

            //
            // Create a new  key (or open existing one).
            //
            dwError = RegCreateKeyEx(
                            hKey,
                            _T("Current"),
                            0,
                            0,
                            REG_OPTION_VOLATILE, // options
                            KEY_SET_VALUE,       // desired access
                            NULL,
                            &s_hCurrentKey,
                            NULL);

            RegCloseKey(hKey);

            if (ERROR_SUCCESS != dwError)
            {
                CalaisError(__SUBROUTINE__, 103, dwError);
                throw dwError;
            }
        }

        //
        // Build the pipe ACL.
        //

        ASSERT(!m_hComPipe.IsValid());
        m_aclPipe.InitializeFromProcessToken();
        m_aclPipe.AllowOwner(
            GENERIC_READ | GENERIC_WRITE | GENERIC_ALL);
        m_aclPipe.Allow(
            &m_aclPipe.SID_Local,
            (FILE_GENERIC_WRITE | FILE_GENERIC_READ)
            & ~FILE_CREATE_PIPE_INSTANCE);
        m_aclPipe.Allow(
            &m_aclPipe.SID_System,
            (FILE_GENERIC_WRITE | FILE_GENERIC_READ)
            & ~FILE_CREATE_PIPE_INSTANCE);


        for (;;)
        {
                //
                // Build the pipe name.
                //
            _itot(s_nPipeNo, szPipeNo, 16);

            m_bfPipeName.Set((LPCBYTE)szPipeHdr, cbPipeHeader);
            m_bfPipeName.Append((LPCBYTE)szName, dwLen);
            m_bfPipeName.Append((LPCBYTE)szPipeNo, sizeof(szPipeNo));

            //
            // Build the Pipe (First instance)
            //

            m_hComPipe = CreateNamedPipe(
                            (LPCTSTR)m_bfPipeName.Access(),
                            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED | FILE_FLAG_FIRST_PIPE_INSTANCE,
                            PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
                            PIPE_UNLIMITED_INSTANCES,
                            CALAIS_COMM_MSGLEN,
                            CALAIS_COMM_MSGLEN,
                            CALCOM_PIPE_TIMEOUT,
                            m_aclPipe);
            if (!m_hComPipe.IsValid())
            {
                dwError = m_hComPipe.GetLastError();
                if (dwError == ERROR_ACCESS_DENIED)
                {
                    s_nPipeNo++;
                    continue;
                }
                CalaisError(__SUBROUTINE__, 109, dwError);
                throw dwError;
            }
            else
                break;
        }

        dwError = RegSetValueEx(
                       s_hCurrentKey,
                       NULL,           // Use key's unnamed value
                       0,
                       REG_DWORD,
                       (LPBYTE) &s_nPipeNo,
                       sizeof(DWORD));
        if (ERROR_SUCCESS != dwError)
        {
            CalaisError(__SUBROUTINE__, 102, dwError);
            throw dwError;
        }

        //
        // Prepare the overlapped structure.
        //

        m_hOvrWait = m_ovrlp.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!m_hOvrWait.IsValid())
        {
            DWORD dwErr = m_hOvrWait.GetLastError();
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Comm Responder failed to create overlapped event: %1"),
                dwErr);
            throw dwErr;
        }
    }

    catch (...)
    {
        CalaisError(__SUBROUTINE__, 110);
        Clear();
        throw;
    }

}


/*++

Listen:

    This method listens on the previously created Communication channel for an
    incoming connection request.  When one comes in, it establishes a containing
    CComChannel object for it, and returns it.  To disconnect the comm channel,
    just delete the returned CComChannel object.

Arguments:

    None

Return Value:

    The CComChannel established.

Throws:

    DWORDs containing any error codes encountered.

Author:

    Doug Barlow (dbarlow) 10/30/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CComResponder::Listen")

CComChannel *
CComResponder::Listen(
    void)
{
    CComChannel *pChannel = NULL;

    for (;;)
    {
        CHandleObject hComPipe(DBGT("Comm Pipe handle from CComResponder::Listen"));

        try
        {
            BOOL fSts;


            //
            // Wait for an incoming connect request.
            //

RetryConnect:
            fSts = ConnectNamedPipe(m_hComPipe, &m_ovrlp);
            if (!fSts)
            {
                BOOL fErrorProcessed;
                DWORD dwSts = GetLastError();
                DWORD dwSize;
                DWORD dwWait;

                do
                {
                    fErrorProcessed = TRUE;
                    switch (dwSts)
                    {
                    //
                    // Block until something happens.
                    case ERROR_IO_PENDING:
                        dwWait = WaitForAnyObject(
                                    INFINITE,
                                    m_ovrlp.hEvent,
                                    g_hCalaisShutdown,
                                    NULL);
                        switch (dwWait)
                        {
                        case 1: // We've got a connect request
                            fErrorProcessed = FALSE;
                            fSts = GetOverlappedResult(
                                        m_hComPipe,
                                        &m_ovrlp,
                                        &dwSize,
                                        TRUE);
                            dwSts = fSts ? ERROR_SUCCESS : GetLastError();
                            break;
                        case 2: // Application shutdown
                            throw (DWORD)SCARD_P_SHUTDOWN;
                            break;
                        default:
                            CalaisWarning(
                                __SUBROUTINE__,
                                DBGT("Wait for connect pipe returned invalid value"));
                            throw (DWORD)SCARD_F_INTERNAL_ERROR;
                        }
                        break;

                    //
                    // Success after a wait event.
                    case ERROR_SUCCESS:
                        break;

                    //
                    // Non-error.  Just ignore it.
                    case ERROR_PIPE_CONNECTED:
                        break;

                    //
                    // The client has closed its end 
                    case ERROR_NO_DATA:
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("ConnectNamedPipe returned ERROR_NO_DATA, disconnecting and retrying"));
                        DisconnectNamedPipe(m_hComPipe);
                        goto RetryConnect;

                    //
                    // Unexpected error.  Report it.
                    default:
                        CalaisError(__SUBROUTINE__, 108, dwSts);
                        throw dwSts;
                    }
                } while (!fErrorProcessed);
            }


            //
            // Kick off another Pipe instance for the next request.
            //


            hComPipe = m_hComPipe.Relinquish();
            // m_hComPipe = INVALID_HANDLE_VALUE;
            m_hComPipe = CreateNamedPipe(
                            (LPCTSTR)m_bfPipeName.Access(),
                            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                            PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
                            PIPE_UNLIMITED_INSTANCES,
                            CALAIS_COMM_MSGLEN,
                            CALAIS_COMM_MSGLEN,
                            CALCOM_PIPE_TIMEOUT,
                            m_aclPipe);
            if (!m_hComPipe.IsValid())
            {
                DWORD dwErr = m_hComPipe.GetLastError();
                CalaisError(__SUBROUTINE__, 105, dwErr);
                throw dwErr;
            }


            //
            // Handle the connect request data.
            //


            pChannel = new CComChannel(hComPipe);
            if (NULL == pChannel)
            {
                DWORD dwSts = SCARD_E_NO_MEMORY;
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Com Responder could not allocate a Comm Channel:  %1"),
                    dwSts);
                throw dwSts;
            }
            hComPipe.Relinquish();
            break;
        }

        catch (...)
        {
            if (NULL != pChannel)
            {
                delete pChannel;
                pChannel = NULL;
            }
            if (hComPipe.IsValid())
                hComPipe.Close();
            throw;
        }
    }

    return pChannel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\inc\calcom.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    CalCom

Abstract:

    This header file describes the classes used to implement communication
    between the Calais API DLL and the Calais Service Manager Server.

Author:

    Doug Barlow (dbarlow) 10/30/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _CALCOM_H_
#define _CALCOM_H_

#include <winSCard.h>
#include <CalaisLb.h>

#define CALAIS_COMM_V1_00          0 // Version identifier for communications
#define CALAIS_COMM_V2_02 0x00020002 // 2.2 Designation
#define CALAIS_COMM_CURRENT   CALAIS_COMM_V2_02
#define CALAIS_LOCK_TIMEOUT    20000 // Milliseconds to wait before a lock is
                                     // declared dead.
#define CALAIS_THREAD_TIMEOUT  30000 // Milliseconds to wait before a thread is
                                     // declared dead.
#define CALAIS_COMM_MSGLEN       512 // Expected reasonable size of a message

#include "Locks.h"

class CComInitiator;
class CComResponder;

extern HANDLE g_hCalaisShutdown;    // We declare it here, since we don't know
                                    // if it comes from the client or server.

extern DWORD StartCalaisService(void);
extern HANDLE AccessStartedEvent(void);
extern HANDLE AccessStoppedEvent(void);
extern HANDLE AccessNewReaderEvent(void);
extern void ReleaseStartedEvent(void);
extern void ReleaseStoppedEvent(void);
extern void ReleaseNewReaderEvent(void);
extern void ReleaseAllEvents(void);
extern "C" DWORD WINAPI ServiceMonitor(LPVOID pvParameter);


//
// An INTERCHANGEHANDLE is an internal identifier for communications between
// the client and server.  It isn't exposed to users.  For now, it's a simple
// 32-bit unsigned index value.
//

typedef DWORD INTERCHANGEHANDLE;


//
//==============================================================================
//
//  CComChannel
//

class CComChannel
{
public:

    //  Constructors & Destructor
    ~CComChannel();

    //  Properties

    //  Methods
    DWORD Send(LPCVOID pvData, DWORD cbLen);
    void Receive(LPVOID pvData, DWORD cbLen);
    HANDLE Process(void) const
    { return m_hProc; };
    void Process(HANDLE hProc)
    { ASSERT(!m_hProc.IsValid());
      m_hProc = hProc; };

    //  Operators

protected:

    // Internal comm structures
    typedef struct
    {
        DWORD dwSync;
        DWORD dwVersion;
    } CONNECT_REQMSG;    // Connect request message.

    typedef struct
    {
        DWORD dwStatus;
        DWORD dwVersion;
    } CONNECT_RSPMSG;   // Connect response message.

    //  Constructors & Destructor
    CComChannel(HANDLE hPipe);

    //  Properties
    CHandleObject m_hPipe;
    CHandleObject m_hProc;
    CHandleObject m_hOvrWait;
    OVERLAPPED m_ovrlp;

    //  Methods

    // Friends
    friend class CComInitiator;
    friend class CComResponder;
    friend DWORD WINAPI ServiceMonitor(LPVOID pvParameter);
};


//
//==============================================================================
//
//  CComInitiator
//

class CComInitiator
{
public:

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CComChannel *Initiate(LPCTSTR szName, LPDWORD pdwVersion) const;

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
//==============================================================================
//
//  CComResponder
//

class CComResponder
{
public:

    //  Constructors & Destructor
    CComResponder();
    ~CComResponder();

    //  Properties

    //  Methods
    void Create(LPCTSTR szName);
    CComChannel *Listen(void);

    //  Operators

protected:
    //  Properties
    CHandleObject m_hComPipe;
    CHandleObject m_hAccessMutex;
    CBuffer m_bfPipeName;
    CSecurityDescriptor m_aclPipe;
    OVERLAPPED m_ovrlp;
    CHandleObject m_hOvrWait;

    //  Methods
    void Clean(void);
    void Clear(void);
};


//
//==============================================================================
//
//  CComObject and derivatives.
//

class CComObject
{
public:
    typedef enum
    {
        EstablishContext_request = 0,
        EstablishContext_response,
        ReleaseContext_request,
        ReleaseContext_response,
        IsValidContext_request,
        IsValidContext_response,
#if 0
        ListReaderGroups_request,
        ListReaderGroups_response,
#endif
        ListReaders_request,
        ListReaders_response,
#if 0
        ListCards_request,
        ListCards_response,
        ListInterfaces_request,
        ListInterfaces_response,
        GetProviderId_request,
        GetProviderId_response,
        IntroduceReaderGroup_request,
        IntroduceReaderGroup_response,
        ForgetReaderGroup_request,
        ForgetReaderGroup_response,
        IntroduceReader_request,
        IntroduceReader_response,
        ForgetReader_request,
        ForgetReader_response,
        AddReaderToGroup_request,
        AddReaderToGroup_response,
        RemoveReaderFromGroup_request,
        RemoveReaderFromGroup_response,
        IntroduceCardType_request,
        IntroduceCardType_response,
        ForgetCardType_request,
        ForgetCardType_response,
        FreeMemory_request,
        FreeMemory_response,
#endif
        LocateCards_request,
        LocateCards_response,
        GetStatusChange_request,
        GetStatusChange_response,
#if 0
        Cancel_request,
        Cancel_response,
#endif
        Connect_request,
        Connect_response,
        Reconnect_request,
        Reconnect_response,
        Disconnect_request,
        Disconnect_response,
        BeginTransaction_request,
        BeginTransaction_response,
        EndTransaction_request,
        EndTransaction_response,
        Status_request,
        Status_response,
        Transmit_request,
        Transmit_response,
        OpenReader_request,
        OpenReader_response,
        Control_request,
        Control_response,
        GetAttrib_request,
        GetAttrib_response,
        SetAttrib_request,
        SetAttrib_response,
        OutofRange
    } COMMAND_ID;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
    } CObjGeneric_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjGeneric_response;
    typedef struct
    {
        DWORD
            dwOffset,
            dwLength;
    } Desc;
    static const DWORD
        AUTOCOUNT,      // Append symbol to force computing string length.
        MULTISTRING;    // Append symbol to force computing multistring length.

    //  Constructors & Destructor
    CComObject();
    virtual ~CComObject() { /* Mandatory Base Class Destructor */ };

    //  Properties

    //  Methods
#ifdef DBG
    void dbgCheck(void) const;
#define ComObjCheck dbgCheck()
#else
#define ComObjCheck
#endif
    static CComObject *
    ReceiveComObject(       // Spit out the type of Com Object coming in.
        CComChannel *pChannel);
    CObjGeneric_response *Receive(CComChannel *pChannel);
    DWORD Send(CComChannel *pChannel);
    LPBYTE Request(void) const
    { return m_bfRequest.Access(); };
    LPBYTE Response(void) const
    { return m_bfResponse.Access(); };
    LPBYTE Data(void) const
    {
        ComObjCheck;
        return m_pbfActive->Access();
    };
    DWORD Length(void) const
    {
        ComObjCheck;
        return m_pbfActive->Length();
    };
    COMMAND_ID Type(void) const
    {
        ComObjCheck;
        return (COMMAND_ID)(*(LPDWORD)Data());
    };
    void Presize(DWORD cbSize)
    {
        ComObjCheck;
        m_pbfActive->Presize(cbSize);
    };
    LPVOID Prep(Desc &dsc, DWORD cbLength);
    LPBYTE Append(Desc &dsc, LPCGUID rgguid, DWORD cguid)
    { return Append(dsc, (LPCBYTE)rgguid, cguid * sizeof(GUID)); };
    LPBYTE Append(Desc &dsc, LPCTSTR szString, DWORD cchLen = AUTOCOUNT);
    LPBYTE Append(Desc &dsc, LPCBYTE pbData, DWORD cbLength);
    LPCVOID Parse(Desc &dsc, LPDWORD pcbLen = NULL);

    //  Operators

protected:
    //  Properties
    CBuffer *m_pbfActive;
    CBuffer m_bfRequest;
    CBuffer m_bfResponse;

    //  Methods
    void InitStruct(DWORD dwCommandId, DWORD dwDataOffset, DWORD dwExtra);

    // Friends
    friend CComObject * ReceiveComObject(HANDLE hFile);
};


//
////////////////////////////////////////////////////////////////////////////////
//
//  Service Manager Access Services
//
//      The following services are used to manage user and terminal contexts for
//      smartcards.
//
//      The first few fields are very specific.  For request structures they
//      must be:
//
//          DWORD
//              dwCommandId,
//              dwTotalLength,
//              dwDataOffset;
//
//      and for response structures they must be:
//
//          DWORD
//              dwCommandId,
//              dwTotalLength,
//              dwDataOffset,
//              dwStatus;
//
//      As defined for CObjGeneric_request and CObjGeneric_response,
//      respectively.
//

//
// ComEstablishContext
//

class ComEstablishContext
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        DWORD dwProcId;
        UINT64 hptrCancelEvent;
    } CObjEstablishContext_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscCancelEvent;
    } CObjEstablishContext_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjEstablishContext_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            EstablishContext_request,
            sizeof(CObjEstablishContext_request),
            dwExtraLen);
        return (CObjEstablishContext_request *)Data();
    };
    CObjEstablishContext_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            EstablishContext_response,
            sizeof(CObjEstablishContext_response),
            dwExtraLen);
        return (CObjEstablishContext_response *)Data();
    };
    CObjEstablishContext_response *Receive(CComChannel *pChannel)
    {
        return (CObjEstablishContext_response *)CComObject::Receive(pChannel);
    };


    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComReleaseContext
//

class ComReleaseContext
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
    } CObjReleaseContext_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjReleaseContext_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjReleaseContext_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ReleaseContext_request,
            sizeof(CObjReleaseContext_request),
            dwExtraLen);
        return (CObjReleaseContext_request *)Data();
    };
    CObjReleaseContext_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ReleaseContext_response,
            sizeof(CObjReleaseContext_response),
            dwExtraLen);
        return (CObjReleaseContext_response *)Data();
    };
    CObjReleaseContext_response *Receive(CComChannel *pChannel)
    {
        return (CObjReleaseContext_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComIsValidContext
//

class ComIsValidContext
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
    } CObjIsValidContext_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjIsValidContext_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjIsValidContext_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            IsValidContext_request,
            sizeof(CObjIsValidContext_request),
            dwExtraLen);
        return (CObjIsValidContext_request *)Data();
    };
    CObjIsValidContext_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            IsValidContext_response,
            sizeof(CObjIsValidContext_response),
            dwExtraLen);
        return (CObjIsValidContext_response *)Data();
    };
    CObjIsValidContext_response *Receive(CComChannel *pChannel)
    {
        return (CObjIsValidContext_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Services
//
//      The following services supply means for tracking cards within readers.
//

//
// ComLocateCards
//

class ComLocateCards
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscAtrs;           // ATR strings w/ leading byte length.
        Desc dscAtrMasks;       // ATR Masks w/ leading byte length.
        Desc dscReaders;        // mszReaders as device names
        Desc dscReaderStates;   // rgdwReaderStates
    } CObjLocateCards_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscReaderStates;   // rgdwReaderStates
        Desc dscAtrs;           // ATR strings w/ leading byte length.
    } CObjLocateCards_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjLocateCards_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            LocateCards_request,
            sizeof(CObjLocateCards_request),
            dwExtraLen);
        return (CObjLocateCards_request *)Data();
    };
    CObjLocateCards_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            LocateCards_response,
            sizeof(CObjLocateCards_response),
            dwExtraLen);
        return (CObjLocateCards_response *)Data();
    };
    CObjLocateCards_response *Receive(CComChannel *pChannel)
    {
        return (CObjLocateCards_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComGetStatusChange
//

class ComGetStatusChange
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        DWORD dwTimeout;
        Desc dscReaders;        // mszReaders as device names.
        Desc dscReaderStates;   // rgdwReaderStates
    } CObjGetStatusChange_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscReaderStates;   // rgdwReaderStates
        Desc dscAtrs;           // ATR strings w/ leading byte length.
    } CObjGetStatusChange_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjGetStatusChange_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            GetStatusChange_request,
            sizeof(CObjGetStatusChange_request),
            dwExtraLen);
        return (CObjGetStatusChange_request *)Data();
    };
    CObjGetStatusChange_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            GetStatusChange_response,
            sizeof(CObjGetStatusChange_response),
            dwExtraLen);
        return (CObjGetStatusChange_response *)Data();
    };
    CObjGetStatusChange_response *Receive(CComChannel *pChannel)
    {
        return (CObjGetStatusChange_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
////////////////////////////////////////////////////////////////////////////////
//
//  Card/Reader Access Services
//
//      The following services provide means for establishing communication with
//      the card.
//

//
// ComConnect
//

class ComConnect
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        DWORD dwShareMode;
        DWORD dwPreferredProtocols;
        Desc dscReader;     // szReader
    } CObjConnect_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        INTERCHANGEHANDLE hCard;
        DWORD dwActiveProtocol;
    } CObjConnect_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjConnect_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            Connect_request,
            sizeof(CObjConnect_request),
            dwExtraLen);
        return (CObjConnect_request *)Data();
    };
    CObjConnect_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            Connect_response,
            sizeof(CObjConnect_response),
            dwExtraLen);
        return (CObjConnect_response *)Data();
    };
    CObjConnect_response *Receive(CComChannel *pChannel)
    {
        return (CObjConnect_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComReconnect
//

class ComReconnect
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
        DWORD dwShareMode;
        DWORD dwPreferredProtocols;
        DWORD dwInitialization;
    } CObjReconnect_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        DWORD dwActiveProtocol;
    } CObjReconnect_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjReconnect_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            Reconnect_request,
            sizeof(CObjReconnect_request),
            dwExtraLen);
        return (CObjReconnect_request *)Data();
    };
    CObjReconnect_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            Reconnect_response,
            sizeof(CObjReconnect_response),
            dwExtraLen);
        return (CObjReconnect_response *)Data();
    };
    CObjReconnect_response *Receive(CComChannel *pChannel)
    {
        return (CObjReconnect_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComDisconnect
//

class ComDisconnect
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
        DWORD dwDisposition;
    } CObjDisconnect_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjDisconnect_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjDisconnect_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            Disconnect_request,
            sizeof(CObjDisconnect_request),
            dwExtraLen);
        return (CObjDisconnect_request *)Data();
    };
    CObjDisconnect_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            Disconnect_response,
            sizeof(CObjDisconnect_response),
            dwExtraLen);
        return (CObjDisconnect_response *)Data();
    };
    CObjDisconnect_response *Receive(CComChannel *pChannel)
    {
        return (CObjDisconnect_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComBeginTransaction
//

class ComBeginTransaction
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
    } CObjBeginTransaction_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjBeginTransaction_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjBeginTransaction_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            BeginTransaction_request,
            sizeof(CObjBeginTransaction_request),
            dwExtraLen);
        return (CObjBeginTransaction_request *)Data();
    };
    CObjBeginTransaction_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            BeginTransaction_response,
            sizeof(CObjBeginTransaction_response),
            dwExtraLen);
        return (CObjBeginTransaction_response *)Data();
    };
    CObjBeginTransaction_response *Receive(CComChannel *pChannel)
    {
        return (CObjBeginTransaction_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComEndTransaction
//

class ComEndTransaction
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
        DWORD dwDisposition;
    } CObjEndTransaction_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjEndTransaction_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjEndTransaction_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            EndTransaction_request,
            sizeof(CObjEndTransaction_request),
            dwExtraLen);
        return (CObjEndTransaction_request *)Data();
    };
    CObjEndTransaction_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            EndTransaction_response,
            sizeof(CObjEndTransaction_response),
            dwExtraLen);
        return (CObjEndTransaction_response *)Data();
    };
    CObjEndTransaction_response *Receive(CComChannel *pChannel)
    {
        return (CObjEndTransaction_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComStatus
//

class ComStatus
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
    } CObjStatus_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        DWORD dwState;
        DWORD dwProtocol;
        Desc dscAtr;        // pbAtr
        Desc dscSysName;    // szReader
    } CObjStatus_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjStatus_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            Status_request,
            sizeof(CObjStatus_request),
            dwExtraLen);
        return (CObjStatus_request *)Data();
    };
    CObjStatus_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            Status_response,
            sizeof(CObjStatus_response),
            dwExtraLen);
        return (CObjStatus_response *)Data();
    };
    CObjStatus_response *Receive(CComChannel *pChannel)
    {
        return (CObjStatus_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComTransmit
//

class ComTransmit
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
        DWORD dwPciLength;
        DWORD dwRecvLength;
        Desc dscSendPci;    // pioSendPci
        Desc dscSendBuffer; // pbSendBuffer
    } CObjTransmit_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscRecvPci;    // pioRecvPci
        Desc dscRecvBuffer; // pbRecvBuffer
    } CObjTransmit_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjTransmit_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            Transmit_request,
            sizeof(CObjTransmit_request),
            dwExtraLen);
        return (CObjTransmit_request *)Data();
    };
    CObjTransmit_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            Transmit_response,
            sizeof(CObjTransmit_response),
            dwExtraLen);
        return (CObjTransmit_response *)Data();
    };
    CObjTransmit_response *Receive(CComChannel *pChannel)
    {
        return (CObjTransmit_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
////////////////////////////////////////////////////////////////////////////////
//
//  Reader Control Routines
//
//      The following services provide for direct, low-level manipulation of the
//      reader by the calling application allowing it control over the
//      attributes of the communications with the card.  This control is done
//      via an SCARD_ATTRIBUTES structure, which is defined as follows:
//

//
// ComOpenReader
//

class ComOpenReader
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscReader;     // szReader
    } CObjOpenReader_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        INTERCHANGEHANDLE hReader;
        DWORD dwState;
    } CObjOpenReader_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjOpenReader_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            OpenReader_request,
            sizeof(CObjOpenReader_request),
            dwExtraLen);
        return (CObjOpenReader_request *)Data();
    };
    CObjOpenReader_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            OpenReader_response,
            sizeof(CObjOpenReader_response),
            dwExtraLen);
        return (CObjOpenReader_response *)Data();
    };
    CObjOpenReader_response *Receive(CComChannel *pChannel)
    {
        return (CObjOpenReader_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComControl
//

class ComControl
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
        DWORD dwControlCode;
        DWORD dwOutLength;
        Desc dscInBuffer;       // lpInBuffer
    } CObjControl_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscOutBuffer;      // lpOutBuffer
    } CObjControl_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjControl_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            Control_request,
            sizeof(CObjControl_request),
            dwExtraLen);
        return (CObjControl_request *)Data();
    };
    CObjControl_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            Control_response,
            sizeof(CObjControl_response),
            dwExtraLen);
        return (CObjControl_response *)Data();
    };
    CObjControl_response *Receive(CComChannel *pChannel)
    {
        return (CObjControl_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComGetAttrib
//

class ComGetAttrib
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
        DWORD dwAttrId;
        DWORD dwOutLength;
    } CObjGetAttrib_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscAttr;       // pbAttr
    } CObjGetAttrib_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjGetAttrib_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            GetAttrib_request,
            sizeof(CObjGetAttrib_request),
            dwExtraLen);
        return (CObjGetAttrib_request *)Data();
    };
    CObjGetAttrib_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            GetAttrib_response,
            sizeof(CObjGetAttrib_response),
            dwExtraLen);
        return (CObjGetAttrib_response *)Data();
    };
    CObjGetAttrib_response *Receive(CComChannel *pChannel)
    {
        return (CObjGetAttrib_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComSetAttrib
//

class ComSetAttrib
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        INTERCHANGEHANDLE hCard;
        DWORD dwAttrId;
        Desc dscAttr;       // pbAttr
    } CObjSetAttrib_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjSetAttrib_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjSetAttrib_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            SetAttrib_request,
            sizeof(CObjSetAttrib_request),
            dwExtraLen);
        return (CObjSetAttrib_request *)Data();
    };
    CObjSetAttrib_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            SetAttrib_response,
            sizeof(CObjSetAttrib_response),
            dwExtraLen);
        return (CObjSetAttrib_response *)Data();
    };
    CObjSetAttrib_response *Receive(CComChannel *pChannel)
    {
        return (CObjSetAttrib_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
////////////////////////////////////////////////////////////////////////////////
//
//  Smartcard Database Management Services
//
//      The following services provide for managing the Smartcard Database.
//

//
// ComListReaders
//

class ComListReaders
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscReaders;     // mszReaders
    } CObjListReaders_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscReaders;    // rgfReaderActive
    } CObjListReaders_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjListReaders_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ListReaders_request,
            sizeof(CObjListReaders_request),
            dwExtraLen);
        return (CObjListReaders_request *)Data();
    };
    CObjListReaders_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ListReaders_response,
            sizeof(CObjListReaders_response),
            dwExtraLen);
        return (CObjListReaders_response *)Data();
    };
    CObjListReaders_response *Receive(CComChannel *pChannel)
    {
        return (CObjListReaders_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


#if 0
//
// ComListReaderGroups
//

class ComListReaderGroups
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
    } CObjListReaderGroups_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscGroups;     // mszGroups
    } CObjListReaderGroups_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjListReaderGroups_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ListReaderGroups_request,
            sizeof(CObjListReaderGroups_request),
            dwExtraLen);
        return (CObjListReaderGroups_request *)Data();
    };
    CObjListReaderGroups_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ListReaderGroups_response,
            sizeof(CObjListReaderGroups_response),
            dwExtraLen);
        return (CObjListReaderGroups_response *)Data();
    };
    CObjListReaderGroups_response *Receive(CComChannel *pChannel)
    {
        return (CObjListReaderGroups_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComListCards
//

class ComListCards
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscAtr;        // pbAtr
        Desc dscInterfaces; // pguidInterfaces
    } CObjListCards_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscCards;      // mszCards
    } CObjListCards_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjListCards_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ListCards_request,
            sizeof(CObjListCards_request),
            dwExtraLen);
        return (CObjListCards_request *)Data();
    };
    CObjListCards_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ListCards_response,
            sizeof(CObjListCards_response),
            dwExtraLen);
        return (CObjListCards_response *)Data();
    };
    CObjListCards_response *Receive(CComChannel *pChannel)
    {
        return (CObjListCards_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComListInterfaces
//

class ComListInterfaces
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscCard;       // szCard
    } CObjListInterfaces_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscInterfaces; // pguidInterfaces
    } CObjListInterfaces_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjListInterfaces_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ListInterfaces_request,
            sizeof(CObjListInterfaces_request),
            dwExtraLen);
        return (CObjListInterfaces_request *)Data();
    };
    CObjListInterfaces_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ListInterfaces_response,
            sizeof(CObjListInterfaces_response),
            dwExtraLen);
        return (CObjListInterfaces_response *)Data();
    };
    CObjListInterfaces_response *Receive(CComChannel *pChannel)
    {
        return (CObjListInterfaces_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComGetProviderId
//

class ComGetProviderId
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscCard;       // szCard
    } CObjGetProviderId_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        Desc dscProviderId; // pguidProviderId
    } CObjGetProviderId_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjGetProviderId_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            GetProviderId_request,
            sizeof(CObjGetProviderId_request),
            dwExtraLen);
        return (CObjGetProviderId_request *)Data();
    };
    CObjGetProviderId_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            GetProviderId_response,
            sizeof(CObjGetProviderId_response),
            dwExtraLen);
        return (CObjGetProviderId_response *)Data();
    };
    CObjGetProviderId_response *Receive(CComChannel *pChannel)
    {
        return (CObjGetProviderId_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComIntroduceReaderGroup
//

class ComIntroduceReaderGroup
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscGroupName;  // szGroupName
    } CObjIntroduceReaderGroup_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjIntroduceReaderGroup_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjIntroduceReaderGroup_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            IntroduceReaderGroup_request,
            sizeof(CObjIntroduceReaderGroup_request),
            dwExtraLen);
        return (CObjIntroduceReaderGroup_request *)Data();
    };
    CObjIntroduceReaderGroup_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            IntroduceReaderGroup_response,
            sizeof(CObjIntroduceReaderGroup_response),
            dwExtraLen);
        return (CObjIntroduceReaderGroup_response *)Data();
    };
    CObjIntroduceReaderGroup_response *Receive(CComChannel *pChannel)
    {
        return (CObjIntroduceReaderGroup_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComForgetReaderGroup
//

class ComForgetReaderGroup
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscGroupName;  // szGroupName
    } CObjForgetReaderGroup_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjForgetReaderGroup_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjForgetReaderGroup_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ForgetReaderGroup_request,
            sizeof(CObjForgetReaderGroup_request),
            dwExtraLen);
        return (CObjForgetReaderGroup_request *)Data();
    };
    CObjForgetReaderGroup_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ForgetReaderGroup_response,
            sizeof(CObjForgetReaderGroup_response),
            dwExtraLen);
        return (CObjForgetReaderGroup_response *)Data();
    };
    CObjForgetReaderGroup_response *Receive(CComChannel *pChannel)
    {
        return (CObjForgetReaderGroup_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComIntroduceReader
//

class ComIntroduceReader
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscReaderName; // szReaderName
        Desc dscDeviceName; // szDeviceName
    } CObjIntroduceReader_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjIntroduceReader_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjIntroduceReader_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            IntroduceReader_request,
            sizeof(CObjIntroduceReader_request),
            dwExtraLen);
        return (CObjIntroduceReader_request *)Data();
    };
    CObjIntroduceReader_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            IntroduceReader_response,
            sizeof(CObjIntroduceReader_response),
            dwExtraLen);
        return (CObjIntroduceReader_response *)Data();
    };
    CObjIntroduceReader_response *Receive(CComChannel *pChannel)
    {
        return (CObjIntroduceReader_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComForgetReader
//

class ComForgetReader
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscReaderName; // szReaderName
    } CObjForgetReader_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjForgetReader_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjForgetReader_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ForgetReader_request,
            sizeof(CObjForgetReader_request),
            dwExtraLen);
        return (CObjForgetReader_request *)Data();
    };
    CObjForgetReader_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ForgetReader_response,
            sizeof(CObjForgetReader_response),
            dwExtraLen);
        return (CObjForgetReader_response *)Data();
    };
    CObjForgetReader_response *Receive(CComChannel *pChannel)
    {
        return (CObjForgetReader_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComAddReaderToGroup
//

class ComAddReaderToGroup
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscReaderName; // szReaderName
        Desc dscGroupName;  // szGroupName
    } CObjAddReaderToGroup_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjAddReaderToGroup_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjAddReaderToGroup_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            AddReaderToGroup_request,
            sizeof(CObjAddReaderToGroup_request),
            dwExtraLen);
        return (CObjAddReaderToGroup_request *)Data();
    };
    CObjAddReaderToGroup_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            AddReaderToGroup_response,
            sizeof(CObjAddReaderToGroup_response),
            dwExtraLen);
        return (CObjAddReaderToGroup_response *)Data();
    };
    CObjAddReaderToGroup_response *Receive(CComChannel *pChannel)
    {
        return (CObjAddReaderToGroup_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComRemoveReaderFromGroup
//

class ComRemoveReaderFromGroup
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscReaderName; // szReaderName
        Desc dscGroupName;  // szGroupName
    } CObjRemoveReaderFromGroup_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjRemoveReaderFromGroup_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjRemoveReaderFromGroup_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            RemoveReaderFromGroup_request,
            sizeof(CObjRemoveReaderFromGroup_request),
            dwExtraLen);
        return (CObjRemoveReaderFromGroup_request *)Data();
    };
    CObjRemoveReaderFromGroup_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            RemoveReaderFromGroup_response,
            sizeof(CObjRemoveReaderFromGroup_response),
            dwExtraLen);
        return (CObjRemoveReaderFromGroup_response *)Data();
    };
    CObjRemoveReaderFromGroup_response *Receive(CComChannel *pChannel)
    {
        return (CObjRemoveReaderFromGroup_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComIntroduceCardType
//

class ComIntroduceCardType
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscCardName;   // szCardName
        Desc dscPrimaryProvider;    // pguidPrimaryProvider
        Desc dscInterfaces; // rgguidInterfaces
        Desc dscAtr;        // pbAtr
        Desc dscAtrMask;    // pbAtrMask
    } CObjIntroduceCardType_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjIntroduceCardType_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjIntroduceCardType_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            IntroduceCardType_request,
            sizeof(CObjIntroduceCardType_request),
            dwExtraLen);
        return (CObjIntroduceCardType_request *)Data();
    };
    CObjIntroduceCardType_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            IntroduceCardType_response,
            sizeof(CObjIntroduceCardType_response),
            dwExtraLen);
        return (CObjIntroduceCardType_response *)Data();
    };
    CObjIntroduceCardType_response *Receive(CComChannel *pChannel)
    {
        return (CObjIntroduceCardType_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComForgetCardType
//

class ComForgetCardType
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
        Desc dscCardName;   // szCardName
    } CObjForgetCardType_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjForgetCardType_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjForgetCardType_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            ForgetCardType_request,
            sizeof(CObjForgetCardType_request),
            dwExtraLen);
        return (CObjForgetCardType_request *)Data();
    };
    CObjForgetCardType_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            ForgetCardType_response,
            sizeof(CObjForgetCardType_response),
            dwExtraLen);
        return (CObjForgetCardType_response *)Data();
    };
    CObjForgetCardType_response *Receive(CComChannel *pChannel)
    {
        return (CObjForgetCardType_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};
#endif


//
////////////////////////////////////////////////////////////////////////////////
//
//  Service Manager Support Routines
//
//      The following services are supplied to simplify the use of the Service
//      Manager API.
//

#if 0
//
// ComCancel
//

class ComCancel
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset;
    } CObjCancel_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjCancel_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjCancel_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            Cancel_request,
            sizeof(CObjCancel_request),
            dwExtraLen);
        return (CObjCancel_request *)Data();
    };
    CObjCancel_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            Cancel_response,
            sizeof(CObjCancel_response),
            dwExtraLen);
        return (CObjCancel_response *)Data();
    };
    CObjCancel_response *Receive(CComChannel *pChannel)
    {
        return (CObjCancel_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};


//
// ComFreeMemory
//

class ComFreeMemory
:   public CComObject
{
public:
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
        LPVOID pvMem;
    } CObjFreeMemory_request;
    typedef struct
    {
        DWORD
            dwCommandId,
            dwTotalLength,
            dwDataOffset,
            dwStatus;
    } CObjFreeMemory_response;

    //  Constructors & Destructor
    //  Properties

    //  Methods
    CObjFreeMemory_request *InitRequest(DWORD dwExtraLen)
    {
        InitStruct(
            FreeMemory_request,
            sizeof(CObjFreeMemory_request),
            dwExtraLen);
        return (CObjFreeMemory_request *)Data();
    };
    CObjFreeMemory_response *InitResponse(DWORD dwExtraLen)
    {
        InitStruct(
            FreeMemory_response,
            sizeof(CObjFreeMemory_response),
            dwExtraLen);
        return (CObjFreeMemory_response *)Data();
    };
    CObjFreeMemory_response *Receive(CComChannel *pChannel)
    {
        return (CObjFreeMemory_response *)CComObject::Receive(pChannel);
    };

    //  Operators

protected:
    //  Properties
    //  Methods
};
#endif
#endif // _CALCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\scardsvr\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF


$(O)\scardmsg.mc: $(PROJECT_ROOT)\published\scard\scarderr.mc scardmsg.mch
    copy $(PROJECT_ROOT)\published\scard\scarderr.mc + scardmsg.mch $@

$(O)\scardmsg.h $(O)\scardmsg.rc $(O)\msg00001.bin: $(O)\scardmsg.mc
    mc -r .\$(O) -h .\$(O) $(O)\scardmsg.mc

scardsvr.rc2: $(O)\scardmsg.rc

scardmsg.rc: $(O)\msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\inc\ctrllib.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    CtrlLib

Abstract:

    This header file describes the service startup and shutdown routines.

Author:

    Doug Barlow (dbarlow) 2/11/1997

Environment:

    Win32

Notes:

--*/

#ifndef _CTRLLIB_H_
#define _CTRLLIB_H_

#ifdef __cplusplus
extern "C" {
#endif

extern DWORD
InstallCalais(
    LPCTSTR szFile,
    LPCTSTR szUser,
    LPCTSTR szPasswd);

extern DWORD
StartCalais(
    LPCTSTR szFile,
    LPCTSTR szUser,
    LPCTSTR szPasswd);

extern DWORD
RestartCalais(
    LPCTSTR szFile,
    LPCTSTR szUser,
    LPCTSTR szPasswd);

extern DWORD
StopCalais(
    void);

#ifdef __cplusplus
}
#endif
#endif // _CTRLLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\inc\calmsgs.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    calmsgs

Abstract:

    This header file describes the symbols and macros used in the Calais Event
    Logging components.

Author:

    Doug Barlow (dbarlow) 5/15/1997

Environment:

    C++, Win32

Notes:

--*/

#ifndef _CALMSGS_H_
#define _CALMSGS_H_
#include <tchar.h>
#ifdef DBG
#include <eh.h>
#endif

#define CALSTR_CALAISEXECUTABLE          1    // "%windir%\\system32\\SCardSvr.exe"
#define CALSTR_PRIMARYSERVICE            2    // "SCardSvr"
#define CALSTR_LEGACYSERVICE             3    // "SCardDrv"
#define CALSTR_CALAISREGISTRYKEY         4    // "SOFTWARE\\Microsoft\\Cryptography\\Calais"
#define CALSTR_READERREGISTRYKEY         5    // "SOFTWARE\\Microsoft\\Cryptography\\Calais\\Readers"
#define CALSTR_SMARTCARDREGISTRYKEY      6    // "SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCards"
#define CALSTR_READERREGISTRYSUBKEY      7    // "Readers"
#define CALSTR_DEVICEREGISTRYSUBKEY      8    // "Device"
#define CALSTR_GROUPSREGISTRYSUBKEY      9    // "Groups"
#define CALSTR_ATRREGISTRYSUBKEY        10    // "ATR"
#define CALSTR_ATRMASKREGISTRYSUBKEY    11    // "ATRMask"
#define CALSTR_INTERFACESREGISTRYSUBKEY 12    // "Supported Interfaces"
#define CALSTR_PRIMARYPROVIDERSUBKEY    13    // "Primary Provider"
#define CALSTR_CRYPTOPROVIDERSUBKEY     14    // "Crypto Provider"
#define CALSTR_SERVICESREGISTRYKEY      15    // "SYSTEM\\CurrentControlSet\\Services"
#define CALSTR_EVENTLOGREGISTRYKEY      16    // "SYSTEM\\CurrentControlSet\\Services\\EventLog"
#define CALSTR_SYSTEMREGISTRYSUBKEY     17    // "System"
#define CALSTR_EVENTMESSAGEFILESUBKEY   18    // "EventMessageFile"
#define CALSTR_TYPESSUPPORTEDSUBKEY     19    // "TypesSupported"
#define CALSTR_PNPDEVICEREGISTRYKEY     20    // "SYSTEM\\CurrentControlSet\\Control\\DeviceClasses\\{50dd5230-ba8a-11d1-bf5d-0000f805f530}"
#define CALSTR_SYMBOLICLINKSUBKEY       21    // "SymbolicLink"
#define CALSTR_VXDPATHREGISTRYKEY       22    // "System\\CurrentControlSet\\Services\\VxD\\Smclib\\Devices"
#define CALSTR_LEGACYDEPENDONGROUP      23    // "+Smart Card Reader"
#define CALSTR_NEWREADEREVENTNAME       24    // "Global\\Microsoft Smart Card Resource Manager New Reader"
#define CALSTR_STARTEDEVENTNAME         25    // "Global\\Microsoft Smart Card Resource Manager Started"
#define CALSTR_CANCELEVENTPREFIX        26    // "Global\\Microsoft Smart Card Cancel Event for %1!d!"
#define CALSTR_COMMPIPENAME             27    // "Microsoft Smart Card Resource Manager"
#define CALSTR_LEGACYDEVICEHEADER       28    // "\\\\.\\"
#define CALSTR_LEGACYDEVICENAME         29    // "SCReader"
#define CALSTR_MAXLEGACYDEVICES         30    // "MaxLegacyDevices"
#define CALSTR_MAXDEFAULTBUFFER         31    // "MaxDefaultBuffer"
#define CALSTR_PIPEDEVICEHEADER         32    // "\\\\.\\pipe\\"
#define CALSTR_SERVICEDEPENDENCIES      33    // "PlugPlay\000"
#define CALSTR_SPECIALREADERHEADER      34    // "\\\\?PNP?\\"
#define CALSTR_ACTIVEREADERCOUNTREADER  35    // "NOTIFICATION"
#define CALSTR_CERTPROPREGISTRY         36    // "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify"
#define CALSTR_CERTPROPKEY              37    // "ScCertProp"
#define CALSTR_DLLNAME                  38    // "DLLName"
#define CALSTR_LOGON                    39    // "Logon"
#define CALSTR_LOGOFF                   40    // "Logoff"
#define CALSTR_LOCK                     41    // "Lock"
#define CALSTR_UNLOCK                   42    // "Unlock"
#define CALSTR_ENABLED                  43    // "Enabled"
#define CALSTR_IMPERSONATE              44    // "Impersonate"
#define CALSTR_ASYNCHRONOUS             45    // "Asynchronous"
#define CALSTR_CERTPROPDLL              46    // "WlNotify.dll"
#define CALSTR_CERTPROPSTART            47    // "SCardStartCertProp"
#define CALSTR_CERTPROPSTOP             48    // "SCardStopCertProp"
#define CALSTR_CERTPROPSUSPEND          49    // "SCardSuspendCertProp"
#define CALSTR_CERTPROPRESUME           50    // "SCardResumeCertProp"
#define CALSTR_SMARTCARDINSERTION       51    // "SmartcardInsertion"
#define CALSTR_SMARTCARDREMOVAL         52    // "SmartcardRemoval"
#define CALSTR_APPEVENTS                53    // "AppEvents"
#define CALSTR_EVENTLABELS              54    // "EventLabels"
#define CALSTR_DOT_DEFAULT              55    // ".Default"
#define CALSTR_DOT_CURRENT              56    // ".Current"
#define CALSTR_SOUNDSREGISTRY           57    // "Schemes\\Apps\\.Default"
#define CALSTR_LOGONREGISTRY            58    //  "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define CALSTR_LOGONREMOVEOPTION        59    //  "ScRemoveOption"
#define CALSTR_STOPPEDEVENTNAME         60    // "Global\\Microsoft Smart Card Resource Manager Stopped"

// Unused
//      CALSTR_TEMPLATEREGISTRYKEY      ?n?    // "SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCard Templates"
//      CALSTR_OEMCONFIGREGISTRYSUBKEY  ?n?    // "OEM Configuration"

// Debug only
#define CALSTR_DEBUGSERVICE             61    // "SCardDbg"
#define CALSTR_DEBUGREGISTRYSUBKEY      62    // "Debug"

#ifdef DBG
#define CALSTR_DEBUGLOGSUBKEY           63    // "Debug"
#define CALSTR_GUIWARNINGSUBKEY         64    // "GuiWarnings"
#define CALSTR_LOGSEVERITYSUBKEY        65    // "LogSeverity"
#define CALSTR_GUISEVERITYSUBKEY        66    // "GuiSeverity"
#define CALSTR_APITRACEFILENAME         67    // "C:\\SCard.log"
#define CALSTR_DRIVERTRACEFILENAME      68    // "C:\\Calais.log"
#define CALSTR_MESSAGETAG               69    // " *MESSAGE* "
#define CALSTR_INFOMESSAGETAG           70    // " *INFO* "
#define CALSTR_WARNINGMESSAGETAG        71    // " *WARNING* "
#define CALSTR_ERRORMESSAGETAG          72    // " *ERROR* "
#define CALSTR_DEBUGSERVICEDISPLAY      73    // "Smart Card Debug"
#define CALSTR_DEBUGSERVICEDESC         74    // "Start this service first to debug Smart card service startup"
#endif


// Internationalizable
#define CALSTR_RESOURCELIMIT           100    // String Ids larger than this are resources
#define CALSTR_PRIMARYSERVICEDISPLAY   CALSTR_RESOURCELIMIT + IDS_PRIMARYSERVICEDISPLAY // "Smart Card"
#define CALSTR_LEGACYSERVICEDISPLAY    CALSTR_RESOURCELIMIT + IDS_LEGACYSERVICEDISPLAY  // "Smart Card Helper"
#define CALSTR_SMARTCARD_INSERTION     CALSTR_RESOURCELIMIT + IDS_SMARTCARD_INSERTION   // "Smart Card Insertion"
#define CALSTR_SMARTCARD_REMOVAL       CALSTR_RESOURCELIMIT + IDS_SMARTCARD_REMOVAL     // "Smart Card Removal"
#define CALSTR_PRIMARYSERVICEDESC      CALSTR_RESOURCELIMIT + IDS_PRIMARYSERVICEDESC
#define CALSTR_LEGACYSERVICEDESC       CALSTR_RESOURCELIMIT + IDS_LEGACYSERVICEDESC

extern const LPCTSTR g_rgszDefaultStrings[];

extern void
CalaisMessageInit(
    LPCTSTR szTitle,
    HANDLE hEventLogger = NULL,
    BOOL fServer = FALSE);
extern void
CalaisMessageClose(
    void);
extern LPCTSTR
CalaisString(
    DWORD dwStringId);

#ifdef DBG

#define DBGT(x) _T(x)
#define DEBUG_TEXT LPCTSTR
#define CalaisDebug(a) _CalaisDebug a

extern void
CalaisInfo(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    LPCTSTR szParam1 = NULL,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL);
extern void
CalaisInfo(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    DWORD dwErrorCode,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL);
extern void
CalaisWarning(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    LPCTSTR szParam1 = NULL,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL);
extern void
CalaisWarning(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    DWORD dwErrorCode,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL);
extern void
CalaisError(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    LPCTSTR szParam1 = NULL,
    LPCTSTR szParam2 = NULL,
    DWORD dwLineNo = 0);
extern void
_CalaisDebug(
    DEBUG_TEXT szMessage,
    ...);
extern void
CalaisSetDebug(
    BOOLEAN Debug
    );
extern void
CalaisMessageLog(
    DEBUG_TEXT szSubroutine,
    WORD wSeverity,
    DEBUG_TEXT szMessageStr,
    DEBUG_TEXT *rgszParams = NULL,
    LPCVOID pvBinaryData = NULL,
    DWORD cbBinaryData = 0);
extern void
WriteApiLog(
    LPCVOID pvData,
    DWORD cbLength);

#else

#define DBGT(x) ((LPCBYTE)(0))
#define DEBUG_TEXT LPCBYTE
#define CalaisDebug(a)

inline void
CalaisInfo(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    LPCTSTR szParam1 = NULL,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL)
{}
inline void
CalaisInfo(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    DWORD dwErrorCode,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL)
{}
inline void
CalaisWarning(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    LPCTSTR szParam1 = NULL,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL)
{}
inline void
CalaisWarning(
    DEBUG_TEXT szSubroutine,
    DEBUG_TEXT szMessage,
    DWORD dwErrorCode,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL)
{}

#endif

extern void
CalaisError(
    DEBUG_TEXT szSubroutine,
    DWORD dwMessageId,
    DWORD dwErrorCode,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL);
extern void
CalaisError(
    DEBUG_TEXT szSubroutine,
    DWORD dwMessageId,
    LPCTSTR szParam1 = NULL,
    LPCTSTR szParam2 = NULL,
    LPCTSTR szParam3 = NULL);
extern void
CalaisMessageLog(
    DEBUG_TEXT szSubroutine,
    WORD wSeverity,
    DWORD dwMessageId,
    LPCTSTR *rgszParams = NULL,
    LPCVOID pvBinaryData = NULL,
    DWORD cbBinaryData = 0);

#ifndef ASSERT
#if defined(_DEBUG)
#define ASSERT(x) _ASSERTE(x)
#if !defined(DBG)
#define DBG
#endif
#elif defined(DBG)
#define ASSERT(x) if (!(x)) { \
        CalaisError(DBGT("Assert"), DBGT("Failed Assertion: %1 at %2(%3)"), #x, __FILE__, __LINE__); \
        DebugBreak(); }
#else
#define ASSERT(x)
#endif
#endif

#endif // _CALMSGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\inc\locks.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Locks

Abstract:

    The following three classes implement a simple single writer, multiple
    readers lock.  CAccessLock is the lock, then the CLockRead and CLockWrite
    objects envoke the lock while they are in scope.  They are all implemented
    inline.

    The CMultiEvent class implements an automatic waitable object that will
    release all threads waiting on it when signaled.

Author:

    Doug Barlow (dbarlow) 10/24/1996

Environment:

    Win32, C++ w/ exceptions

Notes:

    ?Notes?

--*/

#ifndef _LOCKS_H_
#define _LOCKS_H_

#include <WinSCard.h>
#include "CalMsgs.h"
#include <SCardLib.h>
#ifdef DBG
#define REASONABLE_TIME 2 * 60 * 1000   // Two minutes
#else
#define REASONABLE_TIME INFINITE
#endif

extern DWORD
WaitForAnyObject(
    DWORD dwTimeout,
    ...);

extern DWORD
WaitForAnObject(
    HANDLE hWaitOn,
    DWORD dwTimeout);

#ifdef DBG
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("WaitForEverObject")

inline void
WaitForEverObject(
    HANDLE hWaitOn,
    DWORD dwTimeout,
    DEBUG_TEXT szReason,
    LPCTSTR szObject = NULL)
{
    DWORD dwSts;
    while (ERROR_SUCCESS != (dwSts = WaitForAnObject(hWaitOn, dwTimeout)))
        CalaisWarning(__SUBROUTINE__, szReason, dwSts, szObject);
}
inline void
WaitForEverObject(
    HANDLE hWaitOn,
    DWORD dwTimeout,
    DEBUG_TEXT szReason,
    DWORD dwObject)
{
    DWORD dwSts;
    TCHAR szNum[16];

    wsprintf(szNum, TEXT("0x%08x"), dwObject);
    while (ERROR_SUCCESS != (dwSts = WaitForAnObject(hWaitOn, dwTimeout)))
        CalaisWarning(__SUBROUTINE__, szReason, dwSts, szNum);
}
#define WaitForever(hWaitOn, dwTimeout, szReason, szObject) \
    WaitForEverObject(hWaitOn, dwTimeout, szReason, szObject)

#else

inline void
WaitForEverObject(
    HANDLE hWaitOn)
{
    while (ERROR_SUCCESS != WaitForAnObject(hWaitOn, INFINITE));
        // Empty body
}
#define WaitForever(hWaitOn, dwTimeout, szReason, szObject) \
    WaitForEverObject(hWaitOn)

#endif


//
//  Critical Section Support.
//
//  The following Classes and Macros aid in debugging Critical Section
//  Conflicts.
//

//
// Critical section Ids.  Locks must be obtained in the order from lowest
// to highest.  An attempt to access a lower-numbered lock while holding a
// higher numbered lock will result in an ASSERT.
//

// Server side lock IDs
#define CSID_SERVICE_STATUS 0   // Service Status Critical Section
#define CSID_CONTROL_LOCK   1   // Lock for Calais control commands.
#define CSID_SERVER_THREADS 2   // Lock for server thread enumeration.
#define CSID_MULTIEVENT     3   // MultiEvent Critical Access Section
#define CSID_MUTEX          4   // Mutex critical access section
#define CSID_ACCESSCONTROL  5   // Access Lock control
#define CSID_TRACEOUTPUT    6   // Lock for tracing output.

// Client side lock IDs
#define CSID_USER_CONTEXT   0   // User context lock
#define CSID_SUBCONTEXT     1   // Subcontext lock


//
//==============================================================================
//
//  CCriticalSectionObject
//

class CCriticalSectionObject
{
public:

    //  Constructors & Destructor
    CCriticalSectionObject(DWORD dwCsid);
    ~CCriticalSectionObject();

    //  Properties
    //  Methods
    virtual void Enter(DEBUG_TEXT szOwner, DEBUG_TEXT szComment);
    virtual void Leave(void);
    virtual BOOL InitFailed(void) { return m_fInitFailed; }

#ifdef DBG
    LPCTSTR Description(void) const;

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CCriticalSectionObject::Owner")
    LPCTSTR Owner(void) const
        { return (LPCTSTR)m_bfOwner.Access(); };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CCriticalSectionObject::Comment")
    LPCTSTR Comment(void) const
        { return (LPCTSTR)m_bfComment.Access(); };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CCriticalSectionObject::IsOwnedByMe")
    BOOL IsOwnedByMe(void) const
        { return (GetCurrentThreadId() == m_dwOwnerThread); };
#endif
    //  Operators

protected:
    //  Properties
    CRITICAL_SECTION m_csLock;
    BOOL m_fInitFailed;
#ifdef DBG
    DWORD m_dwCsid;
    CBuffer m_bfOwner;
    CBuffer m_bfComment;
    DWORD m_dwOwnerThread;
    DWORD m_dwRecursion;
    DWORD m_dwArrayEntry;
    static CDynamicArray<CCriticalSectionObject> *mg_prgCSObjects;
    static CRITICAL_SECTION mg_csArrayLock;
#endif

    //  Methods
};


//
//==============================================================================
//
//  COwnCriticalSection
//

class COwnCriticalSection
{
public:

    //  Constructors & Destructor
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("COwnCriticalSection::COwnCriticalSection")
        COwnCriticalSection(
            CCriticalSectionObject *pcs,
            DEBUG_TEXT szSubroutine,
            DEBUG_TEXT szComment)
        {
            m_pcsLock = pcs;
            m_pcsLock->Enter(szSubroutine, szComment);
        };

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("COwnCriticalSection::~COwnCriticalSection")
    ~COwnCriticalSection()
    {
        m_pcsLock->Leave();
    };

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties
    CCriticalSectionObject *m_pcsLock;

    //  Methods
};

#define LockSection(cx, reason) \
        COwnCriticalSection csLock(cx, __SUBROUTINE__, reason)

#define LockSection2(cx, reason) \
        COwnCriticalSection csLock2(cx, __SUBROUTINE__, reason)

#ifndef DBG

//
//In-line the simple Critical Section calls.
//

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::CCriticalSectionObject")
inline
CCriticalSectionObject::CCriticalSectionObject(
    DWORD dwCsid)
{
    m_fInitFailed = FALSE;
    try {
        // Preallocate the event used by the EnterCriticalSection
        // function to prevent an exception from being thrown in
        // CCriticalSectionObject::Enter
        if (! InitializeCriticalSectionAndSpinCount(
                &m_csLock, 0x80000000))
            m_fInitFailed = TRUE;
    }
    catch (HRESULT hr) {
        m_fInitFailed = TRUE;
    }
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::~CCriticalSectionObject")
inline
CCriticalSectionObject::~CCriticalSectionObject()
{
    if (m_fInitFailed)
        return;

    DeleteCriticalSection(&m_csLock);
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::Enter")
inline void
CCriticalSectionObject::Enter(
    DEBUG_TEXT szOwner,
    DEBUG_TEXT szComment)
{
    if (m_fInitFailed)
        throw (DWORD)SCARD_E_NO_MEMORY;

    EnterCriticalSection(&m_csLock);
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CCriticalSectionObject::Leave")
inline void
CCriticalSectionObject::Leave(
    void)
{
    LeaveCriticalSection(&m_csLock);
}

#endif // !DBG


//
//==============================================================================
//
//  CHandleObject
//

class CHandleObject
{
public:

    //  Constructors & Destructor
    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::CHandleObject")
    CHandleObject(DEBUG_TEXT szName)
#ifdef DBG
    :   m_bfName((LPCBYTE)szName, (lstrlen(szName) + 1) * sizeof(TCHAR))
#endif
    {
        m_hHandle = NULL;
        m_dwError = ERROR_SUCCESS;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::~CHandleObject")
    ~CHandleObject()
    {
        if (IsValid())
        {
#ifdef _DEBUG
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Unclosed handle '%1' -- fixing."),
                (DEBUG_TEXT)m_bfName.Access());
#endif
            Close();
        }
    };

    //  Properties
    //  Methods
    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::IsValid")
    BOOL IsValid(void) const
    {
        return (NULL != m_hHandle) && (INVALID_HANDLE_VALUE != m_hHandle);
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::Value")
    HANDLE Value(void) const
    {
#ifdef _DEBUG
        if (!IsValid())
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Accessing invalid '%1' handle value."),
                (DEBUG_TEXT)m_bfName.Access());
#endif
        return m_hHandle;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::GetLastError")
    DWORD GetLastError(void) const
    {
        return m_dwError;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::Open")
    HANDLE Open(HANDLE h)
    {
        if ((NULL == h) || (INVALID_HANDLE_VALUE == h))
        {
            m_dwError = ::GetLastError();
#ifdef _DEBUG
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Attempt to assign invalid handle value to '%1'."),
                (DEBUG_TEXT)m_bfName.Access());
#endif
        }
        else
            m_dwError = ERROR_SUCCESS;
        if (IsValid())
        {
#ifdef _DEBUG
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Overwriting handle '%1' -- fixing"),
                (DEBUG_TEXT)m_bfName.Access());
#endif
            Close();
        }
        m_hHandle = h;
        return m_hHandle;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::Close")
    DWORD Close(void)
    {
        DWORD dwSts = ERROR_SUCCESS;

        if (IsValid())
        {
            BOOL fSts;

            fSts = CloseHandle(m_hHandle);
#ifdef DBG
            if (!fSts)
            {
                dwSts = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to close handle '%2': %1"),
                    dwSts,
                    (DEBUG_TEXT)m_bfName.Access());
            }
#endif
            m_hHandle = NULL;
        }
#ifdef DBG
        else
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Attempt to re-close handle '%1'"),
                (DEBUG_TEXT)m_bfName.Access());
        }
#endif
        return dwSts;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::Relinquish")
    HANDLE Relinquish(void)
    {
        HANDLE hTmp = m_hHandle;
#ifdef _DEBUG
        if (!IsValid())
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Relinquishing invalid '%1' handle"),
                (DEBUG_TEXT)m_bfName.Access());
#endif
        m_hHandle = NULL;
        return hTmp;
    };

    //  Operators

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::operator HANDLE")
    operator HANDLE(void) const
    {
#ifdef _DEBUG
        ASSERT(IsValid());	// Assert should be in callers
#endif
        return Value();
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ DBGT("CHandleObject::operator=")
    HANDLE operator=(HANDLE h)
    {
        return Open(h);
    };

protected:
    //  Properties
    HANDLE m_hHandle;
    DWORD m_dwError;
#ifdef DBG
    CBuffer m_bfName;
#endif

    //  Methods
};

#ifdef DBG
//
//==============================================================================
//
//  CDynamicArray
//

template <class T>
class CDynamicValArray
{
public:

    //  Constructors & Destructor

    CDynamicValArray(void)
    { m_Max = m_Mac = 0; m_pvList = NULL; };

    virtual ~CDynamicValArray()
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(void)
    {
        if (NULL != m_pvList)
        {
            delete[] m_pvList;
            m_pvList = NULL;
            m_Max = 0;
            m_Mac = 0;
        }
    };

    void
    Empty(void)
    { m_Mac = 0; };

    T 
    Set(
        IN int nItem,
        IN T pvItem);

    T const
    Get(
        IN int nItem)
    const;

    DWORD
    Count(void) const
    { return m_Mac; };

    //  Operators
    T const
    operator[](int nItem) const
    { return Get(nItem); };


protected:
    //  Properties

    DWORD
        m_Max,          // Number of element slots available.
        m_Mac;          // Number of element slots used.
    T *
        m_pvList;       // The elements.


    //  Methods
};


/*++

Set:

    This routine sets an item in the collection array.  If the array isn't that
    big, it is expanded with NULL elements to become that big.

Arguments:

    nItem - Supplies the index value to be set.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    The value of the inserted value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template<class T>
inline T
CDynamicValArray<T>::Set(
    IN int nItem,
    IN T pvItem)
{
    DWORD index;


    //
    // Make sure the array is big enough.
    //

    if ((DWORD)nItem >= m_Max)
    {
        int newSize = (0 == m_Max ? 4 : m_Max);
        while (nItem >= newSize)
            newSize *= 2;
        T *newList = new T[newSize];
        if (NULL == newList)
            throw (DWORD)ERROR_OUTOFMEMORY;
        for (index = 0; index < m_Mac; index += 1)
            newList[index] = m_pvList[index];
        if (NULL != m_pvList)
            delete[] m_pvList;
        m_pvList = newList;
        m_Max = newSize;
    }


    //
    // Make sure intermediate elements are filled in.
    //

    if ((DWORD)nItem >= m_Mac)
    {
        for (index = m_Mac; index < (DWORD)nItem; index += 1)
            m_pvList[index] = NULL;
        m_Mac = (DWORD)nItem + 1;
    }


    //
    // Fill in the list element.
    //

    m_pvList[(DWORD)nItem] = pvItem;
    return pvItem;
}

/*++

Get:

    This method returns the element at the given index.  If there is no element
    previously stored at that element, it returns NULL.  It does not expand the
    array.

Arguments:

    nItem - Supplies the index into the list.

Return Value:

    The value stored at that index in the list, or NULL if nothing has ever been
    stored there.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template <class T>
inline T const
CDynamicValArray<T>::Get(
    int nItem)
    const
{
    if (m_Mac <= (DWORD)nItem)
        return 0;
    else
        return m_pvList[nItem];
}

#endif


//
//==============================================================================
//
//  CAccessLock
//

class CAccessLock
{
public:
    //  Constructors & Destructor

    CAccessLock(DWORD dwTimeout = CALAIS_LOCK_TIMEOUT);
    ~CAccessLock();

    BOOL InitFailed(void) { return m_csLock.InitFailed(); }

#ifdef DBG
    BOOL NotReadLocked(void);
    BOOL IsReadLocked(void);
    BOOL NotWriteLocked(void);
    BOOL IsWriteLocked(void);
#endif

protected:
    //  Properties

    CCriticalSectionObject m_csLock;
    DWORD m_dwReadCount;
    DWORD m_dwWriteCount;
    DWORD m_dwTimeout;
    CHandleObject m_hSignalNoReaders;
    CHandleObject m_hSignalNoWriters;
    DWORD m_dwOwner;
#ifdef DBG
    CDynamicValArray<DWORD> m_rgdwReaders;
#endif


    //  Methods

    void Wait(HANDLE hSignal);
    void Signal(HANDLE hSignal);
    void Unsignal(HANDLE hSignal);

    void WaitOnReaders(void)
    {
        Wait(m_hSignalNoReaders);
    };
    void WaitOnWriters(void)
    {
        Wait(m_hSignalNoWriters);
    };
    void SignalNoReaders(void)
    {
        Signal(m_hSignalNoReaders);
    };
    void SignalNoWriters(void)
    {
        Signal(m_hSignalNoWriters);
    };
    void UnsignalNoReaders(void)
    {
        Unsignal(m_hSignalNoReaders);
    };
    void UnsignalNoWriters(void)
    {
        Unsignal(m_hSignalNoWriters);
    };

    friend class CLockRead;
    friend class CLockWrite;
};


//
//==============================================================================
//
//  CLockRead
//

class CLockRead
{
public:

    //  Constructors & Destructor
    CLockRead(CAccessLock *pLock);
    ~CLockRead();

    BOOL InitFailed(void) { return m_pLock->InitFailed(); }

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties
    CAccessLock * m_pLock;

    //  Methods
};


//
//==============================================================================
//
//  CLockWrite
//

class CLockWrite
{
public:

    //  Constructors & Destructor

    CLockWrite(CAccessLock *pLock);
    ~CLockWrite();

    BOOL InitFailed(void) { return m_pLock->InitFailed(); }

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties

    CAccessLock *m_pLock;


    //  Methods
};


//
//==============================================================================
//
//  CMutex
//

class CMutex
{
public:

    //  Constructors & Destructor
    CMutex();
    ~CMutex();

    //  Properties

    //  Methods
    void Grab(void);
    BOOL Share(void);
    void Invalidate(void);
    void Take(void);
    BOOL IsGrabbed(void);
    BOOL IsGrabbedByMe(void);
    BOOL IsGrabbedBy(DWORD dwThreadId);
    BOOL InitFailed(void) { return m_csAccessLock.InitFailed(); }

    //  Operators

protected:
    //  Properties
    CCriticalSectionObject m_csAccessLock;
    DWORD m_dwOwnerThreadId;
    DWORD m_dwGrabCount;
    DWORD m_dwValidityCount;
    CHandleObject m_hAvailableEvent;

    //  Methods
};


//
//==============================================================================
//
//  CMultiEvent
//

class CMultiEvent
{
public:

    //  Constructors & Destructor

    CMultiEvent();
    ~CMultiEvent();


    //  Properties
    //  Methods
    HANDLE WaitHandle(void);
    void Signal(void);
    BOOL InitFailed(void) { return m_csLock.InitFailed(); }

    //  Operators

protected:
    //  Properties
    CCriticalSectionObject m_csLock;
    HANDLE m_rghEvents[4];  // Adjust this as necessary.
    DWORD m_dwEventIndex;

    //  Methods
};

#endif // _LOCKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\scardsvr\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SCardSvr.rc
//
#define IDS_STRING1                     1
#define CALSTRING_SCARDSVR              1
#define IDS_PRIMARYSERVICEDISPLAY       1
#define CALSTRING_SCARDDRV              2
#define IDS_LEGACYSERVICEDISPLAY        2
#define IDS_SMARTCARD_INSERTION         3
#define IDS_SMARTCARD_REMOVAL           4
#define IDS_PRIMARYSERVICEDESC          5
#define IDS_LEGACYSERVICEDESC           6
#define IDS_STRING200                   115

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\scardsvr\waitsam.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    waitsam

Abstract:

    This module provides back-door access to some internal NT routines.  This
    is needed to get at the SAM Startup Event -- it has an illegal name from
    the Win32 routines, so we have to sneak back and pull it up from NT
    directly.

Author:

    Doug Barlow (dbarlow) 5/3/1998

Notes:

    As taken from code suggested by MacM

--*/

#define __SUBROUTINE__
#if !defined(_X86_) && !defined(_ALPHA_)
#define _X86_ 1
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#ifndef UNICODE
#define UNICODE     // Force this module to use UNICODE.
#endif
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}

#include <windows.h>

/*++

AccessSAMEvent:

    This procedure opens the handle to the SAM Startup Event handle.

Arguments:

    None

Return Value:

    The handle, or NULL on an error.

Author:

    Doug Barlow (dbarlow) 5/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AccessSAMEvent")

HANDLE
AccessSAMEvent(
    void)
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES EventAttributes;
    CHandleObject EventHandle(DBGT("Event Handle from AccessSAMEvent"));

    //
    // Open the event
    //
    RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED" );
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    Status = NtCreateEvent( &EventHandle,
        SYNCHRONIZE,
        &EventAttributes,
        NotificationEvent,
        FALSE );


    //
    // If the event already exists, just open it.
    //
    if( Status == STATUS_OBJECT_NAME_EXISTS || Status == STATUS_OBJECT_NAME_COLLISION ) {

        Status = NtOpenEvent( &EventHandle,
            SYNCHRONIZE,
            &EventAttributes );
    }
    return EventHandle;
}


/*++

WaitForSAMEvent:

    This procedure can be used to wait for the SAM Startup event using NT
    internal calls.  I don't know how to specify a timeout value, so this
    routine isn't complete.

Arguments:

    hSamActive supplies the handle to the SAM Startup Event.

    dwTimeout supplies the time to wait for the startup event, in milliseconds.

Return Value:

    TRUE - The event was set.

    FALSE - The timeout expired

Throws:

    Any errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 5/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("WaitForSAMEvent")

BOOL
WaitForSAMEvent(
    HANDLE hSamActive,
    DWORD dwTimeout)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = NtWaitForSingleObject(hSamActive, TRUE, NULL);
    return Status;
}


/*++

CloseSamEvent:

    This procedure uses the NT internal routine to close a handle.

Arguments:

    hSamActive supplies the handle to be closed.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 5/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CloseSAMEvent")

void
CloseSAMEvent(
    HANDLE hSamActive)
{
    NtClose(hSamActive);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\scardsvr\scappdev.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    scappdev

Abstract:

    This module provides the device-specific operations that must be performed
    by the controlling resource manager application.  Due to Plug 'n Play, there
    can't be a clean separation between device controller classes and the
    application driving them.  This module provides the hooks to isolate these
    interdependencies as much as possible.

Author:

    Doug Barlow (dbarlow) 4/3/1998

Environment:

    Win32, C++

Notes:

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <winsvc.h>
#include <dbt.h>
#include <WinSCard.h>
#include <CalMsgs.h>
#include <calcom.h>
#include <scardlib.h>

static const GUID l_guidSmartcards
                        = { // 50DD5230-BA8A-11D1-BF5D-0000F805F530
                            0x50DD5230,
                            0xBA8A,
                            0x11D1,
                            { 0xBF, 0x5D, 0x00, 0x00, 0xF8, 0x05, 0xF5, 0x30 } };

static SERVICE_STATUS_HANDLE l_hService = NULL;
static DWORD l_dwType = 0;
static HDEVNOTIFY l_hIfDev = NULL;


/*++

AppInitializeDeviceRegistration:

    This routine is called by a controlling application in order to enable
    PnP and Power Management Events.

Arguments:

    hService supplies the handle to the service application.

    dwType supplies the type of handle supplied.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AppInitializeDeviceRegistration")

void
AppInitializeDeviceRegistration(
    SERVICE_STATUS_HANDLE hService,
    DWORD dwType)
{
    DEV_BROADCAST_DEVICEINTERFACE dbcIfFilter;


    //
    // Save off the application information.
    //

    ASSERT(NULL == l_hService);
    l_hService = hService;
    l_dwType = dwType;
    ASSERT(NULL == l_hIfDev);


    //
    // Register for PnP events.
    //

    ZeroMemory(&dbcIfFilter, sizeof(dbcIfFilter));
    dbcIfFilter.dbcc_size = sizeof(dbcIfFilter);
    dbcIfFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    // dbcIfFilter.dbcc_reserved = NULL;
    CopyMemory(
        &dbcIfFilter.dbcc_classguid,
        &l_guidSmartcards,
        sizeof(GUID));
    // dbcIfFilter.dbcc_name[1];

    l_hIfDev = RegisterDeviceNotification(
                    l_hService,
                    &dbcIfFilter,
                    l_dwType);
    if (NULL == l_hIfDev)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Initialize device registration failed to register for PnP events: %1"),
            GetLastError());
    }
}


/*++

AppTerminateDeviceRegistration:

    This routine is called by a controlling application in order to terminate
    PnP and Power Management Events.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AppTerminateDeviceRegistration")

void
AppTerminateDeviceRegistration(
    void)
{
    BOOL fSts;


    //
    // Unregister for PnP events.
    //

    if (NULL != l_hIfDev)
    {
        try
        {
            fSts = UnregisterDeviceNotification(l_hIfDev);
        }
        catch (...)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Terminate device registration failed to unregister from PnP events: Exception raised"));
        }
        if (!fSts)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Terminate device registration failed to unregister from PnP events: %1"),
                GetLastError());
        }
    }

    l_hService = NULL;
    l_dwType = 0;
    l_hIfDev = NULL;
}


/*++

AppRegisterDevice:

    This routine is called by a Reader Device Object to inform the controlling
    application that it exists and is ready to follow the OS rules for removal.

Arguments:

    hReader supplies the handle to the open device.

    szReader supplies the name of the device.

    ppvAppState supplies a pointer to a storage location for this application
        associated with this device.  The use of this location is specific to
        the application.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AppRegisterDevice")

void
AppRegisterDevice(
    HANDLE hReader,
    LPCTSTR szReader,
    LPVOID *ppvAppState)
{

    //
    // Platform-specific initialization.
    //

    DEV_BROADCAST_HANDLE dbcHandleFilter;
    HDEVNOTIFY *phDevNotify = (HDEVNOTIFY *)ppvAppState;

    //
    // Register for PnP events.
    //

    if (NULL != l_hService)
    {
        ASSERT(NULL == *phDevNotify);
        ZeroMemory(&dbcHandleFilter, sizeof(dbcHandleFilter));
        dbcHandleFilter.dbch_size = sizeof(dbcHandleFilter);
        dbcHandleFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
        dbcHandleFilter.dbch_handle = hReader;

        *phDevNotify = RegisterDeviceNotification(
            l_hService,
            &dbcHandleFilter,
            l_dwType);
        if (NULL == *phDevNotify)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Register device failed to register '%2' for PnP Device removal: %1"),
                GetLastError(),
                szReader);
        }
    }
}


/*++

AppUnregisterDevice:

    This routine is called when a device wants to let the controlling
    application know that it is officially ceasing to exist.

Arguments:

    hReader supplies the handle to the open device.

    szReader supplies the name of the device.

    ppvAppState supplies a pointer to a storage location for this application
        associated with this device.  The use of this location is specific to
        the application.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AppUnregisterDevice")

void
AppUnregisterDevice(
    HANDLE hReader,
    LPCTSTR szReader,
    LPVOID *ppvAppState)
{
    try
    {

        //
        // Platform-specific initialization.
        //

        BOOL fSts;
        HDEVNOTIFY hDevNotify = *(HDEVNOTIFY *)ppvAppState;


        //
        // Unregister from PnP events.
        //

        ASSERT(NULL != l_hIfDev);
        if (NULL != hDevNotify)
        {
            try
            {
                fSts = UnregisterDeviceNotification(hDevNotify);
            }
            catch (...)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Unregister device failed to unregister '%2' from PnP Device removal: EXCEPTION"),
                    GetLastError(),
                    szReader);
                fSts = TRUE;
            }
            if (!fSts)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Unregister device failed to unregister '%2' from PnP Device removal: %1"),
                    GetLastError(),
                    szReader);
            }
            *ppvAppState = NULL;
        }
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Unregister device received unexpected exception."));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\scardsvr\scardsvr.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    SCardSvr

Abstract:

    This module provides the startup logic to make the Calais Resource Manager
    act as a server application under Windows NT.

Author:

    Doug Barlow (dbarlow) 1/16/1997

Environment:

    Win32

Notes:

    This file detects which operating system it's running on, and acts
    accordingly.

--*/

#if defined(_DEBUG)
#define DEBUG_SERVICE
#endif

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <aclapi.h>
#include <dbt.h>
#include <CalServe.h>
#include "resource.h"   // Pick up resource string Ids.

static const DWORD l_dwWaitHint = CALAIS_THREAD_TIMEOUT;
static const GUID l_guidSmartcards
    = { // 50DD5230-BA8A-11D1-BF5D-0000F805F530
        0x50DD5230,
        0xBA8A,
        0x11D1,
        { 0xBF, 0x5D, 0x00, 0x00, 0xF8, 0x05, 0xF5, 0x30}};
static const DWORD l_dwInteractiveAccess
    =                   READ_CONTROL
//                        | SYNCHRONIZE
                        | SERVICE_QUERY_CONFIG
//                      | SERVICE_CHANGE_CONFIG
                        | SERVICE_QUERY_STATUS
                        | SERVICE_ENUMERATE_DEPENDENTS
                        | SERVICE_START
//                      | SERVICE_STOP
//                      | SERVICE_PAUSE_CONTINUE
                        | SERVICE_INTERROGATE
                        | SERVICE_USER_DEFINED_CONTROL
                        | 0;

static const DWORD l_dwSystemAccess
    =                   READ_CONTROL
                        | SERVICE_USER_DEFINED_CONTROL
                        | SERVICE_START
                        | SERVICE_STOP
                        | SERVICE_QUERY_CONFIG
                        | SERVICE_QUERY_STATUS
                        | SERVICE_PAUSE_CONTINUE
                        | SERVICE_INTERROGATE
                        | SERVICE_ENUMERATE_DEPENDENTS
                        | 0;

static CCriticalSectionObject *l_pcsStatusLock = NULL;
static SERVICE_STATUS l_srvStatus, l_srvNonPnP;
static SERVICE_STATUS_HANDLE l_hService = NULL, l_hNonPnP = NULL;
static HANDLE l_hShutdownEvent = NULL;
static HANDLE l_hLegacyEvent = NULL;

#ifdef DEBUG_SERVICE
static SERVICE_STATUS l_srvDebug;
static SERVICE_STATUS_HANDLE l_hDebug = NULL;
static HANDLE l_hDebugDoneEvent = NULL;
static void WINAPI
DebugMain(
    IN DWORD dwArgc,
    IN LPTSTR *pszArgv);
static void WINAPI
DebugHandler(
    IN DWORD dwOpCode);
#endif

static void WINAPI
CalaisMain(
    IN DWORD dwArgc,
    IN LPTSTR *pszArgv);
static void WINAPI
NonPnPMain(
    IN DWORD dwArgc,
    IN LPTSTR *pszArgv);
static DWORD WINAPI
CalaisHandlerEx(
    IN DWORD dwControl,
    IN DWORD dwEventType,
    IN PVOID EventData,
    IN PVOID pData);
static void WINAPI
NonPnPHandler(
    IN DWORD dwOpCode);

static HRESULT UnregisterServer(void);
static HRESULT RegisterServer(void);
static HRESULT AddSounds(void);
static HRESULT RemoveSounds(void);
static HRESULT AddCertProp(void);
static HRESULT RemoveCertProp(void);
static HRESULT AutoLock(DWORD dwOption);
#ifdef _DEBUG
static HRESULT RunNow(void);
#endif


/*++

Main:

    This routine is the entry point for the Resource Manager.

Arguments:

    Per standard Windows applications

Return Value:

    Per standard Windows applications

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/16/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("main")

extern "C" int __cdecl
main(
    int nArgCount,
    LPCTSTR *rgszArgs)
{
    NEW_THREAD;
    SERVICE_TABLE_ENTRY rgsteDispatchTable[4];
    DWORD dwI = 0;
    DWORD dwSts = ERROR_SUCCESS;

    if (1 < nArgCount)
    {
        LPCTSTR szArg = rgszArgs[1];

        if ((TEXT('-') == *szArg) || (TEXT('/') == *szArg))
            szArg += 1;
        switch (SelectString(szArg,
                    TEXT("INSTALL"), TEXT("REMOVE"), TEXT("UNINSTALL"),
                    TEXT("REINSTALL"), TEXT("SOUNDS"), TEXT("NOSOUNDS"),
                    TEXT("NOCERTPROP"), TEXT("AUTOLOCK"), TEXT("AUTOLOGOFF"),
                    TEXT("NOAUTO"),
#ifdef _DEBUG
                    TEXT("RUNNOW"),
#endif
                    NULL))
        {
        case 1:
            dwSts = RegisterServer();
            break;
        case 2:
        case 3:
            dwSts = UnregisterServer();
            break;
        case 4:
            dwSts = UnregisterServer();
            if (ERROR_SUCCESS == dwSts)
                dwSts = RegisterServer();
            break;
        case 5:
            dwSts = AddSounds();
            break;
        case 6:
            dwSts = RemoveSounds();
            break;
        case 7:
            dwSts = RemoveCertProp();
            break;
        case 8: // Auto Lock
            dwSts = AutoLock(1);
            break;
        case 9: // Auto Logoff
            dwSts = AutoLock(2);
            break;
        case 10: // No auto action
            dwSts = AutoLock(0);
            break;
#ifdef _DEBUG
        case 11:
            dwSts = RunNow();
            break;
#endif
        default:
            dwSts = ERROR_INVALID_PARAMETER;
        }
        goto ErrorExit;
    }

    CalaisInfo(
        __SUBROUTINE__,
        DBGT("Initiating Smart Card Services Process"));
    try
    {
#ifdef DEBUG_SERVICE
        rgsteDispatchTable[dwI].lpServiceName = (LPTSTR)CalaisString(CALSTR_DEBUGSERVICE);
        rgsteDispatchTable[dwI].lpServiceProc = DebugMain;
        dwI += 1;
#endif
        rgsteDispatchTable[dwI].lpServiceName = (LPTSTR)CalaisString(CALSTR_PRIMARYSERVICE);
        rgsteDispatchTable[dwI].lpServiceProc = CalaisMain;
        dwI += 1;

        rgsteDispatchTable[dwI].lpServiceName = (LPTSTR)CalaisString(CALSTR_LEGACYSERVICE);
        rgsteDispatchTable[dwI].lpServiceProc = NonPnPMain;
        dwI += 1;

        rgsteDispatchTable[dwI].lpServiceName = NULL;
        rgsteDispatchTable[dwI].lpServiceProc = NULL;

        if (!StartServiceCtrlDispatcher(rgsteDispatchTable))
        {
            dwSts = GetLastError();
            CalaisError(__SUBROUTINE__, 505, dwSts);
            goto ServiceExit;
        }
    }
    catch (DWORD dwErr)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Service Main Routine unhandled error: %1"),
            dwErr);
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Service Main Routine received unexpected exception."));
        dwSts = SCARD_F_UNKNOWN_ERROR;
    }

ServiceExit:
    CalaisInfo(
        __SUBROUTINE__,
        DBGT("Terminating Smart Card Services Process: %1"),
        dwSts);
    return dwSts;

ErrorExit:
    if (ERROR_SUCCESS != dwSts)
    {
        LPCTSTR szErr = NULL;
        
        try
        {
            szErr = ErrorString(dwSts);
        }
        catch(...)
        {
            // Not enough memory to build the error message
            // Nothing else to do
        }

        if (NULL == szErr)
            _tprintf(_T("0x%08x"), dwSts);    // Same form as in ErrorString
                                                // if message can't be found
        else
            _putts(szErr);
    }
    return dwSts;
}


#ifdef _DEBUG
/*++

RunNow:

    This routine kicks off the resource manager running as an application
    process.  That makes the internals easier to debug.

Arguments:

    None

Return Value:

    S_OK

Throws:

    None

Remarks:

    For private debugging only.

Author:

    Doug Barlow (dbarlow) 2/19/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("RunNow")

static HRESULT
RunNow(
    void)
{
    DWORD dwStatus;

    CalaisInfo(
        __SUBROUTINE__,
        DBGT("Initiating Smart Card Services Application"));

    l_pcsStatusLock = new CCriticalSectionObject(CSID_SERVICE_STATUS);
    if (NULL == l_pcsStatusLock)
    {
        CalaisError(__SUBROUTINE__, 501);
        goto FinalExit;
    }
    if (l_pcsStatusLock->InitFailed())
    {
        delete l_pcsStatusLock;
        l_pcsStatusLock = NULL;
        return SCARD_E_NO_MEMORY;
    }
    CalaisMessageInit(TEXT("Calais Application"));

    try
    {
        l_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL == l_hShutdownEvent)
        {
            CalaisError(__SUBROUTINE__, 504, GetLastError());
            goto FinalExit;
        }


        //
        // Start the Calais Service.
        //

        dwStatus = CalaisStart();
        if (SCARD_S_SUCCESS != dwStatus)
            goto ServiceExit;


        //
        // Tell interested parties that we've started.
        //

        ResetEvent(AccessStoppedEvent());
        SetEvent(AccessStartedEvent());        

        //
        // Now just hang around until we're supposed to stop.
        //

        dwStatus = WaitForSingleObject(l_hShutdownEvent, INFINITE);
        switch (dwStatus)
        {
        case WAIT_FAILED:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager cannot wait for shutdown:  %1"),
                GetLastError());
            break;
        case WAIT_ABANDONED:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager received shutdown wait abandoned"));
            // Fall through intentionally
        case WAIT_OBJECT_0:
            break;
        case WAIT_TIMEOUT:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager received shutdown wait time out"));
            break;
        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager received invalid wait return code"));
        }

        ResetEvent(AccessStartedEvent());
        SetEvent(AccessStoppedEvent());
        CalaisStop();
ServiceExit:
        ResetEvent(AccessStartedEvent());
        SetEvent(AccessStoppedEvent());
        CalaisInfo(__SUBROUTINE__, DBGT("Calais Stopping"));

FinalExit:
        ResetEvent(AccessStartedEvent());
        SetEvent(AccessStoppedEvent());
        if (NULL != l_hShutdownEvent)
        {
            if (!CloseHandle(l_hShutdownEvent))
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to close Calais Shutdown Event: %1"),
                    GetLastError());
            l_hShutdownEvent = NULL;
        }
    }
    catch (DWORD dwErr)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Calais RunNow Routine unhandled error: %1"),
            dwErr);
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Calais RunNow Routine received unexpected exception."));
    }
    CalaisMessageClose();
    return S_OK;
}
#endif


#ifdef DEBUG_SERVICE
/*++

DebugMain:

    This helper function supplies a simple debuggable process so that
    the resource manager can be debugged as a service.

Arguments:

    dwArgc supplies the number of command line arguments

    pszArgv supplies pointers to each of the arguments.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 8/25/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("DebugMain")

static void WINAPI
DebugMain(
    IN DWORD dwArgc,
    IN LPTSTR *pszArgv)
{
    NEW_THREAD;
    BOOL fSts;

    CalaisInfo(
        __SUBROUTINE__,
        DBGT("Debug service Start"));
    try
    {
        l_hDebugDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        ASSERT(NULL != l_hDebugDoneEvent);

        l_srvDebug.dwServiceType =              SERVICE_INTERACTIVE_PROCESS |
            SERVICE_WIN32_SHARE_PROCESS;
        l_srvStatus.dwCurrentState =            SERVICE_START_PENDING;
        l_srvDebug.dwControlsAccepted =         SERVICE_ACCEPT_STOP |
            SERVICE_ACCEPT_SHUTDOWN;
        l_srvDebug.dwWin32ExitCode =            NO_ERROR;
        l_srvDebug.dwServiceSpecificExitCode =  0;
        l_srvDebug.dwCheckPoint =               0;
        l_srvDebug.dwWaitHint =                 0;
        l_hDebug = RegisterServiceCtrlHandler(
            CalaisString(CALSTR_DEBUGSERVICE),
            DebugHandler);
        ASSERT(l_hDebug != NULL);

        l_srvDebug.dwCurrentState =             SERVICE_RUNNING;
        fSts = SetServiceStatus(l_hDebug, &l_srvDebug);
        ASSERT(fSts == TRUE);

        CalaisInfo(
            __SUBROUTINE__,
            DBGT("Ready for debugging"));
        WaitForSingleObject(l_hDebugDoneEvent, INFINITE);

        CalaisInfo(
            __SUBROUTINE__,
            DBGT("Debugger service Stopping"));
        l_srvDebug.dwCurrentState  = SERVICE_STOPPED;
        fSts = SetServiceStatus(l_hDebug, &l_srvDebug);
    }
    catch (DWORD dwErr)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Debug Main Routine unhandled error: %1"),
            dwErr);
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Debug Main Routine received unexpected exception."));
    }

    if (NULL != l_hDebugDoneEvent)
    {
        fSts = CloseHandle(l_hDebugDoneEvent);
        l_hDebugDoneEvent = NULL;
        if (!fSts)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to close Debug Service Handle: %1"),
                GetLastError());
        }
    }
    CalaisInfo(__SUBROUTINE__, DBGT("Debug service Complete"));
}


/*++

DebugHandler:

    This routine services Debug requests.

Arguments:

    dwOpCode supplies the service request.

Return Value:

    None

Throws:

    None

Remarks:

    Standard Service processing routine.  In theory, this will never get
    called, but just in case...

Author:

    Doug Barlow (dbarlow) 8/25/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("DebugHandler")

static void WINAPI
DebugHandler(
    IN DWORD dwOpCode)
{
    NEW_THREAD;
    DWORD nRetVal = NO_ERROR;


    //
    // Process the command.
    //

    CalaisInfo(__SUBROUTINE__, DBGT("Debug Handler Entered"));
    try
    {
        switch (dwOpCode)
        {
        case SERVICE_CONTROL_PAUSE:
            l_srvDebug.dwCurrentState = SERVICE_PAUSED;
            break;

        case SERVICE_CONTROL_CONTINUE:
            l_srvDebug.dwCurrentState = SERVICE_RUNNING;
            break;

        case SERVICE_CONTROL_INTERROGATE:
            break;

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            l_srvDebug.dwCurrentState = SERVICE_STOP_PENDING;
            l_srvDebug.dwCheckPoint = 0;
            l_srvDebug.dwWaitHint = 0;
            SetEvent(l_hDebugDoneEvent);
            break;

        default: // No action
            break;
        }

        l_srvDebug.dwWin32ExitCode = nRetVal;
        if (!SetServiceStatus(l_hDebug, &l_srvDebug))
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to register Debug service status: %1"),
                GetLastError());
    }
    catch (DWORD dwErr)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Debug Handler Routine unhandled error: %1"),
            dwErr);
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Debug Handler Routine received unexpected exception."));
    }
    CalaisInfo(__SUBROUTINE__, DBGT("Debug Handler Returned"));
}
#endif


/*++

NonPnPMain:

    This helper function is only called if there is a legacy device
    in the system that defines 'Group = Smart Card Reader'. This 'service'
    is dependent on this group. It is only used to add those readers as known
    readers to the smart card resources manager

Arguments:

    argc supplies the number of command line arguments

    argv supplies pointers to each of the arguments.

Return Value:

    None

Throws:

    None

Author:

    Klaus Schutz July 1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("NonPnPMain")

static void WINAPI
NonPnPMain(
    IN DWORD dwArgc,
    IN LPTSTR *pszArgv)
{
    NEW_THREAD;
    BOOL fSts;

    CalaisWarning(
        __SUBROUTINE__,
        DBGT("NonPnPMain: Registering Non PnP Devices"));
    try
    {
        l_srvNonPnP.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
        l_srvNonPnP.dwCurrentState = SERVICE_START_PENDING;
        l_srvNonPnP.dwControlsAccepted = 0;
        l_srvNonPnP.dwWin32ExitCode = NO_ERROR;
        l_srvNonPnP.dwServiceSpecificExitCode = 0;
        l_srvNonPnP.dwCheckPoint = 0;
        l_srvNonPnP.dwWaitHint = 10000;

        l_hNonPnP = RegisterServiceCtrlHandler(
            CalaisString(CALSTR_LEGACYSERVICE),
            NonPnPHandler);
        if (NULL == l_hNonPnP)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to register NonPnP service handler: %1"),
                GetLastError());
            goto ErrorExit;
        }

        fSts = SetServiceStatus(l_hNonPnP, &l_srvNonPnP);
        if (!fSts)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to update NonPnP service status: %1"),
                GetLastError());
            goto ErrorExit;
        }

        try
        {
            AddAllWdmDrivers();
        }
        catch (...) {}

        l_srvNonPnP.dwCurrentState = SERVICE_STOPPED;
        l_srvNonPnP.dwCheckPoint   = 0;
        l_srvNonPnP.dwWaitHint     = 0;
        fSts = SetServiceStatus(l_hNonPnP, &l_srvNonPnP);
        if (!fSts)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to finish NonPnP service status: %1"),
                GetLastError());
        }
    }
    catch (DWORD dwErr)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Legacy Main Routine unhandled error: %1"),
            dwErr);
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Legacy Main Routine received unexpected exception."));
    }

ErrorExit:
    if (NULL != l_hLegacyEvent)
        SetEvent(l_hLegacyEvent);
    CalaisWarning(__SUBROUTINE__, DBGT("NonPnPMain: Complete"));
}


/*++

NonPnPHandler:

    This routine services the requests for the Non-PnP drivers.  If this
    service starts, then there's a Legacy Reader Driver on the system.  This
    routine kicks it off so that the resource manager can deal with it.

Arguments:

    dwOpCode supplies the service request.

Return Value:

    None

Throws:

    None

Remarks:

    Standard Service processing routine.  In theory, this will never get
    called, but just in case...

Author:

    Klaus Schutz (kschutz) 8/25/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("NonPnPHandler")

static void WINAPI
NonPnPHandler(
    IN DWORD dwOpCode)
{
    NEW_THREAD;
    try
    {
        DWORD nRetVal = NO_ERROR;


        //
        // Process the command.
        //

        CalaisInfo(__SUBROUTINE__, DBGT("NonPnPHandler: Entered"));
        switch (dwOpCode)
        {
        case SERVICE_CONTROL_PAUSE:
            // ?noSupport?
            l_srvNonPnP.dwCurrentState = SERVICE_PAUSED;
            break;

        case SERVICE_CONTROL_CONTINUE:
            l_srvNonPnP.dwCurrentState = SERVICE_RUNNING;
            // ?noSupport?
            break;

        case SERVICE_CONTROL_INTERROGATE:
            break;

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            l_srvNonPnP.dwCurrentState = SERVICE_STOP_PENDING;
            l_srvNonPnP.dwCheckPoint = 0;
            l_srvNonPnP.dwWaitHint = l_dwWaitHint;
            break;

        default: // No action
            break;
        }

        l_srvNonPnP.dwWin32ExitCode = nRetVal;
        if (!SetServiceStatus(l_hNonPnP, &l_srvNonPnP))
            CalaisError(__SUBROUTINE__, 503, GetLastError());
    }
    catch (DWORD dwErr)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Legacy Handler Routine unhandled error: %1"),
            dwErr);
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Legacy Handler Routine received unexpected exception."));
    }
    CalaisInfo(__SUBROUTINE__, DBGT("NonPnPHandler: Returned"));
}


/*++

CalaisMain:

    This is the ServiceMain service entry point.  It is only called under the
    NT operating system, and makes that assumption.

Arguments:

    argc supplies the number of command line arguments

    argv supplies pointers to each of the arguments.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/16/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisMain")

static void WINAPI
CalaisMain(
    IN DWORD dwArgc,
    IN LPTSTR *pszArgv)
{
    NEW_THREAD;
    CalaisMessageInit(CalaisString(CALSTR_PRIMARYSERVICE), NULL, TRUE);
    CalaisInfo(__SUBROUTINE__, DBGT("CalaisMain Entered"));

    l_pcsStatusLock = new CCriticalSectionObject(CSID_SERVICE_STATUS);
    if (NULL == l_pcsStatusLock)
    {
        CalaisError(__SUBROUTINE__, 507);
        return;
    }
    if (l_pcsStatusLock->InitFailed())
    {
        CalaisError(__SUBROUTINE__, 502);
        delete l_pcsStatusLock;
        l_pcsStatusLock = NULL;
        return;
    }

    try
    {
        SC_HANDLE schLegacy  = NULL;
        SC_HANDLE schSCManager = NULL;
        DWORD dwStatus;
        BOOL fSts;

        l_srvStatus.dwServiceType =
#ifdef DBG
            SERVICE_INTERACTIVE_PROCESS |
#endif
            SERVICE_WIN32_SHARE_PROCESS;
        l_srvStatus.dwCurrentState =            SERVICE_START_PENDING;
        l_srvStatus.dwControlsAccepted =
#ifdef SERVICE_ACCEPT_POWER_EVENTS
            SERVICE_ACCEPT_POWER_EVENTS |
#endif
#ifdef SERVICE_ACCEPT_DEVICE_EVENTS
            SERVICE_ACCEPT_DEVICE_EVENTS |
#endif
            SERVICE_ACCEPT_STOP |
            SERVICE_ACCEPT_SHUTDOWN;
        l_srvStatus.dwWin32ExitCode           = NO_ERROR;
        l_srvStatus.dwServiceSpecificExitCode = 0;
        l_srvStatus.dwCheckPoint              = 0;
        l_srvStatus.dwWaitHint                = 0;

        l_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL == l_hShutdownEvent)
        {
            CalaisError(__SUBROUTINE__, 504, GetLastError());
            goto FinalExit;
        }


        //
        // Initialize the service and the internal data structures.
        //

        l_hService = RegisterServiceCtrlHandlerEx(
                            CalaisString(CALSTR_PRIMARYSERVICE),
                            CalaisHandlerEx,
                            NULL);
        if (NULL == l_hService)
        {
            CalaisError(__SUBROUTINE__, 506, GetLastError());
            goto FinalExit;
        }


        //
        // Tell the Service Manager that we're trying to start.
        //

        {
            LockSection(l_pcsStatusLock, DBGT("Service Start Pending"));
            l_srvStatus.dwCurrentState  = SERVICE_START_PENDING;
            l_srvStatus.dwCheckPoint    = 0;
            l_srvStatus.dwWaitHint      = l_dwWaitHint;

            fSts = SetServiceStatus(l_hService, &l_srvStatus);
            dwStatus = fSts ? ERROR_SUCCESS : GetLastError();
        }

        if (ERROR_SUCCESS != dwStatus)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to update Service Manager status: %1"),
                dwStatus);
        }


        //
        // Register for future Plug 'n Play events.
        //

        try
        {
            AppInitializeDeviceRegistration(
                l_hService,
                DEVICE_NOTIFY_SERVICE_HANDLE);
        }
        catch (...)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager failed to register PnP events"));
        }


        //
        // Start the Calais Service.
        //

        dwStatus = CalaisStart();
        if (SCARD_S_SUCCESS != dwStatus)
            goto ServiceExit;
        else
        {
            LockSection(l_pcsStatusLock, DBGT("Declare Service Running"));
            l_srvStatus.dwCurrentState  = SERVICE_RUNNING;
            l_srvStatus.dwCheckPoint    = 0;
            l_srvStatus.dwWaitHint      = 0;
            fSts = SetServiceStatus(l_hService, &l_srvStatus);
            dwStatus = fSts ? ERROR_SUCCESS : GetLastError();
        }
        if (ERROR_SUCCESS != dwStatus)
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to update Service Manager status: %1"),
                dwStatus);


        //
        // Check for legacy devices
        //

        try
        {
            l_hLegacyEvent = CreateEvent(0, TRUE, FALSE, NULL);
            if (NULL == l_hLegacyEvent)
            {
                dwStatus = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to create legacy driver ready event: %1"),
                    dwStatus);
                throw dwStatus;
            }
            schSCManager = OpenSCManager(
                NULL,           // machine (NULL == local)
                NULL,           // database (NULL == default)
                GENERIC_READ);  // access required
            if (NULL == schSCManager)
            {
                dwStatus = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to access service manager: %1"),
                    dwStatus);
                throw dwStatus;
            }
            schLegacy = OpenService(
                schSCManager,
                CalaisString(CALSTR_LEGACYSERVICE),
                SERVICE_QUERY_STATUS | SERVICE_START);
            if (NULL == schLegacy)
            {
                dwStatus = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to access legacy driver service: %1"),
                    dwStatus);
                throw dwStatus;
            }

            // try to start the service
            if (!StartService(schLegacy, 0, NULL))
            {
                dwStatus = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to start the legacy driver service: %1"),
                    dwStatus);
                throw dwStatus;
            }

            CloseServiceHandle(schLegacy);
            schLegacy = NULL;
            CloseServiceHandle(schSCManager);
            schSCManager = NULL;

            if (NULL != l_hLegacyEvent)
                dwStatus = WaitForSingleObject(l_hLegacyEvent, 5000);
        }
        catch (...)
        {
            if (NULL != schLegacy)
                CloseServiceHandle(schLegacy);
            if (NULL != schSCManager)
                CloseServiceHandle(schSCManager);
        }


        //
        // Tell interested parties that we've started.
        //

        ResetEvent(AccessStoppedEvent());
        SetEvent(AccessStartedEvent());
        
        if (NULL != l_hLegacyEvent)
        {
            fSts = CloseHandle(l_hLegacyEvent);
            l_hLegacyEvent = NULL;
            if (!fSts)
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to Close Legacy Service Event: %1"),
                    GetLastError());
        }


        //
        // Now just hang around until we're supposed to stop.
        //

        dwStatus = WaitForSingleObject(l_hShutdownEvent, INFINITE);
        switch (dwStatus)
        {
        case WAIT_FAILED:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager cannot wait for shutdown:  %1"),
                GetLastError());
            break;
        case WAIT_ABANDONED:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager received shutdown wait abandoned"));
            // Fall through intentionally
        case WAIT_OBJECT_0:
            break;
        case WAIT_TIMEOUT:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager received shutdown wait time out"));
            break;
        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager received invalid wait return code"));
        }

        ResetEvent(AccessStartedEvent());
        SetEvent(AccessStoppedEvent());
        CalaisStop();
ServiceExit:
        ResetEvent(AccessStartedEvent());
        SetEvent(AccessStoppedEvent());
        CalaisInfo(__SUBROUTINE__, DBGT("Calais Main Stopping"));
        AppTerminateDeviceRegistration();
        {
            LockSection(l_pcsStatusLock, DBGT("Declare service stopped"));
            l_srvStatus.dwCurrentState  = SERVICE_STOPPED;
            l_srvStatus.dwWin32ExitCode = dwStatus;
            l_srvStatus.dwCheckPoint    = 0;
            l_srvStatus.dwWaitHint      = 0;
            fSts = SetServiceStatus(l_hService, &l_srvStatus);
            dwStatus = fSts ? ERROR_SUCCESS : GetLastError();
        }
        if (ERROR_SUCCESS != dwStatus)
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to update Service Manager status: %1"),
                dwStatus);

FinalExit:
        ResetEvent(AccessStartedEvent());
        SetEvent(AccessStoppedEvent());
        if (NULL != l_hShutdownEvent)
        {
            fSts = CloseHandle(l_hShutdownEvent);
            l_hShutdownEvent = NULL;
            if (!fSts)
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to close Calais Shutdown Event: %1"),
                    GetLastError());
        }
        ReleaseAllEvents();
    }
    catch (DWORD dwErr)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Calais Main Routine unhandled error: %1"),
            dwErr);
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Calais Main Routine received unexpected exception."));
    }
    CalaisInfo(__SUBROUTINE__, DBGT("CalaisMain Ended"));
    CalaisMessageClose();
    if (NULL != l_pcsStatusLock)
    {
        delete l_pcsStatusLock;
        l_pcsStatusLock = NULL;
    }
}


/*++

CalaisHandlerEx:

    The handler service function for Calais on NT5.  This version gets PnP and
    Power Management notifications, too.

Arguments:

    dwOpCode supplies the operation to perform.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/16/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisHandlerEx")

static DWORD WINAPI
CalaisHandlerEx(
    IN DWORD dwControl,
    IN DWORD dwEventType,
    IN PVOID EventData,
    IN PVOID pData)
{
    NEW_THREAD;
    DWORD nRetVal = NO_ERROR;
    LockSection(l_pcsStatusLock, DBGT("Responding to service event"));

    CalaisDebug((DBGT("SCARDSVR!CalaisHandlerEx: Enter\n")));
    try
    {

        //
        // Process the command.
        //

        switch (dwControl)
        {
        case SERVICE_CONTROL_PAUSE:
            // ?noSupport?
            l_srvStatus.dwCurrentState = SERVICE_PAUSED;
            break;

        case SERVICE_CONTROL_CONTINUE:
            l_srvStatus.dwCurrentState = SERVICE_RUNNING;
            // ?noSupport?
            break;

        case SERVICE_CONTROL_INTERROGATE:
            break;

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            l_srvStatus.dwCurrentState = SERVICE_STOP_PENDING;
            l_srvStatus.dwCheckPoint = 0;
            l_srvStatus.dwWaitHint = l_dwWaitHint;
            if (!SetEvent(l_hShutdownEvent))
                CalaisError(__SUBROUTINE__, 516, GetLastError());
            break;

        case SERVICE_CONTROL_DEVICEEVENT:
        {
            DWORD dwSts;
            CTextString tzReader;
            LPCTSTR szReader = NULL;
            DEV_BROADCAST_HDR *pDevHdr = (DEV_BROADCAST_HDR *)EventData;

            CalaisInfo(
                __SUBROUTINE__,
                DBGT("Processing Device Event"));
            switch (dwEventType)
            {
            //
            // A device has been inserted and is now available.
            case DBT_DEVICEARRIVAL:
            {
                DEV_BROADCAST_DEVICEINTERFACE *pDev
                    = (DEV_BROADCAST_DEVICEINTERFACE *)EventData;

                try
                {
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("Processing Device Arrival Event"));
                    if (DBT_DEVTYP_DEVICEINTERFACE == pDev->dbcc_devicetype)
                    {
                        ASSERT(sizeof(DEV_BROADCAST_DEVICEINTERFACE)
                               < pDev->dbcc_size);
                        ASSERT(0 == memcmp(
                                        &pDev->dbcc_classguid,
                                        &l_guidSmartcards,
                                        sizeof(GUID)));
                        ASSERT(0 != pDev->dbcc_name[0]);

                        if (0 == pDev->dbcc_name[1])
                            tzReader = (LPCWSTR)pDev->dbcc_name;
                        else
                            tzReader = (LPCTSTR)pDev->dbcc_name;
                        szReader = tzReader;
                        dwSts = CalaisAddReader(szReader, RDRFLAG_PNPMONITOR);
                        if (ERROR_SUCCESS != dwSts)
                            throw dwSts;
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("New device '%1' added."),
                            szReader);
                    }
                    else
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Spurious device arrival event."));
                }
                catch (DWORD dwError)
                {
                    CalaisError(__SUBROUTINE__, 514, dwError, szReader);
                }
                catch (...)
                {
                    CalaisError(__SUBROUTINE__, 517, szReader);
                }
                break;
            }

            //
            // Permission to remove a device is requested. Any application can
            // deny this request and cancel the removal.
            case DBT_DEVICEQUERYREMOVE:
            {
                DEV_BROADCAST_HANDLE *pDev = (DEV_BROADCAST_HANDLE *)EventData;

                try
                {
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("Processing Device Query Remove Event"));
                    if (DBT_DEVTYP_HANDLE == pDev->dbch_devicetype)
                    {
                        ASSERT(FIELD_OFFSET(
                                    DEV_BROADCAST_HANDLE,
                                    dbch_eventguid)
                                <= pDev->dbch_size);
                        ASSERT(NULL != pDev->dbch_handle);
                        ASSERT(NULL != pDev->dbch_hdevnotify);

                        if (NULL != pDev->dbch_handle)
                        {
                            if (!CalaisQueryReader(pDev->dbch_handle))
                            {
                                CalaisError(
                                    __SUBROUTINE__,
                                    520,
                                    TEXT("DBT_DEVICEQUERYREMOVE/dbch_handle"));
                                nRetVal = ERROR_DEVICE_IN_USE; // BROADCAST_QUERY_DENY
                            }
                            else
                            {
                                szReader = CalaisDisableReader(
                                                (LPVOID)pDev->dbch_handle);
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Device '%1' removal pending."),
                                    szReader);
                            }
                        }
                        else
                        {
                            CalaisError(
                                __SUBROUTINE__,
                                523,
                                TEXT("DBT_DEVICEQUERYREMOVE/dbch_handle"));
                            nRetVal = ERROR_DEVICE_IN_USE; // BROADCAST_QUERY_DENY
                        }
                    }
                    else
                    {
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Spurious device removal query event."));
                        nRetVal = TRUE;
                    }
                }
                catch (DWORD dwError)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Error querying device busy state on reader %2: %1"),
                        dwError,
                        szReader);
                    nRetVal = ERROR_DEVICE_IN_USE; // BROADCAST_QUERY_DENY
                }
                catch (...)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Exception querying device busy state on reader %1"),
                        szReader);
                    CalaisError(
                        __SUBROUTINE__,
                        522,
                        TEXT("DBT_DEVICEQUERYREMOVE"));
                    nRetVal = ERROR_DEVICE_IN_USE; // BROADCAST_QUERY_DENY
                }
                break;
            }

            //
            // Request to remove a device has been canceled.
            case DBT_DEVICEQUERYREMOVEFAILED:
            {
                CBuffer bfDevice;
                DEV_BROADCAST_HANDLE *pDev = (DEV_BROADCAST_HANDLE *)EventData;

                try
                {
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("Processing Device Query Remove Failed Event"));
                    if (DBT_DEVTYP_HANDLE == pDev->dbch_devicetype)
                    {
                        ASSERT(FIELD_OFFSET(
                                    DEV_BROADCAST_HANDLE,
                                    dbch_eventguid)
                                <= pDev->dbch_size);
                        ASSERT(NULL != pDev->dbch_handle);
                        ASSERT(NULL != pDev->dbch_hdevnotify);

                        if (NULL != pDev->dbch_handle)
                        {
                            szReader = CalaisConfirmClosingReader(
                                            pDev->dbch_handle);
                            if (NULL != szReader)
                            {
                                bfDevice.Set(
                                            (LPBYTE)szReader,
                                            (lstrlen(szReader) + 1) * sizeof(TCHAR));
                                szReader = (LPCTSTR)bfDevice.Access();
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Smart Card Resource Manager asked to cancel release of reader %1"),
                                    szReader);
                                if (NULL != pDev->dbch_hdevnotify)
                                {
                                    CalaisRemoveReader(
                                        (LPVOID)pDev->dbch_hdevnotify);
                                    if (NULL != szReader)
                                        dwSts = CalaisAddReader(
                                                    szReader,
                                                    RDRFLAG_PNPMONITOR);
                                }
                            }
                            else
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Smart Card Resource Manager asked to cancel release on unreleased reader"));
                        }
                        else
                            CalaisError(
                                __SUBROUTINE__,
                                521,
                                TEXT("DBT_DEVICEQUERYREMOVEFAILED/dbch_handle"));
                    }
                    else
                    {
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Spurious device removal query failure event."));
                    }
                }
                catch (DWORD dwError)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Error cancelling removal on reader %2: %1"),
                        dwError,
                        szReader);
                }
                catch (...)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Exception cancelling removal on reader %1"),
                        szReader);
                    CalaisError(
                        __SUBROUTINE__,
                        513,
                        TEXT("DBT_DEVICEQUERYREMOVEFAILED"));
                }
                break;
            }

            //
            // Device is about to be removed. Cannot be denied.
            case DBT_DEVICEREMOVEPENDING:
            {
                DEV_BROADCAST_HANDLE *pDev = (DEV_BROADCAST_HANDLE *)EventData;

                try
                {
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("Processing Device Remove Pending Event"));
                    if (DBT_DEVTYP_HANDLE == pDev->dbch_devicetype)
                    {
                        ASSERT(FIELD_OFFSET(
                                    DEV_BROADCAST_HANDLE,
                                    dbch_eventguid)
                                <= pDev->dbch_size);
                        ASSERT(NULL != pDev->dbch_handle);
                        ASSERT(NULL != pDev->dbch_hdevnotify);

                        if (NULL != pDev->dbch_handle)
                        {
                            szReader = CalaisDisableReader(pDev->dbch_handle);
                            CalaisWarning(
                                __SUBROUTINE__,
                                DBGT("Device '%1' being removed."),
                                szReader);
                        }
                        else
                            CalaisError(
                                __SUBROUTINE__,
                                512,
                                TEXT("DBT_DEVICEREMOVEPENDING/dbch_handle"));
                    }
                    else
                    {
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Spurious device removal pending event."));
                    }
                }
                catch (DWORD dwError)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Error removing reader %2: %1"),
                        dwError,
                        szReader);
                }
                catch (...)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Exception removing reader %1"),
                        szReader);
                    CalaisError(
                        __SUBROUTINE__,
                        511,
                        TEXT("DBT_DEVICEREMOVEPENDING"));
                }
                break;
            }

            //
            // Device has been removed.
            case DBT_DEVICEREMOVECOMPLETE:
            {
                try
                {
                    switch (pDevHdr->dbch_devicetype)
                    {
                    case DBT_DEVTYP_HANDLE:
                    {
                        DEV_BROADCAST_HANDLE *pDev =
                            (DEV_BROADCAST_HANDLE *)EventData;
                        try
                        {
                            CalaisInfo(
                                __SUBROUTINE__,
                                DBGT("Processing Device Remove Complete by handle Event"));
                            ASSERT(FIELD_OFFSET(
                                        DEV_BROADCAST_HANDLE,
                                        dbch_eventguid)
                                    <= pDev->dbch_size);
                            ASSERT(DBT_DEVTYP_HANDLE == pDev->dbch_devicetype);
                            ASSERT(NULL != pDev->dbch_handle);
                            ASSERT(NULL != pDev->dbch_hdevnotify);

                            if ((NULL != pDev->dbch_handle)
                                && (NULL != pDev->dbch_hdevnotify))
                            {
                                szReader = CalaisDisableReader(
                                                pDev->dbch_handle);
                                CalaisRemoveReader(
                                    (LPVOID)pDev->dbch_hdevnotify);
                                if (NULL != szReader)
                                    CalaisWarning(
                                        __SUBROUTINE__,
                                        DBGT("Device '%1' removed."),
                                        szReader);
                            }
                            else
                            {
                                if (NULL == pDev->dbch_handle)
                                    CalaisError(
                                        __SUBROUTINE__,
                                        510,
                                        TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_HANDLE/dbch_handle"));
                                if (NULL == pDev->dbch_hdevnotify)
                                    CalaisError(
                                        __SUBROUTINE__,
                                        519,
                                        TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_HANDLE/dbch_hdevnotify"));
                            }
                        }
                        catch (DWORD dwError)
                        {
                            CalaisWarning(
                                __SUBROUTINE__,
                                DBGT("Error completing removal of reader %2: %1"),
                                dwError,
                                szReader);
                        }
                        catch (...)
                        {
                            CalaisWarning(
                                __SUBROUTINE__,
                                DBGT("Exception completing removal of reader %1"),
                                szReader);
                            CalaisError(
                                __SUBROUTINE__,
                                509,
                                TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_HANDLE"));
                        }
                        break;
                    }
                    case DBT_DEVTYP_DEVICEINTERFACE:
                    {
                        DEV_BROADCAST_DEVICEINTERFACE *pDev
                            = (DEV_BROADCAST_DEVICEINTERFACE *)EventData;

                        try
                        {
                            CalaisInfo(
                                __SUBROUTINE__,
                                DBGT("Processing Device Remove Complete by interface Event"));
                            ASSERT(sizeof(DEV_BROADCAST_DEVICEINTERFACE)
                                    < pDev->dbcc_size);
                            ASSERT(DBT_DEVTYP_DEVICEINTERFACE
                                    == pDev->dbcc_devicetype);
                            ASSERT(0 == memcmp(
                                            &pDev->dbcc_classguid,
                                            &l_guidSmartcards,
                                            sizeof(GUID)));
                            ASSERT(0 != pDev->dbcc_name[0]);

                            if (0 == pDev->dbcc_name[1])
                                tzReader = (LPCWSTR)pDev->dbcc_name;
                            else
                                tzReader = (LPCTSTR)pDev->dbcc_name;
                            szReader = tzReader;
                            dwSts = CalaisRemoveDevice(szReader);
                            if (ERROR_SUCCESS == dwSts)
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Device '%1' Removed."),
                                    szReader);
                            else
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Error removing device '%2': %1"),
                                    dwSts,
                                    szReader);
                        }
                        catch (DWORD dwError)
                        {
                            CalaisWarning(
                                __SUBROUTINE__,
                                DBGT("Error completing removal of reader %2: %1"),
                                dwError,
                                szReader);
                        }
                        catch (...)
                        {
                            CalaisWarning(
                                __SUBROUTINE__,
                                DBGT("Exception completing removal of reader %1"),
                                szReader);
                            CalaisError(
                                __SUBROUTINE__,
                                508,
                                TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_DEVICEINTERFACE"));
                        }
                        break;
                    }
                    default:
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Unrecognized PnP Device Removal Type"));
                        break;
                    }
                }
                catch (...)
                {
                    CalaisError(
                        __SUBROUTINE__,
                        518,
                        TEXT("DBT_DEVICEREMOVECOMPLETE"));
                }
                break;
            }

            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Unrecognized PnP Event"));
                break;
            }
            break;
        }

        case SERVICE_CONTROL_POWEREVENT:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Smart Card Resource Manager received Power Event!"));
            break;

        default: // No action
            break;
        }
    }
    catch (DWORD dwError)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Smart Card Resource Manager received error on service action: %1"),
            dwError);
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Smart Card Resource Manager recieved exception on service action"));
    }

    l_srvStatus.dwWin32ExitCode = nRetVal;
    if (!SetServiceStatus(l_hService, &l_srvStatus))
        CalaisError(__SUBROUTINE__, 515, GetLastError());

    CalaisDebug(
        (DBGT("SCARDSVR!CalaisHandlerEx: Exit (%lx)\n"),
        nRetVal));
    return nRetVal;
}


/*++

CalaisTerminate:

    This function is called if the C Run Time Library wants to declare a fault.
    If we get here, we're not coming back.

Arguments:

    None

Return Value:

    None (program exits on return)

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 12/2/1998

--*/

#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisTerminate")
void __cdecl
CalaisTerminate(
    void)
{
    ResetEvent(AccessStartedEvent());
    SetEvent(AccessStoppedEvent());
#ifdef DBG
    TCHAR szTid[sizeof(DWORD) * 2 + 3];
    _stprintf(szTid, TEXT("0x%p"), GetCurrentThreadId);
    CalaisError(
        __SUBROUTINE__,
        DBGT("Fatal Unhandled Exception: TID=%1"),
        szTid);
    DebugBreak();
#endif
}


/*++

UnregisterServer:

    This service removes the registry entries associated with the Calais
    Service.

Arguments:

    None

Return Value:

    Status code as an HRESULT.

Author:

    Doug Barlow (dbarlow) 8/26/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("UnregisterServer")

static HRESULT
UnregisterServer(
    void)
{
    HRESULT hReturnStatus = NO_ERROR;
    SC_HANDLE schService = NULL;
    SC_HANDLE schSCManager = NULL;
    LPCTSTR rgszServices[3];
    DWORD dwIndex;
    LPCTSTR szSvc;


    //
    // Get the service names.
    //

    rgszServices[0] = CalaisString(CALSTR_PRIMARYSERVICE);
    rgszServices[1] = CalaisString(CALSTR_LEGACYSERVICE);
    rgszServices[2] = CalaisString(CALSTR_DEBUGSERVICE);


    //
    // Eliminate the services.
    //

    try
    {
        BOOL fSts;
        SERVICE_STATUS ssStatus;    // current status of the service

        schSCManager = OpenSCManager(
                            NULL,                   // machine (NULL == local)
                            NULL,                   // database (NULL == default)
                            SC_MANAGER_ALL_ACCESS); // access required
        if (NULL == schSCManager)
            throw GetLastError();
        for (dwIndex = sizeof(rgszServices) / sizeof(LPCTSTR); 0 < dwIndex;)
        {
            szSvc = rgszServices[--dwIndex];
            schService = OpenService(
                            schSCManager,
                            szSvc,
                            SERVICE_ALL_ACCESS);
            if (NULL == schService)
                continue;

            do
            {
                fSts = QueryServiceStatus(schService, &ssStatus);
                if (fSts)
                {
                    switch (ssStatus.dwCurrentState)
                    {
                    case SERVICE_START_PENDING:
                    case SERVICE_STOP_PENDING:
                    case SERVICE_CONTINUE_PENDING:
                    case SERVICE_PAUSE_PENDING:
                        Sleep(1000);
                        break;
                    case SERVICE_RUNNING:
                    case SERVICE_PAUSED:
                        fSts = ControlService(
                                    schService,
                                    SERVICE_CONTROL_STOP,
                                    &ssStatus);
                        break;
                    case SERVICE_STOPPED:
                        fSts = DeleteService(schService);
                        if (!fSts)
                            throw GetLastError();
                        fSts = FALSE;
                        break;
                    default:
                        fSts = FALSE;
                    }
                }
            } while (fSts);
            CloseServiceHandle(schService);
            schService = NULL;
        }
        CloseServiceHandle(schSCManager);
        schSCManager = NULL;
    }
    catch (DWORD dwErr)
    {
        if (NULL != schService)
            CloseServiceHandle(schService);
        if (NULL != schSCManager)
            CloseServiceHandle(schSCManager);
        hReturnStatus = HRESULT_FROM_WIN32(dwErr);
    }
    if (NO_ERROR != hReturnStatus)
        goto ErrorExit;


    //
    // Disable automatic certificate propagation.
    //

    hReturnStatus = RemoveCertProp();


    //
    // Delete any left over service registry entries.
    //

    try
    {
        CRegistry regServices(
                        HKEY_LOCAL_MACHINE,
                        CalaisString(CALSTR_SERVICESREGISTRYKEY));

        if (ERROR_SUCCESS == regServices.Status(TRUE))
        {
            for (dwIndex = sizeof(rgszServices) / sizeof(LPCTSTR); 0 < dwIndex;)
            {
                szSvc = rgszServices[--dwIndex];
                regServices.DeleteKey(szSvc, TRUE);
            }
        }
    }
    catch (DWORD) {}


    //
    // Delete any event log registry entries.
    //

    try
    {
        LPCTSTR szCategory;
        DWORD dwSubkey = 0;
        CRegistry regEventLog(
                        HKEY_LOCAL_MACHINE,
                        CalaisString(CALSTR_EVENTLOGREGISTRYKEY));
        CRegistry regCategory;

        if (ERROR_SUCCESS == regEventLog.Status(TRUE))
        {
            for (;;)
            {
                szCategory = regEventLog.Subkey(dwSubkey);
                if (NULL == szCategory)
                    break;
                regCategory.Open(regEventLog, szCategory);
                if (ERROR_SUCCESS == regCategory.Status(TRUE))
                {
                    for (dwIndex = sizeof(rgszServices) / sizeof(LPCTSTR);
                         0 < dwIndex;)
                    {
                        szSvc = rgszServices[--dwIndex];
                        regCategory.DeleteKey(szSvc, TRUE);
                    }
                }
                dwSubkey += 1;
            }
        }
    }
    catch (DWORD) {}


    //
    // Delete any superfluous registry entries.
    //

    try
    {
        CRegistry regCalais(
                        HKEY_LOCAL_MACHINE,
                        CalaisString(CALSTR_CALAISREGISTRYKEY));

        regCalais.DeleteKey(CalaisString(CALSTR_READERREGISTRYSUBKEY), TRUE);
        regCalais.DeleteKey(CalaisString(CALSTR_DEBUGREGISTRYSUBKEY), TRUE);
    }
    catch (DWORD) {}


    //
    // All done!
    //

ErrorExit:
    return hReturnStatus;
}


/*++

RegisterServer:

    This function installs the proper registry entries to enable the Calais
    service.

Arguments:

    None

Return Value:

    Status code as an HRESULT.

Author:

    Doug Barlow (dbarlow) 8/26/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("RegisterServer")

static HRESULT
RegisterServer(
    void)
{
    HRESULT hReturnStatus = NO_ERROR;
    SC_HANDLE schService = NULL;
    SC_HANDLE schSCManager = NULL;
    DWORD dwStatus;
    BOOL fSts;
    TCHAR szServiceFile[MAX_PATH];
    SERVICE_DESCRIPTION ServDesc = { NULL };


    //
    // Find the Service Executable.
    //

    dwStatus = GetModuleFileName(
                    NULL,
                    szServiceFile,
                    sizeof(szServiceFile) / sizeof(TCHAR));
    if (0 == dwStatus)
    {
        dwStatus = ExpandEnvironmentStrings(
            CalaisString(CALSTR_CALAISEXECUTABLE),
            szServiceFile,
            sizeof(szServiceFile));
        if (0 == dwStatus)
        {
            hReturnStatus = HRESULT_FROM_WIN32(GetLastError());
            goto ErrorExit;
        }
    }


    //
    // Establish the Event Log Entries.
    //

    try
    {
        CRegistry regEventLog(
                        HKEY_LOCAL_MACHINE,
                        CalaisString(CALSTR_EVENTLOGREGISTRYKEY));
        CRegistry regCategory(
                        regEventLog,
                        CalaisString(CALSTR_SYSTEMREGISTRYSUBKEY));
        CRegistry regService(
                        regCategory,
                        CalaisString(CALSTR_PRIMARYSERVICE),
                        KEY_ALL_ACCESS,
                        REG_OPTION_NON_VOLATILE);

        regService.SetValue(
                        CalaisString(CALSTR_EVENTMESSAGEFILESUBKEY),
                        szServiceFile,
                        REG_SZ);
        regService.SetValue(
                        CalaisString(CALSTR_TYPESSUPPORTEDSUBKEY),
                        (DWORD)(EVENTLOG_ERROR_TYPE
                                | EVENTLOG_WARNING_TYPE
                                | EVENTLOG_INFORMATION_TYPE));
    }
    catch (DWORD dwErr)
    {
        hReturnStatus = HRESULT_FROM_WIN32(dwErr);
    }
    if (NO_ERROR != hReturnStatus)
        goto ErrorExit;


    //
    // Introduce the services.
    //

    try
    {
        schSCManager = OpenSCManager(
                            NULL,                   // machine (NULL == local)
                            NULL,                   // database (NULL == default)
                            SC_MANAGER_ALL_ACCESS); // access required
        if (NULL == schSCManager)
            throw GetLastError();

        schService = CreateService(
                            schSCManager,
                            CalaisString(CALSTR_PRIMARYSERVICE),
                            CalaisString(CALSTR_PRIMARYSERVICEDISPLAY),
                            SERVICE_ALL_ACCESS,
#ifdef DBG
                            SERVICE_INTERACTIVE_PROCESS |
#endif
                            SERVICE_WIN32_SHARE_PROCESS,
                            SERVICE_DEMAND_START,
                            SERVICE_ERROR_IGNORE,
                            szServiceFile,
                            NULL,   // Service Group
                            NULL,   // Tag Id
                            CalaisString(CALSTR_SERVICEDEPENDENCIES),
                            NULL,   // User Account
                            NULL);  // Password
        if (NULL == schService)
            throw GetLastError();

        ServDesc.lpDescription = (LPTSTR)CalaisString(CALSTR_PRIMARYSERVICEDESC);
        fSts = ChangeServiceConfig2(
                    schService,
                    SERVICE_CONFIG_DESCRIPTION,
                    &ServDesc);
        if (!fSts)
            throw GetLastError();

        CSecurityDescriptor aclService;

        aclService.InitializeFromProcessToken();
        aclService.Allow(
            &aclService.SID_System,
			l_dwSystemAccess);
        aclService.Allow(
            &aclService.SID_LocalService,
            SERVICE_ALL_ACCESS);
        aclService.Allow(
            &aclService.SID_Admins,
            SERVICE_ALL_ACCESS);
        aclService.Allow(
            &aclService.SID_SrvOps,
            SERVICE_ALL_ACCESS);
        aclService.Allow(
            &aclService.SID_Local,
            l_dwInteractiveAccess);
        fSts = SetServiceObjectSecurity(
                    schService,
                    DACL_SECURITY_INFORMATION,
                    aclService);
        if (!fSts)
            throw GetLastError();

        CloseServiceHandle(schService);
        schService = NULL;

#ifdef DEBUG_SERVICE
        schService = CreateService(
                            schSCManager,
                            CalaisString(CALSTR_DEBUGSERVICE),
                            CalaisString(CALSTR_DEBUGSERVICEDISPLAY),
                            SERVICE_ALL_ACCESS,
                            SERVICE_INTERACTIVE_PROCESS |
                            SERVICE_WIN32_SHARE_PROCESS,
                            SERVICE_DEMAND_START,
                            SERVICE_ERROR_IGNORE,
                            szServiceFile,
                            NULL,   // load order group
                            NULL,   // Tag Id
                            NULL,   // Dependencies
                            NULL,   // User Account
                            NULL);  // Password
        if (NULL == schService)
            throw GetLastError();

        ServDesc.lpDescription = (LPTSTR)CalaisString(CALSTR_DEBUGSERVICEDESC);
        fSts = ChangeServiceConfig2(
                    schService,
                    SERVICE_CONFIG_DESCRIPTION,
                    &ServDesc);
        if (!fSts)
            throw GetLastError();

        CloseServiceHandle(schService);
        schService = NULL;
#endif

        schService = CreateService(
                        schSCManager,
                        CalaisString(CALSTR_LEGACYSERVICE),
                        CalaisString(CALSTR_LEGACYSERVICEDISPLAY),
                        SERVICE_ALL_ACCESS,
#ifdef DBG
                        SERVICE_INTERACTIVE_PROCESS |
#endif
                        SERVICE_WIN32_SHARE_PROCESS,
                        SERVICE_DEMAND_START,
                        SERVICE_ERROR_IGNORE,
                        szServiceFile,
                        NULL,   // load order group
                        NULL,   // Tag Id
                        CalaisString(CALSTR_LEGACYDEPENDONGROUP),
                        NULL,   // User Account
                        NULL);  // Password
        if (NULL == schService)
            throw GetLastError();

        ServDesc.lpDescription = (LPTSTR)CalaisString(CALSTR_LEGACYSERVICEDESC);
        fSts = ChangeServiceConfig2(
                    schService,
                    SERVICE_CONFIG_DESCRIPTION,
                    &ServDesc);
        if (!fSts)
            throw GetLastError();

        fSts = SetServiceObjectSecurity(
                    schService,
                    DACL_SECURITY_INFORMATION,
                    aclService);
        if (!fSts)
            throw GetLastError();

        CloseServiceHandle(schService);
        schService = NULL;


        //
        // Enable automatic certificate propagation.
        //

        hReturnStatus = AddCertProp();
        if (NO_ERROR != hReturnStatus)
            goto ErrorExit;

        CloseServiceHandle(schSCManager);
        schSCManager = NULL;
    }
    catch (DWORD dwErr)
    {
        if (NULL != schService)
            CloseServiceHandle(schService);
        if (NULL != schSCManager)
            CloseServiceHandle(schSCManager);
        hReturnStatus = HRESULT_FROM_WIN32(dwErr);
    }
    if (NO_ERROR != hReturnStatus)
        goto ErrorExit;


    //
    // All done!
    //

    return hReturnStatus;


    //
    // An error was detected.  Clean up any outstanding resources and
    // return the error.
    //

ErrorExit:
    UnregisterServer();
    return hReturnStatus;
}


/*++

AddSounds:

    Enable the sound features of the certificate propper for this user.

Arguments:

    None

Return Value:

    Status code as an HRESULT.

Author:

    Doug Barlow (dbarlow) 1/27/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AddSounds")

static HRESULT
AddSounds(
    void)
{
    HRESULT hReturnStatus = HRESULT_FROM_WIN32(SCARD_F_UNKNOWN_ERROR);
    LPCTSTR szNames[2] =
        {   CalaisString(CALSTR_SMARTCARDINSERTION),
            CalaisString(CALSTR_SMARTCARDREMOVAL) };
    LPCTSTR szDisplay[2] =
        {   CalaisString(CALSTR_SMARTCARD_INSERTION),
            CalaisString(CALSTR_SMARTCARD_REMOVAL) };
    DWORD dwIndex;

    try
    {
        CRegistry regScValue;
        CRegistry regDefault;
        CRegistry regAppEvents(HKEY_CURRENT_USER, CalaisString(CALSTR_APPEVENTS));
        CRegistry regEventLabels(regAppEvents, CalaisString(CALSTR_EVENTLABELS));
        CRegistry regDefScheme(regAppEvents, CalaisString(CALSTR_SOUNDSREGISTRY));

        for (dwIndex = 0; dwIndex < 2; dwIndex += 1)
        {
            regScValue.Open(
                regEventLabels,
                szNames[dwIndex],
                KEY_ALL_ACCESS,
                REG_OPTION_NON_VOLATILE);
            if (!regScValue.ValueExists(NULL))
                regScValue.SetValue(NULL, szDisplay[dwIndex]);
            regScValue.Close();

            regScValue.Open(
                regDefScheme,
                szNames[dwIndex],
                KEY_ALL_ACCESS,
                REG_OPTION_NON_VOLATILE);

            regDefault.Open(
                regScValue,
                TEXT(".Current"),
                KEY_ALL_ACCESS,
                REG_OPTION_NON_VOLATILE);
            if (!regDefault.ValueExists(NULL))
                regDefault.SetValue(NULL, TEXT(""));
            regDefault.Close();

            regDefault.Open(
                regScValue,
                TEXT(".Default"),
                KEY_ALL_ACCESS,
                REG_OPTION_NON_VOLATILE);
            if (ERROR_SUCCESS != regDefault.ValueExists(NULL))
                regDefault.SetValue(NULL, TEXT(""));
            regDefault.Close();
        }
    }
    catch (DWORD dwErr)
    {
        hReturnStatus = HRESULT_FROM_WIN32(dwErr);
        goto ErrorExit;
    }


    //
    // All done!
    //

    return NO_ERROR;


    //
    // An error was detected.  Clean up any outstanding resources and
    // return the error.
    //

ErrorExit:
    RemoveSounds();
    return hReturnStatus;
}


/*++

RemoveSounds:

    This function removes sound entries for the current user.

Arguments:

    None

Return Value:

    Status code as an HRESULT.

Author:

    Doug Barlow (dbarlow) 1/28/1999

--*/

static HRESULT
RemoveSounds(
    void)
{
    HRESULT hReturnStatus = HRESULT_FROM_WIN32(SCARD_F_UNKNOWN_ERROR);
    LPCTSTR szNames[2] =
        {   CalaisString(CALSTR_SMARTCARDINSERTION),
            CalaisString(CALSTR_SMARTCARDREMOVAL) };
    DWORD dwIndex;

    try
    {
        CRegistry regAppEvents(HKEY_CURRENT_USER, CalaisString(CALSTR_APPEVENTS));
        CRegistry regEventLabels(regAppEvents, CalaisString(CALSTR_EVENTLABELS));
        CRegistry regDefScheme(regAppEvents, CalaisString(CALSTR_SOUNDSREGISTRY));

        for (dwIndex = 0; dwIndex < 2; dwIndex += 1)
        {
                regEventLabels.DeleteKey(szNames[dwIndex], TRUE);
                regDefScheme.DeleteKey(szNames[dwIndex], TRUE);
        }
    }
    catch (DWORD dwErr)
    {
        hReturnStatus = HRESULT_FROM_WIN32(dwErr);
        goto ErrorExit;
    }


    //
    // All done!
    //

    return NO_ERROR;


    //
    // An error was detected.  Clean up any outstanding resources and
    // return the error.
    //

ErrorExit:
    return hReturnStatus;
}


/*++

AddCertProp:

    Add the registry entry to enable automatic certificate propagation.

Arguments:

    None

Return Value:

    Status code as an HRESULT.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 2/2/1999

--*/

static HRESULT
AddCertProp(
    void)
{
    HRESULT hReturnStatus = HRESULT_FROM_WIN32(SCARD_F_UNKNOWN_ERROR);


    //
    // Fill in the new registry key values.
    //

    try
    {
        CRegistry regNotify(
                    HKEY_LOCAL_MACHINE,
                    CalaisString(CALSTR_CERTPROPREGISTRY));
        CRegistry regCertProp(
                    regNotify,
                    CalaisString(CALSTR_CERTPROPKEY),
                    KEY_ALL_ACCESS,
                    REG_OPTION_NON_VOLATILE);

        regCertProp.SetValue(CalaisString(CALSTR_DLLNAME),      CalaisString(CALSTR_CERTPROPDLL));
        regCertProp.SetValue(CalaisString(CALSTR_LOGON),        CalaisString(CALSTR_CERTPROPSTART));
        regCertProp.SetValue(CalaisString(CALSTR_LOGOFF),       CalaisString(CALSTR_CERTPROPSTOP));
        regCertProp.SetValue(CalaisString(CALSTR_LOCK),         CalaisString(CALSTR_CERTPROPSUSPEND));
        regCertProp.SetValue(CalaisString(CALSTR_UNLOCK),       CalaisString(CALSTR_CERTPROPRESUME));
        regCertProp.SetValue(CalaisString(CALSTR_ENABLED),      1);
        regCertProp.SetValue(CalaisString(CALSTR_IMPERSONATE),  1);
        regCertProp.SetValue(CalaisString(CALSTR_ASYNCHRONOUS), 1);
    }
    catch (DWORD dwErr)
    {
        hReturnStatus = HRESULT_FROM_WIN32(dwErr);
        RemoveCertProp();
        goto ErrorExit;
    }


    //
    // All done!
    //

    return NO_ERROR;


    //
    // An error was detected.  Clean up any outstanding resources and
    // return the error.
    //

ErrorExit:
    return hReturnStatus;
}


/*++

RemoveCertProp:

    Remove the registry entry to disable automatic certificate propagation.

Arguments:

    None

Return Value:

    Status code as an HRESULT.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 2/2/1999

--*/

static HRESULT
RemoveCertProp(
    void)
{
    HRESULT hReturnStatus = HRESULT_FROM_WIN32(SCARD_F_UNKNOWN_ERROR);


    //
    // Only one registry entry to delete.
    //

    try
    {
        CRegistry regNotify(
                    HKEY_LOCAL_MACHINE,
                    CalaisString(CALSTR_CERTPROPREGISTRY));

        regNotify.DeleteKey(CalaisString(CALSTR_CERTPROPKEY), TRUE);
    }
    catch (DWORD dwErr)
    {
        hReturnStatus = HRESULT_FROM_WIN32(dwErr);
        goto ErrorExit;
    }


    //
    // All done!
    //

    return NO_ERROR;


    //
    // An error was detected.  Clean up any outstanding resources and
    // return the error.
    //

ErrorExit:
    return hReturnStatus;
}


/*++

AutoLock:

    Adjust the registry entry to control logon card removal actions.

Arguments:

    dwOption supplies the action to take on card removal.  Currently defined
        values are:

        0 - No action
        1 - Lock the workstation
        2 - Logoff the workstation

Return Value:

    Status code as an HRESULT.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/22/1999

--*/

static HRESULT
AutoLock(
    DWORD dwOption)
{
    HRESULT hReturnStatus = HRESULT_FROM_WIN32(SCARD_F_UNKNOWN_ERROR);
    try
    {
        TCHAR szNum[36];    // Space for a number

        _ultot(dwOption, szNum, 10);
        CRegistry regAuto(
                    HKEY_LOCAL_MACHINE,
                    CalaisString(CALSTR_LOGONREGISTRY));
        regAuto.SetValue(CalaisString(CALSTR_LOGONREMOVEOPTION), szNum);
        hReturnStatus = ERROR_SUCCESS;
    }
    catch (DWORD dwErr)
    {
        hReturnStatus = HRESULT_FROM_WIN32(dwErr);
    }
    return hReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\scredir\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 2000

Module Name:

    makefile.inc.

!ENDIF

$(O)\scredir.idl: $(DS_INC_PATH)\scredir.idl
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\server\calserve.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    CalServe

Abstract:

    This is the primary header file for the Calais Service Manager Server
    application.  It stores common definitions and references the other major
    header files.

Author:

    Doug Barlow (dbarlow) 10/23/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _CALSERVE_H_
#define _CALSERVE_H_

#include <eh.h>
#include <WinSCard.h>
#include <calmsgs.h>
#include <SCardLib.h>
#include <CalCom.h>
#include <SCardErr.h>

#define CALAIS_STACKSIZE 0 // Default stack.

#define NEW_THREAD set_terminate(CalaisTerminate)


//
// Critical Sections and reference numbers.
// &g_csControlLocks[CSLOCK_SERVERLOCK]
//

#define CSLOCK_CALAISCONTROL    0   // Lock for Calais control commands.
#define CSLOCK_SERVERLOCK       1   // Lock for server thread enumeration.

#ifdef DBG
#define CSLOCK_TRACELOCK        2   // Lock for tracing output.

#define CSLOCK_MAXLOCKS         3
#else
#define CSLOCK_MAXLOCKS         2
#endif

extern CCriticalSectionObject *g_pcsControlLocks[CSLOCK_MAXLOCKS];
extern CMultiEvent *g_phReaderChangeEvent;
extern DWORD g_dwDefaultIOMax;


//
// Calais Control definitions.
//

class CReader;
class CReaderReference;

extern DWORD
CalaisStart(
    void);

extern DWORD
CalaisReaderCount(
    void);

extern DWORD
CalaisCountReaders(
    void);

extern CReaderReference *
CalaisLockReader(
    LPCTSTR szReader);

extern void
CalaisReleaseReader(
    CReaderReference **ppRdrRef);

extern DWORD
CalaisAddReader(
    IN CReader *pRdr);

extern DWORD
CalaisAddReader(
    IN LPCTSTR szReader,
    IN DWORD dwFlags);

extern BOOL
CalaisQueryReader(
    HANDLE hReader);

extern LPCTSTR
CalaisDisableReader(
    HANDLE hDriver);

extern LPCTSTR
CalaisConfirmClosingReader(
    HANDLE hDriver);

extern DWORD
CalaisRemoveReader(
    IN LPCTSTR szReader);

extern DWORD
CalaisRemoveReader(
    LPVOID hAppCtrl);

extern DWORD
CalaisRemoveReader(
    DWORD dwIndex);

extern DWORD
CalaisRemoveDevice(
    LPCTSTR szDevice);

extern void
CalaisStop(
    void);

extern DWORD WINAPI
CalaisTerminateReader(
    LPVOID pvParam);    // Don't call this except from CalaisRemoveReader.

extern HANDLE g_hCalaisShutdown;

extern void
AppInitializeDeviceRegistration(
    SERVICE_STATUS_HANDLE hService,
    DWORD dwType);

extern void
AppTerminateDeviceRegistration(
    void);

extern void
AppRegisterDevice(
    HANDLE hReader,
    LPCTSTR szReader,
    LPVOID *ppvAppState);

extern void
AppUnregisterDevice(
    HANDLE hReader,
    LPCTSTR szReader,
    LPVOID *ppvAppState);

extern void __cdecl
CalaisTerminate(
    void);


//
//==============================================================================
//
//  CReader
//

#define RDRFLAG_PNPMONITOR  0x0001  // This reader should be monitored by the
                                    // PnP subsystem.

class CReader
{
public:

    typedef enum {
        Undefined,      // Used to indicate an unset value
        Idle,           // No card inserted, unconnected
        Present,        // Card present, but not reset
        Unresponsive,   // Tried to initalize, but failed
        Unsupported,    // The card isn't supported by this reader
        Ready,          // Card inserted, powered, w/ ATR, unconnected
        Shared,         // Ready + connected shared
        Exclusive,      // Ready + connected exclusive
        Direct,         // Connected in raw mode.
        Closing,        // Shutting down, no new connections accepted.
        Broken,         // Something is wrong, reader disabled
        Inactive        // Starting up or completely shut down.
    } AvailableState;

    typedef struct {
        DWORD dwInsertCount;
        DWORD dwRemoveCount;
        DWORD dwResetCount;
    } ActiveState;

    //  Constructors & Destructor
    CReader();
    virtual ~CReader();

    BOOL InitFailed(void) 
    { 
        return 
            m_rwLock.InitFailed() || 
            m_mtxGrab.InitFailed() ||
            m_ChangeEvent.InitFailed();
    }

    //  Properties

    //  Overridable Methods
    virtual void Initialize(void);
    virtual void Close(void);
    virtual void Disable(void);
    virtual HANDLE ReaderHandle(void) const;
    virtual LPCTSTR DeviceName(void) const;
    virtual DWORD
    Control(
        DWORD dwCode,
        LPCBYTE pbSend = NULL,
        DWORD cbSend = 0,
        LPBYTE pbRecv = NULL,
        LPDWORD pcbLen = NULL,
        BOOL fLogError = TRUE);

    // Trivial inline methods
    AvailableState AvailabilityStatus(void)
    {
        CLockRead rwLock(&m_rwLock);
        return m_dwAvailStatus;
    };
    HANDLE ChangeEvent(void)
    { return m_ChangeEvent.WaitHandle(); };
    LPCTSTR ReaderName(void) const
    { return (LPCTSTR)m_bfReaderName.Access(); };
    void Atr(CBuffer &bfAtr)
    {
        CLockRead rwLock(&m_rwLock);
        bfAtr.Set(m_bfCurrentAtr.Access(), m_bfCurrentAtr.Length());
    };
    DWORD Protocol(void)
    {
        CLockRead rwLock(&m_rwLock);
        return m_dwCurrentProtocol;
    };
    WORD ActivityHash(void)
    {
        CLockRead rwLock(&m_rwLock);
        return (WORD)(0x0000ffff &
                      (m_ActiveState.dwInsertCount
                       + m_ActiveState.dwRemoveCount));
    };
    BOOL IsGrabbedBy(DWORD dwThreadId)
    { return m_mtxGrab.IsGrabbedBy(dwThreadId); };
    BOOL IsGrabbedByMe(void)
    { return m_mtxGrab.IsGrabbedByMe(); };
    BOOL IsLatchedBy(DWORD dwThreadId)
    { return m_mtxLatch.IsGrabbedBy(dwThreadId); };
    BOOL IsLatchedByMe(void)
    { return m_mtxLatch.IsGrabbedByMe(); };
    BOOL ShareReader(void)
    { return m_mtxGrab.Share(); };
    BOOL Unlatch(void)
    { return m_mtxLatch.Share(); };
    DWORD GetCurrentState(void)
    {
        CLockRead rwLock(&m_rwLock);
        return m_dwCurrentState;
    };

    //  Base Object Methods
    void GrabReader(void);
    void LatchReader(const ActiveState *pActiveState);
    void VerifyActive(const ActiveState *pActiveState);
    void VerifyState(void);
    void Dispose(
        IN DWORD dwDisposition,
        IN OUT CReader::ActiveState *pActiveState);
    void Connect(
        IN DWORD dwShareMode,
        IN DWORD dwPreferredProtocols,
        OUT ActiveState *pActState);
    void Disconnect(
        IN OUT ActiveState *pActState,
        IN DWORD dwDisposition,
        OUT LPDWORD pdwDispSts);
    void Reconnect(
        IN DWORD dwShareMode,
        IN DWORD dwPreferredProtocols,
        IN DWORD dwDisposition,
        IN OUT ActiveState *pActState,
        OUT LPDWORD pdwDispSts);
    void Free(
        DWORD dwThreadId,
        DWORD dwDisposition);
    BOOL IsInUse(void);

    // Convenience routines
    void GetReaderAttr(DWORD dwAttr, CBuffer &bfValue, BOOL fLogError = TRUE);
    void SetReaderAttr(DWORD dwAttr, LPCVOID pvValue, DWORD cbValue, BOOL fLogError = TRUE);
    void SetReaderProto(DWORD dwProto);
    void ReaderTransmit(LPCBYTE pbSend, DWORD cbSend, CBuffer &bfRecv);
    void ReaderSwallow(void);
    void ReaderColdReset(CBuffer &bfAtr);
    void ReaderWarmReset(CBuffer &bfAtr);
    void ReaderPowerDown(void);
    void ReaderEject(void);
#ifdef SCARD_CONFISCATE_CARD
    void ReaderConfiscate(void);
#endif
    DWORD GetReaderState(void);
    DWORD
    GetReaderAttr(
        ActiveState *pActiveState,
        DWORD dwAttr,
        BOOL fLogError = TRUE);
    void
    SetReaderAttr(
        ActiveState *pActiveState,
        DWORD dwAttr,
        DWORD dwValue,
        BOOL fLogError = TRUE);
    DWORD GetReaderAttr(DWORD dwAttr, BOOL fLogError = TRUE);
    void SetReaderAttr(DWORD dwAttr, DWORD dwValue, BOOL fLogError = TRUE);
    DWORD
    Control(
        ActiveState *pActiveState,
        DWORD dwCode,
        LPCBYTE pbSend = NULL,
        DWORD cbSend = 0,
        LPBYTE pbRecv = NULL,
        LPDWORD pcbLen = NULL,
        BOOL fLogError = TRUE);
    void
    GetReaderAttr(
        ActiveState *pActiveState,
        DWORD dwAttr,
        CBuffer &bfValue,
        BOOL fLogError = TRUE);
    void
    SetReaderAttr(
        ActiveState *pActiveState,
        DWORD dwAttr,
        LPCVOID pvValue,
        DWORD cbValue,
        BOOL fLogError = TRUE);
    void
    SetReaderProto(
        ActiveState *pActiveState,
        DWORD dwProto);
    void
    SetActive(
        IN BOOL fActive);
    void
    ReaderTransmit(
        ActiveState *pActiveState,
        LPCBYTE pbSend,
        DWORD cbSend,
        CBuffer &bfRecv);
    void
    ReaderSwallow(
        ActiveState *pActiveState);
    void
    ReaderColdReset(
        ActiveState *pActiveState,
        CBuffer &bfAtr);
    void
    ReaderWarmReset(
        ActiveState *pActiveState,
        CBuffer &bfAtr);
    void
    ReaderPowerDown(
        ActiveState *pActiveState);
    void
    ReaderEject(
        ActiveState *pActiveState);
#ifdef SCARD_CONFISCATE_CARD
    void
    ReaderConfiscate(
        ActiveState *pActiveState);
#endif
    DWORD
    GetReaderState(
        ActiveState *pActiveState);

    //  Operators

protected:

    //
    //  Properties
    //

    // Read-Only information.
    CBuffer m_bfReaderName;
    DWORD m_dwCapabilities;
    DWORD m_dwFlags;

    // Read/Write via Access Lock information.
    CAccessLock m_rwLock;
    CBuffer m_bfCurrentAtr;
    AvailableState m_dwAvailStatus;
    ActiveState m_ActiveState;
    DWORD m_dwOwnerThreadId;
    DWORD m_dwShareCount;
    DWORD m_dwCurrentProtocol;
    BOOL m_fDeviceActive;
    DWORD m_dwCurrentState;

    // Device I/O mutexes & events
    CMutex m_mtxGrab;
    CMutex m_mtxLatch;
    CMultiEvent m_ChangeEvent;
    CAccessLock m_rwActive;

    //  Methods
    void SetAvailabilityStatusLocked(AvailableState state)
    {
        CLockWrite rwLock(&m_rwLock);
        SetAvailabilityStatus(state);
    };

    void SetAvailabilityStatus(AvailableState state);
    void Dispose(DWORD dwDisposition);
    void PowerUp(void);
    void PowerDown(void);
    void Clean(void);
    void InvalidateGrabs(void);
    void TakeoverReader(void);

    // Friends
    friend class CReaderReference;
    friend class CTakeReader;
    friend void CalaisStop(void);
    friend DWORD WINAPI CalaisTerminateReader(LPVOID pvParam);
};


//
//==============================================================================
//
//  CLatchReader
//
//      An inline utility class to ensure that Latched readers get unlatched.
//      This also grabs the reader, just in case.
//

class CLatchReader
{
public:

    //  Constructors & Destructor

    CLatchReader(
        CReader *pRdr,
        const CReader::ActiveState *pActiveState = NULL)
    {
        m_pRdr = NULL;
        pRdr->GrabReader();
        try
        {
            pRdr->LatchReader(pActiveState);
            m_pRdr = pRdr;
        }
        catch (...)
        {
            pRdr->ShareReader();
            throw;
        }
    };

    ~CLatchReader()
    {
        if (NULL != m_pRdr)
        {
            if (m_pRdr->InitFailed())
                return;

            m_pRdr->Unlatch();
            m_pRdr->ShareReader();
        }
    };


    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties
    CReader *m_pRdr;

    //  Methods
};


//
//==============================================================================
//
//  CTakeReader
//
//      An inline utility class to ensure that confiscated readers get
//      released.  This class is only for use by system threads.
//

class CTakeReader
{
public:

    //  Constructors & Destructor

    CTakeReader(
        CReader *pRdr)
    {
        m_pRdr = pRdr;
        m_pRdr->TakeoverReader();
    };

    ~CTakeReader()
    {
        m_pRdr->Unlatch();
        m_pRdr->ShareReader();
    };


    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties
    CReader *m_pRdr;

    //  Methods
};


//
//==============================================================================
//
//  CReaderReference
//

class CReaderReference
{
public:
    //  Properties
    //  Methods
    CReader *Reader(void)
    { return m_pReader; };
    CReader::ActiveState *ActiveState(void)
    { return &m_actState; };
    DWORD Mode(void)
    { return m_dwMode; };
    void Mode(DWORD dwMode)
    { m_dwMode = dwMode; };

    //  Operators

protected:
    //  Constructors & Destructor
    CReaderReference(CReader *pRdr)
    {
        ZeroMemory(&m_actState, sizeof(CReader::ActiveState));
        m_dwMode = 0;
        m_pReader = pRdr;
        m_pLock = new CLockRead(&pRdr->m_rwActive);
    };
    ~CReaderReference()
    {
        if (NULL != m_pLock)
            delete m_pLock;
    };

    //  Properties
    CReader *m_pReader;
    CLockRead *m_pLock;
    CReader::ActiveState m_actState;
    DWORD m_dwMode;

    //  Methods

    //  Friends
    friend CReaderReference *CalaisLockReader(LPCTSTR szReader);
    friend void CalaisReleaseReader(CReaderReference **ppRdrRef);
};


//
//==============================================================================
//
//  CServiceThread
//

extern BOOL
DispatchInit(
    void);
extern void
DispatchTerm(
    void);
extern "C" DWORD WINAPI
DispatchMonitor(
    LPVOID pvParameter);
extern "C" DWORD WINAPI
ServiceMonitor(
    LPVOID pvParameter);

class CServiceThread
{
public:

    //  Constructors & Destructor
    ~CServiceThread();

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Constructors & Destructor
    CServiceThread(DWORD dwServerIndex);

    //  Properties
    DWORD m_dwServerIndex;
    CComChannel *m_pcomChannel;
    CHandleObject m_hThread;
    DWORD m_dwThreadId;
    CHandleObject m_hCancelEvent;
    CHandleObject m_hExitEvent;
    CDynamicArray<CReaderReference> m_rgpReaders;

    //  Methods
    void Watch(CComChannel *pcomChannel);
    void DoEstablishContext(ComEstablishContext *pCom);
    void DoReleaseContext(ComReleaseContext *pCom);
    void DoIsValidContext(ComIsValidContext *pCom);
    void DoListReaders(ComListReaders *pCom);
    void DoLocateCards(ComLocateCards *pCom);
    void DoGetStatusChange(ComGetStatusChange *pCom);
    void DoConnect(ComConnect *pCom);
    void DoReconnect(ComReconnect *pCom);
    void DoDisconnect(ComDisconnect *pCom);
    void DoBeginTransaction(ComBeginTransaction *pCom);
    void DoEndTransaction(ComEndTransaction *pCom);
    void DoStatus(ComStatus *pCom);
    void DoTransmit(ComTransmit *pCom);
    void DoControl(ComControl *pCom);
    void DoGetAttrib(ComGetAttrib *pCom);
    void DoSetAttrib(ComSetAttrib *pCom);

    //  Friends
    friend DWORD WINAPI DispatchMonitor(LPVOID pvParameter);
    friend DWORD WINAPI ServiceMonitor(LPVOID pvParameter);
    friend void DispatchTerm(void);
};


//
//==============================================================================
//
//  CReaderDriver
//

extern DWORD
AddReaderDriver(
    IN LPCTSTR szDevice,
    IN DWORD dwFlags);

extern DWORD
AddAllWdmDrivers(
    void);

extern DWORD
AddAllPnPDrivers(
    void);

extern "C" DWORD WINAPI
MonitorReader(
    LPVOID pvParameter);

class CReaderDriver
:   public CReader
{
public:

    //  Constructors & Destructor
    CReaderDriver(
        IN HANDLE hReader,
        IN LPCTSTR szDevice,
        IN DWORD dwFlags);
    virtual ~CReaderDriver();

    //  Properties
    //  Methods
    virtual void Initialize(void);
    virtual void Close(void);
    virtual void Disable(void);
    virtual HANDLE ReaderHandle(void) const;
    virtual LPCTSTR DeviceName(void) const;
    virtual DWORD
    Control(
        DWORD dwCode,
        LPCBYTE pbSend = NULL,
        DWORD cbSend = 0,
        LPBYTE pbRecv = NULL,
        LPDWORD pcbRecv = NULL,
        BOOL fLogError = TRUE);

    //  Operators

protected:

    //
    //  Properties
    //

    // Read-Only information.
    CHandleObject m_hThread;
    DWORD m_dwThreadId;
    CBuffer m_bfDosDevice;
    CHandleObject m_hReader;
    LPVOID m_pvAppControl;

    // Read/Write via Access Lock information.
    OVERLAPPED m_ovrlp;
    CHandleObject m_hOvrWait;

    // Device I/O mutexes & events
    CHandleObject m_hRemoveEvent;

    //  Methods
    LPCTSTR DosDevice(void) const
    { return (LPCTSTR)m_bfDosDevice.Access(); };
    void Clean(void);
    DWORD SyncIoControl(
        DWORD dwIoControlCode,
        LPVOID lpInBuffer,
        DWORD nInBufferSize,
        LPVOID lpOutBuffer,
        DWORD nOutBufferSize,
        LPDWORD lpBytesReturned,
        BOOL fLogError = TRUE);

    // Friends
    friend DWORD WINAPI MonitorReader(LPVOID pvParameter);
};

#endif // _CALSERVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\scredir\scredir.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    scredir

Abstract:

    This module redirects the SCard* API calls	

Author:

    reidk 7/27/2000


--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <winscard.h>
#include "scredir.h"
#include "scioctl.h"
#include "calmsgs.h"
#include "calaislb.h"
#include "rdpdr.h"

//
// from secpkg.h
//
typedef NTSTATUS (NTAPI LSA_IMPERSONATE_CLIENT) (VOID);
typedef LSA_IMPERSONATE_CLIENT * PLSA_IMPERSONATE_CLIENT;


#define wszWinSCardRegKeyRedirector (L"Software\\Microsoft\\SmartCard\\Redirector")
#define wszWinSCardRegVersion       (L"Version")
#define wszWinSCardRegName          (L"Name")
#define wszWinSCardRegNameValue     (L"scredir.dll")

// This is the version number of the interface.
// The high word is the major version which must match exactly.
// The low word is the minor version. The dll must implement 
// a minor version that is greater than or equal to the system
// minor version. This means that if we add a new funtion to the API,
// we increase the minor version and a remoting DLL can still be 
// backward compatible. This is just like RPC version numbers
#define REDIRECTION_VERSION 0x00010000 


#define ERROR_RETURN(x)     lReturn = x; goto ErrorReturn;


typedef struct _REDIR_LOCAL_SCARDCONTEXT
{
    REDIR_SCARDCONTEXT	Context;
    HANDLE				hHeap;
} REDIR_LOCAL_SCARDCONTEXT;

typedef struct _REDIR_LOCAL_SCARDHANDLE
{
    REDIR_LOCAL_SCARDCONTEXT    *pRedirContext;
    REDIR_SCARDHANDLE           Handle;
} REDIR_LOCAL_SCARDHANDLE;

//
// This structure is used to maintain a list of buffers that are
// used for the _SendSCardIOCTL calls
//
#define INITIAL_BUFFER_SIZE   512
typedef struct _BUFFER_LIST_STRUCT
{
    void            *pNext;
    BOOL            fInUse;
    BYTE            *pbBytes;
    unsigned long   cbBytes;
    unsigned long   cbBytesUsed;
} BUFFER_LIST_STRUCT;


HMODULE             g_hModule                               = NULL;

CRITICAL_SECTION    g_CreateCS;
CRITICAL_SECTION    g_SetStartedEventStateCS;
CRITICAL_SECTION    g_StartedEventCreateCS;
CRITICAL_SECTION    g_ProcessDetachEventCreateCS;
CRITICAL_SECTION    g_BufferListCS;

HANDLE              g_hRdpdrDeviceHandle                    = INVALID_HANDLE_VALUE;
HANDLE              g_hRedirStartedEvent                    = NULL;
HANDLE              g_hProcessDetachEvent                   = NULL;
LONG                g_lProcessDetachEventClients            = 0;

BOOL                g_fInTheProcessOfSettingStartedEvent    = FALSE;
HANDLE              g_hRegisteredWaitHandle                 = NULL;
HANDLE              g_hWaitEvent                            = NULL;
IO_STATUS_BLOCK     g_StartedStatusBlock;
 
HANDLE              g_hConnectedEvent                       = NULL;

BOOL                g_fInProcessDetach                      = FALSE;

BUFFER_LIST_STRUCT  *g_pBufferList                          = NULL;

#define IOCTL_RETURN_BUFFER_SIZE   256
BYTE                g_rgbIOCTLReturnBuffer[IOCTL_RETURN_BUFFER_SIZE];
unsigned long       g_cbIOCTLReturnBuffer;


#define _TRY_(y)    __try                                   \
                    {                                       \
                        y;                                  \
                    }                                       \
                    __except(EXCEPTION_EXECUTE_HANDLER)     \
                    {                                       \
                        ERROR_RETURN(GetExceptionCode())    \
                    }

#define _TRY_2(y)   __try                                   \
                    {                                       \
                        y;                                  \
                    }                                       \
                    __except(EXCEPTION_EXECUTE_HANDLER){} // do nothing



//
// Forward declarations
//
NTSTATUS
_SendSCardIOCTLWithWaitForCallback(
    ULONG               IoControlCode,
    PVOID               InputBuffer,
    ULONG               InputBufferLength,
    WAITORTIMERCALLBACK Callback);

void
SafeMesHandleFree(
    handle_t            *ph);

LONG
I_DecodeLongReturn(
    BYTE *pb,
    unsigned long cb);


//---------------------------------------------------------------------------------------
//
//  MIDL allocation routines
//
//---------------------------------------------------------------------------------------
void __RPC_FAR *__RPC_USER  MIDL_user_allocate(size_t size)
{
    void *pv;
    
    if (NULL == (pv = (void *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size)))
    {
        SetLastError(ERROR_OUTOFMEMORY);
    }

    return (pv);
}

void __RPC_USER  MIDL_user_free(void __RPC_FAR *pv)
{
    if (pv != NULL)
    {
        HeapFree(GetProcessHeap(), 0, pv);
    }
}

void * SCRedirAlloc(REDIR_LOCAL_SCARDCONTEXT *pRedirContext, size_t size)
{
    return (HeapAlloc(
                (pRedirContext != NULL) ? pRedirContext->hHeap : GetProcessHeap(), 
                HEAP_ZERO_MEMORY, 
                size));
}

LONG
_MakeSCardError(NTSTATUS Status)
{
    switch (Status)
    {
    case STATUS_DEVICE_NOT_CONNECTED:
        return (SCARD_E_NO_SERVICE);
        break;

    case STATUS_CANCELLED:
        return (SCARD_E_SYSTEM_CANCELLED);
        break;

    default:
        return (SCARD_E_NO_SERVICE);
    }
}


//---------------------------------------------------------------------------------------
//
//  DllRegisterServer
//
//---------------------------------------------------------------------------------------
STDAPI 
DllRegisterServer(void)
{
    HRESULT hr              = ERROR_SUCCESS;
    HKEY    hKey;
    DWORD   dwDisposition;
    DWORD   dwVersion       = REDIRECTION_VERSION;

    hr = RegCreateKeyExW(    
            HKEY_LOCAL_MACHINE,
            wszWinSCardRegKeyRedirector,
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 
            NULL,
            &hKey, 
            &dwDisposition);
    
    if (hr == ERROR_SUCCESS)
    {
        hr = RegSetValueExW(
                hKey, 
                wszWinSCardRegName,
                0, 
                REG_SZ,
                (BYTE *) wszWinSCardRegNameValue,
                (wcslen(wszWinSCardRegNameValue) + 1) * sizeof(WCHAR));
        
        if (hr == ERROR_SUCCESS)
        {
            hr = RegSetValueExW(
                    hKey, 
                    wszWinSCardRegVersion,
                    0, 
                    REG_DWORD,
                    (BYTE *) &dwVersion,
                    sizeof(DWORD));

            RegCloseKey(hKey);
        }   
    }
    
    return (hr);
}


//---------------------------------------------------------------------------------------
//
//  DllUnregisterServer
//
//---------------------------------------------------------------------------------------
STDAPI 
DllUnregisterServer(void)
{
    HRESULT hr              = ERROR_SUCCESS;
    HKEY    hKey;
    DWORD   dwDisposition;
    DWORD   dwVersion       = REDIRECTION_VERSION;

    hr = RegCreateKeyExW(    
            HKEY_LOCAL_MACHINE,
            wszWinSCardRegKeyRedirector,
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 
            NULL,
            &hKey, 
            &dwDisposition);

    if (hr == ERROR_SUCCESS)
    {
        RegDeleteValueW(hKey, wszWinSCardRegName);
        RegDeleteValueW(hKey, wszWinSCardRegVersion);
        RegCloseKey(hKey);
    }

    return (hr);
}


//---------------------------------------------------------------------------------------
//
//  DllMain
//
//---------------------------------------------------------------------------------------
BOOL WINAPI 
DllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    DWORD               dwTryCount              = 0;
    BOOL                fLeaveCritSec;
    DWORD               dwCritSecsInitialized   = 0;
    BUFFER_LIST_STRUCT  *pTemp                  = NULL;

    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        
        g_hModule = hInstDLL;
         __try
        {
            InitializeCriticalSection(&g_CreateCS);
            dwCritSecsInitialized++;
            InitializeCriticalSection(&g_SetStartedEventStateCS);
            dwCritSecsInitialized++;
            InitializeCriticalSection(&g_StartedEventCreateCS);
            dwCritSecsInitialized++;
            InitializeCriticalSection(&g_ProcessDetachEventCreateCS);
            dwCritSecsInitialized++;
            InitializeCriticalSection(&g_BufferListCS);
            dwCritSecsInitialized++;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) 
        {
            if (dwCritSecsInitialized >= 1)
            {
                DeleteCriticalSection(&g_CreateCS);
            }

            if (dwCritSecsInitialized >= 2)
            {
                DeleteCriticalSection(&g_SetStartedEventStateCS);
            }

            if (dwCritSecsInitialized >= 3)
            {
                DeleteCriticalSection(&g_StartedEventCreateCS);
            }

            if (dwCritSecsInitialized >= 4)
            {
                DeleteCriticalSection(&g_ProcessDetachEventCreateCS);
            }

            if (dwCritSecsInitialized >= 5)
            {
                DeleteCriticalSection(&g_BufferListCS);
            }

            SetLastError(GetExceptionCode());
            return (FALSE);
        }

        break;

    case DLL_PROCESS_DETACH:

        g_fInProcessDetach = TRUE;

        //
        // The third parameter, lpvReserved, passed to DllMain
        // is NULL for FreeLibrary and non-NULL for ProcessExit.
        // Only clean up for FreeLibrary
        //
        //if (lpvReserved == NULL)
        {
            //
            // If we are currently waiting for the started event then kill 
            // that wait
            //
            fLeaveCritSec = TRUE;
            __try
            {
                EnterCriticalSection(&g_SetStartedEventStateCS);
            }
            __except(EXCEPTION_EXECUTE_HANDLER) 
            {
                //
                // Can't really do much
                //
                fLeaveCritSec = FALSE;
            }

            if (g_hRegisteredWaitHandle != NULL)
            {
                UnregisterWaitEx(g_hRegisteredWaitHandle, INVALID_HANDLE_VALUE);
                g_hRegisteredWaitHandle = NULL;
            }

            if (g_hWaitEvent != NULL)
            {
                CloseHandle(g_hWaitEvent);
                g_hWaitEvent = NULL;
            }

            if (fLeaveCritSec)
            {
                LeaveCriticalSection(&g_SetStartedEventStateCS);
            }
            
            //
            // If there are clients waiting on IOCTLs to complete, then let them go.
            //
            if (g_hProcessDetachEvent != NULL)
            {
                SetEvent(g_hProcessDetachEvent);            
            }
        
            if (g_hProcessDetachEvent != NULL)
            {
                //
                // wait for all clients until they are done with the event
                //
                while ((g_lProcessDetachEventClients > 0) && (dwTryCount < 50))
                {
                    Sleep(10); 
                    dwTryCount++;
                }

                if (dwTryCount < 50)
                {
                    CloseHandle(g_hProcessDetachEvent);
                }
            }

            if (g_hRdpdrDeviceHandle != INVALID_HANDLE_VALUE)
            {
                CloseHandle(g_hRdpdrDeviceHandle);
            }

            if (g_hRedirStartedEvent != NULL)
            {
                CloseHandle(g_hRedirStartedEvent);
            }

            //
            // Free all the buffers used for the IOCTL calls
            //
            pTemp = g_pBufferList;
            while (pTemp != NULL)
            {
                g_pBufferList = (BUFFER_LIST_STRUCT *) pTemp->pNext;
                MIDL_user_free(pTemp->pbBytes);
                MIDL_user_free(pTemp);
                pTemp = g_pBufferList;
            }

            DeleteCriticalSection(&g_CreateCS);
            DeleteCriticalSection(&g_SetStartedEventStateCS);
            DeleteCriticalSection(&g_StartedEventCreateCS);
            DeleteCriticalSection(&g_ProcessDetachEventCreateCS);
            DeleteCriticalSection(&g_BufferListCS);
        }

        break;
    }

    return (TRUE);
}

//---------------------------------------------------------------------------------------
//
//  GetBuffer
//
//---------------------------------------------------------------------------------------
BUFFER_LIST_STRUCT * 
GetBuffer(void)
{
    BUFFER_LIST_STRUCT *pTemp = NULL;
    BUFFER_LIST_STRUCT *p1    = NULL;
    BUFFER_LIST_STRUCT *p2    = NULL;

    __try
    {
        EnterCriticalSection(&g_BufferListCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        //
        // Can't really do much
        //
        return(NULL);
    }

    //
    // See if there are any buffers allocated yet
    //
    if (g_pBufferList == NULL)
    {
        g_pBufferList = (BUFFER_LIST_STRUCT *) 
                            MIDL_user_allocate(sizeof(BUFFER_LIST_STRUCT)); 
        
        if (g_pBufferList == NULL)
        {
            goto Return;
        }

        g_pBufferList->pbBytes = (BYTE *) MIDL_user_allocate(INITIAL_BUFFER_SIZE); 

        if (g_pBufferList->pbBytes == NULL)
        {
            MIDL_user_free(g_pBufferList);
            goto Return;
        }

        g_pBufferList->pNext = NULL;
        g_pBufferList->fInUse = TRUE;        
        g_pBufferList->cbBytes = INITIAL_BUFFER_SIZE;

        pTemp = g_pBufferList;
        goto Return;     
    }

    //
    // Walk the existing list to see if a free buffer can be found
    //
    pTemp = g_pBufferList;
    while ((pTemp != NULL) && (pTemp->fInUse))
    {
        pTemp = (BUFFER_LIST_STRUCT *)pTemp->pNext;
    }

    if (pTemp != NULL)
    {
        pTemp->fInUse = TRUE;

        //
        // Get rid of any buffers that exist which aren't being used
        //
        p1 = pTemp;
        p2 = (BUFFER_LIST_STRUCT *) pTemp->pNext;
        while (p2 != NULL)
        {
            if (!(p2->fInUse))
            {   
                p1->pNext = p2->pNext;
                
                MIDL_user_free(p2->pbBytes);
                MIDL_user_free(p2);
                
                p2 = (BUFFER_LIST_STRUCT *) p1->pNext;
            }
            else
            {
                p1 = (BUFFER_LIST_STRUCT *) p1->pNext;
                p2 = (BUFFER_LIST_STRUCT *) p2->pNext;
            }
        }
        
        goto Return;
    }
    
    //
    // No free buffers, so create a new one
    //
    pTemp = (BUFFER_LIST_STRUCT *)
                            MIDL_user_allocate(sizeof(BUFFER_LIST_STRUCT)); 

    if (pTemp == NULL)
    {
        goto Return;
    }

    pTemp->pbBytes = (BYTE *) MIDL_user_allocate(INITIAL_BUFFER_SIZE); 

    if (pTemp->pbBytes == NULL)
    {
        MIDL_user_free(pTemp);
        goto Return;
    }

    pTemp->fInUse = TRUE;
    pTemp->cbBytes = INITIAL_BUFFER_SIZE;
    
    pTemp->pNext = g_pBufferList; 
    g_pBufferList = pTemp;
   
Return:

    LeaveCriticalSection(&g_BufferListCS);
    return(pTemp);
}


//---------------------------------------------------------------------------------------
//
//  FreeBuffer
//
//---------------------------------------------------------------------------------------
void
FreeBuffer(BUFFER_LIST_STRUCT *pBuffer)
{
    if (pBuffer != NULL)
    {
        pBuffer->fInUse = FALSE;
    }
}

//---------------------------------------------------------------------------------------
//
//  GrowBuffer
//
//---------------------------------------------------------------------------------------
BOOL
GrowBuffer(BUFFER_LIST_STRUCT *pBuffer)
{
    BYTE *pTemp;
    BOOL fRet = TRUE;

    pTemp = pBuffer->pbBytes;

    pBuffer->pbBytes = (BYTE *) MIDL_user_allocate(pBuffer->cbBytes * 2);

    if (pBuffer->pbBytes == NULL)
    {
        pBuffer->pbBytes = pTemp;
        fRet = FALSE;
    }
    else
    {
        MIDL_user_free(pTemp);
        pBuffer->cbBytes = pBuffer->cbBytes * 2;
    }

    return (fRet);
}



//---------------------------------------------------------------------------------------
//
//  _GetProcessDetachEventHandle
//
//---------------------------------------------------------------------------------------
HANDLE
_GetProcessDetachEventHandle(void)
{
    try
    {
        EnterCriticalSection(&g_ProcessDetachEventCreateCS);
    }
    catch (...) 
    {
        return NULL;
    }

    if (NULL == g_hProcessDetachEvent)
    {
        try
        {
            g_hProcessDetachEvent =
                CreateEvent(
                    NULL,       // pointer to security attributes
                    TRUE,       // flag for manual-reset event
                    FALSE,      // flag for initial state
                    NULL);      // event-object name              
        }
        catch (...)
        {
            goto Return;   
        }
    }

    LeaveCriticalSection(&g_ProcessDetachEventCreateCS);

Return:

    if (g_hProcessDetachEvent != NULL)
    {
        InterlockedIncrement(&g_lProcessDetachEventClients);
    }   

    return (g_hProcessDetachEvent);
}

void
_ReleaseProcessDetachEventHandle(void)
{
    InterlockedDecrement(&g_lProcessDetachEventClients);
}



//---------------------------------------------------------------------------------------
//
// All the code below is to solve the problem of weather or not the redirect Smart
// Card Subsystem is available.  It is available if we are connected to the client,
// and if the clients Smart Card Subsystem is running
//
//---------------------------------------------------------------------------------------

HANDLE
_GetStartedEventHandle(void)
{
    try
    {
        EnterCriticalSection(&g_StartedEventCreateCS);
    }
    catch (...) 
    {
        return NULL;
    }

    if (NULL == g_hRedirStartedEvent)
    {
        g_hRedirStartedEvent = CreateEvent(NULL, TRUE, FALSE, NULL);      
    }

    LeaveCriticalSection(&g_StartedEventCreateCS);

    return (g_hRedirStartedEvent);
}


VOID CALLBACK
AccessStartedEventIOCTLCallback(
    PVOID lpParameter,
    BOOLEAN TimerOrWaitFired)
{
    BOOL    fLeaveCritSec;

    //
    // Close the handle that was used to fire this callback
    //
    fLeaveCritSec = TRUE;
    __try
    {
        EnterCriticalSection(&g_SetStartedEventStateCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        fLeaveCritSec = FALSE;  
    }

    UnregisterWait(g_hRegisteredWaitHandle);
    g_hRegisteredWaitHandle = NULL;
    
    if (fLeaveCritSec)
    {
        LeaveCriticalSection(&g_SetStartedEventStateCS);
    }
    
    //
    // Make sure the AccessStartedEvent IOCTL completed and wasn't timed out
    //
    if (!TimerOrWaitFired)
    {
        //
        // Make sure the AccessStartedEvent IOCTL completed successfully
        //
        if (g_StartedStatusBlock.Status == STATUS_SUCCESS)             
        {
            g_cbIOCTLReturnBuffer = 
                    (unsigned long) g_StartedStatusBlock.Information;  

            //
            // Look at the value returned from the SCARD_IOCTL_ACCESSSTARTEDEVENT
            // call to see if we should set the local started event
            //
            if (I_DecodeLongReturn(
                    g_rgbIOCTLReturnBuffer,
                    g_cbIOCTLReturnBuffer) == SCARD_S_SUCCESS)
            {
                SetEvent(g_hRedirStartedEvent);
            } 
        }
    }
    
    //
    // Unset the g_fInTheProcessOfSettingStartedEvent boolean
    //
    __try
    {
        EnterCriticalSection(&g_SetStartedEventStateCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        g_fInTheProcessOfSettingStartedEvent = FALSE;
        goto Return;
    }

    g_fInTheProcessOfSettingStartedEvent = FALSE;
    LeaveCriticalSection(&g_SetStartedEventStateCS);

Return:

    return;
}

VOID CALLBACK
SCardOnLineIOCTLCallback(
    PVOID lpParameter,
    BOOLEAN TimerOrWaitFired)
{
    BOOL        fOperationDone      = FALSE;
    NTSTATUS    Status              = STATUS_SUCCESS;
    BOOL        fLeaveCritSec;
    BYTE        rgb[4];

    //
    // Close the handle that was used to fire this callback
    //
    fLeaveCritSec = TRUE;
    __try
    {
        EnterCriticalSection(&g_SetStartedEventStateCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        fLeaveCritSec = FALSE;  
    }

    UnregisterWait(g_hRegisteredWaitHandle);
    g_hRegisteredWaitHandle = NULL;

    if (fLeaveCritSec)
    {
        LeaveCriticalSection(&g_SetStartedEventStateCS);
    }
    
    //
    // Make sure the online IOCTL completed and wasn't timed out
    //
    if (TimerOrWaitFired)
    {
        //
        // Timed out, so just cancel operation
        //  
        fOperationDone = TRUE;        
    }
    else
    {
        //
        // Make sure the SCardOnLine IOCTL completed successfully, then try to 
        // send the IOCTL which will wait on the clients started event
        //
        if (g_StartedStatusBlock.Status == STATUS_SUCCESS)
        {
            Status = _SendSCardIOCTLWithWaitForCallback(
                            SCARD_IOCTL_ACCESSSTARTEDEVENT, 
                            rgb, 
                            4,
                            AccessStartedEventIOCTLCallback);
            if (Status == STATUS_SUCCESS)
            {
                g_cbIOCTLReturnBuffer = 
                    (unsigned long) g_StartedStatusBlock.Information;   

                //
                // Look at the value returned from the SCARD_IOCTL_ACCESSSTARTEDEVENT
                // call to see if we should set the local started event
                //
                if (I_DecodeLongReturn(
                        g_rgbIOCTLReturnBuffer,
                        g_cbIOCTLReturnBuffer) == SCARD_S_SUCCESS)
                {
                    SetEvent(g_hRedirStartedEvent);
                }
                
                fOperationDone = TRUE;
            }
            else if (Status == STATUS_PENDING)
            {
                //
                // This OK, since the AccessStartedEventIOCTLCallback function
                // will handle the return once the operation is complete
                //                
            }
            else
            {
                fOperationDone = TRUE;
            }
        }
        else
        {
            fOperationDone = TRUE;     
        }
    }
    
    if (fOperationDone)
    {
        __try
        {
            EnterCriticalSection(&g_SetStartedEventStateCS);
        }
        __except(EXCEPTION_EXECUTE_HANDLER) 
        {
            g_fInTheProcessOfSettingStartedEvent = FALSE;
            goto Return;
        }

        g_fInTheProcessOfSettingStartedEvent = FALSE;
        LeaveCriticalSection(&g_SetStartedEventStateCS);
    }

Return:

    return;
}


BOOL
_SetStartedEventToCorrectState(void)
{
    BOOL        fRet                = TRUE;
    BOOL        fOperationDone      = FALSE;
    HANDLE      h                   = NULL;
    NTSTATUS    Status              = STATUS_SUCCESS;
    BYTE        rgb[4];

    //
    // Make sure the event is created
    //
    if (NULL == (h = _GetStartedEventHandle()))
    {
        fRet = FALSE;
        goto Return;
    }

    //
    // If the event is already set then just return
    //
    if (WAIT_OBJECT_0 == WaitForSingleObject(h, 0))
    {
        goto Return;
    }

    __try
    {
        EnterCriticalSection(&g_SetStartedEventStateCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        fRet = FALSE;
        goto Return;
    }

    //
    // If we are already in the process of setting the started event, then just get out
    //
    if (g_fInTheProcessOfSettingStartedEvent)
    {
        LeaveCriticalSection(&g_SetStartedEventStateCS);
        goto Return;
    }

    g_fInTheProcessOfSettingStartedEvent = TRUE;
    LeaveCriticalSection(&g_SetStartedEventStateCS);

    //
    // Make the blocking call to rdpdr.sys that will only return after the
    // client is connected, and the scard device announce has been processed
    //
    // NOTE: If this fails, then we can't do much,  
    // 
    Status = _SendSCardIOCTLWithWaitForCallback(
                    SCARD_IOCTL_SMARTCARD_ONLINE, 
                    NULL, 
                    0,
                    SCardOnLineIOCTLCallback);
    if (Status == STATUS_SUCCESS)
    {
        //
        // Since the SCARD_IOCTL_SMARTCARD_ONLINE succeeded immediately, we 
        // can just make the SCARD_IOCTL_ACCESSSTARTEDEVENT right now.
        //
        Status = _SendSCardIOCTLWithWaitForCallback(
                        SCARD_IOCTL_ACCESSSTARTEDEVENT, 
                        rgb, 
                        4,
                        AccessStartedEventIOCTLCallback); 
        if (Status == STATUS_SUCCESS)
        {
            g_cbIOCTLReturnBuffer = 
                (unsigned long) g_StartedStatusBlock.Information;   

            //
            // Look at the value returned from the SCARD_IOCTL_ACCESSSTARTEDEVENT
            // call to see if we should set the local started event
            //
            if (I_DecodeLongReturn(
                    g_rgbIOCTLReturnBuffer,
                    g_cbIOCTLReturnBuffer) == SCARD_S_SUCCESS)
            {
                SetEvent(g_hRedirStartedEvent);
            }
            
            fOperationDone = TRUE; 
        }
        else if (Status == STATUS_PENDING)
        {
            //
            // This OK, since the AccessStartedEventIOCTLCallback function
            // will handle the return once the operation is complete
            //            
        }
        else
        {
            fOperationDone = TRUE;            
        }
    }
    else if (Status == STATUS_PENDING)
    {
        //
        // This is OK, the SCardOnLineIOCTLCallback will make the next call
        // to _SendSCardIOCTLWithWaitForCallback with SCARD_IOCTL_ACCESSSTARTEDEVENT
        //        
    }
    else
    {
        fOperationDone = TRUE; 
    }


    if (fOperationDone)
    {
        __try
        {
            EnterCriticalSection(&g_SetStartedEventStateCS);
        }
        __except(EXCEPTION_EXECUTE_HANDLER) 
        {
            g_fInTheProcessOfSettingStartedEvent = FALSE;
            goto ErrorReturn;
        }

        g_fInTheProcessOfSettingStartedEvent = FALSE;
        LeaveCriticalSection(&g_SetStartedEventStateCS);
    }

	//
	// Now check to see if the operation completed successfully
	//
	if ((Status != STATUS_PENDING) && (Status != STATUS_SUCCESS))
	{
		fRet = FALSE;
	}
   
Return:

    return (fRet);

ErrorReturn:

    fRet = FALSE;
    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  _CreateRdpdrDeviceHandle
//
//---------------------------------------------------------------------------------------
HANDLE
_CreateRdpdrDeviceHandle()
{
    WCHAR   wszDeviceName[512];
    
    swprintf(wszDeviceName, L"\\\\TSCLIENT\\%S", DR_SMARTCARD_SUBSYSTEM);
        
    return (CreateFileW(
                wszDeviceName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                CREATE_ALWAYS,
                FILE_FLAG_OVERLAPPED,
                NULL));
}


//---------------------------------------------------------------------------------------
//
//  _CreateGlobalRdpdrHandle
//
//---------------------------------------------------------------------------------------
NTSTATUS
_CreateGlobalRdpdrHandle()
{
    NTSTATUS Status = STATUS_SUCCESS;

    __try
    {
        EnterCriticalSection(&g_CreateCS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        return (FALSE);
    }
    
    //
    // Check to see if the SCardDevice handle has been created
    // yet, if not, then create it
    //
    if (g_hRdpdrDeviceHandle == INVALID_HANDLE_VALUE)
    {
        g_hRdpdrDeviceHandle = _CreateRdpdrDeviceHandle();

        if (g_hRdpdrDeviceHandle == INVALID_HANDLE_VALUE) 
        {
            Status = STATUS_OPEN_FAILED;
        }        
    }

    LeaveCriticalSection(&g_CreateCS); 

    return (Status);
}


//---------------------------------------------------------------------------------------
//
//  _SendSCardIOCTLWithWaitForCallback
//
//---------------------------------------------------------------------------------------
NTSTATUS
_SendSCardIOCTLWithWaitForCallback(
    ULONG               IoControlCode,
    PVOID               InputBuffer,
    ULONG               InputBufferLength,
    WAITORTIMERCALLBACK Callback)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (g_fInProcessDetach)
    {
        goto ErrorReturn;
    }
    
    Status = _CreateGlobalRdpdrHandle();
    if (Status != STATUS_SUCCESS)
    {
        return (Status);
    }

    //
    // Create the event which is set when the function successfully completes
    //
    if (g_hWaitEvent == NULL)
    {
        g_hWaitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (g_hWaitEvent == NULL)
        {
            goto ErrorReturn;
        }
    }
    else
    {
        ResetEvent(g_hWaitEvent);
    }

    Status = NtDeviceIoControlFile(
            g_hRdpdrDeviceHandle,
            g_hWaitEvent,
            NULL,
            NULL,
            &g_StartedStatusBlock,
            IoControlCode,
            InputBuffer,
            InputBufferLength,
            g_rgbIOCTLReturnBuffer, 
            IOCTL_RETURN_BUFFER_SIZE);
    
    if (Status == STATUS_PENDING)
    {
        __try
        {
            EnterCriticalSection(&g_SetStartedEventStateCS);
        }
        __except(EXCEPTION_EXECUTE_HANDLER) 
        {
            goto ErrorReturn; 
        }

        //
        // The g_hWaitEvent being set by the driver will trigger this registered callback
        //
        if (!RegisterWaitForSingleObject(
                &g_hRegisteredWaitHandle,
                g_hWaitEvent,
                Callback,
                NULL,
                INFINITE,
                WT_EXECUTEONLYONCE))
        {
            LeaveCriticalSection(&g_SetStartedEventStateCS); 
            goto ErrorReturn;    
        }
        
        LeaveCriticalSection(&g_SetStartedEventStateCS); 
    }
    else if (Status == STATUS_SUCCESS) 
    {
        g_cbIOCTLReturnBuffer = (unsigned long) g_StartedStatusBlock.Information;        
    }
    else
    {
        g_cbIOCTLReturnBuffer = 0;
    }

Return:

    return (Status);

ErrorReturn:

    Status = STATUS_INSUFFICIENT_RESOURCES;

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  _SendSCardIOCTL
//
//---------------------------------------------------------------------------------------
NTSTATUS
_SendSCardIOCTL(
    ULONG               IoControlCode,
    PVOID               InputBuffer,
    ULONG               InputBufferLength,
    BUFFER_LIST_STRUCT  **ppOutputBuffer)
{
    NTSTATUS        Status              = STATUS_SUCCESS;
    IO_STATUS_BLOCK StatusBlock;
    HANDLE          rgWaitHandles[2];
    DWORD           dwIndex;
    
    *ppOutputBuffer = NULL;

    rgWaitHandles[0] = NULL;
    rgWaitHandles[1] = NULL;

    //
    // Make sure the handle to the rdpdr device is created
    //
    Status = _CreateGlobalRdpdrHandle();
    if (Status != STATUS_SUCCESS)
    {
        return (Status);
    }

    //
    // Get an output buffer for the call
    //
    *ppOutputBuffer = GetBuffer();
    if (*ppOutputBuffer == NULL)
    {
        return (STATUS_NO_MEMORY);
    }

    //
    // Create the event that will be signaled when the IOCTL is complete
    //
    rgWaitHandles[0] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (rgWaitHandles[0]  == NULL)
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    while (1)
    {
        Status = NtDeviceIoControlFile(
                    g_hRdpdrDeviceHandle,
                    rgWaitHandles[0], 
                    NULL,
                    NULL,
                    &StatusBlock,
                    IoControlCode,
                    InputBuffer,
                    InputBufferLength,
                    (*ppOutputBuffer)->pbBytes, 
                    (*ppOutputBuffer)->cbBytes); 
                    
        if (Status == STATUS_PENDING)
        {
            rgWaitHandles[1] = _GetProcessDetachEventHandle();
            if (rgWaitHandles[1] == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            dwIndex = WaitForMultipleObjects(2, rgWaitHandles, FALSE, INFINITE);
            if (dwIndex != WAIT_FAILED)
            {
                dwIndex = dwIndex - WAIT_OBJECT_0;

                //
                // The IOCTL wait event was signaled if dwIndex == 0.  Otherwise the 
                // process detach event was signaled
                //
                if (dwIndex == 0)
                {
                    Status = StatusBlock.Status;
                }
            } 
            else
            {
                Status = STATUS_UNEXPECTED_IO_ERROR;
            }
            
            _ReleaseProcessDetachEventHandle();
        }

        if (Status == STATUS_BUFFER_TOO_SMALL)
        {
            if (!GrowBuffer(*ppOutputBuffer))
            {
                Status = STATUS_NO_MEMORY;
                break;
            }

            ResetEvent(rgWaitHandles[0]);
        }
        else
        {
            break;            
        }
    }
    
    if (Status != STATUS_SUCCESS) 
    {
        //
        // If we got the STATUS_DEVICE_NOT_CONNECTED error, then go back to waiting
        // for a connect
        //
        if (Status == STATUS_DEVICE_NOT_CONNECTED)
        {
            ResetEvent(g_hRedirStartedEvent);
            _SetStartedEventToCorrectState();
        }
        else if ((Status == STATUS_CANCELLED) && 
                 (g_hConnectedEvent != NULL))
        {
            ResetEvent(g_hConnectedEvent);
        }
        
        
        
        (*ppOutputBuffer)->cbBytesUsed = 0;
        goto Return;
    }
    
    (*ppOutputBuffer)->cbBytesUsed = (unsigned long) StatusBlock.Information;

Return:

    if (rgWaitHandles[0] != NULL)
    {
        CloseHandle(rgWaitHandles[0]);
    }

    return (Status);
}


//---------------------------------------------------------------------------------------
//
//  SafeMesHandleFree
//
//---------------------------------------------------------------------------------------
void
SafeMesHandleFree(handle_t *ph)
{
    if (*ph != 0)
    {
        MesHandleFree(*ph);
        *ph = 0;
    }
}


//---------------------------------------------------------------------------------------
//
//  _CalculateNumBytesInMultiStringA
//
//---------------------------------------------------------------------------------------
DWORD
_CalculateNumBytesInMultiStringA(LPCSTR psz)
{
    DWORD   dwTotal     = sizeof(char); // trailing '/0'
    DWORD   dwNumChars  = 0;
    LPCSTR  pszCurrent  = psz;

    if (psz == NULL)
    {
        return (0);
    }

    if (pszCurrent[0] == '\0') 
    {
        if (pszCurrent[1] == '\0')
        {
            return (2 * sizeof(char));   
        }

        pszCurrent++;
        dwTotal += sizeof(char);
    }

    while (pszCurrent[0] != '\0')
    {
        dwNumChars = strlen(pszCurrent) + 1;
        dwTotal += dwNumChars * sizeof(char);
        pszCurrent += dwNumChars;
    }

    return (dwTotal);
}


//---------------------------------------------------------------------------------------
//
//  _CalculateNumBytesInMultiStringW
//
//---------------------------------------------------------------------------------------
DWORD
_CalculateNumBytesInMultiStringW(LPCWSTR pwsz)
{
    DWORD   dwTotal     = sizeof(WCHAR); // trailing L'/0'
    DWORD   dwNumChars  = 0;
    LPCWSTR pwszCurrent = pwsz;

    if (pwsz == NULL)
    {
        return (0);
    }

    if (pwszCurrent[0] == L'\0') 
    {
        if (pwszCurrent[1] == L'\0')
        {
            (2 * sizeof(WCHAR));   
        }

        pwszCurrent++;
        dwTotal += sizeof(WCHAR);
    }

    while (pwszCurrent[0] != L'\0')
    {
        dwNumChars = wcslen(pwszCurrent) + 1;
        dwTotal += dwNumChars * sizeof(WCHAR);
        pwszCurrent += dwNumChars;
    }

    return (dwTotal);
}


//---------------------------------------------------------------------------------------
//
//  _CalculateNumBytesInAtr
//
//---------------------------------------------------------------------------------------
DWORD
_CalculateNumBytesInAtr(LPCBYTE pbAtr)
{
    DWORD   dwAtrLen = 0;
    
    if (ParseAtr(pbAtr, &dwAtrLen, NULL, NULL, 33))
    {
        return (dwAtrLen);
    }
    else
    {
        return (0);
    }   
}


//---------------------------------------------------------------------------------------
//
//  _CopyReturnToCallerBuffer
//
//---------------------------------------------------------------------------------------
#define BYTE_TYPE_RETURN    1
#define SZ_TYPE_RETURN      2
#define WSZ_TYPE_RETURN     3

LONG
_CopyReturnToCallerBuffer(
    REDIR_LOCAL_SCARDCONTEXT    *pRedirContext,
    LPBYTE                      pbReturn,
    DWORD                       cbReturn,
    LPBYTE                      pbUserBuffer,
    LPDWORD                     pcbUserBuffer,
    DWORD                       dwReturnType)
{
    LPBYTE  *ppBuf;
    BOOL    fAutoAllocate = (*pcbUserBuffer == SCARD_AUTOALLOCATE);

    //
    // The number of chars or bytes, depending on the type of return.
    //
    if (dwReturnType == WSZ_TYPE_RETURN)
    {
        *pcbUserBuffer = cbReturn / sizeof(WCHAR);
    }
    else if (dwReturnType == SZ_TYPE_RETURN)
    {
        *pcbUserBuffer = cbReturn / sizeof(char); 
    }
    else
    {
        *pcbUserBuffer = cbReturn;
    }
    
    //
    // If pbUserBuffer is not NULL, then the caller wants the data, 
    // not just the size, so give it to em'
    //
    if ((pbReturn != NULL) &&
        (pbUserBuffer != NULL))
        
    {
        //
        // Allocate space for caller if requested, else, copy to callers
        // supplied buffer
        //
        if (fAutoAllocate)
        {
            ppBuf = (LPBYTE *) pbUserBuffer;
        
            *ppBuf = (LPBYTE) SCRedirAlloc(pRedirContext, cbReturn);
            if (*ppBuf != NULL)
            {
                memcpy(*ppBuf, pbReturn, cbReturn);
            }
            else
            {
                return (SCARD_E_NO_MEMORY);
            }
        }
        else 
        {
            memcpy(pbUserBuffer, pbReturn, cbReturn);            
        }   
    }

    return (SCARD_S_SUCCESS);
}


//---------------------------------------------------------------------------------------
//
//  I_DecodeLongReturn
//
//---------------------------------------------------------------------------------------
LONG
I_DecodeLongReturn(
    BYTE *pb,
    unsigned long cb)
{
    handle_t    h           = 0;
    RPC_STATUS  rpcStatus;
    Long_Return LongReturn;
    LONG        lReturn;

    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pb, 
                        cb, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED);
    }

    memset(&LongReturn, 0, sizeof(LongReturn));
    _TRY_(Long_Return_Decode(h, &LongReturn))
    
    lReturn =  LongReturn.ReturnCode;

    _TRY_2(Long_Return_Free(h, &LongReturn))

Return:

    SafeMesHandleFree(&h);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardEstablishContext
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardEstablishContext(
	IN DWORD dwScope, 
    IN LPCVOID pvReserved1, 
    IN LPCVOID pvReserved2, 
    OUT LPSCARDCONTEXT phContext)
{
    LONG                    lReturn                 = SCARD_S_SUCCESS;
    NTSTATUS                Status                  = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus               = RPC_S_OK;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                h                       = 0;
    BOOL                    fFreeDecode             = FALSE;
    BUFFER_LIST_STRUCT      *pOutputBuffer          = NULL;
    EstablishContext_Call   EstablishContextCall;
    EstablishContext_Return EstablishContextReturn;

    //
    // Validate input params and initialize the out param
    //
    if (phContext == NULL)
    {
        ERROR_RETURN(SCARD_E_INVALID_PARAMETER)
    }
    else
    {
        *phContext = NULL;
    }
    if ((SCARD_SCOPE_USER != dwScope)
            // && (SCARD_SCOPE_TERMINAL != dwScope) // Maybe NT V5+?
            && (SCARD_SCOPE_SYSTEM != dwScope))
    {
        ERROR_RETURN(SCARD_E_INVALID_VALUE)
    }
    
    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the EstablishContext params
    //
    EstablishContextCall.dwScope = dwScope;
    _TRY_(EstablishContext_Call_Encode(h, &EstablishContextCall))
    
    //
    // Make the EstablishContext call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_ESTABLISHCONTEXT,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&EstablishContextReturn, 0, sizeof(EstablishContextReturn));
    _TRY_(EstablishContext_Return_Decode(h, &EstablishContextReturn))
    fFreeDecode = TRUE;
    
    lReturn =  EstablishContextReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        REDIR_LOCAL_SCARDCONTEXT *pRedirLocalContext = NULL;

        //
        // The value that represents the SCARDCONTEXT on the remote client 
        // machine is a variable size, so allocate memory for the struct 
        // that holds the variable length context size and pointer, plus
        // the actual bytes for the context
        //
        pRedirLocalContext = (REDIR_LOCAL_SCARDCONTEXT *) 
                                MIDL_user_allocate(
                                    sizeof(REDIR_LOCAL_SCARDCONTEXT) +
                                    EstablishContextReturn.Context.cbContext);

        if (pRedirLocalContext != NULL)
        {
            pRedirLocalContext->Context.cbContext = EstablishContextReturn.Context.cbContext;
            pRedirLocalContext->Context.pbContext = ((BYTE *) pRedirLocalContext) + 
                                                    sizeof(REDIR_LOCAL_SCARDCONTEXT);            
            memcpy(
                pRedirLocalContext->Context.pbContext, 
                EstablishContextReturn.Context.pbContext,
                EstablishContextReturn.Context.cbContext);

            pRedirLocalContext->hHeap = (HANDLE) pvReserved1;

            *phContext = (SCARDCONTEXT) pRedirLocalContext;

            //
            // This event is the "smart card subsystem started" event that 
            // winscard.dll and scredir.dll share.  scredir will Reset this event 
            // if it gets a STATUS_CANCELLED returned from the rdpdr driver.  It 
            // does this so that the event goes into the unsignalled state as soon as
            // possible when a disconnect is detected... a STATUS_CANCELLED
            // returned from rdpdr happens when a disconnect takes place, so this
            // event is Reset when that happens
            //
            g_hConnectedEvent = (HANDLE) pvReserved2;
        }
        else
        {
            lReturn = SCARD_E_NO_MEMORY;
        }        
    }

Return:

    if (fFreeDecode)
    {
        _TRY_2(EstablishContext_Return_Free(h, &EstablishContextReturn))
    }

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    if ((phContext != NULL) && (*phContext != NULL))
    {
        MIDL_user_free((void *) *phContext);
        *phContext = NULL;
    }

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  I_ContextCallWithLongReturn
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
I_ContextCallWithLongReturn(
    IN SCARDCONTEXT hContext,
    ULONG IoControlCode)
{
    LONG                    lReturn             = SCARD_S_SUCCESS;
    NTSTATUS                Status              = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus           = RPC_S_OK;
    char                    *pbEncodedBuffer    = NULL;
    unsigned long           cbEncodedBuffer     = 0;
    handle_t                h                   = 0;
    BUFFER_LIST_STRUCT      *pOutputBuffer      = NULL;
    Context_Call            ContextCall;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    
    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the ContextCall params
    //
    ContextCall.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    _TRY_(Context_Call_Encode(h, &ContextCall))

    //
    // Make the IoControl call to the client
    //
    Status = _SendSCardIOCTL(
                    IoControlCode,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    
    //
    // Decode the return
    //
    lReturn = I_DecodeLongReturn(pOutputBuffer->pbBytes, pOutputBuffer->cbBytesUsed);    

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardReleaseContext
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardReleaseContext(
    IN SCARDCONTEXT hContext)
{
    LONG lReturn = SCARD_S_SUCCESS;

    __try
    {
        if (hContext == NULL)
        {
            return (SCARD_E_INVALID_PARAMETER);
        }

        lReturn = I_ContextCallWithLongReturn(
                        hContext,
                        SCARD_IOCTL_RELEASECONTEXT);

        MIDL_user_free((REDIR_LOCAL_SCARDCONTEXT *) hContext);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    return (lReturn);
}


//---------------------------------------------------------------------------------------
//
//  SCardIsValidContext
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardIsValidContext(
    IN SCARDCONTEXT hContext)
{
    return (I_ContextCallWithLongReturn(
                hContext,
                SCARD_IOCTL_ISVALIDCONTEXT));
}


//---------------------------------------------------------------------------------------
//
//  SCardListReaderGroups
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
I_SCardListReaderGroups(
    IN SCARDCONTEXT hContext, 
    OUT LPBYTE mszGroups, 
    IN OUT LPDWORD pcchGroups,
    IN BOOL fUnicode)
{
    LONG                    lReturn                 = SCARD_S_SUCCESS;
    NTSTATUS                Status                  = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus               = RPC_S_OK;
    char                    *pbEncodedBuffer        = NULL;
    unsigned long           cbEncodedBuffer         = 0;
    handle_t                h                       = 0;
    BUFFER_LIST_STRUCT      *pOutputBuffer          = NULL;
    ListReaderGroups_Call   ListReaderGroupsCall;
    ListReaderGroups_Return ListReaderGroupsReturn;

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the ListReaderGroups params
    //
    if (hContext != NULL)
    {
        ListReaderGroupsCall.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    }
    else
    {
        ListReaderGroupsCall.Context.pbContext = NULL;
        ListReaderGroupsCall.Context.cbContext = 0;
    }
    ListReaderGroupsCall.fmszGroupsIsNULL   = (mszGroups == NULL);
    ListReaderGroupsCall.cchGroups          = *pcchGroups;
    _TRY_(ListReaderGroups_Call_Encode(h, &ListReaderGroupsCall))

    //
    // Make the ListReaderGroups call to the client
    //
    Status = _SendSCardIOCTL(
                    fUnicode ?  SCARD_IOCTL_LISTREADERGROUPSW : 
                                SCARD_IOCTL_LISTREADERGROUPSA,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&ListReaderGroupsReturn, 0, sizeof(ListReaderGroupsReturn));
    _TRY_(ListReaderGroups_Return_Decode(h, &ListReaderGroupsReturn))
    
    //
    // If successful, then copy the returned multi string
    //
    if (ListReaderGroupsReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        lReturn = _CopyReturnToCallerBuffer(
                        (REDIR_LOCAL_SCARDCONTEXT *) hContext,
                        ListReaderGroupsReturn.msz,
                        ListReaderGroupsReturn.cBytes,
                        mszGroups,
                        pcchGroups,
                        fUnicode ? WSZ_TYPE_RETURN : SZ_TYPE_RETURN);
    }
    else
    {
        lReturn = ListReaderGroupsReturn.ReturnCode;
    }

    _TRY_2(ListReaderGroups_Return_Free(h, &ListReaderGroupsReturn))    

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}

WINSCARDAPI LONG WINAPI 
SCardListReaderGroupsA(
    IN SCARDCONTEXT hContext, 
    OUT LPSTR mszGroups, 
    IN OUT LPDWORD pcchGroups)
{
    return (I_SCardListReaderGroups(
                hContext, 
                (LPBYTE) mszGroups, 
                pcchGroups, 
                FALSE));
}

WINSCARDAPI LONG WINAPI 
SCardListReaderGroupsW(
    IN SCARDCONTEXT hContext, 
    OUT LPWSTR mszGroups, 
    IN OUT LPDWORD pcchGroups)
{
    return (I_SCardListReaderGroups(
                hContext, 
                (LPBYTE) mszGroups, 
                pcchGroups, 
                TRUE));
}


//---------------------------------------------------------------------------------------
//
//  SCardListReaders
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
I_SCardListReaders(
    IN SCARDCONTEXT hContext, 
    IN LPCBYTE mszGroups, 
    OUT LPBYTE mszReaders, 
    IN OUT LPDWORD pcchReaders,
    IN BOOL fUnicode)
{
    LONG                    lReturn             = SCARD_S_SUCCESS;
    NTSTATUS                Status              = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus           = RPC_S_OK;
    char                    *pbEncodedBuffer    = NULL;
    unsigned long           cbEncodedBuffer     = 0;
    handle_t                h                   = 0;
    BUFFER_LIST_STRUCT      *pOutputBuffer      = NULL;
    ListReaders_Call        ListReadersCall;
    ListReaders_Return      ListReadersReturn;

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the ListReaders params
    //
    if (hContext != NULL)
    {
        ListReadersCall.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    }
    else
    {
        ListReadersCall.Context.pbContext = NULL;
        ListReadersCall.Context.cbContext = 0;
    }
    ListReadersCall.cBytes              = fUnicode ?    
                                                _CalculateNumBytesInMultiStringW((LPCWSTR) mszGroups) : 
                                                _CalculateNumBytesInMultiStringA((LPCSTR) mszGroups);
    ListReadersCall.mszGroups           = mszGroups;
    ListReadersCall.fmszReadersIsNULL   = (mszReaders == NULL);
    ListReadersCall.cchReaders          = *pcchReaders;
    _TRY_(ListReaders_Call_Encode(h, &ListReadersCall))

    //
    // Make the ListReaders call to the client
    //
    Status = _SendSCardIOCTL(
                        fUnicode ?  SCARD_IOCTL_LISTREADERSW : 
                                    SCARD_IOCTL_LISTREADERSA,
                        pbEncodedBuffer,
                        cbEncodedBuffer,
                        &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&ListReadersReturn, 0, sizeof(ListReadersReturn));
    _TRY_(ListReaders_Return_Decode(h, &ListReadersReturn))    

    //
    // If successful, then copy the returned multi string
    //
    if (ListReadersReturn.ReturnCode == SCARD_S_SUCCESS)
    {
        lReturn = _CopyReturnToCallerBuffer(
                        (REDIR_LOCAL_SCARDCONTEXT *) hContext,
                        ListReadersReturn.msz,
                        ListReadersReturn.cBytes,
                        mszReaders,
                        pcchReaders,
                        fUnicode ? WSZ_TYPE_RETURN : SZ_TYPE_RETURN);
    }
    else
    {
        lReturn =  ListReadersReturn.ReturnCode;
    }

    _TRY_2(ListReaders_Return_Free(h, &ListReadersReturn))   

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}

WINSCARDAPI LONG WINAPI 
SCardListReadersA(
    IN SCARDCONTEXT hContext, 
    IN LPCSTR mszGroups, 
    OUT LPSTR mszReaders, 
    IN OUT LPDWORD pcchReaders)
{
    return (I_SCardListReaders(
                hContext, 
                (LPCBYTE) mszGroups, 
                (LPBYTE) mszReaders, 
                pcchReaders,
                FALSE));
}

WINSCARDAPI LONG WINAPI 
SCardListReadersW(
    IN SCARDCONTEXT hContext, 
    IN LPCWSTR mszGroups, 
    OUT LPWSTR mszReaders, 
    IN OUT LPDWORD pcchReaders)
{
    return (I_SCardListReaders(
                hContext, 
                (LPCBYTE) mszGroups, 
                (LPBYTE) mszReaders, 
                pcchReaders,
                TRUE));
}


//---------------------------------------------------------------------------------------
//
//  I_ContextAndStringCallWithLongReturn
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
I_ContextAndStringCallWithLongReturn(
    IN SCARDCONTEXT hContext, 
    IN LPCBYTE sz,
    IN BOOL fUnicode,
    ULONG IoControlCode)
{
    LONG                        lReturn                 = SCARD_S_SUCCESS;
    NTSTATUS                    Status                  = STATUS_SUCCESS;
    RPC_STATUS                  rpcStatus               = RPC_S_OK;
    char                        *pbEncodedBuffer        = NULL;
    unsigned long               cbEncodedBuffer         = 0;
    handle_t                    h                       = 0;
    BUFFER_LIST_STRUCT          *pOutputBuffer          = NULL;
    ContextAndStringA_Call      ContextAndStringCallA;
    ContextAndStringW_Call      ContextAndStringCallW;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }    
    
    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the ContextAndString params
    //
    ContextAndStringCallA.Context = 
        ContextAndStringCallW.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    
    if (fUnicode)
    {
        ContextAndStringCallW.sz = (LPCWSTR) sz;
        _TRY_(ContextAndStringW_Call_Encode(h, &ContextAndStringCallW))
    }
    else
    {
        ContextAndStringCallA.sz = (LPCSTR) sz;
        _TRY_(ContextAndStringA_Call_Encode(h, &ContextAndStringCallA))
    }
    
    //
    // Make the call to the client
    //
    Status = _SendSCardIOCTL(
                IoControlCode,
                pbEncodedBuffer,
                cbEncodedBuffer,
                &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    
    //
    // Decode the return
    //
    lReturn = I_DecodeLongReturn(pOutputBuffer->pbBytes, pOutputBuffer->cbBytesUsed);
   
Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardIntroduceReaderGroup
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardIntroduceReaderGroupA(
    IN SCARDCONTEXT hContext, 
    IN LPCSTR szGroupName)
{
    return (I_ContextAndStringCallWithLongReturn(
                hContext, 
                (LPCBYTE) szGroupName,
                FALSE,
                SCARD_IOCTL_INTRODUCEREADERGROUPA));
}

WINSCARDAPI LONG WINAPI 
SCardIntroduceReaderGroupW(
    IN SCARDCONTEXT hContext, 
    IN LPCWSTR szGroupName)
{
    return (I_ContextAndStringCallWithLongReturn(
                hContext, 
                (LPCBYTE) szGroupName,
                TRUE,
                SCARD_IOCTL_INTRODUCEREADERGROUPW));
}


//---------------------------------------------------------------------------------------
//
//  SCardForgetReaderGroup
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardForgetReaderGroupA(
    IN SCARDCONTEXT hContext, 
    IN LPCSTR szGroupName)
{
    return (I_ContextAndStringCallWithLongReturn(
                hContext, 
                (LPCBYTE) szGroupName,
                FALSE,
                SCARD_IOCTL_FORGETREADERGROUPA));
}

WINSCARDAPI LONG WINAPI 
SCardForgetReaderGroupW(
    IN SCARDCONTEXT hContext, 
    IN LPCWSTR szGroupName)
{
    return (I_ContextAndStringCallWithLongReturn(
                hContext, 
                (LPCBYTE) szGroupName,
                TRUE,
                SCARD_IOCTL_FORGETREADERGROUPW));
}


//---------------------------------------------------------------------------------------
//
//  I_ContextAndTwoStringCallWithLongReturn
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
I_ContextAndTwoStringCallWithLongReturn(
    IN SCARDCONTEXT hContext, 
    IN LPCBYTE sz1,
    IN LPCBYTE sz2,
    IN BOOL fUnicode,
    ULONG IoControlCode)
{
    LONG                        lReturn                     = SCARD_S_SUCCESS;
    NTSTATUS                    Status                      = STATUS_SUCCESS;
    RPC_STATUS                  rpcStatus                   = RPC_S_OK;
    char                        *pbEncodedBuffer            = NULL;
    unsigned long               cbEncodedBuffer             = 0;
    handle_t                    h                           = 0;
    BUFFER_LIST_STRUCT          *pOutputBuffer              = NULL;
    ContextAndTwoStringA_Call   ContextAndTwoStringCallA;
    ContextAndTwoStringW_Call   ContextAndTwoStringCallW;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    
    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the ContextAndTwoString params
    //
    ContextAndTwoStringCallA.Context = 
        ContextAndTwoStringCallW.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    
    if (fUnicode)
    {
        ContextAndTwoStringCallW.sz1 = (LPCWSTR) sz1;
        ContextAndTwoStringCallW.sz2 = (LPCWSTR) sz2;
        _TRY_(ContextAndTwoStringW_Call_Encode(h, &ContextAndTwoStringCallW))
    }
    else
    {
        ContextAndTwoStringCallA.sz1 = (LPCSTR) sz1;
        ContextAndTwoStringCallA.sz2 = (LPCSTR) sz2;
        _TRY_(ContextAndTwoStringA_Call_Encode(h, &ContextAndTwoStringCallA))
    }
    
    //
    // Make the call to the client
    //
    Status = _SendSCardIOCTL(
                    IoControlCode,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        MesHandleFree(h);
        ERROR_RETURN(_MakeSCardError(Status))
    }
    
    //
    // Decode the return
    //
    lReturn = I_DecodeLongReturn(pOutputBuffer->pbBytes, pOutputBuffer->cbBytesUsed);

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardIntroduceReader
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardIntroduceReaderA(
    IN SCARDCONTEXT hContext, 
    IN LPCSTR szReaderName, 
    IN LPCSTR szDeviceName)
{
    return (I_ContextAndTwoStringCallWithLongReturn(
                hContext, 
                (LPCBYTE) szReaderName,
                (LPCBYTE) szDeviceName,
                FALSE,
                SCARD_IOCTL_INTRODUCEREADERA));   
}

WINSCARDAPI LONG WINAPI 
SCardIntroduceReaderW(
    IN SCARDCONTEXT hContext, 
    IN LPCWSTR szReaderName, 
    IN LPCWSTR szDeviceName)
{
    return (I_ContextAndTwoStringCallWithLongReturn(
                hContext, 
                (LPCBYTE) szReaderName,
                (LPCBYTE) szDeviceName,
                TRUE,
                SCARD_IOCTL_INTRODUCEREADERW));   
}


//---------------------------------------------------------------------------------------
//
//  SCardForgetReader
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardForgetReaderA(
    IN SCARDCONTEXT hContext, 
    IN LPCSTR szReaderName)
{
    return (I_ContextAndStringCallWithLongReturn(
                hContext, 
                (LPCBYTE) szReaderName,
                FALSE,
                SCARD_IOCTL_FORGETREADERA));
}

WINSCARDAPI LONG WINAPI 
SCardForgetReaderW(
    IN SCARDCONTEXT hContext, 
    IN LPCWSTR szReaderName)
{
    return (I_ContextAndStringCallWithLongReturn(
                hContext, 
                (LPCBYTE) szReaderName,
                TRUE,
                SCARD_IOCTL_FORGETREADERW));
}


//---------------------------------------------------------------------------------------
//
//  SCardAddReaderToGroup
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardAddReaderToGroupA(
    IN SCARDCONTEXT hContext, 
    IN LPCSTR szReaderName, 
    IN LPCSTR szGroupName)
{
    return (I_ContextAndTwoStringCallWithLongReturn(
                hContext, 
                (LPCBYTE) szReaderName,
                (LPCBYTE) szGroupName,
                FALSE,
                SCARD_IOCTL_ADDREADERTOGROUPA));
}

WINSCARDAPI LONG WINAPI 
SCardAddReaderToGroupW(
    IN SCARDCONTEXT hContext, 
    IN LPCWSTR szReaderName, 
    IN LPCWSTR szGroupName)
{
    return (I_ContextAndTwoStringCallWithLongReturn(
                hContext, 
                (LPCBYTE) szReaderName,
                (LPCBYTE) szGroupName,
                TRUE,
                SCARD_IOCTL_ADDREADERTOGROUPW)); 
}


//---------------------------------------------------------------------------------------
//
//  SCardRemoveReaderFromGroup
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardRemoveReaderFromGroupA(
    IN SCARDCONTEXT hContext, 
    IN LPCSTR szReaderName, 
    IN LPCSTR szGroupName)
{
    return (I_ContextAndTwoStringCallWithLongReturn(
                hContext, 
                (LPCBYTE) szReaderName,
                (LPCBYTE) szGroupName,
                FALSE,
                SCARD_IOCTL_REMOVEREADERFROMGROUPA)); 
}

WINSCARDAPI LONG WINAPI 
SCardRemoveReaderFromGroupW(
    IN SCARDCONTEXT hContext, 
    IN LPCWSTR szReaderName, 
    IN LPCWSTR szGroupName)
{
    return (I_ContextAndTwoStringCallWithLongReturn(
                hContext, 
                (LPCBYTE) szReaderName,
                (LPCBYTE) szGroupName,
                TRUE,
                SCARD_IOCTL_REMOVEREADERFROMGROUPW)); 
}


//---------------------------------------------------------------------------------------
//
//  _AllocAndCopyReaderState*StructsForCall and _CopyReaderState*StructsForReturn
//
//---------------------------------------------------------------------------------------
LONG
_AllocAndCopyReaderStateAStructsForCall(
    DWORD                   cReaders,
    ReaderStateA            **prgReaderStatesToEncodeA,
    LPSCARD_READERSTATE_A   rgReaderStates)
{
    DWORD           i;
    ReaderStateA    *rgAlloced;

    rgAlloced = (ReaderStateA *) 
            MIDL_user_allocate(cReaders * sizeof(ReaderStateA));

    if (rgAlloced == NULL)
    {
        return (SCARD_E_NO_MEMORY);
    }

    for (i=0; i<cReaders; i++)
    {       
        rgAlloced[i].Common.dwCurrentState = 
                rgReaderStates[i].dwCurrentState;
        rgAlloced[i].Common.dwEventState = 
                rgReaderStates[i].dwEventState;
        rgAlloced[i].Common.cbAtr = 
            rgReaderStates[i].cbAtr;
        memcpy(
            rgAlloced[i].Common.rgbAtr,
            rgReaderStates[i].rgbAtr,
            36);
        rgAlloced[i].szReader = 
                rgReaderStates[i].szReader;        
    }

    *prgReaderStatesToEncodeA = rgAlloced;

    return (SCARD_S_SUCCESS);
}

LONG
_AllocAndCopyReaderStateWStructsForCall(
    DWORD                   cReaders,
    ReaderStateW            **prgReaderStatesToEncodeW,
    LPSCARD_READERSTATE_W   rgReaderStates)
{
    DWORD           i;
    ReaderStateW    *rgAlloced;

    rgAlloced = (ReaderStateW *) 
            MIDL_user_allocate(cReaders * sizeof(ReaderStateW));

    if (rgAlloced == NULL)
    {
        return (SCARD_E_NO_MEMORY);
    }

    for (i=0; i<cReaders; i++)
    {       
        rgAlloced[i].Common.dwCurrentState = 
                rgReaderStates[i].dwCurrentState;
        rgAlloced[i].Common.dwEventState = 
                rgReaderStates[i].dwEventState;
        rgAlloced[i].Common.cbAtr = 
            rgReaderStates[i].cbAtr;
        memcpy(
            rgAlloced[i].Common.rgbAtr,
            rgReaderStates[i].rgbAtr,
            36);
        rgAlloced[i].szReader = 
                rgReaderStates[i].szReader;        
    }

    *prgReaderStatesToEncodeW = rgAlloced;

    return (SCARD_S_SUCCESS);
}

void
_CopyReaderStateAStructsForReturn(
    DWORD                   cReaders,
    LPSCARD_READERSTATE_A   rgReaderStates,
    ReaderState_Return      *rgReaderStatesReturned)
{
    DWORD i;

    for (i=0; i<cReaders; i++)
    {
        rgReaderStates[i].dwCurrentState = 
                rgReaderStatesReturned[i].dwCurrentState;
        rgReaderStates[i].dwEventState = 
                rgReaderStatesReturned[i].dwEventState;
        rgReaderStates[i].cbAtr = 
                rgReaderStatesReturned[i].cbAtr;
        memcpy(
            rgReaderStates[i].rgbAtr,
            rgReaderStatesReturned[i].rgbAtr,
            36);
    }
}

void
_CopyReaderStateWStructsForReturn(
    DWORD                   cReaders,
    LPSCARD_READERSTATE_W   rgReaderStates,
    ReaderState_Return      *rgReaderStatesReturned)
{
    DWORD i;

    for (i=0; i<cReaders; i++)
    {
        rgReaderStates[i].dwCurrentState = 
                rgReaderStatesReturned[i].dwCurrentState;
        rgReaderStates[i].dwEventState = 
                rgReaderStatesReturned[i].dwEventState;
        rgReaderStates[i].cbAtr = 
                rgReaderStatesReturned[i].cbAtr;
        memcpy(
            rgReaderStates[i].rgbAtr,
            rgReaderStatesReturned[i].rgbAtr,
            36);
    }
}


//---------------------------------------------------------------------------------------
//
//  _AllocAndCopyATRMasksForCall
//
//---------------------------------------------------------------------------------------
LONG
_AllocAndCopyATRMasksForCall(
    DWORD                   cAtrs,
    LocateCards_ATRMask     **prgATRMasksToEncode,
    LPSCARD_ATRMASK         rgAtrMasks)
{
    DWORD               i;
    LocateCards_ATRMask *rgAlloced;

    rgAlloced = (LocateCards_ATRMask *) 
            MIDL_user_allocate(cAtrs * sizeof(LocateCards_ATRMask));

    if (rgAlloced == NULL)
    {
        return (SCARD_E_NO_MEMORY);
    }

    for (i=0; i<cAtrs; i++)
    {       
        rgAlloced[i].cbAtr = rgAtrMasks[i].cbAtr;
        memcpy(
            rgAlloced[i].rgbAtr,
            rgAtrMasks[i].rgbAtr,
            36);
        memcpy(
            rgAlloced[i].rgbMask,
            rgAtrMasks[i].rgbMask,
            36);  
    }

    *prgATRMasksToEncode = rgAlloced;

    return (SCARD_S_SUCCESS);
}

//---------------------------------------------------------------------------------------
//
//  SCardLocateCardsA
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardLocateCardsA(
    IN SCARDCONTEXT hContext, 
    IN LPCSTR mszCards, 
    IN OUT LPSCARD_READERSTATE_A rgReaderStates, 
    IN DWORD cReaders)
{
    LONG                lReturn                     = SCARD_S_SUCCESS;
    NTSTATUS            Status                      = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus                   = RPC_S_OK;
    char                *pbEncodedBuffer            = NULL;
    unsigned long       cbEncodedBuffer             = 0;
    handle_t            h                           = 0;
    LocateCardsA_Call   LocateCardsCallA;
    LocateCards_Return  LocateCardsReturn;
    ReaderStateA        *rgReaderStatesToEncodeA    = NULL;
    BUFFER_LIST_STRUCT  *pOutputBuffer              = NULL;
    DWORD               i;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    
    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the LocateCards params
    // 
    LocateCardsCallA.Context =  ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    LocateCardsCallA.cBytes = _CalculateNumBytesInMultiStringA(mszCards);
    LocateCardsCallA.mszCards = (LPCBYTE) mszCards;
    LocateCardsCallA.cReaders = cReaders;

    lReturn = _AllocAndCopyReaderStateAStructsForCall(
                    cReaders, 
                    &rgReaderStatesToEncodeA, 
                    rgReaderStates);
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }
    LocateCardsCallA.rgReaderStates = rgReaderStatesToEncodeA;

    _TRY_(LocateCardsA_Call_Encode(h, &LocateCardsCallA))

    //
    // Make the LocateCards call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_LOCATECARDSA,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&LocateCardsReturn, 0 , sizeof(LocateCardsReturn));
    _TRY_(LocateCards_Return_Decode(h, &LocateCardsReturn))
    
    lReturn = LocateCardsReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        _CopyReaderStateAStructsForReturn(
                cReaders, 
                rgReaderStates, 
                LocateCardsReturn.rgReaderStates);  
    }

    _TRY_2(LocateCards_Return_Free(h, &LocateCardsReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(rgReaderStatesToEncodeA);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardLocateCardsW
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardLocateCardsW(
    IN SCARDCONTEXT hContext, 
    IN LPCWSTR mszCards, 
    IN OUT LPSCARD_READERSTATE_W rgReaderStates, 
    IN DWORD cReaders)
{
    LONG                lReturn                     = SCARD_S_SUCCESS;
    NTSTATUS            Status                      = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus                   = RPC_S_OK;
    char                *pbEncodedBuffer            = NULL;
    unsigned long       cbEncodedBuffer             = 0;
    handle_t            h                           = 0;
    LocateCardsW_Call   LocateCardsCallW;
    LocateCards_Return  LocateCardsReturn;
    ReaderStateW        *rgReaderStatesToEncodeW    = NULL;
    BUFFER_LIST_STRUCT  *pOutputBuffer              = NULL;
    DWORD               i;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    
    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the LocateCards params
    //
    LocateCardsCallW.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    LocateCardsCallW.cBytes = _CalculateNumBytesInMultiStringW(mszCards);
    LocateCardsCallW.mszCards = (LPCBYTE) mszCards;
    LocateCardsCallW.cReaders = cReaders;

    lReturn = _AllocAndCopyReaderStateWStructsForCall(
                    cReaders, 
                    &rgReaderStatesToEncodeW, 
                    rgReaderStates); 
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }
    LocateCardsCallW.rgReaderStates = rgReaderStatesToEncodeW;
    
    _TRY_(LocateCardsW_Call_Encode(h, &LocateCardsCallW))

    //
    // Make the LocateCards call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_LOCATECARDSW,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&LocateCardsReturn, 0, sizeof(LocateCardsReturn));
    _TRY_(LocateCards_Return_Decode(h, &LocateCardsReturn))
    
    lReturn = LocateCardsReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        _CopyReaderStateWStructsForReturn(
                cReaders, 
                rgReaderStates, 
                LocateCardsReturn.rgReaderStates);     
    }

    _TRY_2(LocateCards_Return_Free(h, &LocateCardsReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(rgReaderStatesToEncodeW);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardLocateCardsByATRA
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardLocateCardsByATRA(
    IN SCARDCONTEXT hContext, 
    IN LPSCARD_ATRMASK rgAtrMasks,
    IN DWORD cAtrs, 
    IN OUT LPSCARD_READERSTATE_A rgReaderStates, 
    IN DWORD cReaders)
{
    LONG                    lReturn                     = SCARD_S_SUCCESS;
    NTSTATUS                Status                      = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus                   = RPC_S_OK;
    char                    *pbEncodedBuffer            = NULL;
    unsigned long           cbEncodedBuffer             = 0;
    handle_t                h                           = 0;
    LocateCardsByATRA_Call  LocateCardsByATRA_Call;
    LocateCards_ATRMask     *rgATRMasksToEncode         = NULL;
    LocateCards_Return      LocateCardsReturn;
    ReaderStateA            *rgReaderStatesToEncodeA    = NULL;
    BUFFER_LIST_STRUCT      *pOutputBuffer              = NULL;
    DWORD                   i;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    
    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the LocateCards params
    // 
    LocateCardsByATRA_Call.Context =  ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    LocateCardsByATRA_Call.cAtrs = cAtrs;
    LocateCardsByATRA_Call.cReaders = cReaders;

    lReturn = _AllocAndCopyATRMasksForCall(
                    cAtrs, 
                    &rgATRMasksToEncode, 
                    rgAtrMasks);
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }
    LocateCardsByATRA_Call.rgAtrMasks = rgATRMasksToEncode;

    lReturn = _AllocAndCopyReaderStateAStructsForCall(
                    cReaders, 
                    &rgReaderStatesToEncodeA, 
                    rgReaderStates);
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }
    LocateCardsByATRA_Call.rgReaderStates = rgReaderStatesToEncodeA;

    _TRY_(LocateCardsByATRA_Call_Encode(h, &LocateCardsByATRA_Call))

    //
    // Make the LocateCards call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_LOCATECARDSBYATRA,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&LocateCardsReturn, 0 , sizeof(LocateCardsReturn));
    _TRY_(LocateCards_Return_Decode(h, &LocateCardsReturn))
    
    lReturn = LocateCardsReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        _CopyReaderStateAStructsForReturn(
                cReaders, 
                rgReaderStates, 
                LocateCardsReturn.rgReaderStates);  
    }

    _TRY_2(LocateCards_Return_Free(h, &LocateCardsReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(rgATRMasksToEncode);

    MIDL_user_free(rgReaderStatesToEncodeA);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardLocateCardsByATRW
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardLocateCardsByATRW(
    IN SCARDCONTEXT hContext, 
    IN LPSCARD_ATRMASK rgAtrMasks,
    IN DWORD cAtrs, 
    IN OUT LPSCARD_READERSTATE_W rgReaderStates, 
    IN DWORD cReaders)
{
    LONG                    lReturn                     = SCARD_S_SUCCESS;
    NTSTATUS                Status                      = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus                   = RPC_S_OK;
    char                    *pbEncodedBuffer            = NULL;
    unsigned long           cbEncodedBuffer             = 0;
    handle_t                h                           = 0;
    LocateCardsByATRW_Call  LocateCardsByATRW_Call;
    LocateCards_ATRMask     *rgATRMasksToEncode         = NULL;
    LocateCards_Return      LocateCardsReturn;
    ReaderStateW            *rgReaderStatesToEncodeW    = NULL;
    BUFFER_LIST_STRUCT      *pOutputBuffer              = NULL;
    DWORD                   i;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    
    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the LocateCards params
    // 
    LocateCardsByATRW_Call.Context =  ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    LocateCardsByATRW_Call.cAtrs = cAtrs;
    LocateCardsByATRW_Call.cReaders = cReaders;

    lReturn = _AllocAndCopyATRMasksForCall(
                    cAtrs, 
                    &rgATRMasksToEncode, 
                    rgAtrMasks);
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }
    LocateCardsByATRW_Call.rgAtrMasks = rgATRMasksToEncode;

    lReturn = _AllocAndCopyReaderStateWStructsForCall(
                    cReaders, 
                    &rgReaderStatesToEncodeW, 
                    rgReaderStates);
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }
    LocateCardsByATRW_Call.rgReaderStates = rgReaderStatesToEncodeW;

    _TRY_(LocateCardsByATRW_Call_Encode(h, &LocateCardsByATRW_Call))

    //
    // Make the LocateCards call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_LOCATECARDSBYATRW,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&LocateCardsReturn, 0 , sizeof(LocateCardsReturn));
    _TRY_(LocateCards_Return_Decode(h, &LocateCardsReturn))
    
    lReturn = LocateCardsReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        _CopyReaderStateWStructsForReturn(
                cReaders, 
                rgReaderStates, 
                LocateCardsReturn.rgReaderStates);  
    }

    _TRY_2(LocateCards_Return_Free(h, &LocateCardsReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(rgATRMasksToEncode);

    MIDL_user_free(rgReaderStatesToEncodeW);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardGetStatusChangeA
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardGetStatusChangeA(
    IN SCARDCONTEXT hContext, 
    IN DWORD dwTimeout, 
    IN OUT LPSCARD_READERSTATE_A rgReaderStates, 
    IN DWORD cReaders)
{
    LONG                    lReturn                     = SCARD_S_SUCCESS;
    NTSTATUS                Status                      = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus                   = RPC_S_OK;
    char                    *pbEncodedBuffer            = NULL;
    unsigned long           cbEncodedBuffer             = 0;
    handle_t                h                           = 0;
    GetStatusChangeA_Call   GetStatusChangeCallA;
    GetStatusChange_Return  GetStatusChangeReturn;
    ReaderStateA            *rgReaderStatesToEncodeA    = NULL;
    BUFFER_LIST_STRUCT      *pOutputBuffer              = NULL;
    DWORD                   i;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    
    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the LocateCards params
    //
    GetStatusChangeCallA.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    GetStatusChangeCallA.dwTimeOut = dwTimeout;
    GetStatusChangeCallA.cReaders = cReaders;
    
    lReturn = _AllocAndCopyReaderStateAStructsForCall(
                    cReaders, 
                    &rgReaderStatesToEncodeA, 
                    rgReaderStates); 
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }
    
    GetStatusChangeCallA.rgReaderStates = rgReaderStatesToEncodeA;
    
    _TRY_(GetStatusChangeA_Call_Encode(h, &GetStatusChangeCallA))

    //
    // Make the GetStatusChange call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_GETSTATUSCHANGEA,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&GetStatusChangeReturn, 0, sizeof(GetStatusChangeReturn));
    _TRY_(GetStatusChange_Return_Decode(h, &GetStatusChangeReturn))
    
    lReturn = GetStatusChangeReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        _CopyReaderStateAStructsForReturn(
                cReaders, 
                rgReaderStates, 
                GetStatusChangeReturn.rgReaderStates);        
    }

    _TRY_2(GetStatusChange_Return_Free(h, &GetStatusChangeReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(rgReaderStatesToEncodeA);       

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardGetStatusChangew
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardGetStatusChangeW(
    IN SCARDCONTEXT hContext, 
    IN DWORD dwTimeout, 
    IN OUT LPSCARD_READERSTATE_W rgReaderStates, 
    IN DWORD cReaders)
{
    LONG                    lReturn                     = SCARD_S_SUCCESS;
    NTSTATUS                Status                      = STATUS_SUCCESS;
    RPC_STATUS              rpcStatus                   = RPC_S_OK;
    char                    *pbEncodedBuffer            = NULL;
    unsigned long           cbEncodedBuffer             = 0;
    handle_t                h                           = 0;
    GetStatusChangeW_Call   GetStatusChangeCallW;
    GetStatusChange_Return  GetStatusChangeReturn;
    ReaderStateW            *rgReaderStatesToEncodeW    = NULL;
    BUFFER_LIST_STRUCT      *pOutputBuffer              = NULL;
    DWORD                   i;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    
    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the LocateCards params
    //
    GetStatusChangeCallW.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    GetStatusChangeCallW.dwTimeOut = dwTimeout;
    GetStatusChangeCallW.cReaders = cReaders;
    
    lReturn = _AllocAndCopyReaderStateWStructsForCall(
                    cReaders, 
                    &rgReaderStatesToEncodeW, 
                    rgReaderStates); 
    if (lReturn != SCARD_S_SUCCESS)
    {
        ERROR_RETURN(SCARD_E_NO_MEMORY)
    }
    
    GetStatusChangeCallW.rgReaderStates = rgReaderStatesToEncodeW;

    _TRY_(GetStatusChangeW_Call_Encode(h, &GetStatusChangeCallW))

    //
    // Make the GetStatusChange call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_GETSTATUSCHANGEW,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&GetStatusChangeReturn, 0, sizeof(GetStatusChangeReturn));
    _TRY_(GetStatusChange_Return_Decode(h, &GetStatusChangeReturn))
    
    lReturn = GetStatusChangeReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        _CopyReaderStateWStructsForReturn(
                cReaders, 
                rgReaderStates, 
                GetStatusChangeReturn.rgReaderStates);    
    }

    _TRY_2(GetStatusChange_Return_Free(h, &GetStatusChangeReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    MIDL_user_free(rgReaderStatesToEncodeW);       

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}

WINSCARDAPI LONG WINAPI 
SCardCancel(
    IN SCARDCONTEXT hContext)
{
    return (I_ContextCallWithLongReturn(
                hContext,
                SCARD_IOCTL_CANCEL));
}


//---------------------------------------------------------------------------------------
//
//  SCardConnect
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
I_SCardConnect(
    IN SCARDCONTEXT hContext, 
    IN LPCBYTE szReader, 
    IN DWORD dwShareMode, 
    IN DWORD dwPreferredProtocols, 
    OUT LPSCARDHANDLE phCard, 
    OUT LPDWORD pdwActiveProtocol,
    IN BOOL fUnicode)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    ConnectA_Call       ConnectCallA;
    ConnectW_Call       ConnectCallW;
    Connect_Return      ConnectReturn;

    if (hContext == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    
    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the Connect params
    //
    ConnectCallA.Common.Context = 
        ConnectCallW.Common.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
    ConnectCallA.Common.dwShareMode = 
        ConnectCallW.Common.dwShareMode = dwShareMode;
    ConnectCallA.Common.dwPreferredProtocols = 
        ConnectCallW.Common.dwPreferredProtocols = dwPreferredProtocols;
    
    if (fUnicode)
    {
        ConnectCallW.szReader = (LPCWSTR) szReader;
        _TRY_(ConnectW_Call_Encode(h, &ConnectCallW))
    }
    else
    {
        ConnectCallA.szReader = (LPCSTR) szReader;
        _TRY_(ConnectA_Call_Encode(h, &ConnectCallA))
    }
    
    //
    // Make the ListInterfaces call to the client
    //
    Status = _SendSCardIOCTL(
                    fUnicode ?  SCARD_IOCTL_CONNECTW : 
                                SCARD_IOCTL_CONNECTA,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&ConnectReturn, 0, sizeof(ConnectReturn));
    _TRY_(Connect_Return_Decode(h, &ConnectReturn))
    
    lReturn =  ConnectReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        REDIR_LOCAL_SCARDHANDLE *pRedirHandle = NULL;

        //
        // The value that represents the SCARDHANDLE on the remote client 
        // machine is a variable size, so allocate memory to for the struct 
        // that holds the variable length handle size and pointer, plus
        // the actual bytes for the handle, it also holds the context
        //
        pRedirHandle = (REDIR_LOCAL_SCARDHANDLE *) 
                                MIDL_user_allocate(
                                    sizeof(REDIR_LOCAL_SCARDHANDLE)   +
                                    ConnectReturn.hCard.cbHandle);

        if (pRedirHandle != NULL)
        {
            pRedirHandle->pRedirContext = (REDIR_LOCAL_SCARDCONTEXT *) hContext;
            
            pRedirHandle->Handle.Context = ((REDIR_LOCAL_SCARDCONTEXT *) hContext)->Context;
            
            pRedirHandle->Handle.cbHandle = ConnectReturn.hCard.cbHandle;
            pRedirHandle->Handle.pbHandle = ((BYTE *) pRedirHandle) + 
                                                sizeof(REDIR_LOCAL_SCARDHANDLE);
            memcpy(
                pRedirHandle->Handle.pbHandle, 
                ConnectReturn.hCard.pbHandle,
                ConnectReturn.hCard.cbHandle);

            *phCard = (SCARDHANDLE) pRedirHandle;

            *pdwActiveProtocol = ConnectReturn.dwActiveProtocol; 
        }
        else
        {
            lReturn = SCARD_E_NO_MEMORY;
        }          
    }

    _TRY_2(Connect_Return_Free(h, &ConnectReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}

WINSCARDAPI LONG WINAPI 
SCardConnectA(
    IN SCARDCONTEXT hContext, 
    IN LPCSTR szReader, 
    IN DWORD dwShareMode, 
    IN DWORD dwPreferredProtocols, 
    OUT LPSCARDHANDLE phCard, 
    OUT LPDWORD pdwActiveProtocol)
{
    return (I_SCardConnect(
                hContext, 
                (LPCBYTE) szReader, 
                dwShareMode, 
                dwPreferredProtocols, 
                phCard, 
                pdwActiveProtocol,
                FALSE));
}

WINSCARDAPI LONG WINAPI 
SCardConnectW(
    IN SCARDCONTEXT hContext, 
    IN LPCWSTR szReader, 
    IN DWORD dwShareMode, 
    IN DWORD dwPreferredProtocols, 
    OUT LPSCARDHANDLE phCard, 
    OUT LPDWORD pdwActiveProtocol)
{
    return (I_SCardConnect(
                hContext, 
                (LPCBYTE) szReader, 
                dwShareMode, 
                dwPreferredProtocols, 
                phCard, 
                pdwActiveProtocol,
                TRUE));
}


//---------------------------------------------------------------------------------------
//
//  SCardReconnect
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardReconnect(
    IN SCARDHANDLE hCard, 
    IN DWORD dwShareMode, 
    IN DWORD dwPreferredProtocols, 
    IN DWORD dwInitialization, 
    OUT LPDWORD pdwActiveProtocol)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    Reconnect_Call      ReconnectCall;
    Reconnect_Return    ReconnectReturn;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the Reconnect params
    //
    ReconnectCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    ReconnectCall.dwShareMode = dwShareMode;
    ReconnectCall.dwPreferredProtocols = dwPreferredProtocols;
    ReconnectCall.dwInitialization = dwInitialization;
    
    _TRY_(Reconnect_Call_Encode(h, &ReconnectCall))
    
    //
    // Make the Reconnect call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_RECONNECT,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&ReconnectReturn, 0, sizeof(ReconnectReturn));
    _TRY_(Reconnect_Return_Decode(h, &ReconnectReturn))
    
    lReturn =  ReconnectReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        *pdwActiveProtocol = ReconnectReturn.dwActiveProtocol; 
    }

    _TRY_2(Reconnect_Return_Free(h, &ReconnectReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  I_HCardAndDispositionCall
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
I_HCardAndDispositionCall(
    IN SCARDHANDLE hCard, 
    IN DWORD dwDisposition,
    ULONG IoControlCode)
{
    LONG                        lReturn                 = SCARD_S_SUCCESS;
    NTSTATUS                    Status                  = STATUS_SUCCESS;
    RPC_STATUS                  rpcStatus               = RPC_S_OK;
    char                        *pbEncodedBuffer        = NULL;
    unsigned long               cbEncodedBuffer         = 0;
    handle_t                    h                       = 0;
    BUFFER_LIST_STRUCT          *pOutputBuffer          = NULL;
    HCardAndDisposition_Call    HCardAndDispositionCall;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    
    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the Reconnect params
    //
    HCardAndDispositionCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    HCardAndDispositionCall.dwDisposition = dwDisposition;
    
    _TRY_(HCardAndDisposition_Call_Encode(h, &HCardAndDispositionCall))
    
    //
    // Make the Reconnect call to the client
    //
    Status = _SendSCardIOCTL(
                    IoControlCode,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }

    //
    // Decode the return
    //
    lReturn = I_DecodeLongReturn(pOutputBuffer->pbBytes, pOutputBuffer->cbBytesUsed);

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardDisconnect
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardDisconnect(
    IN SCARDHANDLE hCard, 
    IN DWORD dwDisposition)
{
    LONG lReturn = SCARD_S_SUCCESS;

    lReturn = I_HCardAndDispositionCall(
                    hCard, 
                    dwDisposition,
                    SCARD_IOCTL_DISCONNECT);

    MIDL_user_free((REDIR_SCARDHANDLE *) hCard);

    return (lReturn);
}


//---------------------------------------------------------------------------------------
//
//  SCardBeginTransaction
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardBeginTransaction(
    IN SCARDHANDLE hCard)
{
    return (I_HCardAndDispositionCall(
                hCard, 
                0, // SCardBeginTransaction doesn't use a dispostion, so just set to 0
                SCARD_IOCTL_BEGINTRANSACTION));
}


//---------------------------------------------------------------------------------------
//
//  SCardEndTransaction
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardEndTransaction(
    IN SCARDHANDLE hCard, 
    IN DWORD dwDisposition)
{
    return (I_HCardAndDispositionCall(
                hCard, 
                dwDisposition,
                SCARD_IOCTL_ENDTRANSACTION));
}


//---------------------------------------------------------------------------------------
//
//  SCardState
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardState(
    IN SCARDHANDLE hCard, 
    OUT LPDWORD pdwState, 
    OUT LPDWORD pdwProtocol, 
    OUT LPBYTE pbAtr, 
    IN OUT LPDWORD pcbAtrLen)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    State_Call          StateCall;
    State_Return        StateReturn;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the Reconnect params
    //
    StateCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    StateCall.fpbAtrIsNULL = (pbAtr == NULL);
    StateCall.cbAtrLen = *pcbAtrLen;
    
    _TRY_(State_Call_Encode(h, &StateCall))
    
    //
    // Make the Reconnect call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_STATE,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&StateReturn, 0, sizeof(StateReturn));
    _TRY_(State_Return_Decode(h, &StateReturn))
    
    lReturn =  StateReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        *pdwState = StateReturn.dwState;
        *pdwProtocol = StateReturn.dwProtocol;
        
        lReturn = _CopyReturnToCallerBuffer(
                        ((REDIR_LOCAL_SCARDHANDLE *) hCard)->pRedirContext,
                        StateReturn.rgAtr,
                        StateReturn.cbAtrLen,
                        pbAtr,
                        pcbAtrLen,
                        BYTE_TYPE_RETURN);  
    }

    _TRY_2(State_Return_Free(h, &StateReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardStatus
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
I_SCardStatus(
    IN SCARDHANDLE hCard, 
    OUT LPBYTE mszReaderNames, 
    IN OUT LPDWORD pcchReaderLen, 
    OUT LPDWORD pdwState, 
    OUT LPDWORD pdwProtocol, 
    OUT LPBYTE pbAtr, 
    IN OUT LPDWORD pcbAtrLen,
    IN BOOL fUnicode)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    Status_Call         StatusCall;
    Status_Return       StatusReturn;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the Reconnect params
    //
    StatusCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    StatusCall.fmszReaderNamesIsNULL = (mszReaderNames == NULL);
    StatusCall.cchReaderLen = *pcchReaderLen;
    StatusCall.cbAtrLen = *pcbAtrLen;
    
    _TRY_(Status_Call_Encode(h, &StatusCall))
    
    //
    // Make the Status call to the client
    //
    Status = _SendSCardIOCTL(
                    fUnicode ?  SCARD_IOCTL_STATUSW :
                                SCARD_IOCTL_STATUSA,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&StatusReturn, 0, sizeof(StatusReturn));
    _TRY_(Status_Return_Decode(h, &StatusReturn))
    
    lReturn =  StatusReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        lReturn = _CopyReturnToCallerBuffer(
                        ((REDIR_LOCAL_SCARDHANDLE *) hCard)->pRedirContext,
                        StatusReturn.mszReaderNames,
                        StatusReturn.cBytes,
                        mszReaderNames,
                        pcchReaderLen,
                        fUnicode ? WSZ_TYPE_RETURN : SZ_TYPE_RETURN);
        
        if (lReturn == SCARD_S_SUCCESS)
        {
            *pdwState = StatusReturn.dwState;
            *pdwProtocol = StatusReturn.dwProtocol;
            *pcbAtrLen = StatusReturn.cbAtrLen;

            memcpy(
                pbAtr,
                StatusReturn.pbAtr,
                StatusReturn.cbAtrLen);
        }
    }

    _TRY_2(Status_Return_Free(h, &StatusReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}

WINSCARDAPI LONG WINAPI 
SCardStatusA(
    IN SCARDHANDLE hCard, 
    OUT LPSTR mszReaderNames, 
    IN OUT LPDWORD pcchReaderLen, 
    OUT LPDWORD pdwState, 
    OUT LPDWORD pdwProtocol, 
    OUT LPBYTE pbAtr, 
    IN OUT LPDWORD pcbAtrLen)
{
    return (I_SCardStatus(
                hCard, 
                (LPBYTE) mszReaderNames, 
                pcchReaderLen, 
                pdwState, 
                pdwProtocol, 
                pbAtr, 
                pcbAtrLen,
                FALSE));
}

WINSCARDAPI LONG WINAPI 
SCardStatusW(
    IN SCARDHANDLE hCard, 
    OUT LPWSTR mszReaderNames, 
    IN OUT LPDWORD pcchReaderLen, 
    OUT LPDWORD pdwState, 
    OUT LPDWORD pdwProtocol, 
    OUT LPBYTE pbAtr, 
    IN OUT LPDWORD pcbAtrLen)
{
    return (I_SCardStatus(
                hCard, 
                (LPBYTE) mszReaderNames, 
                pcchReaderLen, 
                pdwState, 
                pdwProtocol, 
                pbAtr, 
                pcbAtrLen,
                TRUE));
}


//---------------------------------------------------------------------------------------
//
//  SCardTransmit
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardTransmit(
    IN SCARDHANDLE hCard, 
    IN LPCSCARD_IO_REQUEST pioSendPci, 
    IN LPCBYTE pbSendBuffer, 
    IN DWORD cbSendLength, 
    IN OUT LPSCARD_IO_REQUEST pioRecvPci, 
    OUT LPBYTE pbRecvBuffer, 
    IN OUT LPDWORD pcbRecvLength)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    Transmit_Call       TransmitCall;
    Transmit_Return     TransmitReturn;
    SCardIO_Request     ioRecvPci;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the Transmit params
    //
    TransmitCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    TransmitCall.ioSendPci.dwProtocol = pioSendPci->dwProtocol;
    
    TransmitCall.ioSendPci.cbExtraBytes = pioSendPci->cbPciLength - 
                                            sizeof(SCARD_IO_REQUEST);
    if (TransmitCall.ioSendPci.cbExtraBytes != 0)
    {
        TransmitCall.ioSendPci.pbExtraBytes = ((BYTE *) pioSendPci) + 
                                                sizeof(SCARD_IO_REQUEST);
    }
    else
    {
        TransmitCall.ioSendPci.pbExtraBytes = NULL;
    }
    
    TransmitCall.cbSendLength = cbSendLength;
    TransmitCall.pbSendBuffer = pbSendBuffer;
    
    if (pioRecvPci != NULL)
    {
        TransmitCall.pioRecvPci = &ioRecvPci;
        ioRecvPci.dwProtocol = pioRecvPci->dwProtocol;    
        ioRecvPci.cbExtraBytes = pioRecvPci->cbPciLength - sizeof(SCARD_IO_REQUEST);
        if (ioRecvPci.cbExtraBytes != 0)
        {
            ioRecvPci.pbExtraBytes = ((LPBYTE) pioRecvPci) + sizeof(SCARD_IO_REQUEST);
        }
        else
        {
            ioRecvPci.pbExtraBytes = NULL;  
        }
    }
    else
    {
        TransmitCall.pioRecvPci = NULL;
    }
    
    TransmitCall.fpbRecvBufferIsNULL = (pbRecvBuffer == NULL);
    TransmitCall.cbRecvLength = *pcbRecvLength;
    
    _TRY_(Transmit_Call_Encode(h, &TransmitCall))
    
    //
    // Make the Status call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_TRANSMIT,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&TransmitReturn, 0, sizeof(TransmitReturn));
    _TRY_(Transmit_Return_Decode(h, &TransmitReturn))
    
    lReturn =  TransmitReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        if ((pioRecvPci != NULL) &&
            (TransmitReturn.pioRecvPci != NULL))
        {
            pioRecvPci->dwProtocol = TransmitReturn.pioRecvPci->dwProtocol;
            if (TransmitReturn.pioRecvPci->cbExtraBytes != 0)
            {
                memcpy(
                    ((LPBYTE) pioRecvPci) + sizeof(SCARD_IO_REQUEST),
                    TransmitReturn.pioRecvPci->pbExtraBytes,
                    TransmitReturn.pioRecvPci->cbExtraBytes);
            }
        }

        lReturn = _CopyReturnToCallerBuffer(
                        ((REDIR_LOCAL_SCARDHANDLE *) hCard)->pRedirContext,
                        TransmitReturn.pbRecvBuffer,
                        TransmitReturn.cbRecvLength,
                        pbRecvBuffer,
                        pcbRecvLength,
                        BYTE_TYPE_RETURN);        
    }

    _TRY_2(Transmit_Return_Free(h, &TransmitReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardControl
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardControl(
    IN SCARDHANDLE hCard, 
    IN DWORD dwControlCode,
    IN LPCVOID pvInBuffer, 
    IN DWORD cbInBufferSize, 
    OUT LPVOID pvOutBuffer, 
    IN DWORD cbOutBufferSize, 
    OUT LPDWORD pcbBytesReturned)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    Control_Call        ControlCall;
    Control_Return      ControlReturn;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the Control params
    //
    ControlCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    ControlCall.dwControlCode = dwControlCode;
    ControlCall.cbInBufferSize = cbInBufferSize;
    ControlCall.pvInBuffer = (LPCBYTE) pvInBuffer;
    ControlCall.fpvOutBufferIsNULL = (pvOutBuffer == NULL);
    ControlCall.cbOutBufferSize = cbOutBufferSize;
    
    _TRY_(Control_Call_Encode(h, &ControlCall))
    
    //
    // Make the Control call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_CONTROL,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&ControlReturn, 0, sizeof(ControlReturn));
    _TRY_(Control_Return_Decode(h, &ControlReturn))
    
    lReturn =  ControlReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        *pcbBytesReturned = ControlReturn.cbOutBufferSize; 
        lReturn = _CopyReturnToCallerBuffer(
                        ((REDIR_LOCAL_SCARDHANDLE *) hCard)->pRedirContext,
                        ControlReturn.pvOutBuffer,
                        ControlReturn.cbOutBufferSize,
                        (LPBYTE) pvOutBuffer,
                        pcbBytesReturned,
                        BYTE_TYPE_RETURN);        
    }

    _TRY_2(Control_Return_Free(h, &ControlReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardGetAttrib
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardGetAttrib(
    IN SCARDHANDLE hCard, 
    IN DWORD dwAttrId, 
    OUT LPBYTE pbAttr, 
    IN OUT LPDWORD pcbAttrLen)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    GetAttrib_Call      GetAttribCall;
    GetAttrib_Return    GetAttribReturn;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }

    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the GetAttrib params
    //
    GetAttribCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    GetAttribCall.dwAttrId = dwAttrId;;
    GetAttribCall.fpbAttrIsNULL = (pbAttr == NULL);
    GetAttribCall.cbAttrLen = *pcbAttrLen;
    
    _TRY_(GetAttrib_Call_Encode(h, &GetAttribCall))
    
    //
    // Make the GetAttrib call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_GETATTRIB,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    SafeMesHandleFree(&h);

    //
    // Decode the return
    //
    rpcStatus = MesDecodeBufferHandleCreate(
                        (char *) pOutputBuffer->pbBytes, 
                        pOutputBuffer->cbBytesUsed, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    memset(&GetAttribReturn, 0, sizeof(GetAttribReturn));
    _TRY_(GetAttrib_Return_Decode(h, &GetAttribReturn))
    
    lReturn =  GetAttribReturn.ReturnCode;

    if (lReturn == SCARD_S_SUCCESS)
    {
        lReturn = _CopyReturnToCallerBuffer(
                        ((REDIR_LOCAL_SCARDHANDLE *) hCard)->pRedirContext,
                        GetAttribReturn.pbAttr,
                        GetAttribReturn.cbAttrLen,
                        (LPBYTE) pbAttr,
                        pcbAttrLen,
                        BYTE_TYPE_RETURN);        
    }

    _TRY_2(GetAttrib_Return_Free(h, &GetAttribReturn))

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardSetAttrib
//
//---------------------------------------------------------------------------------------
WINSCARDAPI LONG WINAPI 
SCardSetAttrib(
    IN SCARDHANDLE hCard, 
    IN DWORD dwAttrId, 
    IN LPCBYTE pbAttr, 
    IN DWORD cbAttrLen)
{
    LONG                lReturn             = SCARD_S_SUCCESS;
    NTSTATUS            Status              = STATUS_SUCCESS;
    RPC_STATUS          rpcStatus           = RPC_S_OK;
    char                *pbEncodedBuffer    = NULL;
    unsigned long       cbEncodedBuffer     = 0;
    handle_t            h                   = 0;
    BUFFER_LIST_STRUCT  *pOutputBuffer      = NULL;
    SetAttrib_Call      SetAttribCall;

    if (hCard == NULL)
    {
        return (SCARD_E_INVALID_PARAMETER);
    }
    
    //
    // Initialize encoding handle
    //
    rpcStatus = MesEncodeDynBufferHandleCreate(
                        &pbEncodedBuffer, 
                        &cbEncodedBuffer, 
                        &h);
    if (rpcStatus != RPC_S_OK)
    {
        ERROR_RETURN(SCARD_E_UNEXPECTED)
    }

    //
    // Encode the SetAttrib params
    //
    SetAttribCall.hCard = ((REDIR_LOCAL_SCARDHANDLE *) hCard)->Handle;
    SetAttribCall.dwAttrId = dwAttrId;;
    SetAttribCall.pbAttr = pbAttr;
    SetAttribCall.cbAttrLen = cbAttrLen;
    
    _TRY_(SetAttrib_Call_Encode(h, &SetAttribCall))
    
    //
    // Make the SetAttrib call to the client
    //
    Status = _SendSCardIOCTL(
                    SCARD_IOCTL_SETATTRIB,
                    pbEncodedBuffer,
                    cbEncodedBuffer,
                    &pOutputBuffer);
    if (Status != STATUS_SUCCESS)
    {
        ERROR_RETURN(_MakeSCardError(Status))
    }
    
    //
    // Decode the return
    //
    lReturn = I_DecodeLongReturn(pOutputBuffer->pbBytes, pOutputBuffer->cbBytesUsed);

Return:

    SafeMesHandleFree(&h);

    MIDL_user_free(pbEncodedBuffer);

    FreeBuffer(pOutputBuffer);

    return (lReturn);

ErrorReturn:

    goto Return;
}


//---------------------------------------------------------------------------------------
//
//  SCardAccessStartedEvent
//
//---------------------------------------------------------------------------------------
WINSCARDAPI HANDLE WINAPI 
SCardAccessStartedEvent(void)
{
    HANDLE h;

    h = _GetStartedEventHandle();

    if ((h == NULL) || !_SetStartedEventToCorrectState())
    {
        //
        // Either we couldn't create the event, or we couldn't start the thread to set
        // the event, so return NULL
        //
        return (NULL);
    }

    //
    // Check to see if the event is already set, if not, give the thread which sets 
    // the event a chance to run and set the event before returning
    //
    if (WAIT_OBJECT_0 != WaitForSingleObject(h, 0))
    {
        WaitForSingleObject(h, 10);
    }
    
    //
    // This API has old semantics where it just return the handle straight away
    // instead of duplicating it.
    //
    return (h);
}


//---------------------------------------------------------------------------------------
//
//  SCardReleaseStartedEvent
//
//---------------------------------------------------------------------------------------
WINSCARDAPI void WINAPI 
SCardReleaseStartedEvent(void)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\server\control.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Control

Abstract:

    This module provides the common control operations of the Calais Service
    Manager.

Author:

    Doug Barlow (dbarlow) 10/23/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#undef __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "CalServe.h"

class WORKER_THREAD
{
public:
    WORKER_THREAD(void) : hThread(DBGT("Worker Thread handle")) {};
    CHandleObject hThread;
    DWORD dwThreadId;
};

CCriticalSectionObject *g_pcsControlLocks[CSLOCK_MAXLOCKS];
const DWORD g_dwControlLockDesc[]
    = {
        CSID_CONTROL_LOCK,      // Lock for Calais control commands.
        CSID_SERVER_THREADS,    // Lock for server thread enumeration.
        CSID_TRACEOUTPUT        // Lock for tracing output.
      };
#if (CSLOCK_MAXLOCKS > 3)   // Make sure global locks get named!
#error "You're missing some global lock names"
#endif

static BOOL
    l_fActive = FALSE,
    l_fStarted = FALSE;
static CDynamicArray<CReader> l_rgReaders;
static CDynamicArray<WORKER_THREAD> l_rgWorkerThreads;
HANDLE g_hCalaisShutdown = NULL;
CMultiEvent *g_phReaderChangeEvent;


static CReader *LocateReader(LPCTSTR szReader);
static CReader *LocateReader(HANDLE hReader);


/*++

CalaisStart:

    This is the main entry routine into Calais.  It starts all the other threads
    needed in Calais, initializes control values, etc., then returns.

Arguments:

    None

Return Value:

    A DWORD success code, indicating success or the error code.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisStart")

DWORD
CalaisStart(
    void)
{
    DWORD dwExitCode = SCARD_S_SUCCESS;
    DWORD dwReaderCount = 0;

    if (!l_fStarted)
    {
        DWORD dwIndex;

        for (dwIndex = 0; dwIndex < CSLOCK_MAXLOCKS; dwIndex += 1)
        {
            g_pcsControlLocks[dwIndex]
                = new CCriticalSectionObject(g_dwControlLockDesc[dwIndex]);
            if (NULL == g_pcsControlLocks[dwIndex])
                return (DWORD)SCARD_E_NO_MEMORY;
            if (g_pcsControlLocks[dwIndex]->InitFailed())
            {
                delete g_pcsControlLocks[dwIndex];
                g_pcsControlLocks[dwIndex] = NULL;
                do
                {
                    dwIndex--;
                    delete g_pcsControlLocks[dwIndex];
                    g_pcsControlLocks[dwIndex] = NULL;
                }
                while (0 != dwIndex);

                return (DWORD)SCARD_E_NO_MEMORY;
            }
        }

        try
        {
            LockSection(
                g_pcsControlLocks[CSLOCK_CALAISCONTROL],
                DBGT("Initializing Calais"));
            l_fStarted = TRUE;
            g_phReaderChangeEvent = new CMultiEvent;
            if (NULL == g_phReaderChangeEvent)
            {
                CalaisError(__SUBROUTINE__, 206);
                return (DWORD)SCARD_E_NO_MEMORY;
            }
            if (g_phReaderChangeEvent->InitFailed())
            {
                CalaisError(__SUBROUTINE__, 207);
                delete g_phReaderChangeEvent;
                g_phReaderChangeEvent = NULL;
                return (DWORD)SCARD_E_NO_MEMORY;
            }
            g_hCalaisShutdown = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (NULL == g_hCalaisShutdown)
            {
                DWORD dwError = GetLastError();
                CalaisError(__SUBROUTINE__, 204, dwError);
                throw dwError;
            }


            //
            // Make sure the system registries exist.
            //

            try
            {
                CRegistry regCalais(
                    HKEY_LOCAL_MACHINE,
                    CalaisString(CALSTR_CALAISREGISTRYKEY),
                    KEY_READ,
                    REG_OPTION_EXISTS,
                    NULL);

                regCalais.Status(); // Will throw if key was not found

                try
                {
                    g_dwDefaultIOMax = regCalais.GetNumericValue(
                                            CalaisString(CALSTR_MAXDEFAULTBUFFER));
                }
                catch (DWORD) {}
            }
            catch (DWORD dwErr)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to verify Calais registry entries: %1"),
                    dwErr);
                throw;
            }


            //
            // Kick off the various reader classes.
            //

            l_fActive = TRUE;
            dwReaderCount += AddAllPnPDrivers();

            //
            // Initialize communications.
            //

            DispatchInit();
        }

        catch (DWORD dwError)
        {
            dwExitCode = dwError;
            CalaisError(__SUBROUTINE__, 201, dwExitCode);
            if (NULL != g_hCalaisShutdown)
            {
                if (!CloseHandle(g_hCalaisShutdown))
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Failed to close Calais Shutdown Event: %1"),
                        GetLastError());
                g_hCalaisShutdown = NULL;
            }
        }

        catch (...)
        {
            dwExitCode = SCARD_F_UNKNOWN_ERROR;
            CalaisError(__SUBROUTINE__, 202);
            if (NULL != g_hCalaisShutdown)
            {
                if (!CloseHandle(g_hCalaisShutdown))
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Failed to close Calais Shutdown Event: %1"),
                        GetLastError());
                g_hCalaisShutdown = NULL;
            }
        }
    }

    return dwExitCode;
}


/*++

CalaisReaderCount:

    This routine gets the number of possible known readers, with locking.

Arguments:

    None

Return Value:

    The number of available slots in the Known Reader array.  Some of the slots
    may have NULL values.

Author:

    Doug Barlow (dbarlow) 6/11/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisReaderCount")

DWORD
CalaisReaderCount(
    void)
{
    ASSERT(l_fStarted);
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Counting the readers"));
    return l_rgReaders.Count();
}


/*++

CalaisCountReaders:

    This routine takes a more proactive approach to counting readers.  It goes
    through the array and deducts any non-functional readers from the total.

Arguments:

    None

Return Value:

    The number of truely active readers.

Author:

    Doug Barlow (dbarlow) 1/11/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisCountReaders")

DWORD
CalaisCountReaders(
    void)
{
    ASSERT(l_fStarted);
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Authoritative reader count"));
    DWORD dwIndex, dwReaders = l_rgReaders.Count();
    CReader *pRdr;

    for (dwIndex = dwReaders; 0 < dwIndex;)
    {
        dwIndex -= 1;
        pRdr = l_rgReaders[dwIndex];
        if (NULL == pRdr)
            dwReaders -= 1;
        else if (CReader::Closing <= pRdr->AvailabilityStatus())
            dwReaders -= 1;
    }

    return dwReaders;
}


/*++

CalaisLockReader:

    This routine returns the value in the known reader list at the given
    location, with locking, so that the reader object won't go away until
    released.

Arguments:

    szReader supplies the name of the reader to search for.

Return Value:

    A Reader reference object for the entry at that index.

Author:

    Doug Barlow (dbarlow) 6/11/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisLockReader")

CReaderReference *
CalaisLockReader(
    LPCTSTR szReader)
{
    ASSERT(l_fStarted);
    CReader * pReader = NULL;
    CReaderReference *pRdrRef = NULL;
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Marking Reader as in use."));

    pReader = LocateReader(szReader);
    if (NULL == pReader)
        throw (DWORD)SCARD_E_UNKNOWN_READER;
    pRdrRef = new CReaderReference(pReader);
    if (NULL == pRdrRef)
    {
        CalaisError(__SUBROUTINE__, 203);
        throw (DWORD)SCARD_E_NO_MEMORY;
    }
    return pRdrRef;
}


/*++

CalaisReleaseReader:

    This routine releases a reader obtained via CalaisLockReader.

Arguments:

    ppRdrRef supplies the address of the pointer to a reader reference.
    It is automatically set to NULL when it is freed.

Return Value:

    None

Throws:

    Errors are thrown as DWORDs

Author:

    Doug Barlow (dbarlow) 6/11/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisReleaseReader")

void
CalaisReleaseReader(
    CReaderReference **ppRdrRef)
{
    ASSERT(l_fStarted);
    ASSERT(NULL != ppRdrRef);
    if (NULL != *ppRdrRef)
    {
        ASSERT(!(*ppRdrRef)->Reader()->IsLatchedByMe());
        delete *ppRdrRef;
        *ppRdrRef = NULL;
    }
}


/*++

CalaisAddReader:

    This routine adds a reader into the active device list.

Arguments:

    pRdr supplies a CReader object to be added.

    szReader supplies the name of the reader to be added.

    dwFlags supplies requested flags for this reader.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 4/29/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisAddReader")

DWORD
CalaisAddReader(
    LPCTSTR szReader,
    DWORD dwFlags)
{
    DWORD dwIndex;
    DWORD dwReturn = ERROR_SUCCESS;
    CReader * pReader = NULL;
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Adding a new reader to the list"));

    for (dwIndex = l_rgReaders.Count(); 0 < dwIndex;)
    {
        dwIndex -= 1;
        pReader = l_rgReaders[dwIndex];
        if (NULL != pReader)
        {
            if (0 == lstrcmpi(szReader, pReader->DeviceName()))
            {
                dwReturn = SCARD_E_DUPLICATE_READER;
                break;
            }
        }
    }

    if (ERROR_SUCCESS == dwReturn)
        dwReturn = AddReaderDriver(szReader, dwFlags);
    return dwReturn;
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisAddReader")

DWORD
CalaisAddReader(
    CReader *pRdr)
{
    DWORD dwExitCode = SCARD_S_SUCCESS;
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Adding a reader to the list."));

    try
    {
        if (!l_fActive)
            throw (DWORD)SCARD_E_SYSTEM_CANCELLED;
        DWORD dwIndex;
        LPCTSTR szReader = pRdr->ReaderName();


        //
        // Make sure this is a unique device name.
        //

        if (NULL != LocateReader(szReader))
        {
            CalaisError(__SUBROUTINE__, 205, szReader);
            throw (DWORD)SCARD_E_DUPLICATE_READER;
        }


        //
        // Make sure the reader has a name in the system.
        //

        CBuffer bfTmp;

        ListReaderNames(SCARD_SCOPE_SYSTEM, szReader, bfTmp);
        if (NULL == FirstString(bfTmp))
            IntroduceReader(
                SCARD_SCOPE_SYSTEM,
                szReader,
                szReader);


        //
        // Add it to the list.
        //

        dwIndex = 0;
        while (NULL != l_rgReaders[dwIndex])
            dwIndex += 1;
        l_rgReaders.Set(dwIndex, pRdr);
        PulseEvent(AccessNewReaderEvent());
    }

    catch (DWORD dwError)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Server Control received error attempting to create reader object: %1"),
            dwError);
        dwExitCode = dwError;
    }

    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Server Control received exception attempting to create reader object"));
        dwExitCode = SCARD_E_INVALID_PARAMETER;
    }

    return dwExitCode;
}


/*++

CalaisQueryReader:

    This routine queries a device to see if it can be removed from the active
    device list.

Arguments:

    hReader supplies the handle by which the reader can be identified.

Return Value:

    TRUE - The device can be deactived.
    FALSE - The device should not be deactivated.

Author:

    Doug Barlow (dbarlow) 4/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisQueryReader")

BOOL
CalaisQueryReader(
    HANDLE hReader)
{
    BOOL fReturn = FALSE;
    CReader * pReader = NULL;
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Checking reader usage"));

    pReader = LocateReader(hReader);
    if (NULL != pReader)
        fReturn = !pReader->IsInUse();
    else
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("CalaisQueryReader was asked for nonexistent reader"));
        fReturn = FALSE;
    }
    return fReturn;
}


/*++

CalaisDisableReader:

    This routine moves a reader to an inactive state pending removal.

Arguments:

    hDriver supplies the handle by which the reader can be identified.

Return Value:

    The name of the reader being disabled.

Author:

    Doug Barlow (dbarlow) 4/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisDisableReader")

LPCTSTR
CalaisDisableReader(
    HANDLE hDriver)
{
    LPCTSTR szReturn = NULL;
    CReader * pReader = NULL;
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Disabing the reader"));

    pReader = LocateReader(hDriver);
    if (NULL != pReader)
    {
        pReader->Disable();
        szReturn = pReader->DeviceName();
    }
    return szReturn;
}


/*++

CalaisConfirmClosingReader:

    This routine ensures a reader is marked Closing, then moves a reader to
    an inactive state pending removal.

Arguments:

    hDriver supplies the handle by which the reader can be identified.

Return Value:

    The name of the reader being disabled.

Author:

    Doug Barlow (dbarlow) 4/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisConfirmClosingReader")

LPCTSTR
CalaisConfirmClosingReader(
    HANDLE hDriver)
{
    LPCTSTR szReturn = NULL;
    CReader * pReader = NULL;
    LockSection(
        g_pcsControlLocks[CSLOCK_CALAISCONTROL],
        DBGT("Confirm closing the reader"));

    pReader = LocateReader(hDriver);
    if (NULL != pReader)
    {
        if (CReader::Closing <= pReader->AvailabilityStatus())
        {
            pReader->Disable();
            szReturn = pReader->DeviceName();
        }
    }
    return szReturn;
}


/*++

CalaisRemoveReader:

    This routine removes a reader from the active device list.

Arguments:

    szReader supplies the internal name of the reader to be removed.

    dwIndex supplies the global reader array index to be removed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 4/29/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisRemoveReader")

DWORD
CalaisRemoveReader(
    LPCTSTR szReader)
{
    DWORD dwExitCode = SCARD_S_SUCCESS;

    try
    {
        CReader *pRdr = NULL;
        DWORD dwIndex;


        //
        // Look for it in the reader list, and remove it.
        //

        {
            LockSection(
                g_pcsControlLocks[CSLOCK_CALAISCONTROL],
                DBGT("Removing reader from list"));

            for (dwIndex = l_rgReaders.Count(); dwIndex > 0;)
            {
                pRdr = l_rgReaders[--dwIndex];
                if (NULL == pRdr)
                    continue;
                if (0 == lstrcmpi(szReader, pRdr->ReaderName()))
                    break;
                pRdr = NULL;
            }
        }
        if (NULL == pRdr)
            throw (DWORD)SCARD_E_UNKNOWN_READER;
        CalaisRemoveReader(dwIndex);
    }

    catch (DWORD dwErr)
    {
        dwExitCode = dwErr;
    }
    catch (...)
    {
        dwExitCode = SCARD_E_INVALID_PARAMETER;
    }
    return dwExitCode;
}

DWORD
CalaisRemoveReader(
    LPVOID hAppCtrl)
{
    DWORD dwExitCode = SCARD_S_SUCCESS;

    try
    {
        CReader *pRdr = NULL;
        DWORD dwIndex;


        //
        // Look for it in the reader list, and remove it.
        //

        {
            LockSection(
                g_pcsControlLocks[CSLOCK_CALAISCONTROL],
                DBGT("Removing reader from list"));
            for (dwIndex = l_rgReaders.Count(); dwIndex > 0;)
            {
                pRdr = l_rgReaders[--dwIndex];
                if (NULL == pRdr)
                    continue;
                if (hAppCtrl == pRdr->ReaderHandle())
                    break;
                pRdr = NULL;
            }
        }
        if (NULL == pRdr)
            throw (DWORD)SCARD_E_UNKNOWN_READER;
        CalaisRemoveReader(dwIndex);
    }

    catch (DWORD dwErr)
    {
        dwExitCode = dwErr;
    }
    catch (...)
    {
        dwExitCode = SCARD_E_INVALID_PARAMETER;
    }
    return dwExitCode;
}

DWORD
CalaisRemoveReader(
    DWORD dwIndex)
{
    DWORD dwExitCode = SCARD_S_SUCCESS;
    WORKER_THREAD *pWrkThread = NULL;

    try
    {
        CReader *pRdr;

        //
        // Lock the global reader array and remove the entry, so no other
        // threads can access it.
        //

        {
            LockSection(
                g_pcsControlLocks[CSLOCK_CALAISCONTROL],
                DBGT("Removing Reader from list"));
            if (l_rgReaders.Count() <= dwIndex)
                throw (DWORD)SCARD_E_UNKNOWN_READER;
            pRdr = l_rgReaders[dwIndex];
            l_rgReaders.Set(dwIndex, NULL);
            g_phReaderChangeEvent->Signal();
        }


        //
        // Disable the device, and wait for all outstanding references to clear.
        // Then delete it.
        //

        if (NULL != pRdr)
        {
            pWrkThread = new WORKER_THREAD;
            if (NULL == pWrkThread)
                throw (DWORD)SCARD_E_NO_MEMORY;

            pWrkThread->hThread = CreateThread(
                                        NULL,               // Not inheritable
                                        CALAIS_STACKSIZE,   // Default stack size
                                        CalaisTerminateReader,
                                        pRdr,
                                        CREATE_SUSPENDED,
                                        &pWrkThread->dwThreadId);
            if (!pWrkThread->hThread.IsValid())
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to start background terminator: %1"),
                    pWrkThread->hThread.GetLastError());
                delete pWrkThread;
                pWrkThread = NULL;
            }

            {
                LockSection(
                    g_pcsControlLocks[CSLOCK_CALAISCONTROL],
                    DBGT("Deleting the reader"));
                for (dwIndex = 0; NULL != l_rgWorkerThreads[dwIndex]; dwIndex += 1);
                // Null Loop body
                l_rgWorkerThreads.Set(dwIndex, pWrkThread);
                ResumeThread(pWrkThread->hThread);
                pWrkThread = NULL;
            }
        }
    }

    catch (DWORD dwErr)
    {
        dwExitCode = dwErr;
        if (NULL != pWrkThread)
            delete pWrkThread;
    }
    catch (...)
    {
        dwExitCode = SCARD_E_INVALID_PARAMETER;
        if (NULL != pWrkThread)
            delete pWrkThread;
    }
    return dwExitCode;
}


/*++

CalaisRemoveDevice:

    This routine removes a reader from the active device list, identified by
    it's low level name.

Arguments:

    szDevice supplies the internal name of the reader to be removed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 4/15/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisRemoveDevice")

DWORD
CalaisRemoveDevice(
    LPCTSTR szDevice)
{
    DWORD dwExitCode = SCARD_S_SUCCESS;

    try
    {
        CReader *pRdr = NULL;
        DWORD dwIndex;


        //
        // Look for it in the reader list, and remove it.
        //

        {
            LockSection(
                g_pcsControlLocks[CSLOCK_CALAISCONTROL],
                DBGT("Remove the device"));
            for (dwIndex = l_rgReaders.Count(); dwIndex > 0;)
            {
                pRdr = l_rgReaders[--dwIndex];
                if (NULL == pRdr)
                    continue;
                if (0 == lstrcmpi(szDevice, pRdr->DeviceName()))
                    break;
                pRdr = NULL;
            }
        }
        if (NULL == pRdr)
            throw (DWORD)SCARD_E_UNKNOWN_READER;
        CalaisRemoveReader(dwIndex);
    }

    catch (DWORD dwErr)
    {
        dwExitCode = dwErr;
    }
    catch (...)
    {
        dwExitCode = SCARD_E_INVALID_PARAMETER;
    }
    return dwExitCode;
}


/*++

CalaisStop:

    This routine is called when it is time for the Calais subsystem to close
    down.  It cleanly terminates the threads and shuts down the interface, and
    returns when it is completed.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 11/25/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisStop")

void
CalaisStop(
    void)
{
    DWORD dwIndex, dwSts, dwCount;
    BOOL fSts;


    //
    // Mark all the readers as Closing.
    //

    ASSERT(l_fActive);
    ASSERT(l_fStarted);
    fSts = SetEvent(g_hCalaisShutdown);
    ASSERT(fSts);
    Sleep(2000);    // Let the event have it's effect.
    {
        LockSection(
            g_pcsControlLocks[CSLOCK_CALAISCONTROL],
            DBGT("Close down all the readers"));
        l_fActive = FALSE;
        dwCount = l_rgReaders.Count();
        for (dwIndex = dwCount; dwIndex > 0;)
        {
            CReader *pRdr;
            pRdr = l_rgReaders[--dwIndex];
            if (NULL != pRdr)
            {
                pRdr->InvalidateGrabs();
                if (CReader::Closing > pRdr->AvailabilityStatus())
                    pRdr->SetAvailabilityStatusLocked(CReader::Closing);
            }
        }
    }


    //
    // Terminate Service processing.
    //

    DispatchTerm();


    //
    // Disable all the readers.
    //

    for (dwIndex = dwCount; dwIndex > 0;)
    {
        dwSts = CalaisRemoveReader(--dwIndex);
        if (SCARD_S_SUCCESS != dwSts)
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Calais Stop failed to remove reader"));
    }


    //
    // Wait for those readers to be closed.
    //

    {
        LockSection(
            g_pcsControlLocks[CSLOCK_CALAISCONTROL],
            DBGT("Get the length of the reader list"));
        dwCount = l_rgWorkerThreads.Count();
    }
    for (dwIndex = dwCount; 0 < dwIndex;)
    {
        HANDLE hThread;
        DWORD dwThreadId;
        WORKER_THREAD *pWrkThread = NULL;

        {
            LockSection(
                g_pcsControlLocks[CSLOCK_CALAISCONTROL],
                DBGT("Get the worker thread"));
            pWrkThread = l_rgWorkerThreads[--dwIndex];
            if (NULL == pWrkThread)
                continue;
            hThread = pWrkThread->hThread.Value();
            dwThreadId = pWrkThread->dwThreadId;

        }

        WaitForever(
            hThread,
            REASONABLE_TIME,
            DBGT("Waiting for reader termination, thread %2"),
            dwThreadId);
    }


    //
    // All done.  Close out any remaining handles and return.
    //

    l_fStarted = FALSE;
    if (!CloseHandle(g_hCalaisShutdown))
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Failed to close Calais Shutdown Event: %1"),
            GetLastError());
    ReleaseAllEvents();
    if (NULL != g_phReaderChangeEvent)
    {
        delete g_phReaderChangeEvent;
        g_phReaderChangeEvent = NULL;
    }

    for (dwIndex = 0; dwIndex < CSLOCK_MAXLOCKS; dwIndex += 1)
    {
        delete g_pcsControlLocks[dwIndex];
        g_pcsControlLocks[dwIndex] = NULL;
    }
}


/*++

LocateReader:

    This function locates a reader in the global reader array by name.
    It assumes the reader array has already been locked.

Arguments:

    szReader supplies the name of the reader to search for.

Return Value:

    The pointer to the reader, or NULL if none is found.

Author:

    Doug Barlow (dbarlow) 6/17/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("LocateReader")

static CReader *
LocateReader(
    LPCTSTR szReader)
{
    DWORD dwIndex;
    CReader * pReader = NULL;

    for (dwIndex = l_rgReaders.Count(); 0 < dwIndex;)
    {
        dwIndex -= 1;
        pReader = l_rgReaders[dwIndex];
        if (NULL != pReader)
        {
            if (0 == lstrcmpi(szReader, pReader->ReaderName()))
                return pReader;
        }
    }
    return NULL;
}

static CReader *
LocateReader(
    HANDLE hReader)
{
    DWORD dwIndex;
    CReader * pReader = NULL;

    for (dwIndex = l_rgReaders.Count(); 0 < dwIndex;)
    {
        dwIndex -= 1;
        pReader = l_rgReaders[dwIndex];
        if (NULL != pReader)
        {
            if (hReader == pReader->ReaderHandle())
                return pReader;
        }
    }
    return NULL;
}


/*++

CalaisTerminateReader:

    This routine removes a reader.  It is designed so that it has the option
    of being called as a background thread.

Arguments:

    pvParam is actually the DWORD index to be removed.

Return Value:

    A DWORD success code, indicating success or the error code.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 4/8/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CalaisTerminateReader")

DWORD WINAPI
CalaisTerminateReader(
    LPVOID pvParam)
{
    NEW_THREAD;
    WORKER_THREAD *pWrkThread = NULL;
    DWORD dwReturn = 0;
    CReader *pRdr = (CReader *)pvParam;

    try
    {

        //
        // Make sure all outstanding references are invalidated.
        //

        {
            CTakeReader myReader(pRdr);
            CLockWrite rwLock(&pRdr->m_rwLock);
            pRdr->m_ActiveState.dwRemoveCount += 1;
            pRdr->SetAvailabilityStatus(CReader::Inactive);
        }
        {
            CLockWrite rwActive(&pRdr->m_rwActive);
        }
        delete pRdr;
    }
    catch (DWORD dwErr)
    {
        dwReturn = dwErr;
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Failed to Terminate a reader object: %1"),
            dwErr);
    }
    catch (...)
    {
        dwReturn = SCARD_E_INVALID_PARAMETER;
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Exception during attempt to Terminate a reader object."));
    }


    {
        LockSection(
            g_pcsControlLocks[CSLOCK_CALAISCONTROL],
            DBGT("Remove this thread from the worker list"));
        for (DWORD dwIndex = l_rgWorkerThreads.Count();
             0 < dwIndex;)
        {
            pWrkThread = l_rgWorkerThreads[--dwIndex];
            if (NULL != pWrkThread)
            {
                if (GetCurrentThreadId() == pWrkThread->dwThreadId)
                {
                    l_rgWorkerThreads.Set(dwIndex, NULL);
                    break;
                }
                else
                    pWrkThread = NULL;
            }
        }
    }

    ASSERT(NULL != pWrkThread); // How did we get started?
    if (NULL != pWrkThread)
    {
        if (pWrkThread->hThread.IsValid())
            pWrkThread->hThread.Close();
        delete pWrkThread;
    }
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\changpin\chpin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       chPin.cpp
//
//--------------------------------------------------------------------------

// chPin.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "chPin.h"
#include "chPinDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChangePinApp

BEGIN_MESSAGE_MAP(CChangePinApp, CWinApp)
    //{{AFX_MSG_MAP(CChangePinApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChangePinApp construction

CChangePinApp::CChangePinApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CChangePinApp object

CChangePinApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CChangePinApp initialization

BOOL CChangePinApp::InitInstance()
{
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    CChangePinDlg dlg;
    m_pMainWnd = &dlg;
    int nResponse = dlg.DoModal();
    if (nResponse == IDOK)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with OK
    }
    else if (nResponse == IDCANCEL)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with Cancel
    }

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\server\dispatch.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    dispatch

Abstract:

    This module implements the Calais Server communication and dispatch
    services.

Author:

    Doug Barlow (dbarlow) 12/3/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <scarderr.h>   // This picks up extra definitions
#include "CalServe.h"
#ifdef DBG
#include <stdio.h>
#include <tchar.h>
#endif

#define DEFAULT_OUT_BUFFER_SPACE 264

// Convert between an interchange handle and an index.
#define H2L(x) ((DWORD)(x))
#define L2H(x) ((INTERCHANGEHANDLE)(x))

DWORD g_dwDefaultIOMax = DEFAULT_OUT_BUFFER_SPACE;
static CComResponder *l_pcomResponder = NULL;
static HANDLE l_hDispatchThread = NULL;
static DWORD l_dwDispatchThreadId = 0;
static CDynamicArray<CServiceThread> l_rgServers;


//
////////////////////////////////////////////////////////////////////////////////
//
//  Dispach service routines.
//

/*++

DispatchInit:

    This routine establishes communications and kicks off the dispatcher thread.

Arguments:

    None

Return Value:

    TRUE - Success
    FALSE - Error starting

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/3/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("DispatchInit")

BOOL
DispatchInit(
    void)
{
    BOOL fReturn = FALSE;
    DWORD dwLastErr;

    try
    {
        l_pcomResponder = new CComResponder;
        if (NULL == l_pcomResponder)
        {
            CalaisError(__SUBROUTINE__, 301);
            throw (DWORD)SCARD_E_NO_MEMORY;
        }

        l_pcomResponder->Create(CalaisString(CALSTR_COMMPIPENAME));
        l_hDispatchThread = CreateThread(
                        NULL,   // Not inheritable
                        CALAIS_STACKSIZE,   // Default stack size
                        (LPTHREAD_START_ROUTINE)DispatchMonitor,
                        l_pcomResponder,
                        0,      // Run immediately
                        &l_dwDispatchThreadId);
        if (NULL == l_hDispatchThread)
        {
            dwLastErr = GetLastError();
            CalaisError(__SUBROUTINE__, 302, dwLastErr);
            throw dwLastErr;
        }

        fReturn = TRUE;
    }

    catch (...)
    {
        if (NULL != l_pcomResponder)
        {
            delete l_pcomResponder;
            l_pcomResponder = NULL;
        }
        throw;
    }

    return fReturn;
}


/*++

DispatchTerm:

    This routine stops the dispatcher.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/2/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("DispatchTerm")

void
DispatchTerm(
    void)
{
    DWORD dwSts, ix, dwCount;
    CServiceThread *pSvr;
    BOOL fRemaining = TRUE;
    HANDLE hThread; // Temporary handle holder


    //
    // Terminate all the service threads.
    //

    {
        LockSection(
            g_pcsControlLocks[CSLOCK_SERVERLOCK],
            DBGT("Get the count of service threads"));
        dwCount = l_rgServers.Count();
    }
    while (fRemaining)
    {
        fRemaining = FALSE;
        for (ix = dwCount; 0 < ix;)
        {
            {
                LockSection(
                    g_pcsControlLocks[CSLOCK_SERVERLOCK],
                    DBGT("Get the active thread"));
                pSvr = l_rgServers[--ix];
                if (NULL != pSvr)
                {
                    l_rgServers.Set(ix, NULL);
                    hThread = pSvr->m_hThread;
                }
            }
            if (NULL != pSvr)
            {
                if (NULL != hThread)
                {
                    dwSts = WaitForAnObject(hThread, CALAIS_THREAD_TIMEOUT);
                    if (ERROR_SUCCESS != dwSts)
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Leaking a Service Thread: %1"),
                            dwSts);
                }
                fRemaining = TRUE;
            }
        }
    }


    //
    // Terminate the main responder.
    //

    if (NULL != l_hDispatchThread)
    {
        dwSts = WaitForAnObject(l_hDispatchThread, CALAIS_THREAD_TIMEOUT);
        if (ERROR_SUCCESS != dwSts)
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Leaking the Dispatch Thread: %1"),
                dwSts);
        if (!CloseHandle(l_hDispatchThread))
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to close Dispatch Thread Handle: %1"),
                GetLastError());
        l_hDispatchThread = NULL;
    }
    if (NULL != l_pcomResponder)
    {
        delete l_pcomResponder;
        l_pcomResponder = NULL;
    }
}


/*++

DispatchMonitor:

    This is the main code for monitoring incoming communication connection
    requests.

Arguments:

    pvParam supplies the parameter from the CreateThread call.  In this case,
        it's the address of the CComResponder object to monitor.

Return Value:

    Zero

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/24/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("DispatchMonitor")

DWORD WINAPI
DispatchMonitor(
    LPVOID pvParameter)
{
    NEW_THREAD;
    BOOL fDone = FALSE;
    CComResponder *pcomResponder = (CComResponder *)pvParameter;
    CComChannel *pcomChannel = NULL;
    CServiceThread *pService = NULL;
    DWORD dwIndex = 0;

    do
    {

        //
        // Look for an incoming connection.
        //

        try
        {
            pcomChannel = pcomResponder->Listen();
        }
        catch (DWORD dwError)
        {
            if (SCARD_P_SHUTDOWN == dwError)
                fDone = TRUE;   // Stop service request.
            else
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Error listening for an incoming connect request: %1"),
                    dwError);
            continue;
        }
        catch (...)
        {
            CalaisError(__SUBROUTINE__, 303);
            fDone = TRUE;       // Shut down, we're insane.
            continue;
        }


        //
        // Connection request established, pass off to service thread.
        //

        try
        {
            LockSection(
                g_pcsControlLocks[CSLOCK_SERVERLOCK],
                DBGT("Find a service thread slot"));
            for (dwIndex = 0; NULL != l_rgServers[dwIndex]; dwIndex += 1);
                // empty body.
            l_rgServers.Set(dwIndex, NULL);   // Make sure we can create it.
            pService = new CServiceThread(dwIndex);
            if (NULL == pService)
            {
                CalaisError(__SUBROUTINE__, 307);
                throw (DWORD)SCARD_E_NO_MEMORY;
            }
            l_rgServers.Set(dwIndex, pService);
            pService->Watch(pcomChannel);
            pcomChannel = NULL;
            pService = NULL;

        }
        catch (...)
        {
            if (NULL != pService)
                delete pService;
            if (NULL != pcomChannel)
                delete pcomChannel;
        }

    } while (!fDone);

    return 0;
}


/*++

ServiceMonitor:

    This is the main code for monitoring existing connections for requests for
    service, and dispatching the requests.

Arguments:

    pvParam supplies the parameter from the CreateThread call.  In this case,
        it's the address of the controlling CServiceThread object.

Return Value:

    Zero

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/24/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("ServiceMonitor")

extern "C" DWORD WINAPI
ServiceMonitor(
    LPVOID pvParameter)
{
    NEW_THREAD;
    CServiceThread *pSvc = (CServiceThread *)pvParameter;
    CComObject *pCom = NULL;
    BOOL fDone = FALSE;
    BOOL fSts;
    DWORD dwSts;
    CComObject::COMMAND_ID cid;


    //
    // Establish the connection.
    //

#ifdef DBG
    TCHAR szTid[sizeof(DWORD_PTR) * 2 + 3];
    _stprintf(szTid, DBGT("0x%lx"), GetCurrentThreadId());
#else
    LPCTSTR szTid = NULL;
#endif
    CalaisInfo(
        __SUBROUTINE__,
        DBGT("Context Create (TID = %1)"),
        szTid);
    try
    {
        CComChannel::CONNECT_REQMSG crq;
        CComChannel::CONNECT_RSPMSG crsp;
        CComChannel *pChannel = pSvc->m_pcomChannel;

        pChannel->Receive(&crq, sizeof(crq));


        //
        // Be the caller, just in case of funny business.
        //

        fSts = ImpersonateNamedPipeClient(pChannel->m_hPipe);
        if (!fSts)
        {
            dwSts = GetLastError();
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Context TID=%2 Failed to impersonate caller: %1"),
                dwSts,
                szTid);
        }


        //
        // Verify the connect request information.
        //

        if (0 != crq.dwSync)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Comm Responder Context TID=%1 got invalid sync data on connection pipe"),
                szTid);
            throw (DWORD)SCARD_F_COMM_ERROR;
        }

        if (CALAIS_COMM_CURRENT != crq.dwVersion)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Comm Responder Context TID=%1 got invalid connect verion from connection pipe."),
                szTid);
            throw (DWORD)SCARD_F_COMM_ERROR;
        }


        //
        // Confirm the connect request.
        //

        crsp.dwStatus = SCARD_S_SUCCESS;
        crsp.dwVersion = CALAIS_COMM_CURRENT;
        dwSts = pChannel->Send(&crsp, sizeof(crsp));
        if (ERROR_SUCCESS != dwSts)
            fDone = TRUE;
    }
    catch (...)
    {
        fDone = TRUE;
    }


    //
    // Loop for as long as there are services to perform.
    //

    while (!fDone)
    {
        ASSERT(NULL == pCom);
        try
        {
            CalaisInfo(
                __SUBROUTINE__,
                DBGT("TID=%1: Waiting for request..."),
                szTid);
            pCom = CComObject::ReceiveComObject(pSvc->m_pcomChannel);
            CalaisInfo(
                __SUBROUTINE__,
                DBGT("TID=%1: ...Processing request"),
                szTid);
            cid = pCom->Type();
            try
            {
                switch (cid)
                {
                case CComObject::EstablishContext_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Establish Context Start..."),
                        szTid);
                    pSvc->DoEstablishContext(
                            (ComEstablishContext *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Establish Context Complete"),
                        szTid);
                    break;

                case CComObject::IsValidContext_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Is Valid Context Start..."),
                        szTid);
                    pSvc->DoIsValidContext((ComIsValidContext *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Is Valid Context Complete"),
                        szTid);
                    break;

                case CComObject::ReleaseContext_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Release Context Start..."),
                        szTid);
                    pSvc->DoReleaseContext((ComReleaseContext *)pCom);
                    fDone = TRUE;
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Release Context Complete"),
                        szTid);
                    break;

                case CComObject::LocateCards_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Locate Cards Start..."),
                        szTid);
                    pSvc->DoLocateCards((ComLocateCards *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Locate Cards Complete"),
                        szTid);
                    break;

                case CComObject::GetStatusChange_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Get Status Change Start..."),
                        szTid);
                    pSvc->DoGetStatusChange((ComGetStatusChange *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Get Status Change Complete"),
                        szTid);
                    break;

                case CComObject::ListReaders_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: List Readers Start..."),
                        szTid);
                    pSvc->DoListReaders((ComListReaders *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... List Readers Complete"),
                        szTid);
                    break;

                case CComObject::Connect_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Connect Start..."),
                        szTid);
                    pSvc->DoConnect((ComConnect *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Connect Complete"),
                        szTid);
                    break;

                case CComObject::Reconnect_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Reconnect Start..."),
                        szTid);
                    pSvc->DoReconnect((ComReconnect *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Reconnect Complete"),
                        szTid);
                    break;

                case CComObject::Disconnect_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Disconnect Start..."),
                        szTid);
                    pSvc->DoDisconnect((ComDisconnect *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Disconnect Complete"),
                        szTid);
                    break;

                case CComObject::BeginTransaction_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Begin Transaction Start..."),
                        szTid);
                    pSvc->DoBeginTransaction((ComBeginTransaction *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Begin Transaction Complete"),
                        szTid);
                    break;

                case CComObject::EndTransaction_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: End Transaction Start..."),
                        szTid);
                    pSvc->DoEndTransaction((ComEndTransaction *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... End Transaction Complete"),
                        szTid);
                    break;

                case CComObject::Status_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Status Request Start..."),
                        szTid);
                    pSvc->DoStatus((ComStatus *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Status Request Complete"),
                        szTid);
                    break;

                case CComObject::Transmit_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Transmit Start..."),
                        szTid);
                    pSvc->DoTransmit((ComTransmit *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Transmit Complete"),
                        szTid);
                    break;

                case CComObject::Control_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Control Start..."),
                        szTid);
                    pSvc->DoControl((ComControl *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Control Complete"),
                        szTid);
                    break;

                case CComObject::GetAttrib_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Get Attribute Start..."),
                        szTid);
                    pSvc->DoGetAttrib((ComGetAttrib *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Get Attribute Complete"),
                        szTid);
                    break;

                case CComObject::SetAttrib_request:
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: Set Attribute Start..."),
                        szTid);
                    pSvc->DoSetAttrib((ComSetAttrib *)pCom);
                    CalaisInfo(
                        __SUBROUTINE__,
                        DBGT("TID=%1: ... Set Attribute Complete"),
                        szTid);
                    break;

                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Service Monitor received invalid request"));
                    throw (DWORD)SCARD_F_COMM_ERROR;
                }

                dwSts = pCom->Send(pSvc->m_pcomChannel);
                delete pCom;
                pCom = NULL;
                if (ERROR_SUCCESS != dwSts)
                    fDone = TRUE;
            }

            catch (DWORD dwError)
            {
                CalaisInfo(
                    __SUBROUTINE__,
                    DBGT("TID=%2: Caught error return: %1"),
                    dwError,
                    szTid);
                CComObject::CObjGeneric_response rsp;

                rsp.dwCommandId = cid + 1;
                rsp.dwTotalLength =
                    rsp.dwDataOffset =
                        sizeof(CComObject::CObjGeneric_response);
                rsp.dwStatus = dwError;
                dwSts = pSvc->m_pcomChannel->Send(&rsp, sizeof(rsp));
                if (ERROR_SUCCESS != dwSts)
                    fDone = TRUE;
#ifdef DBG
                WriteApiLog(&rsp, sizeof(rsp));
#endif
                if (NULL != pCom)
                {
                    delete pCom;
                    pCom = NULL;
                }
            }

            catch (...)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Responder TID=%1: Caught exception!"),
                    szTid);
                CComObject::CObjGeneric_response rsp;

                rsp.dwCommandId = cid + 1;
                rsp.dwTotalLength =
                    rsp.dwDataOffset =
                        sizeof(CComObject::CObjGeneric_response);
                rsp.dwStatus = SCARD_F_UNKNOWN_ERROR;
                dwSts = pSvc->m_pcomChannel->Send(&rsp, sizeof(rsp));
                if (ERROR_SUCCESS != dwSts)
                    fDone = TRUE;
#ifdef DBG
                WriteApiLog(&rsp, sizeof(rsp));
#endif
                if (NULL != pCom)
                {
                    delete pCom;
                    pCom = NULL;
                }
            }
        }

        catch (DWORD dwError)
        {
            switch (dwError)
            {
            case ERROR_NO_DATA:
            case ERROR_BROKEN_PIPE:
            case SCARD_P_SHUTDOWN:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Service thread TID=%2 terminating due to unexpected error:  %1"),
                    dwError,
                    szTid);
            }
            if (NULL != pCom)
                delete pCom;
            fDone = TRUE;
        }

        catch (...)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Service thread TID=%1 terminating due to unexpected exception"),
                szTid);
            if (NULL != pCom)
                delete pCom;
            fDone = TRUE;
        }
#ifdef DBG
        CReaderReference *pRdrRef;
        CReader * pRdr;

        for (DWORD dwIndex = pSvc->m_rgpReaders.Count(); 0 < dwIndex;)
        {
            dwIndex -= 1;
            pRdrRef = pSvc->m_rgpReaders[dwIndex];
            if (NULL != pRdrRef)
            {
                pRdr = pRdrRef->Reader();
                if (NULL != pRdr)
                {
                    ASSERT(!pRdr->IsLatchedByMe());
                }
            }
        }
#endif
    }

    delete pSvc;
    CalaisInfo(
        __SUBROUTINE__,
        DBGT("Context Close, TID = %1"),
        szTid);
    return 0;
}


//
//==============================================================================
//
//  CServiceThread
//

/*++

CServiceThread:

    This is the constructor for a CServiceThread.  It merely initializes the
    object.  The Watch method kicks off the thread.  Note this is protected, so
    that only the Dispatch Monitor may start a Service Thread.

Arguments:

    dwServerIndex supplies a cross link into the l_rgServers array, so that this
        object can clean up after itself.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/5/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::CServiceThread")

CServiceThread::CServiceThread(
    DWORD dwServerIndex)
:   m_rgpReaders(),
    m_hThread(DBGT("CServiceThread Worker Thread")),
    m_hCancelEvent(DBGT("CServiceThread Cancel event")),
    m_hExitEvent(DBGT("CServiceThread Exit event"))
{
    m_dwServerIndex = dwServerIndex;
    m_pcomChannel = NULL;
    m_dwThreadId = 0;
}


/*++

~CServiceThread:

    This is the destructor for a CServiceThread.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/5/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::~CServiceThread")

CServiceThread::~CServiceThread()
{
    DWORD dwIndex, dwSts;
    BOOL fSts;
    CReaderReference *pRdrRef;


    //
    // Take us out of the service thread list.
    //

    {
        LockSection(
            g_pcsControlLocks[CSLOCK_SERVERLOCK],
            DBGT("Removing deleted service thread from the worker thread list"));
        l_rgServers.Set(m_dwServerIndex, NULL);
    }


    m_hThread.Close();


    //
    // Break any outstanding Connections left open on the thread.
    //

    for (dwIndex = m_rgpReaders.Count(); dwIndex > 0;)
    {
        dwIndex -= 1;
        pRdrRef = m_rgpReaders[dwIndex];
        if (NULL != pRdrRef)
        {
            CReader *pRdr = pRdrRef->Reader();
            ASSERT(NULL != pRdr);
            try
            {
                pRdr->Disconnect(
                        pRdrRef->ActiveState(),
                        SCARD_RESET_CARD,
                        &dwSts);
            }
            catch (...) {}
            m_rgpReaders.Set(dwIndex, NULL);
            ASSERT(!pRdr->IsLatchedBy(m_dwThreadId));
            ASSERT(!pRdr->IsGrabbedBy(m_dwThreadId));
            CalaisReleaseReader(&pRdrRef);
        }
    }


    //
    // Final resource cleanup.
    //

    if (NULL != m_pcomChannel)
    {
        delete m_pcomChannel;
        m_pcomChannel = NULL;
    }
    if (m_hCancelEvent.IsValid())
        m_hCancelEvent.Close();
    if (m_hExitEvent.IsValid())
        m_hExitEvent.Close();
}


/*++

Watch:

    This method kicks off the service thread for this object.

Arguments:

    pcomChannel supplies the communications channel to service.

Return Value:

    None

Throws:

    Errors as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/5/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::Watch")

void
CServiceThread::Watch(
    CComChannel *pcomChannel)
{
    DWORD dwLastErr;

    ASSERT(!m_hThread.IsValid());
    ASSERT(0 == m_dwThreadId);

    m_pcomChannel = pcomChannel;
    m_hThread = CreateThread(
                    NULL,   // Not inheritable
                    CALAIS_STACKSIZE,   // Default stack size
                    (LPTHREAD_START_ROUTINE)ServiceMonitor,
                    this,
                    0,      // Run immediately
                    &m_dwThreadId);
    if (!m_hThread.IsValid())
    {
        dwLastErr = m_hThread.GetLastError();
        CalaisError(__SUBROUTINE__, 304, dwLastErr);
        throw dwLastErr;
    }
}


/*++

DoEstablishContext:

    This method performs the EstablishContext service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoEstablishContext")

void
CServiceThread::DoEstablishContext(
    ComEstablishContext *pCom)
{
    static const TCHAR szEmptyString[] = TEXT("");
    BOOL fSts;
    CHandleObject hCancelEvent(DBGT("Cancel Event in DoEstablishContext"));
    CHandleObject hTargetProc(DBGT("Target Process in DoEstablishContext"));
    LPCTSTR szEventName = szEmptyString;

    try
    {
        DWORD dwSts;
        ComEstablishContext::CObjEstablishContext_request *pReq
            = (ComEstablishContext::CObjEstablishContext_request *)pCom->Request();


        //
        // If the caller wants to offer a cancel event, see if we can use it.
        //

        if (INVALID_HANDLE_VALUE != (HANDLE) pReq->hptrCancelEvent)
        {

            //
            // Get a handle to the caller so that we can tell if it exits.
            //

            hTargetProc = OpenProcess(
                            PROCESS_DUP_HANDLE | SYNCHRONIZE, // access flag
                            FALSE,              // handle inheritance flag
                            pReq->dwProcId);    // process identifier
            if (!hTargetProc.IsValid())
            {
                CalaisInfo(
                    __SUBROUTINE__,
                    DBGT("Comm Responder can't duplicate handles from received procId:  %1"),
                    hTargetProc.GetLastError());
                hTargetProc = OpenProcess(SYNCHRONIZE, FALSE, pReq->dwProcId);
                if (!hTargetProc.IsValid())
                {
                    dwSts = hTargetProc.GetLastError();
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Comm Responder can't synchronize to received procId:  %1"),
                        dwSts);
                    // throw dwSts;
                }
                ASSERT(!hCancelEvent.IsValid());
            }
            else
            {
                HANDLE h = NULL;
                fSts = DuplicateHandle(
                            hTargetProc,        // handle to process
                            (HANDLE) pReq->hptrCancelEvent, // handle to duplicate
                            GetCurrentProcess(),// handle to process to duplicate to
                            &h,                 // pointer to duplicate handle
                            SYNCHRONIZE,        // access for duplicate handle
                            FALSE,              // handle inheritance flag
                            0);                 // optional actions
                if (!fSts)
                {
                    dwSts = GetLastError();
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Comm Responder could not dup offered cancel event:  %1"),
                        dwSts);
                    ASSERT(NULL == h);
                }
                hCancelEvent = h;
            }
        }


        //
        // Now if hCancelEvent isn't valid, it means that the caller wants one,
        // but we can't attach to the one they've proposed.  We'll propose an
        // alternate.
        //

        if (!hCancelEvent.IsValid()
            && (INVALID_HANDLE_VALUE != (HANDLE) pReq->hptrCancelEvent))
        {
            DWORD dwThreadId = GetCurrentThreadId();
            CSecurityDescriptor acl;

            dwSts = FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_STRING
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CalaisString(CALSTR_CANCELEVENTPREFIX),
                        0, 0,  // ignored
                        (LPTSTR)&szEventName,
                        sizeof(LPVOID),  // min characters to allocate
                        (va_list *)&dwThreadId);
            if (0 == dwSts)
            {
                dwSts = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Comm Responder can't build cancel event name:  %1"),
                    dwSts);
                throw dwSts;
            }

            acl.Initialize();
            acl.Allow(
                &acl.SID_LocalService,
                EVENT_ALL_ACCESS);
            acl.Allow(
                &acl.SID_Local,
                EVENT_MODIFY_STATE | SYNCHRONIZE);
            acl.Allow(
                &acl.SID_System,
                EVENT_MODIFY_STATE | SYNCHRONIZE);

            hCancelEvent = CreateEvent(
                                acl,            // pointer to security attributes
                                TRUE,           // flag for manual-reset event
                                FALSE,          // flag for initial state
                                szEventName);   // pointer to event-object name
            if (!hCancelEvent.IsValid())
            {
                dwSts = hCancelEvent.GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Comm Responder can't create cancel event:  %1"),
                    dwSts);
                throw dwSts;
            }
        }

        m_hExitEvent = hTargetProc.Relinquish();
        m_hCancelEvent = hCancelEvent.Relinquish();
        ComEstablishContext::CObjEstablishContext_response *pRsp
            = (ComEstablishContext::CObjEstablishContext_response *)pCom->InitResponse(0);
        pRsp = (ComEstablishContext::CObjEstablishContext_response *)
                pCom->Append(
                    pRsp->dscCancelEvent,
                    szEventName,
                    (lstrlen(szEventName) + 1) * sizeof(TCHAR));
        pRsp->dwStatus = SCARD_S_SUCCESS;
        if (szEmptyString != szEventName)
            LocalFree((HLOCAL)szEventName);
    }

    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Failed to establish context"));
        if (hCancelEvent.IsValid())
            hCancelEvent.Close();
        if (hTargetProc.IsValid())
            hTargetProc.Close();
        if (szEmptyString != szEventName)
            LocalFree((HLOCAL)szEventName);
        throw;
    }
}


/*++

DoReleaseContext:

    This method performs the ReleaseContext service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoReleaseContext")

void
CServiceThread::DoReleaseContext(
    ComReleaseContext *pCom)
{
    ComReleaseContext::CObjReleaseContext_request *pReq =
        (ComReleaseContext::CObjReleaseContext_request *)pCom->Request();
    ComReleaseContext::CObjReleaseContext_response *pRsp =
        (ComReleaseContext::CObjReleaseContext_response *)pCom->InitResponse(0);
    pRsp->dwStatus = SCARD_S_SUCCESS;
}


/*++

DoIsValidContext:

    This method performs the IsValidContext service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoIsValidContext")

void
CServiceThread::DoIsValidContext(
    ComIsValidContext *pCom)
{
    ComIsValidContext::CObjIsValidContext_request *pReq =
        (ComIsValidContext::CObjIsValidContext_request *)pCom->Request();
    ComIsValidContext::CObjIsValidContext_response *pRsp =
        (ComIsValidContext::CObjIsValidContext_response *)pCom->InitResponse(0);
    pRsp->dwStatus = SCARD_S_SUCCESS;
}


/*++

DoListReaders:

    This method performs the ListReaders service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 5/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoListReaders")

void
CServiceThread::DoListReaders(
    ComListReaders *pCom)
{
    CReaderReference *pRdrRef;
    CReader *pReader;
    CBuffer bfReaderStates;
    LPBOOL rgfReaderStates;
    DWORD dwReaderCount, dwActiveReaderCount;
    LPCTSTR szReader, mszQueryReaders;
    ComListReaders::CObjListReaders_request *pReq =
        (ComListReaders::CObjListReaders_request *)pCom->Request();

    mszQueryReaders = (LPCTSTR)pCom->Parse(pReq->dscReaders);
    dwReaderCount = MStringCount(mszQueryReaders);
    ComListReaders::CObjListReaders_response *pRsp =
        (ComListReaders::CObjListReaders_response *)pCom->
            InitResponse(dwReaderCount * sizeof(BOOL));
    rgfReaderStates = (LPBOOL)bfReaderStates.Resize(
                                    dwReaderCount * sizeof(BOOL));

    dwReaderCount = dwActiveReaderCount = 0;
    for (szReader = FirstString(mszQueryReaders);
         NULL != szReader;
         szReader = NextString(szReader))
     {
        rgfReaderStates[dwReaderCount] = FALSE;
        try
        {
            pRdrRef = NULL;
            pRdrRef = CalaisLockReader(szReader);
            ASSERT(NULL != pRdrRef);
            pReader = pRdrRef->Reader();
            ASSERT(NULL != pReader);
            if (CReader::Closing > (BYTE)pReader->AvailabilityStatus())
            {
                rgfReaderStates[dwReaderCount] = TRUE;
                dwActiveReaderCount += 1;
            }
            CalaisReleaseReader(&pRdrRef);
        }
        catch (DWORD dwError)
        {
            if (NULL != pRdrRef)
                CalaisReleaseReader(&pRdrRef);
            if (SCARD_E_UNKNOWN_READER != dwError)
                throw;
        }
        catch (...)
        {
            if (NULL != pRdrRef)
                CalaisReleaseReader(&pRdrRef);
            throw;
        }
        dwReaderCount += 1;
    }

    if (0 == dwActiveReaderCount)
        throw (DWORD)SCARD_E_NO_READERS_AVAILABLE;
    ASSERT(dwReaderCount == bfReaderStates.Length() / sizeof(BOOL));
    pRsp = (ComListReaders::CObjListReaders_response *)
        pCom->Append(
            pRsp->dscReaders,
            bfReaderStates.Access(),
            bfReaderStates.Length());
    pRsp->dwStatus = SCARD_S_SUCCESS;
}


/*++

DoLocateCards:

    This method performs the LocateCards service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoLocateCards")

void
CServiceThread::DoLocateCards(
    ComLocateCards *pCom)
{
    DWORD dwStateCount;
    DWORD cbTotAtrs, cbTotMasks;
    CBuffer bfAtrs, bfAtr;
    BYTE bAtrLen;
    ComLocateCards::CObjLocateCards_request *pReq =
        (ComLocateCards::CObjLocateCards_request *)pCom->Request();
    ComLocateCards::CObjLocateCards_response *pRsp;
    CDynamicArray<const BYTE> rgbAtrs;
    CDynamicArray<const BYTE> rgbMasks;
    CDynamicArray<const BYTE> rgbAtrLens;
    DWORD cbLength, dwAtrLen;
    DWORD dwIndex;


    //
    // Pull in and parse the command parameters.
    //

    LPBYTE pbAtrs = (LPBYTE)pCom->Parse(pReq->dscAtrs, &cbTotAtrs);
    LPCBYTE pbMasks = (LPCBYTE)pCom->Parse(pReq->dscAtrMasks, &cbTotMasks);
    LPCTSTR mszReaders = (LPCTSTR)pCom->Parse(pReq->dscReaders);
    LPDWORD rgdwStates = (LPDWORD)pCom->Parse(
                                pReq->dscReaderStates,
                                &dwStateCount);
    if (0 == *mszReaders)
        throw (DWORD)SCARD_E_UNKNOWN_READER;
    if ((0 == cbTotAtrs)
        || (0 == cbTotMasks)
        || (0 == dwStateCount)
        || (0 != dwStateCount % sizeof(DWORD)))
        throw (DWORD)SCARD_E_INVALID_VALUE;
    dwStateCount /= sizeof(DWORD);


    //
    // Extract the ATRs and Masks.
    //

    while (0 < cbTotAtrs)
    {
        rgbAtrLens.Add(pbAtrs);
        cbLength = *pbAtrs++;
        if (cbLength > cbTotAtrs)
            throw (DWORD)SCARD_F_COMM_ERROR;
        dwAtrLen = cbLength;
        if (33 < dwAtrLen)
            throw (DWORD)SCARD_E_INVALID_ATR;
        cbLength = *pbMasks++;
        if (cbLength > cbTotMasks)
            throw (DWORD)SCARD_F_COMM_ERROR;
        if (0 == cbLength)
            rgbMasks.Add(NULL);
        else
        {
            if (dwAtrLen != cbLength)
                throw (DWORD)SCARD_E_INVALID_ATR;
            for (dwIndex = 0; dwIndex < dwAtrLen; dwIndex += 1)
                pbAtrs[dwIndex] &= pbMasks[dwIndex];
            rgbMasks.Add(pbMasks);
        }
        rgbAtrs.Add(pbAtrs);
        cbTotAtrs -= dwAtrLen + 1;
        pbAtrs += dwAtrLen;

        cbTotMasks -= cbLength + 1;
        pbMasks += cbLength;
    }
    if (0 != cbTotMasks)
        throw (DWORD)SCARD_F_COMM_ERROR;


    //
    // Look for the card.
    //

    CReaderReference *pRdrRef = NULL;
    LPCTSTR szReader;
    DWORD dwRdrStatus;
    DWORD dwRdrCount;
    DWORD ix;
    CReader::AvailableState avlState;
    WORD wActivityCount = 0;

    dwRdrCount = 0;
    for (dwIndex = 0, szReader = FirstString(mszReaders);
         dwIndex < dwStateCount;
         dwIndex += 1, szReader = NextString(szReader))
    {

        //
        // Make sure we have something to do.
        //

        if (0 != (rgdwStates[dwIndex] & SCARD_STATE_IGNORE))
        {
            rgdwStates[dwIndex] = SCARD_STATE_IGNORE;
            bAtrLen = 0;
            bfAtrs.Append(&bAtrLen, sizeof(bAtrLen));   // No ATR.
            continue;
        }


        //
        // Look for the named reader device and get its state.
        //

        try
        {
            CReader *pReader = NULL;
            try
            {
                pRdrRef = CalaisLockReader(szReader);
                ASSERT(NULL != pRdrRef);
                pReader = pRdrRef->Reader();
                ASSERT(NULL != pReader);
            }
            catch (...)
            {
                pRdrRef = NULL;
            }

            if (NULL == pRdrRef)
            {
                rgdwStates[dwIndex] = SCARD_STATE_UNKNOWN
                    | SCARD_STATE_CHANGED
                    | SCARD_STATE_IGNORE;
                bAtrLen = 0;
                bfAtrs.Append(&bAtrLen, sizeof(bAtrLen));   // No ATR.
                continue;
            }
            dwRdrCount += 1;

            avlState = pReader->AvailabilityStatus();
            wActivityCount = pReader->ActivityHash();
            switch (avlState)
            {
            case CReader::Unresponsive:
            case CReader::Unsupported:
                dwRdrStatus = SCARD_STATE_PRESENT | SCARD_STATE_MUTE;
                break;
            case CReader::Idle:
                dwRdrStatus = SCARD_STATE_EMPTY;
                break;
            case CReader::Present:
                dwRdrStatus = SCARD_STATE_PRESENT | SCARD_STATE_UNPOWERED;
                break;
            case CReader::Ready:
                dwRdrStatus = SCARD_STATE_PRESENT;
                break;
            case CReader::Shared:
                dwRdrStatus = SCARD_STATE_PRESENT | SCARD_STATE_INUSE;
                break;
            case CReader::Exclusive:
                dwRdrStatus = SCARD_STATE_PRESENT
                              | SCARD_STATE_INUSE
                              | SCARD_STATE_EXCLUSIVE;
                break;
            case CReader::Closing:
            case CReader::Broken:
            case CReader::Inactive:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Locate sees reader in unavailable state"));
                dwRdrStatus = SCARD_STATE_UNAVAILABLE
                              | SCARD_STATE_IGNORE;
                wActivityCount = 0;
                break;
            case CReader::Direct:
                dwRdrStatus = SCARD_STATE_UNAVAILABLE;
                break;
            case CReader::Undefined:
                dwRdrStatus = SCARD_STATE_UNKNOWN
                              | SCARD_STATE_IGNORE;
                wActivityCount = 0;
                break;
            default:
                CalaisError(__SUBROUTINE__, 305);
                throw (DWORD)SCARD_F_INTERNAL_ERROR;
            }


            //
            // Return the ATR, if any.
            //

            pReader->Atr(bfAtr);
            CalaisReleaseReader(&pRdrRef);
            // pReader = NULL;
        }
        catch (...)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Locate Cards received an unexpected exception"));
            CalaisReleaseReader(&pRdrRef);
            throw;
        }

        ASSERT(33 >= bfAtr.Length());
        bAtrLen = (BYTE)bfAtr.Length();
        bfAtrs.Append(&bAtrLen, sizeof(bAtrLen));
        bfAtrs.Append(bfAtr.Access(), bfAtr.Length());


        //
        // See if the ATR matches.
        //

        if (SCARD_STATE_PRESENT
            == (dwRdrStatus & (SCARD_STATE_PRESENT | SCARD_STATE_MUTE)))
        {
            ASSERT(2 <= bfAtr.Length());
            for (ix = 0; ix < rgbAtrs.Count(); ix += 1)
            {
                cbLength = *rgbAtrLens[ix];
                if (AtrCompare(bfAtr, rgbAtrs[ix], rgbMasks[ix], cbLength))
                {
                    dwRdrStatus |= SCARD_STATE_ATRMATCH;
                    break;
                }
            }
        }


        //
        // See if that's what the user expects.
        //

        if (dwRdrStatus != (rgdwStates[dwIndex] & (
            SCARD_STATE_UNKNOWN
            | SCARD_STATE_UNAVAILABLE
            | SCARD_STATE_EMPTY
            | SCARD_STATE_PRESENT
            | SCARD_STATE_ATRMATCH
            | SCARD_STATE_EXCLUSIVE
            | SCARD_STATE_INUSE)))
            dwRdrStatus |= SCARD_STATE_CHANGED;


        //
        // Report back the status.
        //

        dwRdrStatus += (DWORD)(wActivityCount) << (sizeof(WORD) * 8);
        rgdwStates[dwIndex] = dwRdrStatus;
    }


    //
    // Report back to the caller.
    //

    if (0 == dwRdrCount)
        throw (DWORD)SCARD_E_NO_READERS_AVAILABLE;
    pRsp = pCom->InitResponse(
            dwStateCount + bfAtrs.Length() + 2 * sizeof(DWORD));
    pRsp = (ComLocateCards::CObjLocateCards_response *)
            pCom->Append(
                pRsp->dscReaderStates,
                (LPCBYTE)rgdwStates,
                dwStateCount * sizeof(DWORD));
    pRsp = (ComLocateCards::CObjLocateCards_response *)
            pCom->Append(
                pRsp->dscAtrs,
                bfAtrs.Access(),
                bfAtrs.Length());
    pRsp->dwStatus = SCARD_S_SUCCESS;
}


/*++

DoGetStatusChange:

    This method performs the GetStatusChange service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoGetStatusChange")

void
CServiceThread::DoGetStatusChange(
    ComGetStatusChange *pCom)
{
#ifdef DBG
    TCHAR szTid[sizeof(DWORD_PTR) * 2 + 3];
    _stprintf(szTid, DBGT("0x%lx"), GetCurrentThreadId());
#else
    LPCTSTR szTid = NULL;
#endif
    DWORD dwStateCount;
    DWORD dwRdrCount;
    BOOL fPnPNotify = FALSE;
    CBuffer bfAtrs, bfAtr;
    BYTE bAtrLen;
    CReaderReference *pRdrRef = NULL;
    CDynamicArray<CReaderReference> rgpReaders;
    CDynamicArray<void> rgpvWaitHandles;

    ComGetStatusChange::CObjGetStatusChange_request *pReq =
        (ComGetStatusChange::CObjGetStatusChange_request *)pCom->Request();
    LPCTSTR mszReaders = (LPCTSTR)pCom->Parse(pReq->dscReaders);
    LPDWORD rgdwStates = (LPDWORD)pCom->Parse(
                                pReq->dscReaderStates,
                                &dwStateCount);
    ComGetStatusChange::CObjGetStatusChange_response *pRsp;


    //
    // Pull in and parse the command parameters.
    //

    if (0 == *mszReaders)
        throw (DWORD)SCARD_E_UNKNOWN_READER;
    if ((0 == dwStateCount)
        || (0 != dwStateCount % sizeof(DWORD)))
        throw (DWORD)SCARD_E_INVALID_VALUE;
    dwStateCount /= sizeof(DWORD);


    //
    // Scan for Changes.
    //

    for (;;)
    {
        LPCTSTR szReader;
        DWORD dwIndex, dwJ;
        DWORD dwRdrStatus;
        BOOL fChangeDetected = FALSE;
        HANDLE hChangeEvent = NULL; // Temporary storage, never closed.
        CReader *pReader = NULL;
        CReader::AvailableState avlState;
        WORD wActivityCount = 0;

        try
        {

            //
            // Compare the statuses.
            //

            dwRdrCount = 0;
            bfAtrs.Reset();
            rgpvWaitHandles.Empty();
            for (dwIndex = 0, szReader = FirstString(mszReaders);
                 dwIndex < dwStateCount;
                 dwIndex += 1, szReader = NextString(szReader))
            {

                //
                // Make sure we have something to do.
                //

                if (0 != (rgdwStates[dwIndex] & SCARD_STATE_IGNORE))
                {
                    bAtrLen = 0;
                    bfAtrs.Append(&bAtrLen, sizeof(bAtrLen));   // No ATR.
                    rgdwStates[dwIndex] = SCARD_STATE_IGNORE;
                    continue;
                }


                //
                // Look for the named reader device and get its state.
                //

                if (NULL == rgpReaders[dwIndex])
                {
                    try
                    {
                        pRdrRef = CalaisLockReader(szReader);
                        ASSERT(NULL != pRdrRef);
                        pReader = pRdrRef->Reader();
                        ASSERT(NULL != pReader);
                    }
                    catch (...)
                    {
                        pRdrRef = NULL;
                    }

                    if (NULL == pRdrRef)
                    {
                        DWORD cchHeader = lstrlen(CalaisString(CALSTR_SPECIALREADERHEADER));


                        //
                        // See if it's a specal case reader name.
                        // Special notariety goes to Craig Delthony
                        // for inventing this backdoor mechanism.
                        //

                        bfAtr.Reset();
                        if (0 == _tcsncicmp(
                                    szReader,
                                    CalaisString(CALSTR_SPECIALREADERHEADER),
                                    cchHeader))
                        {
                            LPCTSTR szSpecial = szReader + cchHeader;
                            CalaisInfo(
                                __SUBROUTINE__,
                                DBGT("Special Reader Name Flag '%2', TID = %1"),
                                szTid,
                                szSpecial);

                            if (0 == lstrcmpi(
                                            szSpecial,
                                            CalaisString(CALSTR_ACTIVEREADERCOUNTREADER)))
                            {

                                //
                                // Report the number of active readers.
                                //
                                //  The high order word of the Reader Status
                                //  contains the number of active readers.
                                //

                                rgdwStates[dwIndex] &= (SCARD_STATE_UNKNOWN
                                                        | (((DWORD)((WORD)(-1)))
                                                           << sizeof(WORD) * 8));
                                                           // 8 Bits per byte
                                dwRdrStatus = CalaisCountReaders();
                                dwRdrStatus <<= sizeof(WORD) * 8;   // 8 Bits per byte
                                dwRdrCount += 1;
                                fPnPNotify = TRUE;
                                goto CheckChange;
                            }
                            // Other flags can be added here
                            else
                            {

                                //
                                // Unrecognized special reader name.
                                //

                                dwRdrStatus = SCARD_STATE_UNKNOWN
                                              | SCARD_STATE_IGNORE;
                                goto CheckChange;
                            }
                        }
                        else
                        {
                            dwRdrStatus = SCARD_STATE_UNKNOWN
                                          | SCARD_STATE_IGNORE;
                            goto CheckChange;
                        }
                    }
                    rgpReaders.Set(dwIndex, pRdrRef);
                    pRdrRef = NULL;
                }
                else
                    pReader = rgpReaders[dwIndex]->Reader();
                dwRdrCount += 1;

                try
                {
                    pReader->Atr(bfAtr);
                    avlState = pReader->AvailabilityStatus();
                    hChangeEvent = pReader->ChangeEvent();
                    wActivityCount = pReader->ActivityHash();
                }
                catch (...)
                {
                    bfAtr.Reset();
                    avlState = CReader::Undefined;
                    hChangeEvent = NULL;
                    wActivityCount = 0;
                }

                switch (avlState)
                {
                case CReader::Unresponsive:
                case CReader::Unsupported:
                    dwRdrStatus = SCARD_STATE_PRESENT
                                  | SCARD_STATE_MUTE;
                    break;
                case CReader::Idle:
                    dwRdrStatus = SCARD_STATE_EMPTY;
                    break;
                case CReader::Present:
                    dwRdrStatus = SCARD_STATE_PRESENT
                                  | SCARD_STATE_UNPOWERED;
                    break;
                case CReader::Ready:
                    dwRdrStatus = SCARD_STATE_PRESENT;
                    break;
                case CReader::Shared:
                    dwRdrStatus = SCARD_STATE_PRESENT
                                  | SCARD_STATE_INUSE;
                    break;
                case CReader::Exclusive:
                    dwRdrStatus = SCARD_STATE_PRESENT
                                  | SCARD_STATE_INUSE
                                  | SCARD_STATE_EXCLUSIVE;
                    break;
                case CReader::Closing:
                case CReader::Inactive:
                case CReader::Broken:
                    dwRdrStatus = SCARD_STATE_UNAVAILABLE
                                  | SCARD_STATE_IGNORE;
                    pRdrRef = rgpReaders[dwIndex];
                    rgpReaders.Set(dwIndex, NULL);
                    CalaisReleaseReader(&pRdrRef);
                    pReader = NULL;
                    hChangeEvent = NULL;
                    wActivityCount = 0;
                    break;
                case CReader::Direct:
                    dwRdrStatus = SCARD_STATE_UNAVAILABLE;
                    break;
                case CReader::Undefined:
                    dwRdrStatus = SCARD_STATE_UNKNOWN
                                  | SCARD_STATE_IGNORE;
                    bfAtr.Reset();
                    hChangeEvent = NULL;
                    wActivityCount = 0;
                    break;
                default:
                    CalaisError(__SUBROUTINE__, 306);
                    throw (DWORD)SCARD_F_INTERNAL_ERROR;
                }
                dwRdrStatus += (DWORD)(wActivityCount) << (sizeof(WORD) * 8);
                rgdwStates[dwIndex] &= (0xffff0000
                                        | SCARD_STATE_UNKNOWN
                                        | SCARD_STATE_UNAVAILABLE
                                        | SCARD_STATE_EMPTY
                                        | SCARD_STATE_PRESENT
                                        | SCARD_STATE_EXCLUSIVE
                                        | SCARD_STATE_INUSE
                                        | SCARD_STATE_MUTE
                                        | SCARD_STATE_UNPOWERED);

                if (((rgdwStates[dwIndex] & 0x0000ffff) == (dwRdrStatus & 0x0000ffff))
                    && ((rgdwStates[dwIndex] & 0xffff0000) != (dwRdrStatus & 0xffff0000))
                    && ((rgdwStates[dwIndex] & 0xffff0000) != 0))
                {

                    //
                    // The state has changed back to what the caller originally
                    // thought it was.  Rather than loose an event, we simulate
                    // a pseudo-event, to ensure the caller is up to date on
                    // what all has already happened.  Then when they call us
                    // again, we'll correct that pseudo-state to the real thing.
                    //

                    dwRdrStatus ^= (SCARD_STATE_EMPTY | SCARD_STATE_PRESENT);

                    bfAtr.Reset();      // Do not send back any ATR in any case

                    dwRdrStatus &= 0x0000ffff;  // We indeed backtrack by one event
                    dwRdrStatus += (DWORD)(--wActivityCount) << (sizeof(WORD) * 8);

                    switch (dwRdrStatus & (SCARD_STATE_EMPTY | SCARD_STATE_PRESENT))
                    {
                    case SCARD_STATE_EMPTY:
                            // Mask the bits according to spec (no card)
                        dwRdrStatus &= ~(SCARD_STATE_EXCLUSIVE
                                        | SCARD_STATE_INUSE
                                        | SCARD_STATE_MUTE);
                        break;
                    case SCARD_STATE_PRESENT:
                            // We claim that a card is present but we lie.
                            // We'd better declare it mute. It doesn't really matter as
                            // it is already withdrawn
                        dwRdrStatus |= SCARD_STATE_MUTE;
                        break;
                    default:
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("Card state invalid"));
                        throw (DWORD)SCARD_F_INTERNAL_ERROR;
                    }
                }

                if (NULL != hChangeEvent)
                {
                    for (dwJ = rgpvWaitHandles.Count(); dwJ > 0;)
                    {
                        if (rgpvWaitHandles[--dwJ] == hChangeEvent)
                        {
                            hChangeEvent = NULL;
                            break;
                        }
                    }
                    if (NULL != hChangeEvent)
                        rgpvWaitHandles.Add(hChangeEvent);
                }


                //
                // Return the ATR, if any.
                //

CheckChange:
                ASSERT(33 >= bfAtr.Length());
                bAtrLen = (BYTE)bfAtr.Length();
                bfAtrs.Append(&bAtrLen, sizeof(bAtrLen));
                bfAtrs.Append(bfAtr.Access(), bfAtr.Length());


                //
                // See if that's what the user expects.
                //

                if (0 != (dwRdrStatus ^ rgdwStates[dwIndex]))
                {
                    rgdwStates[dwIndex] = dwRdrStatus | SCARD_STATE_CHANGED;
                    fChangeDetected = TRUE;
                }
                else
                    rgdwStates[dwIndex] = dwRdrStatus;
            }

            if (0 == dwRdrCount)
                throw (DWORD)SCARD_E_NO_READERS_AVAILABLE;
            if (fChangeDetected)
                break;


            //
            // If nothing has changed, wait for something to happen.
            //

            ASSERT(WAIT_ABANDONED_0 > WAIT_OBJECT_0);
            CalaisInfo(
                __SUBROUTINE__,
                DBGT("Status Change Block, TID = %1"),
                szTid);
            ASSERT(m_hCancelEvent.IsValid());
            rgpvWaitHandles.Add(m_hCancelEvent);
            if (m_hExitEvent.IsValid())
                rgpvWaitHandles.Add(m_hExitEvent);
            if (fPnPNotify)
                rgpvWaitHandles.Add(g_phReaderChangeEvent->WaitHandle());
            rgpvWaitHandles.Add(g_hCalaisShutdown);
            dwIndex = WaitForMultipleObjects(
                            rgpvWaitHandles.Count(),
                            (LPHANDLE)rgpvWaitHandles.Array(),
                            FALSE,
                            pReq->dwTimeout);
            if (WAIT_FAILED == dwIndex)
            {
                DWORD dwErr = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Command dispatch TID=%2 cannot wait for Reader changes:  %1"),
                    dwErr,
                    szTid);
                throw dwErr;
            }
            C_ASSERT(WAIT_OBJECT_0 == 0);
            if (WAIT_TIMEOUT == dwIndex)
                throw (DWORD)SCARD_E_TIMEOUT;
            if (WAIT_ABANDONED_0 <= dwIndex)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Wait Abandoned received TID=%1 while waiting for Reader changes"),
                    szTid);
                dwIndex -= WAIT_ABANDONED_0;
            }
            if (dwIndex >= rgpvWaitHandles.Count())
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid wait response TID=%1 while waiting for Reader changes"),
                    szTid);
                throw (DWORD)SCARD_F_INTERNAL_ERROR;
            }
            CalaisInfo(
                __SUBROUTINE__,
                DBGT("Status Change Unblock, TID = %1"),
                szTid);
            ASSERT(NULL != rgpvWaitHandles[dwIndex]);
            ASSERT(INVALID_HANDLE_VALUE != rgpvWaitHandles[dwIndex]);
            if (rgpvWaitHandles[dwIndex] == g_hCalaisShutdown)
                throw (DWORD)SCARD_E_SYSTEM_CANCELLED;
            if (rgpvWaitHandles[dwIndex] == m_hExitEvent.Value())
                throw (DWORD)SCARD_E_CANCELLED; // Caller exited.
            if (m_hCancelEvent.Value() == rgpvWaitHandles[dwIndex])
                throw (DWORD)SCARD_E_CANCELLED; // Caller canceled.
        }
        catch (DWORD dwError)
        {
            DWORD ix;
            switch (dwError)
            {
            case SCARD_E_CANCELLED:
                CalaisInfo(
                    __SUBROUTINE__,
                    DBGT("Get Status Change TID = %1 Cancelled by user"),
                    szTid);
                break;
            case SCARD_E_SYSTEM_CANCELLED:
                CalaisInfo(
                    __SUBROUTINE__,
                    DBGT("Get Status Change TID = %1 Cancelled by system"),
                    szTid);
                break;
            case SCARD_E_TIMEOUT:
                CalaisInfo(
                    __SUBROUTINE__,
                    DBGT("Get Status Change TID = %1 timeout"),
                    szTid);
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Get Status Change TID=%2 received unexpected exception: %1"),
                    dwError,
                    szTid);
            }
            CalaisReleaseReader(&pRdrRef);
            for (ix = rgpReaders.Count(); ix > 0;)
            {
                ix -= 1;
                pRdrRef = rgpReaders[ix];
                CalaisReleaseReader(&pRdrRef);
            }
            throw;
        }
        catch (...)
        {
            DWORD ix;
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Get Status Change TID=%1 received unexpected exception"),
                szTid);
            CalaisReleaseReader(&pRdrRef);
            for (ix = rgpReaders.Count(); ix > 0;)
            {
                ix -= 1;
                pRdrRef = rgpReaders[ix];
                CalaisReleaseReader(&pRdrRef);
            }
            throw;
        }
    }


    //
    // Clean up.
    //

    CalaisReleaseReader(&pRdrRef);
    for (DWORD ix = rgpReaders.Count(); ix > 0;)
    {
        ix -= 1;
        pRdrRef = rgpReaders[ix];
        CalaisReleaseReader(&pRdrRef);
    }


    //
    // Report back to the caller.
    //

    pRsp = pCom->InitResponse(dwStateCount);
    pRsp = (ComGetStatusChange::CObjGetStatusChange_response *)
            pCom->Append(
                pRsp->dscReaderStates,
                (LPCBYTE)rgdwStates,
                dwStateCount * sizeof(DWORD));
    pRsp = (ComGetStatusChange::CObjGetStatusChange_response *)
            pCom->Append(
                pRsp->dscAtrs,
                bfAtrs.Access(),
                bfAtrs.Length());
    pRsp->dwStatus = SCARD_S_SUCCESS;
}


/*++

DoConnect:

    This method performs the Connect service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoConnect")

void
CServiceThread::DoConnect(
    ComConnect *pCom)
{
    CReaderReference *pRdrRef = NULL;
    CReader *pReader = NULL;

    try
    {
        LPCTSTR szReader;
        DWORD dwIndex;
        ComConnect::CObjConnect_request *pReq
            = (ComConnect::CObjConnect_request *)pCom->Request();
        szReader = (LPCTSTR)pCom->Parse(pReq->dscReader);


        //
        //  Find the requested reader.
        //

        if (0 == *szReader)
            throw (DWORD)SCARD_E_UNKNOWN_READER;
        pRdrRef = CalaisLockReader(szReader);
        ASSERT(NULL != pRdrRef);
        pReader = pRdrRef->Reader();
        ASSERT(NULL != pReader);


        //
        // Try to establish the requested ownership.
        //

        pReader->Connect(
            pReq->dwShareMode,
            pReq->dwPreferredProtocols,
            pRdrRef->ActiveState());
        pRdrRef->Mode(pReq->dwShareMode);
        for (dwIndex = 0; NULL != m_rgpReaders[dwIndex]; dwIndex += 1);
            // null body
        m_rgpReaders.Set(dwIndex, pRdrRef);
        pRdrRef = NULL;

        ComConnect::CObjConnect_response *pRsp = pCom->InitResponse(0);
        pRsp->hCard = L2H(dwIndex);
        pRsp->dwActiveProtocol = pReader->Protocol();
        pRsp->dwStatus = SCARD_S_SUCCESS;
    }

    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Failed to Connect to reader"));
        CalaisReleaseReader(&pRdrRef);
        throw;
    }
    ASSERT(!pReader->IsLatchedByMe());
}


/*++

DoReconnect:

    This method performs the Reconnect service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoReconnect")

void
CServiceThread::DoReconnect(
    ComReconnect *pCom)
{
    ComReconnect::CObjReconnect_request *pReq
        = (ComReconnect::CObjReconnect_request *)pCom->Request();
    DWORD dwIndex = (DWORD)pReq->hCard;
    DWORD dwDispSts;
    CReaderReference * pRdrRef = m_rgpReaders[dwIndex];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_HANDLE;
    CReader *pReader = pRdrRef->Reader();
    pReader->Reconnect(
            pReq->dwShareMode,
            pReq->dwPreferredProtocols,
            pReq->dwInitialization,
            pRdrRef->ActiveState(),
            &dwDispSts);
    pRdrRef->Mode(pReq->dwShareMode);

    ComReconnect::CObjReconnect_response *pRsp
        = pCom->InitResponse(0);
    pRsp->dwActiveProtocol = pReader->Protocol();
    pRsp->dwStatus = SCARD_S_SUCCESS;
    ASSERT(!pReader->IsLatchedByMe());
}


/*++

DoDisconnect:

    This method performs the Disconnect service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoDisconnect")

void
CServiceThread::DoDisconnect(
    ComDisconnect *pCom)
{
    CReaderReference *pRdrRef = NULL;
    ComDisconnect::CObjDisconnect_request *pReq
        = (ComDisconnect::CObjDisconnect_request *)pCom->Request();
    DWORD dwIndex = (DWORD)pReq->hCard;
    DWORD dwDispSts;

    pRdrRef = m_rgpReaders[dwIndex];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_HANDLE;
    CReader *pRdr = pRdrRef->Reader();
    try
    {
        pRdr->Disconnect(
            pRdrRef->ActiveState(),
            pReq->dwDisposition,
            &dwDispSts);
    }
    catch (...) {}
    m_rgpReaders.Set(dwIndex, NULL);
    CalaisReleaseReader(&pRdrRef);

    ComDisconnect::CObjDisconnect_response *pRsp
        = pCom->InitResponse(0);
    pRsp->dwStatus = SCARD_S_SUCCESS;
}


/*++

DoBeginTransaction:

    This method performs the BeginTransaction service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoBeginTransaction")

void
CServiceThread::DoBeginTransaction(
    ComBeginTransaction *pCom)
{
    CReader *pRdr = NULL;
#ifdef DBG
    TCHAR szTid[sizeof(DWORD_PTR) * 2 + 3];
    _stprintf(szTid, DBGT("0x%lx"), GetCurrentThreadId());
#else
    LPCTSTR szTid = NULL;
#endif
    try
    {
        ComBeginTransaction::CObjBeginTransaction_request *pReq
            = (ComBeginTransaction::CObjBeginTransaction_request *)
                pCom->Request();
        CReaderReference *pRdrRef = m_rgpReaders[H2L(pReq->hCard)];
        if (NULL == pRdrRef)
            throw (DWORD)SCARD_E_INVALID_VALUE;
        CReader *pRdr2 = pRdrRef->Reader();
        pRdr2->VerifyActive(pRdrRef->ActiveState());
        pRdr2->GrabReader();
        pRdr = pRdr2;
        CalaisInfo(
            __SUBROUTINE__,
            DBGT("Begin Transaction, TID = %1"),
            szTid);
        ComBeginTransaction::CObjBeginTransaction_response *pRsp
            = pCom->InitResponse(0);
        pRsp->dwStatus = SCARD_S_SUCCESS;
    }
    catch (...)
    {
        if (NULL != pRdr)
        {
            pRdr->ShareReader();
            ASSERT(!pRdr->IsLatchedByMe());
        }
        throw;
    }
    ASSERT(!pRdr->IsLatchedByMe());
    ASSERT(pRdr->IsGrabbedByMe());
}


/*++

DoEndTransaction:

    This method performs the EndTransaction service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoEndTransaction")

void
CServiceThread::DoEndTransaction(
    ComEndTransaction *pCom)
{
#ifdef DBG
    TCHAR szTid[sizeof(DWORD_PTR) * 2 + 3];
    _stprintf(szTid, DBGT("0x%lx"), GetCurrentThreadId());
#else
    LPCTSTR szTid = NULL;
#endif
    ComEndTransaction::CObjEndTransaction_request *pReq
        = (ComEndTransaction::CObjEndTransaction_request *)pCom->Request();
    CReaderReference *pRdrRef = m_rgpReaders[H2L(pReq->hCard)];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    CReader *pReader = pRdrRef->Reader();

    pReader->VerifyActive(pRdrRef->ActiveState());
    if (!pReader->IsGrabbedByMe())
        throw (DWORD)SCARD_E_NOT_TRANSACTED;

    switch (pReq->dwDisposition)
    {
    case SCARD_LEAVE_CARD:
        break;
    case SCARD_RESET_CARD:
    case SCARD_UNPOWER_CARD:
#ifdef SCARD_CONFISCATE_CARD
    case SCARD_CONFISCATE_CARD:
#endif
    case SCARD_EJECT_CARD:
        pReader->Dispose(pReq->dwDisposition, pRdrRef->ActiveState());
        break;

    default:
        throw (DWORD)SCARD_E_INVALID_VALUE;
    }

    if (!pReader->ShareReader())
        throw (DWORD)SCARD_E_NOT_TRANSACTED;
    CalaisInfo(
        __SUBROUTINE__,
        DBGT("End Transaction, TID = %1"),
        szTid);
    ComEndTransaction::CObjEndTransaction_response *pRsp
        = pCom->InitResponse(0);
    pRsp->dwStatus = SCARD_S_SUCCESS;
    ASSERT(!pReader->IsLatchedByMe());
}


/*++

DoStatus:

    This method performs the Status service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoStatus")

void
CServiceThread::DoStatus(
    ComStatus *pCom)
{
    CBuffer bfAtr;
    LPCTSTR szName;
    DWORD dwNameLen;
    ComStatus::CObjStatus_request *pReq
        = (ComStatus::CObjStatus_request *)pCom->Request();
    DWORD dwIndex = (DWORD)pReq->hCard;
    CReaderReference * pRdrRef = m_rgpReaders[dwIndex];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_HANDLE;
    CReader *pReader = pRdrRef->Reader();

    szName = pReader->ReaderName();
    dwNameLen = (lstrlen(szName) + 1) * sizeof(TCHAR);
    pReader->Atr(bfAtr);

    ComStatus::CObjStatus_response *pRsp
        = pCom->InitResponse(36 + dwNameLen);   // Room for an ATR.
    pRsp->dwState = pReader->GetReaderState(
                pRdrRef->ActiveState());
    pRsp->dwProtocol = pReader->Protocol();
    pRsp = (ComStatus::CObjStatus_response *)
        pCom->Append(pRsp->dscAtr, bfAtr.Access(), bfAtr.Length());
    pRsp = (ComStatus::CObjStatus_response *)
        pCom->Append(pRsp->dscSysName, szName, dwNameLen);
    pRsp->dwStatus = SCARD_S_SUCCESS;
    ASSERT(!pReader->IsLatchedByMe());
}


/*++

DoTransmit:

    This method performs the Transmit service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoTransmit")

void
CServiceThread::DoTransmit(
    ComTransmit *pCom)
{
    CBuffer bfSendData;
    CBuffer bfRecvData;
    LPCBYTE pbSendData;
    DWORD dwLen;
    SCARD_IO_REQUEST *pioReq;
    ComTransmit::CObjTransmit_request *pReq
        = (ComTransmit::CObjTransmit_request *)pCom->Request();
    CReaderReference *pRdrRef = m_rgpReaders[H2L(pReq->hCard)];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    pioReq = (SCARD_IO_REQUEST *)pCom->Parse(pReq->dscSendPci, &dwLen);
    if (dwLen < sizeof(SCARD_IO_REQUEST))
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Transmit data request too small."));
        throw (DWORD)SCARD_F_COMM_ERROR;
    }
    if (dwLen != pioReq->cbPciLength)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Transmit Request PCI length exceeds data."));
        throw (DWORD)SCARD_F_COMM_ERROR;
    }
    if (0 != (dwLen % sizeof(DWORD)))
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Badly formed Transmit Request PCI data."));
        throw (DWORD)SCARD_E_INVALID_VALUE;
    }
    pbSendData = (LPCBYTE)pCom->Parse(pReq->dscSendBuffer, &dwLen);
    bfSendData.Presize(pioReq->cbPciLength + dwLen);
    if (0 != pReq->dwRecvLength)
        bfRecvData.Presize(pReq->dwPciLength + pReq->dwRecvLength);
    else
        bfRecvData.Presize(pReq->dwPciLength + g_dwDefaultIOMax);

    CReader *pReader = pRdrRef->Reader();
    if (0 == pioReq->dwProtocol)
        pioReq->dwProtocol = pReader->Protocol();
    bfSendData.Set((LPCBYTE)pioReq, pioReq->cbPciLength);
    bfSendData.Append(pbSendData, dwLen);
    try
    {
        pReader->ReaderTransmit(
            pRdrRef->ActiveState(),
            bfSendData.Access(),
            bfSendData.Length(),
            bfRecvData);
    }
    catch (DWORD dwErr)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Card Transmission Error reported: %1"),
            dwErr);
#ifdef SCARD_E_COMM_DATA_LOST
        if (ERROR_SEM_TIMEOUT == dwErr)
            dwErr = SCARD_E_COMM_DATA_LOST;
#endif
        throw dwErr;
    }
    catch (...)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Card Transmission exception reported"));
        throw (DWORD)SCARD_F_UNKNOWN_ERROR;
    }

    if (bfRecvData.Length() < sizeof(SCARD_IO_REQUEST))
    {
        CalaisError(__SUBROUTINE__, 308, pReader->ReaderName());
        throw (DWORD)SCARD_F_INTERNAL_ERROR;
    }
    pioReq = (SCARD_IO_REQUEST *)bfRecvData.Access();
    if (bfRecvData.Length() < pioReq->cbPciLength)
    {
        CalaisError(__SUBROUTINE__, 309, pReader->ReaderName());
        throw (DWORD)SCARD_F_INTERNAL_ERROR;
    }

    ComTransmit::CObjTransmit_response *pRsp
        = pCom->InitResponse(pioReq->cbPciLength + sizeof(DWORD));
    pRsp = (ComTransmit::CObjTransmit_response *)pCom->Append(
                pRsp->dscRecvPci,
                (LPCBYTE)pioReq,
                pioReq->cbPciLength);
    pRsp = (ComTransmit::CObjTransmit_response *)pCom->Append(
                pRsp->dscRecvBuffer,
                bfRecvData.Access(pioReq->cbPciLength),
                bfRecvData.Length() - pioReq->cbPciLength);
    pRsp->dwStatus = SCARD_S_SUCCESS;
    ASSERT(!pReader->IsLatchedByMe());
}


/*++

DoControl:

    This method performs the Control service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoControl")

void
CServiceThread::DoControl(
    ComControl *pCom)
{
    LPCBYTE pbInData;
    DWORD cbInData, dwSts, dwLen;
    CBuffer bfOutData(g_dwDefaultIOMax);
    ComControl::CObjControl_request *pReq
        = (ComControl::CObjControl_request *)pCom->Request();
    CReaderReference *pRdrRef = m_rgpReaders[H2L(pReq->hCard)];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    pbInData = (LPCBYTE)pCom->Parse(pReq->dscInBuffer, &cbInData);
    bfOutData.Presize(pReq->dwOutLength);

    CReader *pRdr = pRdrRef->Reader();
    dwLen = bfOutData.Space();
    dwSts = pRdr->Control(
                pRdrRef->ActiveState(),
                pReq->dwControlCode,
                pbInData,
                cbInData,
                bfOutData.Access(),
                &dwLen);
    if (ERROR_SUCCESS != dwSts)
        throw dwSts;
    bfOutData.Resize(dwLen, TRUE);

    ComControl::CObjControl_response *pRsp
        = pCom->InitResponse(pReq->dwOutLength);
    pRsp = (ComControl::CObjControl_response *)pCom->Append(
                pRsp->dscOutBuffer,
                bfOutData.Access(),
                bfOutData.Length());
    pRsp->dwStatus = SCARD_S_SUCCESS;
    ASSERT(!pRdr->IsLatchedByMe());
}


/*++

DoGetAttrib:

    This method performs the GetAttrib service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoGetAttrib")

void
CServiceThread::DoGetAttrib(
    ComGetAttrib *pCom)
{
    CBuffer bfOutData(g_dwDefaultIOMax);
    ComGetAttrib::CObjGetAttrib_request *pReq
        = (ComGetAttrib::CObjGetAttrib_request *)pCom->Request();
    CReaderReference *pRdrRef = m_rgpReaders[H2L(pReq->hCard)];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    bfOutData.Presize(pReq->dwOutLength);

    CReader *pRdr = pRdrRef->Reader();
    switch (pReq->dwAttrId)
    {
#ifdef UNICODE
    case SCARD_ATTR_DEVICE_SYSTEM_NAME_A:
    case SCARD_ATTR_DEVICE_FRIENDLY_NAME_A:
#else
    case SCARD_ATTR_DEVICE_SYSTEM_NAME_W:
    case SCARD_ATTR_DEVICE_FRIENDLY_NAME_W:
#endif
    case SCARD_ATTR_DEVICE_FRIENDLY_NAME:
        throw (DWORD)SCARD_E_INVALID_VALUE;
        break;
    case SCARD_ATTR_DEVICE_SYSTEM_NAME:
    {
        LPCTSTR szName = pRdr->ReaderName();
        bfOutData.Set(
            (LPCBYTE)szName,
            (lstrlen(szName) + 1) * sizeof(TCHAR));
        break;
    }
    default:
        pRdr->GetReaderAttr(
                    pRdrRef->ActiveState(),
                    pReq->dwAttrId,
                    bfOutData);
    }

    ComGetAttrib::CObjGetAttrib_response *pRsp
        = pCom->InitResponse(pReq->dwOutLength);

    pRsp = (ComGetAttrib::CObjGetAttrib_response *)pCom->Append(
                pRsp->dscAttr,
                bfOutData.Access(),
                bfOutData.Length());
    pRsp->dwStatus = SCARD_S_SUCCESS;
    ASSERT(!pRdr->IsLatchedByMe());
}


/*++

DoSetAttrib:

    This method performs the SetAttrib service on behalf of the client.

Arguments:

    pCom supplies the Communications Object being processed.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/6/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CServiceThread::DoSetAttrib")

void
CServiceThread::DoSetAttrib(
    ComSetAttrib *pCom)
{
    LPCBYTE pbAttr;
    DWORD cbAttr;
    ComSetAttrib::CObjSetAttrib_request *pReq
        = (ComSetAttrib::CObjSetAttrib_request *)pCom->Request();
    CReaderReference *pRdrRef = m_rgpReaders[H2L(pReq->hCard)];
    if (NULL == pRdrRef)
        throw (DWORD)SCARD_E_INVALID_VALUE;
    pbAttr = (LPCBYTE)pCom->Parse(pReq->dscAttr, &cbAttr);

    CReader *pRdr = pRdrRef->Reader();
    pRdr->SetReaderAttr(
                pRdrRef->ActiveState(),
                pReq->dwAttrId,
                pbAttr,
                cbAttr);

    ComSetAttrib::CObjSetAttrib_response *pRsp
        = pCom->InitResponse(0);
    pRsp->dwStatus = SCARD_S_SUCCESS;
    ASSERT(!pRdr->IsLatchedByMe());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\server\driver.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    driver

Abstract:

    This file implements the driver subclass of the reader class.  This subclass
    is specific to drivers conforming to the PC/SC and Calais specifications.

Author:

    Doug Barlow (dbarlow) 6/3/1997

Environment:

    Win32, C++

Notes:

    This subclass uses interrupts to monitor insertion and removal events.

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#ifndef _WIN32_WINDOWS
#define _WIN32_WINDOWS 0x0400
#endif

#include <windows.h>
#include <stdlib.h>
#include <dbt.h>
#include <setupapi.h>
#include <CalServe.h>

#define MONITOR_MAX_TRIES 3     // We'll try waiting for a card 3 times before
                                // we kill the thread.
#define SCARD_IO_TIMEOUT 15000  // Maximum time to allow for an I/O operation
                                // before complaining.
#define POWERDOWN_TIMEOUT 15    // Number of seconds to wait before powering
                                // down a newly inserted but unused card.
#ifdef DBG
#define SCARD_TRACE_ENABLED
static LPCTSTR MapIoControlCodeToString(ULONG IoControlCode);
#endif

#ifdef SCARD_TRACE_ENABLED
typedef struct {
    DWORD dwStructLen;      // Actual structure length
    SYSTEMTIME StartTime;   // Time request was posted
    SYSTEMTIME EndTime;     // Time request completed
    DWORD dwProcId;         // Process Id
    DWORD dwThreadId;       // Thread Id
    HANDLE hDevice;         // I/O handle
    DWORD dwIoControlCode;  // I/O control code issued
    DWORD nInBuffer;        // Offset to input buffer
    DWORD nInBufferSize;    // Input buffer size
    DWORD nOutBuffer;       // Offset to output buffer
    DWORD nOutBufferSize;   // Size of user's receive buffer
    DWORD nBytesReturned;   // Actual size of returned data
    DWORD dwStatus;         // Returned status code
                            // InBuffer and OutBuffer follow.
} RequestTrace;
#endif

static const GUID l_guidSmartcards
                        = { // 50DD5230-BA8A-11D1-BF5D-0000F805F530
                            0x50DD5230,
                            0xBA8A,
                            0x11D1,
                            { 0xBF, 0x5D, 0x00, 0x00, 0xF8, 0x05, 0xF5, 0x30 } };
static const LARGE_INTEGER l_ftPowerdownTime
                        = { (DWORD)(-(POWERDOWN_TIMEOUT * 10000000)), -1 };
static DWORD l_dwMaxWdmReaders = 0;


/*++

AddAllWdmDrivers:

    This routine adds all the PC/SC compliant WDM drivers and
    non-interrupting drivers that it can find into the Resource Manager.

Arguments:

    None

Return Value:

    The number of readers added

Author:

    Doug Barlow (dbarlow) 6/11/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AddAllWdmDrivers")

DWORD
AddAllWdmDrivers(
    void)
{
    if (0 == l_dwMaxWdmReaders)
    {
        l_dwMaxWdmReaders = MAXIMUM_SMARTCARD_READERS;

        try
        {
            CRegistry regCalais(
                        HKEY_LOCAL_MACHINE,
                        CalaisString(CALSTR_CALAISREGISTRYKEY),
                        KEY_READ,
                        REG_OPTION_EXISTS);
            l_dwMaxWdmReaders = regCalais.GetNumericValue(
                                    CalaisString(CALSTR_MAXLEGACYDEVICES));
        }
        catch (...) {}
    }

    LPCTSTR szDevHeader = CalaisString(CALSTR_LEGACYDEVICEHEADER);
    LPCTSTR szDevName = CalaisString(CALSTR_LEGACYDEVICENAME);
    DWORD cchDevHeader = lstrlen(szDevHeader);
    DWORD cchDevName = lstrlen(szDevName);
    TCHAR szDevice[MAX_PATH];
    DWORD dwSts, dwIndex, dwCount = 0;
    int nSts;


    //
    // Look for usable devices.
    //

    for (dwIndex = 0; dwIndex < l_dwMaxWdmReaders; dwIndex += 1)
    {
        nSts = wsprintf(
                    szDevice,
                    TEXT("%s%s%lu"),
                    szDevHeader,
                    szDevName,
                    dwIndex);
        if (0 >= nSts)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Server control cannot build device name:  %1"),
                GetLastError());
            continue;
        }

        dwSts = AddReaderDriver(szDevice, 0);
        if (ERROR_SUCCESS != dwSts)
            continue;
        dwCount += 1;
    }
    return dwCount;
}


/*++

AddAllPnPDrivers:

    This routine adds all the PC/SC compliant PnP drivers that it can find into
    the Resource Manager.

Arguments:

    None

Return Value:

    The number of readers added

Author:

    Doug Barlow (dbarlow) 3/26/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AddAllPnPDrivers")

DWORD
AddAllPnPDrivers(
    void)
{
#if 0
    DWORD dwSts;
    BOOL fSts;
    HDEVINFO hDevInfoSet = INVALID_HANDLE_VALUE;
    SP_DEVICE_INTERFACE_DATA DeviceData;
    DWORD dwIndex;
    DWORD dwLength;
    DWORD dwCount = 0;
    LPCTSTR szDevice;
    GUID guidSmartcards;


    //
    // Get a list of PnP Smart Card Readers on this system.
    //

    try
    {
        CBuffer bfDevDetail;
        PSP_DEVICE_INTERFACE_DETAIL_DATA pDevDetail;

        CopyMemory(&guidSmartcards, &l_guidSmartcards, sizeof(GUID));
        hDevInfoSet = SetupDiGetClassDevs(
            &guidSmartcards,
            NULL,
            NULL,
            DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
        if (INVALID_HANDLE_VALUE == hDevInfoSet)
        {
            dwSts = GetLastError();
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Server control cannot enumerate PnP devices:  %1"),
                dwSts);
            throw dwSts;
        }

        bfDevDetail.Resize(sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA));
        for (dwIndex = 0;; dwIndex += 1)
        {
            try
            {

                //
                // Get one device at a time.
                //

                ZeroMemory(&DeviceData, sizeof(DeviceData));
                DeviceData.cbSize = sizeof(DeviceData);
                fSts = SetupDiEnumDeviceInterfaces(
                    hDevInfoSet,
                    NULL,
                    &guidSmartcards,
                    dwIndex,
                    &DeviceData);
                if (!fSts)
                {
                    dwSts = GetLastError();
                    if (ERROR_NO_MORE_ITEMS == dwSts)
                        break;
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Server control failed device enumeration:  %1"),
                        dwSts);
                    continue;
                }


                //
                // Get the device name.
                //

                do
                {
                    ZeroMemory(
                        bfDevDetail.Access(),
                        bfDevDetail.Space());
                    pDevDetail =
                        (PSP_DEVICE_INTERFACE_DETAIL_DATA)bfDevDetail.Access();
                    pDevDetail->cbSize =
                        sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                    fSts = SetupDiGetDeviceInterfaceDetail(
                        hDevInfoSet,
                        &DeviceData,
                        pDevDetail,
                        bfDevDetail.Space(),
                        &dwLength,
                        NULL);
                    if (!fSts)
                    {
                        dwSts = GetLastError();
                        if (ERROR_INSUFFICIENT_BUFFER != dwSts)
                        {
                            CalaisWarning(
                                __SUBROUTINE__,
                                DBGT("Server control failed to get PnP device details:  %1"),
                                dwSts);
                            throw dwSts;
                        }
                    }
                    bfDevDetail.Resize(dwLength, fSts);
                } while (!fSts);
                szDevice = pDevDetail->DevicePath;


                //
                // Start the device.
                //

                dwSts = CalaisAddReader(szDevice, RDRFLAG_PNPMONITOR);
                if (ERROR_SUCCESS == dwSts)
                    dwCount += 1;
            }
            catch (...) {}
        }
        fSts = SetupDiDestroyDeviceInfoList(hDevInfoSet);
        hDevInfoSet = INVALID_HANDLE_VALUE;
        if (!fSts)
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Server control cannot destroy PnP device enumeration:  %1"),
                GetLastError());
    }
    catch (...)
    {
        if (INVALID_HANDLE_VALUE != hDevInfoSet)
        {
            fSts = SetupDiDestroyDeviceInfoList(hDevInfoSet);
            if (!fSts)
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Server control cannot destroy PnP device enumeration:  %1"),
                    GetLastError());
        }
    }
    return dwCount;
#else
    DWORD dwIndex, dwSubindex, dwSts, dwCount = 0;
    LPCTSTR szBus, szPort, szDevice;
    CRegistry regBus, regPort;
    CRegistry regPnPList(HKEY_LOCAL_MACHINE, CalaisString(CALSTR_PNPDEVICEREGISTRYKEY), KEY_READ);


    //
    // Look for usable devices.
    //


    for (dwIndex = 0;; dwIndex += 1)
    {
        try
        {
            szBus = regPnPList.Subkey(dwIndex);
            if (NULL == szBus)
                break;
            regBus.Open(regPnPList, szBus, KEY_READ);
            for (dwSubindex = 0;; dwSubindex += 1)
            {
                try
                {
                    szPort = regBus.Subkey(dwSubindex);
                }
                catch (...)
                {
                    szPort = NULL;
                }
                if (NULL == szPort)
                    break;
                try
                {
                    regPort.Open(regBus, szPort, KEY_READ);
                    szDevice = regPort.GetStringValue(
                                    CalaisString(CALSTR_SYMBOLICLINKSUBKEY));
                    if (NULL != szDevice)
                        dwSts = CalaisAddReader(szDevice, RDRFLAG_PNPMONITOR);
                    if (ERROR_SUCCESS == dwSts)
                        dwCount += 1;
                    regPort.Close();
                }
                catch (...)
                {
                    regPort.Close();
                }
            }
            regBus.Close();
        }
        catch (...)
        {
            regBus.Close();
            szBus = NULL;
        }
        if (NULL == szBus)
            break;
    }
    return dwCount;
#endif
}


/*++

AddReaderDriver:

    This routine adds a given driver by name.

Arguments:

    szDevice supplies the device name of the reader to be added.

    dwFlags supplies the set of flags requested for this reader.

Return Value:

    A status code as a DWORD value.  ERROR_SUCCESS implies success.

Author:

    Doug Barlow (dbarlow) 3/26/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("AddReaderDriver")

DWORD
AddReaderDriver(
    IN LPCTSTR szDevice,
    IN DWORD dwFlags)
{
    CHandleObject hReader(DBGT("Reader to be added in AddReaderDriver"));
    CReader *pRdr = NULL;
    DWORD dwReturn = ERROR_SUCCESS;

    try
    {
        DWORD dwSts;


        //
        // See if we can get to the reader.
        //

        hReader = CreateFile(
                    szDevice,
                    GENERIC_READ | GENERIC_WRITE,
                    0,      // No sharing
                    NULL,   // No inheritance
                    OPEN_EXISTING,
                    FILE_FLAG_OVERLAPPED,
                    NULL);
        if (!hReader.IsValid())
        {
            dwSts = hReader.GetLastError();
            if ((ERROR_BAD_DEVICE != dwSts)
                && (ERROR_BAD_UNIT != dwSts)
                && (ERROR_FILE_NOT_FOUND != dwSts))
                CalaisError(__SUBROUTINE__, 602, dwSts);
            // throw dwSts;
            return dwSts;   // More efficient.
        }

        pRdr = new CReaderDriver(
                        hReader,
                        szDevice,
                        dwFlags);
        if (NULL == pRdr)
        {
            CalaisError(__SUBROUTINE__, 603, szDevice);
            return (DWORD)SCARD_E_NO_MEMORY;
        }
        if (pRdr->InitFailed())
        {
            CalaisError(__SUBROUTINE__, 611);
            delete pRdr;
            pRdr = NULL;
            return (DWORD) SCARD_E_NO_MEMORY;
        }
        hReader.Relinquish();


        //
        // Finalize initialization.
        //

        pRdr->Initialize();
        dwSts = CalaisAddReader(pRdr);
        if (SCARD_S_SUCCESS != dwSts)
            throw dwSts;
        pRdr = NULL;


        //
        // Clean up.
        //

        ASSERT(!hReader.IsValid());
        ASSERT(NULL == pRdr);
    }
    catch (DWORD dwError)
    {
        if (hReader.IsValid())
            hReader.Close();
        if (NULL != pRdr)
            delete pRdr;
        dwReturn = dwError;
    }
    catch (...)
    {
        if (hReader.IsValid())
            hReader.Close();
        if (NULL != pRdr)
            delete pRdr;
        dwReturn = SCARD_F_UNKNOWN_ERROR;
    }

    return dwReturn;
}


#ifdef DBG
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("MapIoControlCodeToString")
static LPCTSTR
MapIoControlCodeToString(
    ULONG IoControlCode
    )
{
    ULONG i;

    static const struct {

        ULONG   IoControlCode;
        LPCTSTR String;

    } IoControlList[] = {

        IOCTL_SMARTCARD_POWER,          TEXT("POWER"),
        IOCTL_SMARTCARD_GET_ATTRIBUTE,  TEXT("GET_ATTRIBUTE"),
        IOCTL_SMARTCARD_SET_ATTRIBUTE,  TEXT("SET_ATTRIBUTE"),
        IOCTL_SMARTCARD_CONFISCATE,     TEXT("CONFISCATE"),
        IOCTL_SMARTCARD_TRANSMIT,       TEXT("TRANSMIT"),
        IOCTL_SMARTCARD_EJECT,          TEXT("EJECT"),
        IOCTL_SMARTCARD_SWALLOW,        TEXT("SWALLOW"),
        IOCTL_SMARTCARD_IS_PRESENT,     TEXT("IS_PRESENT"),
        IOCTL_SMARTCARD_IS_ABSENT,      TEXT("IS_ABSENT"),
        IOCTL_SMARTCARD_SET_PROTOCOL,   TEXT("SET_PROTOCOL"),
        IOCTL_SMARTCARD_GET_STATE,      TEXT("GET_STATE"),
        IOCTL_SMARTCARD_GET_LAST_ERROR, TEXT("GET_LAST_ERROR")
    };

    for (i = 0; i < sizeof(IoControlList) / sizeof(IoControlList[0]); i++) {

        if (IoControlCode == IoControlList[i].IoControlCode) {

            return IoControlList[i].String;
        }
    }

    return TEXT("*** UNKNOWN ***");
}
#endif


//
//==============================================================================
//
//  CReaderDriver
//

/*++

CReaderDriver:

    This is the constructor for a CReaderDriver class.  It just zeroes out the
    data structures in preparation for the Initialize call.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::CReaderDriver")

CReaderDriver::CReaderDriver(
    HANDLE hReader,
    LPCTSTR szDevice,
    DWORD dwFlags)
:   m_bfDosDevice(),
    m_hReader(DBGT("CReaderDriver's reader handle")),
    m_hThread(DBGT("CReaderDriver's Thread Handle")),
    m_hRemoveEvent(DBGT("CReaderDriver's Remove Event")),
    m_hOvrWait(DBGT("CReaderDriver's Overlapped I/O completion event"))
{
    // don't do any initialization if the CReader object failed
    // to initialize correctly
    if (InitFailed())
        return;

    Clean();
    m_bfDosDevice.Set(
        (LPBYTE)szDevice,
        (lstrlen(szDevice) + 1) * sizeof(TCHAR));
    m_hReader = hReader;
    m_dwCapabilities = 0;
    m_dwFlags |= dwFlags;
}


/*++

~CReaderDriver:

    This is the destructor for the reader class.  It just uses the Close service
    to shut down.  Note that it is *NOT* declared virtual, in order to improve
    performance.  Should it be desirable to subclass this class, this will have
    to change.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::~CReaderDriver")

CReaderDriver::~CReaderDriver()
{
    if (InitFailed())
        return;

    TakeoverReader();
    Close();
}


/*++

Clean:

    This routine is used to initialize all the property values.  It does *NOT*
    do any deallocation or locking!  Use Close() for that.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::Clean")

void
CReaderDriver::Clean(
    void)
{
    m_pvAppControl = NULL;
    m_dwThreadId = 0;
    m_bfDosDevice.Reset();
    ZeroMemory(&m_ovrlp, sizeof(m_ovrlp));
    ASSERT(m_dwAvailStatus == Inactive);
    // CReader::Clean();
}


/*++

Close:

    This routine does the work of closing down a CReaderDriver class, and
    returning it to it's default state.  It does not assume any particular
    state, other than that the class has been Clean()ed once (at construction).

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::Close")

void
CReaderDriver::Close(
    void)
{
    AppUnregisterDevice(m_hReader, DosDevice(), &m_pvAppControl);
    if (m_hReader.IsValid())
        CReader::Close();
    if (m_hThread.IsValid())
    {
        ASSERT(m_hRemoveEvent.IsValid());
        if (!SetEvent(m_hRemoveEvent))
        {
            DWORD dwErr = GetLastError();
            CalaisError(__SUBROUTINE__, 604, dwErr);
        }
        WaitForever(
            m_hThread,
            CALAIS_THREAD_TIMEOUT,
            DBGT("Waiting for Reader Driver thread %2: %1"),
            m_dwThreadId);
        m_hThread.Close();
        m_hRemoveEvent.Close();
    }

    if (m_hReader.IsValid())
        m_hReader.Close();
    if (m_hRemoveEvent.IsValid())
        m_hRemoveEvent.Close();
    if (m_hOvrWait.IsValid())
        m_hOvrWait.Close();
    Clean();
}


/*++

Initialize:

    This method initializes a clean CReaderDriver object to a running state.

Arguments:

    None

Return Value:

    None

Throws:

    Errors as DWORD status codes

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::Initialize")

void
CReaderDriver::Initialize(
    void)
{
    ASSERT(m_hReader.IsValid());
    ASSERT(!m_hRemoveEvent.IsValid());
    ASSERT(NULL == m_ovrlp.hEvent);

    try
    {
        DWORD dwSts;


        //
        // Prep the Overlapped structure.
        //

        m_hOvrWait = m_ovrlp.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!m_hOvrWait.IsValid())
        {
            dwSts = m_hOvrWait.GetLastError();
            CalaisError(__SUBROUTINE__, 605, dwSts);
            throw dwSts;
        }


        //
        // Determine the characteristics.
        //

        try
        {
            CLatchReader latch(this);
            m_dwCapabilities = GetReaderAttr(SCARD_ATTR_CHARACTERISTICS);
        }
        catch (...)
        {
            m_dwCapabilities = SCARD_READER_EJECTS;   // Safe assumption
        }


        //
        // Do common initialization.
        //

        CReader::Initialize();
        if (0 != (m_dwFlags & RDRFLAG_PNPMONITOR))
            AppRegisterDevice(m_hReader, DosDevice(), &m_pvAppControl);


        //
        // Kick off the monitor thread.
        //

        m_hRemoveEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!m_hRemoveEvent.IsValid())
        {
            dwSts = m_hRemoveEvent.GetLastError();
            CalaisError(__SUBROUTINE__, 606, dwSts);
            throw dwSts;
        }
        m_hThread = CreateThread(
                        NULL,   // Not inheritable
                        CALAIS_STACKSIZE,   // Default stack size
                        MonitorReader,
                        this,
                        CREATE_SUSPENDED,
                        &m_dwThreadId);
        if (!m_hThread.IsValid())
        {
            dwSts = m_hThread.GetLastError();
            CalaisError(__SUBROUTINE__, 607, dwSts);
            throw dwSts;
        }
        if ((DWORD)(-1) == ResumeThread(m_hThread))
        {
            dwSts = GetLastError();
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Monitor Thread won't resume:  %1"),
                dwSts);
        }
    }

    catch (...)
    {
        Close();
        throw;
    }
}


/*++

Disable:

    This method releases any physical resources associated with the reader
    object, and marks the object offline.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORDs

Author:

    Doug Barlow (dbarlow) 4/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::Disable")

void
CReaderDriver::Disable(
    void)
{
    DWORD dwSts;

    CReader::Disable();
    ASSERT(m_hRemoveEvent.IsValid());
    if (!SetEvent(m_hRemoveEvent))
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Reader Driver Disable can't notify '%2's monitor thread: %1"),
            GetLastError(),
            ReaderName());
    if (m_hThread.IsValid())
    {
        dwSts = WaitForAnObject(m_hThread, CALAIS_THREAD_TIMEOUT);
        if (ERROR_SUCCESS != dwSts)
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Abandoning wait for Reader Driver Disable: Closing reader %1"),
                ReaderName());
    }
    CalaisWarning(
        __SUBROUTINE__,
        DBGT("Reader Driver Disable: Closing reader %1"),
        ReaderName());
    CLockWrite rwLock(&m_rwLock);
    if (m_hReader.IsValid())
        m_hReader.Close();
}


/*++

ReaderHandle:

    This method returns a designated value identifying the reader.  The actual
    value is dependent on the object's type and state, and is not guaranteed to
    be unique among readers.

Arguments:

    None

Return Value:

    The designated handle of this reader.

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::ReaderHandle")

HANDLE
CReaderDriver::ReaderHandle(
    void)
const
{
    if (m_hReader.IsValid())
        return m_hReader.Value();
    else
        return m_pvAppControl;  // A bit of magic to help find closed readers.
}


/*++

DeviceName:

    This method returns any low level name associated with the reader.

Arguments:

    None

Return Value:

    The low level name of the reader.

Author:

    Doug Barlow (dbarlow) 4/15/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::DeviceName")

LPCTSTR
CReaderDriver::DeviceName(
    void)
const
{
    return DosDevice();
}


/*++

Control:

    This method performs an I/O control operation on the reader.

Arguments:

    dwCode supplies the IOCTL code to be performed.

    pbSend supplies the buffer to be sent to the reader.

    cbSend supplies the length of the buffer to be sent, in bytes.

    pbRecv receives the data returned from the reader.

    cbRecv supplies the length of the receive buffer, in bytes.

    pcbRecv receives the actual length of the receive buffer used, in bytes.

    fLogError supplies a boolean indicator as to whether or not to log any errors
        that may occur.

Return Value:

    The returned status indication.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/26/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::Control")

DWORD
CReaderDriver::Control(
    DWORD dwCode,
    LPCBYTE pbSend,
    DWORD cbSend,
    LPBYTE pbRecv,
    LPDWORD pdwLen,
    BOOL fLogError)
{
    DWORD dwStatus;
    DWORD dwSpace, dwLength;

    ASSERT(IsLatchedByMe());
    if (NULL == pdwLen)
    {
        dwSpace = 0;
        pdwLen = &dwLength;
    }
    else
        dwSpace = *pdwLen;
    *pdwLen = 0;

    dwStatus = SyncIoControl(
                    dwCode,
                    (LPVOID)pbSend,
                    cbSend,
                    pbRecv,
                    dwSpace,
                    pdwLen,
                    fLogError);
    if ((ERROR_SUCCESS != dwStatus) && fLogError)
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Driver '%2' returned error code to control request:  %1"),
            dwStatus,
            ReaderName());
    }
    return dwStatus;
}


/*++

SyncIoControl:

    This service performs a synchronous I/O control service, blocking out other
    access.

Arguments:

    dwIoControlCodesupplies the control code of the operation to perform

    lpInBuffersupplies a pointer to buffer to supply input data

    nInBufferSize supplies the size of input buffer

    lpOutBuffer receives any output data

    nOutBufferSize supplies the size of output buffer

    lpBytesReturned receives the output byte count

    lpOverlapped supplies the overlapped structure for asynchronous operation

    fLogError supplies a boolean indicator as to whether or not to log any errors
        that may occur.

Return Value:

    ERROR_SUCCESS if all went well, otherwise the error code.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/17/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReaderDriver::SyncIoControl")

DWORD
CReaderDriver::SyncIoControl(
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    BOOL fLogError)
{
    DWORD dwReturn = ERROR_SUCCESS;
    BOOL fSts;

#ifdef SCARD_TRACE_ENABLED
    static DWORD l_cbStructLen = 0;
    static LPBYTE l_pbStruct = NULL;

    DWORD cbTraceStruct = sizeof(RequestTrace) + nInBufferSize + nOutBufferSize;
    RequestTrace *prqTrace;
    LPBYTE pbData;
    HANDLE hLogFile = INVALID_HANDLE_VALUE;

    try
    {
        if (NULL == l_pbStruct)
        {
            l_pbStruct = (LPBYTE)malloc(cbTraceStruct);
            if (NULL == l_pbStruct)
            {
                DWORD dwErr = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Can't allocate trace buffer: %1"),
                    dwErr);
                throw dwErr;

            }
            l_cbStructLen = cbTraceStruct;
        }
        else
        {
            if (l_cbStructLen < cbTraceStruct)
            {
                free(l_pbStruct);
                l_pbStruct = (LPBYTE)malloc(cbTraceStruct);
                if (NULL == l_pbStruct)
                {
                    DWORD dwErr = GetLastError();
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Can't enlarge trace buffer: %1"),
                        dwErr);
                    throw dwErr;

                }
                l_cbStructLen = cbTraceStruct;
            }
        }

        prqTrace = (RequestTrace *)l_pbStruct;
        pbData = l_pbStruct + sizeof(RequestTrace);
        GetLocalTime(&prqTrace->StartTime);
        prqTrace->dwProcId = GetCurrentProcessId();
        prqTrace->dwThreadId = GetCurrentThreadId();
        prqTrace->hDevice = m_hReader;
        prqTrace->dwIoControlCode = dwIoControlCode;
        CopyMemory(pbData, lpInBuffer, nInBufferSize);
        prqTrace->nInBuffer = (DWORD)(pbData - (LPBYTE)prqTrace);
        prqTrace->nInBufferSize = nInBufferSize;
        pbData += nInBufferSize;
        prqTrace->nOutBufferSize = nOutBufferSize;
    }
    catch (...)
    {
        if (NULL != l_pbStruct)
            free(l_pbStruct);
        l_pbStruct = NULL;
        l_cbStructLen = 0;
    }
#endif

    ASSERT(IsLatchedByMe());
    if (m_hReader.IsValid())
    {
        fSts = DeviceIoControl(
                    m_hReader,
                    dwIoControlCode,
                    lpInBuffer,
                    nInBufferSize,
                    lpOutBuffer,
                    nOutBufferSize,
                    lpBytesReturned,
                    &m_ovrlp);
        if (!fSts)
        {
            DWORD dwSts;

            dwSts = GetLastError();
            if (ERROR_IO_PENDING == dwSts)
            {
                for (;;)
                {
                    dwSts = WaitForAnObject(m_ovrlp.hEvent, SCARD_IO_TIMEOUT);
                    if (ERROR_SUCCESS == dwSts)
                        break;
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("I/O wait on device '%2' has timed out: %1"),
                        dwSts,
                        ReaderName());
                }
                fSts = GetOverlappedResult(
                    m_hReader,
                    &m_ovrlp,
                    lpBytesReturned,
                    TRUE);
                if (!fSts)
                    dwReturn = GetLastError();
            }
            else
                dwReturn = dwSts;
        }
    }
    else
    {
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("I/O attempted to Reader '%1' with handle INVALID"),
            ReaderName());
        dwReturn = ERROR_DEVICE_REMOVED;
    }

#ifdef SCARD_TRACE_ENABLED
    if (0 < l_cbStructLen)
    {
        GetLocalTime(&prqTrace->EndTime);
        prqTrace->dwStatus = dwReturn;
        prqTrace->nOutBuffer = (DWORD)(pbData - (LPBYTE)prqTrace);
        prqTrace->nBytesReturned = *lpBytesReturned;
        CopyMemory(pbData, lpOutBuffer, *lpBytesReturned);
        prqTrace->dwStructLen = sizeof(RequestTrace)
            + nInBufferSize + *lpBytesReturned;

        LockSection(
            g_pcsControlLocks[CSLOCK_TRACELOCK],
            DBGT("Logging Synchronous I/O to the reader"));
        hLogFile = CreateFile(
                        CalaisString(CALSTR_DRIVERTRACEFILENAME),
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
        if (INVALID_HANDLE_VALUE != hLogFile)
        {
            DWORD dwLen;
            dwLen = SetFilePointer(hLogFile, 0, NULL, FILE_END);
            fSts = WriteFile(
                        hLogFile,
                        prqTrace,
                        prqTrace->dwStructLen,
                        &dwLen,
                        NULL);
            CloseHandle(hLogFile);
        }
    }
#endif

    if ((ERROR_SUCCESS != dwReturn) && fLogError)
    {
        TCHAR szIoctl[20];  // Ugly but enough to fit all messages below
        DWORD dwReport = dwReturn;

        switch(dwIoControlCode)
        {
        case IOCTL_SMARTCARD_POWER:
            _tcscpy(szIoctl, _T("POWER"));

                // Remap "The disk media is not recognized. It may not be formatted."
                // to "The smart card is not responding to a reset."
            if (dwReturn == ERROR_UNRECOGNIZED_MEDIA)
                dwReport = SCARD_W_UNRESPONSIVE_CARD;
            break;
        case IOCTL_SMARTCARD_GET_ATTRIBUTE:
            _tcscpy(szIoctl, _T("GET_ATTRIBUTE"));
            break;
        case IOCTL_SMARTCARD_SET_ATTRIBUTE:
            _tcscpy(szIoctl, _T("SET_ATTRIBUTE"));
            break;
        case IOCTL_SMARTCARD_CONFISCATE:
            _tcscpy(szIoctl, _T("CONFISCATE"));
            break;
        case IOCTL_SMARTCARD_TRANSMIT:
            _tcscpy(szIoctl, _T("TRANSMIT"));
            break;
        case IOCTL_SMARTCARD_EJECT:
            _tcscpy(szIoctl, _T("EJECT"));
            break;
        case IOCTL_SMARTCARD_SWALLOW:
            _tcscpy(szIoctl, _T("SWALLOW"));
            break;
        case IOCTL_SMARTCARD_IS_PRESENT:
            _tcscpy(szIoctl, _T("IS_PRESENT"));
            break;
        case IOCTL_SMARTCARD_IS_ABSENT:
            _tcscpy(szIoctl, _T("IS_ABSENT"));
            break;
        case IOCTL_SMARTCARD_SET_PROTOCOL:
            _tcscpy(szIoctl, _T("SET_PROTOCOL"));
            break;
        case IOCTL_SMARTCARD_GET_STATE:
            _tcscpy(szIoctl, _T("GET_STATE"));
            break;
        case IOCTL_SMARTCARD_GET_LAST_ERROR:
            _tcscpy(szIoctl, _T("GET_LAST_ERROR"));
            break;
        case IOCTL_SMARTCARD_GET_PERF_CNTR:
            _tcscpy(szIoctl, _T("GET_PERF_CNTR"));
            break;
        default:
            _tcscpy(szIoctl, _T("0x"));
            _ultot(dwIoControlCode, szIoctl+2, 16);
        }

        CalaisError(
            __SUBROUTINE__,
            610,
            dwReport,
            ReaderName(),
            szIoctl);
        // "Smart Card Reader '%2' rejected IOCTL 0x%3: %1"
    }
    return dwReturn;
}


//
////////////////////////////////////////////////////////////////////////////////
//
//  CReaderDriver friends
//

/*++

MonitorReader:

    This routine monitors card insertion events for a reader, and maintains the
    status flags in the associated CReaderDriver object.

    Since this routine runs as a separate thread, it must grab the reader prior
    to passing requests other than wait functions to it.

Arguments:

    pvParameter supplies the value from the CreateThread call.  In this case,
        it's the address of the associated CReaderDriver object.

Return Value:

    Zero - Normal termination
    One - Abnormal termination

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/5/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("MonitorReader")

DWORD WINAPI
MonitorReader(
    LPVOID pvParameter)
{
    NEW_THREAD;
    BOOL fAllDone = FALSE;
    BOOL fDeleteWhenDone = FALSE;
    BOOL fHardError;
    BOOL fSts;
    DWORD dwRetLen, dwErr, dwTries, dwWait, dwDrvrErr;
    DWORD dwErrRetry = MONITOR_MAX_TRIES;
    CReader::AvailableState avlState;
    CReaderDriver *pRdr = (CReaderDriver *)pvParameter;
    OVERLAPPED ovrWait;
    CHandleObject hOvrWait(DBGT("Overlapped wait event in MonitorReader"));
    CHandleObject hPowerDownTimer(DBGT("Power Down Timer in MonitorReader"));
#ifdef SCARD_TRACE_ENABLED
    RequestTrace rqTrace;
#endif
#ifdef DBG
    static const LPCTSTR l_pchWait[] = {
        TEXT("internal error"), TEXT("power down"), TEXT("io completion"),
        TEXT("shut down"), TEXT("shut down")
    };
#endif

    try
    {

        //
        // Prep work.
        //

        fSts = SetThreadPriority(
                    pRdr->m_hThread,
                    THREAD_PRIORITY_ABOVE_NORMAL);
        if (!fSts)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to prioritize reader '%2' monitor thread: %1"),
                GetLastError(),
                pRdr->ReaderName());
        }
        hOvrWait = ovrWait.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!hOvrWait.IsValid())
        {
            dwErr = hOvrWait.GetLastError();
            CalaisError(__SUBROUTINE__, 609, dwErr);
            throw dwErr;
        }
        hPowerDownTimer = CreateWaitableTimer(NULL, FALSE, NULL);
        if (!hPowerDownTimer.IsValid())
        {
            dwErr = hPowerDownTimer.GetLastError();
            CalaisError(__SUBROUTINE__, 608, dwErr);
            throw dwErr;
        }


        //
        // At startup, declare the reader active.
        //

        {
            CLockWrite rwLock(&pRdr->m_rwLock);
            ASSERT(CReader::Inactive == pRdr->m_dwAvailStatus);
            pRdr->SetAvailabilityStatus(CReader::Idle);
        }
        g_phReaderChangeEvent->Signal();


        //
        // Loop watching for card insertion/removals while the service is
        // running.
        //

        while (!fAllDone)
        {
            try
            {

                //
                // Look for a smartcard insertion.
                //

                dwTries = MONITOR_MAX_TRIES;
                for (;;)
                {
#ifdef SCARD_TRACE_ENABLED
                    GetLocalTime(&rqTrace.StartTime);
                    rqTrace.dwProcId = GetCurrentProcessId();
                    rqTrace.dwThreadId = GetCurrentThreadId();
                    rqTrace.hDevice = pRdr->m_hReader;
                    rqTrace.dwIoControlCode = IOCTL_SMARTCARD_IS_PRESENT;
                    rqTrace.nInBuffer = NULL;
                    rqTrace.nInBufferSize = 0;
                    rqTrace.nOutBufferSize = 0;
#endif
                    ASSERT(!pRdr->IsLatchedByMe());
                    fSts = DeviceIoControl(
                                pRdr->m_hReader,
                                IOCTL_SMARTCARD_IS_PRESENT,
                                NULL, 0,
                                NULL, 0,
                                &dwRetLen,
                                &ovrWait);
                    if (!fSts)
                    {
                        BOOL fErrorProcessed;

                        dwErr = dwDrvrErr = GetLastError();
                        do
                        {
                            fErrorProcessed = TRUE;
                            fHardError = FALSE;
                            switch (dwErr)
                            {

                            //
                            // The driver will let us know.
                            //

                            case ERROR_IO_PENDING:
                                dwWait = WaitForAnyObject(
                                                INFINITE,
                                                ovrWait.hEvent,
                                                pRdr->m_hRemoveEvent.Value(),
                                                g_hCalaisShutdown,
                                                NULL);

                                switch (dwWait)
                                {
                                case 1: // I/O Completed
                                {
                                    pRdr->LatchReader(NULL);
                                    fErrorProcessed = FALSE;
                                    fSts = GetOverlappedResult(
                                                pRdr->m_hReader,
                                                &ovrWait,
                                                &dwRetLen,
                                                TRUE);
                                    if (!fSts)
                                        dwErr = dwDrvrErr = GetLastError();
                                    else
                                        dwErr = dwDrvrErr = ERROR_SUCCESS;
                                    pRdr->Unlatch();
                                    break;
                                }

                                case 2: // Shutdown indicator
                                case 3:
                                    fAllDone = TRUE;
                                    dwErr = ERROR_SUCCESS;
                                    dwDrvrErr = SCARD_P_SHUTDOWN;
                                    break;

                                default:
                                    CalaisWarning(
                                        __SUBROUTINE__,
                                        DBGT("Wait for card insertion returned invalid value"));
                                    throw (DWORD)SCARD_F_INTERNAL_ERROR;
                                }
                                break;


                            //
                            // Success.  Continue monitoring for events.
                            //

                            case ERROR_SUCCESS:         // Success after a wait event.
                                break;


                            //
                            // PnP Shutdown errors -- handle them gracefully.
                            //

                            case ERROR_DEVICE_REMOVED:  // PnP Device yanked out of system
                            case ERROR_DEV_NOT_EXIST:
                            case ERROR_INVALID_FUNCTION:
                                fDeleteWhenDone = TRUE;
                                // Fall through intentionally
                            case ERROR_INVALID_HANDLE:  // We must be shutting down.
                            case ERROR_OPERATION_ABORTED:   // PnP Polite shutdown request
                                fAllDone = TRUE;
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Reader return code takes reader '%2' offline:  %1"),
                                    dwErr,
                                    pRdr->DeviceName());
                                dwErr = ERROR_SUCCESS;
                                break;


                            //
                            // A hard error.  Log it, and declare the device broken.
                            //

                            default:
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Reader insertion monitor failed wait:  %1"),
                                    dwErr);
                                fHardError = TRUE;
                            }
                        } while (!fErrorProcessed);
                    }
                    else
                        dwErr = dwDrvrErr = ERROR_SUCCESS;
#ifdef SCARD_TRACE_ENABLED
                    {
                        GetLocalTime(&rqTrace.EndTime);
                        rqTrace.dwStatus = dwDrvrErr;
                        rqTrace.nOutBuffer = NULL;
                        rqTrace.nBytesReturned = 0;
                        rqTrace.dwStructLen = sizeof(RequestTrace);

                        LockSection(
                            g_pcsControlLocks[CSLOCK_TRACELOCK],
                            DBGT("Logging a card insertion"));
                        HANDLE hLogFile = INVALID_HANDLE_VALUE;

                        hLogFile = CreateFile(
                                        CalaisString(CALSTR_DRIVERTRACEFILENAME),
                                        GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);
                        if (INVALID_HANDLE_VALUE != hLogFile)
                        {
                            DWORD dwLen;
                            dwLen = SetFilePointer(hLogFile, 0, NULL, FILE_END);
                            fSts = WriteFile(
                                        hLogFile,
                                        &rqTrace,
                                        rqTrace.dwStructLen,
                                        &dwLen,
                                        NULL);
                            CloseHandle(hLogFile);
                        }
                    }
#endif
                    if (ERROR_SUCCESS == dwErr)
                        break;
                    if (fHardError)
                    {
                        ASSERT(0 < dwTries);
                        if (0 == --dwTries)
                        {
                            pRdr->SetAvailabilityStatusLocked(CReader::Broken);
                            CalaisError(__SUBROUTINE__, 612, dwErr);
                            throw dwErr;
                        }
                    }
                }
                if (fAllDone)
                    continue;

                {
                    CLockWrite rwLock(&pRdr->m_rwLock);
                    pRdr->m_ActiveState.dwInsertCount += 1;
                    pRdr->m_ActiveState.dwResetCount = 0;
                    avlState = pRdr->m_dwAvailStatus;
                }

                if (CReader::Direct > avlState)
                {
                    try
                    {
                        ASSERT(!pRdr->m_mtxLatch.IsGrabbed());
                        ASSERT(!pRdr->m_mtxGrab.IsGrabbed());
                        CLatchReader latch(pRdr);   // Take reader
                        pRdr->PowerUp();
                    }
                    catch (...) {}
                }
                else
                {
                    if (CReader::Present > pRdr->m_dwAvailStatus)
                        pRdr->SetAvailabilityStatus(CReader::Present);
                }


                //
                // Start the power-down timer.
                //

                fSts = SetWaitableTimer(
                            hPowerDownTimer,
                            &l_ftPowerdownTime,
                            0,
                            NULL,
                            NULL,
                            FALSE);
                if (!fSts)
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Reader Monitor can't request powerdown timeout: %1"),
                        GetLastError());


                //
                // Look for a smartcard removal.
                //

                dwTries = MONITOR_MAX_TRIES;
                for (;;)
                {
#ifdef SCARD_TRACE_ENABLED
                    GetLocalTime(&rqTrace.StartTime);
                    rqTrace.dwProcId = GetCurrentProcessId();
                    rqTrace.dwThreadId = GetCurrentThreadId();
                    rqTrace.hDevice = pRdr->m_hReader;
                    rqTrace.dwIoControlCode = IOCTL_SMARTCARD_IS_ABSENT;
                    rqTrace.nInBuffer = NULL;
                    rqTrace.nInBufferSize = 0;
                    rqTrace.nOutBufferSize = 0;
#endif
                    ASSERT(!pRdr->IsLatchedByMe());

                    fSts = DeviceIoControl(
                                pRdr->m_hReader,
                                IOCTL_SMARTCARD_IS_ABSENT,
                                NULL, 0,
                                NULL, 0,
                                &dwRetLen,
                                &ovrWait);
                    if (!fSts)
                    {
                        BOOL fErrorProcessed;

                        dwErr = dwDrvrErr = GetLastError();
                        do
                        {
                            fErrorProcessed = TRUE;
                            fHardError = FALSE;
                            switch (dwErr)
                            {

                            //
                            // The driver will let us know.
                            //

                            case ERROR_IO_PENDING:
                                dwWait = WaitForAnyObject(
                                                INFINITE,
                                                hPowerDownTimer.Value(),
                                                ovrWait.hEvent,
                                                pRdr->m_hRemoveEvent.Value(),
                                                g_hCalaisShutdown,
                                                NULL);
                                switch (dwWait)
                                {
                                case 1: // Powerdown indicator
                                    if (!pRdr->IsInUse())
                                        pRdr->ReaderPowerDown(NULL);
                                    dwErr = ERROR_IO_PENDING;   // Keep looping
                                    fErrorProcessed = FALSE;
                                    break;

                                case 2: // I/O completed
                                {
                                    pRdr->LatchReader(NULL);
                                    fErrorProcessed = FALSE;
                                    fSts = GetOverlappedResult(
                                                pRdr->m_hReader,
                                                &ovrWait,
                                                &dwRetLen,
                                                TRUE);
                                    if (!fSts)
                                        dwErr = dwDrvrErr = GetLastError();
                                    else
                                        dwErr = ERROR_SUCCESS;
                                    pRdr->Unlatch();
                                    break;
                                }

                                case 3: // Shutdown indicator
                                case 4:
                                    fAllDone = TRUE;
                                    dwErr = ERROR_SUCCESS;
                                    dwDrvrErr = SCARD_P_SHUTDOWN;
                                    break;

                                default:
                                    CalaisWarning(
                                        __SUBROUTINE__,
                                        DBGT("Wait for card removal returned invalid value"));
                                    throw (DWORD)SCARD_F_INTERNAL_ERROR;
                                }
                                break;


                            //
                            // Success.  Continue monitoring for events.
                            //

                            case ERROR_SUCCESS:         // Success after a wait event.
                                break;


                            //
                            // PnP Shutdown errors -- handle them gracefully.
                            //

                            case ERROR_DEVICE_REMOVED:  // PnP Device yanked out of system
                            case ERROR_DEV_NOT_EXIST:
                            case ERROR_INVALID_FUNCTION:
                                fDeleteWhenDone = TRUE;
                                // Fall through intentionally
                            case ERROR_INVALID_HANDLE:  // We're shutting down.
                            case ERROR_OPERATION_ABORTED:   // PnP Polite shutdown request
                                dwErr = ERROR_SUCCESS;
                                fAllDone = TRUE;
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Reader return code takes reader '%2' offline:  %1"),
                                    dwErr,
                                    pRdr->DeviceName());
                                break;


                            //
                            // A hard error.  Log it, and declare the device broken.
                            //

                            default:
                                CalaisWarning(
                                    __SUBROUTINE__,
                                    DBGT("Reader removal monitor failed wait:  %1"),
                                    dwErr);
                                fHardError = TRUE;
                            }
                        } while (!fErrorProcessed);
                    }
                    else
                        dwErr = dwDrvrErr = ERROR_SUCCESS;

#ifdef SCARD_TRACE_ENABLED
                    {
                        GetLocalTime(&rqTrace.EndTime);
                        rqTrace.dwStatus = dwDrvrErr;
                        rqTrace.nOutBuffer = NULL;
                        rqTrace.nBytesReturned = 0;
                        rqTrace.dwStructLen = sizeof(RequestTrace);

                        LockSection(
                            g_pcsControlLocks[CSLOCK_TRACELOCK],
                            DBGT("Logging a card removal"));
                        HANDLE hLogFile = INVALID_HANDLE_VALUE;

                        hLogFile = CreateFile(
                                        CalaisString(CALSTR_DRIVERTRACEFILENAME),
                                        GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);
                        if (INVALID_HANDLE_VALUE != hLogFile)
                        {
                            DWORD dwLen;
                            dwLen = SetFilePointer(hLogFile, 0, NULL, FILE_END);
                            fSts = WriteFile(
                                        hLogFile,
                                        &rqTrace,
                                        rqTrace.dwStructLen,
                                        &dwLen,
                                        NULL);
                            CloseHandle(hLogFile);
                        }
                    }
#endif
                    if (ERROR_SUCCESS == dwErr)
                        break;
                    if (fHardError)
                    {
                        ASSERT(0 < dwTries);
                        if (0 == --dwTries)
                        {
                            pRdr->SetAvailabilityStatusLocked(CReader::Broken);
                            CalaisError(__SUBROUTINE__, 615, dwErr);
                            throw dwErr;
                        }
                    }
                }
                fSts = CancelWaitableTimer(hPowerDownTimer);
                if (!fSts)
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Reader Monitor can't cancel powerdown timeout: %1"),
                        GetLastError());
                if (fAllDone)
                    continue;

                {
                    CLockWrite rwLock(&pRdr->m_rwLock);
                    pRdr->m_bfCurrentAtr.Reset();
                    pRdr->m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    pRdr->m_ActiveState.dwRemoveCount += 1;
                }
                if (CReader::Direct > pRdr->AvailabilityStatus())
                {
                    pRdr->InvalidateGrabs();
                    pRdr->SetAvailabilityStatusLocked(CReader::Idle);
                }

                dwErrRetry = MONITOR_MAX_TRIES;
            }
            catch (DWORD dwError)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Reader Monitor '%2' caught processing error: %1"),
                    dwError,
                    pRdr->ReaderName());
                if (fHardError)
                    throw;
                try
                {
                    pRdr->ReaderPowerDown(NULL);
                }
                catch (...) {}
                ASSERT(0 != dwErrRetry);
                if (0 == --dwErrRetry)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("Error threshold reached, abandoning reader %1."),
                        pRdr->ReaderName());
                    throw;
                }
            }
        }

        CLockWrite rwLock(&pRdr->m_rwLock);
        if (CReader::Closing > pRdr->m_dwAvailStatus)
            pRdr->SetAvailabilityStatus(CReader::Inactive);
    }

    catch (DWORD dwError)
    {
        CalaisError(__SUBROUTINE__, 616, dwError, pRdr->ReaderName());
        pRdr->SetAvailabilityStatusLocked(CReader::Broken);
    }

    catch (...)
    {
        CalaisError(__SUBROUTINE__, 617, pRdr->ReaderName());
        pRdr->SetAvailabilityStatusLocked(CReader::Broken);
    }


    //
    // Cleanup code.
    //

    CalaisInfo(
        __SUBROUTINE__,
        DBGT("Reader monitor for '%1' is shutting down."),
        pRdr->ReaderName());
    if (hOvrWait.IsValid())
        hOvrWait.Close();
    if (hPowerDownTimer.IsValid())
        hPowerDownTimer.Close();
    if (fDeleteWhenDone)
    {
        {
            CLockWrite rwLock(&pRdr->m_rwLock);
            pRdr->m_bfCurrentAtr.Reset();
            pRdr->m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            pRdr->m_ActiveState.dwRemoveCount += 1;
            pRdr->m_hThread = NULL;
        }
        CalaisRemoveReader(pRdr->ReaderName());
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\changpin\chpin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       chPin.h
//
//--------------------------------------------------------------------------

// ChangePin.h : main header file for the CHANGEPIN application
//

#if !defined(AFX_CHANGEPIN_H__99CC45B5_C1C8_11D2_88F3_00C04F79F800__INCLUDED_)
#define AFX_CHANGEPIN_H__99CC45B5_C1C8_11D2_88F3_00C04F79F800__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CChangePinApp:
// See ChangePin.cpp for the implementation of this class
//

class CChangePinApp : public CWinApp
{
public:
	CChangePinApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChangePinApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CChangePinApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHANGEPIN_H__99CC45B5_C1C8_11D2_88F3_00C04F79F800__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\changpin\chpindlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       chPinDlg.h
//
//--------------------------------------------------------------------------

// ChangePinDlg.h : header file
//

#if !defined(AFX_CHANGEPINDLG_H__99CC45B7_C1C8_11D2_88F3_00C04F79F800__INCLUDED_)
#define AFX_CHANGEPINDLG_H__99CC45B7_C1C8_11D2_88F3_00C04F79F800__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CChangePinDlg dialog

class CChangePinDlg : public CDialog
{
// Construction
public:
	CChangePinDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CChangePinDlg)
	enum { IDD = IDD_CHANGEPIN_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChangePinDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;
    CWinThread *m_pThread;

	// Generated message map functions
	//{{AFX_MSG(CChangePinDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
    afx_msg LRESULT OnAllDone(WPARAM, LPARAM);
    //}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHANGEPINDLG_H__99CC45B7_C1C8_11D2_88F3_00C04F79F800__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\server\server\reader.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Reader

Abstract:

    This module provides the implementation of the Calais CReader class.

Author:

    Doug Barlow (dbarlow) 10/23/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    The CReader object has several levels of locking.  It is critical that the
    locking be done in the correct order, to prevent deadlocks.  Here are the
    levels of locking, in the order they must be performed.  A level may be
    skipped, but once a given level is reached, you may not attempt to request
    a lock from a lower numbered level.

    1)  Grabbed - A reader object may be Grabbed.  This is the weakest lock,
        and is used to maintain Transactions requested from client
        applications.  Since clients may have errors, internal threads may
        override this lock if necessary.

    2)  Latched - A reader object may be Latched.  This is similar to a Grab,
        but is done by routines within the Resource Manager.  Latches may not
        be overridden by other threads.

    3)  Write Lock - A thread that needs write access to the CReader
        properties must establish a write lock on the CReader object.  This is
        an exclusive lock.  A thread with a Write Lock may also request Read
        Locks.

    4)  Read Lock - A thread that needs read access to the CReader properties
        must establish a read lock on the CReader Object.  There can be
        multiple simoultaneous readers.  If you have a read lock, it cannot be
        changed to a write lock!

    All locks are counted, so that obtaining one twice by the same thread is
    supported.

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <CalServe.h>

#define SCARD_IO_TIMEOUT 15000  // Maximum time to allow for an I/O operation
                                // before complaining.
#ifdef DBG
extern BOOL g_fGuiWarnings;
#endif


//
//==============================================================================
//
//  CReader
//

/*++

CReader:

    This is the constructor for a CReader class.  It just zeroes out the data
    structures in preparation for the Initialize call.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::CReader")

CReader::CReader(
    void)
:   m_rwLock(),
    m_bfReaderName(),
    m_bfCurrentAtr(36),
    m_ChangeEvent(),
    m_mtxGrab()
{
    Clean();
}


/*++

~CReader:

    This is the destructor for the reader class.  It just uses the Close service
    to shut down.  Note that it is *NOT* declared virtual, in order to improve
    performance.  Should it be desirable to subclass this class, this will have
    to change.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::~CReader")

CReader::~CReader()
{
    if (InitFailed())
        return;

    TakeoverReader();
    Close();
}


/*++

Clean:

    This routine is used to initialize all the property values.  It does *NOT*
    do any deallocation or locking!  Use Close() for that.

Arguments:

    None

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Clean")

void
CReader::Clean(
    void)
{
    m_bfReaderName.Reset();
    m_bfCurrentAtr.Reset();
    m_dwFlags = 0;
    m_dwCapabilities = 0;
    m_dwAvailStatus = Inactive;
    m_ActiveState.dwInsertCount = 0;
    m_ActiveState.dwRemoveCount = 0;
    m_ActiveState.dwResetCount = 0;
    m_dwOwnerThreadId = 0;
    m_dwShareCount = 0;
    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
    m_fDeviceActive = TRUE;
    m_dwCurrentState = SCARD_UNKNOWN;
}


/*++

Initialize:

    This method initializes a clean CReader object to a running state.

Arguments:

    None

Return Value:

    None

Throws:

    Errors as DWORD status codes

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Initialize")

void
CReader::Initialize(
    void)
{
    CLatchReader latch(this);
    try
    {

        //
        // Get it's Device Name.  Note device names always come in from the
        // driver in ASCII characters.
        //

        TCHAR szUnit[32];
        CTextString szVendor, szDevice, szName;
        CBuffer bfAttr(MAXIMUM_ATTR_STRING_LENGTH + 2 * sizeof(WCHAR));
        DWORD dwUnit, cchUnit;
        CLockWrite rwLock(&m_rwLock);

        try
        {
            GetReaderAttr(
                SCARD_ATTR_VENDOR_NAME,
                bfAttr);
            if (0 == bfAttr.Length())
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Reader driver reports NULL Vendor"));
            }
            else
            {
                bfAttr.Append((LPBYTE)"\000", sizeof(CHAR));
                szVendor = (LPCSTR)bfAttr.Access();
            }
        }
        catch (DWORD dwError)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reader object failed to obtain reader vendor name:  %1"),
                dwError);
            szVendor.Reset();
        }
        catch (...)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reader object received exception while trying to obtain reader vendor name"));
            szVendor.Reset();
        }

        try
        {
            GetReaderAttr(
                SCARD_ATTR_VENDOR_IFD_TYPE,
                bfAttr);
            if (0 == bfAttr.Length())
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Reader driver reports NULL device type"));
            }
            else
            {
                bfAttr.Append((LPBYTE)"\000", sizeof(CHAR));
                szDevice = (LPCSTR)bfAttr.Access();
            }
        }
        catch (DWORD dwError)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reader object failed to obtain reader device type:  %1"),
                dwError);
            szDevice.Reset();
        }
        catch (...)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reader object received exception while trying to obtain reader device type"));
            szDevice.Reset();
        }

        if ((0 == szVendor.Length()) && (0 == szDevice.Length()))
        {
            CalaisError(__SUBROUTINE__, 406);
            throw (DWORD)SCARD_E_READER_UNSUPPORTED;
        }

        try
        {
            dwUnit = GetReaderAttr(SCARD_ATTR_DEVICE_UNIT);
            cchUnit = wsprintf(szUnit, TEXT("%lu"), dwUnit);
            if (0 >= cchUnit)
                throw GetLastError();
        }
        catch (DWORD dwError)
        {
            *szUnit = 0;
            cchUnit = 0;
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reader '%2' failed to obtain reader device type:  %1"),
                dwError,
                ReaderName());
        }
        catch (...)
        {
            *szUnit = 0;
            cchUnit = 0;
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reader '%1' received exception while trying to obtain reader device type"),
                ReaderName());
        }


        //
        // Put all the pieces together.
        //

        szName.Reset();
        if (0 < szVendor.Length())
            szName += szVendor;
        if (0 < szDevice.Length())
        {
            if (0 < szName.Length())
                szName += TEXT(" ");
            szName += szDevice;
        }
        if (0 < cchUnit)
        {
            if (0 < szName.Length())
                szName += TEXT(" ");
            szName += szUnit;
        }
        ASSERT(0 < szName.Length());
        m_bfReaderName.Set(
            (LPCBYTE)((LPCTSTR)szName),
            (szName.Length() + 1) * sizeof(TCHAR));
    }

    catch (...)
    {
        Close();
        throw;
    }
}


/*++

Close:

    This routine does the work of closing down a CReader class, and returning it
    to it's default state.  It does not assume any particular state, other than
    that the class has been Clean()ed once (at construction).

Arguments:

    None

Return Value:

    None

Throws:

    None

Notes:

    You must not have a read lock when calling this routine.

Author:

    Doug Barlow (dbarlow) 10/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Close")

void
CReader::Close(
    void)
{
    ASSERT(IsLatchedByMe());
    CLockWrite rwLock(&m_rwActive);
    if (Inactive != m_dwAvailStatus)
    {
        try
        {
            SetAvailabilityStatusLocked(Closing);
            Dispose(SCARD_EJECT_CARD);
        }
        catch (DWORD dwErr)
        {
            if (SCARD_E_NO_SMARTCARD != dwErr)
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Reader '%2' shutdown cannot eject card:  %1"),
                    dwErr,
                    ReaderName());
        }
        catch (...)
        {
            CalaisError(__SUBROUTINE__, 401);
        }

        while (Unlatch())
            ;   // Empty Loop Body
        while (m_mtxGrab.Share())
            ;   // Empty Loop Body
        Clean();
    }
}


/*++

Disable:

    This method releases any physical resources associated with the reader
    object, and marks the object offline.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORDs

Author:

    Doug Barlow (dbarlow) 4/7/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Disable")

void
CReader::Disable(
    void)
{
    try
    {
        CTakeReader take(this);
        Dispose(SCARD_EJECT_CARD);
    }
    catch (...) {}
    SetAvailabilityStatusLocked(Closing);
}


/*++

GetReaderState:

    This routine is the default implementation of the base method.  It
    just passes the same operation on to the control method.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

Return Value:

    A DWORD representing the reader state.  This must be one of the following
    values:

        SCARD_UNKNOWN     This value implies the driver is unaware
                          of the current state of the reader.
        SCARD_ABSENT      This value implies there is no card in
                          the reader.
        SCARD_PRESENT     This value implies there is a card is
                          present in the reader, but that it has
                          not been moved into position for use.
        SCARD_SWALLOWED   This value implies there is a card in the
                          reader in position for use.  The card is
                          not powered.
        SCARD_POWERED     This value implies there is power is
                          being provided to the card, but the
                          Reader Driver is unaware of the mode of
                          the card.
        SCARD_NEGOTIABLE  This value implies the card has been
                          reset and is awaiting PTS negotiation.
        SCARD_SPECIFIC    This value implies the card has been
                          reset and specific communication
                          protocols have been established.

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::GetReaderState")

DWORD
CReader::GetReaderState(
    void)
{
    DWORD dwReaderSts = 0;
    DWORD dwLength = sizeof(DWORD);
    DWORD dwSts;

    ASSERT(IsGrabbedByMe());
    ASSERT(IsLatchedByMe());
    dwSts = Control(
                IOCTL_SMARTCARD_GET_STATE,
                NULL, 0,
                (LPBYTE)&dwReaderSts,
                &dwLength);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
    if (SCARD_UNKNOWN == dwReaderSts)
    {
        {
            CLockWrite rwLock(&m_rwLock);
            SetAvailabilityStatus(Broken);
            m_bfCurrentAtr.Reset();
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
        }
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("GetReaderState received unknown device state"));
        throw (DWORD)SCARD_F_INTERNAL_ERROR;
    }
    m_dwCurrentState = dwReaderSts;
    return dwReaderSts;
}

DWORD
CReader::GetReaderState(
    ActiveState *pActiveState)
{
    CLatchReader latch(this, pActiveState);
    return GetReaderState();
}


/*++

GrabReader:

    This routine obtains the reader for this thread, ensuring that the reader is
    in a useable state.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 4/21/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::GrabReader")

void
CReader::GrabReader(
    void)
{
    ASSERT(m_rwLock.NotReadLocked());
    ASSERT(m_rwLock.NotWriteLocked());
    ASSERT(!IsLatchedByMe());
    m_mtxGrab.Grab();
}


/*++

InvalidateGrabs:

    This method is for use by internal system threads.  It politlely invalidates
    any existing grabs that might be outstanding by clients.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    This routine intentionally cheats on the locking order.  It first latches a
    reader to be sure that no active threads are currently using it.  It then
    modifies the Grab mutex to appear that no one had a grab lock.

    This results in the appearance that the locking order had been followed.

Author:

    Doug Barlow (dbarlow) 6/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::InvalidateGrabs")

void
CReader::InvalidateGrabs(
    void)
{
    ASSERT(!IsLatchedByMe());
    m_mtxLatch.Grab();
    m_mtxGrab.Invalidate();
    m_mtxLatch.Share();
}


/*++

TakeoverReader:

    This method is for use by internal system threads.  It politlely invalidates
    any existing grabs that might be outstanding by clients, and reassigns the
    grab lock to this thread.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    This routine intentionally cheats on the locking order.  It first latches a
    reader to be sure that no active threads are currently using it.  It then
    modifies the Grab mutex to appear that we had previously grabbed the reader.

    This results in the appearance that the locking order had been followed.

Author:

    Doug Barlow (dbarlow) 6/1/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::TakeoverReader")

void
CReader::TakeoverReader(
    void)
{
    if (!IsLatchedByMe())
    {
        m_mtxLatch.Grab();
        m_mtxGrab.Take();
    }
    ASSERT(IsLatchedByMe());
    ASSERT(IsGrabbedByMe());
}


/*++

LatchReader:

    This routine obtains the reader for this thread, ensuring that the reader is
    in a useable state.

Arguments:

    pActState receives the snapshot of the active state to use in future access
        requests.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 4/21/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::LatchReader")

void
CReader::LatchReader(
    const ActiveState *pActiveState)
{
    VerifyActive(pActiveState);
    ASSERT(m_rwLock.NotReadLocked());
    ASSERT(m_rwLock.NotWriteLocked());
    m_mtxLatch.Grab();
    if (NULL != pActiveState)
    {
        try
        {
            VerifyState();
            VerifyActive(pActiveState);
        }
        catch (...)
        {
            m_mtxLatch.Share();
            throw;
        }
    }
}


/*++

VerifyState:

    This method ensures the reader and card are usable in the current context.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 5/30/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::VerifyState")

void
CReader::VerifyState(
    void)
{
    DWORD dwNewState, dwOldState;

    ASSERT(IsGrabbedByMe());


    //
    // As long as the current state isn't what we thought it was,
    // bring this reader up to date.
    //

    if (Direct != AvailabilityStatus())
    {
        CLockWrite rwLock(&m_rwLock);
        for (;;)
        {

            //
            // Compare where we think the device is to where the device
            // controller thinks the device is.  If they're the same, we're
            // done.
            //

            dwOldState = GetCurrentState();
            dwNewState = GetReaderState();
            if (dwOldState == dwNewState)
                break;


            //
            // Our opinions differ on where the reader is.  Bring us into sync.
            //

            switch (dwOldState)
            {

            //
            // If we're here, then we're booting up the reader.
            //

            case SCARD_UNKNOWN:
                switch (dwNewState)
                {
                case SCARD_ABSENT:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_bfCurrentAtr.Reset();
                    m_ActiveState.dwRemoveCount += 1;
                    if (Direct > m_dwAvailStatus)
                        SetAvailabilityStatus(Idle);
                    break;
                case SCARD_PRESENT:
                case SCARD_SWALLOWED:
                case SCARD_POWERED:
                case SCARD_NEGOTIABLE:
                case SCARD_SPECIFIC:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_bfCurrentAtr.Reset();
                    m_ActiveState.dwInsertCount += 1;
                    if (Direct > m_dwAvailStatus)
                        PowerUp();
                    break;
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("VerifyState found '%1' in invalid state"),
                        ReaderName());
                }
                break;


            //
            // We don't think there's a card in the reader.  If we're wrong,
            // power it up.
            //

            case SCARD_ABSENT:
                switch (dwNewState)
                {
                case SCARD_PRESENT:
                case SCARD_SWALLOWED:
                case SCARD_POWERED:
                case SCARD_NEGOTIABLE:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    // Fall through intentionally
                case SCARD_SPECIFIC:
                    m_ActiveState.dwInsertCount += 1;
                    if (Direct > m_dwAvailStatus)
                    {
                        m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("VerifyState found '%1' in invalid state"),
                        ReaderName());
                }
                break;


            //
            //  We think there's a card there that needs to be powered up.
            //

            case SCARD_PRESENT:
                switch (dwNewState)
                {
                case SCARD_ABSENT:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_bfCurrentAtr.Reset();
                    m_ActiveState.dwRemoveCount += 1;
                    break;
                case SCARD_SWALLOWED:
                case SCARD_POWERED:
                case SCARD_NEGOTIABLE:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    // Fall through intentionally
                case SCARD_SPECIFIC:
                    if (Direct > m_dwAvailStatus)
                    {
                        m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("VerifyState found '%1' in invalid state"),
                        ReaderName());
                }
                break;


            //
            // We think that a card was in place for use, but hasn't been
            // powered.
            //

            case SCARD_SWALLOWED:
                switch (dwNewState)
                {
                case SCARD_ABSENT:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_bfCurrentAtr.Reset();
                    m_ActiveState.dwRemoveCount += 1;
                    break;
                case SCARD_PRESENT:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_ActiveState.dwResetCount += 1;
                    if (Direct > m_dwAvailStatus)
                    {
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                case SCARD_POWERED:
                case SCARD_NEGOTIABLE:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    // Fall through intentionally
                case SCARD_SPECIFIC:
                    if (Direct > m_dwAvailStatus)
                    {
                        m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("VerifyState found '%1' in invalid state"),
                        ReaderName());
                }
                break;


            //
            // We think the card is just waiting to be reset.
            //

            case SCARD_POWERED:
                switch (dwNewState)
                {
                case SCARD_ABSENT:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_bfCurrentAtr.Reset();
                    m_ActiveState.dwRemoveCount += 1;
                    break;
                case SCARD_PRESENT:
                case SCARD_SWALLOWED:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_ActiveState.dwResetCount += 1;
                    if (Direct > m_dwAvailStatus)
                    {
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                case SCARD_NEGOTIABLE:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    // Fall through intentionally
                case SCARD_SPECIFIC:
                    if (Direct > m_dwAvailStatus)
                    {
                        m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("VerifyState found '%1' in invalid state"),
                        ReaderName());
                }
                break;


            //
            // We think the card is ready to go, but needs a decision on which
            // protocol to use.
            //

            case SCARD_NEGOTIABLE:
                switch (dwNewState)
                {
                case SCARD_ABSENT:
                    m_ActiveState.dwRemoveCount += 1;
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_bfCurrentAtr.Reset();
                    break;
                case SCARD_PRESENT:
                case SCARD_SWALLOWED:
                case SCARD_POWERED:
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_ActiveState.dwResetCount += 1;
                    if (Direct > m_dwAvailStatus)
                    {
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                case SCARD_SPECIFIC:
                        if (Direct > m_dwAvailStatus)
                        {
                            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                            m_bfCurrentAtr.Reset();
                            PowerUp();
                        }
                    break;
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("VerifyState found '%1' in invalid state"),
                        ReaderName());
                }
                break;


            //
            // We think the card has a protocol established.
            //

            case SCARD_SPECIFIC:
                switch (dwNewState)
                {
                case SCARD_ABSENT:
                    m_ActiveState.dwRemoveCount += 1;
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    m_bfCurrentAtr.Reset();
                    break;
                case SCARD_PRESENT:
                case SCARD_SWALLOWED:
                case SCARD_POWERED:
                case SCARD_NEGOTIABLE:
                    m_ActiveState.dwResetCount += 1;
                    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                    if (Direct > m_dwAvailStatus)
                    {
                        m_bfCurrentAtr.Reset();
                        PowerUp();
                    }
                    break;
                default:
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("VerifyState found '%1' in invalid state"),
                        ReaderName());
                }
                break;


            //
            // Oops.  We don't know diddly about what's going on.
            //

            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("VerifyState of '%1' thinks it is in an unrecognized state"),
                    ReaderName());
            }
        }
    }
}


/*++

PowerUp:

    This routine brings a reader up to a ready state.

Arguments:

    None

Return Value:

    None

Throws:

    Errors that might occur.

Author:

    Doug Barlow (dbarlow) 1/7/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::PowerUp")

void
CReader::PowerUp(
    void)
{
    BOOL fDone = FALSE;
    DWORD dwSts, dwRetry;
    DWORD dwReaderSts;
    DWORD dwLastSts = SCARD_UNKNOWN;
    DWORD dwAtrLen;
    BOOL fSts;
    DWORD dwErrorCount = 3;

    ASSERT(IsGrabbedByMe());
    ASSERT(IsLatchedByMe());

    CLockWrite rwLock(&m_rwLock);
    while (!fDone)
    {

        //
        // Get the current reader status, and make sure it's changing.
        //

        dwReaderSts = GetReaderState();
        if (dwReaderSts != dwLastSts)
        {
            dwLastSts = dwReaderSts;
            dwErrorCount = 3;
        }
        else
        {
            ASSERT(0 < dwErrorCount);
            dwErrorCount -= 1;
            if (0 == dwErrorCount)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Reader '%1' won't change state!"),
                    ReaderName());
                m_bfCurrentAtr.Reset();
                m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                SetAvailabilityStatus(Unsupported);
                throw (DWORD)SCARD_E_CARD_UNSUPPORTED;
            }
        }

        switch (dwReaderSts)
        {
        case SCARD_ABSENT:
            m_bfCurrentAtr.Reset();
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            m_ActiveState.dwRemoveCount += 1;
            if (Direct > m_dwAvailStatus)
                SetAvailabilityStatus(Idle);
            throw (DWORD)SCARD_E_NO_SMARTCARD;
            break;
        case SCARD_PRESENT:
            m_bfCurrentAtr.Reset();
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            if (0 != (SCARD_READER_SWALLOWS & m_dwCapabilities))
            {
                try
                {
                    ReaderSwallow();
                    continue;   // Continue the loop.
                }
                catch (DWORD dwError)
                {
                    switch (dwError)
                    {
                    case ERROR_NOT_SUPPORTED:
                        m_dwCapabilities &= ~SCARD_READER_SWALLOWS;
                        break;      // Fall through to SWALLOWED.
                    default:
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("PowerUp on '%2' failed to swallow card:  %1"),
                            dwError,
                            ReaderName());
                    }
                }
                catch (...)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("PowerUp on '%1' got exception trying to swallow card"),
                        ReaderName());
                }
            }
            // Fall through on purpose.
        case SCARD_SWALLOWED:
            m_bfCurrentAtr.Reset();
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            dwRetry = 3;
            dwSts = ERROR_SUCCESS;
            do
            {
                try
                {
                    ReaderColdReset(m_bfCurrentAtr);
                    dwSts = ERROR_SUCCESS;
                }
                catch (DWORD dwError)
                {
                    dwSts = dwError;
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("PowerUp on '%2' failed to power card:  %1"),
                        dwError,
                        ReaderName());
                }
                catch (...)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("PowerUp on '%1' got exception trying to power card"),
                        ReaderName());
                    dwSts = SCARD_F_INTERNAL_ERROR;
                }

                switch (dwSts)
                {
                case ERROR_BAD_COMMAND:
                case ERROR_MEDIA_CHANGED:
                case ERROR_NO_MEDIA_IN_DRIVE:
                case ERROR_UNRECOGNIZED_MEDIA:
                    continue;
                    break;
                // default:
                //      no action
                }
            } while ((0 < --dwRetry) && (ERROR_SUCCESS != dwSts));
            if (ERROR_SUCCESS != dwSts)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("PowerUp on '%1' abandoning attempt to power card"),
                    ReaderName());
                m_bfCurrentAtr.Reset();
                if (Direct > m_dwAvailStatus)
                    SetAvailabilityStatus(Unresponsive);
                fDone = TRUE;
            }
            else
            {
                if (Ready > m_dwAvailStatus)
                {
                    SetAvailabilityStatus(Ready);
                    SetActive(FALSE);
                }
            }
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            m_ActiveState.dwResetCount += 1;
            break;

        case SCARD_POWERED:
            m_bfCurrentAtr.Reset();
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            try
            {
               ReaderWarmReset(m_bfCurrentAtr);
                if (Ready > m_dwAvailStatus)
                {
                    SetAvailabilityStatus(Ready);
                    SetActive(FALSE);
                }
            }
            catch (DWORD dwError)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("PowerUp on '%2' failed to reset card:  %1"),
                    dwError,
                    ReaderName());
                if (Direct > m_dwAvailStatus)
                    SetAvailabilityStatus(Unresponsive);
                m_bfCurrentAtr.Reset();
            }
            catch (...)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("PowerUp on '%1' received exception attempting to warm reset card"),
                    ReaderName());
                if (Direct > m_dwAvailStatus)
                    SetAvailabilityStatus(Unresponsive);
                m_bfCurrentAtr.Reset();
            }
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            m_ActiveState.dwResetCount += 1;
            break;

        case SCARD_NEGOTIABLE:
            ASSERT(SCARD_PROTOCOL_UNDEFINED == m_dwCurrentProtocol);
            if ((Direct > m_dwAvailStatus) && (2 > m_bfCurrentAtr.Length()))
            {
                try
                {
                    GetReaderAttr(
                        SCARD_ATTR_ATR_STRING,
                        m_bfCurrentAtr);
                    if (Ready > m_dwAvailStatus)
                    {
                        SetAvailabilityStatus(Ready);
                        SetActive(FALSE);
                    }
                }
                catch (DWORD dwError)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("PowerUp on '%2' cannot get Current ATR:  %1"),
                        dwError,
                        ReaderName());
                    SetAvailabilityStatus(Unresponsive);
                    m_bfCurrentAtr.Reset();
                }
                catch (...)
                {
                    CalaisWarning(
                        __SUBROUTINE__,
                        DBGT("PowerUp on '%1' received exception trying to get Current ATR"),
                        ReaderName());
                    SetAvailabilityStatus(Unresponsive);
                    m_bfCurrentAtr.Reset();
                }
            }
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            fDone = TRUE;
            break;

        case SCARD_SPECIFIC:
            if (Direct > m_dwAvailStatus)
            {
                if (2 > m_bfCurrentAtr.Length())
                {
                    try
                    {
                        GetReaderAttr(SCARD_ATTR_ATR_STRING, m_bfCurrentAtr);
                    }
                    catch (DWORD dwError)
                    {
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("PowerUp on '%2' cannot get Current ATR:  %1"),
                            dwError,
                            ReaderName());
                        SetAvailabilityStatus(Unresponsive);
                        m_bfCurrentAtr.Reset();
                        m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                        fDone = TRUE;
                    }
                    catch (...)
                    {
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("PowerUp on '%1' received exception trying to get Current ATR"),
                            ReaderName());
                        SetAvailabilityStatus(Unresponsive);
                        m_bfCurrentAtr.Reset();
                        m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                        fDone = TRUE;
                    }
                }
                if (SCARD_PROTOCOL_UNDEFINED == m_dwCurrentProtocol)
                {
                    try
                    {
                        m_dwCurrentProtocol = GetReaderAttr(
                                    SCARD_ATTR_CURRENT_PROTOCOL_TYPE);
                    }
                    catch (DWORD dwError)
                    {
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("PowerUp on '%2' cannot get Current Protocol:  %1"),
                            dwError,
                            ReaderName());
                    }
                    catch (...)
                    {
                        CalaisWarning(
                            __SUBROUTINE__,
                            DBGT("PowerUp on '%1' received exception trying to get Current Protocol"),
                            ReaderName());
                    }
                }
            }
            if (Ready > m_dwAvailStatus)
            {
                SetAvailabilityStatus(Ready);
                SetActive(FALSE);
            }
            fDone = TRUE;
            break;

        case SCARD_UNKNOWN:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("PowerUp on '%1' received unknown device state"),
                ReaderName());
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
            break;

        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("PowerUp on '%1' received invalid current device state"),
                ReaderName());
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
            break;
        }
    }
    if ((Direct > m_dwAvailStatus) && (0 != m_bfCurrentAtr.Length()))
    {
        fSts = ParseAtr(
            m_bfCurrentAtr,
            &dwAtrLen,
            NULL,
            NULL,
            m_bfCurrentAtr.Length());
        if (!fSts || (m_bfCurrentAtr.Length() != dwAtrLen))
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reported ATR from '%1' is invalid."),
                ReaderName());
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            SetAvailabilityStatus(Unsupported);
            throw (DWORD)SCARD_E_CARD_UNSUPPORTED;
        }
    }
}


/*++

PowerDown:

    This method brings the smartcard down.

Arguments:

    None

Return Value:

    None

Throws:

    Errors encountered, as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/7/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::PowerDown")

void
CReader::PowerDown(
    void)
{
    BOOL fDone = FALSE;
    DWORD dwReaderSts;
    DWORD dwLastSts = SCARD_UNKNOWN;
    DWORD dwErrorCount = 3;


    //
    // Bring down the card.
    //

    ASSERT(IsGrabbedByMe());
    ASSERT(IsLatchedByMe());
    CLockWrite rwLock(&m_rwLock);
    while (!fDone)
    {

        //
        // Get the current reader status.
        //

        try
        {
            dwReaderSts = GetReaderState();
        }
        catch (DWORD dwError)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("PowerDown on '%2' failed to obtain reader status:  %1"),
                dwError,
                ReaderName());
            throw;
        }
        catch (...)
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("PowerDown on '%1' received exception trying to obtain reader status"),
                ReaderName());
            throw;
        }


        //
        // Make sure it's changing.
        //

        if (dwReaderSts != dwLastSts)
        {
            dwLastSts = dwReaderSts;
            dwErrorCount = 3;
        }
        else
        {
            ASSERT(0 < dwErrorCount);
            dwErrorCount -= 1;
            if (0 == dwErrorCount)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Reader '%1' won't change state!"),
                    ReaderName());
                m_bfCurrentAtr.Reset();
                m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
                SetAvailabilityStatus(Unsupported);
                throw (DWORD)SCARD_E_CARD_UNSUPPORTED;
            }
        }

        switch (dwReaderSts)
        {
        case SCARD_SPECIFIC:
            ASSERT(SCARD_PROTOCOL_UNDEFINED != m_dwCurrentProtocol);
            // Fall through intentionally.

        case SCARD_NEGOTIABLE:
            ASSERT(Unresponsive != m_dwAvailStatus
                   ? 2 <= m_bfCurrentAtr.Length()
                   : TRUE);
            // Fall through intentionally.

        case SCARD_POWERED:
            ASSERT((SCARD_POWERED != dwReaderSts)
                    || (SCARD_PROTOCOL_UNDEFINED == m_dwCurrentProtocol));
            try
            {
                ReaderPowerDown();
            }
            catch (DWORD dwError)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("PowerDown on '%2' failed to unpower card:  %1"),
                    dwError,
                    ReaderName());
                throw;
            }
            catch (...)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("PowerDown on '%1' received exception attempting to unpower card"),
                    ReaderName());
                throw;
            }
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            m_ActiveState.dwResetCount += 1;
            break;

        case SCARD_SWALLOWED:
        case SCARD_PRESENT:
            fDone = TRUE;
            if (Direct > m_dwAvailStatus)
                SetAvailabilityStatus(Present);
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            break;

        case SCARD_ABSENT:
            ASSERT(0 == m_bfCurrentAtr.Length());
            ASSERT(SCARD_PROTOCOL_UNDEFINED == m_dwCurrentProtocol);
            m_bfCurrentAtr.Reset();
            m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
            throw (DWORD)SCARD_E_NO_SMARTCARD;
            break;

        case SCARD_UNKNOWN:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("PowerDown on '%1' received unknown device state"),
                ReaderName());
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
            break;

        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("PowerDown on '%1' received invalid current device state"),
                ReaderName());
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
        }
    }
}


/*++

SetAvailabilityStatus:

    This method controls the availability status indicator, maintains the last
    state, and manages the change event flag.

Arguments:

    state supplies the new state to take effect.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/15/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::SetAvailabilityStatus")

void
CReader::SetAvailabilityStatus(
    CReader::AvailableState state)
{
    ASSERT(m_rwLock.IsWriteLocked());
    if (m_dwAvailStatus != state)
    {
        m_dwAvailStatus = state;
        if (Ready >= m_dwAvailStatus)
        {
            m_dwOwnerThreadId = 0;
            m_dwShareCount = 0;
        }
        m_ChangeEvent.Signal();
    }
}


/*++

VerifyActive:

    This method verifies that the card hasn't been removed or reset since the
    last operation.

Arguments:

    pActiveState supplies a pointer to a structure containing the state the
        caller believes we're in.

Return Value:

    None

Throws:

    If a discrepancy is detected, we throw the error code indicating the
    discrepancy.

Author:

    Doug Barlow (dbarlow) 12/5/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::VerifyActive")

void
CReader::VerifyActive(
    const CReader::ActiveState *pActiveState)
{
    if (NULL != pActiveState)
    {
        CLockRead rwLock(&m_rwLock);
        switch (m_dwAvailStatus)
        {
        case Idle:
        case Present:
        case Unresponsive:
        case Unsupported:
        case Ready:
        case Shared:
        case Exclusive:
        {
            if (pActiveState->dwInsertCount != m_ActiveState.dwInsertCount)
                throw (DWORD)SCARD_W_REMOVED_CARD;
            if (pActiveState->dwRemoveCount != m_ActiveState.dwRemoveCount)
                throw (DWORD)SCARD_W_REMOVED_CARD;
            if (pActiveState->dwResetCount != m_ActiveState.dwResetCount)
                throw (DWORD)SCARD_W_RESET_CARD;
             break;
       }
        case Direct:
            break;
        case Closing:
        case Broken:
        case Inactive:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Verification failed on disabled reader '%1'"),
                ReaderName());
            throw (DWORD)SCARD_E_READER_UNAVAILABLE;
            break;
        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Invalid reader active state from '%1' to Verify Active"),
                ReaderName());
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
        }
    }
}


/*++

Dispose:

    This method performs a card disposition command.

Arguments:

    dwDisposition supplies the type of disposition to perform.

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.  This structure is updated following card
        disposition, so that it remains valid.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 12/26/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Dispose")

void
CReader::Dispose(
    DWORD dwDisposition,
    CReader::ActiveState *pActiveState)
{
    VerifyActive(pActiveState);
    if (SCARD_LEAVE_CARD != dwDisposition)
    {
        ASSERT(!IsLatchedByMe());
        CLatchReader latch(this, pActiveState);
        Dispose(dwDisposition);
        if (NULL != pActiveState)
            pActiveState->dwResetCount = m_ActiveState.dwResetCount;
    }
}

void
CReader::Dispose(
    DWORD dwDisposition)
{
    switch (dwDisposition)
    {
    case SCARD_LEAVE_CARD:      // Don't do anything special.
        break;
    case SCARD_RESET_CARD:      // Warm Reset the card.
    {
        ASSERT(IsGrabbedByMe());
        ASSERT(IsLatchedByMe());
        CLockWrite rwLock(&m_rwLock);
        m_bfCurrentAtr.Reset();
        m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
        m_ActiveState.dwResetCount += 1;
        ReaderWarmReset(m_bfCurrentAtr);
        break;
    }
    case SCARD_UNPOWER_CARD:    // Power down the card
    {
        ASSERT(IsGrabbedByMe());
        ASSERT(IsLatchedByMe());
        PowerDown();
        break;
    }
#ifdef SCARD_CONFISCATE_CARD
    case SCARD_CONFISCATE_CARD: // Confiscate the card
    {
        ASSERT(IsGrabbedByMe());
        ASSERT(IsLatchedByMe());
        PowerDown();
        ReaderConfiscate();
        break;
    }
#endif
    case SCARD_EJECT_CARD:      // Eject the card on close
    {
        ASSERT(IsGrabbedByMe());
        ASSERT(IsLatchedByMe());
        PowerDown();
        ReaderEject();
        break;
    }
    default:
        throw (DWORD)SCARD_E_INVALID_VALUE;
    }
}



/*++

Connect:

    This method allows a service thread to connect to this reader.

Arguments:

    dwShareMode supplies the share mode indicator.

    dwPreferredProtocols supplies a bitmask of acceptable protocols to
        negotiate.

    pActState receives the snapshot of the active state to use in future access
        requests.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 12/23/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Connect")

void
CReader::Connect(
    IN DWORD dwShareMode,
    IN DWORD dwPreferredProtocols,
    OUT ActiveState *pActState)
{
    AvailableState avlState;
    DWORD dwOwnerThreadId;
    DWORD dwShareCount;

    if ((SCARD_SHARE_DIRECT != dwShareMode) && (0 == dwPreferredProtocols))
        throw (DWORD)SCARD_E_INVALID_VALUE;

    {
        CLockWrite rwLock(&m_rwLock);
        avlState = m_dwAvailStatus;
        dwOwnerThreadId = m_dwOwnerThreadId;
        dwShareCount = m_dwShareCount;

        switch (avlState)
        {
        case Idle:
            ASSERT(0 == m_dwShareCount);
            ASSERT(0 == m_dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
                throw (DWORD)SCARD_W_REMOVED_CARD;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                if (0 != dwPreferredProtocols)
                    throw (DWORD)SCARD_W_REMOVED_CARD;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Unresponsive:
            ASSERT(0 == m_dwShareCount);
            ASSERT(0 == m_dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
                throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                if (0 != dwPreferredProtocols)
                    throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
                break;
            default:
                throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
            }
            break;

        case Unsupported:
            ASSERT(0 == m_dwShareCount);
            ASSERT(0 == m_dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
                throw (DWORD)SCARD_W_UNSUPPORTED_CARD;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                if (0 != dwPreferredProtocols)
                    throw (DWORD)SCARD_W_UNSUPPORTED_CARD;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Present:
            if ((SCARD_SHARE_DIRECT == dwShareMode) && (0 != dwPreferredProtocols))
                throw (DWORD)SCARD_E_NOT_READY;
            // Fall through intentionally

        case Ready:
            ASSERT(0 == m_dwShareCount);
            ASSERT(0 == m_dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
                avlState = Exclusive;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            case SCARD_SHARE_SHARED:
                dwShareCount += 1;
                avlState = Shared;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Shared:
            ASSERT(0 != m_dwShareCount);
            ASSERT(0 == m_dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_DIRECT:
            case SCARD_SHARE_EXCLUSIVE:
                throw (DWORD)SCARD_E_SHARING_VIOLATION;
                break;
            case SCARD_SHARE_SHARED:
                avlState = Shared;
                dwShareCount += 1;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Exclusive:
        case Direct:
            ASSERT(0 == m_dwShareCount);
            ASSERT(0 != m_dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
            case SCARD_SHARE_DIRECT:
                throw (DWORD)SCARD_E_SHARING_VIOLATION;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Closing:
        case Broken:
        case Inactive:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Connecting to disabled reader '%1'"),
                ReaderName());
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
            case SCARD_SHARE_DIRECT:
                throw (DWORD)SCARD_E_READER_UNAVAILABLE;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        default:
            CalaisError(__SUBROUTINE__, 410);
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
        }


        //
        // It's official!  Write the changes back to the structure.
        //

        CopyMemory(pActState, &m_ActiveState, sizeof(ActiveState));
        m_dwOwnerThreadId = dwOwnerThreadId;
        m_dwShareCount = dwShareCount;
        SetAvailabilityStatus(avlState);
    }


    //
    // Adjust the protocol settings and confirm the request.
    //
    // Since we can't get a latch while a write lock is in effect, we consider
    // the caller officially connected at this point.  Now we try and set the
    // protocol request, and if we fail, we disconnect again.
    //

    if (0 != dwPreferredProtocols)
    {
        try
        {
            DWORD dwCurrentProtocol;

            CLatchReader latch(this, &m_ActiveState);
            PowerUp();
            SetActive(TRUE);
            dwCurrentProtocol = GetReaderAttr(SCARD_ATTR_CURRENT_PROTOCOL_TYPE);
            if (SCARD_PROTOCOL_UNDEFINED == dwCurrentProtocol)
            {
                SetReaderProto(dwPreferredProtocols);
                dwCurrentProtocol =
                    GetReaderAttr(SCARD_ATTR_CURRENT_PROTOCOL_TYPE);
                ASSERT(0 != dwCurrentProtocol);
            }
            else
            {
                if (0 == (dwPreferredProtocols & dwCurrentProtocol))
                {
                    switch (dwPreferredProtocols)
                    {
                    case SCARD_PROTOCOL_RAW:
                        {
                            if (Exclusive > avlState)
                                throw (DWORD)SCARD_E_SHARING_VIOLATION;
                            SetReaderProto(dwPreferredProtocols);
                            dwCurrentProtocol = GetReaderAttr(
                                SCARD_ATTR_CURRENT_PROTOCOL_TYPE);
                            ASSERT(0 != dwCurrentProtocol);
                            break;
                        }
                    case SCARD_PROTOCOL_DEFAULT:
                        ASSERT(SCARD_PROTOCOL_UNDEFINED != dwCurrentProtocol);
                        break;
                    default:
                        throw (DWORD)SCARD_E_PROTO_MISMATCH;
                    }
                }
            }
            CLockWrite rwLock(&m_rwLock);
            m_dwCurrentProtocol = dwCurrentProtocol;
            CopyMemory(pActState, &m_ActiveState, sizeof(ActiveState));
        }
        catch (...)
        {
            try
            {
                DWORD dwDispStatus;

                Disconnect(
                    pActState,
                    SCARD_LEAVE_CARD,
                    &dwDispStatus);
            }
            catch (DWORD dwError)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to autodisconnect during connect error recovery: %1"),
                    dwError);
            }
            catch (...)
            {
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Exception on disconnect during connect error recovery"));
            }
            throw;
        }
    }
}


/*++

Disconnect:

    This method relases a previously established connection between a service
    thread and this reader object.

Arguments:

    pActiveState = This supplies the active state structure, to make sure that
        this is the same card as expected.  This structure is updated following
        card disposition, so that it remains valid.

    hShutdown - This supplies the active handle of the calling dispatch thread.

    dwDisposition supplies an indication as to what to do to the card upon
        completion.

    pdwDispSts receives a disposition status code, indicating whether or not
        the requested disposition was carried out successfully.

Return Value:

    None

Throws:

    This method may throw exceptions if internal invalid states are detected.

Author:

    Doug Barlow (dbarlow) 12/26/1996

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Disconnect")

void
CReader::Disconnect(
    ActiveState *pActState,
    DWORD dwDisposition,
    LPDWORD pdwDispSts)
{
    enum { Unverified, Verified, Reset, Invalid } nValid = Unverified;


    //
    // Attempt to dispose of the card as requested.  It's possible that we
    // aren't still active, so this might fail.
    //

    try
    {
        VerifyActive(pActState);
        nValid = Verified;
    }
    catch (DWORD dwError)
    {
        *pdwDispSts = dwError;
        dwDisposition = SCARD_LEAVE_CARD;
        switch (dwError)
        {
        case SCARD_W_RESET_CARD:
            nValid = Reset;
            break;
        case SCARD_W_REMOVED_CARD:
        case SCARD_E_READER_UNAVAILABLE:
            nValid = Invalid;
            break;
        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Unrecognized validation error code '%1'.  Assuming Invalid."),
                dwError);
            nValid = Invalid;
        }
    }
    ASSERT(Unverified != nValid);


    //
    // Change the card's internal state.
    //

    {
        CLockWrite rwLock(&m_rwLock);
        switch (m_dwAvailStatus)
        {
        case Idle:
        case Unresponsive:
        case Unsupported:
        case Present:
        case Ready:
            ASSERT(Invalid == nValid);
            throw (DWORD)SCARD_W_REMOVED_CARD;
            break;

        case Shared:
            ASSERT(0 < m_dwShareCount);
            ASSERT(0 == m_dwOwnerThreadId);
            switch (nValid)
            {
            case Reset:
                // A reset card is still considered valid.
                // Fall through intentionally.
            case Verified:
                m_dwShareCount -= 1;
                if (0 == m_dwShareCount)
                    SetAvailabilityStatus(Ready);
                break;
            case Invalid:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid validity setting."));
            }
            break;

        case Exclusive:
            ASSERT(0 == m_dwShareCount);
            ASSERT(m_dwOwnerThreadId == GetCurrentThreadId());
            switch (nValid)
            {
            case Reset:
                // A reset card is still considered valid.
                // Fall through intentionally.
            case Verified:
                m_dwOwnerThreadId = 0;
                SetAvailabilityStatus(Ready);
                break;
            case Invalid:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid validity setting."));
            }
            break;

        case Direct:
            ASSERT(0 == m_dwShareCount);
            ASSERT(m_dwOwnerThreadId == GetCurrentThreadId());
            m_dwOwnerThreadId = 0;
            m_dwCurrentState = SCARD_UNKNOWN;
            m_dwAvailStatus = Undefined;
            break;

        case Closing:
        case Broken:
        case Inactive:
            switch (nValid)
            {
            case Reset:
                // A reset card is still considered valid.
                // Fall through intentionally.
            case Verified:
                if (0 != m_dwOwnerThreadId)
                {
                    ASSERT(m_dwOwnerThreadId == GetCurrentThreadId());
                    m_dwOwnerThreadId = 0;
                }
                else
                {
                    ASSERT(0 < m_dwShareCount);
                    m_dwShareCount -= 1;
                }
                break;
            case Invalid:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid validity setting."));
            }
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Disconnecting from disabled reader '%1'"),
                ReaderName());
            break;

        default:
            CalaisError(__SUBROUTINE__, 403);
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
        }
    }


    //
    // Verify our state is consistent, and dispose of the card as requested.
    //

    try
    {
        CLatchReader latch(this);
        VerifyState();
        VerifyActive(pActState);
        Dispose(dwDisposition);
        *pdwDispSts = SCARD_S_SUCCESS;
    }
    catch (DWORD dwErr)
    {
        *pdwDispSts = dwErr;
    }


    //
    // Release any mutex held by this thread.
    //

    while (m_mtxGrab.Share())
        ;   // empty loop body


    //
    // Check to see if the reader can be powered down.  We peek to see if
    // we should bother, and if so, go through the trouble of acquiring the
    // locks.  Then we check again to make sure it's still appropriate to
    // power it down.
    //

    if (Ready == AvailabilityStatus())
    {
        CLatchReader latch(this);
        CLockWrite rwLock(&m_rwLock);
        if (Ready == m_dwAvailStatus)
        {
            SetActive(FALSE);
            ReaderPowerDown();
            SetAvailabilityStatus(Present);
        }
    }
}


/*++

Reconnect:

    This method allows a service thread to adjust it's connection to this
    reader.

Arguments:

    dwShareMode supplies the share mode indicator.

    dwPreferredProtocols supplies a bitmask of acceptable protocols to
        negotiate.

    dwDisposition supplies an indication as to what to do to the card upon
        completion.

    pActiveState = This supplies the active state structure, to make sure that
        this is the same card as expected, and receives the snapshot of the
        active state to use in future access requests.

    pdwDispSts receives a disposition status code, indicating whether or not
        the requested disposition was carried out successfully.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/28/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Reconnect")

void
CReader::Reconnect(
    IN DWORD dwShareMode,
    IN DWORD dwPreferredProtocols,
    IN DWORD dwDisposition,
    IN OUT ActiveState *pActState,
    OUT LPDWORD pdwDispSts)
{
    enum { Unverified, Verified, Reset, Invalid } nValid = Unverified;
    AvailableState avlState;
    DWORD dwOwnerThreadId;
    DWORD dwShareCount;
    AvailableState avlState_bkup;
    DWORD dwOwnerThreadId_bkup;
    DWORD dwShareCount_bkup;
    ActiveState actState_bkup;
    DWORD dwRealReaderState;


    //
    // Reconnect to the card.
    //

    if ((SCARD_SHARE_DIRECT != dwShareMode) && (0 == dwPreferredProtocols))
        throw (DWORD)SCARD_E_INVALID_VALUE;


    //
    // Validate any existing connection.
    //

    try
    {
        VerifyActive(pActState);
        nValid = Verified;
    }
    catch (DWORD dwError)
    {
        switch (dwError)
        {
        case SCARD_W_RESET_CARD:
            nValid = Reset;
            break;
        case SCARD_W_REMOVED_CARD:
            nValid = Invalid;
            break;
        default:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Unrecognized validation error code '%1'.  Assuming Invalid."),
                dwError);
            nValid = Invalid;
        }
    }
    ASSERT(Unverified != nValid);

    *pdwDispSts = SCARD_E_CANT_DISPOSE;
    if (Verified == nValid)
    {

        //
        // Attempt to dispose of the card as requested.
        //

        try
        {
            while (m_mtxGrab.Share())
                ;   // Empty loop body
            CLatchReader latch(this, NULL);
            Dispose(dwDisposition);
            dwRealReaderState = GetReaderState();
            *pdwDispSts = SCARD_S_SUCCESS;
        }
        catch (DWORD dwError)
        {
            *pdwDispSts = dwError;
        }
        catch (...)
        {
            *pdwDispSts = SCARD_E_CANT_DISPOSE;
        }
    }
    else
        dwRealReaderState = GetReaderState(NULL);


    //
    // Change the card's internal state.
    //

    {
        CLockWrite rwLock(&m_rwLock);
        avlState_bkup = avlState = m_dwAvailStatus;
        dwOwnerThreadId_bkup = dwOwnerThreadId = m_dwOwnerThreadId;
        dwShareCount_bkup = dwShareCount = m_dwShareCount;
        CopyMemory(&actState_bkup, pActState, sizeof(ActiveState));

        switch (avlState)
        {
        case Idle:
            // Disconnect
            ASSERT(Invalid == nValid);

            // Connect
            ASSERT(0 == dwShareCount);
            ASSERT(0 == dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
                throw (DWORD)SCARD_W_REMOVED_CARD;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                if (0 != dwPreferredProtocols)
                    throw (DWORD)SCARD_W_REMOVED_CARD;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Unresponsive:
            // Disconnect
            ASSERT(Invalid == nValid);

            // Connect
            ASSERT(0 == dwShareCount);
            ASSERT(0 == dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
                throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                if (0 != dwPreferredProtocols)
                    throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
                break;
            default:
                throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
            }
            break;

        case Unsupported:
            // Disconnect
            ASSERT(Invalid == nValid);

            // Connect
            ASSERT(0 == dwShareCount);
            ASSERT(0 == dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
                throw (DWORD)SCARD_W_UNSUPPORTED_CARD;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                if (0 != dwPreferredProtocols)
                    throw (DWORD)SCARD_W_UNSUPPORTED_CARD;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Present:
            // Disconnect
            ASSERT(Invalid == nValid);

            // Connect
            if ((SCARD_SHARE_DIRECT == dwShareMode) && (0 != dwPreferredProtocols))
                throw (DWORD)SCARD_E_NOT_READY;
            // Fall through intentionally

        case Ready:
            // Disconnect
            ASSERT(Invalid == nValid);

            // Connect
            ASSERT(0 == dwShareCount);
            ASSERT(0 == dwOwnerThreadId);
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
                avlState = Exclusive;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            case SCARD_SHARE_SHARED:
                dwShareCount += 1;
                avlState = Shared;
                break;
            case SCARD_SHARE_DIRECT:
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Shared:
            ASSERT(0 < dwShareCount);
            ASSERT(0 == dwOwnerThreadId);

            // Disconnect
            switch (nValid)
            {
            case Reset:
                // A reset card is still considered valid.
                // Fall through intentionally.
            case Verified:
                dwShareCount -= 1;
                break;
            case Invalid:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid validity setting."));
            }

            // Connect
            switch (dwShareMode)
            {
            case SCARD_SHARE_DIRECT:
                if (0 != dwShareCount)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            case SCARD_SHARE_EXCLUSIVE:
                if (0 != dwShareCount)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Exclusive;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            case SCARD_SHARE_SHARED:
                avlState = Shared;
                dwShareCount += 1;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Exclusive:
            ASSERT(0 == dwShareCount);
            ASSERT(0 != dwOwnerThreadId);

            // Disconnect
            switch (nValid)
            {
            case Reset:
                // A reset card is still considered valid.
                // Fall through intentionally.
            case Verified:
                ASSERT(0 == m_dwShareCount);
                ASSERT(dwOwnerThreadId == GetCurrentThreadId());
                dwOwnerThreadId = 0;
                break;
            case Invalid:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid validity setting."));
            }

            // Connect
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
                if (0 != dwOwnerThreadId)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Exclusive;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            case SCARD_SHARE_SHARED:
                if (0 != dwOwnerThreadId)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Shared;
                dwShareCount += 1;
                break;
            case SCARD_SHARE_DIRECT:
                if (0 != dwOwnerThreadId)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Direct:
            ASSERT(0 == dwShareCount);
            ASSERT(0 != dwOwnerThreadId);

            // Disconnect
            switch (nValid)
            {
            case Reset:
                // A reset card is still considered valid.
                // Fall through intentionally.
            case Verified:
                ASSERT(0 == m_dwShareCount);
                ASSERT(dwOwnerThreadId == GetCurrentThreadId());
                dwOwnerThreadId = 0;
                break;
            case Invalid:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid validity setting."));
            }

            // Connect
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
                if (SCARD_PRESENT > dwRealReaderState)
                    throw (DWORD)SCARD_E_NO_SMARTCARD;
                if (0 != dwOwnerThreadId)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Exclusive;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            case SCARD_SHARE_SHARED:
                if (SCARD_PRESENT > dwRealReaderState)
                    throw (DWORD)SCARD_E_NO_SMARTCARD;
                if (0 != dwOwnerThreadId)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Shared;
                dwShareCount += 1;
                break;
            case SCARD_SHARE_DIRECT:
                if (0 != dwOwnerThreadId)
                    throw (DWORD)SCARD_E_SHARING_VIOLATION;
                avlState = Direct;
                dwOwnerThreadId = GetCurrentThreadId();
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        case Closing:
        case Broken:
        case Inactive:
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Reconnecting to disabled reader '%1'"),
                ReaderName());

            // Disconnect
            switch (nValid)
            {
            case Reset:
                // A reset card is still considered valid.
                // Fall through intentionally.
            case Verified:
                if (0 != dwOwnerThreadId)
                    dwOwnerThreadId = 0;
                else
                {
                    ASSERT(0 < dwShareCount);
                    dwShareCount -= 1;
                }
                break;
            case Invalid:
                break;
            default:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Invalid validity setting."));
            }

            // Connect
            switch (dwShareMode)
            {
            case SCARD_SHARE_EXCLUSIVE:
            case SCARD_SHARE_SHARED:
            case SCARD_SHARE_DIRECT:
                throw (DWORD)SCARD_E_READER_UNAVAILABLE;
                break;
            default:
                throw (DWORD)SCARD_E_INVALID_VALUE;
            }
            break;

        default:
            CalaisError(__SUBROUTINE__, 402);
            throw (DWORD)SCARD_F_INTERNAL_ERROR;
        }


        //
        // It's official!  Write the changes back to the structure.
        //

        CopyMemory(pActState, &m_ActiveState, sizeof(ActiveState));
        m_dwOwnerThreadId = dwOwnerThreadId;
        m_dwShareCount = dwShareCount;
        m_dwAvailStatus = avlState;
    }


    //
    // Verify the protocol settings.
    //

    if (0 != dwPreferredProtocols)
    {
        try
        {
            DWORD dwCurrentProtocol;

            CLatchReader latch(this, &m_ActiveState);
            PowerUp();
            SetActive(TRUE);
            dwCurrentProtocol = GetReaderAttr(SCARD_ATTR_CURRENT_PROTOCOL_TYPE);
            if (SCARD_PROTOCOL_UNDEFINED == dwCurrentProtocol)
            {
                SetReaderProto(dwPreferredProtocols);
                dwCurrentProtocol =
                    GetReaderAttr(SCARD_ATTR_CURRENT_PROTOCOL_TYPE);
                ASSERT(0 != dwCurrentProtocol);
            }
            else
            {
                if (0 == (dwPreferredProtocols & dwCurrentProtocol))
                {
                    switch (dwPreferredProtocols)
                    {
                    case SCARD_PROTOCOL_RAW:
                    {
                        if (Exclusive > avlState)
                            throw (DWORD)SCARD_E_SHARING_VIOLATION;
                        SetReaderProto(dwPreferredProtocols);
                        dwCurrentProtocol = GetReaderAttr(
                            SCARD_ATTR_CURRENT_PROTOCOL_TYPE);
                        ASSERT(0 != dwCurrentProtocol);
                        break;
                    }
                    case SCARD_PROTOCOL_DEFAULT:
                        ASSERT(SCARD_PROTOCOL_UNDEFINED != dwCurrentProtocol);
                        break;
                    default:
                        throw (DWORD)SCARD_E_PROTO_MISMATCH;
                    }
                }
            }
            CLockWrite rwLock(&m_rwLock);
            m_dwCurrentProtocol = dwCurrentProtocol;
            CopyMemory(pActState, &m_ActiveState, sizeof(ActiveState));
        }
        catch (...)
        {

            //
            // Back out the latest changes.
            //

            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Failed to establish protocol on reconnect"));

            CLockWrite rwLock(&m_rwLock);
            avlState = m_dwAvailStatus;
            dwOwnerThreadId = m_dwOwnerThreadId;
            dwShareCount = m_dwShareCount;

            switch (avlState)
            {

            //
            // We know from above that we're connected.  Other cases
            // can't possibly happen.
            //

            case Idle:
            case Unresponsive:
            case Unsupported:
            case Present:
            case Ready:
                ASSERT(Direct == avlState_bkup);
                m_dwAvailStatus = avlState_bkup ;
                m_dwOwnerThreadId = dwOwnerThreadId_bkup;
                m_dwShareCount = dwShareCount_bkup;
                break;

            case Shared:
                ASSERT(0 < dwShareCount);
                ASSERT(0 == dwOwnerThreadId);
                dwShareCount -= 1;
                if (0 == dwShareCount)
                    avlState = Ready;
                break;

            case Exclusive:
            case Direct:
                ASSERT(0 == dwShareCount);
                ASSERT(dwOwnerThreadId == GetCurrentThreadId());
                dwOwnerThreadId = 0;
                avlState = avlState_bkup;
                break;

            case Closing:
            case Broken:
            case Inactive:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Dis-Reconnecting from disabled reader '%1'"),
                    ReaderName());
                if (0 != dwOwnerThreadId)
                    dwOwnerThreadId = 0;
                else
                {
                    ASSERT(0 < dwShareCount);
                    dwShareCount -= 1;
                }
                break;

            default:
                CalaisError(__SUBROUTINE__, 411);
                throw (DWORD)SCARD_F_INTERNAL_ERROR;
            }


            //
            // We've rolled back to the original state.  Commit the changes.
            //

            CopyMemory(pActState, &actState_bkup, sizeof(ActiveState));
            m_dwOwnerThreadId = dwOwnerThreadId;
            m_dwShareCount = dwShareCount;
            SetAvailabilityStatus(avlState);
            throw;
        }
    }


    //
    // Ok, we can now admit to the changes
    //

    SetAvailabilityStatusLocked(avlState);
}


/*++

Free:

    This method is used to terminate another thread's hold on the reader.  It
    should be used only by thread termination code.

Arguments:

    dwThreadId supplies the thread believed to be holding the object.

    dwDisposition supplies the disposition of the card.

Return Value:

    None

Throws:

    Errors as DWORDs

Author:

    Doug Barlow (dbarlow) 6/19/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Free")

void
CReader::Free(
    DWORD dwThreadId,
    DWORD dwDisposition)
{
    BOOL fGrabbed = FALSE;

    try
    {
        if (m_mtxGrab.IsGrabbedBy(dwThreadId))
        {

            //
            // Careful!  We only want to take it away from the specified
            // thread, so we can't use the more general take routines.
            //

            m_mtxGrab.Take();
            fGrabbed = TRUE;

            CLatchReader latch(this);
            Dispose(dwDisposition);
            CLockWrite rwLock(&m_rwLock);
            switch (m_dwAvailStatus)
            {
            case Ready:
            case Idle:
            case Present:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Freeing hold on unheld reader!"));
                ASSERT(0 == m_dwShareCount);
                ASSERT(0 == m_dwOwnerThreadId);
                break;

            case Shared:
                ASSERT(0 < m_dwShareCount);
                ASSERT(0 == m_dwOwnerThreadId);
                m_dwShareCount -= 1;
                if (0 == m_dwShareCount)
                {
                    SetAvailabilityStatus(Ready);
                    SetActive(FALSE);
                    ReaderPowerDown();
                }
                break;

            case Exclusive:
            case Direct:
                ASSERT(0 == m_dwShareCount);
                ASSERT(m_dwOwnerThreadId == dwThreadId);
                m_dwOwnerThreadId = 0;
                SetAvailabilityStatus(Ready);
                SetActive(FALSE);
                ReaderPowerDown();
                break;

            case Closing:
            case Broken:
            case Inactive:
            case Unresponsive:
            case Unsupported:
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Freeing hold on freed reader!"));
                break;

            default:
                CalaisError(__SUBROUTINE__, 412);
                throw (DWORD)SCARD_F_INTERNAL_ERROR;
            }
        }
    }
    catch (...) {}

    if (fGrabbed)
        m_mtxGrab.Share();
}


/*++

IsInUse:

    This method provides a simple mechanism to determine whether or not this
    reader is in use by any applications.

Arguments:

    None

Return Value:

    TRUE - The reader is in use.
    FALSE - The reader is not in use.

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 4/21/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::IsInUse")

BOOL
CReader::IsInUse(
    void)
{
    BOOL fReturn = FALSE;

    switch (AvailabilityStatus())
    {
    case Idle:
    case Unresponsive:
    case Unsupported:
    case Present:
    case Ready:
    case Broken:
        fReturn = FALSE;
        break;

    case Shared:
    case Exclusive:
    case Direct:
        fReturn = TRUE;
        break;

    case Closing:
    case Inactive:
        fReturn = FALSE;
        break;

    default:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("IsInUse detected reader in invalid state"));
    }
    return fReturn;
}


/*++

ReaderPowerDown:

    This routine is the default implementation of the base method.  It
    just passes the same operation on to the control method.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderPowerDown")

void
CReader::ReaderPowerDown(
    void)
{
    DWORD dwSts;
    DWORD dwAction = SCARD_POWER_DOWN;

    ASSERT(IsLatchedByMe());

    dwSts = Control(
                IOCTL_SMARTCARD_POWER,
                (LPCBYTE)&dwAction,
                sizeof(DWORD));
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
    CLockWrite rwLock(&m_rwLock);
    m_dwCurrentProtocol = SCARD_PROTOCOL_UNDEFINED;
}

void
CReader::ReaderPowerDown(
    ActiveState *pActiveState)
{
    CLatchReader latch(this, pActiveState);
    ReaderPowerDown();
}


/*++

GetReaderAttr:

    Get attributes from the reader driver.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

    dwAttr - This supplies the identifier of the attribute being requested.

    bfValue - This buffer receives the returned attribute value.

    dwValue - This DWORD receives the returned attribute value.

    fLogError - This supplies a flag as to whether or not an error to this
        operation needs to be logged.  The default value is TRUE, to enable
        logging.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::GetReaderAttr")

void
CReader::GetReaderAttr(
    DWORD dwAttr,
    CBuffer &bfValue,
    BOOL fLogError)
{
    ASSERT(IsLatchedByMe());
    DWORD cbLen = bfValue.Space();
    DWORD dwSts = Control(
                    IOCTL_SMARTCARD_GET_ATTRIBUTE,
                    (LPCBYTE)&dwAttr,
                    sizeof(dwAttr),
                    bfValue.Access(),
                    &cbLen,
                    fLogError);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
    bfValue.Resize(cbLen);
}

DWORD
CReader::GetReaderAttr(
    DWORD dwAttr,
    BOOL fLogError)
{
    DWORD dwRetAttr = 0;
    DWORD cbLen = sizeof(DWORD);

    ASSERT(IsLatchedByMe());
    DWORD dwSts = Control(
                    IOCTL_SMARTCARD_GET_ATTRIBUTE,
                    (LPCBYTE)&dwAttr,
                    sizeof(dwAttr),
                    (LPBYTE)&dwRetAttr,
                    &cbLen,
                    fLogError);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
    return dwRetAttr;
}

void
CReader::GetReaderAttr(
    ActiveState *pActiveState,
    DWORD dwAttr,
    CBuffer &bfValue,
    BOOL fLogError)
{
    CLatchReader latch(this, pActiveState);
    GetReaderAttr(dwAttr, bfValue, fLogError);
}

DWORD
CReader::GetReaderAttr(
    ActiveState *pActiveState,
    DWORD dwAttr,
    BOOL fLogError)
{
    CLatchReader latch(this, pActiveState);
    return GetReaderAttr(dwAttr, fLogError);
}


/*++

SetReaderAttr:

    Set driver attributes.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

    dwAttr - This supplies the identifier of the attribute being set.

    pvValue - This supplies the value of the attribute being set, if any.

    cbValue - This supples the length of any buffer suppoed in pvValue,
        in bytes.

    dwValue - This supplies the value of the attribute being set as a DWORD.

    fLogError - This supplies a flag as to whether or not an error to this
        operation needs to be logged.  The default value is TRUE, to enable
        logging.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::SetReaderAttr")

void
CReader::SetReaderAttr(
    DWORD dwAttr,
    LPCVOID pvValue,
    DWORD cbValue,
    BOOL fLogError)
{
    DWORD dwSts;
    CBuffer bfAttr(sizeof(DWORD) + cbValue);

    ASSERT(IsLatchedByMe());
    bfAttr.Set((LPCBYTE)&dwAttr, sizeof(DWORD));
    bfAttr.Append((LPCBYTE)pvValue, cbValue);
    dwSts = Control(
                IOCTL_SMARTCARD_SET_ATTRIBUTE,
                bfAttr.Access(),
                bfAttr.Length(),
                NULL,
                NULL,
                fLogError);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
}

void
CReader::SetReaderAttr(
    DWORD dwAttr,
    DWORD dwValue,
    BOOL fLogError)
{
    DWORD dwSts, rgdwValue[2];

    ASSERT(IsLatchedByMe());
    rgdwValue[0] = dwAttr;
    rgdwValue[1] = dwValue;
    dwSts = Control(
                IOCTL_SMARTCARD_SET_ATTRIBUTE,
                (LPCBYTE)rgdwValue,
                sizeof(rgdwValue),
                NULL,
                NULL,
                fLogError);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
}

void
CReader::SetReaderAttr(
    ActiveState *pActiveState,
    DWORD dwAttr,
    LPCVOID pvValue,
    DWORD cbValue,
    BOOL fLogError)
{
    CLatchReader latch(this, pActiveState);
    SetReaderAttr(dwAttr, pvValue, cbValue, fLogError);
}

void
CReader::SetReaderAttr(
    ActiveState *pActiveState,
    DWORD dwAttr,
    DWORD dwValue,
    BOOL fLogError)
{
    CLatchReader latch(this, pActiveState);
    SetReaderAttr(dwAttr, dwValue, fLogError);
}


/*++

SetReaderProto:

    Set the driver protocol.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

    dwProto - This supplies the protocol to which to force the smartcard in the
        current reader.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::SetReaderProto")

void
CReader::SetReaderProto(
    DWORD dwProto)
{
    DWORD dwSts, dwNew, dwLen;

    ASSERT(IsLatchedByMe());
    dwLen = sizeof(DWORD);
    dwNew = 0;
    dwSts = Control(
                IOCTL_SMARTCARD_SET_PROTOCOL,
                (LPCBYTE)&dwProto,
                sizeof(DWORD),
                (LPBYTE)&dwNew,
                &dwLen);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
}

void
CReader::SetReaderProto(
    ActiveState *pActiveState,
    DWORD dwProto)
{
    CLatchReader latch(this, pActiveState);
    SetReaderProto(dwProto);
}


/*++

SetActive:

    Tell the driver it's active.

Arguments:

    fActive supplies the indication to be passed to the driver.

Return Value:

    None

Throws:

    None - It specifically swallows any errors.

Author:

    Doug Barlow (dbarlow) 7/15/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::SetActive")

#define DISABLED 0xff00
void
CReader::SetActive(
    IN BOOL fActive)
{
    ASSERT(DISABLED != TRUE);
    ASSERT(DISABLED != FALSE);
    ASSERT(IsLatchedByMe());
    CLockWrite lock(&m_rwLock);

    if ((DISABLED != m_fDeviceActive) && (fActive != m_fDeviceActive))
    {
        try
        {
            // Don't report any errors
            SetReaderAttr(SCARD_ATTR_DEVICE_IN_USE, fActive, FALSE);
        }
        catch (...)
        {
            fActive = DISABLED;
        }
        m_fDeviceActive = fActive;
    }
}


/*++

ReaderTransmit:

    Transmit data to the driver.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

    pbSendData supplies the data to be sent,

    cbSendData supplies the length of the data to be sent, in bytes.

    bfRecvData receives the returned data.  It is assumed that this buffer has
        been presized to receive the largest maximum return.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderTransmit")

void
CReader::ReaderTransmit(
    LPCBYTE pbSendData,
    DWORD cbSendData,
    CBuffer &bfRecvData)
{
    DWORD dwSts, cbLen;

    ASSERT(IsLatchedByMe());

    cbLen = bfRecvData.Space();
    dwSts = Control(
                IOCTL_SMARTCARD_TRANSMIT,
                pbSendData,
                cbSendData,
                bfRecvData.Access(),
                &cbLen);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
    bfRecvData.Resize(cbLen);
}

void
CReader::ReaderTransmit(
    ActiveState *pActiveState,
    LPCBYTE pbSendData,
    DWORD cbSendData,
    CBuffer &bfRecvData)
{
    CLatchReader latch(this, pActiveState);
    ReaderTransmit(pbSendData, cbSendData, bfRecvData);
}


/*++

ReaderSwallow:

    Tell the reader driver to swallow a card.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderSwallow")

void
CReader::ReaderSwallow(
    void)
{
    DWORD dwSts;

    ASSERT(IsLatchedByMe());
    dwSts = Control(
                IOCTL_SMARTCARD_SWALLOW);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
}

void
CReader::ReaderSwallow(
    ActiveState *pActiveState)
{
    CLatchReader latch(this, pActiveState);
    ReaderSwallow();
}


/*++

ReaderColdReset:

    Tell the driver to do a cold reset on the card.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

    bfAtr - This receives the reported ATR string of the card.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderColdReset")

void
CReader::ReaderColdReset(
    CBuffer &bfAtr)
{
    DWORD dwSts;
    DWORD dwAction = SCARD_COLD_RESET;
    DWORD cbLen;
#ifdef DBG
    CBuffer cfAtrSiCrypt((PBYTE) "\x3B\xEF\x00\x00\x81\x31\x20\x49\x00\x5C\x50\x43\x54\x10\x27\xF8\xD2\x76\x00\x00\x38\x33\x00\x4D", 24);
#endif

    ASSERT(IsLatchedByMe());

    bfAtr.Presize(33);
    cbLen = bfAtr.Space();
    dwSts = Control(
                IOCTL_SMARTCARD_POWER,
                (LPCBYTE)&dwAction,
                sizeof(DWORD),
                bfAtr.Access(),
                &cbLen);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
    bfAtr.Resize(cbLen, TRUE);
    if ((2 > cbLen) && (Direct > AvailabilityStatus()))
    {
        CalaisInfo(
            __SUBROUTINE__,
            DBGT("Reader '%1' Unresponsive to cold reset"),
            ReaderName());
        throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
    }
#ifdef DBG
    if(bfAtr.Compare(cfAtrSiCrypt) == 0) {

        DebugBreak();
    }
#endif
}

void
CReader::ReaderColdReset(
    ActiveState *pActiveState,
    CBuffer &bfAtr)
{
    CLatchReader latch(this, pActiveState);
    ReaderColdReset(bfAtr);
}


/*++

ReaderWarmReset:

    Tell the reader driver to do a warm reset on the card.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

    bfAtr - This receives the reported ATR string of the card.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderWarmReset")

void
CReader::ReaderWarmReset(
    CBuffer &bfAtr)
{
    DWORD dwSts;
    DWORD dwAction = SCARD_WARM_RESET;
    DWORD cbLen;

    ASSERT(IsLatchedByMe());

    bfAtr.Presize(33);
    cbLen = bfAtr.Space();
    dwSts = Control(
                IOCTL_SMARTCARD_POWER,
                (LPCBYTE)&dwAction,
                sizeof(DWORD),
                bfAtr.Access(),
                &cbLen);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
    bfAtr.Resize(cbLen, TRUE);
    if ((2 > cbLen) && (Direct > AvailabilityStatus()))
    {
        CalaisInfo(
            __SUBROUTINE__,
            DBGT("Reader '%1' Unresponsive to warm reset"),
            ReaderName());
        throw (DWORD)SCARD_W_UNRESPONSIVE_CARD;
    }
}

void
CReader::ReaderWarmReset(
    ActiveState *pActiveState,
    CBuffer &bfAtr)
{
    CLatchReader latch(this, pActiveState);
    ReaderWarmReset(bfAtr);
}


/*++

ReaderEject:

    Tell the driver to eject the card.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderEject")

void
CReader::ReaderEject(
    void)
{
    DWORD dwSts;

    ASSERT(IsLatchedByMe());
    dwSts = Control(
                IOCTL_SMARTCARD_EJECT);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
}

void
CReader::ReaderEject(
    ActiveState *pActiveState)
{
    CLatchReader latch(this, pActiveState);
    ReaderEject();
}


#ifdef  SCARD_CONFISCATE_CARD
/*++

ReaderConfiscate:

    Tell the driver to confiscate the card.

Arguments:

    pActiveState - This supplies an active state structure to be used to verify
        connection integrity.

Return Value:

    None

Throws:

    Errors returned from the control method.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderConfiscate")

void
CReader::ReaderConfiscate(
    void)
{
    DWORD dwSts, dwRetLen;

    ASSERT(IsLatchedByMe());
    dwSts = Control(
                IOCTL_SMARTCARD_CONFISCATE);
    if (SCARD_S_SUCCESS != dwSts)
        throw dwSts;
}

void
CReader::ReaderConfiscate(
    ActiveState *pActiveState)
{
    CLatchReader grab(this, pActiveState);
    ReaderConfiscate();
}
#endif


//
///////////////////////////////////////////////////////////////////////////////
//
// The following routines are default actions for child reader classes.
//


/*++

Control:

    The default implementation of Control just returns the error code
    'NO_SUPPORT'.

Arguments:

    dwCode - This supplies the control code for the operation. This value
        identifies the specific operation to be performed.

    pbSend - This supplies a pointer to a buffer that contains the data required
        to perform the operation.  This parameter can be NULL if the dwCode
        parameter specifies an operation that does not require input data.

    cbSend - This supplies the size, in bytes, of the buffer pointed to by
        pbSend.

    pbRedv = This buffer recieves the return value, if any.  If none is
        expected, this parameter may be NULL.

    pcbRecv - This supplies the length of the pbRecv buffer in bytes, and
        receives the actual length of the return value, in bytes.  This
        parameter may be NULL if and only if pbRecv is NULL.

    fLogError - This supplies a flag indicating whether or not errors should
        be logged.  The default is TRUE.

Return Value:

    As returned from the driver or handler.

Throws:

    Per VerifyActive.

Author:

    Doug Barlow (dbarlow) 6/10/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::Control")

DWORD
CReader::Control(
    ActiveState *pActiveState,
    DWORD dwCode,
    LPCBYTE pbSend,
    DWORD cbSend,
    LPBYTE pbRecv,
    LPDWORD pcbLen,
    BOOL fLogError)
{
    CLatchReader latch(this, pActiveState);
    return Control(dwCode, pbSend, cbSend, pbRecv, pcbLen, fLogError);
}

DWORD
CReader::Control(
    DWORD dwCode,
    LPCBYTE pbSend,
    DWORD cbSend,
    LPBYTE pbRecv,
    LPDWORD pcbRecv,
    BOOL fLogError)
{
    return ERROR_NOT_SUPPORTED;
}


/*++

ReaderHandle:

    This method returns a designated value identifying the reader.  The actual
    value is dependent on the object's type and state, and is not guaranteed to
    be unique among readers.

Arguments:

    None

Return Value:

    The designated handle of this reader.

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::ReaderHandle")

HANDLE
CReader::ReaderHandle(
    void)
const
{
    return INVALID_HANDLE_VALUE;
}


/*++

DeviceName:

    This method returns any low level name associated with the reader.

Arguments:

    None

Return Value:

    The low level name of the reader.

Author:

    Doug Barlow (dbarlow) 4/15/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ DBGT("CReader::DeviceName")

LPCTSTR
CReader::DeviceName(
    void)
const
{
    return TEXT("");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\changpin\chpindlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       chPinDlg.cpp
//
//--------------------------------------------------------------------------

// chPinDlg.cpp : implementation file
//

#include "stdafx.h"
#include <winscard.h>
#include <wincrypt.h>
#include <scardlib.h>
#include "chPin.h"
#include "chPinDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static UINT AFX_CDECL WorkThread(LPVOID);
static DWORD CSPType(IN LPCTSTR szProvider);

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChangePinDlg dialog

CChangePinDlg::CChangePinDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CChangePinDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CChangePinDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CChangePinDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CChangePinDlg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CChangePinDlg, CDialog)
    //{{AFX_MSG_MAP(CChangePinDlg)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_MESSAGE(APP_ALLDONE, OnAllDone)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChangePinDlg message handlers

BOOL CChangePinDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // Add "About..." menu item to system menu.

    // IDM_ABOUTBOX must be in the system command range.
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX < 0xF000);

    CMenu* pSysMenu = GetSystemMenu(FALSE);
    if (pSysMenu != NULL)
    {
        CString strAboutMenu;
        strAboutMenu.LoadString(IDS_ABOUTBOX);
        if (!strAboutMenu.IsEmpty())
        {
            pSysMenu->AppendMenu(MF_SEPARATOR);
            pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
        }
    }

    // Set the icon for this dialog.  The framework does this automatically
    //  when the application's main window is not a dialog
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon

    // TODO: Add extra initialization here
    m_pThread = AfxBeginThread(WorkThread, this);

    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CChangePinDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
    if ((nID & 0xFFF0) == IDM_ABOUTBOX)
    {
        CAboutDlg dlgAbout;
        dlgAbout.DoModal();
    }
    else
    {
        CDialog::OnSysCommand(nID, lParam);
    }
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CChangePinDlg::OnPaint()
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CChangePinDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

static UINT AFX_CDECL
WorkThread(
    LPVOID pv)
{
    static TCHAR szReader[MAX_PATH];
    static TCHAR szCard[MAX_PATH];
    static TCHAR szProvider[MAX_PATH];
    static BYTE  pbSignature[(1024 / 8) + (4 * sizeof(DWORD))];
    CChangePinDlg *pDlg = (CChangePinDlg *)pv;
    OPENCARDNAME_EX ocn;
    OPENCARD_SEARCH_CRITERIA ocsc;
    SCARDCONTEXT hCtx = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    HCRYPTHASH hHash = NULL;
    DWORD dwSts, dwLen, dwKeyType;
    DWORD dwProvType;
    BOOL fSts;
    CString szFqcn;

    dwSts = SCardEstablishContext(SCARD_SCOPE_USER, NULL, NULL, &hCtx);
    if (SCARD_S_SUCCESS != dwSts)
        goto ErrorExit;

    ZeroMemory(&ocsc, sizeof(ocsc));
    ocsc.dwStructSize = sizeof(ocsc);
    // LPSTR           lpstrGroupNames;        // OPTIONAL reader groups to include in
    // DWORD           nMaxGroupNames;         //          search.  NULL defaults to
    //                                         //          SCard$DefaultReaders
    // LPCGUID         rgguidInterfaces;       // OPTIONAL requested interfaces
    // DWORD           cguidInterfaces;        //          supported by card's SSP
    // LPSTR           lpstrCardNames;         // OPTIONAL requested card names; all cards w/
    // DWORD           nMaxCardNames;          //          matching ATRs will be accepted
    // LPOCNCHKPROC    lpfnCheck;              // OPTIONAL if NULL no user check will be performed.
    // LPOCNCONNPROCA  lpfnConnect;            // OPTIONAL if lpfnConnect is provided,
    // LPOCNDSCPROC    lpfnDisconnect;         //          lpfnDisconnect must also be set.
    // LPVOID          pvUserData;             // OPTIONAL parameter to callbacks
    // DWORD           dwShareMode;            // OPTIONAL must be set if lpfnCheck is not null
    // DWORD           dwPreferredProtocols;   // OPTIONAL

    ZeroMemory(&ocn, sizeof(ocn));
    ocn.dwStructSize = sizeof(ocn);
    ocn.hSCardContext = hCtx;
    ocn.hwndOwner = pDlg->m_hWnd;
    ocn.dwFlags = SC_DLG_FORCE_UI;
    ocn.lpstrTitle = TEXT("Change PIN Card Selection");
    ocn.lpstrSearchDesc = TEXT("Select the Smart Card who's PIN is to be changed.");
//    HICON           hIcon;                  // OPTIONAL 32x32 icon for your brand insignia
    ocn.pOpenCardSearchCriteria = &ocsc;
//    LPOCNCONNPROCA  lpfnConnect;            // OPTIONAL - performed on successful selection
//    LPVOID          pvUserData;             // OPTIONAL parameter to lpfnConnect
//    DWORD           dwShareMode;            // OPTIONAL - if lpfnConnect is NULL, dwShareMode and
//    DWORD           dwPreferredProtocols;   // OPTIONAL   dwPreferredProtocols will be used to
//                                            //            connect to the selected card
    ocn.lpstrRdr = szReader;
    ocn.nMaxRdr = sizeof(szReader) / sizeof(TCHAR);
    ocn.lpstrCard = szCard;
    ocn.nMaxCard = sizeof(szCard) / sizeof(TCHAR);
//    DWORD               dwActiveProtocol;       // [OUT] set only if dwShareMode not NULL
//    SCARDHANDLE         hCardHandle;            // [OUT] set if a card connection was indicated

    dwSts = SCardUIDlgSelectCard(&ocn);
    if (NULL != ocn.hCardHandle)
        dwSts = SCardDisconnect(ocn.hCardHandle, SCARD_LEAVE_CARD);
    if (SCARD_S_SUCCESS != dwSts)
        goto ErrorExit;


    //
    // The user has selected a card.  Translate that into a CSP.
    //

    dwLen = sizeof(szProvider) / sizeof(TCHAR);
    dwSts = SCardGetCardTypeProviderName(
                hCtx,
                szCard,
                SCARD_PROVIDER_CSP,
                szProvider,
                &dwLen);
    if (SCARD_S_SUCCESS != dwSts)
        goto ErrorExit;
    dwSts = SCardReleaseContext(hCtx);
    hCtx = NULL;
    if (SCARD_S_SUCCESS != dwSts)
        goto ErrorExit;
    dwProvType = CSPType(szProvider);
    if (0 == dwProvType)
    {
        dwSts = NTE_PROV_TYPE_ENTRY_BAD;
        goto ErrorExit;
    }
    szFqcn = TEXT("\\\\.\\");
    szFqcn += szReader;


    //
    // Activate a Key on the card.
    //

    fSts = CryptAcquireContext(&hProv, szFqcn, szProvider, dwProvType, 0);
    if (!fSts)
    {
        dwSts = GetLastError();
        goto ErrorExit;
    }
    for (dwKeyType = AT_KEYEXCHANGE; dwKeyType <= AT_SIGNATURE; dwKeyType += 1)
    {
        fSts = CryptGetUserKey(hProv, dwKeyType, &hKey);
        if (fSts)
            break;
    }
    if (!fSts)
    {
        dwSts = GetLastError();
        goto ErrorExit;
    }


    //
    // Use the CSP to force a PIN prompt.
    //

    fSts = CryptCreateHash(hProv, CALG_SHA, NULL, 0, &hHash);
    if (!fSts)
    {
        dwSts = GetLastError();
        goto ErrorExit;
    }
    fSts = CryptHashData(hHash, (LPBYTE)szProvider, sizeof(szProvider), 0);
    if (!fSts)
    {
        dwSts = GetLastError();
        goto ErrorExit;
    }
    dwLen = sizeof(pbSignature);
    fSts = CryptSignHash(hHash, dwKeyType, NULL, 0, pbSignature, &dwLen);


    //
    // All done.  Clean up and notify the main thread that we're done.
    //

ErrorExit:
    if (NULL != hHash)
        CryptDestroyHash(hHash);
    if (NULL != hKey)
        CryptDestroyKey(hKey);
    if (NULL != hProv)
        CryptReleaseContext(hProv, 0);
    if (NULL != hCtx)
        SCardReleaseContext(hCtx);
    if (SCARD_S_SUCCESS != dwSts)
        AfxMessageBox(ErrorString(dwSts), MB_ICONEXCLAMATION | MB_OK);
    pDlg->PostMessage(APP_ALLDONE);
    return 0;
}




/*++

CSPType:

    This function converts a CSP Name to a CSP Type.

Arguments:

    szProvider supplies the name of the CSP.

Return Value:

    The CSP type of the given CSP, or zero if no such CSP can be found.

Author:

    Doug Barlow (dbarlow) 1/14/1999

--*/

static DWORD
CSPType(
    IN LPCTSTR szProvider)
{
    LONG nSts;
    HKEY hList = NULL;
    HKEY hProv = NULL;
    DWORD dwProvType, dwValType, dwValLen;

    nSts = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider"),
                0,
                KEY_READ,
                &hList);
    if (ERROR_SUCCESS != nSts)
        goto ErrorExit;
    nSts = RegOpenKeyEx(
                hList,
                szProvider,
                0,
                KEY_READ,
                &hProv);
    if (ERROR_SUCCESS != nSts)
        goto ErrorExit;
    dwValLen = sizeof(DWORD);
    dwProvType = 0; // Assumes little endian.
    nSts = RegQueryValueEx(
                hProv,
                TEXT("Type"),
                0,
                &dwValType,
                (LPBYTE)&dwProvType,
                &dwValLen);
    if (ERROR_SUCCESS != nSts)
        goto ErrorExit;
    RegCloseKey(hProv);
    RegCloseKey(hList);
    return dwProvType;

ErrorExit:
    if (NULL != hProv)
        RegCloseKey(hProv);
    if (NULL != hList)
        RegCloseKey(hList);
    return 0;
}

LRESULT
CChangePinDlg::OnAllDone(
    WPARAM wParam,
    LPARAM lParam)
{
    WaitForSingleObject(m_pThread->m_hThread, INFINITE);
    CDialog::OnOK();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\changpin\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ChangePin.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define APP_ALLDONE                     101
#define IDD_CHANGEPIN_DIALOG            102
#define IDR_MAINFRAME                   128

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\changpin\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       StdAfx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	ChangePin.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\changpin\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       StdAfx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__99CC45B9_C1C8_11D2_88F3_00C04F79F800__INCLUDED_)
#define AFX_STDAFX_H__99CC45B9_C1C8_11D2_88F3_00C04F79F800__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
// #include <afxdtctl.h>       // MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
// #include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__99CC45B9_C1C8_11D2_88F3_00C04F79F800__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\checksc\checksc.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

	CheckSC

Abstract:

    This application is used to provide a snapshot of the Calais (Smart Card
	Resource Manager) service's status, and to display certificates on smart
	cards via the common WinNT UI.

	CheckSC -- describes the RM status and displays each available sc cert(s)
			
	-r Readername	-- for just one reader
	-sig			-- display signature key certs only
	-ex				-- display exchange key certs only
	-nocert			-- don't look for certs to display
	-key			-- verify keyset public key matches cert public key

Author:

    Amanda Matlosz (AMatlosz) 07/14/1998

Environment:

    Win32 Console App

Notes:

    For use in NT5 public key rollout testing

--*/

/*++
	need to include the following libs:

    calaislb.lib (unicode build: calaislbw.lib)
	winscard.lib
--*/
#include <iostream.h>
#include <stdlib.h>
#include <stdio.h>
// #include <string.h>
// #include <stdarg.h>
#include <winscard.h>
#include <SCardLib.h>
#include <winsvc.h>
#include <scEvents.h>
#include <cryptui.h>



#ifndef SCARD_PROVIDER_CSP
#define SCARD_PROVIDER_CSP 2
#endif

#define KERB_PKINIT_CLIENT_CERT_TYPE szOID_PKIX_KP_CLIENT_AUTH

// 
// Globals
//

int g_nKeys;
DWORD g_rgKeySet[2]; // { AT_KEYEXCHANGE , AT_SIGNATURE };
SCARDCONTEXT g_hSCardCtx;
LPTSTR g_szReaderName;
DWORD g_dwNumReaders;
BOOL g_fReaderNameAllocd;
BOOL g_fChain = FALSE;
BOOL g_fPublicKeyCheck = FALSE;
SCARD_READERSTATE* g_pReaderStatusArray;
const char* g_szEx = TEXT("exchange");
const char* g_szSig = TEXT("signature");


//
// Functions
//

///////////////////////////////////////////////////////////////////////////////
// DisplayUsage does easy UI
void DisplayUsage()
{
    cout << "\n"
         << "CheckSC [-sig|-ex|-nocert|-chain|-key] [-r \"Readername\"]\n"
		 << " -sig    Displays only signature key certificates.\n"
		 << " -ex     Displays only signature key certificates.\n"
         << " -nocert Does not display smart card certificates.\n"
         << " -chain  Check trust status.\n"  
		 << " -key    Verify keyset public key matches certificate public key.\n"
         << endl;
}

///////////////////////////////////////////////////////////////////////////////
// ProcessCommandLine does the dirty work, sets behavior globals
bool ProcessCommandLine(DWORD cArgs, LPCTSTR rgszArgs[])
{

	// set everything to default

    g_szReaderName = NULL;  // no reader
	g_rgKeySet[0] = AT_KEYEXCHANGE; // certs for both kinds of keys
	g_rgKeySet[1] = AT_SIGNATURE;
	g_nKeys = 2;
	
    if (cArgs == 1) 
    {
        return true;
    }

	// For each arg, verify that it's a real arg and deal with it

	bool fLookForReader = false;
	bool fCertOptionSpecified = false;
	bool fBogus = FALSE;

	for (DWORD n=1; n<cArgs; n++)
	{
		if ('/' == *rgszArgs[n] || '-' == *rgszArgs[n])
		{
			if (0 == _stricmp("r", rgszArgs[n]+1*sizeof(TCHAR))) // reader
			{
				fLookForReader = true;
			}
			else if (0 == _stricmp("sig",rgszArgs[n]+1*sizeof(TCHAR))) // signature cert only
			{
				if (true == fCertOptionSpecified)
				{
					// bogus!
					fBogus = true;
					break;
				}
				g_rgKeySet[0] = AT_SIGNATURE;
				g_nKeys = 1;
			}
			else if (0 == _stricmp("ex",rgszArgs[n]+1*sizeof(TCHAR))) // exchange cert only
			{
				if (true == fCertOptionSpecified)
				{
					// bogus!
					fBogus = true;
					break;
				}
				g_rgKeySet[0] = AT_KEYEXCHANGE;
				g_nKeys = 1;
			}
			else if (0 == _stricmp("nocert",rgszArgs[n]+1*sizeof(TCHAR))) // no certs
			{
				if (true == fCertOptionSpecified)
				{
					// bogus!
					fBogus = true;
					break;
				}
				g_nKeys = 0;
			}
			else if (0 == _stricmp("chain",rgszArgs[n]+1*sizeof(TCHAR))) // verify chain
			{
			    g_fChain = TRUE;

			}
			else if (0 == _stricmp("key",rgszArgs[n]+1*sizeof(TCHAR))) // verify cert & keyset
			{
				g_fPublicKeyCheck = TRUE;
			}
			else
			{
				// bogus!!
				fBogus = true;
				break;
			}
		}
		else if (fLookForReader)
		{
			fLookForReader = false;
			g_szReaderName = (LPTSTR)rgszArgs[n];
		}
		else
		{
			// Bogus!
			fBogus = true;
			break;
		}
	}

	if (!fLookForReader && !fBogus)
	{
		// All's well, we're set to go
		return true;
	}

	//
	// educate user when args incorrect
	//

	DisplayUsage();
	return false;
}


///////////////////////////////////////////////////////////////////////////////
bool IsCalaisRunning()
{
	bool fCalaisUp = false;
    HANDLE hCalaisStarted = NULL;

    HMODULE hDll = GetModuleHandle( TEXT("WINSCARD.DLL") );

    typedef HANDLE (WINAPI *PFN_SCARDACCESSSTARTEDEVENT)(VOID);
    PFN_SCARDACCESSSTARTEDEVENT pSCardAccessStartedEvent;

    pSCardAccessStartedEvent = (PFN_SCARDACCESSSTARTEDEVENT) GetProcAddress(hDll, "SCardAccessStartedEvent");

    if (pSCardAccessStartedEvent)
    {
        hCalaisStarted = pSCardAccessStartedEvent();
    }

    if (hCalaisStarted)
    {
        if (WAIT_OBJECT_0 == WaitForSingleObject(hCalaisStarted, 1000))
        {
            fCalaisUp = true;
        }
    }


	//
	// Display status
	//

	if (fCalaisUp)
	{
		cout << "\n"
			 << "The Microsoft Smart Card Resource Manager is running.\n"
			 << endl;
	}
	else
	{
		cout << "\n"
			 << "The Microsoft Smart Card Resource Manager is not running.\n"
			 << endl;
	}

    //
    // Clean up
    //

	return fCalaisUp;
}


///////////////////////////////////////////////////////////////////////////////
// DisplayReaderList tries to set g_hSCardCtx, get a list of currently available
// smart card readers, and display their status
void DisplayReaderList()
{
	long lReturn = SCARD_S_SUCCESS;

	cout << "Current reader/card status:\n" << endl;

	// Acquire global SCARDCONTEXT from resource manager if possible

    lReturn = SCardEstablishContext(SCARD_SCOPE_USER,
									NULL,
									NULL,
									&g_hSCardCtx);

	if (SCARD_S_SUCCESS != lReturn)
	{
		cout << "SCardEstablishContext failed for user scope.\n"
			 << "A list of smart card readers cannot be determined.\n"
			 << endl;

		return;
	}

	// Build a readerstatus array from either a list of readers; or use the one the user specified

	g_dwNumReaders = 0;
	if (NULL == g_szReaderName)
	{
		DWORD dwAutoAllocate = SCARD_AUTOALLOCATE;
		g_fReaderNameAllocd = true;
		lReturn = SCardListReaders(g_hSCardCtx,
									SCARD_DEFAULT_READERS,
									(LPTSTR)&g_szReaderName,
									&dwAutoAllocate);

		if (SCARD_S_SUCCESS != lReturn)
		{
			TCHAR szMsg[128]; // %Xx
			sprintf(szMsg, 
					"SCardListReaders failed for SCARD_ALL_READERS with: 0x%X.\n",
					lReturn);

			cout << szMsg;
			if (SCARD_E_NO_READERS_AVAILABLE == lReturn)
			{
				cout << "No smart card readers are currently available.\n";
			}
			else
			{
				cout << "A list of smart card readers could not be determined.\n";
			}
			cout << endl;

			return;
		}

		// Build a readerstatus array...

		LPCTSTR szReaderName = g_szReaderName;
		g_dwNumReaders = MStringCount(szReaderName);

		g_pReaderStatusArray = new SCARD_READERSTATE[g_dwNumReaders];
		::ZeroMemory((LPVOID)g_pReaderStatusArray, sizeof(g_pReaderStatusArray));

		szReaderName = FirstString(szReaderName);

		for (DWORD dwRdr = 0; NULL != szReaderName && dwRdr < g_dwNumReaders; szReaderName = NextString(szReaderName), dwRdr++)
		{
			g_pReaderStatusArray[dwRdr].szReader = (LPCTSTR)szReaderName;
			g_pReaderStatusArray[dwRdr].dwCurrentState = SCARD_STATE_UNAWARE;
		}
	}
	else
	{
		g_dwNumReaders = 1;
		g_pReaderStatusArray = new SCARD_READERSTATE;
		g_pReaderStatusArray->szReader = (LPCTSTR)g_szReaderName;
		g_pReaderStatusArray->dwCurrentState = SCARD_STATE_UNAWARE;
	}

	// ...And get the reader status from the resource manager
		
	lReturn = SCardGetStatusChange(g_hSCardCtx,
		                            INFINITE, // hardly
				                    g_pReaderStatusArray,
					                g_dwNumReaders);

	if (SCARD_S_SUCCESS != lReturn)
	{
		TCHAR szMsg[128]; // %Xx
		sprintf(szMsg, 
				"SCardGetStatusChange failed with: 0x%X.\n",
				lReturn);

		cout << szMsg << endl;

		sprintf(szMsg, 
				"MStringCount returned %d readers.\n",
				g_dwNumReaders);
		cout << szMsg << endl;

		return;
	}

	// Finally, display all reader information

	DWORD dwState = 0;
	for (DWORD dwRdrSt = 0; dwRdrSt < g_dwNumReaders; dwRdrSt++)
	{

		//--- reader: readerName\n
		cout << TEXT("--- reader: ") 
			<< g_pReaderStatusArray[dwRdrSt].szReader 
			<< TEXT("\n");

		//--- status: /bits/\n
		bool fOr = false;
		cout << TEXT("--- status: ");
		dwState = g_pReaderStatusArray[dwRdrSt].dwEventState;

		if (0 != (dwState & SCARD_STATE_UNKNOWN))
		{
			cout << TEXT("SCARD_STATE_UNKNOWN ");
			fOr = true;
		}
		if (0 != (dwState & SCARD_STATE_UNAVAILABLE))
		{
			if (fOr)
			{
				cout << TEXT("| ");
			}
			cout << TEXT("SCARD_STATE_UNAVAILABLE ");
			fOr = true;
		}
		if (0 != (dwState & SCARD_STATE_EMPTY))
		{
			if (fOr)
			{
				cout << TEXT("| ");
			}
			cout << TEXT("SCARD_STATE_EMPTY ");
			fOr = true;
		}
		if (0 != (dwState & SCARD_STATE_PRESENT))
		{
			if (fOr)
			{
				cout << TEXT("| ");
			}
			cout << TEXT("SCARD_STATE_PRESENT ";)
			fOr = true;
		}
		if (0 != (dwState & SCARD_STATE_EXCLUSIVE))
		{
			if (fOr)
			{
				cout << TEXT("| ";)
			}
			cout << TEXT("SCARD_STATE_EXCLUSIVE ");
			fOr = true;
		}
		if (0 != (dwState & SCARD_STATE_INUSE))
		{
			if (fOr)
			{
				cout << TEXT("| ");
			}
			cout << TEXT("SCARD_STATE_INUSE ");
			fOr = true;
		}
		if (0 != (dwState & SCARD_STATE_MUTE))
		{
			if (fOr)
			{
				cout << TEXT("| ");
			}
			cout << TEXT("SCARD_STATE_MUTE ");
			fOr = true;
		}
		if (0 != (dwState & SCARD_STATE_UNPOWERED))
		{
			if (fOr)
			{
				cout << TEXT("| ");
			}
			cout << TEXT("SCARD_STATE_UNPOWERED");
			fOr = true;
		}
		cout << TEXT("\n");
		
		//--- status: what scstatus would say\n
		cout << TEXT("--- status: ");
		
		// NO CARD
		if(dwState & SCARD_STATE_EMPTY)
		{
			cout << TEXT("No card.");// SC_STATUS_NO_CARD;
		}
		// CARD in reader: SHARED, EXCLUSIVE, FREE, UNKNOWN ?
		else if(dwState & SCARD_STATE_PRESENT)
		{
			if (dwState & SCARD_STATE_MUTE)
			{
				cout << TEXT("The card is unrecognized or not responding.");// SC_STATUS_UNKNOWN;
			}
			else if (dwState & SCARD_STATE_INUSE)
			{
				if(dwState & SCARD_STATE_EXCLUSIVE)
				{
					cout << TEXT("Card is in use exclusively by another process.");// SC_STATUS_EXCLUSIVE;
				}
				else
				{
					cout << TEXT("The card is being shared by a process.");// SC_STATUS_SHARED;
				}
			}
			else
			{
				cout << TEXT("The card is available for use.");// SC_SATATUS_AVAILABLE;
			}
		}
		// READER ERROR: at this point, something's gone wrong
		else // dwState & SCARD_STATE_UNAVAILABLE
		{
			cout << TEXT("Card/Reader not responding.");// SC_STATUS_ERROR;
		}

		cout << TEXT("\n");

		//- card name(s):\n\n
		cout << TEXT("---   card: ");
		if (0 < g_pReaderStatusArray[dwRdrSt].cbAtr)
		{
			//
			// Get the name of the card
			//
			LPTSTR szCardName = NULL;
			DWORD dwAutoAllocate = SCARD_AUTOALLOCATE;
			lReturn = SCardListCards(g_hSCardCtx,
									g_pReaderStatusArray[dwRdrSt].rgbAtr,
									NULL,
									0,
									(LPTSTR)&szCardName,
									&dwAutoAllocate);
			if (SCARD_S_SUCCESS != lReturn || NULL == szCardName)
			{
				cout << TEXT("Unknown Card.");
			}
			else
			{
				LPCTSTR szName = szCardName;
				bool fNotFirst = false;
				for (szName = FirstString(szName); NULL != szName; szName = NextString(szName))
				{
					if (fNotFirst) cout << TEXT(", ");
					cout << szName;
					fNotFirst = true;
				}
			}

			if (NULL != szCardName)
			{
				SCardFreeMemory(g_hSCardCtx, (PVOID)szCardName);
			}

		}

		cout << TEXT("\n") << endl;
	}
}


///////////////////////////////////////////////////////////////////////////////
// GetCertContext -- called by DisplayCerts
PCCERT_CONTEXT GetCertContext(HCRYPTPROV* phProv, HCRYPTKEY* phKey, DWORD dwKeySpec)
{
	PCCERT_CONTEXT pCertCtx = NULL;
	LONG lResult = SCARD_S_SUCCESS;
	BOOL fSts = FALSE;

	PCERT_PUBLIC_KEY_INFO pInfo = NULL;
    CRYPT_KEY_PROV_INFO KeyProvInfo;
    LPSTR szContainerName = NULL;
    LPSTR szProvName = NULL;
    LPWSTR wszContainerName = NULL;
	LPWSTR wszProvName = NULL;
    DWORD cbContainerName, cbProvName;
    LPBYTE pbCert = NULL;
    DWORD cbCertLen;
	int nLen = 0;

	//
	// Get the cert from this key
	//

    fSts = CryptGetKeyParam(
                *phKey,
                KP_CERTIFICATE,
                NULL,
                &cbCertLen,
                0);
    if (!fSts)
    {
        lResult = GetLastError();
        if (ERROR_MORE_DATA != lResult)
        {
            return NULL;
        }
    }
    lResult = SCARD_S_SUCCESS;
    pbCert = (LPBYTE)LocalAlloc(LPTR, cbCertLen);
    if (NULL == pbCert)
    {
        return NULL;
    }
    fSts = CryptGetKeyParam(
                *phKey,
                KP_CERTIFICATE,
                pbCert,
                &cbCertLen,
                0);
    if (!fSts)
    {
        return NULL;
    }

    //
    // Convert the certificate into a Cert Context.
    //
    pCertCtx = CertCreateCertificateContext(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    pbCert,
                    cbCertLen);
    if (NULL == pCertCtx)
    {
        lResult = GetLastError();
        goto ErrorExit;
    }

	//
	// Perform public key check
	//

	if (g_fPublicKeyCheck) // -key
	{
        cout << "\nPerforming public key matching test...\n";

		DWORD dwPCBsize = 0;

		fSts = CryptExportPublicKeyInfo(
				*phProv,        // in  
				dwKeySpec,              // in
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,     // in  
				NULL, 
				&dwPCBsize               // in, out
				);
		if (!fSts)
		{
			lResult = GetLastError();

		    TCHAR sz[256];
			sprintf(sz,"CryptExportPublicKeyInfo failed: 0x%x\n ", lResult);
			cout << sz;

			goto ErrorExit;
		}
		if (dwPCBsize == 0)
		{
			lResult = SCARD_E_UNEXPECTED; // huh?

			cout << "CryptExportPublicKeyInfo succeeded but returned size==0\n";

			goto ErrorExit;
		}

	    pInfo = (PCERT_PUBLIC_KEY_INFO)LocalAlloc(LPTR, dwPCBsize);
		if (NULL == pInfo)
		{
			lResult = E_OUTOFMEMORY;
			cout << "Could not complete key test; out of memory.\n";
			goto ErrorExit;
		}

		fSts = CryptExportPublicKeyInfo(
				*phProv,
				dwKeySpec, 
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
				pInfo, 
				&dwPCBsize               
				);
		if (!fSts)
		{
			lResult = GetLastError();

		    TCHAR sz[256];
			sprintf(sz,"CryptExportPublicKeyInfo failed: 0x%x\n ", lResult);
			cout << sz;

			goto ErrorExit;
		}

		fSts = CertComparePublicKeyInfo(
			  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,      
			  pInfo,										// from the private keyset
			  &(pCertCtx->pCertInfo->SubjectPublicKeyInfo)	// public key from cert
			  );
		if (!fSts)
		{
			lResult = GetLastError();
			goto ErrorExit;
		}

        cout << "Public key matching test succeeded.\n";

	}

    //
    //  Associate cryptprovider w/ the private key property of this cert
    //

    //  ... need the container name

    fSts = CryptGetProvParam(
            *phProv,
            PP_CONTAINER,
            NULL,     // out
            &cbContainerName,   // in/out
            0);
    if (!fSts)
    {
		lResult = GetLastError();
		goto ErrorExit;
    }
    szContainerName = (LPSTR)LocalAlloc(LPTR, cbContainerName);
    fSts = CryptGetProvParam(
            *phProv,
            PP_CONTAINER,
            (PBYTE)szContainerName,
            &cbContainerName,
            0);
    if (!fSts)
    {
		lResult = GetLastError();
		goto ErrorExit;
    }
	nLen = MultiByteToWideChar(
			GetACP(),
			MB_PRECOMPOSED,
			szContainerName, 
			-1, 
			NULL, 
			0);
	if (0 < nLen)
	{
		wszContainerName = (LPWSTR)LocalAlloc(LPTR, nLen*sizeof(WCHAR));

		nLen = MultiByteToWideChar(
				GetACP(),
				MB_PRECOMPOSED, 
				szContainerName,
				-1,
				wszContainerName,
				nLen);
		if (0 == nLen)
		{
			lResult = GetLastError();
			goto ErrorExit;
		}
	}

    //  ... need the provider name

    fSts = CryptGetProvParam(
            *phProv,
            PP_NAME,
            NULL,     // out
            &cbProvName,   // in/out
            0);
    if (!fSts)
    {
		lResult = GetLastError();
		goto ErrorExit;
    }
    szProvName = (LPSTR)LocalAlloc(LPTR, cbProvName);
    fSts = CryptGetProvParam(
            *phProv,
            PP_NAME,
            (PBYTE)szProvName,     // out
            &cbProvName,   // in/out
            0);
    if (!fSts)
    {
		lResult = GetLastError();
		goto ErrorExit;
    }
	nLen = MultiByteToWideChar(
			GetACP(),
			MB_PRECOMPOSED,
			szProvName, 
			-1, 
			NULL, 
			0);
	if (0 < nLen)
	{
		wszProvName = (LPWSTR)LocalAlloc(LPTR, nLen*sizeof(WCHAR));

		nLen = MultiByteToWideChar(
				GetACP(),
				MB_PRECOMPOSED, 
				szProvName,
				-1,
				wszProvName,
				nLen);
		if (0 == nLen)
		{
			lResult = GetLastError();
			goto ErrorExit;
		}
	}

	//
	// Set the cert context properties to reflect the prov info
	//

    KeyProvInfo.pwszContainerName = wszContainerName;
    KeyProvInfo.pwszProvName = wszProvName;
    KeyProvInfo.dwProvType = PROV_RSA_FULL;
    KeyProvInfo.dwFlags = CERT_SET_KEY_CONTEXT_PROP_ID;
    KeyProvInfo.cProvParam = 0;
    KeyProvInfo.rgProvParam = NULL;
    KeyProvInfo.dwKeySpec = dwKeySpec;

    fSts = CertSetCertificateContextProperty(
                pCertCtx,
                CERT_KEY_PROV_INFO_PROP_ID,
                0, 
                (void *)&KeyProvInfo);
    if (!fSts)
    {
        lResult = GetLastError();

		// the cert's been incorrectly created -- scrap it.
		CertFreeCertificateContext(pCertCtx);
		pCertCtx = NULL;

        goto ErrorExit;
    }


  
ErrorExit:

	if (NULL != pInfo)
	{
		LocalFree(pInfo);
	}
    if(NULL != szContainerName)
    {
        LocalFree(szContainerName);
    }
    if(NULL != szProvName)
    {
        LocalFree(szProvName);
    }
    if(NULL != wszContainerName)
    {
        LocalFree(wszContainerName);
    }
    if(NULL != wszProvName)
    {
        LocalFree(wszProvName);
    }

	return pCertCtx;
}

/*++

DisplayChainInfo:
    
    This code verifies that the SC cert is valid.
    Uses identical code to KDC cert chaining engine.
        
Author:
   
     Todds
--*/
DWORD
DisplayChainInfo(PCCERT_CONTEXT pCert)
{


    BOOL    fRet = FALSE;
    DWORD   dwErr = 0;
    TCHAR   sz[256];
    CERT_CHAIN_PARA ChainParameters = {0};
    LPSTR ClientAuthUsage = KERB_PKINIT_CLIENT_CERT_TYPE;
    PCCERT_CHAIN_CONTEXT ChainContext = NULL;

    ChainParameters.cbSize = sizeof(CERT_CHAIN_PARA);
    ChainParameters.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainParameters.RequestedUsage.Usage.cUsageIdentifier = 1;
    ChainParameters.RequestedUsage.Usage.rgpszUsageIdentifier = &ClientAuthUsage;

    if (!CertGetCertificateChain(
                          HCCE_LOCAL_MACHINE,
                          pCert,
                          NULL,                 // evaluate at current time
                          NULL,                 // no additional stores
                          &ChainParameters,
                          CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT,
                          NULL,                 // reserved
                          &ChainContext
                          ))
    {
        dwErr = GetLastError();
		sprintf(sz,"CertGetCertificateChain failed: 0x%x\n ", dwErr);
        cout << sz;
    }
    else
    {
        if (ChainContext->TrustStatus.dwErrorStatus != CERT_TRUST_NO_ERROR)
        {
            dwErr = ChainContext->TrustStatus.dwErrorStatus;
            sprintf(sz,"CertGetCertificateChain TrustStatus failed, see wincrypt.h: 0x%x\n ", dwErr);
            cout << sz;
        }

    }

    if (ChainContext != NULL)
    {
        CertFreeCertificateChain(ChainContext);
    }

    return dwErr;

}

///////////////////////////////////////////////////////////////////////////////
// DisplayCerts
void DisplayCerts()
{
	_ASSERTE(0 < g_nKeys);

	// For each reader that has a card, load the CSP and display the cert

	for (DWORD dw = 0; dw < g_dwNumReaders; dw++)
	{
		LPTSTR szCardName = NULL;
		LPTSTR szCSPName = NULL;

		if(0 >= g_pReaderStatusArray[dw].cbAtr)
		{
			// no point to do anymore work in this iteration
			continue;
		}

		//
		// Inform user of current test
		//
		cout << TEXT("\n=======================================================\n")
			 << TEXT("Analyzing card in reader: ")
			 << g_pReaderStatusArray[dw].szReader
			 << TEXT("\n");

		// Get the name of the card

		DWORD dwAutoAllocate = SCARD_AUTOALLOCATE;
		LONG lReturn = SCardListCards(g_hSCardCtx,
								g_pReaderStatusArray[dw].rgbAtr,
								NULL,
								0,
								(LPTSTR)&szCardName,
								&dwAutoAllocate);

		if (SCARD_S_SUCCESS == lReturn)
		{
			dwAutoAllocate = SCARD_AUTOALLOCATE;
			lReturn = SCardGetCardTypeProviderName(
							g_hSCardCtx,
							szCardName,
							SCARD_PROVIDER_CSP,
							(LPTSTR)&szCSPName,
							&dwAutoAllocate);
			if (SCARD_S_SUCCESS != lReturn)
			{
				TCHAR szErr[16];
				sprintf(szErr, "0x%X", lReturn);
				cout << TEXT("Error on SCardGetCardTypeProviderName for ")
					 << szCardName
					 << TEXT(": ")
					 << szErr
					 << TEXT("\n");
			}
		}

		// Prepare FullyQualifiedContainerName for CryptAcCntx call

		TCHAR szFQCN[256];
		sprintf(szFQCN, "\\\\.\\%s\\", g_pReaderStatusArray[dw].szReader);
		HCRYPTPROV hProv = NULL;

		if (SCARD_S_SUCCESS == lReturn)
		{
			BOOL fSts = CryptAcquireContext(
							&hProv,
							szFQCN,	// default container via reader
							szCSPName,
							PROV_RSA_FULL, 
							CRYPT_SILENT);

			// Enumerate the keys user specified and display the certs...

			if (fSts)
			{
				for (int n=0; n<g_nKeys; n++)
				{
					// Which keyset is this?
					LPCTSTR szKeyset = AT_KEYEXCHANGE==g_rgKeySet[n]?g_szEx:g_szSig;
					HCRYPTKEY hKey = NULL;

					// Get the key
					fSts = CryptGetUserKey(
								hProv,
								g_rgKeySet[n],
								&hKey);
					if (!fSts)
					{
						lReturn = GetLastError();
						if (NTE_NO_KEY == lReturn)
						{
							cout << TEXT("No ")
								 << szKeyset
								 << TEXT(" cert for reader: ")
								 << g_pReaderStatusArray[dw].szReader
								 << TEXT("\n");

						}
						else
						{
							TCHAR sz[256];
							sprintf(sz,"An error (0x%X) occurred opening the ", lReturn);
							cout << sz
								 << szKeyset
								 << TEXT(" key for reader: ")
								 << g_pReaderStatusArray[dw].szReader
								 << TEXT("\n");
						}

						// No point to work on this keyset anymore
						continue;
					}

					// Get the cert for this key
					PCCERT_CONTEXT pCertCtx = NULL;

					pCertCtx = GetCertContext(&hProv, &hKey, g_rgKeySet[n]);

					if (NULL != pCertCtx)
					{

                        //
                        //  If desired, attempt to build a certificate chain
                        //
                        if (g_fChain)
                        {
							cout << TEXT("\nPerforming cert chain verification...\n");
                            if (S_OK != DisplayChainInfo(pCertCtx)) {
                                cout << TEXT("Cert did not chain!\n") << endl;
                            } else {
                                cout << TEXT("---  chain: Chain verifies.\n") << endl;
                            }
                        }

						// call common UI to display m_pCertContext
						// ( from cryptui.h ( cryptui.dll ) )
						TCHAR szTitle[300];
						sprintf(szTitle, 
								"%s : %s",
								g_pReaderStatusArray[dw].szReader,
								szKeyset);

						CRYPTUI_VIEWCERTIFICATE_STRUCT CertViewInfo;
						memset( &CertViewInfo, 0, sizeof( CertViewInfo ) );

						CertViewInfo.dwSize = (sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));
						CertViewInfo.hwndParent = NULL;
						CertViewInfo.szTitle = szTitle;
						CertViewInfo.dwFlags =	CRYPTUI_DISABLE_EDITPROPERTIES | 
												CRYPTUI_DISABLE_ADDTOSTORE;
						CertViewInfo.pCertContext = pCertCtx;

						BOOL fThrowAway = FALSE;
						fSts = CryptUIDlgViewCertificate(&CertViewInfo, &fThrowAway);

						// clean up certcontext
						CertFreeCertificateContext(pCertCtx);

						cout << TEXT("Displayed ")
							 << szKeyset
							 << TEXT(" cert for reader: ")
							 << g_pReaderStatusArray[dw].szReader
							 << TEXT("\n");
					}
					else
					{
						cout << TEXT("No cert retrieved for reader: ")
							 << g_pReaderStatusArray[dw].szReader
							 << TEXT("\n");
					}

					// clean up stuff
					if (NULL != hKey)
					{
						CryptDestroyKey(hKey);
						hKey = NULL;
					}
				}
			}
			else
			{
				TCHAR szErr[16];
				sprintf(szErr, "0x%X", GetLastError());
				cout << TEXT("Error on CryptAcquireContext for ")
					 << szCSPName
					 << TEXT(": ")
					 << szErr
					 << TEXT("\n");

			}
		}

		// Clean up 

		if (NULL != szCSPName)
		{
			SCardFreeMemory(g_hSCardCtx, (PVOID)szCSPName);
			szCSPName = NULL;
		}
		if (NULL != szCardName)
		{
			SCardFreeMemory(g_hSCardCtx, (PVOID)szCardName);
			szCardName = NULL;
		}
		if (NULL != hProv)
		{
			CryptReleaseContext(hProv, 0);
			hProv = NULL;
		}
	} // end for
}



/*++

main:

    This is the main entry point for the test program. 
    It runs the test.  Nice and simple, borrowed from DBarlow                  

Author:

    Doug Barlow (dbarlow) 11/10/1997

Revisions:

	AMatlosz 2/26/98

--*/

void __cdecl
main(DWORD cArgs,LPCTSTR rgszArgs[])
{
	//init globals & locals
	g_nKeys = 0;
	g_rgKeySet[0] = g_rgKeySet[1] = 0;
	g_hSCardCtx = NULL;
	g_szReaderName = NULL;
	g_fReaderNameAllocd = false;
	g_dwNumReaders = 0;
	g_pReaderStatusArray = NULL;

	if (!ProcessCommandLine(cArgs, rgszArgs))
	{
		return;
	}

	if (IsCalaisRunning())
	{
		DisplayReaderList();

		if (0 < g_nKeys)
		{
			DisplayCerts();
		}
	}

	cout << TEXT("\ndone.") << endl;

	// clean up globals

	if (g_fReaderNameAllocd && NULL != g_szReaderName)
	{
		SCardFreeMemory(g_hSCardCtx, (PVOID)g_szReaderName);
	}
    if (NULL != g_hSCardCtx)
	{
        SCardReleaseContext(g_hSCardCtx);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\cspsigck\cspsigck.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       cspsigck.cpp
//
//--------------------------------------------------------------------------

// cspsigck.cpp : Defines the entry point for the console application.
//

// #ifndef WIN32_LEAN_AND_MEAN
// #define WIN32_LEAN_AND_MEAN
// #endif
// #include <windows.h>                    //  All the Windows definitions.
#include "afx.h"
#include <iostream.h>
#ifndef WINVER
#define WINVER 0x0500
#endif
#include <wincrypt.h>

static LPCTSTR
ErrorString(
    DWORD dwErrorCode);
static void
FreeErrorString(
    LPCTSTR szErrorString);

DWORD __cdecl
main(
     int argc, 
     char* argv[])
{
    static TCHAR szDots[] =
            TEXT("........................................................................");
    DWORD dwReturn = 0;
    HCRYPTPROV hProv = NULL;
    DWORD dwIndex, dwLength, dwSts, dwProvType;
    BOOL fSts;
    CString szProvider;

    cout << TEXT("==============================================================================\n")
         << TEXT("           Cryptographic Service Provider Signature validation\n")
         << TEXT("------------------------------------------------------------------------------\n")
         << flush;

    dwIndex = 0;
    for (;;)
    {
        dwLength = 0;
        fSts = CryptEnumProviders(
                    dwIndex,
                    NULL,
                    0,
                    &dwProvType,
                    NULL,
                    &dwLength);
        if (fSts)
        {
            fSts = CryptEnumProviders(
                        dwIndex,
                        NULL,
                        0,
                        &dwProvType,
                        szProvider.GetBuffer(dwLength / sizeof(TCHAR)),
                        &dwLength);
            dwSts = GetLastError();
            szProvider.ReleaseBuffer();
            if (!fSts)
            {
                cerr << TEXT("\n ERROR Can't obtain provider name: ")
                     << ErrorString(dwSts)
                     << endl;
                goto ErrorExit;
            }
        }
        else
        {
            dwSts = GetLastError();
            if (ERROR_NO_MORE_ITEMS == dwSts)
                break;
            cerr << TEXT("\n ERROR Can't obtain provider name length: ")
                 << ErrorString(dwSts)
                 << endl;
            goto ErrorExit;
        }

        cout << szProvider << &szDots[szProvider.GetLength()] << flush;
        fSts = CryptAcquireContext(
                    &hProv,
                    NULL,
                    szProvider,
                    dwProvType,
                    CRYPT_VERIFYCONTEXT);
        if (fSts)
        {
            cout << TEXT("passed") << endl;
            fSts = CryptReleaseContext(hProv, 0);
            hProv = NULL;
            if (!fSts)
            {
                dwSts = GetLastError();
                cerr << TEXT("\n ERROR Can't release context: ")
                     << ErrorString(dwSts)
                     << endl;
                goto ErrorExit;
            }
        }
        else
        {
            dwSts = GetLastError();
            dwReturn = dwSts;
            cout << TEXT("FAILED\n")
                 << TEXT("    ") << ErrorString(dwSts)
                 << endl;
            ASSERT(NULL == hProv);
        }

        dwIndex += 1;
    }
    cout << TEXT("------------------------------------------------------------------------------\n")
         << TEXT("Final Status") << &szDots[12]
         << (LPCTSTR)((ERROR_SUCCESS == dwReturn) ? TEXT("passed\n") : TEXT("FAILED\n"))
         << TEXT("==============================================================================\n")
         << flush;
	dwReturn = 0;

ErrorExit:
    if (hProv != NULL)
        CryptReleaseContext(hProv, 0);
    return dwReturn;
}


/*++

ErrorString:

    This routine does it's very best to translate a given error code into a
    text message.  Any trailing non-printable characters are striped from the
    end of the text message, such as carriage returns and line feeds.

Arguments:

    dwErrorCode supplies the error code to be translated.

Return Value:

    The address of a freshly allocated text string.  Use FreeErrorString to
    dispose of it.

Throws:

    Errors are thrown as DWORD status codes.

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

static LPCTSTR
ErrorString(
    DWORD dwErrorCode)
{
    LPTSTR szErrorString = NULL;

    try
    {
        DWORD dwLen;
        LPTSTR szLast;

        dwLen = FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    dwErrorCode,
                    LANG_NEUTRAL,
                    (LPTSTR)&szErrorString,
                    0,
                    NULL);
        if (0 == dwLen)
        {
            ASSERT(NULL == szErrorString);
            dwLen = FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE,
                        GetModuleHandle(NULL),
                        dwErrorCode,
                        LANG_NEUTRAL,
                        (LPTSTR)&szErrorString,
                        0,
                        NULL);
            if (0 == dwLen)
            {
                ASSERT(NULL == szErrorString);
                szErrorString = (LPTSTR)LocalAlloc(
                                        LMEM_FIXED,
                                        32 * sizeof(TCHAR));
                if (NULL == szErrorString)
                    throw (DWORD)SCARD_E_NO_MEMORY;
                _stprintf(szErrorString, TEXT("0x%08x"), dwErrorCode);
            }
        }

        ASSERT(NULL != szErrorString);
        for (szLast = szErrorString + lstrlen(szErrorString) - 1;
             szLast > szErrorString;
             szLast -= 1)
         {
            if (_istgraph(*szLast))
                break;
            *szLast = 0;
         }
    }
    catch (...)
    {
        FreeErrorString(szErrorString);
        throw;
    }

    return szErrorString;
}


/*++

FreeErrorString:

    This routine frees the Error String allocated by the ErrorString service.

Arguments:

    szErrorString supplies the error string to be deallocated.

Return Value:

    None

Throws:

    None

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

static void
FreeErrorString(
    LPCTSTR szErrorString)
{
    if (NULL != szErrorString)
        LocalFree((LPVOID)szErrorString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\checksc\checksc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       CheckSC.h
//
//--------------------------------------------------------------------------

// CheckSC.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\csptrace\csptrace.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    cspTrace

Abstract:

    This program performs analysis on a CSP Function trace.

Author:

    Doug Barlow (dbarlow) 2/19/1998

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#include <wincrypt.h>
#include <tchar.h>
#include <stdlib.h>
#include <iostream.h>
#include <iomanip.h>
#include <scardlib.h>
#include "cspTrace.h"

LPCTSTR g_szMajorAction = TEXT("Initialization");
LPCTSTR g_szMinorAction = NULL;

static const TCHAR l_szLogCsp[] = TEXT("LogCsp.dll");
static const TCHAR l_szCspNames[] = TEXT("SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider");
static const TCHAR l_szImagePath[] = TEXT("Image Path");
static const TCHAR l_szLogCspRegistry[] = TEXT("SOFTWARE\\Microsoft\\Cryptography\\Logging Crypto Provider");
static const TCHAR l_szTargetCsp[] = TEXT("Target");
static const TCHAR l_szLogFile[] = TEXT("Logging File");
static const TCHAR l_szDefaultFile[] = TEXT("C:\\cspTrace.log");

static void
ShowSyntax(
    ostream &outStr);
static void
DoInstall(
    IN LPCTSTR szProvider,
    IN LPCTSTR szInFile);
static void
DoRemove(
    void);
static void
DoClearLog(
    void);
static void
DoShowStatus(
    void);


/*++

main:

    This is the main entry point for the program.

Arguments:

    dwArgCount supplies the number of arguments.

    szrgArgs supplies the argument strings.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/30/1997

--*/

void _cdecl
main(
    IN DWORD dwArgCount,
    IN LPCTSTR szrgArgs[])
{
    LPCTSTR szInFile = NULL;
    LPCTSTR szProvider = NULL;
    DWORD dwArgIndex = 0;
    enum TraceAction {
            Undefined = 0,
            Install,
            Remove,
            ClearLog,
            ShowStatus,
            ShowTrace,
            ScriptTrace
    } nTraceAction = Undefined;


    //
    // Check for command line options
    //

    while (NULL != szrgArgs[++dwArgIndex])
    {
        switch (SelectString(szrgArgs[dwArgIndex],
                    TEXT("INSTALL"),    TEXT("REMOVE"),     TEXT("CLEAR"),
                    TEXT("RESET"),      TEXT("STATUS"),     TEXT("PARSE"),
                    TEXT("DISPLAY"),    TEXT("SCRIPT"),     TEXT("TCL"),
                    TEXT("-FILE"),      TEXT("-PROVIDER"),  TEXT("-CSP"),
                    NULL))
        {
        case 1:     // install
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = Install;
            break;
        case 2:     // remove
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = Remove;
            break;
        case 3:     // clear
        case 4:     // reset
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = ClearLog;
            break;
        case 5:     // status
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = ShowStatus;
            break;
        case 6:     // parse
        case 7:     // display
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = ShowTrace;
            break;
        case 8:     // script
        case 9:     // tcl
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = ScriptTrace;
            break;
        case 10:    // -file
            if (NULL != szInFile)
                ShowSyntax(cerr);
            szInFile = szrgArgs[++dwArgIndex];
            if (NULL == szInFile)
                ShowSyntax(cerr);
            break;
        case 11:    // -provider
        case 12:    // -csp
            if (NULL != szProvider)
                ShowSyntax(cerr);
            szProvider = szrgArgs[++dwArgIndex];
            if (NULL == szProvider)
                ShowSyntax(cerr);
            break;
        default:
            ShowSyntax(cerr);
        }
    }


    //
    // Perform the requested Action
    //

    try
    {
        switch (nTraceAction)
        {
        case Install:
            ACTION("Installation");
            if (NULL == szInFile)
                szInFile = l_szDefaultFile;
            DoInstall(szProvider, szInFile);
            break;
        case Remove:
            ACTION("Removal");
            DoRemove();
            break;
        case ClearLog:
            ACTION("Clearing Log File");
            DoClearLog();
            break;
        case ShowStatus:
            ACTION("Displaying Status");
            DoShowStatus();
            break;
        case Undefined:
        case ShowTrace:
            ACTION("Log File Interpretation");
            if (NULL == szInFile)
                szInFile = l_szDefaultFile;
            DoShowTrace(szInFile);
            break;
        case ScriptTrace:
            ACTION("Log File Scripting");
            if (NULL == szInFile)
                szInFile = l_szDefaultFile;
            DoTclTrace(szInFile);
            break;
        default:
            ShowSyntax(cerr);
        }
    }
    catch (DWORD dwError)
    {
        cerr << TEXT("ERROR: Failed during ")
             << g_szMajorAction
             << endl;
        if (NULL != g_szMinorAction)
            cerr << TEXT("       Action: ")
                 << g_szMinorAction
                 << endl;
        if (ERROR_SUCCESS != dwError)
            cerr << TEXT("       Error:  ")
                 << CErrorString(dwError)
                 << endl;
    }
    exit(0);
}


/*++

ShowSyntax:

    Display the command line usage model.

Arguments:

    None

Return Value:

    This routine calls exit(0), so it never returns.

Author:

    Doug Barlow (dbarlow) 5/16/1998

--*/

static void
ShowSyntax(
    ostream &outStr)
{
    outStr << TEXT("Usage:\n")
           << TEXT("----------------------------------------------------------\n")
           << TEXT("install [-file <logFile] [-provider <cspName>]\n")
           << TEXT("remove\n")
           << TEXT("clear\n")
           << TEXT("status\n")
           << TEXT("display [-file <logFile]\n")
           << TEXT("script [-file <logFile]\n")
           << endl;
    exit(1);
}


/*++

DoInstall:

    This routine performs an installation of the logging CSP.

Arguments:

    szProvider supplies the name of the CSP to log.  If this is NULL, the
        routine prompts for which CSP to use.

    szInFile supplies the name of the logging file.  If this is NULL, the
        default file is used.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Remarks:

    None

Author:

    Doug Barlow (dbarlow) 5/18/1998

--*/

static void
DoInstall(
    IN LPCTSTR szProvider,
    IN LPCTSTR szInFile)
{
    LPCTSTR szLogCsp = FindLogCsp();
    CRegistry regChosenCsp;
    LPCTSTR szCspImage;


    //
    // Make sure we're not already installed.
    //

    DoRemove();


    //
    // Choose the CSP to be logged.
    //

    if (NULL == szProvider)
    {
        SUBACTION("Enumerating CSPs");
        CRegistry regCsps(HKEY_LOCAL_MACHINE, l_szCspNames, KEY_READ);
        DWORD dwIndex, dwChoice;
        LPCTSTR szCsp;

        do
        {
            cout << TEXT("Choose the CSP to be logged:") << endl;
            for (dwIndex = 0;; dwIndex += 1)
            {
                szCsp = regCsps.Subkey(dwIndex);
                if (NULL == szCsp)
                    break;
                cout << TEXT("  ") << dwIndex + 1 << TEXT(") ") << szCsp << endl;
            }
            cout << TEXT("Selection: ") << flush;
            cin >> dwChoice;
        } while ((0 == dwChoice) || (dwChoice > dwIndex));

        SUBACTION("Selecting Chosen CSP");
        szCsp = regCsps.Subkey(dwChoice - 1);
        regChosenCsp.Open(regCsps, szCsp, KEY_ALL_ACCESS);
    }
    else
    {
        SUBACTION("Selecting Specified CSP");
        CRegistry regCsps(HKEY_LOCAL_MACHINE, l_szCspNames, KEY_READ);
        regChosenCsp.Open(regCsps, szProvider, KEY_ALL_ACCESS);
    }


    //
    // Wedge in the Logging CSP.
    //

    SUBACTION("Wedging the Logging CSP");
    szCspImage = regChosenCsp.GetStringValue(l_szImagePath);
    CRegistry regLogCsp(
                HKEY_LOCAL_MACHINE,
                l_szLogCspRegistry,
                KEY_ALL_ACCESS,
                REG_OPTION_NON_VOLATILE);
    if (NULL != szInFile)
        regLogCsp.SetValue(l_szLogFile, szInFile);
    if (NULL == _tcschr(szCspImage, TEXT('%')))
        regLogCsp.SetValue(l_szTargetCsp, szCspImage, REG_SZ);
    else
        regLogCsp.SetValue(l_szTargetCsp, szCspImage, REG_EXPAND_SZ);
    regChosenCsp.SetValue(l_szImagePath, szLogCsp, REG_SZ);


    //
    // Initialize the logging file.
    //

    DoClearLog();
}


/*++

DoRemove:

    This routine Removes the Logging CSP.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    None

Author:

    Doug Barlow (dbarlow) 5/18/1998

--*/

static void
DoRemove(
    void)
{
    LPCTSTR szLoggedCsp = FindLoggedCsp();

    if (NULL != szLoggedCsp)
    {
        SUBACTION("Accessing Registry Keys");
        CRegistry regCsps(HKEY_LOCAL_MACHINE, l_szCspNames, KEY_READ);
        CRegistry regLoggedCsp(regCsps, szLoggedCsp);
        CRegistry regLogCsp(HKEY_LOCAL_MACHINE, l_szLogCspRegistry);
        LPCTSTR szCspImage = regLogCsp.GetStringValue(l_szTargetCsp);

        SUBACTION("Changing Registry Values");
        if (NULL == _tcschr(szCspImage, TEXT('%')))
            regLoggedCsp.SetValue(l_szImagePath, szCspImage, REG_SZ);
        else
            regLoggedCsp.SetValue(l_szImagePath, szCspImage, REG_EXPAND_SZ);
        regLogCsp.DeleteValue(l_szLogFile, TRUE);
        regLogCsp.DeleteValue(l_szTargetCsp);
    }
}


/*++

DoClearLog:

    This routine resets the log file.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    None

Author:

    Doug Barlow (dbarlow) 5/18/1998

--*/

static void
DoClearLog(
    void)
{
    SUBACTION("Getting Log File Name");
    CRegistry regLogCsp(HKEY_LOCAL_MACHINE, l_szLogCspRegistry, KEY_READ);
    LPCTSTR szLogFile = regLogCsp.GetStringValue(l_szLogFile);
    HANDLE hLogFile;

    SUBACTION("Creating Log File");
    hLogFile = CreateFile(
                    szLogFile,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if (INVALID_HANDLE_VALUE == hLogFile)
        throw GetLastError();
    CloseHandle(hLogFile);
}


/*++

DoShowStatus:

    This routine displays the current status of the logging CSP.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    None

Author:

    Doug Barlow (dbarlow) 5/18/1998

--*/

static void
DoShowStatus(
    void)
{
    LPCTSTR szLoggedCsp = NULL;
    TCHAR szLogFile[MAX_PATH] = TEXT("<Unavailable>");
    LPCTSTR szFileAccessibility = NULL;
    CErrorString szErrStr;
    DWORD dwFileSize = 0xffffffff;


    //
    // Obtain the CSP being logged.
    //

    try
    {
        szLoggedCsp = FindLoggedCsp();
        if (NULL == szLoggedCsp)
            szLoggedCsp = TEXT("<none>");
    }
    catch (DWORD)
    {
        szLoggedCsp = TEXT("<unavailable>");
    }


    //
    // Obtain the Logging file.
    //

    try
    {
        CRegistry regLogCsp(HKEY_LOCAL_MACHINE, l_szLogCspRegistry, KEY_READ);
        LPCTSTR szLogFileTmp = regLogCsp.GetStringValue(l_szLogFile);

        if (NULL != szLogFileTmp)
        {
            lstrcpy(szLogFile, szLogFileTmp);
            HANDLE hLogFile;

            hLogFile = CreateFile(
                szLogFileTmp,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
            if (INVALID_HANDLE_VALUE != hLogFile)
            {
                dwFileSize = GetFileSize(hLogFile, NULL);
                CloseHandle(hLogFile);
                szFileAccessibility = TEXT("Success");
            }
            else
            {
                szErrStr.SetError(GetLastError());
                szFileAccessibility = szErrStr.Value();
            }
        }
    }
    catch (DWORD)
    {
        lstrcpy(szLogFile , TEXT("<Unset>"));
        szFileAccessibility = TEXT("N/A");
    }


    //
    // Tell the user what we know.
    //

    cout << TEXT("CSP Logging Status:") << endl
         << TEXT("  Logged CSP:   ") << szLoggedCsp << endl
         << TEXT("  Logging File: ") << szLogFile << endl
         << TEXT("  File Status:  ") << szFileAccessibility << endl
         << TEXT("  File Size:    ");
    if (0xffffffff == dwFileSize)
        cout << TEXT("N/A") << endl;
    else
        cout << dwFileSize << TEXT(" bytes") << endl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\csptrace\csptrace.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    cspTrace

Abstract:

    This header file encapsulates the common definitions shared among the
    modules of the cspTrace utility.

Author:

    Doug Barlow (dbarlow) 5/16/1998

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _CSPTRACE_H_
#define _CSPTRACE_H_

#define ACTION(x)    g_szMajorAction = TEXT(x);
#define SUBACTION(x) g_szMinorAction = TEXT(x);

extern LPCTSTR g_szMajorAction;
extern LPCTSTR g_szMinorAction;


//
// Definitions duplicated from logcsp.
//

typedef enum
{
    AcquireContext = 0,
    GetProvParam,
    ReleaseContext,
    SetProvParam,
    DeriveKey,
    DestroyKey,
    ExportKey,
    GenKey,
    GetKeyParam,
    GenRandom,
    GetUserKey,
    ImportKey,
    SetKeyParam,
    Encrypt,
    Decrypt,
    CreateHash,
    DestroyHash,
    GetHashParam,
    HashData,
    HashSessionKey,
    SetHashParam,
    SignHash,
    VerifySignature,
    Undefined
} LogTypeId;

typedef enum
{
    logid_False = 0,
    logid_True,
    logid_Exception
} CompletionCode;

typedef struct
{
    DWORD cbLength;
    DWORD cbDataOffset;
    LogTypeId id;
    CompletionCode status;
    DWORD dwStatus;
    DWORD dwProcId;
    DWORD dwThreadId;
    SYSTEMTIME startTime;
    SYSTEMTIME endTime;
} LogHeader;

typedef struct {
    DWORD cbOffset;
    DWORD cbLength;
} LogBuffer;


//
// Application definitions
//

typedef struct {
    DWORD dwValue;
    LPCTSTR szValue;
} ValueMap;

extern void
DoShowTrace(
    IN LPCTSTR szInFile);

extern void
DoTclTrace(
    IN LPCTSTR szInFile);

extern LPCTSTR
FindLogCsp(
    void);

extern LPCTSTR
FindLoggedCsp(
    void);

#define PHex(x) TEXT("0x") << hex << setw(8) << setfill(TEXT('0')) << (x)
#define PDec(x) dec << setw(0) << setfill(TEXT(' ')) << (x)
#define MAP(x) { x, TEXT(#x) }
#define PTime(x) dec \
    << setw(2) << setfill(TEXT('0')) << (x).wHour   << TEXT(":") \
    << setw(2) << setfill(TEXT('0')) << (x).wMinute << TEXT(":") \
    << setw(2) << setfill(TEXT('0')) << (x).wSecond << TEXT(".") \
    << setw(3) << setfill(TEXT('0')) << (x).wMilliseconds

extern const ValueMap rgMapService[];
extern const ValueMap rgMapAcquireFlags[];
extern const ValueMap rgMapGetProvParam[];
extern const ValueMap rgMapGetProvFlags[];
extern const ValueMap rgMapSetProvParam[];
extern const ValueMap rgMapHashParam[];
extern const ValueMap rgMapGenKeyFlags[];
extern const ValueMap rgMapDeriveKeyFlags[];
extern const ValueMap rgMapExportKeyFlags[];
extern const ValueMap rgMapKeyParam[];
extern const ValueMap rgMapKeyId[];
extern const ValueMap rgMapBlobType[];
extern const ValueMap rgMapAlgId[];

#endif // _CSPTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\invmap\invmap.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    InvMap

Abstract:

    This file provides an application that dumps an inverse bit ordering array
    to the supplied file.  It is invoked with the command,

        invmap <file>

    It then writes a binary reverse mapping table to that file, which can be
    formatted with hexfmt.

Author:

    Doug Barlow (dbarlow) 12/3/1996

Environment:

    CRT

Notes:

    See DBarlow for hexfmt.

--*/

#include <windows.h>
#include <crtdbg.h>
#include <iostream.h>
#include <fstream.h>
#ifdef _DEBUG
#define ASSERT(x) _ASSERTE(x)
#else
#define ASSERT(x)
#endif


int _cdecl
main(
    ULONG argc,
    TCHAR *argv[])
{
    static BYTE rgbInv[256];
    DWORD ix, jx;
    BYTE org, inv;

    if (2 != argc)
    {
        cerr << "Usage: " << argv[0] << " <outFile>" << endl;
        return 0;
    }

    ofstream outf(argv[1], ios::out | ios::noreplace | ios::binary);
    if (!outf)
    {
        cerr << "Can't create file " << argv[1] << endl;
        return 1;
    }

    for (ix = 0; 256 > ix; ix += 1)
    {
        inv = 0;
        org = (BYTE)ix;
        for (jx = 0; jx < 8; jx += 1)
        {
            inv <<= 1;
            if (0 == (org & 0x01))
                inv |= 0x01;
            org >>= 1;
        }
        rgbInv[ix] = inv;
        outf << inv;
    }

#ifdef _DEBUG
    for (ix = 0; 256 > ix; ix += 1)
    {
        org = (BYTE)ix;
        inv = (BYTE)rgbInv[ix];
        ASSERT(inv == rgbInv[org]);
        ASSERT(org == rgbInv[inv]);
    }
#endif

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\csptrace\tcltrace.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    tclTrace

Abstract:

    This module implements the CSP Tracing interpretation

Author:

    Doug Barlow (dbarlow) 5/27/1998

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#include <wincrypt.h>
#include <stdlib.h>
#include <iostream.h>
#include <iomanip.h>
#include <tchar.h>
#include <stdio.h>
#include <SCardLib.h>
#include "cspTrace.h"

static void
ShowBuf(
    LogBuffer &lb,
    ostream &outStr);
static LPCTSTR
ShowString(
    LogBuffer &lb);
static void
dump(
    const BYTE *pbData,
    DWORD cbLen,
    ostream &outStr);

LPCTSTR
MapValue(
    DWORD dwValue,
    const ValueMap *rgMap);

LPCTSTR
MaskValue(
    DWORD dwValue,
    const ValueMap *rgMap);

static LPBYTE l_pbLogData = NULL;
static DWORD  l_cbLogData = 0;


/*++

DoTclTrace:

    This routine interprets the given binary file, writing the output to stdout.

Arguments:

    szInFile supplies the file name to be parsed.

Return Value:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 5/16/1998

--*/

void
DoTclTrace(
    IN LPCTSTR szInFile)
{
    HANDLE hLogFile = NULL;
    DWORD cbStructLen = 0;
    LPBYTE pbStruct = NULL;
    LogHeader *pLogObj;
    DWORD dwLen, dwRead;
    BOOL fSts;


    //
    // Open the log file.
    //

    hLogFile = CreateFile(
        szInFile,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (INVALID_HANDLE_VALUE == hLogFile)
    {
        cerr << TEXT("Can't open file ")
             << szInFile
             << ": "
             << CErrorString(GetLastError())
             << endl;
         goto ErrorExit;
    }


    //
    // Parse the file contents.
    //

    for (;;)
    {
        fSts = ReadFile(
                    hLogFile,
                    &dwLen,
                    sizeof(DWORD),
                    &dwRead,
                    NULL);
        if ((!fSts) || (0 == dwRead))
            goto ErrorExit;

        if (cbStructLen < dwLen)
        {
            if (NULL != pbStruct)
                LocalFree(pbStruct);
            pbStruct = (LPBYTE)LocalAlloc(LPTR, dwLen);
            cbStructLen = dwLen;
        }
        fSts = ReadFile(
                    hLogFile,
                    &pbStruct[sizeof(DWORD)],
                    dwLen - sizeof(DWORD),
                    &dwRead,
                    NULL);
        if (!fSts)
        {
            cerr << "File read error: " << CErrorString(GetLastError()) << endl;
            goto ErrorExit;
        }


        //
        // Parse the structure into bytesize chunks.
        //

        pLogObj = (LogHeader *)pbStruct;
        pLogObj->cbLength = dwLen;
        l_pbLogData = pbStruct + pLogObj->cbDataOffset;
        l_cbLogData = pLogObj->cbLength - pLogObj->cbDataOffset;


        //
        // We've got the structure, now display the contents.
        //

        switch (pLogObj->id)
        {

        case AcquireContext:
        {
            struct TmpLog {
                LogHeader lh;
                LogBuffer bfContainer;
                DWORD dwFlags;
                LogBuffer bfVTable;
                HCRYPTPROV hProv;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set hProv ^\n")
                 << TEXT("    [crypt acquire ^\n")
                 << TEXT("        provider $prov ^\n");
            if ((DWORD)(-1) != pld->bfContainer.cbOffset)
                cout << TEXT("        container {") << ShowString(pld->bfContainer) << TEXT("} ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {" << MaskValue(pld->dwFlags, rgMapAcquireFlags)) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case GetProvParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwParam;
                DWORD dwDataLen;
                DWORD dwFlags;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set param ^\n")
                 << TEXT("    [crypt $hProv parameter ") << MapValue(pld->dwParam, rgMapGetProvParam) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, rgMapGetProvFlags) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case ReleaseContext:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hProv release ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("    flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("}]\n");
            cout << TEXT("    \n") << endl;
            break;
        }

        case SetProvParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwParam;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hProv parameter ") << MapValue(pld->dwParam, rgMapSetProvParam) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("    flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            ShowBuf(pld->bfData, cout);
            cout << TEXT("    \n") << endl;
            break;
        }

        case DeriveKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                ALG_ID Algid;
                HCRYPTHASH hHash;
                DWORD dwFlags;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set hKey ^\n")
                 << TEXT("    [crypt $hProv create key ^\n")
                 << TEXT("        algorithm ") << MapValue(pld->Algid, rgMapAlgId) << TEXT(" ^\n")
                 << TEXT("        hash $hHash ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, rgMapDeriveKeyFlags) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case DestroyKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hKey release\n")
                 << endl;
            break;
        }

        case ExportKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                HCRYPTKEY hPubKey;
                DWORD dwBlobType;
                DWORD dwFlags;
                DWORD dwDataLen;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set expKey ^\n")
                 << TEXT("    [crypt $hKey export ^\n")
                 << TEXT("        key $hPubKey ^\n")
                 << TEXT("        type ") << MapValue(pld->dwBlobType, rgMapBlobType) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, rgMapExportKeyFlags) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case GenKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                ALG_ID Algid;
                DWORD dwFlags;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set hKey ^\n")
                 << TEXT("    [crypt $hProv create key ^\n")
                 << TEXT("        algorithm ") << MapValue(pld->Algid, rgMapAlgId) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, rgMapGenKeyFlags) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case GetKeyParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                DWORD dwParam;
                DWORD dwDataLen;
                DWORD dwFlags;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set param ^\n")
                 << TEXT("    [crypt $hKey parameter ") << MapValue(pld->dwParam, rgMapKeyParam) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case GenRandom:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwLen;
                LogBuffer bfBuffer;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set rnd ^\n")
                 << TEXT("    [crypt $hProv get random ") << pld->dwLen << TEXT("]\n")
                 << endl;
            break;
        }

        case GetUserKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwKeySpec;
                HCRYPTKEY hUserKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set hKey ^\n")
                 << TEXT("    [crypt $hProv get key ") << MapValue(pld->dwKeySpec, rgMapKeyId) << TEXT("]\n")
                 << endl;
            break;
        }

        case ImportKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                LogBuffer bfData;
                HCRYPTKEY hPubKey;
                DWORD dwFlags;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set hKey ^\n")
                 << TEXT("    [crypt $hProv import ^\n");
            if (0 != pld->hPubKey)
                 cout << TEXT("        key $hPubKey ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            ShowBuf(pld->bfData, cout);
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case SetKeyParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                DWORD dwParam;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hKey parameter ") << MapValue(pld->dwParam, rgMapKeyParam) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            ShowBuf(pld->bfData, cout);
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case Encrypt:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                HCRYPTHASH hHash;
                BOOL Final;
                DWORD dwFlags;
                LogBuffer bfInData;
                DWORD dwBufLen;
                LogBuffer bfOutData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set ciphertext ^\n")
                 << TEXT("    [crypt $hKey encrypt ^\n");
            if (NULL != pld->hHash)
                cout << TEXT("        hash $hHash ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            if (pld->Final)
                cout << TEXT("        final ^\n");
            else
                cout << TEXT("        more ^\n");
            ShowBuf(pld->bfInData, cout);
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case Decrypt:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                HCRYPTHASH hHash;
                BOOL Final;
                DWORD dwFlags;
                LogBuffer bfInData;
                LogBuffer bfOutData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set cleartext ^\n")
                 << TEXT("    [crypt $hKey decrypt ^\n");
            if (NULL != pld->hHash)
                cout << TEXT("        hash $hHash ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            if (pld->Final)
                cout << TEXT("        final ^\n");
            else
                cout << TEXT("        more ^\n");
            ShowBuf(pld->bfInData, cout);
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case CreateHash:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                ALG_ID Algid;
                HCRYPTKEY hKey;
                DWORD dwFlags;
                HCRYPTHASH hHash;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set hHash ^\n")
                 << TEXT("    [crypt $hProv create hash ^\n")
                 << TEXT("        algorithm ") << MapValue(pld->Algid, rgMapAlgId) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case DestroyHash:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hHash release\n") << endl;
            break;
        }

        case GetHashParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                DWORD dwParam;
                DWORD dwDataLen;
                DWORD dwFlags;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set param ^\n")
                 << TEXT("    [crypt $hKey parameter ") << MapValue(pld->dwParam, rgMapHashParam) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("    flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case HashData:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hHash hash ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("    flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            ShowBuf(pld->bfData, cout);
            cout << endl;
            break;
        }

        case HashSessionKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                HCRYPTKEY hKey;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hHash hash ^\n")
                 << TEXT("    key $hKey ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("    flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case SetHashParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                DWORD dwParam;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hHash parameter ") << MapValue(pld->dwParam, rgMapHashParam) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("    flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            ShowBuf(pld->bfData, cout);
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case SignHash:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                DWORD dwKeySpec;
                LogBuffer bfDescription;
                DWORD dwFlags;
                DWORD dwSigLen;
                LogBuffer bfSignature;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set sig ^\n")
                 << TEXT("    [crypt $hHash sign ^\n")
                 << TEXT("        key ") << MapValue(pld->dwKeySpec, rgMapKeyId) << TEXT(" ^\n");
            if ((DWORD)(-1) != pld->bfDescription.cbOffset)
                cout << TEXT("        description {") << ShowString(pld->bfDescription) << TEXT("} ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("}]\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case VerifySignature:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                LogBuffer bfSignature;
                DWORD dwSigLen;
                HCRYPTKEY hPubKey;
                LogBuffer bfDescription;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hHash verify ^\n")
                 << TEXT("    key $hKey ^\n");
            if ((DWORD)(-1) != pld->bfDescription.cbOffset)
                cout << TEXT("    description {") << ShowString(pld->bfDescription) << TEXT("} ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("    flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("}\n");
            ShowBuf(pld->bfSignature, cout);
            cout << TEXT("    ]\n") << endl;
            break;
        }

        default:
            cerr << TEXT("Internal error") << endl;
            goto ErrorExit;
            break;
        }
    }

ErrorExit:
    if (NULL == hLogFile)
        CloseHandle(hLogFile);
}


//
///////////////////////////////////////////////////////////////////////////////
//
// Suport routines
//

static void
dump(
    const BYTE *pbData,
    DWORD cbLen,
    ostream &outStr)
{
    unsigned long int
        b, i, lc;
    char
        buffer[32];


    lc = 0;
    while (0 < cbLen)
    {
        b = min(sizeof(buffer), cbLen);
        memcpy(buffer, pbData, b);
        pbData += b;
        cbLen -= b;
        if (0 < b)
        {
            outStr << TEXT("    ");
            for (i = 0; i < b; i += 1)
                outStr
                    << setw(2) << setfill('0') << hex
                    << ((unsigned int)buffer[i] & 0xff);
            outStr << endl;
            lc += b;
        }
    }
}


static LPCTSTR
MapValue(
    DWORD dwValue,
    const ValueMap *rgMap)
{
    static TCHAR szReturn[128];
    DWORD dwIndex;

    if (NULL != rgMap)
    {
        for (dwIndex = 0; NULL != rgMap[dwIndex].szValue; dwIndex += 1)
            if (rgMap[dwIndex].dwValue == dwValue)
                break;
        if (NULL != rgMap[dwIndex].szValue)
            lstrcpy(szReturn, rgMap[dwIndex].szValue);
        else
            _stprintf(szReturn, TEXT("0x%08x"), dwValue);
    }
    else
        _stprintf(szReturn, TEXT("0x%08x"), dwValue);
    return szReturn;
}


static LPCTSTR
MaskValue(
    DWORD dwValue,
    const ValueMap *rgMap)
{
    static TCHAR szReturn[1024];
    TCHAR szNumeric[16];
    DWORD dwIndex;
    BOOL fSpace = FALSE;

    szReturn[0] = 0;
    if (NULL != rgMap)
    {
        for (dwIndex = 0; NULL != rgMap[dwIndex].szValue; dwIndex += 1)
        {
            if (rgMap[dwIndex].dwValue == (rgMap[dwIndex].dwValue & dwValue))
            {
                if (fSpace)
                    lstrcat(szReturn, TEXT(" "));
                else
                    fSpace = TRUE;
                lstrcat(szReturn, rgMap[dwIndex].szValue);
                dwValue &= ~rgMap[dwIndex].dwValue;
            }
        }
        if (0 != dwValue)
        {
            if (fSpace)
            {
                lstrcat(szReturn, TEXT(" "));
                fSpace = TRUE;
            }
            _stprintf(szNumeric, TEXT("0x%08x"), dwValue);
            lstrcat(szReturn, szNumeric);
        }
        else if (!fSpace)
            _stprintf(szReturn, TEXT("0x%08x"), dwValue);
    }
    else
        _stprintf(szReturn, TEXT("0x%08x"), dwValue);
    return szReturn;
}

static void
ShowBuf(
    LogBuffer &lb,
    ostream &outStr)
{
    if ((DWORD)(-1) == lb.cbOffset)
        outStr << TEXT("    ") << TEXT("<NULL>") << endl;
    else if (0 == lb.cbLength)
        outStr << TEXT("    {}") << endl;
    else if (l_cbLogData < lb.cbOffset + lb.cbLength)
        outStr << TEXT("    ") << TEXT("<BufferOverrun>") << endl;
    else
        dump(&l_pbLogData[lb.cbOffset], lb.cbLength, outStr);
}

static LPCTSTR
ShowString(
    LogBuffer &lb)
{
    LPCTSTR szReturn;

    if ((DWORD)(-1) == lb.cbOffset)
        szReturn = TEXT("<NULL>");
    else if (0 == lb.cbLength)
        szReturn = TEXT("{}");
    else if (l_cbLogData < lb.cbOffset + lb.cbLength)
        szReturn = TEXT("<bufferOverrun>");
    else if (TEXT('\000') != (LPCTSTR)(l_pbLogData[lb.cbOffset + lb.cbLength - sizeof(TCHAR)]))
        szReturn = TEXT("<UnterminatedString>");
    else
        szReturn = (LPCTSTR)&l_pbLogData[lb.cbOffset];
    return szReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\csptrace\showtrace.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    showTrace

Abstract:

    This module implements the CSP Tracing interpretation

Author:

    Doug Barlow (dbarlow) 5/16/1998

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#include <wincrypt.h>
#include <stdlib.h>
#include <iostream.h>
#include <iomanip.h>
#include <SCardLib.h>
#include "cspTrace.h"


//
// Definitions duplicated from logcsp.
//

static LPCTSTR
    CPNames[]
        = {
            TEXT("CryptAcquireContext"),
            TEXT("CryptGetProvParam"),
            TEXT("CryptReleaseContext"),
            TEXT("CryptSetProvParam"),
            TEXT("CryptDeriveKey"),
            TEXT("CryptDestroyKey"),
            TEXT("CryptExportKey"),
            TEXT("CryptGenKey"),
            TEXT("CryptGetKeyParam"),
            TEXT("CryptGenRandom"),
            TEXT("CryptGetUserKey"),
            TEXT("CryptImportKey"),
            TEXT("CryptSetKeyParam"),
            TEXT("CryptEncrypt"),
            TEXT("CryptDecrypt"),
            TEXT("CryptCreateHash"),
            TEXT("CryptDestroyHash"),
            TEXT("CryptGetHashParam"),
            TEXT("CryptHashData"),
            TEXT("CryptHashSessionKey"),
            TEXT("CryptSetHashParam"),
            TEXT("CryptSignHash"),
            TEXT("CryptVerifySignature"),
            NULL };

static void
ShowBuf(
    LPCTSTR szName,
    LogBuffer &lb,
    ostream &outStr);
static void
dump(
    const BYTE *pbData,
    DWORD cbLen,
    ostream &outStr);

static void
MapValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap);

static void
MaskValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap);

const ValueMap rgMapService[]
    = { MAP(AcquireContext),    MAP(GetProvParam),      MAP(ReleaseContext),
        MAP(SetProvParam),      MAP(DeriveKey),         MAP(DestroyKey),
        MAP(ExportKey),         MAP(GenKey),            MAP(GetKeyParam),
        MAP(GenRandom),         MAP(GetUserKey),        MAP(ImportKey),
        MAP(SetKeyParam),       MAP(Encrypt),           MAP(Decrypt),
        MAP(CreateHash),        MAP(DestroyHash),       MAP(GetHashParam),
        MAP(HashData),          MAP(HashSessionKey),    MAP(SetHashParam),
        MAP(SignHash),          MAP(VerifySignature),
        { 0, NULL } };

// dwFlags definitions for CryptAcquireContext
const ValueMap rgMapAcquireFlags[]
    = { MAP(CRYPT_VERIFYCONTEXT),   MAP(CRYPT_NEWKEYSET),
        MAP(CRYPT_DELETEKEYSET),    MAP(CRYPT_MACHINE_KEYSET),
        MAP(CRYPT_SILENT),
        { 0, NULL } };

// Parameter definitions for CryptGetProvParam
const ValueMap rgMapGetProvParam[]
    = { MAP(PP_ENUMALGS),           MAP(PP_ENUMCONTAINERS),
        MAP(PP_IMPTYPE),            MAP(PP_NAME),
        MAP(PP_VERSION),            MAP(PP_CONTAINER),
        MAP(PP_CHANGE_PASSWORD),    MAP(PP_KEYSET_SEC_DESCR),
        MAP(PP_CERTCHAIN),          MAP(PP_KEY_TYPE_SUBTYPE),
        MAP(PP_PROVTYPE),           MAP(PP_KEYSTORAGE),
        MAP(PP_APPLI_CERT),         MAP(PP_SYM_KEYSIZE),
        MAP(PP_SESSION_KEYSIZE),    MAP(PP_UI_PROMPT),
        MAP(PP_ENUMALGS_EX),        MAP(PP_ENUMMANDROOTS),
        MAP(PP_ENUMELECTROOTS),     MAP(PP_KEYSET_TYPE),
        MAP(PP_ADMIN_PIN),          MAP(PP_KEYEXCHANGE_PIN),
        MAP(PP_SIGNATURE_PIN),      MAP(PP_SIG_KEYSIZE_INC),
        MAP(PP_KEYX_KEYSIZE_INC),   MAP(PP_UNIQUE_CONTAINER),
        { 0, NULL } };

// Flag definitions for CryptGetProvParam
const ValueMap rgMapGetProvFlags[]
    = { MAP(CRYPT_FIRST),           MAP(CRYPT_NEXT),
      { 0, NULL } };

// Parameter definitions for CryptSetProvParam
const ValueMap rgMapSetProvParam[]
    = {
        MAP(PP_CLIENT_HWND),        MAP(PP_ENUMCONTAINERS),
        MAP(PP_IMPTYPE),            MAP(PP_NAME),
        MAP(PP_VERSION),            MAP(PP_CONTAINER),
        MAP(PP_CHANGE_PASSWORD),    MAP(PP_KEYSET_SEC_DESCR),
        MAP(PP_CERTCHAIN),          MAP(PP_KEY_TYPE_SUBTYPE),
        MAP(PP_CONTEXT_INFO),       MAP(PP_KEYEXCHANGE_KEYSIZE),
        MAP(PP_SIGNATURE_KEYSIZE),  MAP(PP_KEYEXCHANGE_ALG),
        MAP(PP_SIGNATURE_ALG),      MAP(PP_PROVTYPE),
        MAP(PP_KEYSTORAGE),         MAP(PP_APPLI_CERT),
        MAP(PP_SYM_KEYSIZE),        MAP(PP_SESSION_KEYSIZE),
        MAP(PP_UI_PROMPT),          MAP(PP_ENUMALGS_EX),
        MAP(PP_DELETEKEY),          MAP(PP_ENUMMANDROOTS),
        MAP(PP_ENUMELECTROOTS),     MAP(PP_KEYSET_TYPE),
        MAP(PP_ADMIN_PIN),          MAP(PP_KEYEXCHANGE_PIN),
        MAP(PP_SIGNATURE_PIN),
        { 0, NULL } };

// Parameter definitions for Hash Param
const ValueMap rgMapHashParam[]
    = {
        MAP(HP_ALGID),              MAP(HP_HASHVAL),
        MAP(HP_HASHSIZE),           MAP(HP_HMAC_INFO),
        MAP(HP_TLS1PRF_LABEL),      MAP(HP_TLS1PRF_SEED),
        { 0, NULL } };

// dwFlag definitions for CryptGenKey
const ValueMap rgMapGenKeyFlags[]
    = { MAP(CRYPT_EXPORTABLE),      MAP(CRYPT_USER_PROTECTED),
        MAP(CRYPT_CREATE_SALT),     MAP(CRYPT_UPDATE_KEY),
        MAP(CRYPT_NO_SALT),         MAP(CRYPT_PREGEN),
        MAP(CRYPT_RECIPIENT),       MAP(CRYPT_INITIATOR),
        MAP(CRYPT_ONLINE),          MAP(CRYPT_SF),
        MAP(CRYPT_CREATE_IV),       MAP(CRYPT_KEK),
        MAP(CRYPT_DATA_KEY),        MAP(CRYPT_VOLATILE),
        { 0, NULL } };

// dwFlags definitions for CryptDeriveKey
const ValueMap rgMapDeriveKeyFlags[]
    = { MAP(CRYPT_SERVER),
        { 0, NULL } };

// dwFlag definitions for CryptExportKey
const ValueMap rgMapExportKeyFlags[]
    = { MAP(CRYPT_Y_ONLY),          MAP(CRYPT_SSL2_FALLBACK),
        MAP(CRYPT_DESTROYKEY),
        { 0, NULL } };

// Parameter IDs for Get and Set KeyParam
const ValueMap rgMapKeyParam[]
    = { MAP(KP_IV),                 MAP(KP_SALT),
        MAP(KP_PADDING),            MAP(KP_MODE),
        MAP(KP_MODE_BITS),          MAP(KP_PERMISSIONS),
        MAP(KP_ALGID),              MAP(KP_BLOCKLEN),
        MAP(KP_KEYLEN),             MAP(KP_SALT_EX),
        MAP(KP_P),                  MAP(KP_G),
        MAP(KP_Q),                  MAP(KP_X),
        MAP(KP_Y),                  MAP(KP_RA),
        MAP(KP_RB),                 MAP(KP_INFO),
        MAP(KP_EFFECTIVE_KEYLEN),   MAP(KP_SCHANNEL_ALG),
        MAP(KP_CLIENT_RANDOM),      MAP(KP_SERVER_RANDOM),
        MAP(KP_RP),                 MAP(KP_PRECOMP_MD5),
        MAP(KP_PRECOMP_SHA),        MAP(KP_CERTIFICATE),
        MAP(KP_CLEAR_KEY),          MAP(KP_PUB_EX_LEN),
        MAP(KP_PUB_EX_VAL),         MAP(KP_KEYVAL),
        MAP(KP_ADMIN_PIN),          MAP(KP_KEYEXCHANGE_PIN),
        MAP(KP_SIGNATURE_PIN),      MAP(KP_PREHASH),
        { 0, NULL } };

// Key Type Id Definitions
const ValueMap rgMapKeyId[]
    = { MAP(AT_KEYEXCHANGE),        MAP(AT_SIGNATURE),
        { 0, NULL } };

// exported key blob definitions
const ValueMap rgMapBlobType[]
    = { MAP(SIMPLEBLOB),            MAP(PUBLICKEYBLOB),
        MAP(PRIVATEKEYBLOB),        MAP(PLAINTEXTKEYBLOB),
        MAP(OPAQUEKEYBLOB),
        { 0, NULL } };

// algorithm identifier definitions
const ValueMap rgMapAlgId[]
    = { MAP(AT_KEYEXCHANGE),        MAP(AT_SIGNATURE),
        MAP(CALG_MD2),              MAP(CALG_MD4),
        MAP(CALG_MD5),              MAP(CALG_SHA),
        MAP(CALG_SHA1),             MAP(CALG_MAC),
        MAP(CALG_RSA_SIGN),         MAP(CALG_DSS_SIGN),
        MAP(CALG_RSA_KEYX),         MAP(CALG_DES),
        MAP(CALG_3DES_112),         MAP(CALG_3DES),
        MAP(CALG_RC2),              MAP(CALG_RC4),
        MAP(CALG_SEAL),             MAP(CALG_DH_SF),
        MAP(CALG_DH_EPHEM),         MAP(CALG_AGREEDKEY_ANY),
        MAP(CALG_KEA_KEYX),         MAP(CALG_HUGHES_MD5),
        MAP(CALG_SKIPJACK),         MAP(CALG_TEK),
        MAP(CALG_CYLINK_MEK),       MAP(CALG_SSL3_SHAMD5),
        MAP(CALG_SSL3_MASTER),      MAP(CALG_SCHANNEL_MASTER_HASH),
        MAP(CALG_SCHANNEL_MAC_KEY), MAP(CALG_SCHANNEL_ENC_KEY),
        MAP(CALG_PCT1_MASTER),      MAP(CALG_SSL2_MASTER),
        MAP(CALG_TLS1_MASTER),      MAP(CALG_RC5),
        MAP(CALG_HMAC),             MAP(CALG_TLS1PRF),
        { 0, NULL } };


// ?Definitions?
// MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), rgMap?what?Flags);
static const ValueMap rgMapDemo[]
    = {
        { 0, NULL } };

static LPBYTE l_pbLogData = NULL;
static DWORD  l_cbLogData = 0;


/*++

DoShowTrace:

    This routine interprets the given binary file, writing the output to stdout.

Arguments:

    szInFile supplies the file name to be parsed.

Return Value:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 5/16/1998

--*/

void
DoShowTrace(
    IN LPCTSTR szInFile)
{
    HANDLE hLogFile = NULL;
    DWORD cbStructLen = 0;
    LPBYTE pbStruct = NULL;
    LogHeader *pLogObj;
    DWORD dwLen, dwRead;
    BOOL fSts;


    //
    // Open the log file.
    //

    hLogFile = CreateFile(
        szInFile,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (INVALID_HANDLE_VALUE == hLogFile)
    {
        cerr << TEXT("Can't open file ")
             << szInFile
             << ": "
             << CErrorString(GetLastError())
             << endl;
         goto ErrorExit;
    }


    //
    // Parse the file contents.
    //

    for (;;)
    {
        fSts = ReadFile(
                    hLogFile,
                    &dwLen,
                    sizeof(DWORD),
                    &dwRead,
                    NULL);
        if ((!fSts) || (0 == dwRead))
            goto ErrorExit;

        if (cbStructLen < dwLen)
        {
            if (NULL != pbStruct)
                LocalFree(pbStruct);
            pbStruct = (LPBYTE)LocalAlloc(LPTR, dwLen);
            cbStructLen = dwLen;
        }
        fSts = ReadFile(
                    hLogFile,
                    &pbStruct[sizeof(DWORD)],
                    dwLen - sizeof(DWORD),
                    &dwRead,
                    NULL);
        if (!fSts)
        {
            cerr << "File read error: " << CErrorString(GetLastError()) << endl;
            goto ErrorExit;
        }


        //
        // Parse the structure into bytesize chunks.
        //

        pLogObj = (LogHeader *)pbStruct;
        pLogObj->cbLength = dwLen;
        l_pbLogData = pbStruct + pLogObj->cbDataOffset;
        l_cbLogData = pLogObj->cbLength - pLogObj->cbDataOffset;


        //
        // We've got the structure, now display the contents.
        //

        cout
            << TEXT("-----------------------------------------------------\n")
            << flush;
        MapValue(cout, pLogObj->id, TEXT("Service:        "), rgMapService);
        switch (pLogObj->status)
        {
        case logid_False:
            cout << TEXT("Error returned") << endl;
            // Fall through intentionally
        case logid_True:
            cout
                << TEXT("Status:         ") << CErrorString(pLogObj->dwStatus)
                << endl;
            break;
        case logid_Exception:
            cout << TEXT("Exception Thrown\n") << flush;
            break;
        default:
            cerr << TEXT("Trace Log error: invalid Call Status.") << endl;
            goto ErrorExit;
        }
            cout
                << TEXT("Process/Thread: ")
                << PHex(pLogObj->dwProcId) << TEXT("/") << PHex(pLogObj->dwThreadId)
                << endl;
            cout
                << TEXT("Time:           ")
                << PTime(pLogObj->startTime) << TEXT(" - ") << PTime(pLogObj->endTime)
                << endl;
        switch (pLogObj->id)
        {

        case AcquireContext:
        {
            struct TmpLog {
                LogHeader lh;
                LogBuffer bfContainer;
                DWORD dwFlags;
                LogBuffer bfVTable;
                HCRYPTPROV hProv;
            } *pld = (struct TmpLog *)pLogObj;
            ShowBuf(TEXT("Container:      "), pld->bfContainer, cout);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), rgMapAcquireFlags);
            ShowBuf(TEXT("VTable          "), pld->bfVTable, cout);
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            break;
        }

        case GetProvParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwParam;
                DWORD dwDataLen;
                DWORD dwFlags;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            MapValue(cout, pld->dwParam, TEXT("Param Id:       "), rgMapGetProvParam);
            cout << TEXT("Buffer Space:   ") << PHex(pld->dwDataLen) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), rgMapGetProvFlags);
            ShowBuf(TEXT("Returned Data:  "), pld->bfData, cout);
            break;
        }

        case ReleaseContext:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            break;
        }

        case SetProvParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwParam;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            MapValue(cout, pld->dwParam, TEXT("Param Id:       "), rgMapSetProvParam);
            ShowBuf(TEXT("Supplied Data:  "), pld->bfData, cout);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            break;
        }

        case DeriveKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                ALG_ID Algid;
                HCRYPTHASH hHash;
                DWORD dwFlags;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            MapValue(cout, pld->Algid, TEXT("Algorithm:      "), rgMapAlgId);
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), rgMapDeriveKeyFlags);
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            break;
        }

        case DestroyKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            break;
        }

        case ExportKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                HCRYPTKEY hPubKey;
                DWORD dwBlobType;
                DWORD dwFlags;
                DWORD dwDataLen;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            cout << TEXT("HCRYPTpubKEY:   ") << PHex(pld->hPubKey) << endl;
            MapValue(cout, pld->dwBlobType, TEXT("BlobType:       "), rgMapBlobType);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), rgMapExportKeyFlags);
            cout << TEXT("Buffer Space:   ") << PHex(pld->dwDataLen) << endl;
            ShowBuf(TEXT("Returned Data:  "), pld->bfData, cout);
            break;
        }

        case GenKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                ALG_ID Algid;
                DWORD dwFlags;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            MapValue(cout, pld->Algid, TEXT("Algorithm:      "), rgMapAlgId);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), rgMapGenKeyFlags);
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            break;
        }

        case GetKeyParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                DWORD dwParam;
                DWORD dwDataLen;
                DWORD dwFlags;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            MapValue(cout, pld->dwParam, TEXT("Param Id:       "), rgMapKeyParam);
            cout << TEXT("Buffer Space:   ") << PHex(pld->dwDataLen) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            ShowBuf(TEXT("Returned Data:  "), pld->bfData, cout);
            break;
        }

        case GenRandom:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwLen;
                LogBuffer bfBuffer;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("Length:         ") << PHex(pld->dwLen) << endl;
            ShowBuf(TEXT("Returned Data:  "), pld->bfBuffer, cout);
            break;
        }

        case GetUserKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwKeySpec;
                HCRYPTKEY hUserKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            MapValue(cout, pld->dwKeySpec, TEXT("KeySpec:        "), rgMapKeyId);
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hUserKey) << endl;
            break;
        }

        case ImportKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                LogBuffer bfData;
                HCRYPTKEY hPubKey;
                DWORD dwFlags;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            ShowBuf(TEXT("Supplied Data:  "), pld->bfData, cout);
            cout << TEXT("HCRYPTpubKEY:   ") << PHex(pld->hPubKey) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            break;
        }

        case SetKeyParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                DWORD dwParam;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            MapValue(cout, pld->dwParam, TEXT("Param Id:       "), rgMapKeyParam);
            ShowBuf(TEXT("Supplied Data:  "), pld->bfData, cout);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            break;
        }

        case Encrypt:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                HCRYPTHASH hHash;
                BOOL Final;
                DWORD dwFlags;
                LogBuffer bfInData;
                DWORD dwBufLen;
                LogBuffer bfOutData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            cout << TEXT("Final:          ") << PHex(pld->Final) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            ShowBuf(TEXT("Supplied Data:  "), pld->bfInData, cout);
            cout << TEXT("Buffer Space:   ") << PHex(pld->dwBufLen) << endl;
            ShowBuf(TEXT("Received Data:  "), pld->bfOutData, cout);
            break;
        }

        case Decrypt:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                HCRYPTHASH hHash;
                BOOL Final;
                DWORD dwFlags;
                LogBuffer bfInData;
                LogBuffer bfOutData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            cout << TEXT("Final:          ") << PHex(pld->Final) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            ShowBuf(TEXT("Supplied Data:  "), pld->bfInData, cout);
            ShowBuf(TEXT("Received Data:  "), pld->bfOutData, cout);
            break;
        }

        case CreateHash:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                ALG_ID Algid;
                HCRYPTKEY hKey;
                DWORD dwFlags;
                HCRYPTHASH hHash;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            MapValue(cout, pld->Algid, TEXT("Algorithm:      "), rgMapAlgId);
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            break;
        }

        case DestroyHash:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            break;
        }

        case GetHashParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                DWORD dwParam;
                DWORD dwDataLen;
                DWORD dwFlags;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            MapValue(cout, pld->dwParam, TEXT("Param Id:       "), rgMapHashParam);
            cout << TEXT("Buffer Space:   ") << PHex(pld->dwDataLen) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            ShowBuf(TEXT("Returned Data:  "), pld->bfData, cout);
            break;
        }

        case HashData:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            ShowBuf(TEXT("Supplied Data:  "), pld->bfData, cout);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            break;
        }

        case HashSessionKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                HCRYPTKEY hKey;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            break;
        }

        case SetHashParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                DWORD dwParam;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            MapValue(cout, pld->dwParam, TEXT("Param Id:       "), rgMapHashParam);
            ShowBuf(TEXT("Supplied Data:  "), pld->bfData, cout);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            break;
        }

        case SignHash:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                DWORD dwKeySpec;
                LogBuffer bfDescription;
                DWORD dwFlags;
                DWORD dwSigLen;
                LogBuffer bfSignature;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            MapValue(cout, pld->dwKeySpec, TEXT("KeySpec:        "), rgMapKeyId);
            ShowBuf(TEXT("Description:    "), pld->bfDescription, cout);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            cout << TEXT("Buffer Space:   ") << PHex(pld->dwSigLen) << endl;
            ShowBuf(TEXT("Signature:      "), pld->bfSignature, cout);
            break;
        }

        case VerifySignature:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                LogBuffer bfSignature;
                DWORD dwSigLen;
                HCRYPTKEY hPubKey;
                LogBuffer bfDescription;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            ShowBuf(TEXT("Signature:      "), pld->bfSignature, cout);
            cout << TEXT("HCRYPTpubKEY:   ") << PHex(pld->hPubKey) << endl;
            ShowBuf(TEXT("Description:    "), pld->bfDescription, cout);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            break;
        }

        default:
            cerr << TEXT("Internal error") << endl;
            goto ErrorExit;
            break;
        }
    }

ErrorExit:
    if (NULL == hLogFile)
        CloseHandle(hLogFile);
}


//
///////////////////////////////////////////////////////////////////////////////
//
// Suport routines
//

static void
dump(
    const BYTE *pbData,
    DWORD cbLen,
    ostream &outStr)
{
    unsigned long int
        b, i, lc;
    char
        buffer[8];


    lc = 0;
    while (0 < cbLen)
    {
        b = min(sizeof(buffer), cbLen);
        memcpy(buffer, pbData, b);
        pbData += b;
        cbLen -= b;
        if (0 < b)
        {
            outStr << TEXT("                ") << setw(8) << setfill(TEXT('0')) << hex << lc;
            for (i = 0; i < b; i += 1)
                outStr
                    << "  "
                    << setw(2) << setfill('0') << hex
                    << ((unsigned int)buffer[i] & 0xff);
            for (; i < sizeof(buffer) + 1; i += 1)
                outStr << "    ";
            for (i = 0; i < b; i += 1)
                outStr
                    << setw(0) << setfill(' ') << dec
                    << ((0 != iscntrl((int)(0x7f & buffer[i])))
                        ? TEXT('.')
                        : buffer[i]);
            outStr << endl;
            lc += b;
        }
    }
}


static void
MapValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap)
{
    DWORD dwIndex;

    if (NULL != rgMap)
    {
        for (dwIndex = 0; NULL != rgMap[dwIndex].szValue; dwIndex += 1)
            if (rgMap[dwIndex].dwValue == dwValue)
                break;
        if (NULL != rgMap[dwIndex].szValue)
            outStr << szLeader << rgMap[dwIndex].szValue << endl;
        else
            outStr << szLeader << PHex(dwValue) << endl;
    }
    else
        outStr << szLeader << PHex(dwValue) << endl;
}


static void
MaskValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap)
{
    DWORD dwIndex;
    BOOL fSpace = FALSE;

    if (NULL != rgMap)
    {
        outStr << szLeader;

        for (dwIndex = 0; NULL != rgMap[dwIndex].szValue; dwIndex += 1)
        {
            if (rgMap[dwIndex].dwValue == (rgMap[dwIndex].dwValue & dwValue))
            {
                if (fSpace)
                    outStr << TEXT(' ');
                else
                    fSpace = TRUE;
                outStr << rgMap[dwIndex].szValue;
                dwValue &= ~rgMap[dwIndex].dwValue;
            }
        }
        if (0 != dwValue)
        {
            if (fSpace)
            {
                outStr << TEXT(' ');
                fSpace = TRUE;
            }
            outStr << PHex(dwValue);
        }
        else if (!fSpace)
            outStr << PHex(dwValue);
        outStr << endl;
    }
    else
        outStr << szLeader << PHex(dwValue) << endl;
}

static void
ShowBuf(
    LPCTSTR szName,
    LogBuffer &lb,
    ostream &outStr)
{
    if ((DWORD)(-1) == lb.cbOffset)
    {
        outStr << szName << TEXT("<NULL>\n")
               << TEXT("Length:         ")
               << PDec(lb.cbLength)
               << TEXT(" (") << PHex(lb.cbLength) << TEXT(")")
               << endl;
    }
    else if (0 == lb.cbLength)
    {
        outStr << szName << TEXT("\n")
               << TEXT("Length:         ")
               << PDec(lb.cbLength)
               << TEXT(" (") << PHex(lb.cbLength) << TEXT(")")
               << endl;
    }
    else if (l_cbLogData < lb.cbOffset + lb.cbLength)
    {
        outStr << szName << TEXT("<Buffer Overrun>\n")
               << TEXT("Length:         ")
               << PDec(lb.cbLength)
               << TEXT(" (") << PHex(lb.cbLength) << TEXT(")")
               << endl;
    }
    else
    {
        outStr << szName << endl;
        dump(&l_pbLogData[lb.cbOffset], lb.cbLength, outStr);
        outStr << TEXT("Length:         ")
               << PDec(lb.cbLength)
               << TEXT(" (") << PHex(lb.cbLength) << TEXT(")")
               << endl;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\csptrace\trcutils.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    trcUtils

Abstract:

    This module provides utility services for the CSP Trace functions.

Author:

    Doug Barlow (dbarlow) 5/18/1998

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#include <wincrypt.h>
#include <stdlib.h>
#include <iostream.h>
#include <iomanip.h>
#include <tchar.h>
#include <scardlib.h>
#include "cspTrace.h"

static const TCHAR l_szLogCsp[] = TEXT("LogCsp.dll");


/*++

FindLogCsp:

    This routine locates the LogCsp.dll file on the disk.

Arguments:

    None

Return Value:

    The full path name of the LogCsp.dll.

Author:

    Doug Barlow (dbarlow) 5/18/1998

--*/

LPCTSTR
FindLogCsp(
    void)
{
    static TCHAR szLogCspPath[MAX_PATH] = TEXT("");

    SUBACTION("Searching for the Logging CSP Image");
    if (0 == szLogCspPath[0])
    {
        DWORD dwSts;
        LPTSTR szFile;

        dwSts = SearchPath(
                    NULL,
                    l_szLogCsp,
                    NULL,
                    sizeof(szLogCspPath),
                    szLogCspPath,
                    &szFile);
        ASSERT(sizeof(szLogCspPath) >= dwSts);
        if (0 == dwSts)
        {
            szLogCspPath[0] = 0;
            throw GetLastError();
        }
    }
    return szLogCspPath;
}


/*++

FindLoggedCsp:

    This routine scans the CSP registry, looking for an entry that points to
    the Logging CSP.  If more than one such entry exists, only the first one is
    returned.

Arguments:

    None

Return Value:

    The name of a CSP that is being logged, or NULL.

Author:

    Doug Barlow (dbarlow) 5/18/1998

--*/

LPCTSTR
FindLoggedCsp(
    void)
{
    static TCHAR szCspName[MAX_PATH];
    SUBACTION("Searching for a Logged CSP");
    CRegistry
        rgCspDefault(
            HKEY_LOCAL_MACHINE,
            TEXT("SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider"),
            KEY_READ);
    CRegistry rgCsp;
    LPCTSTR szCsp, szCspPath;
    DWORD dwIndex, dwLen;
    LONG nCompare;

    for (dwIndex = 0;; dwIndex += 1)
    {
        szCsp = rgCspDefault.Subkey(dwIndex);
        if (NULL == szCsp)
            break;
        rgCsp.Open(rgCspDefault, szCsp, KEY_READ);
        szCspPath = rgCsp.GetStringValue(TEXT("Image Path"));
        dwLen = lstrlen(szCspPath);
        if (dwLen >= (sizeof(l_szLogCsp) - 1) / sizeof(TCHAR))
            nCompare = lstrcmpi(
                l_szLogCsp,
                &szCspPath[dwLen - (sizeof(l_szLogCsp) - 1) / sizeof(TCHAR)]);
        else
            nCompare = -1;
        rgCsp.Close();
        if (0 == nCompare)
        {
            lstrcpy(szCspName, szCsp);
            return szCspName;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\log\logpriv.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\inc\tstring.h ===
#ifndef _TString_H_DEF_
#define _TString_H_DEF_

#include <string>

#if defined(_UNICODE) || defined(UNICODE)
typedef std::wstring TSTRING;
#else
typedef std::string TSTRING;
#endif

#endif	// _TString_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\inc\log.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Log

Abstract:

    This module implements the logging capabilities of SCTest.

Author:

    Eric Perlin (ericperl) 06/07/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef _Log_H_DEF_
#define _Log_H_DEF_

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <wchar.h>
#include <tchar.h>
#include <stdio.h>

#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const BYTE *LPCBYTE;
#endif

#define LOGBUFFERSIZE	4096

typedef struct {
    TCHAR *szLogCrt;						// Current pointer in the buffer
    TCHAR szLogBuffer[LOGBUFFERSIZE];		// Buffering of the log
} LOGCONTEXT, *PLOGCONTEXT;

void LogInit(
	IN LPCTSTR szLogName,
	IN BOOL fVerbose
	);

void LogClose(
	);

void LogLock(
    );

void LogUnlock(
    );

PLOGCONTEXT LogStart(
	);

void LogStop(
    IN PLOGCONTEXT pLogCtx,
	IN BOOL fExpected = TRUE
	);

void LogString2FP(
	IN FILE *fp,
	IN LPCSTR szMsg
	);

void LogString2FP(
	IN FILE *fp,
	IN LPCWSTR szMsg
	);

void LogThisOnly(
	IN LPCSTR szMsg,
	IN BOOL fExpected = TRUE
	);

void LogThisOnly(
	IN LPCWSTR szMsg,
	IN BOOL fExpected = TRUE
	);

PLOGCONTEXT LogStart(
    IN LPCTSTR szFunctionName,
	IN DWORD dwGLE,
	IN DWORD dwExpected,
    IN LPSYSTEMTIME pxStartST,
    IN LPSYSTEMTIME pxEndST
	);

PLOGCONTEXT LogVerification(
    IN LPCTSTR szFunctionName,
    IN BOOL fSucceeded
	);

void LogNiceError(
    IN PLOGCONTEXT pLogCtx,
    IN DWORD dwRet,
    IN LPCTSTR szHeader = NULL
    );

void LogString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCSTR szS
	);

void LogString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCWSTR szS
	);

void LogString(
    IN PLOGCONTEXT pLogCtx,
    IN LPCSTR szHeader,
	IN LPCSTR szS
	);

void LogString(
    IN PLOGCONTEXT pLogCtx,
    IN LPCWSTR szHeader,
	IN LPCWSTR szS
	);

void LogMultiString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCSTR szMS,
    IN LPCSTR szHeader = NULL
	);

void LogMultiString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCWSTR szMS,
    IN LPCWSTR szHeader = NULL
	);

void LogBinaryData(
    IN PLOGCONTEXT pLogCtx,
	IN LPCBYTE rgData,
	IN DWORD dwSize,
    IN LPCTSTR szHeader = NULL
	);

void LogDWORD(
    IN PLOGCONTEXT pLogCtx,
	IN DWORD dwDW,
    IN LPCTSTR szHeader = NULL
	);

void LogPtr(
    IN PLOGCONTEXT pLogCtx,
	IN LPCVOID lpv,
    IN LPCTSTR szHeader
	);

void LogDecimal(
    IN PLOGCONTEXT pLogCtx,
	IN DWORD dwDW,
    IN LPCTSTR szHeader = NULL
	);

void LogResetCounters(
	);

DWORD LogGetErrorCounter(
	);

#endif	// _Log_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\log\logt.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    LogT

Abstract:

    This module implements the logging capabilities of SCTest,
	specifically the part build for both Unicode and ANSI.

Author:

    Eric Perlin (ericperl) 07/21/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <fstream>
#include <algorithm>
#include "TString.h"
#include "Log.h"

extern BOOL g_fVerbose;
extern FILE *g_fpLog;

/*++

LogThisOnly:

	Implements logging according to the following matrix:
	Console Output:
			| Verbose |   Not   |
	-----------------------------
	Not Exp.|  cerr	  |   cerr	|
	-----------------------------
	Expected|  cout   |    /    |  
	-----------------------------
	If a log was specified, everything is logged.

Arguments:

	szMsg supplies the content to be logged
	fExpected indicates the expected status

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
void LogThisOnly(
	IN LPCTSTR szMsg,
	IN BOOL fExpected
	)
{
	LogLock();
	if (!fExpected)
	{
		LogString2FP(stderr, szMsg);
	}
	else if (g_fVerbose)
	{
		LogString2FP(stdout, szMsg);
	}

	if (NULL != g_fpLog)
	{
		LogString2FP(g_fpLog, szMsg);
	}
	LogUnlock();
}



/*++

LogString:

Arguments:

    szHeader supplies a header
	szMsg supplies the content to be logged

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogString(
    IN PLOGCONTEXT pLogCtx,
    IN LPCTSTR szHeader,
	IN LPCTSTR szS
	)
{
	if (szHeader)
	{
		LogString(pLogCtx, szHeader);
	}

	if (NULL == szS)
	{
		LogString(pLogCtx, _T("<null>"));
	}
	else if (0 == _tcslen(szS))
	{
		LogString(pLogCtx, _T("<empty>"));
	}
	else
	{
		LogString(pLogCtx, szS);
	}

	if (szHeader)
	{
		LogString(pLogCtx, _T("\n"));
	}
}

/*++

LogMultiString:

Arguments:

	szMS supplies the multi-string to be logged
    szHeader supplies a header

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogMultiString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCTSTR szMS,
    IN LPCTSTR szHeader
	)
{
	if (szHeader)
	{
		LogString(pLogCtx, szHeader, _T(" "));
	}

	if (NULL == szMS)
	{
		LogString(pLogCtx, _T("                <null>"));
	    if (szHeader)
	    {
		    LogString(pLogCtx, _T("\n"));
	    }
	}
	else if ( (TCHAR)'\0' == *szMS )
	{
		LogString(pLogCtx, _T("                <empty>"));
	    if (szHeader)
	    {
		    LogString(pLogCtx, _T("\n"));
	    }
	}
	else
	{
		LPCTSTR sz = szMS;
		while ( (TCHAR)'\0' != *sz )
		{
			// Display the value.
			LogString(pLogCtx, _T("                "), sz);
			// Advance to the next value.
			sz = sz + _tcslen(sz) + 1;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\log\logw\logw.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <stdio.h>
#include "Log.h"

/*++

LogString2FP:

Arguments:

	fp supplies the stream 
	szMsg supplies the content to be logged

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogString2FP(
	IN FILE *fp,
	IN LPCWSTR szMsg
	)
{
#if defined(_UNICODE) || defined(UNICODE)
		fwprintf(fp, L"%s", szMsg);
#else
		fwprintf(fp, L"%S", szMsg);   // Conversion required
#endif
}

/*++

LogString:

Arguments:

	szMsg supplies the content to be logged

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCWSTR szMsg
	)
{
#if defined(_UNICODE) || defined(UNICODE)
		pLogCtx->szLogCrt += swprintf(pLogCtx->szLogCrt, L"%s", szMsg);
#else
		pLogCtx->szLogCrt += swprintf(pLogCtx->szLogCrt, L"%S", szMsg);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\log\loga\loga.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <stdio.h>
#include "Log.h"

/*++

LogString2FP:

Arguments:

	fp supplies the stream 
	szMsg supplies the content to be logged

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogString2FP(
	IN FILE *fp,
	IN LPCSTR szMsg
	)
{
#if defined(_UNICODE) || defined(UNICODE)
		fprintf(fp, "%S", szMsg);   // Conversion required
#else
		fprintf(fp, "%s", szMsg);
#endif
}

/*++

LogString:

Arguments:

	szMsg supplies the content to be logged

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCSTR szMsg
	)
{
#if defined(_UNICODE) || defined(UNICODE)
		pLogCtx->szLogCrt += sprintf(pLogCtx->szLogCrt, "%S", szMsg);
#else
		pLogCtx->szLogCrt += sprintf(pLogCtx->szLogCrt, "%s", szMsg);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\item.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Item

Abstract:

    Virtual test item implementation.

Author:

    Eric Perlin (ericperl) 06/07/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "Item.h"
#include "Log.h"


void CItem::Log() const
{
    PLOGCONTEXT pLogCtx = LogStart();

	LogString(pLogCtx, _T("Test "));
	LogDecimal(pLogCtx, GetTestNumber());
	LogString(pLogCtx, _T(" ("));

	if (IsInteractive())
	{
		LogString(pLogCtx, _T("i"));
	}
	else
	{
		LogString(pLogCtx, _T("-"));
	}

	if (IsFatal())
	{
		LogString(pLogCtx, _T("f"));
	}
	else
	{
		LogString(pLogCtx, _T("-"));
	}

	if (m_szDescription.empty())
	{
		LogString(pLogCtx, _T("): "), _T("No description"));
	}
	else
	{
		LogString(pLogCtx, _T("): "), m_szDescription.c_str());
	}

    LogStop(pLogCtx, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\log\log\log.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Log

Abstract:

    This module implements the logging capabilities of SCTest.

Author:

    Eric Perlin (ericperl) 05/31/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TString.h"
#include <algorithm>
#include "Log.h"

BOOL g_fVerbose = FALSE;				// Verbose flag
FILE *g_fpLog = NULL;

static TSTRING l_szLogName;
static HANDLE l_hLogMutex = NULL;
static DWORD l_cbError;
static DWORD l_cbInSequence;

using namespace std;

/*++

LogInit:

    Inits logging (log file & verbosity).
	Shall be followed by a LogClose when logging is not needed anymore.

Arguments:

    szLogName supplies the log file name (can be NULL if no log is required)
	fVerbose supplies the verbose mode

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
void LogInit(
	IN LPCTSTR szLogName,
	IN BOOL fVerbose
	)
{
	g_fVerbose = fVerbose;

	if (NULL != szLogName)
	{
		l_szLogName = szLogName;

		if (g_fVerbose)
		{
			_ftprintf(stdout, _T("Logging to file: %s\n"), l_szLogName);
		}

		{
			TSTRING szLogMutexName;

			szLogMutexName = _T("Mutex_");
			szLogMutexName += l_szLogName;

			TSTRING::iterator begin, end;

			begin = szLogMutexName.begin();
			end = szLogMutexName.end();

			replace(begin, end, (TCHAR)'\\', (TCHAR)'_');

			if (g_fVerbose)
			{
				_ftprintf(stdout, _T("Logging mutex used: %s\n"), szLogMutexName);
			}

			if (NULL == (l_hLogMutex = CreateMutex(NULL, FALSE, szLogMutexName.c_str())))
			{
				PLOGCONTEXT pLogCtx = LogStart();
				LogNiceError(pLogCtx, GetLastError(), _T("Error creating the logging mutex: "));
				LogStop(pLogCtx, FALSE);
			}
		}
	}
}

/*++

LogClose:

    Terminates logging for this process (resource cleanup).
	This is the counterpart of LogInit.

Arguments:

    None

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
void LogClose()
{
	if (NULL != l_hLogMutex)
	{
		CloseHandle(l_hLogMutex);
		l_hLogMutex = NULL;
	}
}

/*++

LogLock:

    Locks the log file (shall be followed by LogUnlock at some point so other
	threads/processes can access the log).

Arguments:
    None

Return Value:
    None.

Author:

    Eric Perlin (ericperl) 10/31/2000

--*/
void LogLock(
    )
{
	BOOL fOpen = TRUE;			// Opening the log file or not

	if (NULL != l_hLogMutex)
	{
Again:
		DWORD dwWait = WaitForSingleObject(l_hLogMutex, 1000);
		switch(dwWait)
		{
		case WAIT_OBJECT_0:		// expected
			break;
		case WAIT_TIMEOUT:		// other logs busy for more than 1 sec!!!
			_ftprintf(stderr, _T("Timeout waiting for the Logging mutex\n"));
			fOpen = FALSE;
			break;
		case WAIT_ABANDONED:
				// A thread failed to release it before it died. I am now the owner.
				// Let's put it back in a state where it can be waited on.
			ReleaseMutex(l_hLogMutex);
			goto Again;
		default:
			_ftprintf(stderr, _T("Error waiting for the logging mutex: %08lX\n"), GetLastError());
			fOpen = FALSE;
			break;
		}
	}

	if (!l_szLogName.empty())
	{
		if (fOpen)
		{
			g_fpLog = _tfopen(l_szLogName.c_str(), _T("at+"));
			if (NULL == g_fpLog)
			{
				_ftprintf(stderr, _T("Couldn't open/create the log file: %s\n"), l_szLogName);
				l_szLogName.resize(0);
			}
		}
	}
}

/*++

LogLock:

    Unlocks the log file (counterpart of LogLock).

Arguments:
    None

Return Value:
    None.

Author:

    Eric Perlin (ericperl) 10/31/2000

--*/
void LogUnlock(
    )
{
	if (NULL != l_hLogMutex)
	{
		ReleaseMutex(l_hLogMutex);
	}
}

/*++

LogStart:

    Starts logging (shall be followed by LogStop at some point so other
	threads/processes can access the log).

Arguments:
    None

Return Value:
    A log context.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
PLOGCONTEXT LogStart()
{
    PLOGCONTEXT pLogCtx = (PLOGCONTEXT)HeapAlloc(GetProcessHeap(), 0, sizeof(LOGCONTEXT));

    if (NULL != pLogCtx)
    {
    		// Buffer management
        pLogCtx->szLogCrt = pLogCtx->szLogBuffer;
	    *(pLogCtx->szLogCrt) = 0;
    }

    return pLogCtx;
}

/*++

LogStop:

    Releases the log "acquired" by LogStart().
	Flushes the logging buffer according to the following matrix:
	Console Output:
			| Verbose |   Not   |
	-----------------------------
	Not Exp.|  cerr	  |   cerr	|
	-----------------------------
	Expected|  cout   |    /    |  
	-----------------------------
	If a log was specified, everything is logged.

Arguments:

    pLogCtx provides the log context to be dumped
	fExpected indicates the expected status

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
void LogStop(
    IN PLOGCONTEXT pLogCtx,
	IN BOOL fExpected
)
{
    LogLock();

	if ((pLogCtx) && (pLogCtx->szLogCrt != pLogCtx->szLogBuffer))
	{
		if (NULL != g_fpLog)
		{
			_fputts(pLogCtx->szLogBuffer, g_fpLog);
		}

		if (!fExpected)
		{
			_fputts(pLogCtx->szLogBuffer, stderr);
		}
		else if (g_fVerbose)
		{
			_fputts(pLogCtx->szLogBuffer, stdout);
		}
		else
		{	// We want to output the success (but not the parameters)
			pLogCtx->szLogCrt = _tcsstr(pLogCtx->szLogBuffer, _T("\n"));
			if (NULL != pLogCtx->szLogCrt)
			{
				pLogCtx->szLogCrt += _tcslen(_T("\n"));
				*(pLogCtx->szLogCrt) = 0;
				_fputts(pLogCtx->szLogBuffer, stdout);
			}
		}

		HeapFree(GetProcessHeap(), 0, pLogCtx);
	}

	if (NULL != g_fpLog)
	{
		fflush(g_fpLog);
		fclose(g_fpLog);
		g_fpLog = NULL;
	}

    LogUnlock();
}

/*++

LogNiceError:

    Outputs a nice error message.

Arguments:

    pLogCtx provides the log context to be used
	szHeader supplies an error header
    dwRet is the error code

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
void LogNiceError(
    IN PLOGCONTEXT pLogCtx,
    IN DWORD dwRet,
    IN LPCTSTR szHeader
    )
{
    if (NULL == pLogCtx)
        return;

	if (szHeader)
	{
		pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("%s"), szHeader);
	}

        // Display the error code
	pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%08X (%ld)\n    -> "), dwRet, dwRet);

        // Display the error message
    {
        DWORD ret;
        LPVOID lpMsgBuf = NULL;
		DWORD dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS;

		if ((dwRet & ~0x7F) == 0xC0000080)		// WPSC proxy error
		{
			dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
		}
		else
		{
			dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
		}

        ret = FormatMessage( 
            dwFlags,
            NULL,
            dwRet,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL 
        );

        if (ret && lpMsgBuf)
        {
			size_t len = _tcslen((TCHAR *)lpMsgBuf);
			if (len>=2)
			{
				len--;

				do 
				{
					if (((TCHAR *)lpMsgBuf)[len] < 32)	// not printable, likely to be a \n
						((TCHAR *)lpMsgBuf)[len] = (TCHAR)' ';
				} while (--len);
			}

			pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("%s\n"), (LPTSTR)lpMsgBuf);

            // Free the buffer.
            LocalFree( lpMsgBuf );
        }
        else
		{
			pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("No corresponding message!\n"));
		}
    }
}

/*++

LogStart:

    Starts logging for some API call (calls the parameter free version).

Arguments:
    szFunctionName
	dwGLE
	dwExpected
    pxStartST
    pxEndST

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
PLOGCONTEXT LogStart(
    IN LPCTSTR szFunctionName,
	IN DWORD dwGLE,
	IN DWORD dwExpected,
    IN LPSYSTEMTIME pxStartST,
    IN LPSYSTEMTIME pxEndST
	)
{
    PLOGCONTEXT pLogCtx = LogStart();

		// Entry point logging
        // Service Name
    if (NULL != pLogCtx)
	{
		TCHAR szLine[100];
		TCHAR szHeader[100];

		_stprintf(
			szHeader,
			_T("%3ld. "),
			++l_cbInSequence);

		if (dwGLE == dwExpected)
		{
			_stprintf(szLine, _T("%-67sPassed"), szFunctionName);
		}
		else
		{
			l_cbError++;
			_stprintf(szLine, _T("%-66s*FAILED*"), szFunctionName);
		}

		LogString(pLogCtx, szHeader, szLine);
	}

    if (NULL != pLogCtx)
	{
	    if (dwExpected == 0)
	    {
            LogString(pLogCtx, _T("Expected:       Success\n"));
	    }
	    else
	    {
		    LogNiceError(pLogCtx, dwExpected, _T("Expected:       "));
	    }
	    if (dwGLE == 0)
	    {
            LogString(pLogCtx, _T("Returned:       Success\n"));
	    }
	    else
	    {
		    LogNiceError(pLogCtx, dwGLE, _T("Returned:       "));
	    }

            // Process/Thread ID
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("Process/Thread: 0x%08lX / 0x%08lX\n"),
		    GetCurrentProcessId(), GetCurrentThreadId());

            // Time
        {
            FILETIME xSFT, xEFT;
		    ULARGE_INTEGER ullS, ullE;

            SystemTimeToFileTime(pxStartST, &xSFT);
		    memcpy(&ullS, &xSFT, sizeof(FILETIME));
            SystemTimeToFileTime(pxEndST, &xEFT);
		    memcpy(&ullE, &xEFT, sizeof(FILETIME));
		    ullE.QuadPart -= ullS.QuadPart;	// time difference
		    ullE.QuadPart /= 10000;			// in ms

            pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt,
			    _T("Time:           %02d:%02d:%02d.%03d - %02d:%02d:%02d.%03d (%I64d ms)\n"),
                    pxStartST->wHour,
                    pxStartST->wMinute,
                    pxStartST->wSecond,
                    pxStartST->wMilliseconds,
                    pxEndST->wHour,
                    pxEndST->wMinute,
                    pxEndST->wSecond,
                    pxEndST->wMilliseconds,
                    ullE.QuadPart
                    );
        }
    }

    return pLogCtx;
}

/*++

LogVerification:

    Starts logging verification code (calls the parameter free version).

Arguments:
    szFunctionName
    fSucceeded

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 10/18/2000

--*/
PLOGCONTEXT LogVerification(
    IN LPCTSTR szFunctionName,
    IN BOOL fSucceeded
	)
{
    PLOGCONTEXT pLogCtx = LogStart();

		// Entry point logging
        // Service Name
    if (NULL != pLogCtx)
	{
		TCHAR szLine[100];
		TCHAR szHeader[100];

		_stprintf(
			szHeader,
			_T("%3ld. "),
			++l_cbInSequence);

		if (fSucceeded)
		{
			_stprintf(szLine, _T("%-67sPassed"), szFunctionName);
		}
		else
		{
			l_cbError++;
			_stprintf(szLine, _T("%-66s*FAILED*"), szFunctionName);
		}

		LogString(pLogCtx, szHeader,	szLine);
	}

    if (NULL != pLogCtx)
    {
            // Process/Thread ID
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("Process/Thread: 0x%08lX / 0x%08lX\n"),
		    GetCurrentProcessId(), GetCurrentThreadId());
    }

    return pLogCtx;
}

void LogBinaryData(
    IN PLOGCONTEXT pLogCtx,
	IN LPCBYTE rgData,
	IN DWORD dwSize,
    IN LPCTSTR szHeader
	)
{
    if (NULL == pLogCtx)
        return;

	if (szHeader)
	{
		LogString(pLogCtx, szHeader);
	}

	if (NULL == rgData)
	{
		LogString(pLogCtx, _T("<NULL>"));
	}
	else
	{
		DWORD dwOffset = 0;
		DWORD i;

		while (dwOffset < dwSize)
		{
			pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("\n                "));
#ifdef _WIN64
	        pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%016I64X  "), rgData+dwOffset);
#else
	        pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%08lX  "), rgData+dwOffset);
#endif
			for (i=0 ; (i<8) && (dwOffset+i<dwSize) ; i++)
			{
				pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("  %02X"), rgData[dwOffset+i]);
			}
			while (i<8)
			{
				pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("    "));
				i++;
			}
			
			pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("    "));
			for (i=0 ; (i<8) && (dwOffset+i<dwSize) ; i++)
			{
				if ((rgData[dwOffset+i] < 32) || (rgData[dwOffset+i] > 127))
				{
					pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T(" "));
				}
				else
				{
					pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("%c"), rgData[dwOffset+i]);
				}
			}

			dwOffset += 8;
		}

        pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("\n"));
	}
}

void LogDWORD(
    IN PLOGCONTEXT pLogCtx,
	IN DWORD dwDW,
    IN LPCTSTR szHeader
	)
{
    if (NULL == pLogCtx)
        return;

	if (szHeader)
	{
		LogString(pLogCtx, szHeader);

	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%08lX\n"), dwDW);
	}
	else
	{
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%08lX"), dwDW);
	}

}

void LogPtr(
    IN PLOGCONTEXT pLogCtx,
	IN LPCVOID lpv,
    IN LPCTSTR szHeader
	)
{
    if (NULL == pLogCtx)
        return;

	if (szHeader)
	{
		LogString(pLogCtx, szHeader);

#ifdef _WIN64
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%016I64X\n"), lpv);
#else
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%08lX\n"), lpv);
#endif
	}
	else
	{
#ifdef _WIN64
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%016I64X"), lpv);
#else
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%08lX"), lpv);
#endif
	}

}

void LogDecimal(
    IN PLOGCONTEXT pLogCtx,
	IN DWORD dwDW,
    IN LPCTSTR szHeader
	)
{
    if (NULL == pLogCtx)
        return;

	if (szHeader)
	{
		LogString(pLogCtx, szHeader);

	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("%ld\n"), dwDW);
	}
	else
	{
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("%ld"), dwDW);
	}

}

void LogResetCounters(
	)
{
	l_cbError = 0;
	l_cbInSequence = 0;
}


DWORD LogGetErrorCounter(
	)
{
	return l_cbError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\apiproxy.c ===
/*
** Proxied Application Program Interface (API) for Windows Card
**
*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "MarshalPC.h"

LONG WINAPI SCWTransmit(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut);

    // Buffers for APDU exchange
#define MAX_APDU    255

    // Command header helpers
#define CLA(cla)    UINT82XSCM(&phTmp->xSCM, cla, TYPE_NOTYPE_NOCOUNT)
#define INS(ins)    UINT82XSCM(&phTmp->xSCM, ins, TYPE_NOTYPE_NOCOUNT)
#define P1(p1)      UINT82XSCM(&phTmp->xSCM, p1, TYPE_NOTYPE_NOCOUNT)
#define P2(p2)      UINT82XSCM(&phTmp->xSCM, p2, TYPE_NOTYPE_NOCOUNT)
#define Lc(lc)      (phTmp->pbLc = GetSCMCrtPointer(&phTmp->xSCM), UINT82XSCM(&phTmp->xSCM, 0, TYPE_NOTYPE_NOCOUNT))  // We don't know at this time
#define UPDATE_Lc(lc) *phTmp->pbLc = lc


static SCODE ExtractSCODE(LPMYSCARDHANDLE phTmp, LPCBYTE abRAPDU, DWORD dwOut);

//*****************************************************************************
//      EXPORTED API
//*****************************************************************************

/*
** AnA
*/
SCODE WINAPI hScwGetPrincipalUID(SCARDHANDLE hCard, WCSTR principalName, TUID *principalUID)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(1);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, principalName, phTmp->dwFlags & FLAG_BIGENDIAN);
		UINT8BYREF2XSCM(&phTmp->xSCM, principalUID);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			*principalUID = XSCM2UINT8(&phTmp->xSCM);
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}


SCODE WINAPI hScwAuthenticateName(SCARDHANDLE hCard, WCSTR name , BYTE *supportData, TCOUNT supportDataLength) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(2);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, name, phTmp->dwFlags & FLAG_BIGENDIAN);
		ByteArray2XSCM(&phTmp->xSCM, supportData, supportDataLength);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = 255;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwAuthenticateUID(SCARDHANDLE hCard, TUID uid, BYTE *supportData, TCOUNT supportDataLength) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(3);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		UINT82XSCM(&phTmp->xSCM, uid, TYPE_TYPED);
		ByteArray2XSCM(&phTmp->xSCM, supportData, supportDataLength);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwDeauthenticateName(SCARDHANDLE hCard, WCSTR principalName)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(4);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, principalName, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwDeauthenticateUID(SCARDHANDLE hCard, TUID uid) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(5);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		UINT82XSCM(&phTmp->xSCM, uid, TYPE_TYPED);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwIsAuthenticatedName(SCARDHANDLE hCard, WCSTR principalName)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(6);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, principalName, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwIsAuthenticatedUID(SCARDHANDLE hCard, TUID uid) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(7);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		UINT82XSCM(&phTmp->xSCM, uid, TYPE_TYPED);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwIsAuthorized(SCARDHANDLE hCard, WCSTR resourceName, BYTE operation) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(8);
		Lc(0);
//		UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
//		UINT82XSCM(&phTmp->xSCM, resourceType, TYPE_TYPED);
		String2XSCM(&phTmp->xSCM, resourceName, phTmp->dwFlags & FLAG_BIGENDIAN);
		UINT82XSCM(&phTmp->xSCM, operation, TYPE_TYPED);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

/*
** File System
*/

SCODE WINAPI hScwCreateFile(SCARDHANDLE hCard, WCSTR fileName, WCSTR aclFileName, HFILE *phFile) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(1);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		String2XSCM(&phTmp->xSCM, aclFileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		HFILEBYREF2XSCM(&phTmp->xSCM, phFile);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			if (phFile)
				*phFile = XSCM2HFILE(&phTmp->xSCM);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwDeleteFile(SCARDHANDLE hCard, WCSTR fileName) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(2);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwCloseFile(SCARDHANDLE hCard, HFILE hFile) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(4);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		HFILE2XSCM(&phTmp->xSCM, hFile);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE __hScwReadFile(SCARDHANDLE hCard, HFILE hFile, BYTE *buffer, TCOUNT length, TCOUNT *bytesRead)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(5);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
		HFILE2XSCM(&phTmp->xSCM, hFile);
		ByteArrayOut2XSCM(&phTmp->xSCM, buffer, length);
		UINT8BYREF2XSCM(&phTmp->xSCM, bytesRead);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			BYTE *_pbBuffer;
			UINT8 len;

			len = XSCM2ByteArray(&phTmp->xSCM, &_pbBuffer);
			*bytesRead = XSCM2UINT8(&phTmp->xSCM);
			memcpy(buffer, _pbBuffer, *bytesRead);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwReadFile32(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, DWORD nRequestedBytes, DWORD *pnActualBytes)
{
	SCODE ret;
	TCOUNT nNow, nOpt, nRead;
	DWORD nOverall = 0;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if ((phTmp == NULL) || (pnActualBytes == NULL))
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

			// v1.0 IN: #param | 8 | HFILE | a | L | 108 | Read / OUT: RC | L | Data | Read | SW (already deducted so max = bResLen-10)
			// v1.1 IN: #param | 8 | HFILE | a | L | 108 | Read / OUT: L | Data | Read | SW (already deducted so max = bResLen-9)
		if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
		{
			if (phTmp->bResLen < 10)
				RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		}
		else if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_1)
		{
			if (phTmp->bResLen < 9)
				RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		}
		else
			RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

		nOpt = phTmp->bResLen - 9;		// Biggest possible
		if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
			nOpt--;

		do
		{
			nNow = (TCOUNT)((nRequestedBytes - nOverall > nOpt) ? nOpt : nRequestedBytes - nOverall);

			ret = __hScwReadFile(hCard, hFile, pbBuffer+nOverall, nNow, &nRead);

			if (FAILED(ret))
				break;

			nOverall += nRead;
		} while ((nOverall < nRequestedBytes) && (nRead == nNow));

		if (!(FAILED(ret)))
			*pnActualBytes = nOverall;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwReadFile(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, TCOUNT nRequestedBytes, TCOUNT *pnActualBytes)
{
	DWORD cbActual;
	SCODE ret;

	if (IsBadWritePtr(pnActualBytes, 1))
		ret = hScwReadFile32(hCard, hFile, pbBuffer, (DWORD)nRequestedBytes, NULL);
	else
	{
		ret = hScwReadFile32(hCard, hFile, pbBuffer, (DWORD)nRequestedBytes, &cbActual);
		if (!FAILED(ret))
			*pnActualBytes = (TCOUNT)cbActual;
	}
	return ret;
}

SCODE __hScwWriteFile(SCARDHANDLE hCard, HFILE hFile, BYTE *buffer, TCOUNT length, TCOUNT *bytesWritten)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(6);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
		HFILE2XSCM(&phTmp->xSCM, hFile);
		ByteArray2XSCM(&phTmp->xSCM, buffer, length);
		UINT8BYREF2XSCM(&phTmp->xSCM, bytesWritten);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			*bytesWritten = XSCM2UINT8(&phTmp->xSCM);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwWriteFile32(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, DWORD nRequestedBytes, DWORD *pnActualBytes)
{
	SCODE ret;
	TCOUNT nNow, nOpt, nWritten;
	DWORD nOverall = 0;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if ((phTmp == NULL) || (pnActualBytes == NULL))
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

			// v1.0 IN: #param | 8 | HFILE | A | L | Data | 108 | Written / OUT: RC | Written | SW (already deducted so max = bResLen-9)
			// v1.1 IN: #param | 8 | HFILE | A | L | Data | 108 | Written / OUT: Written | SW (already deducted so max = bResLen-8)
		if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
		{
			if (phTmp->bResLen < 9)
				RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		}
		else if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_1)
		{
			if (phTmp->bResLen < 8)
				RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		}
		else
			RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

		nOpt = phTmp->bResLen - 8;		// Biggest possible
		if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
			nOpt--;

		do
		{
			nNow = (TCOUNT)((nRequestedBytes - nOverall > (TCOUNT)nOpt) ? nOpt : nRequestedBytes - nOverall);

			ret = __hScwWriteFile(hCard, hFile, pbBuffer+nOverall, nNow, &nWritten);

			if (FAILED(ret))
				break;

			nOverall += nWritten;
		} while ((nOverall < nRequestedBytes) && (nWritten == nNow));

		if (!(FAILED(ret)))
			*pnActualBytes = nOverall;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwWriteFile(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, TCOUNT nRequestedBytes, TCOUNT *pnActualBytes)
{
	DWORD cbActual;
	SCODE ret;

	if (IsBadWritePtr(pnActualBytes, 1))
		ret = hScwWriteFile32(hCard, hFile, pbBuffer, (DWORD)nRequestedBytes, NULL);
	else
	{
		ret = hScwWriteFile32(hCard, hFile, pbBuffer, (DWORD)nRequestedBytes, &cbActual);
		if (!FAILED(ret))
			*pnActualBytes = (TCOUNT)cbActual;
	}
	return ret;
}

SCODE WINAPI hScwGetFileLength(SCARDHANDLE hCard, HFILE hFile, TOFFSET *fileSize)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(7);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		HFILE2XSCM(&phTmp->xSCM, hFile);
		UINT16BYREF2XSCM(&phTmp->xSCM, fileSize, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			*fileSize = XSCM2UINT16(&phTmp->xSCM, phTmp->dwFlags & FLAG_BIGENDIAN);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwSetFileLength(SCARDHANDLE hCard, HFILE hFile, TOFFSET fileSize)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(8);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		HFILE2XSCM(&phTmp->xSCM, hFile);
		UINT162XSCM(&phTmp->xSCM, fileSize, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwSetFilePointer(SCARDHANDLE hCard, HFILE hFile, INT16 offset, BYTE mode)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(9);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
		HFILE2XSCM(&phTmp->xSCM, hFile);
		UINT162XSCM(&phTmp->xSCM, (UINT16)offset, phTmp->dwFlags & FLAG_BIGENDIAN);
		UINT82XSCM(&phTmp->xSCM, mode, TYPE_TYPED);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwGetFileAttributes(SCARDHANDLE hCard, WCSTR fileName, UINT16 *attributeValue) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(11);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		UINT16BYREF2XSCM(&phTmp->xSCM, attributeValue, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			*attributeValue = XSCM2UINT16(&phTmp->xSCM, phTmp->dwFlags & FLAG_BIGENDIAN);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwSetFileAttributes(SCARDHANDLE hCard, WCSTR fileName, UINT16 attributeValue) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(12);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		UINT162XSCM(&phTmp->xSCM, attributeValue, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwSetFileACL(SCARDHANDLE hCard, WCSTR fileName, WCSTR aclFileName)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(13);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		String2XSCM(&phTmp->xSCM, aclFileName, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwGetFileAclHandle(SCARDHANDLE hCard, WCSTR fileName, HFILE *phFile)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(14);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		HFILEBYREF2XSCM(&phTmp->xSCM, phFile);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			if (phFile)
				*phFile = XSCM2HFILE(&phTmp->xSCM);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwEnumFile(SCARDHANDLE hCard, WCSTR directoryName, UINT16 *fileCookie, WSTR fileName, TCOUNT fileNameLength) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(15);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, directoryName, phTmp->dwFlags & FLAG_BIGENDIAN);
		UINT16BYREF2XSCM(&phTmp->xSCM, fileCookie, phTmp->dwFlags & FLAG_BIGENDIAN);
		StringOut2XSCM(&phTmp->xSCM, fileName, fileNameLength, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			WCSTR wsz;
			UINT8 len;

			*fileCookie = XSCM2UINT16(&phTmp->xSCM, phTmp->dwFlags & FLAG_BIGENDIAN);
			wsz = XSCM2String(&phTmp->xSCM, &len, phTmp->dwFlags & FLAG_BIGENDIAN);
			if (len > fileNameLength)
				ret = SCW_E_BUFFERTOOSMALL;
			else
				wcscpy(fileName, wsz);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwCreateDirectory(SCARDHANDLE hCard, WCSTR fileName, WCSTR aclFileName) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(16);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		String2XSCM(&phTmp->xSCM, aclFileName, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwSetDispatchTable(SCARDHANDLE hCard, WCSTR wszFileName)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(17);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, wszFileName, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}


/*
** Cryptography
*/

SCODE WINAPI hScwCryptoInitialize(SCARDHANDLE hCard, BYTE mechanism, BYTE *key)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	TCOUNT len = 0;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(5);
		P2(1);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		UINT82XSCM(&phTmp->xSCM, mechanism, TYPE_TYPED);

		if (key)
			len = 2 + key[1];	// T+L+V
		ByteArray2XSCM(&phTmp->xSCM, key, len);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			phTmp->byCryptoM = mechanism;		// Store the last mechanism for 1024 hack
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwCryptoAction(SCARDHANDLE hCard, BYTE *dataIn, TCOUNT dataInLength, BYTE *dataOut, TCOUNT *dataOutLength)
{
	BOOL fHack = FALSE;
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		if ((((phTmp->byCryptoM & CM_CRYPTO_NAME) == CM_RSA) || ((phTmp->byCryptoM & CM_CRYPTO_NAME) == CM_RSA_CRT)) &&
			((phTmp->byCryptoM & CM_DATA_INFILE) != CM_DATA_INFILE))
		{								// Hack for 1024 RSA
			P1(0xFE);
			P2(0);
			Lc(0);
			ByteArray2XSCM(&phTmp->xSCM, dataIn, dataInLength);
			if (dataOutLength == NULL)
				RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);
			abCAPDU[5] = *dataOutLength;
			fHack = TRUE;
		}
		else
		{
			P1(5);
			P2(2);
			Lc(0);
			UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
			ByteArray2XSCM(&phTmp->xSCM, dataIn, dataInLength);
			ByteArrayOut2XSCM(&phTmp->xSCM, dataOut, (TCOUNT)(dataOutLength == 0 ? 0 : *dataOutLength));
			UINT8BYREF2XSCM(&phTmp->xSCM, dataOutLength);
		}

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			BYTE *pb;
			TCOUNT len;

			len = XSCM2ByteArray(&phTmp->xSCM, &pb);
			if (len > *dataOutLength)
				ret = SCW_E_BUFFERTOOSMALL;
			else
			{
				memcpy(dataOut, pb, len);
				if (fHack)
					*dataOutLength = len;
				else
					*dataOutLength = XSCM2UINT8(&phTmp->xSCM);
			}
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwCryptoUpdate(SCARDHANDLE hCard, BYTE *dataIn, TCOUNT dataInLength)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(5);
		P2(3);
		Lc(0);
 		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		ByteArray2XSCM(&phTmp->xSCM, dataIn, dataInLength);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwCryptoFinalize(SCARDHANDLE hCard, BYTE *dataOut, TCOUNT *dataOutLength)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(5);
		P2(4);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		ByteArrayOut2XSCM(&phTmp->xSCM, dataOut, (TCOUNT)(dataOutLength == 0 ? 0 : *dataOutLength));
		UINT8BYREF2XSCM(&phTmp->xSCM, dataOutLength);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			BYTE *pb;
			TCOUNT len;

			len = XSCM2ByteArray(&phTmp->xSCM, &pb);
			if (len > *dataOutLength)
				ret = SCW_E_BUFFERTOOSMALL;
			else
			{
				memcpy(dataOut, pb, len);
				*dataOutLength = XSCM2UINT8(&phTmp->xSCM);
			}
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwGenerateRandom(SCARDHANDLE hCard, BYTE *dataOut, TCOUNT dataOutLength)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(5);
		P2(5);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		ByteArrayOut2XSCM(&phTmp->xSCM, dataOut, dataOutLength);
		UINT8BYREF2XSCM(&phTmp->xSCM, &dataOutLength);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			BYTE *pb;
			TCOUNT len;

			len = XSCM2ByteArray(&phTmp->xSCM, &pb);
			if (len != dataOutLength)
				ret = SCW_E_BUFFERTOOSMALL;
			else
				memcpy(dataOut, pb, len);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

 
/*
** Runtime Environment
*/

SCODE WINAPI hScwRTEExecute(SCARDHANDLE hCard, WCSTR wszCodeFileName, WCSTR wszDataFileName, UINT8 bRestart)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(1);
		P2(1);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, wszCodeFileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		String2XSCM(&phTmp->xSCM, wszDataFileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		UINT82XSCM(&phTmp->xSCM, bRestart, TYPE_TYPED);

        // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}


/*
	ScwExecute:
		I-:	lpxHdr (points to 4 bytes (CLA, INS, P1, P2))
		I-: InBuf (Incoming data from card's perspective (NULL -> no data in))
		I-: InBufLen (length of data pointed by InBuf)
		-O: OutBuf (Buffer that will receive the R-APDU (NULL -> no expected data))
		IO: pOutBufLen (I -> Size of OutBuf, O -> Number of bytes written in OutBuf)
		-O: pwSW (Card Status Word)
*/
SCODE WINAPI hScwExecute(SCARDHANDLE hCard, LPISO_HEADER lpxHdr, BYTE *InBuf, TCOUNT InBufLen, BYTE *OutBuf, TCOUNT *pOutBufLen, UINT16 *pwSW)
{
    SCODE ret;
    DWORD dwIn, dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	__try {

		if ((lpxHdr == NULL) || (pwSW == NULL) || ((OutBuf != NULL) && (pOutBufLen == NULL)))
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		abCAPDU[0] = lpxHdr->CLA;
		abCAPDU[1] = lpxHdr->INS;
		abCAPDU[2] = lpxHdr->P1;
		abCAPDU[3] = lpxHdr->P2;
		if ((InBuf != NULL) && (InBufLen != 0))
		{
			abCAPDU[4] = (BYTE)InBufLen;
			memcpy(abCAPDU+5, InBuf, InBufLen);
			dwIn = 5 + InBufLen;

			// We don't care about out data yet
		}
		else
		{	// No in data. How much data out then?

			dwIn = 5;
			if (OutBuf == NULL)		// No data out either
			{
				abCAPDU[4] = 0;
				if (phTmp->dwProtocol == SCARD_PROTOCOL_T0)
					dwIn = 4;		// To indicate a case 1 command
			}
			else
				abCAPDU[4] = (BYTE)(*pOutBufLen);
		}

        // API transfer
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, dwIn, abRAPDU, &dwOut);

        if (dwRet == 0)
        {
			if (dwOut < 2)
				ret = SCARD_F_INTERNAL_ERROR;
			else
			{
				*pwSW = MAKEWORD(abRAPDU[dwOut-1], abRAPDU[dwOut-2]);
				dwOut -= 2;

				ret = 0;
				if (OutBuf != NULL)
				{
					if (dwOut <= (DWORD)(*pOutBufLen))
					{
						memcpy(OutBuf, abRAPDU, dwOut);
						*pOutBufLen = (TCOUNT)dwOut;
					}
					else
						ret = SCW_E_BUFFERTOOSMALL;
				}
			}
        }
        else
            ret = (SCODE)dwRet;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

static SCODE ExtractSCODE(LPMYSCARDHANDLE phTmp, LPCBYTE abRAPDU, DWORD dwOut)
{
	if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
	{
		if ((dwOut < 2) || (abRAPDU[dwOut-2] != 0x90) || (abRAPDU[dwOut-1] != 0x00))
			RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

		InitXSCM(phTmp, abRAPDU, (WORD)(dwOut-2));	// Doesn't take SW into account
		return XSCM2SCODE(&phTmp->xSCM);
	}
	else if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_1)
	{
		if ((dwOut < 2) || (abRAPDU[dwOut-2] != 0x90))
			RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

		InitXSCM(phTmp, abRAPDU, (WORD)(dwOut-2));	// Doesn't take SW into account
		return MAKESCODE(abRAPDU[dwOut-1]);
	}
	else
		RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

	return SCW_S_OK;	// to please the compiler
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\logscard.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    LogSCard

Abstract:

    This module implements the logging of SCardxxx APIs & structures.

Author:

    Eric Perlin (ericperl) 05/31/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <tchar.h>
#include <winscard.h>

#include "Log.h"

typedef struct {
    DWORD dwValue;
    LPCTSTR szValue;
} ValueMap;
#define MAP(x) { x, _T(#x) }

static const ValueMap rgMapState[] = {
    MAP(SCARD_STATE_UNAWARE),
    MAP(SCARD_STATE_IGNORE),
    MAP(SCARD_STATE_CHANGED),
    MAP(SCARD_STATE_UNKNOWN),
    MAP(SCARD_STATE_UNAVAILABLE),
    MAP(SCARD_STATE_EMPTY),
    MAP(SCARD_STATE_PRESENT),
    MAP(SCARD_STATE_ATRMATCH),
    MAP(SCARD_STATE_EXCLUSIVE),
    MAP(SCARD_STATE_INUSE),
    MAP(SCARD_STATE_MUTE),
    MAP(SCARD_STATE_UNPOWERED),
    { 0, NULL } };

static const ValueMap rgMapProtocol[] = {
    MAP(SCARD_PROTOCOL_T0),
    MAP(SCARD_PROTOCOL_T1),
    MAP(SCARD_PROTOCOL_UNDEFINED),
    { 0, NULL } };

static const ValueMap rgMapAttrib[] = {
    MAP(SCARD_ATTR_VENDOR_NAME),
    MAP(SCARD_ATTR_VENDOR_IFD_TYPE),
    MAP(SCARD_ATTR_VENDOR_IFD_VERSION),
    MAP(SCARD_ATTR_VENDOR_IFD_SERIAL_NO),
    MAP(SCARD_ATTR_CHANNEL_ID),
    MAP(SCARD_ATTR_PROTOCOL_TYPES),
    MAP(SCARD_ATTR_DEFAULT_CLK),
    MAP(SCARD_ATTR_MAX_CLK),
    MAP(SCARD_ATTR_DEFAULT_DATA_RATE),
    MAP(SCARD_ATTR_MAX_DATA_RATE),
    MAP(SCARD_ATTR_MAX_IFSD),
    MAP(SCARD_ATTR_POWER_MGMT_SUPPORT),
    MAP(SCARD_ATTR_USER_TO_CARD_AUTH_DEVICE),
    MAP(SCARD_ATTR_USER_AUTH_INPUT_DEVICE),
    MAP(SCARD_ATTR_CHARACTERISTICS),

    MAP(SCARD_ATTR_CURRENT_PROTOCOL_TYPE),
    MAP(SCARD_ATTR_CURRENT_CLK),
    MAP(SCARD_ATTR_CURRENT_F),
    MAP(SCARD_ATTR_CURRENT_D),
    MAP(SCARD_ATTR_CURRENT_N),
    MAP(SCARD_ATTR_CURRENT_W),
    MAP(SCARD_ATTR_CURRENT_IFSC),
    MAP(SCARD_ATTR_CURRENT_IFSD),
    MAP(SCARD_ATTR_CURRENT_BWT),
    MAP(SCARD_ATTR_CURRENT_CWT),
    MAP(SCARD_ATTR_CURRENT_EBC_ENCODING),
    MAP(SCARD_ATTR_EXTENDED_BWT),

    MAP(SCARD_ATTR_ICC_PRESENCE),
    MAP(SCARD_ATTR_ICC_INTERFACE_STATUS),
    MAP(SCARD_ATTR_CURRENT_IO_STATE),
    MAP(SCARD_ATTR_ATR_STRING),
    MAP(SCARD_ATTR_ICC_TYPE_PER_ATR),

    MAP(SCARD_ATTR_ESC_RESET),
    MAP(SCARD_ATTR_ESC_CANCEL),
    MAP(SCARD_ATTR_ESC_AUTHREQUEST),
    MAP(SCARD_ATTR_MAXINPUT),

    MAP(SCARD_ATTR_DEVICE_UNIT),
    MAP(SCARD_ATTR_DEVICE_IN_USE),
    MAP(SCARD_ATTR_DEVICE_FRIENDLY_NAME_A),
    MAP(SCARD_ATTR_DEVICE_SYSTEM_NAME_A),
    MAP(SCARD_ATTR_DEVICE_FRIENDLY_NAME_W),
    MAP(SCARD_ATTR_DEVICE_SYSTEM_NAME_W),
    MAP(SCARD_ATTR_SUPRESS_T1_IFS_REQUEST),

    { 0, NULL } };

/*++

LogSCardContext:

    Logs a SCARDCONTEXT.

Arguments:
    hContext is the SCARDCONTEXT to be displayed

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 06/19/2000

--*/
void LogSCardContext(
    IN PLOGCONTEXT pLogCtx,
    IN SCARDCONTEXT hContext
    )
{
    LogPtr(pLogCtx, (LPCVOID)hContext, _T("SCARDCONTEXT:   "));
}

/*++

LogSCardHandle:

    Logs a SCARDHANDLE.

Arguments:
    hCard is the SCARDHANDLE to be displayed

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/14/2000

--*/
void LogSCardHandle(
    IN PLOGCONTEXT pLogCtx,
    IN SCARDHANDLE hCard
    )
{
    LogPtr(pLogCtx, (LPCVOID)hCard, _T("SCARDHANDLE:    "));
}

/*++

LogSCardReaderState:

    Outputs a reader state.

Arguments:
    szHeader supplies a header
    dwRS is the state to be displayed

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 06/01/2000

--*/
void LogSCardReaderState(
    IN PLOGCONTEXT pLogCtx,
    IN LPCTSTR szHeader,
    IN DWORD dwRS
    )
{
    DWORD dwIndex;

    LogString(pLogCtx, szHeader);
	LogDWORD(pLogCtx, dwRS);
    LogDecimal(pLogCtx, (DWORD)(dwRS >> 16), _T(" -> Event #= "));
	LogString(pLogCtx, _T("                "));
    dwRS &= 0x0000FFFF;
    if (rgMapState[0].dwValue == dwRS)
    {
        LogString(pLogCtx, rgMapState[0].szValue, _T(" "));
    }
    else
    {
        for (dwIndex = 1 ; NULL != rgMapState[dwIndex].szValue ; dwIndex++)
        {
            if ((dwRS & rgMapState[dwIndex].dwValue) == rgMapState[dwIndex].dwValue)
            {       // We have a match
		        LogString(pLogCtx, rgMapState[dwIndex].szValue);
				LogString(pLogCtx, _T(" "));
                dwRS &= ~rgMapState[dwIndex].dwValue;    // Get rid of this bit
            }
            if (dwRS == 0)
                break;
        }

        if (0 != dwRS)  // Unrecognized bits
        {
            LogDWORD(pLogCtx, dwRS);
        }
        LogString(pLogCtx, _T("\n"));
    }
}

/*++

LogConnectShareMode:

    Outputs a share mode.

Arguments:
    szHeader supplies a header
    dwShareMode is the mode to be displayed

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 06/23/2000

--*/
void LogConnectShareMode(
    IN PLOGCONTEXT pLogCtx,
    IN LPCTSTR szHeader,
    IN DWORD dwShareMode
	)
{
	if (SCARD_SHARE_SHARED == dwShareMode)
	{
	    LogString(pLogCtx, szHeader, _T("SCARD_SHARE_SHARED"));
	}
	else if (SCARD_SHARE_EXCLUSIVE == dwShareMode)
	{
	    LogString(pLogCtx, szHeader, _T("SCARD_SHARE_EXCLUSIVE"));
	}
	else if (SCARD_SHARE_DIRECT == dwShareMode)
	{
	    LogString(pLogCtx, szHeader, _T("SCARD_SHARE_DIRECT"));
	}
	else
	{
		LogString(pLogCtx, szHeader);
	    LogDWORD(pLogCtx, dwShareMode, _T("Unrecognized share mode: "));
	}
}

/*++

LogDisposition:

    Outputs a disposition.

Arguments:
    szHeader supplies a header
    dwShareMode is the disposition to be displayed

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/14/2000

--*/
void LogDisposition(
    IN PLOGCONTEXT pLogCtx, 
    IN LPCTSTR szHeader,
    IN DWORD dwDisposition
	)
{
	if (SCARD_LEAVE_CARD == dwDisposition)
	{
	    LogString(pLogCtx, szHeader, _T("SCARD_LEAVE_CARD"));
	}
	else if (SCARD_RESET_CARD == dwDisposition)
	{
	    LogString(pLogCtx, szHeader, _T("SCARD_RESET_CARD"));
	}
	else if (SCARD_UNPOWER_CARD == dwDisposition)
	{
	    LogString(pLogCtx, szHeader, _T("SCARD_UNPOWER_CARD"));
	}
	else if (SCARD_EJECT_CARD == dwDisposition)
	{
	    LogString(pLogCtx, szHeader, _T("SCARD_EJECT_CARD"));
	}
	else
	{
	    LogString(pLogCtx, szHeader);
	    LogDWORD(pLogCtx, dwDisposition, _T("Unrecognized disposition: "));
	}
}

/*++

LogSCardProtocol:

    Outputs a protocol.

Arguments:
    szHeader supplies a header
    dwProtocol is the protocol to be displayed

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 06/23/2000

--*/
void LogSCardProtocol(
    IN PLOGCONTEXT pLogCtx, 
    IN LPCTSTR szHeader,
    IN DWORD dwProtocol
    )
{
    DWORD dwIndex;

    if (0 == dwProtocol)
    {
        LogDWORD(pLogCtx, dwProtocol, szHeader);
    }
    else
    {
	    LogString(pLogCtx, szHeader);
        for (dwIndex = 0 ; NULL != rgMapProtocol[dwIndex].szValue ; dwIndex++)
        {
            if ((dwProtocol & rgMapProtocol[dwIndex].dwValue) == rgMapProtocol[dwIndex].dwValue)
            {       // We have a match
                LogString(pLogCtx, rgMapProtocol[dwIndex].szValue);
				LogString(pLogCtx, _T(" "));
                dwProtocol &= ~rgMapProtocol[dwIndex].dwValue;    // Get rid of this bit
            }
            if (dwProtocol == 0)
                break;
        }

		if (0 != dwProtocol)  // Unrecognized bits
		{
			LogDWORD(pLogCtx, dwProtocol);
		}
		LogString(pLogCtx, _T("\n"));
    }
}

/*++

LogSCardAttrib:

    Outputs an attribute.

Arguments:
    szHeader supplies a header
    dwAttrib is the attribute to be displayed

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 10/11/2000

--*/
void LogSCardAttrib(
    IN PLOGCONTEXT pLogCtx, 
    IN LPCTSTR szHeader,
    IN DWORD dwAttrib
    )
{
    DWORD dwIndex;

    if (0 == dwAttrib)
    {
        LogDWORD(pLogCtx, dwAttrib, szHeader);
    }
    else
    {
	    LogString(pLogCtx, szHeader);
        for (dwIndex = 0 ; NULL != rgMapAttrib[dwIndex].szValue ; dwIndex++)
        {
            if (dwAttrib == rgMapAttrib[dwIndex].dwValue)
            {       // We have a match
                LogString(pLogCtx, rgMapAttrib[dwIndex].szValue);
                break;
            }
        }

        if (NULL == rgMapAttrib[dwIndex].szValue)
        {
            LogString(pLogCtx, _T("Unknown Attribute"));
        }

		LogString(pLogCtx, _T("\n"));
    }
}

/*++

LogSCardGetStatusChange:

    Calls SCardGetStatusChange and displays the parameters.

Arguments:

    cf SCardGetStatusChange
	lExpected is the expected result

Return Value:

    cf SCardGetStatusChange

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/

LONG LogSCardGetStatusChange(
  IN SCARDCONTEXT hContext,
  IN DWORD dwTimeout,
  IN OUT LPSCARD_READERSTATE rgReaderStates,
  IN DWORD cReaders,
  IN LONG lExpected
)
{
    LONG lRes;
    DWORD dw;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

    lRes = SCardGetStatusChange(
        hContext,
        dwTimeout,
        rgReaderStates,
        cReaders
        );

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardGetStatusChange"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx, hContext);

	LogDecimal(pLogCtx, dwTimeout, _T("Timeout:        "));

    for (dw = 0 ; dw < cReaders ; dw++)
    {
		LogString(pLogCtx, _T("Reader"));
		LogDecimal(pLogCtx, dw);
		if (IsBadReadPtr(rgReaderStates+dw, sizeof(SCARD_READERSTATE)))
		{
			LogPtr(pLogCtx, rgReaderStates+dw, _T(" state has invalid address "));
		}
		else
		{
			LogString(pLogCtx, _T(": "), rgReaderStates[dw].szReader);
			LogSCardReaderState(pLogCtx, _T("Current:        "), rgReaderStates[dw].dwCurrentState);
			LogSCardReaderState(pLogCtx, _T("Event  :        "), rgReaderStates[dw].dwEventState);
		}
    }

    LogDWORD(pLogCtx, cReaders, _T("# of readers:   "));

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardEstablishContext:

    Calls SCardEstablishContext and displays the parameters.

Arguments:

    cf SCardEstablishContext
	lExpected is the expected result

Return Value:

    cf SCardEstablishContext

Author:

    Eric Perlin (ericperl) 06/22/2000

--*/
LONG LogSCardEstablishContext(
    IN  DWORD dwScope,
    IN  LPCVOID pvReserved1,
    IN  LPCVOID pvReserved2,
    OUT LPSCARDCONTEXT phContext,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardEstablishContext(
		dwScope,
		pvReserved1,
		pvReserved2,
		phContext
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardEstablishContext"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	if (dwScope == SCARD_SCOPE_USER)
	{
		LogString(pLogCtx, _T("Scope:          "), _T("SCARD_SCOPE_USER"));
	}
	else if (dwScope == SCARD_SCOPE_SYSTEM)
	{
		LogString(pLogCtx, _T("Scope:          "), _T("SCARD_SCOPE_SYSTEM"));
	}
	else
	{
		LogDWORD(pLogCtx, dwScope, _T("Unknown Scope:  "));
	}

    LogPtr(pLogCtx, pvReserved1, _T("Reserved1:      "));
    LogPtr(pLogCtx, pvReserved2, _T("Reserved2:      "));

	if (IsBadReadPtr(phContext, sizeof(SCARDCONTEXT)))
	{
		LogPtr(pLogCtx, phContext, _T("LPSCARDCONTEXT is invalid: "));
	}
	else
	{
		LogSCardContext(pLogCtx ,*phContext);
	}

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardListReaders:

    Calls SCardListReaders and displays the parameters.

Arguments:

    cf SCardListReaders
	lExpected is the expected result

Return Value:

    cf SCardListReaders

Author:

    Eric Perlin (ericperl) 06/22/2000

--*/
LONG LogSCardListReaders(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR mszGroups,
	OUT LPTSTR mszReaders,
	IN OUT LPDWORD pcchReaders,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;
	DWORD cchSave = 0;

	GetLocalTime(&xSST);


	if (!IsBadReadPtr(pcchReaders, sizeof(DWORD)))
	{
		cchSave = *pcchReaders;
	}

	lRes= SCardListReaders(
		hContext,
		mszGroups,
		mszReaders,
		pcchReaders
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardListReaders"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	if (NULL == mszGroups)
	{
	    LogString(pLogCtx, _T("mszGroups is NULL, all readers are listed\n"));
	}
	else
	{
		LogMultiString(
            pLogCtx, 
			mszGroups,
			_T("Groups:         ")
		);
	}

	if (FAILED(lRes))
	{
	    LogPtr(pLogCtx, mszReaders, _T("mszReaders:     "));
	    LogPtr(pLogCtx, pcchReaders, _T("pcchReaders:    "));
		if (!IsBadReadPtr(pcchReaders, sizeof(DWORD)))
		{
			if (SCARD_AUTOALLOCATE == *pcchReaders)
			{
				LogString(pLogCtx, _T("*pcchReaders:   SCARD_AUTOALLOCATE\n"));
			}
			else
			{
				LogDWORD(pLogCtx, *pcchReaders, _T("*pcchReaders:   "));
			}
		}
		else
		{
			LogPtr(pLogCtx, pcchReaders, _T("pcchReaders:   (Invalid address) "));
		}
	}
	else
	{
		if (SCARD_AUTOALLOCATE == cchSave)
		{
			LogMultiString(
                pLogCtx, 
				*((TCHAR **)mszReaders),
				_T("Readers (allocated): ")
			);
		}
		else
		{
			LogMultiString(
                pLogCtx, 
				mszReaders,
				_T("Readers: ")
			);
		}
		LogDWORD(pLogCtx, *pcchReaders, _T("*pcchReaders:   "));
	}

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardFreeMemory:

    Calls SCardFreeMemory and displays the parameters.

Arguments:

    cf SCardFreeMemory
	lExpected is the expected result

Return Value:

    cf SCardFreeMemory

Author:

    Eric Perlin (ericperl) 06/23/2000

--*/
LONG LogSCardFreeMemory(
	IN SCARDCONTEXT hContext,  
	IN LPCVOID pvMem,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardFreeMemory(
		hContext,  
		pvMem
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardFreeMemory"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogPtr(pLogCtx, pvMem, _T("pvMem:          "));

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}


/*++

LogSCardReleaseContext:

    Calls SCardReleaseContext and displays the parameters.

Arguments:

    cf SCardReleaseContext
	lExpected is the expected result

Return Value:

    cf SCardReleaseContext

Author:

    Eric Perlin (ericperl) 06/23/2000

--*/
LONG LogSCardReleaseContext(
	IN SCARDCONTEXT hContext,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardReleaseContext(
		hContext
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardReleaseContext"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}


/*++

LogSCardUIDlgSelectCard:

    Calls SCardUIDlgSelectCard and displays the parameters.

Arguments:

    cf SCardUIDlgSelectCard
	lExpected is the expected result

Return Value:

    cf SCardUIDlgSelectCard

Author:

    Eric Perlin (ericperl) 06/23/2000

--*/
LONG LogSCardUIDlgSelectCard(
  IN LPOPENCARDNAME_EX pDlgStruc,
  IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardUIDlgSelectCard(
		pDlgStruc
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardUIDlgSelectCard"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogPtr(pLogCtx, pDlgStruc, _T("Ptr dlg struct: "));

	if (!IsBadReadPtr(pDlgStruc, sizeof(OPENCARDNAME_EX)))
	{
		LogDecimal(pLogCtx, pDlgStruc->dwStructSize, _T("Struct size:    "));
		LogSCardContext(pLogCtx ,pDlgStruc->hSCardContext);
		LogPtr(pLogCtx, pDlgStruc->hwndOwner, _T("HWND of Owner:  "));
		if (SC_DLG_MINIMAL_UI == pDlgStruc->dwFlags)
		{
			LogString(pLogCtx, _T("Flags:          "), _T("SC_DLG_MINIMAL_UI"));
		}
		else if (SC_DLG_NO_UI == pDlgStruc->dwFlags)
		{
			LogString(pLogCtx, _T("Flags:          "), _T("SC_DLG_NO_UI"));
		}
		else if (SC_DLG_FORCE_UI == pDlgStruc->dwFlags)
		{
			LogString(pLogCtx, _T("Flags:          "), _T("SC_DLG_FORCE_UI"));
		}
		else
		{
			LogDWORD(pLogCtx, pDlgStruc->dwFlags, _T("Flags???????:   "));
		}

		LogString(pLogCtx, _T("Title:          "), pDlgStruc->lpstrTitle);

		LogString(pLogCtx, _T("Search Descr.:  "), pDlgStruc->lpstrSearchDesc);
		 
		LogPtr(pLogCtx, pDlgStruc->hIcon, _T("Icon:           "));
		LogPtr(pLogCtx, pDlgStruc->pOpenCardSearchCriteria, _T("Ptr OCSC struct "));

		if (NULL != pDlgStruc->pOpenCardSearchCriteria)
		{
			LogDecimal(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->dwStructSize, _T("    Struct size:    "));

			if (NULL == pDlgStruc->pOpenCardSearchCriteria->lpstrGroupNames)
			{
				LogString(pLogCtx, _T("    Group names is NULL, all readers can be used\n"));
			}
			else
			{
				LogMultiString(
                    pLogCtx, 
					pDlgStruc->pOpenCardSearchCriteria->lpstrGroupNames,
					_T("    Group names:    ")
				);
			}
			LogDecimal(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->nMaxGroupNames, _T("    Max GroupNames: "));

			LogPtr(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->rgguidInterfaces, _T("    Ptr to GUID(s): "));
			LogDecimal(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->cguidInterfaces, _T("    # of GUIDs:     "));

			if (NULL == pDlgStruc->pOpenCardSearchCriteria->lpstrCardNames)
			{
				LogString(pLogCtx, _T("    CardNames is NULL, any card can be selected\n"));
			}
			else
			{
				LogMultiString(
                    pLogCtx, 
					pDlgStruc->pOpenCardSearchCriteria->lpstrCardNames,
					_T("    Card names:     ")
				);
			}
			LogDecimal(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->nMaxCardNames, _T("    Max Card names: "));
			 
			LogPtr(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->lpfnCheck, _T("    lpfnCheck:      "));
			LogPtr(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->lpfnConnect, _T("    lpfnConnect:    "));
			LogPtr(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->lpfnDisconnect, _T("    lpfnDisconnect: "));
			LogPtr(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->pvUserData, _T("    pvUserData:     "));

			LogConnectShareMode(pLogCtx, _T("    Share Mode:     "), pDlgStruc->pOpenCardSearchCriteria->dwShareMode);
			LogSCardProtocol(pLogCtx, _T("    Pref Protocols: "), pDlgStruc->pOpenCardSearchCriteria->dwPreferredProtocols);
		}

		LogPtr(pLogCtx, pDlgStruc->lpfnConnect, _T("lpfnConnect:    "));
		LogPtr(pLogCtx, pDlgStruc->pvUserData, _T("pvUserData:     "));
		LogConnectShareMode(pLogCtx, _T("Share Mode:     "), pDlgStruc->dwShareMode);
		LogSCardProtocol(pLogCtx, _T("Pref Protocols: "), pDlgStruc->dwPreferredProtocols);

		LogPtr(pLogCtx, pDlgStruc->lpstrRdr, _T("Reader:         "));
		if (SCARD_S_SUCCESS == lRes)
		{
			LogString(pLogCtx, _T(" ->             "), pDlgStruc->lpstrRdr);
		}
		LogDecimal(pLogCtx, pDlgStruc->nMaxRdr, _T("Max #ch in rdr: "));

		LogPtr(pLogCtx, pDlgStruc->lpstrCard, _T("Card:           "));
		if (SCARD_S_SUCCESS == lRes)
		{
			LogString(pLogCtx, _T(" ->             "), pDlgStruc->lpstrCard);
		}
		LogDecimal(pLogCtx, pDlgStruc->nMaxCard, _T("Max #ch in card "));

		LogSCardProtocol(pLogCtx, _T("Active Protocol "), pDlgStruc->dwActiveProtocol);
		 
		LogSCardHandle(pLogCtx, pDlgStruc->hCardHandle);
	}
 
	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardListCards:

    Calls SCardListCards and displays the parameters.

Arguments:

    cf SCardListCards
	lExpected is the expected result

Return Value:

    cf SCardListCards

Author:

    Eric Perlin (ericperl) 07/13/2000

--*/
LONG LogSCardListCards(
	IN SCARDCONTEXT hContext,
	IN LPCBYTE pbAtr,
	IN LPCGUID rgguidInterfaces,
	IN DWORD cguidInterfaceCount,
	OUT LPTSTR mszCards,
	IN OUT LPDWORD pcchCards,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;
	DWORD cchSave = 0;

	GetLocalTime(&xSST);

	if (!IsBadReadPtr(pcchCards, sizeof(DWORD)))
	{
		cchSave = *pcchCards;
	}

	lRes = SCardListCards(
		hContext,  
		pbAtr,
		rgguidInterfaces,
		cguidInterfaceCount,
		mszCards,
		pcchCards
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardListCards"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogPtr(pLogCtx, pbAtr, _T("Atr:            "));
	// TODO, ATR parsing

	LogPtr(pLogCtx, rgguidInterfaces, _T("Ptr to GUID(s): "));
	LogDWORD(pLogCtx, cguidInterfaceCount, _T("# of GUIDs:     "));

	if (FAILED(lRes))
	{
	    LogPtr(pLogCtx, mszCards, _T("Ptr card names: "));
		if (!IsBadReadPtr(pcchCards, sizeof(DWORD)))
		{
			if (SCARD_AUTOALLOCATE == *pcchCards)
			{
				LogString(pLogCtx, _T("# of chars:     "), _T("SCARD_AUTOALLOCATE"));
			}
			else
			{
				LogDWORD(pLogCtx, *pcchCards, _T("# of chars:     "));
			}
		}
		else
		{
			LogPtr(pLogCtx, pcchCards, _T("Ptr to # chars: (Invalid address) "));
		}
	}
	else
	{
		if (SCARD_AUTOALLOCATE == cchSave)
		{
			LogMultiString(
                pLogCtx, 
				*((TCHAR **)mszCards),
				_T("Cards (allocated): ")
			);
		}
		else
		{
			LogMultiString(
                pLogCtx, 
				mszCards,
				_T("Cards: ")
			);
		}
		LogDWORD(pLogCtx, *pcchCards, _T("# of chars:     "));
	}

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardIntroduceCardType:

    Calls SCardIntroduceCardType and displays the parameters.

Arguments:

    cf SCardIntroduceCardType
	lExpected is the expected result

Return Value:

    cf SCardIntroduceCardType

Author:

    Eric Perlin (ericperl) 06/23/2000

--*/
LONG LogSCardIntroduceCardType(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szCardName,
	IN LPCGUID pguidPrimaryProvider,
	IN LPCGUID rgguidInterfaces,
	IN DWORD dwInterfaceCount,
	IN LPCBYTE pbAtr,
	IN LPCBYTE pbAtrMask,
	IN DWORD cbAtrLen,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardIntroduceCardType(
		hContext,  
		szCardName,
		pguidPrimaryProvider,
		rgguidInterfaces,
		dwInterfaceCount,
		pbAtr,
		pbAtrMask,
		cbAtrLen
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardIntroduceCardType"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("szCardName:     "), szCardName);

	LogPtr(pLogCtx, pguidPrimaryProvider, _T("pguidPrimProv:  "));
	LogPtr(pLogCtx, rgguidInterfaces, _T("rgguidInterf.:  "));
	LogDWORD(pLogCtx, dwInterfaceCount, _T("dwInterfCount:  "));

	LogBinaryData(pLogCtx, pbAtr, cbAtrLen, _T("pbAtr:          "));
	LogBinaryData(pLogCtx, pbAtrMask, cbAtrLen, _T("pbAtrMask:      "));

	LogDecimal(pLogCtx, cbAtrLen, _T("cbAtrLen:       "));

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardForgetCardType:

    Calls SCardForgetCardType and displays the parameters.

Arguments:

    cf SCardForgetCardType
	lExpected is the expected result

Return Value:

    cf SCardForgetCardType

Author:

    Eric Perlin (ericperl) 07/14/2000

--*/
LONG LogSCardForgetCardType(
	IN SCARDCONTEXT hContext,  
	IN LPCTSTR szCardName,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardForgetCardType(
		hContext,
		szCardName
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardForgetCardType"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("szCardName:     "), szCardName);
  
	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardConnect:

    Calls SCardConnect and displays the parameters.

Arguments:

    cf SCardConnect
	lExpected is the expected result

Return Value:

    cf SCardConnect

Author:

    Eric Perlin (ericperl) 07/17/2000

--*/
LONG LogSCardConnect(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szReader,
	IN DWORD dwShareMode,
	IN DWORD dwPreferredProtocols,
	OUT LPSCARDHANDLE phCard,
	OUT LPDWORD pdwActiveProtocol,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardConnect(
		hContext,  
		szReader,
		dwShareMode,
		dwPreferredProtocols,
		phCard,
		pdwActiveProtocol
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardConnect"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("Reader:         "), szReader);

	LogConnectShareMode(pLogCtx, _T("ShareMode:      "), dwShareMode);

	LogSCardProtocol(pLogCtx, _T("PrefProtocols:  "), dwPreferredProtocols);

	if (IsBadReadPtr(phCard, sizeof(SCARDHANDLE)))
	{
	    LogPtr(pLogCtx, phCard, _T("LPSCARDHANDLE:  (Invalid address) "));
	}
	else
	{
		LogSCardHandle(pLogCtx, *phCard);
	}

	if (IsBadReadPtr(pdwActiveProtocol, sizeof(DWORD)))
	{
	    LogPtr(pLogCtx, pdwActiveProtocol, _T("&ActivProtocol: (Invalid address) "));
	}
	else
	{
		LogSCardProtocol(pLogCtx, _T("ActiveProtocol: "), *pdwActiveProtocol);
	}

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardDisconnect:

    Calls SCardDisconnect and displays the parameters.

Arguments:

    cf SCardDisconnect
	lExpected is the expected result

Return Value:

    cf SCardDisconnect

Author:

    Eric Perlin (ericperl) 06/23/2000

--*/
LONG LogSCardDisconnect(
	IN SCARDHANDLE hCard,  
	IN DWORD dwDisposition,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardDisconnect(
		hCard,  
		dwDisposition
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardDisconnect"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardHandle(pLogCtx, hCard);

	LogDisposition(pLogCtx, _T("Disposition:    "), dwDisposition);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardBeginTransaction:

    Calls SCardBeginTransaction and displays the parameters.

Arguments:

    cf SCardBeginTransaction
	lExpected is the expected result

Return Value:

    cf SCardBeginTransaction

Author:

    Eric Perlin (ericperl) 07/14/2000

--*/
LONG LogSCardBeginTransaction(
	IN SCARDHANDLE hCard,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardBeginTransaction(
		hCard  
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardBeginTransaction"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardHandle(pLogCtx, hCard);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardEndTransaction:

    Calls SCardEndTransaction and displays the parameters.

Arguments:

    cf SCardEndTransaction
	lExpected is the expected result

Return Value:

    cf SCardEndTransaction

Author:

    Eric Perlin (ericperl) 07/17/2000

--*/
LONG LogSCardEndTransaction(
	IN SCARDHANDLE hCard,
	IN DWORD dwDisposition,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardEndTransaction(
		hCard,
		dwDisposition
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardEndTransaction"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardHandle(pLogCtx, hCard);

	LogDisposition(pLogCtx, _T("Disposition:    "), dwDisposition);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardReconnect:

    Calls SCardReconnect and displays the parameters.

Arguments:

    cf SCardReconnect
	lExpected is the expected result

Return Value:

    cf SCardReconnect

Author:

    Eric Perlin (ericperl) 07/27/2000

--*/
LONG LogSCardReconnect(
	IN SCARDHANDLE hCard,
	IN DWORD dwShareMode,
	IN DWORD dwPreferredProtocols,
    IN DWORD dwInitialization,
	OUT LPDWORD pdwActiveProtocol,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardReconnect(
		hCard,  
		dwShareMode,
		dwPreferredProtocols,
		dwInitialization,
		pdwActiveProtocol
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardReconnect"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardHandle(pLogCtx, hCard);

	LogConnectShareMode(pLogCtx, _T("ShareMode:      "), dwShareMode);

	LogSCardProtocol(pLogCtx, _T("PrefProtocols:  "), dwPreferredProtocols);

	LogDisposition(pLogCtx, _T("Initialization: "), dwInitialization);

	if (IsBadReadPtr(pdwActiveProtocol, sizeof(DWORD)))
	{
	    LogPtr(pLogCtx, pdwActiveProtocol, _T("&ActivProtocol: (Invalid address) "));
	}
	else
	{
		LogSCardProtocol(pLogCtx, _T("ActiveProtocol: "), *pdwActiveProtocol);
	}

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardIntroduceReaderGroup:

    Calls SCardIntroduceReaderGroup and displays the parameters.

Arguments:

    cf SCardIntroduceReaderGroup
	lExpected is the expected result

Return Value:

    cf SCardIntroduceReaderGroup

Author:

    Eric Perlin (ericperl) 07/28/2000

--*/
LONG LogSCardIntroduceReaderGroup(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szGroupName,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardIntroduceReaderGroup(
		hContext,
		szGroupName
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardIntroduceReaderGroup"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("Group Name:     "), szGroupName);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardAddReaderToGroup:

    Calls SCardAddReaderToGroup and displays the parameters.

Arguments:

    cf SCardAddReaderToGroup
	lExpected is the expected result

Return Value:

    cf SCardAddReaderToGroup

Author:

    Eric Perlin (ericperl) 07/28/2000

--*/
LONG LogSCardAddReaderToGroup(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szReaderName,
	IN LPCTSTR szGroupName,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardAddReaderToGroup(
		hContext,  
		szReaderName,
		szGroupName
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardAddReaderToGroup"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("Reader Name:    "), szReaderName);
	LogString(pLogCtx, _T("Group Name:     "), szGroupName);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardForgetReaderGroup:

    Calls SCardForgetReaderGroup and displays the parameters.

Arguments:

    cf SCardForgetReaderGroup
	lExpected is the expected result

Return Value:

    cf SCardForgetReaderGroup

Author:

    Eric Perlin (ericperl) 07/28/2000

--*/
LONG LogSCardForgetReaderGroup(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szGroupName,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardForgetReaderGroup(
		hContext,
		szGroupName
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardForgetReaderGroup"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("Group Name:     "), szGroupName);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardAccessStartedEvent:

    Calls SCardAccessStartedEvent and displays the parameters.

Arguments:

    cf SCardAccessStartedEvent
	lExpected is the expected result

Return Value:

    cf SCardAccessStartedEvent

Author:

    Eric Perlin (ericperl) 07/28/2000

--*/
typedef HANDLE (WINAPI FN_SCARDACCESSSTARTEDEVENT)(VOID);
typedef FN_SCARDACCESSSTARTEDEVENT * PFN_SCARDACCESSSTARTEDEVENT ;


HANDLE LogSCardAccessStartedEvent(
	IN LONG lExpected
)
{
    LONG lRes = 0;
	HANDLE hEvent;
	SYSTEMTIME xSST, xEST;
	PFN_SCARDACCESSSTARTEDEVENT pSCardAccessStartedEvent = NULL;
    static HMODULE hDll = NULL;

	if (NULL == hDll)
	{
		hDll = LoadLibrary(_T("WINSCARD.DLL"));
	}

	GetLocalTime(&xSST);

    if (NULL == hDll)
    {
        lRes = ERROR_FILE_NOT_FOUND;
    }
	else
	{
	    pSCardAccessStartedEvent = (PFN_SCARDACCESSSTARTEDEVENT) GetProcAddress(hDll, "SCardAccessStartedEvent");
		if (NULL == pSCardAccessStartedEvent)
		{
			lRes = ERROR_PROC_NOT_FOUND;
		}
	}

	if (0 == lRes)
	{
		hEvent = pSCardAccessStartedEvent();
		if (NULL == hEvent)
		{
			lRes = GetLastError();
		}
	}

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardAccessStartedEvent"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogPtr(pLogCtx, hEvent, _T("HANDLE:         "));

	LogStop(pLogCtx, lRes == lExpected);

	SetLastError(lRes);

    return hEvent;
}

/*++

LogSCardGetAttrib:

    Calls SCardGetAttrib and displays the parameters.

Arguments:

    cf SCardGetAttrib
	lExpected is the expected result

Return Value:

    cf SCardGetAttrib

Author:

    Eric Perlin (ericperl) 07/28/2000

--*/
LONG LogSCardGetAttrib(
    IN SCARDHANDLE hCard,
    IN DWORD dwAttrId,
    OUT LPBYTE pbAttr,
    IN OUT LPDWORD pcbAttrLen,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;
	DWORD cchSave = 0;

	GetLocalTime(&xSST);


	if (!IsBadReadPtr(pcbAttrLen, sizeof(DWORD)))
	{
		cchSave = *pcbAttrLen;
	}

	lRes = SCardGetAttrib(
		hCard,  
        dwAttrId,
        pbAttr,
        pcbAttrLen
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardGetAttrib"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardHandle(pLogCtx, hCard);

    LogSCardAttrib(pLogCtx, _T("Attribute:      "), dwAttrId);

	if (FAILED(lRes))
	{
	    LogPtr(pLogCtx, pbAttr, _T("pbAttr:         "));
	    LogPtr(pLogCtx, pcbAttrLen, _T("pcbAttrLen:     "));
		if (!IsBadReadPtr(pcbAttrLen, sizeof(DWORD)))
		{
			if (SCARD_AUTOALLOCATE == *pcbAttrLen)
			{
				LogString(pLogCtx, _T("*pcbAttrLen:    SCARD_AUTOALLOCATE\n"));
			}
			else
			{
				LogDWORD(pLogCtx, *pcbAttrLen, _T("*pcbAttrLen:    "));
			}
		}
		else
		{
			LogPtr(pLogCtx, pcbAttrLen, _T("pcbAttrLen:    (Invalid address) "));
		}
	}
	else
	{
		if (SCARD_AUTOALLOCATE == cchSave)
		{
			LogBinaryData(
                pLogCtx, 
				*((BYTE **)pbAttr),
                *pcbAttrLen,
				_T("Attrib. (allocated): ")
			);

            if (*pcbAttrLen == 4)   // Also display as DWORD
            {
    		    LogDWORD(pLogCtx, *((DWORD *)*((BYTE **)pbAttr)), _T("Attrib.:        "));
            }

		}
		else
		{
			LogBinaryData(
                pLogCtx, 
				pbAttr,
                *pcbAttrLen,
				_T("Attrib.: ")
			);

            if (*pcbAttrLen == 4)   // Also display as DWORD
            {
    		    LogDWORD(pLogCtx, *((DWORD *)pbAttr), _T("Attrib.:        "));
            }

		}
		LogDWORD(pLogCtx, *pcbAttrLen, _T("*pcbAttrLen:    "));

	}

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardLocateCards:

    Calls SCardLocateCards and displays the parameters.

Arguments:

    cf SCardLocateCards
	lExpected is the expected result

Return Value:

    cf SCardLocateCards

Author:

    Eric Perlin (ericperl) 07/28/2000

--*/
LONG LogSCardLocateCards(
    IN SCARDCONTEXT hContext,
    IN LPCTSTR mszCards,
    IN OUT LPSCARD_READERSTATE rgReaderStates,
    IN DWORD cReaders,
    IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;
    DWORD dw;

	GetLocalTime(&xSST);

	lRes = SCardLocateCards(
		hContext,  
        mszCards,
        rgReaderStates,
        cReaders
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardLocateCards"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

    LogMultiString(pLogCtx, mszCards, _T("Cards:          "));

    for (dw = 0 ; dw < cReaders ; dw++)
    {
		LogString(pLogCtx, _T("Reader"));
		LogDecimal(pLogCtx, dw);
		if (IsBadReadPtr(rgReaderStates+dw, sizeof(SCARD_READERSTATE)))
		{
			LogPtr(pLogCtx, rgReaderStates+dw, _T(" state has invalid address "));
		}
		else
		{
			LogString(pLogCtx, _T(": "), rgReaderStates[dw].szReader);
			LogSCardReaderState(pLogCtx, _T("Current:        "), rgReaderStates[dw].dwCurrentState);
			LogSCardReaderState(pLogCtx, _T("Event  :        "), rgReaderStates[dw].dwEventState);
		}
    }

    LogDWORD(pLogCtx, cReaders, _T("# of readers:   "));

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardIntroduceReader:

    Calls SCardIntroduceReader and displays the parameters.

Arguments:

    cf SCardIntroduceReader
	lExpected is the expected result

Return Value:

    cf SCardIntroduceReader

Author:

    Eric Perlin (ericperl) 10/18/2000

--*/
LONG LogSCardIntroduceReader(
	IN SCARDCONTEXT hContext,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szDeviceName,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardIntroduceReader(
		hContext,  
        szReaderName,
        szDeviceName
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardIntroduceReader"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("Reader:         "), szReaderName);
	LogString(pLogCtx, _T("Device:         "), szDeviceName);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardForgetReader:

    Calls SCardForgetReader and displays the parameters.

Arguments:

    cf SCardForgetReader
	lExpected is the expected result

Return Value:

    cf SCardForgetReader

Author:

    Eric Perlin (ericperl) 10/18/2000

--*/
LONG LogSCardForgetReader(
	IN SCARDCONTEXT hContext,
    IN LPCTSTR szReaderName,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardForgetReader(
		hContext,
        szReaderName
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardForgetReader"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("Reader:         "), szReaderName);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

Logxxx:

    Calls xxx and displays the parameters.

Arguments:

    cf xxx
	lExpected is the expected result

Return Value:

    cf xxx

Author:

    Eric Perlin (ericperl) 10/18/2000

--*/
#if 0
LONG Logxxx(
	IN SCARDCONTEXT hContext,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = xxx(
		hContext,  
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("xxx"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogStop(lRes == lExpected);

    return lRes;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\item.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Item

Abstract:

    Virtual test item declaration.

Author:

    Eric Perlin (ericperl) 06/07/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/


#ifndef _Item_H_DEF_
#define _Item_H_DEF_

#include "tchar.h"
#include "TString.h"

	// Not very nice here but will be inherited by all tests...
extern LPCTSTR g_szReaderGroups;

class CItem
{
protected:
	TSTRING m_szDescription;	// Test Description

	void SetTestNumber(DWORD dwTestNumber)
	{
		if (0 == m_dwTestNumber)
		{
			m_dwTestNumber = dwTestNumber;
		}
	}

private:
	BOOL m_fInteractive;		// Interactive test?
	BOOL m_fFatal;				// Do we go on if this fails?
	DWORD m_dwTestNumber;		// Test Number

public:
	CItem(
		BOOL fInteractive,
		BOOL fFatal,
		LPCTSTR szDescription
		) :	m_fInteractive(fInteractive),
			m_fFatal(fFatal),
			m_szDescription(szDescription)
	{
		m_dwTestNumber = 0;
	}

	virtual DWORD Run() = 0;

	BOOL IsInteractive() const
	{
		return m_fInteractive;
	}

	BOOL IsFatal() const
	{
		return m_fFatal;
	}

	DWORD GetTestNumber() const
	{
		return m_dwTestNumber;
	}

	LPCTSTR GetDescription() const
	{
		return m_szDescription.c_str();
	}

	void Log() const;
};


#endif // _Item_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\logwpscproxy.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    LogWPSCProxy

Abstract:

    This module defines the logging of hScwxxx APIs & structures.

Author:

    Eric Perlin (ericperl) 07/21/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "wpscproxy.h"

SCODE WINAPI LoghScwAttachToCard(
	IN SCARDHANDLE hCard,			// PC/SC handle
	IN LPCWSTR mszCardNames,		// Acceptable card names for GetOpenCardName
	OUT LPSCARDHANDLE phCard,		// WPSC Proxy handle
	IN SCODE lExpected				// Expected outcome
	);


SCODE WINAPI LoghScwDetachFromCard(
	IN SCARDHANDLE hCard,			// WPSC Proxy handle
	IN SCODE lExpected				// Expected outcome
	);

SCODE WINAPI LoghScwAuthenticateName(
	IN SCARDHANDLE hCard,			// WPSC Proxy handle
	IN WCSTR wszPrincipalName,
	IN BYTE *pbSupportData,
	IN TCOUNT nSupportDataLength,
	IN SCODE lExpected				// Expected outcome
	);

SCODE WINAPI LoghScwIsAuthenticatedName(
	IN SCARDHANDLE hCard,			// WPSC Proxy handle
	IN WCSTR wszPrincipalName,
	IN SCODE lExpected				// Expected outcome
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\logwpscproxy.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    LogWPSCProxy

Abstract:

    This module implements the logging of hScwxxx APIs & structures.

Author:

    Eric Perlin (ericperl) 07/21/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <tchar.h>
#include "MarshalPC.h"

#include "Log.h"
#include "LogSCard.h"

#define LogWPSCHandle LogSCardHandle

/*++

LoghScwAttachToCard:

    Calls hScwAttachToCard and displays the parameters.

Arguments:

    cf hScwAttachToCard
	lExpected is the expected result

Return Value:

    cf hScwAttachToCard

Author:

    Eric Perlin (ericperl) 07/21/2000

--*/
SCODE WINAPI LoghScwAttachToCard(
	IN SCARDHANDLE hCard,			// PC/SC handle
	IN LPCWSTR mszCardNames,		// Acceptable card names for GetOpenCardName
	OUT LPSCARDHANDLE phCard,		// WPSC Proxy handle
	IN SCODE lExpected
	)
{
    SCODE lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = hScwAttachToCard(
		hCard,
		mszCardNames,
		phCard
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("hScwAttachToCard"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	if (NULL == hCard)
	{
		LogString(pLogCtx, _T("PC/SC handle is NULL, connecting to a physical card by name\n"));
	}
	else if (NULL_TX == hCard)
	{
		LogString(pLogCtx, _T("PC/SC handle is NULL, connecting to a simulated card by name\n"));
	}
	else
	{
		LogDWORD(pLogCtx, (DWORD)hCard, _T("PC/SC handle:   "));
	}

	if (NULL == mszCardNames)
	{
	    LogString(pLogCtx, _T("mszCardNames is NULL, connecting to a physical card by handle\n"));
	}
	else if (NULL_TX_NAME == mszCardNames)
	{
	    LogString(pLogCtx, _T("mszCardNames is NULL, connecting to a simulated card by handle\n"));
	}
	else
	{
		LogMultiString(pLogCtx, mszCardNames, L"Card Names:     ");
	}

	if (IsBadReadPtr(phCard, sizeof(SCARDHANDLE)))
	{
		LogPtr(pLogCtx, phCard, _T("LPSCARDHANDLE is invalid: "));
	}
	else
	{
		LogDWORD(pLogCtx, (DWORD)*phCard, _T("SCWAPI handle:  "));
		LPMYSCARDHANDLE lpxTmp = (LPMYSCARDHANDLE)(*phCard);

		LogSCardContext(pLogCtx, lpxTmp->hCtx);
		LogSCardHandle(pLogCtx, lpxTmp->hCard);

		LogDWORD(pLogCtx, lpxTmp->dwFlags, _T("Internal flags: "));
		LogSCardProtocol(pLogCtx, _T("Protocol:       "), lpxTmp->dwProtocol);

		LogPtr(pLogCtx, lpxTmp->lpfnTransmit, _T("Transmit cback: "));
		LogDecimal(pLogCtx, (DWORD)(lpxTmp->bResLen), _T("Card IO size:   "));

		LogDWORD(pLogCtx, (DWORD)(lpxTmp->byINS), _T("Card proxy INS: "));
	}

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;

}


/*++

LoghScwDetachFromCard:

    Calls hScwDetachFromCard and displays the parameters.

Arguments:

    cf hScwDetachFromCard
	lExpected is the expected result

Return Value:

    cf hScwDetachFromCard

Author:

    Eric Perlin (ericperl) 07/24/2000

--*/
SCODE WINAPI LoghScwDetachFromCard(
	IN SCARDHANDLE hCard,		// WPSC Proxy handle
	IN SCODE lExpected			// Expected outcome
)
{
    SCODE lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = hScwDetachFromCard(
		hCard
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("hScwDetachFromCard"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogWPSCHandle(pLogCtx, hCard);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LoghScwAuthenticateName:

    Calls hScwAuthenticateName and displays the parameters.

Arguments:

    cf hScwAuthenticateName
	lExpected is the expected result

Return Value:

    cf hScwAuthenticateName

Author:

    Eric Perlin (ericperl) 07/24/2000

--*/
SCODE WINAPI LoghScwAuthenticateName(
	IN SCARDHANDLE hCard,			// WPSC Proxy handle
	IN WCSTR wszPrincipalName,
	IN BYTE *pbSupportData,
	IN TCOUNT nSupportDataLength,
	IN SCODE lExpected				// Expected outcome
)
{
    SCODE lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = hScwAuthenticateName(
		hCard,  
		wszPrincipalName,
		pbSupportData,
		nSupportDataLength
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("hScwAuthenticateName"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogWPSCHandle(pLogCtx, hCard);

	LogString(pLogCtx, L"wszKPName:      ", wszPrincipalName);

	if (IsBadReadPtr(pbSupportData, (UINT)nSupportDataLength))
	{
	    LogPtr(pLogCtx, pbSupportData, _T("Support Data:   (Invalid address) "));
	}
	else
	{
		LogBinaryData(pLogCtx, pbSupportData, (DWORD)nSupportDataLength, _T("Support Data:   "));
	}
	LogDecimal(pLogCtx, nSupportDataLength, _T("Data length:    "));

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LoghScwIsAuthenticatedName:

    Calls hScwIsAuthenticatedName and displays the parameters.

Arguments:

    cf hScwIsAuthenticatedName
	lExpected is the expected result

Return Value:

    cf hScwIsAuthenticatedName

Author:

    Eric Perlin (ericperl) 07/24/2000

--*/
SCODE WINAPI LoghScwIsAuthenticatedName(
	IN SCARDHANDLE hCard,			// WPSC Proxy handle
	IN WCSTR wszPrincipalName,
	IN SCODE lExpected				// Expected outcome
)
{
    SCODE lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = hScwIsAuthenticatedName(
		hCard,  
		wszPrincipalName
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("hScwIsAuthenticatedName"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogWPSCHandle(pLogCtx, hCard);

	LogString(pLogCtx, L"wszKPName:      ", wszPrincipalName);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

Logxxx:

    Calls xxx and displays the parameters.

Arguments:

    cf xxx
	lExpected is the expected result

Return Value:

    cf xxx

Author:

    Eric Perlin (ericperl) 07/24/2000

--*/
#if 0
SCODE WINAPI Logxxx(
	IN SCARDHANDLE hCard,			// WPSC Proxy handle
	IN SCODE lExpected				// Expected outcome
)
{
    SCODE lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = xxx(
		hCard,  
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("xxx"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogWPSCHandle(hCard);

	LogStop(lRes == lExpected);

    return lRes;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\marshalpc.c ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "MarshalPC.h"
#include <string.h>

//*****************************************************************************
//      Un/Marshaling
//*****************************************************************************


void InitXSCM(LPMYSCARDHANDLE phTmp, const BYTE *pbBuffer, WORD len)
{
    phTmp->xSCM.wResLen = len;

	if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
		phTmp->xSCM.wExpLen = 1;			// Prereserves the return code
	else
		phTmp->xSCM.wExpLen = 0;			// Return code in SW2
	phTmp->xSCM.wGenLen = 0;
    phTmp->xSCM.pbBuffer = (LPBYTE)pbBuffer;
}

WORD GetSCMBufferLength(LPXSCM pxSCM)
{
    return pxSCM->wGenLen;
}

BYTE *GetSCMCrtPointer(LPXSCM pxSCM)
{
    return pxSCM->pbBuffer;
}


//*****************************************************************************
// PARAM EXTRACTION (we care only that there is enough data received, i.e.
// we ignore pxSCM->wGenLen & pxSCM->wExpLen

SCODE XSCM2SCODE(LPXSCM pxSCM)
{
	BYTE by;
	if (pxSCM->wResLen == 0)
		RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
	pxSCM->wResLen -= sizeof(UINT8);
	by = *(pxSCM->pbBuffer)++;
    return MAKESCODE(by);
}

UINT8 XSCM2UINT8(LPXSCM pxSCM)
{
	if (pxSCM->wResLen == 0)
		RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
	pxSCM->wResLen -= sizeof(UINT8);
    return *((UINT8 *)pxSCM->pbBuffer)++;
}

HFILE XSCM2HFILE(LPXSCM pxSCM)
{
	return (HFILE)(XSCM2UINT8(pxSCM));
}

UINT16 XSCM2UINT16(LPXSCM pxSCM, BOOL fBigEndian)
{
	if (pxSCM->wResLen < sizeof(UINT16))
		RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
	pxSCM->wResLen -= sizeof(UINT16);
    if (fBigEndian)
    {
        UINT16 w = *((UINT16 *)pxSCM->pbBuffer)++;
        w = (UINT16)(w>>8) | (UINT16)(w<<8);
        return w;
    }
    else
        return *((UINT16 *)pxSCM->pbBuffer)++;
}

    // Returns length in WCHAR
WCSTR XSCM2String(LPXSCM pxSCM, UINT8 *plen, BOOL fBigEndian)
{
        // Get the length (addr next byte + length -> next object
    WCSTR wsz;
    UINT8 len, i;

    len = XSCM2UINT8(pxSCM);
	if (len == 0)
	{
		wsz = NULL;
	}
	else
	{
		if (pxSCM->wResLen < (WORD)len)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		pxSCM->wResLen -= (WORD)len;
		wsz = (WCSTR)pxSCM->pbBuffer;
            // In place byte switching
//        if (fBigEndian)
//        {
//            BYTE b;
//            for (i=0 ; i<(len&0xF7)-2 ; i+=2)
//            {
//                b = pxSCM->pbBuffer[i];
//                pxSCM->pbBuffer[i] = pxSCM->pbBuffer[i + 1];
//                pxSCM->pbBuffer[i+1] = b;
//            }
//        }
			// Verify 0 terminated within len/2
		for (i=0 ; i<len/2 ; i++)
		{
			if (wsz[i] == (WCHAR)0)
				break;
		}
		if (i >= len/2) 
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		else
			len = i+1;

		pxSCM->pbBuffer += len;
	}
    if (plen)
        *plen = len;
    return wsz;
}

TCOUNT XSCM2ByteArray(LPXSCM pxSCM, UINT8 **ppb)
{
    TCOUNT len = XSCM2UINT8(pxSCM);
    if (len)
    {
		if (pxSCM->wResLen < (WORD)len)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		pxSCM->wResLen -= (WORD)len;
        *ppb = (UINT8 *)pxSCM->pbBuffer;
        pxSCM->pbBuffer += len;
    }
    else
        *ppb = NULL;
    return len;
}

//*****************************************************************************


void UINT82XSCM(LPXSCM pxSCM, UINT8 val, int type)
{
	switch (type)
	{
	case TYPE_NOTYPE_NOCOUNT:	// Goes in the header
		break;					// There can't be a problem

	case TYPE_NOTYPE_COUNT:		// Probably #param or a param type (1 byte)
		if (pxSCM->wExpLen + sizeof(UINT8) > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		break;

	case TYPE_TYPED:			// 8 bits number passed by value (2 bytes)
		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
				// Prefix by the type (8)
		*((UINT8 *)pxSCM->pbBuffer)++ = 8;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
		break;
	}

		// Add the value already !
    *((UINT8 *)pxSCM->pbBuffer)++ = val;
	if (type != TYPE_NOTYPE_NOCOUNT)	// Header doesn't count as expanded
		pxSCM->wExpLen += sizeof(UINT8);
	pxSCM->wGenLen += sizeof(UINT8);
}

	// proxies HFILE as an UINT8
void HFILE2XSCM(LPXSCM pxSCM, HFILE val)
{
	if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) > pxSCM->wResLen)
		RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

				// Prefix by the type (8 -> UINT8)
	*((UINT8 *)pxSCM->pbBuffer)++ = 8;
	pxSCM->wExpLen += sizeof(UINT8);
	pxSCM->wGenLen += sizeof(UINT8);
    *((UINT8 *)pxSCM->pbBuffer)++ = (UINT8)val;
	pxSCM->wExpLen += sizeof(UINT8);
	pxSCM->wGenLen += sizeof(UINT8);
}

void UINT162XSCM(LPXSCM pxSCM, UINT16 val, BOOL fBigEndian)
{
	if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT16) > pxSCM->wResLen)
		RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

				// Prefix by the type (16)
    *((UINT8 *)pxSCM->pbBuffer)++ = 16;
	pxSCM->wExpLen += sizeof(UINT8);
	pxSCM->wGenLen += sizeof(UINT8);
    if (fBigEndian)
    {
        *pxSCM->pbBuffer++ = (BYTE)(val>>8);
        *pxSCM->pbBuffer++ = (BYTE)(val);
    }
    else
        *((UINT16 *)pxSCM->pbBuffer)++ = val;
	pxSCM->wExpLen += sizeof(UINT16);
	pxSCM->wGenLen += sizeof(UINT16);
}

void ByteArray2XSCM(LPXSCM pxSCM, const BYTE *pbBuffer, TCOUNT len)
{
    if (pbBuffer == NULL)
    {
			// This is equivalent to marshal a NULL & "len as a UINT8"
		NULL2XSCM(pxSCM);
		UINT82XSCM(pxSCM, len, TYPE_TYPED);
    }
    else
    {
		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + len > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

				// Prefix by the type ('A')
		*((UINT8 *)pxSCM->pbBuffer)++ = 'A';
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
				// Add the length
        *((UINT8 *)pxSCM->pbBuffer)++ = len;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
				// Add the data already
        memcpy(pxSCM->pbBuffer, pbBuffer, len);
        pxSCM->pbBuffer += len;
        pxSCM->wExpLen += len;
        pxSCM->wGenLen += len;
    }
}

void String2XSCM(LPXSCM pxSCM, WCSTR wsz, BOOL fBigEndian)
{
	UINT16 len; //, i;

	if (wsz == NULL)
    {
			// This is equivalent to marshal a NULL
		NULL2XSCM(pxSCM);
    }
	else
    {
			// No overflow needs to be checked in the following assignement to len
		if (wcslen(wsz) > 0x7FFE)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

			// compute the length (addr next byte + length -> next object
		len = (wcslen(wsz) + 1) * sizeof(WCHAR);

		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + len > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

				// Prefix by the type ('S')
		*((UINT8 *)pxSCM->pbBuffer)++ = 'S';
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
				// Add the length
	    *((UINT8 *)pxSCM->pbBuffer)++ = (UINT8)len;		// No chance the length check succeeds
														// if len > 255
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
				// Add the data already
           // Byte switching?
//        if (fBigEndian)
//        {
//            for (i=0 ; i<len ; i+=2)
//            {
//                pxSCM->pbBuffer[i] = (BYTE)(wsz[i>>1]>>8);
//                pxSCM->pbBuffer[i+1] = (BYTE)(wsz[i>>1]);
//            }
//        }
//        else
	        memcpy(pxSCM->pbBuffer, (BYTE *)wsz, len);

        pxSCM->pbBuffer += len;
        pxSCM->wExpLen += len;
        pxSCM->wGenLen += len;
    }
}

void UINT8BYREF2XSCM(LPXSCM pxSCM, UINT8 *val)
{
	if (val)
	{
			// In this case the card unmarshaling code will reserve 1 byte in the
			// OutputBuffer and have _param[_iparam++]._pv point to it
		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + sizeof(UINT8) > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

					// Prefix by the type (108)
		*((UINT8 *)pxSCM->pbBuffer)++ = 108;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
					// Add the value already
		*((UINT8 *)pxSCM->pbBuffer)++ = *val;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);

					// As mentioned above, 1 byte will be reserved in the output buffer
		pxSCM->wExpLen += sizeof(UINT8);
	}
	else
	{
			// This is equivalent to marshal a NULL
		NULL2XSCM(pxSCM);
	}
}

void HFILEBYREF2XSCM(LPXSCM pxSCM, HFILE *val)
{
	if (val)
	{
			// In this case the card unmarshaling code will reserve 1 byte in the
			// OutputBuffer and have _param[_iparam++]._pv point to it
		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + sizeof(UINT8) > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

					// Prefix by the type (108)
		*((UINT8 *)pxSCM->pbBuffer)++ = 108;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
					// Add the value already
		*((UINT8 *)pxSCM->pbBuffer)++ = (UINT8)*val;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);

					// As mentioned above, 1 byte will be reserved in the output buffer
		pxSCM->wExpLen += sizeof(UINT8);
	}
	else
	{
			// This is equivalent to marshal a NULL
		NULL2XSCM(pxSCM);
	}
}

void UINT16BYREF2XSCM(LPXSCM pxSCM, UINT16 *val, BOOL fBigEndian)
{
	if (val)
	{
			// In this case the card unmarshaling code will reserve 2 bytes in the
			// OutputBuffer and have _param[_iparam++]._pv point to it
		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT16) + sizeof(UINT16) > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

					// Prefix by the type (116)
		*((UINT8 *)pxSCM->pbBuffer)++ = 116;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
					// Add the value already
		if (fBigEndian)
		{
			*pxSCM->pbBuffer++ = (BYTE)((*val)>>8);
			*pxSCM->pbBuffer++ = (BYTE)(*val);
		}
		else
			*((UINT16 *)pxSCM->pbBuffer)++ = *val;
		pxSCM->wExpLen += sizeof(UINT16);
		pxSCM->wGenLen += sizeof(UINT16);

					// As mentioned above, 2 bytes will be reserved in the output buffer
		pxSCM->wExpLen += sizeof(UINT16);
	}
	else
	{
			// This is equivalent to marshal a NULL
		NULL2XSCM(pxSCM);
	}
}

void ByteArrayOut2XSCM(LPXSCM pxSCM, BYTE *pb, TCOUNT len)
{
	if (pb)
	{
			// In this case the card unmarshaling code will reserve 1+len bytes in the
			// OutputBuffer and have _param[_iparam++]._pv point to the len bytes
			// Note that the current buffer isn't passed in
		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + sizeof(UINT8) + len > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

					// Prefix by the type ('a')
		*((UINT8 *)pxSCM->pbBuffer)++ = 'a';
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
					// Add the length
		*((UINT8 *)pxSCM->pbBuffer)++ = len;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);

					// As mentioned above, 1+len bytes will be reserved in the output buffer
		pxSCM->wExpLen += sizeof(UINT8) + len;
	}
	else
	{
			// This is equivalent to marshal a NULL & "len as a UINT8"
		NULL2XSCM(pxSCM);
		UINT82XSCM(pxSCM, len, TYPE_TYPED);
	}
}

void StringOut2XSCM(LPXSCM pxSCM, WSTR wsz, TCOUNT len, BOOL fBigEndian)
{
	if (wsz)
	{
							// len is a WCHAR count
		if (len > 127)		// This would cause overflows in String marshaling
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

			// In this case the card unmarshaling code will reserve 1+len*2 bytes in the
			// OutputBuffer and have _param[_iparam++]._pv point to the len bytes
			// Note that the current buffer isn't passed in
		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + sizeof(UINT8) + len*2 > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

					// Prefix by the type ('s')
		*((UINT8 *)pxSCM->pbBuffer)++ = 's';
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
		*((UINT8 *)pxSCM->pbBuffer)++ = len*2;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);

					// As mentioned above, 1+len*2 bytes will be reserved in the output buffer
		pxSCM->wExpLen += sizeof(UINT8) + len*2;
	}
	else
	{
			// This is equivalent to marshal a NULL & "len as a UINT8"
		NULL2XSCM(pxSCM);
		UINT82XSCM(pxSCM, len, TYPE_TYPED);
	}
}

void NULL2XSCM(LPXSCM pxSCM)
{
	if (pxSCM->wExpLen + sizeof(UINT8) > pxSCM->wResLen)
		RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

				// Prefix by the type (0)
     *((UINT8 *)pxSCM->pbBuffer)++ = 0;
	pxSCM->wExpLen += sizeof(UINT8);
	pxSCM->wGenLen += sizeof(UINT8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\logscard.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    LogSCard

Abstract:

    This module defines the logging of SCardxxx APIs & structures.

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef _LogSCard_H_DEF_
#define _LogSCard_H_DEF_

#include <winscard.h>
#include "Log.h"

void LogSCardContext(
    IN PLOGCONTEXT pLogCtx,
    IN SCARDCONTEXT hContext
    );

void LogSCardHandle(
    IN PLOGCONTEXT pLogCtx,
    IN SCARDHANDLE hCard
    );

void LogSCardProtocol(
    IN PLOGCONTEXT pLogCtx,
    IN LPCTSTR szHeader,
    IN DWORD dwProtocol
    );

LONG LogSCardEstablishContext(
    IN  DWORD dwScope,
    IN  LPCVOID pvReserved1,
    IN  LPCVOID pvReserved2,
    OUT LPSCARDCONTEXT phContext,
	IN LONG lExpected
);

LONG LogSCardListReaders(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR mszGroups,
	OUT LPTSTR mszReaders,
	IN OUT LPDWORD pcchReaders,
	IN LONG lExpected
);

LONG LogSCardGetStatusChange(
	IN SCARDCONTEXT hContext,
	IN DWORD dwTimeout,
	IN OUT LPSCARD_READERSTATE rgReaderStates,
	IN DWORD cReaders,
	IN LONG lExpected
);

LONG LogSCardFreeMemory(
	IN SCARDCONTEXT hContext,  
	IN LPCVOID pvMem,
	IN LONG lExpected
);

LONG LogSCardReleaseContext(
	IN SCARDCONTEXT hContext,
	IN LONG lExpected
);

LONG LogSCardUIDlgSelectCard(
	IN LPOPENCARDNAME_EX pDlgStruc,
	IN LONG lExpected
);

LONG LogSCardListCards(
	IN SCARDCONTEXT hContext,
	IN LPCBYTE pbAtr,
	IN LPCGUID rgguidInterfaces,
	IN DWORD cguidInterfaceCount,
	OUT LPTSTR mszCards,
	IN OUT LPDWORD pcchCards,
	IN LONG lExpected
);

LONG LogSCardIntroduceCardType(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szCardName,
	IN LPCGUID pguidPrimaryProvider,
	IN LPCGUID rgguidInterfaces,
	IN DWORD dwInterfaceCount,
	IN LPCBYTE pbAtr,
	IN LPCBYTE pbAtrMask,
	IN DWORD cbAtrLen,
	IN LONG lExpected
);

LONG LogSCardForgetCardType(
	IN SCARDCONTEXT hContext,  
	IN LPCTSTR szCardName,
	IN LONG lExpected
);

LONG LogSCardConnect(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szReader,
	IN DWORD dwShareMode,
	IN DWORD dwPreferredProtocols,
	OUT LPSCARDHANDLE phCard,
	OUT LPDWORD pdwActiveProtocol,
	IN LONG lExpected
);

LONG LogSCardDisconnect(
	IN SCARDHANDLE hCard,  
	IN DWORD dwDisposition,
	IN LONG lExpected
);

LONG LogSCardBeginTransaction(
	IN SCARDHANDLE hCard,
	IN LONG lExpected
);

LONG LogSCardEndTransaction(
	IN SCARDHANDLE hCard,
	IN DWORD dwDisposition,
	IN LONG lExpected
);

LONG LogSCardReconnect(
	IN SCARDHANDLE hCard,
	IN DWORD dwShareMode,
	IN DWORD dwPreferredProtocols,
	IN DWORD dwInitialization,
	OUT LPDWORD pdwActiveProtocol,
	IN LONG lExpected
);

LONG LogSCardIntroduceReaderGroup(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szGroupName,
	IN LONG lExpected
);

LONG LogSCardAddReaderToGroup(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szReaderName,
	IN LPCTSTR szGroupName,
	IN LONG lExpected
);

LONG LogSCardForgetReaderGroup(
	IN SCARDCONTEXT hContext,  
	IN LPCTSTR szGroupName,
	IN LONG lExpected
);

HANDLE LogSCardAccessStartedEvent(
	IN LONG lExpected
);

LONG LogSCardGetAttrib(
    IN SCARDHANDLE hCard,
    IN DWORD dwAttrId,
    OUT LPBYTE pbAttr,
    IN OUT LPDWORD pcbAttrLen,
    IN LONG lExpected
);

LONG LogSCardLocateCards(
    IN SCARDCONTEXT hContext,
    IN LPCTSTR mszCards,
    IN OUT LPSCARD_READERSTATE rgReaderStates,
    IN DWORD cReaders,
    IN LONG lExpected
);

LONG LogSCardIntroduceReader(
	IN SCARDCONTEXT hContext,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szDeviceName,
	IN LONG lExpected
);

LONG LogSCardForgetReader(
	IN SCARDCONTEXT hContext,
    IN LPCTSTR szReaderName,
	IN LONG lExpected
);

#endif //_LogSCard_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\marshalpc.h ===
#ifndef _MARSHAL_H_DEF
#define _MARSHAL_H_DEF

	// Card SCODEs are 8 bits with msb meaning error
    // Win32 SCODEs are 32 bits with msb meaning error
#define MAKESCODE(r) ((SCODE)((r) & 0x80 ? (r) | 0xC0000000L : (r)))

#include "wpscproxy.h"

	// Smart Card Marshaling structure
typedef struct {
    WORD wGenLen;		// Size of the generated buffer
	WORD wExpLen;		// Size of the expanded buffer (after unmarshaling in the card)
	WORD wResLen;		// Size of the reserved buffer (as returned by the card)
    BYTE *pbBuffer;		// Pointer where the next argument will be added
} XSCM;

typedef XSCM *LPXSCM;

#define FLAG_REALPCSC	0
#define FLAG_FAKEPCSC	1
#define FLAG_NOT_PCSC	2
#define FLAG_MASKPCSC	1	// To get the PC/SC index in the array below
#define FLAG_TYPEPCSC	3	// To get the PC/SC type

#define FLAG_BIGENDIAN	0x80000000L
#define FLAG_MY_ATTACH	0x40000000L
#define FLAG_ISPROXY	0x20000000L

#define FLAG_MASKVER	0x00FF0000L
#define FLAG2VERSION(dw)	((dw)&FLAG_MASKVER)
#define VERSION_1_0		0x00100000L
#define VERSION_1_1		0x00110000L

typedef struct {
	SCARDCONTEXT hCtx;		// Associated ResMgr context
	SCARDHANDLE hCard;		// Associated PC/SC card handle 
	DWORD dwFlags;			// 
	DWORD dwProtocol;
	LPFNSCWTRANSMITPROC lpfnTransmit;
	BYTE bResLen;			// Reserved length in TheBuffer in the card
	BYTE *pbLc;				// Stores Crt SCM pointer for future update
	XSCM xSCM;
	BYTE byINS;				// INS to be used for proxy
	BYTE byCryptoM;			// Last Crypto mechanism
} MYSCARDHANDLE;

typedef MYSCARDHANDLE *LPMYSCARDHANDLE;


	// Raisable exceptions
#define STATUS_INSUFFICIENT_MEM     0xE0000001
#define STATUS_INVALID_PARAM		0xE0000002
#define STATUS_NO_SERVICE			0xE0000003
#define STATUS_INTERNAL_ERROR		0xE0000004

	// len will set wResLen in the above structure
	// If wExpLen gets bigger than wResLen, an exception will be generated (marshaling)
	// If wResLen indicates that the buffer cannot hold the parameter, an exception
	// will be raised too (unmarshaling)
void InitXSCM(LPMYSCARDHANDLE phTmp, const BYTE *pbBuffer, WORD len);

	// Generated buffer length
WORD GetSCMBufferLength(LPXSCM pxSCM);
BYTE *GetSCMCrtPointer(LPXSCM pxSCM);

	// Extraction of data from the returned buffer (PC unmarshaling)
	// helper functions
SCODE XSCM2SCODE(LPXSCM pxSCM);
UINT8 XSCM2UINT8(LPXSCM pxSCM);
HFILE XSCM2HFILE(LPXSCM pxSCM);
UINT16 XSCM2UINT16(LPXSCM pxSCM, BOOL fBigEndian);
WCSTR XSCM2String(LPXSCM pxSCM, UINT8 *plen, BOOL fBigEndian);
TCOUNT XSCM2ByteArray(LPXSCM pxSCM, UINT8 **ppb);

	// Laying out of data in the buffer to be sent (PC marshaling)
	// helper functions
#define TYPE_NOTYPE_NOCOUNT		0		// Not prefixed with type, not data
#define TYPE_TYPED				1		// Prefixed with type (always counts)
#define TYPE_NOTYPE_COUNT		2		// Not prefixed with type, but is data

void UINT82XSCM(LPXSCM pxSCM, UINT8 val, int type);
void HFILE2XSCM(LPXSCM pxSCM, HFILE val);
void UINT162XSCM(LPXSCM pxSCM, UINT16 val, BOOL fBigEndian);
void ByteArray2XSCM(LPXSCM pxSCM, const BYTE *pbBuffer, TCOUNT len);
void String2XSCM(LPXSCM pxSCM, WCSTR wsz, BOOL fBigEndian);
void SW2XSCM(LPXSCM pxSCM, UINT16 wSW);
void UINT8BYREF2XSCM(LPXSCM pxSCM, UINT8 *val);
void HFILEBYREF2XSCM(LPXSCM pxSCM, HFILE *val);
void UINT16BYREF2XSCM(LPXSCM pxSCM, UINT16 *val, BOOL fBigEndian);
void ByteArrayOut2XSCM(LPXSCM pxSCM, BYTE *pb, TCOUNT len);
void StringOut2XSCM(LPXSCM pxSCM, WSTR wsz, TCOUNT len, BOOL fBigEndian);
void NULL2XSCM(LPXSCM pxSCM);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\test1.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test1

Abstract:

    Test1 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"

class CTest1 : public CTestItem
{
public:
	CTest1() : CTestItem(TRUE, FALSE,
		_T("Regression 26067: Quick SC changes are not always reported by SCardGetStatusChange"),
		_T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest1 Test1;

DWORD CTest1::Run()
{
    LONG lRes;
    SCARDCONTEXT hSCCtx = NULL;
    LPTSTR pmszReaders = NULL;
    LPTSTR pReader;
    DWORD cch = SCARD_AUTOALLOCATE;
    LPSCARD_READERSTATE rgReaderStates = NULL;
    DWORD dwCntDwn, dwSleepSecs = 0;
    DWORD dwCrtRep, dwReps = 0;
    DWORD dwRdr;

    dwSleepSecs = 10;
    dwReps = 2;

    __try {

        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            __leave;
        }


            // Retrieve the list the readers.
        lRes = LogSCardListReaders(
            hSCCtx,
            g_szReaderGroups,
            (LPTSTR)&pmszReaders,
            &cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            __leave;
        }
            // Display the list of readers
        pReader = pmszReaders;
        cch = 0;
        while ( (TCHAR)'\0' != *pReader )
        {
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            cch++;
        }

        if (cch == 0)
        {
            PLOGCONTEXT pLogCtx = LogVerification(_T("Reader presence verification"), FALSE);
            LogString(pLogCtx, _T("                A reader is required and none could be found!\n"));
            LogStop(pLogCtx, FALSE);
            lRes = SCARD_F_UNKNOWN_ERROR;   // Shouldn't happen
            __leave;
        }

        rgReaderStates = (LPSCARD_READERSTATE)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            sizeof(SCARD_READERSTATE) * cch
            );
        if (rgReaderStates == NULL)
        {
            PLOGCONTEXT pLogCtx = LogVerification(_T("HeapAlloc"), FALSE);
            LogString(pLogCtx, _T("                Allocating the array of SCARD_READERSTATE failed!\n"));
            LogStop(pLogCtx, FALSE);
            lRes = ERROR_OUTOFMEMORY;
            __leave;
        }

            // Setup the SCARD_READERSTATE array
        pReader = pmszReaders;
        cch = 0;
        while ( '\0' != *pReader )
        {
            rgReaderStates[cch].szReader = pReader;
            rgReaderStates[cch].dwCurrentState = SCARD_STATE_UNAWARE;
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            cch++;
        }

            // Get the initial state
        LogThisOnly(_T("\n\nInitial call to get current state(s):\n"), TRUE);

        lRes = LogSCardGetStatusChange(
            hSCCtx,
            1000,
            rgReaderStates,
            cch,
			SCARD_S_SUCCESS
            );
        if (FAILED(lRes))
        {
            __leave;
        }


        _ftprintf(stdout, _T("\n\nThis test verifies the generation of pseudo events when the state of the\n"));
        _ftprintf(stdout, _T("reader has returned to the state assumed by the caller although a few\n"));
        _ftprintf(stdout, _T("transitions occurred. Insert and remove cards during the countdowns.\n"));

        for (dwCrtRep = 0 ; dwCrtRep < dwReps ; dwCrtRep++)
        {
            for (dwRdr = 0; dwRdr < cch ; dwRdr++)
                rgReaderStates[dwRdr].dwCurrentState = rgReaderStates[dwRdr].dwEventState;

            _ftprintf(stdout, _T("Repetition %ld of %ld\n"), dwCrtRep+1, dwReps);
            _ftprintf(stdout, _T("Countdown to next call:"));
            dwCntDwn = dwSleepSecs;
            while (dwCntDwn--)
            {
                _ftprintf(stdout, _T(" %ld"), dwCntDwn);
				fflush(stdout);
                Sleep(1000);
            }
            _ftprintf(stdout, _T("\n"));

            lRes = LogSCardGetStatusChange(
                hSCCtx,
                5000,
                rgReaderStates,
                cch,
				SCARD_S_SUCCESS
                );
            if (FAILED(lRes))
            {
                if (SCARD_E_TIMEOUT != lRes)
                    __leave;
            }
        }

        _ftprintf(stdout, _T("This test is finished!\n"));
        lRes = -2;      // Invalid error

    }
    __finally
    {
        if (lRes == 0)
        {
            LogThisOnly(_T("Test1: an exception occurred!"), FALSE);
            lRes = -1;
        }

            // Cleanup
        if (NULL != rgReaderStates)
		{
            HeapFree(GetProcessHeap(), 0, (LPVOID)rgReaderStates);
		}

        if (NULL != pmszReaders)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszReaders,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    if (-2 == lRes)
	{
        lRes = 0;
	}

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\test2.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test2

Abstract:

    Test2 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"

class CTest2 : public CTestItem
{
public:
	CTest2() : CTestItem(TRUE, FALSE,
		_T("Regression of 112347 & 112348 revolving around SCardUIDlgSelectCard"),
		_T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest2 Test2;

DWORD CTest2::Run()
{
    LONG lRes;
    SCARDCONTEXT hSCCtx = NULL;
	OPENCARDNAME_EX xOCNX;
	TCHAR szRdrName[256];
	TCHAR szCardName[256];

    __try {

        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            __leave;
        }

		xOCNX.dwStructSize = sizeof(OPENCARDNAME_EX);
		xOCNX.hSCardContext = hSCCtx;
		xOCNX.hwndOwner = NULL;
		xOCNX.dwFlags = SC_DLG_FORCE_UI;
		xOCNX.lpstrTitle = NULL;
		xOCNX.lpstrSearchDesc = NULL;
		xOCNX.hIcon = NULL;
		xOCNX.pOpenCardSearchCriteria = NULL;
		xOCNX.lpfnConnect = NULL;
		xOCNX.pvUserData = NULL;
		xOCNX.dwShareMode = SCARD_SHARE_SHARED;
		xOCNX.dwPreferredProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
		xOCNX.lpstrRdr = szRdrName;
		xOCNX.nMaxRdr = sizeof(szRdrName) / sizeof(TCHAR);
		xOCNX.lpstrCard = szCardName;
		xOCNX.nMaxCard = sizeof(szCardName) / sizeof(TCHAR);
		xOCNX.dwActiveProtocol = 0;
		xOCNX.hCardHandle = NULL;

		lRes = LogSCardUIDlgSelectCard(
			&xOCNX,
			SCARD_W_CANCELLED_BY_USER
			);

        lRes = -2;      // Invalid error

    }
    __finally
    {
        if (lRes == 0)
        {
            LogThisOnly(_T("Test2: an exception occurred!\n"), FALSE);
            lRes = -1;
        }

		if (NULL != xOCNX.hCardHandle)
		{
			LogSCardDisconnect(
				xOCNX.hCardHandle,
				SCARD_RESET_CARD,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    if (-2 == lRes)
	{
        lRes = 0;
	}

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\test3.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test3

Abstract:

    Test3 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 07/13/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"
#include "LogWPSCProxy.h"

class CTest3 : public CTestItem
{
public:
	CTest3() : CTestItem(TRUE, FALSE,
		_T("SCardEndTransaction with dispositions other than LEAVE"),
		_T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest3 Test3;

typedef struct {
	LPCTSTR szReaderName;
	HANDLE hEvent;
} THREAD_DATA;


DWORD WINAPI ThreadProc(
	IN LPVOID lpParam
	)
{
	DWORD dwRes;
    SCARDCONTEXT hSCCtx = NULL;
	SCARDHANDLE hCard = NULL;
	SCARDHANDLE hScwCard = NULL;
	DWORD dwProtocol = 0;
	BOOL fTransacted = FALSE;
	THREAD_DATA *pxTD = (THREAD_DATA *)lpParam;
	DWORD dwDisposition = SCARD_LEAVE_CARD;
	DWORD dwWait;

    __try {
		dwRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            __leave;
        }

		dwRes = LogSCardConnect(
			hSCCtx,
			pxTD->szReaderName,
			SCARD_SHARE_SHARED,
			SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
			&hCard,
			&dwProtocol,
			SCARD_S_SUCCESS);
        if (FAILED(dwRes))
        {
            __leave;
        }

SecondRound:
		dwRes = LogSCardBeginTransaction(
			hCard,
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
            __leave;
		}
		fTransacted = TRUE;

		dwRes = LoghScwAttachToCard(
			hCard, 
			NULL, 
			&hScwCard, 
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
            __leave;
		}

		dwRes = LoghScwAuthenticateName(
			hScwCard,
			L"test",
			(BYTE *)"1234",
			4,
			SCW_S_OK
			);
		if (FAILED(dwRes))
		{
            __leave;
		}

		dwRes = LoghScwIsAuthenticatedName(
			hScwCard,
			L"test",
			SCW_S_OK
			);
		if (FAILED(dwRes))
		{
            __leave;
		}

		LoghScwDetachFromCard(
			hScwCard,
			SCARD_S_SUCCESS
			);
		hScwCard = NULL;

		dwRes = LogSCardEndTransaction(
			hCard,
			dwDisposition,
			SCARD_S_SUCCESS
			);
		fTransacted = FALSE;
		if (FAILED(dwRes))
		{
            __leave;
		}

		SetEvent(pxTD->hEvent);				// Will release the main thread

		Sleep(10);

		if (SCARD_LEAVE_CARD == dwDisposition)	// 1st round
		{
			dwDisposition = SCARD_RESET_CARD;	// For the second round

Retry:
			dwWait = WaitForSingleObject(pxTD->hEvent, 6000);
			if (WAIT_OBJECT_0 == dwWait)		// The main thread verified the status
			{
				goto SecondRound;
			}
			else
			{
                PLOGCONTEXT pLogCtx = LogVerification(_T("WaitForSingleObject"), FALSE);
                LogString(pLogCtx, _T("                Waiting for the main thread failed, retrying!\n"));
                LogStop(pLogCtx, FALSE);
				goto Retry;
			}
		}

        dwRes = -2;      // Invalid error
    }
    __finally
    {
        if (dwRes == 0)
        {
            LogThisOnly(_T("Test3!AuthAndTest: an exception occurred!\n"), FALSE);
            dwRes = -1;
        }

		if (NULL != hScwCard)
		{
			LoghScwDetachFromCard(
				hScwCard,
				SCARD_S_SUCCESS
				);
		}

		if (fTransacted)
		{
			LogSCardEndTransaction(
				hCard,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != hCard)
		{
			LogSCardDisconnect(
				hCard,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
	}

    if (-2 == dwRes)
	{
        dwRes = 0;
	}

	return dwRes;
}

DWORD CTest3::Run()
{
    DWORD dwRes;
    SCARDCONTEXT hSCCtx = NULL;
	SCARDHANDLE hScwCard = NULL;
	const BYTE rgAtr[] =     {0x3b, 0xd7, 0x13, 0x00, 0x40, 0x3a, 0x57, 0x69, 0x6e, 0x43, 0x61, 0x72, 0x64};
	const BYTE rgAtrMask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
	const TCHAR szCardName[] = _T("SCWUnnamed\0");
    LPTSTR pmszCards = NULL;
    DWORD cch = SCARD_AUTOALLOCATE;
	BOOL fMyIntro = FALSE;
	OPENCARDNAME_EX xOCNX;
	TCHAR szRdrName[256];
	TCHAR szCard[256];
	THREAD_DATA xTD = {NULL, NULL};
	HANDLE hThread = NULL;
	BOOL fTransacted = FALSE;
	DWORD dwWait;

    __try {

			// Init for cleanup to work properly
		xOCNX.hCardHandle = NULL;

        dwRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            __leave;
        }

            // Is the card listed.
        dwRes = LogSCardListCards(
            hSCCtx,
            rgAtr,
			NULL,
			0,
            (LPTSTR)&pmszCards,
            &cch,
			SCARD_S_SUCCESS
			);
        if ((FAILED(dwRes)) || (0 == _tcslen(pmszCards)))
        {
			dwRes = LogSCardIntroduceCardType(
				hSCCtx,
				szCardName,
				NULL, NULL, 0,
				rgAtr,
				rgAtrMask,
				sizeof(rgAtr),
				SCARD_S_SUCCESS
				);
			if (FAILED(dwRes))
			{
				__leave;	// I won't be able to connect to the card.
			}

			fMyIntro = TRUE;
        }

		OPENCARD_SEARCH_CRITERIA xOPSCX;
		memset(&xOPSCX, 0, sizeof(OPENCARD_SEARCH_CRITERIA));
		xOPSCX.dwStructSize = sizeof(OPENCARD_SEARCH_CRITERIA);
		xOPSCX.lpstrGroupNames = (LPTSTR)g_szReaderGroups;
		if (NULL == g_szReaderGroups)
		{
			xOPSCX.nMaxGroupNames = 0;
		}
		else
		{
			xOPSCX.nMaxGroupNames = _tcslen(g_szReaderGroups + 2);
		}
		xOPSCX.lpstrCardNames = (LPTSTR)szCardName;
		xOPSCX.nMaxCardNames = sizeof(szCardName)/sizeof(TCHAR);
		xOPSCX.dwShareMode = SCARD_SHARE_SHARED;
		xOPSCX.dwPreferredProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;

		xOCNX.dwStructSize = sizeof(OPENCARDNAME_EX);
		xOCNX.hSCardContext = hSCCtx;
		xOCNX.hwndOwner = NULL;
		xOCNX.dwFlags = SC_DLG_MINIMAL_UI;
		xOCNX.lpstrTitle = NULL;
		xOCNX.lpstrSearchDesc = _T("Please insert a 1.1 WPSC with test user (PIN 1234)");
		xOCNX.hIcon = NULL;
		xOCNX.pOpenCardSearchCriteria = &xOPSCX;
		xOCNX.lpfnConnect = NULL;
		xOCNX.pvUserData = NULL;
		xOCNX.dwShareMode = SCARD_SHARE_SHARED;
		xOCNX.dwPreferredProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
		xOCNX.lpstrRdr = szRdrName;
		xOCNX.nMaxRdr = sizeof(szRdrName) / sizeof(TCHAR);
		xOCNX.lpstrCard = szCard;
		xOCNX.nMaxCard = sizeof(szCard) / sizeof(TCHAR);
		xOCNX.dwActiveProtocol = 0;
		xOCNX.hCardHandle = NULL;

		dwRes = LogSCardUIDlgSelectCard(
			&xOCNX,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            __leave;
        }

		dwRes = LoghScwAttachToCard(
			xOCNX.hCardHandle, 
			NULL, 
			&hScwCard, 
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
			__leave;
		}

		xTD.szReaderName = szRdrName;
		xTD.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (NULL == xTD.hEvent)
		{
			dwRes = GetLastError();
            __leave;
		}

		DWORD dwThreadId;

		hThread = CreateThread(
			NULL,					// SD
			0,						// initial stack size
			ThreadProc,				// thread function
			&xTD,					// thread argument
			CREATE_SUSPENDED,		// creation option
			&dwThreadId				// thread identifier
			);
		if (NULL == hThread)
		{
			dwRes = GetLastError();
            __leave;
		}

		ResumeThread(hThread);

				// Wait for the end of the first round
Again1st:
		dwWait = WaitForSingleObject(xTD.hEvent, 60000);	// 1 min, allowing some debugging
		if (WAIT_OBJECT_0 == dwWait)
		{
			dwRes = LogSCardBeginTransaction(
				xOCNX.hCardHandle,
				SCARD_S_SUCCESS
				);
			if (FAILED(dwRes))
			{
				__leave;
			}
			fTransacted = TRUE;

				// We can signal back to the other thread, the transaction mechanism
				// will insure the sync
			SetEvent(xTD.hEvent);

			dwRes = LoghScwIsAuthenticatedName(
				hScwCard,
				L"test",
				SCW_S_OK
				);
			if (FAILED(dwRes))
			{
				__leave;
			}

			dwRes = LogSCardEndTransaction(	// Releases the other thread
				xOCNX.hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
			fTransacted = FALSE;
			if (FAILED(dwRes))
			{
				__leave;
			}
		}
		else
		{
            PLOGCONTEXT pLogCtx = LogVerification(_T("WaitForSingleObject"), FALSE);
            LogString(pLogCtx, _T("                Waiting for the worker thread failed, retrying!\n"));
            LogStop(pLogCtx, FALSE);
			goto Again1st;
		}

				// Wait for the end of the second round
Again2nd:
		dwWait = WaitForSingleObject(xTD.hEvent, 60000);	// 1 min, allowing some debugging
		if (WAIT_OBJECT_0 == dwWait)
		{
			dwRes = LogSCardBeginTransaction(
				xOCNX.hCardHandle,
				SCARD_W_RESET_CARD
				);
RestartTrans:
			if (FAILED(dwRes))
			{
				if (SCARD_W_RESET_CARD == dwRes)
				{
					dwRes = LogSCardReconnect(
						xOCNX.hCardHandle,
						SCARD_SHARE_SHARED,
						SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
						SCARD_LEAVE_CARD,
						&xOCNX.dwActiveProtocol,
						SCARD_S_SUCCESS
						);
					if (FAILED(dwRes))
					{
						__leave;
					}

					dwRes = LogSCardBeginTransaction(
						xOCNX.hCardHandle,
						SCARD_S_SUCCESS
						);

					goto RestartTrans;
				}
				else
				{
					__leave;
				}
			}
			fTransacted = TRUE;

				// We can signal back to the other thread, the transaction mechanism
				// will insure the sync
			SetEvent(xTD.hEvent);

			dwRes = LoghScwIsAuthenticatedName(
				hScwCard,
				L"test",
				SCW_E_NOTAUTHENTICATED
				);
			if (FAILED(dwRes))
			{
				__leave;
			}

			dwRes = LogSCardEndTransaction(	// Releases the other thread
				xOCNX.hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
			fTransacted = FALSE;
			if (FAILED(dwRes))
			{
				__leave;
			}
		}
		else
		{
            PLOGCONTEXT pLogCtx = LogVerification(_T("WaitForSingleObject"), FALSE);
            LogString(pLogCtx, _T("                Waiting for the worker thread failed, retrying!\n"));
            LogStop(pLogCtx, FALSE);
			goto Again2nd;
		}

        dwRes = -2;      // Invalid error

    }
    __finally
    {
        if (dwRes == 0)
        {
            LogThisOnly(_T("Test3: an exception occurred!\n"), FALSE);
            dwRes = -1;
        }

		if (NULL != hThread)
		{
			dwWait = WaitForSingleObject(hThread, 50000);
			if (WAIT_OBJECT_0 == dwWait)
			{
				GetExitCodeThread(hThread, &dwRes);
			}
			else
			{
				// Why is this thread taking so long
				TerminateThread(hThread, -1);
				dwRes = -1;
			}
		}

		if (NULL != hScwCard)
		{
			LoghScwDetachFromCard(
				hScwCard,
				SCARD_S_SUCCESS
				);
		}

		if (fTransacted)
		{
			LogSCardEndTransaction(
				xOCNX.hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != xTD.hEvent)
		{
			CloseHandle(xTD.hEvent);
		}

		if (NULL != xOCNX.hCardHandle)
		{
			LogSCardDisconnect(
				xOCNX.hCardHandle,
				SCARD_RESET_CARD,
				SCARD_S_SUCCESS
				);
		}
 
		if (fMyIntro)
		{
			LogSCardForgetCardType(
				hSCCtx,
				szCardName,
				SCARD_S_SUCCESS
				);
		}

            // Cleanup
//        if (NULL != rgReaderStates)
//		{
//          HeapFree(GetProcessHeap(), 0, (LPVOID)rgReaderStates);
//		}

        if (NULL != pmszCards)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszCards,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    if (-2 == dwRes)
	{
        dwRes = 0;
	}

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\part.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Part

Abstract:

    Part implementation.
	A Part is a collection of individual tests.

Author:

    Eric Perlin (ericperl) 06/07/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "Part.h"
#include <algorithm>
#include "Log.h"


extern PPARTVECTOR g_pPartVector;

using namespace std;

CPart::CPart(
	LPCTSTR szDescription
	) :	CItem(FALSE, FALSE, szDescription) 
{
	g_pPartVector.push_back(this);
	SetTestNumber(g_pPartVector.size());
}

void CPart::AddTest(
	PTESTITEM pTest
	)
{
	m_TestBag.push_back(pTest);
}

DWORD CPart::Run()
{
	PTESTITEMVECTOR::iterator theIterator, theEnd;
	DWORD dwRet = 0;
    BOOL fOnce = FALSE;
    PLOGCONTEXT pLogCtx;

	theEnd = m_TestVector.end();
    for (theIterator = m_TestVector.begin(); theIterator != theEnd ; theIterator++)
	{
        if (!fOnce)
	    {       // Putting this here will ensure that only a part is only displayed if there
                // are tests to be run in it
		    pLogCtx = LogStart();
    		LogString(pLogCtx, _T("\n==============================================================================\n"));
            LogStop(pLogCtx, FALSE);
		    Log();
            pLogCtx = LogStart();
    		LogString(pLogCtx, _T("------------------------------------------------------------------------------\n"));
		    LogStop(pLogCtx, FALSE);
            fOnce = TRUE;
	    }

		(*theIterator)->Log();

		LogResetCounters();
		dwRet = (*theIterator)->Run();
        (*theIterator)->Cleanup();

		pLogCtx = LogStart();
		if (0 == LogGetErrorCounter())
		{
			LogString(pLogCtx, _T("--------------------------------------------------------------------- Passed -\n"));
		}
		else if (1 == LogGetErrorCounter())
		{
			LogString(pLogCtx, _T("-------------------------------------------------------------------- 1 ERROR -\n"));
		}
		else 
		{
			TCHAR szLine[100];
			_stprintf(szLine, 
				_T("----------------------------------------------------------------- %3ld ERRORS -\n"), 
				LogGetErrorCounter());
			LogString(pLogCtx, szLine);
		}
		LogStop(pLogCtx, FALSE);

		if (FAILED(dwRet) && (*theIterator)->IsFatal())
		{
			break;
		}
	}

	return dwRet;
}

void CPart::BuildListOfTestsToBeRun(
		BOOL fInteractive,		// Don't add the interactive test if FALSE
		DWORDVECTOR rgToRun		// If not empty only add the specified tests
		)
{
	DWORD count;
	PTESTITEMVECTOR::iterator theIterator, theEnd;

	theEnd = m_TestBag.end();
    for (theIterator = m_TestBag.begin(); theIterator != theEnd ; theIterator++)
	{
		if ((fInteractive == FALSE) && ((*theIterator)->IsInteractive()))
		{
			continue;
		}

		if (rgToRun.empty())
		{
			m_TestVector.push_back(*theIterator);
		}
		else
		{
			typedef DWORDVECTOR::iterator DWORDVECTORIT;
			DWORDVECTORIT location, start, end;

			start = rgToRun.begin();
			end = rgToRun.end();

			location = find(start, end, (DWORD)((*theIterator)->GetTestNumber()));
			if (location != end)
			{
				m_TestVector.push_back(*theIterator);
			}
		}
	}
}

void CPart::Display()
{
	PTESTITEMVECTOR::iterator theIterator, theEnd;

	Log();

	theEnd = m_TestVector.end();
    for (theIterator = m_TestVector.begin(); theIterator != theEnd ; theIterator++)
	{
		(*theIterator)->Log();
	}

}

void CPart::Log() const
{
    PLOGCONTEXT pLogCtx = LogStart();

	LogString(pLogCtx, _T("Part "));
	LogDecimal(pLogCtx, GetTestNumber());

	if (m_szDescription.empty())
	{
		LogString(pLogCtx, _T(": "), _T("No description"));
	}
	else
	{
		LogString(pLogCtx, _T(": "), m_szDescription.c_str());
	}

	LogStop(pLogCtx, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\part.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Part

Abstract:

    Part declaration.
	A Part is a collection of individual tests.

Author:

    Eric Perlin (ericperl) 06/07/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef _Part_H_DEF_
#define _Part_H_DEF_

#include "TestItem.h"
#include <vector>

typedef std::vector<DWORD> DWORDVECTOR;				// Dynamic vector of DWORDs

class CPart : public CItem
{
private:
	PTESTITEMVECTOR m_TestVector;		// Tests to be run

protected:
	PTESTITEMVECTOR m_TestBag;			// ALL tests belonging to this part

public:
	CPart(
		LPCTSTR szDescription
		);

	void AddTest(
		PTESTITEM pTest
		);

	void BuildListOfTestsToBeRun(
		BOOL fInteractive,		// Don't add the interactive test if FALSE
		DWORDVECTOR rgToRun		// If not empty only add the specified tests
		);

	DWORD Run();

	void Display();

	void Log() const;
};

typedef CPart *PPART;
typedef std::vector<PPART> PPARTVECTOR;				// Dynamic vector of CPart pointers

#endif	// _Part_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\sctest.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    SCTest

Abstract:

    This program performs some testing on the SC Resource Manager.

Author:

    Eric Perlin (ericperl) 05/31/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <tchar.h>

#include "Log.h"
#include "Part.h"
#include <algorithm>

#include "LogSCard.h"

using namespace std;


	// It might be used as reader groupS so the double ending 0 is necessary
static const TCHAR g_cszMyReaderGroup[] = _T("My Reader Group\0");

LPCTSTR g_szReaderGroups = NULL;
PPARTVECTOR g_pPartVector;

/*++

_tmain:

    This is the main entry point for the program.

Arguments:

    dwArgCount supplies the number of arguments.
    szrgArgs supplies the argument strings.

Return Value:

    0 if everything went fine, a win32 error code otherwise.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/

int _cdecl
_tmain(
    IN DWORD dwArgCount,
    IN LPCTSTR szrgArgs[])
{
	BOOL fInteractive = FALSE;			// Interactive tests run?
	DWORDVECTOR rgTests;				// List of tests to be run
	DWORDVECTOR rgParts;				// List of parts to be run
	BOOL fDisplay = FALSE;				// Only display test description?
	LPCTSTR szReaderName = NULL;		// Reader Name
	LPCTSTR szPIN = NULL;				// PIN
	LPCTSTR szLog = NULL;				// PIN
	BOOL fVerbose = FALSE;				// Verbose?
	BOOL fInitOnce = FALSE;				// Call LogInit only one
	BOOL fRGIntroed = FALSE;			// My Reader Group was introduced

	DWORD dwArg;
	int iRet;


    _ftprintf(stdout, _T("\nSCTest version 0.1\n\n"));

		// Argument parsing
	for (dwArg=1 ; dwArg < dwArgCount ; dwArg++)
	{
		if ((szrgArgs[dwArg][0] == (TCHAR)'-') || (szrgArgs[dwArg][0] == (TCHAR)'/'))
		{
			if (_tcsicmp(&szrgArgs[dwArg][1], _T("h")) == 0)
			{
				goto Usage;
			}
			else if (_tcsicmp(&szrgArgs[dwArg][1], _T("?")) == 0)
			{
				goto Usage;
			}
			else if (_tcsicmp(&szrgArgs[dwArg][1], _T("l")) == 0)
			{
				dwArg++;

				szLog = szrgArgs[dwArg];
			}
			else if (_tcsicmp(&szrgArgs[dwArg][1], _T("v")) == 0)
			{
				fVerbose = TRUE;
			}
			else
			{
				if (!fInitOnce)
				{
						// Init logging
					LogInit(szLog, fVerbose);
					fInitOnce = TRUE;
				}

				if (_tcsicmp(&szrgArgs[dwArg][1], _T("i")) == 0)
				{
					fInteractive = TRUE;
				}
				else if (_tcsicmp(&szrgArgs[dwArg][1], _T("a")) == 0)
				{
					dwArg++;

					DWORD dwPart;
					TCHAR szSeps[]   = _T(",");
					TCHAR *szToken;
					TCHAR *szEnd;

					szToken = _tcstok((TCHAR *)szrgArgs[dwArg], szSeps);
					while(szToken != NULL)
					{
						dwPart = _tcstoul(szToken, &szEnd, 10);
						if (*szEnd != (TCHAR)0)
						{
							_ftprintf(stderr, _T("Invalid Part number: %s\n"), szToken);
							iRet = -3;
							goto Usage;
						}

						rgParts.push_back(dwPart);

						szToken = _tcstok(NULL, szSeps);
					}
				}
				else if (_tcsicmp(&szrgArgs[dwArg][1], _T("t")) == 0)
				{
					dwArg++;

					DWORD dwTest;
					TCHAR szSeps[]   = _T(",");
					TCHAR *szToken;
					TCHAR *szEnd;

					szToken = _tcstok((TCHAR *)szrgArgs[dwArg], szSeps);
					while(szToken != NULL)
					{
						dwTest = _tcstoul(szToken, &szEnd, 10);
						if (*szEnd != (TCHAR)0)
						{
							_ftprintf(stderr, _T("Invalid test number: %s\n"), szToken);
							iRet = -5;
							goto Usage;
						}

						rgTests.push_back(dwTest);

						szToken = _tcstok(NULL, szSeps);
					}
				}
				else if (_tcsicmp(&szrgArgs[dwArg][1], _T("d")) == 0)
				{
					fDisplay = TRUE;
				}
				else if (_tcsicmp(&szrgArgs[dwArg][1], _T("r")) == 0)
				{
					dwArg++;

					szReaderName = szrgArgs[dwArg];

					{
						// Initialize the reader group(s) for this instance
						DWORD dwRes;
						SCARDCONTEXT hSCCtx = NULL;

						_ftprintf(stdout, _T("Reader group initialization\n"));

						dwRes = LogSCardEstablishContext(
							SCARD_SCOPE_USER,
							NULL,
							NULL,
							&hSCCtx,
							SCARD_S_SUCCESS
							);
						if (!FAILED(dwRes))
						{
							dwRes = LogSCardAddReaderToGroup(
								hSCCtx,
								szReaderName,
								g_cszMyReaderGroup,
								SCARD_S_SUCCESS
								);

							if (!FAILED(dwRes))
							{
								g_szReaderGroups = g_cszMyReaderGroup;
							}
						}
						if (NULL != hSCCtx)
						{
							fRGIntroed = TRUE;

							LogSCardReleaseContext(
								hSCCtx,
								SCARD_S_SUCCESS
								);
						}
					}
				}
				else if (_tcsicmp(&szrgArgs[dwArg][1], _T("p")) == 0)
				{
					dwArg++;

					szPIN = szrgArgs[dwArg];
				}
				else
				{
					_ftprintf(stderr, _T("Command line argument is not recognized: %s\n"), szrgArgs[dwArg]);
					iRet = -2;
					goto Usage;
				}
			}
		}
		else
		{
			_ftprintf(stderr, _T("Command line argument doesn't start with - or /: %s\n"), szrgArgs[dwArg]);
			iRet = -1;
			goto Usage;
		}
	}


	if (!fInitOnce)
	{
			// Init logging
		LogInit(szLog, fVerbose);
	}

	{
		PPARTVECTOR::iterator theIterator, theEnd;

		theEnd = g_pPartVector.end();
		for (theIterator = g_pPartVector.begin(); theIterator != theEnd ; theIterator++)
		{
			if (!rgParts.empty())
			{
				typedef DWORDVECTOR::iterator DWORDVECTORIT;
				DWORDVECTORIT location, start, end;

				start = rgParts.begin();
				end = rgParts.end();

				location = find(start, end, (DWORD)((*theIterator)->GetTestNumber()));
				if (location == end)
				{
					continue;
				}
			}
			(*theIterator)->BuildListOfTestsToBeRun(fDisplay? TRUE : fInteractive, rgTests);
			if (fDisplay)
			{
				(*theIterator)->Display();
			}
			else
			{
				(*theIterator)->Run();
			}

		}
	}

	iRet = 0;
	goto End;

Usage:
	_ftprintf(stdout, _T("Usage: "));
	{
		TCHAR *szExeName = _tcsrchr(szrgArgs[0], (int)'\\');
		if (NULL == szExeName)
		{
			_ftprintf(stdout, szrgArgs[0]);
		}
		else
		{
			_ftprintf(stdout, szExeName+1);
		}
		_ftprintf(stdout, _T("[-h] [-l log] [-v] [-i] [-a x[,x]] [-t y[,y]] [-d] [-r n] [-p PIN]\n"));
	}
	_ftprintf(stdout, _T("\tIf present, the -v & -l options must be listed first\n")); 
	_ftprintf(stdout, _T("\t-h or -? displays this message\n")); 
	_ftprintf(stdout, _T("\t-l indicates the name of the log file\n")); 
	_ftprintf(stdout, _T("\t-v indicates verbose output\n")); 
	_ftprintf(stdout, _T("\t-i indicates interactive tests shall be run\n")); 
	_ftprintf(stdout, _T("\t-a followed by comma separated part numbers will only run these tests\n")); 
	_ftprintf(stdout, _T("\t-t followed by comma separated test numbers will only run these tests\n")); 
	_ftprintf(stdout, _T("\t-d will only display the tests description\n"));
	_ftprintf(stdout, _T("\t-r specifies the reader name (n) to be used for the tests\n")); 
	_ftprintf(stdout, _T("\t-p specifies the PIN to be used for the tests\n")); 


End:
	if (fRGIntroed)
	{
		// Cleans up the reader group(s) for this instance
		DWORD dwRes;
		SCARDCONTEXT hSCCtx = NULL;

		_ftprintf(stdout, _T("\nReader group cleanup\n"));

		dwRes = LogSCardEstablishContext(
			SCARD_SCOPE_USER,
			NULL,
			NULL,
			&hSCCtx,
			SCARD_S_SUCCESS
			);

		if (!FAILED(dwRes))
		{
			dwRes = LogSCardForgetReaderGroup(
				hSCCtx,
				g_cszMyReaderGroup,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != hSCCtx)
		{
			LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
	}
		// We are done with logging
	LogClose();

	return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\test3savs.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test3

Abstract:

    Test3 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 07/13/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"
#include "LogWPSCProxy.h"

class CTest3 : public CTestItem
{
public:
	CTest3() : CTestItem(TRUE, FALSE,
		_T("Test of SCardEndTransaction with dispositions other than leave"),
		_T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest3 Test3;

typedef struct {
	LPCTSTR szReaderName;
	HANDLE hEvent;
} THREAD_DATA;


DWORD WINAPI ThreadProc(
	IN LPVOID lpParam
	)
{
	DWORD dwRes;
    SCARDCONTEXT hSCCtx = NULL;
	SCARDHANDLE hCard = NULL;
	SCARDHANDLE hScwCard = NULL;
	DWORD dwProtocol = 0;
	BOOL fTransacted = FALSE;
	THREAD_DATA *pxTD = (THREAD_DATA *)lpParam;
	DWORD dwDisposition = SCARD_LEAVE_CARD;
	DWORD dwWait;

    __try {
		dwRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            __leave;
        }

		dwRes = LogSCardConnect(
			hSCCtx,
			pxTD->szReaderName,
			SCARD_SHARE_SHARED,
			SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
			&hCard,
			&dwProtocol,
			SCARD_S_SUCCESS);
        if (FAILED(dwRes))
        {
            __leave;
        }

SecondRound:
		dwRes = LogSCardBeginTransaction(
			hCard,
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
            __leave;
		}
		fTransacted = TRUE;

		dwRes = LoghScwAttachToCard(
			hCard, 
			NULL, 
			&hScwCard, 
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
            __leave;
		}

		dwRes = LoghScwAuthenticateName(
			hScwCard,
			L"test",
			(BYTE *)"1234",
			4,
			SCW_S_OK
			);
		if (FAILED(dwRes))
		{
            __leave;
		}

		dwRes = LoghScwIsAuthenticatedName(
			hScwCard,
			L"test",
			SCW_S_OK
			);
		if (FAILED(dwRes))
		{
            __leave;
		}

		LoghScwDetachFromCard(
			hScwCard,
			SCARD_S_SUCCESS
			);
		hScwCard = NULL;

		dwRes = LogSCardEndTransaction(
			hCard,
			dwDisposition,
			SCARD_S_SUCCESS
			);
		fTransacted = FALSE;
		if (FAILED(dwRes))
		{
            __leave;
		}

		SetEvent(pxTD->hEvent);				// Will release the main thread

		Sleep(10);

		if (SCARD_LEAVE_CARD == dwDisposition)	// 1st round
		{
			dwDisposition = SCARD_RESET_CARD;	// For the second round

Retry:
			dwWait = WaitForSingleObject(pxTD->hEvent, 6000);
			if (WAIT_OBJECT_0 == dwWait)		// The main thread verified the status
			{
				goto SecondRound;
			}
			else
			{
	            LogThisOnly(_T("Test3!AuthAndTest: waiting for the main thread failed, retrying!\n"), FALSE);
				goto Retry;
			}
		}

        dwRes = -2;      // Invalid error
    }
    __finally
    {
        if (dwRes == 0)
        {
            LogThisOnly(_T("Test3!AuthAndTest: an exception occurred!\n"), FALSE);
            dwRes = -1;
        }

		if (NULL != hScwCard)
		{
			LoghScwDetachFromCard(
				hScwCard,
				SCARD_S_SUCCESS
				);
		}

		if (fTransacted)
		{
			LogSCardEndTransaction(
				hCard,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != hCard)
		{
			LogSCardDisconnect(
				hCard,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
	}

    if (-2 == dwRes)
	{
        dwRes = 0;
	}

	return dwRes;
}

DWORD CTest3::Run()
{
    DWORD dwRes;
    SCARDCONTEXT hSCCtx = NULL;
	SCARDHANDLE hScwCard = NULL;
	const BYTE rgAtr[] =     {0x3b, 0xd7, 0x13, 0x00, 0x40, 0x3a, 0x57, 0x69, 0x6e, 0x43, 0x61, 0x72, 0x64};
	const BYTE rgAtrMask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
	const TCHAR szCardName[] = _T("SCWUnnamed\0");
    LPTSTR pmszCards = NULL;
    DWORD cch = SCARD_AUTOALLOCATE;
	BOOL fMyIntro = FALSE;
	OPENCARDNAME_EX xOCNX;
	TCHAR szRdrName[256];
	TCHAR szCard[256];
	THREAD_DATA xTD = {NULL, NULL};
	HANDLE hThread = NULL;
	BOOL fTransacted = FALSE;
	DWORD dwWait;

    __try {

			// Init for cleanup to work properly
		xOCNX.hCardHandle = NULL;

        dwRes = LogSCardEstablishContext(
            SCARD_SCOPE_SYSTEM,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            __leave;
        }

            // Is the card listed.
        dwRes = LogSCardListCards(
            hSCCtx,
            rgAtr,
			NULL,
			0,
            (LPTSTR)&pmszCards,
            &cch,
			SCARD_S_SUCCESS
			);
        if ((FAILED(dwRes)) || (0 == _tcslen(pmszCards)))
        {
			dwRes = LogSCardIntroduceCardType(
				hSCCtx,
				szCardName,
				NULL, NULL, 0,
				rgAtr,
				rgAtrMask,
				sizeof(rgAtr),
				SCARD_S_SUCCESS
				);
			if (FAILED(dwRes))
			{
				__leave;	// I won't be able to connect to the card.
			}

			fMyIntro = TRUE;
        }

		OPENCARD_SEARCH_CRITERIA xOPSCX;
		memset(&xOPSCX, 0, sizeof(OPENCARD_SEARCH_CRITERIA));
		xOPSCX.dwStructSize = sizeof(OPENCARD_SEARCH_CRITERIA);
		xOPSCX.lpstrGroupNames = (LPTSTR)g_szReaderGroups;
		if (NULL == g_szReaderGroups)
		{
			xOPSCX.nMaxGroupNames = 0;
		}
		else
		{
			xOPSCX.nMaxGroupNames = _tcslen(g_szReaderGroups + 2);
		}
		xOPSCX.lpstrCardNames = (LPTSTR)szCardName;
		xOPSCX.nMaxCardNames = sizeof(szCardName)/sizeof(TCHAR);
		xOPSCX.dwShareMode = SCARD_SHARE_SHARED;
		xOPSCX.dwPreferredProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;

		xOCNX.dwStructSize = sizeof(OPENCARDNAME_EX);
		xOCNX.hSCardContext = hSCCtx;
		xOCNX.hwndOwner = NULL;
		xOCNX.dwFlags = SC_DLG_MINIMAL_UI;
		xOCNX.lpstrTitle = NULL;
		xOCNX.lpstrSearchDesc = _T("Please insert a 1.1 WPSC with test user (PIN 1234)");
		xOCNX.hIcon = NULL;
		xOCNX.pOpenCardSearchCriteria = &xOPSCX;
		xOCNX.lpfnConnect = NULL;
		xOCNX.pvUserData = NULL;
		xOCNX.dwShareMode = SCARD_SHARE_SHARED;
		xOCNX.dwPreferredProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
		xOCNX.lpstrRdr = szRdrName;
		xOCNX.nMaxRdr = sizeof(szRdrName) / sizeof(TCHAR);
		xOCNX.lpstrCard = szCard;
		xOCNX.nMaxCard = sizeof(szCard) / sizeof(TCHAR);
		xOCNX.dwActiveProtocol = 0;
		xOCNX.hCardHandle = NULL;

		dwRes = LogSCardUIDlgSelectCard(
			&xOCNX,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            __leave;
        }

		dwRes = LoghScwAttachToCard(
			xOCNX.hCardHandle, 
			NULL, 
			&hScwCard, 
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
			__leave;
		}

		xTD.szReaderName = szRdrName;
		xTD.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (NULL == xTD.hEvent)
		{
			dwRes = GetLastError();
            __leave;
		}

		DWORD dwThreadId;

		hThread = CreateThread(
			NULL,					// SD
			0,						// initial stack size
			ThreadProc,				// thread function
			&xTD,					// thread argument
			CREATE_SUSPENDED,		// creation option
			&dwThreadId				// thread identifier
			);
		if (NULL == hThread)
		{
			dwRes = GetLastError();
            __leave;
		}

		ResumeThread(hThread);

				// Wait for the end of the first round
Again1st:
		dwWait = WaitForSingleObject(xTD.hEvent, 60000);	// 1 min, allowing some debugging
		if (WAIT_OBJECT_0 == dwWait)
		{
			dwRes = LogSCardBeginTransaction(
				xOCNX.hCardHandle,
				SCARD_S_SUCCESS
				);
			if (FAILED(dwRes))
			{
				__leave;
			}
			fTransacted = TRUE;

				// We can signal back to the other thread, the transaction mechanism
				// will insure the sync
			SetEvent(xTD.hEvent);

			dwRes = LoghScwIsAuthenticatedName(
				hScwCard,
				L"test",
				SCW_S_OK
				);
			if (FAILED(dwRes))
			{
				__leave;
			}

			dwRes = LogSCardEndTransaction(	// Releases the other thread
				xOCNX.hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
			fTransacted = FALSE;
			if (FAILED(dwRes))
			{
				__leave;
			}
		}
		else
		{
	        LogThisOnly(_T("Test3! waiting for the worker thread failed, retrying!\n"), FALSE);
			goto Again1st;
		}

				// Wait for the end of the second round
Again2nd:
		dwWait = WaitForSingleObject(xTD.hEvent, 60000);	// 1 min, allowing some debugging
		if (WAIT_OBJECT_0 == dwWait)
		{
			dwRes = LogSCardBeginTransaction(
				xOCNX.hCardHandle,
				SCARD_W_RESET_CARD
				);
RestartTrans:
			if (FAILED(dwRes))
			{
				if (SCARD_W_RESET_CARD == dwRes)
				{
					dwRes = LogSCardReconnect(
						xOCNX.hCardHandle,
						SCARD_SHARE_SHARED,
						SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
						SCARD_LEAVE_CARD,
						&xOCNX.dwActiveProtocol,
						SCARD_S_SUCCESS
						);
					if (FAILED(dwRes))
					{
						__leave;
					}

					dwRes = LogSCardBeginTransaction(
						xOCNX.hCardHandle,
						SCARD_S_SUCCESS
						);

					goto RestartTrans;
				}
				else
				{
					__leave;
				}
			}
			fTransacted = TRUE;

				// We can signal back to the other thread, the transaction mechanism
				// will insure the sync
			SetEvent(xTD.hEvent);

			dwRes = LoghScwIsAuthenticatedName(
				hScwCard,
				L"test",
				SCW_E_NOTAUTHENTICATED
				);
			if (FAILED(dwRes))
			{
				__leave;
			}

			dwRes = LogSCardEndTransaction(	// Releases the other thread
				xOCNX.hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
			fTransacted = FALSE;
			if (FAILED(dwRes))
			{
				__leave;
			}
		}
		else
		{
	        LogThisOnly(_T("Test3! waiting for the worker thread failed, retrying!\n"), FALSE);
			goto Again2nd;
		}

        dwRes = -2;      // Invalid error

    }
    __finally
    {
        if (dwRes == 0)
        {
            LogThisOnly(_T("Test3: an exception occurred!\n"), FALSE);
            dwRes = -1;
        }

		if (NULL != hThread)
		{
			dwWait = WaitForSingleObject(hThread, 50000);
			if (WAIT_OBJECT_0 == dwWait)
			{
				GetExitCodeThread(hThread, &dwRes);
			}
			else
			{
				// Why is this thread taking so long
				TerminateThread(hThread, -1);
				dwRes = -1;
			}
		}

		if (NULL != hScwCard)
		{
			LoghScwDetachFromCard(
				hScwCard,
				SCARD_S_SUCCESS
				);
		}

		if (fTransacted)
		{
			LogSCardEndTransaction(
				xOCNX.hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != xTD.hEvent)
		{
			CloseHandle(xTD.hEvent);
		}

		if (NULL != xOCNX.hCardHandle)
		{
			LogSCardDisconnect(
				xOCNX.hCardHandle,
				SCARD_RESET_CARD,
				SCARD_S_SUCCESS
				);
		}
 
		if (fMyIntro)
		{
			LogSCardForgetCardType(
				hSCCtx,
				szCardName,
				SCARD_S_SUCCESS
				);
		}

            // Cleanup
//        if (NULL != rgReaderStates)
//		{
//          HeapFree(GetProcessHeap(), 0, (LPVOID)rgReaderStates);
//		}

        if (NULL != pmszCards)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszCards,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    if (-2 == dwRes)
	{
        dwRes = 0;
	}

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\test4.h ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"

class CTest4 : public CTestItem
{
private:
    BOOL fIntroed;

public:
	CTest4() : CTestItem(FALSE, FALSE, _T("SCardIntroduceCard SCWUnnamed in user scope"),
        _T("Positive database management"))
	{
        fIntroed = FALSE;
	}

	DWORD Run();

    DWORD Cleanup();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\test5.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test5

Abstract:

    Test5 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"
#include <conio.h>

class CTest5 : public CTestItem
{
public:
	CTest5() : CTestItem(TRUE, FALSE, _T("AccessStartedEvent simple test"), _T("On demand tests"))
	{
	}

	DWORD Run();
};

CTest5 Test5;

DWORD CTest5::Run()
{
    LONG lRes;
    HANDLE hEvent = NULL;

    __try {

        hEvent = LogSCardAccessStartedEvent(
			SCARD_S_SUCCESS
			);
        if (NULL == hEvent)
        {
			lRes = GetLastError();
            __leave;
        }

		_ftprintf(stdout, _T("Press a key to cancel the waiting loop...\n"));
		do
		{
			lRes = WaitForSingleObjectEx(
				hEvent,
				5000,
				FALSE
				);         

			if (_kbhit())
			{
	            break;
			}

			_ftprintf(stdout, _T("Waiting for smart card subsystem...\n"));

		} while (lRes == WAIT_TIMEOUT);

        lRes = -2;      // Invalid error

    }
    __finally
    {
        if (lRes == 0)
        {
            LogThisOnly(_T("Test5: an exception occurred!"), FALSE);
            lRes = -1;
        }
    }

    if (-2 == lRes)
	{
        lRes = 0;
	}

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\test7.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test7

Abstract:

    Test7 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "Test4.h"
#include <stdlib.h>
#include "LogSCard.h"

const LPCTSTR szMyReadersName = _T("My New Reader Name");
const LPCTSTR szMyReadersKey  = _T("SOFTWARE\\Microsoft\\Cryptography\\Calais\\Readers");

class CTest7 : public CTestItem
{
public:
	CTest7() : CTestItem(FALSE, FALSE, _T("SCardIntroduceReader API regression"),
		_T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest7 Test7;
extern CTest4 Test4;

DWORD CTest7::Run()
{
    LONG lRes;
    SCARDCONTEXT hSCCtx = NULL;
    LPTSTR pmszReaders = NULL;
    LPTSTR pReader;
    LPSCARD_READERSTATE rgReaderStates = NULL;
	LPBYTE lpbyAttr = NULL;
    DWORD cch = SCARD_AUTOALLOCATE;
    DWORD dwReaderCount, i;
	SCARDHANDLE hCardHandle = NULL;
    HKEY hMyReadersKey = NULL;
    HKEY hMyNewReaderKey = NULL;

    __try {

        lRes = Test4.Run();
        if (FAILED(lRes))
        {
            __leave;
        }

        // Initial cleanup in case of previous aborted tests
        lRes = RegOpenKeyEx(
            HKEY_CURRENT_USER,
            szMyReadersKey,
            0,
            KEY_ALL_ACCESS,
            &hMyReadersKey);
        if (ERROR_SUCCESS == lRes)
        {
            // The key exists, delete MyReaderName
            RegDeleteKey(hMyReadersKey, szMyReadersName);
            RegCloseKey(hMyReadersKey);
            hMyReadersKey = NULL;
        }

        lRes = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            szMyReadersKey,
            0,
            KEY_ALL_ACCESS,
            &hMyReadersKey);
        if (ERROR_SUCCESS == lRes)
        {
            // The key exists, delete MyReaderName
            LONG lTemp = RegDeleteKey(hMyReadersKey, szMyReadersName);
            RegCloseKey(hMyReadersKey);
            hMyReadersKey = NULL;
        }
        else
        {
            PLOGCONTEXT pLogCtx = LogStart();
            LogString(pLogCtx, 
                _T("WARNING:        The resulting key couldn't be opened with all access:\n                HKCU\\"),
                szMyReadersKey);
            LogStop(pLogCtx, FALSE);
        }


        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            __leave;
        }

            // Retrieve the list the readers.
        lRes = LogSCardListReaders(
            hSCCtx,
            g_szReaderGroups,
            (LPTSTR)&pmszReaders,
            &cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            __leave;
        }

            // Display the list of readers
        pReader = pmszReaders;
        dwReaderCount = 0;
        while ( (TCHAR)'\0' != *pReader )
        {
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            dwReaderCount++;
        }

        if (dwReaderCount == 0)
        {
            LogThisOnly(_T("Reader count is zero!!!, terminating!\n"), FALSE);
            lRes = SCARD_F_UNKNOWN_ERROR;   // Shouldn't happen
            __leave;
        }

        rgReaderStates = (LPSCARD_READERSTATE)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            sizeof(SCARD_READERSTATE) * dwReaderCount
            );
        if (rgReaderStates == NULL)
        {
            LogThisOnly(_T("Allocating the array of SCARD_READERSTATE failed, terminating!\n"), FALSE);
            lRes = ERROR_OUTOFMEMORY;
            __leave;
        }

            // Setup the SCARD_READERSTATE array
        pReader = pmszReaders;
        cch = 0;
        while ( '\0' != *pReader )
        {
            rgReaderStates[cch].szReader = pReader;
            rgReaderStates[cch].dwCurrentState = SCARD_STATE_UNAWARE;
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            cch++;
        }

        lRes = LogSCardLocateCards(
            hSCCtx,
            _T("SCWUnnamed\0"),
            rgReaderStates,
            cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            __leave;
        }

        for (i=0 ; i<dwReaderCount ; i++)
        {
            if ((rgReaderStates[i].dwEventState & SCARD_STATE_PRESENT) &&
                !(rgReaderStates[i].dwEventState & SCARD_STATE_EXCLUSIVE))
            {
                DWORD dwProtocol;

		        lRes = LogSCardConnect(
			        hSCCtx,
			        rgReaderStates[i].szReader,
			        SCARD_SHARE_SHARED,
			        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
			        &hCardHandle,
			        &dwProtocol,
			        SCARD_S_SUCCESS);
                if (FAILED(lRes))
                {
                    __leave;
                }

                cch = SCARD_AUTOALLOCATE;
                lpbyAttr = NULL;
		        lRes = LogSCardGetAttrib(
			        hCardHandle,
			        SCARD_ATTR_DEVICE_SYSTEM_NAME,
			        (LPBYTE)(&lpbyAttr),
			        &cch,
			        SCARD_S_SUCCESS
                    );
                if (FAILED(lRes))
                {
                    __leave;
                }

                // Add the reader name.
                lRes = LogSCardIntroduceReader(
                    hSCCtx,
                    szMyReadersName,
                    (LPCTSTR)lpbyAttr,
                    SCARD_S_SUCCESS
                    );
                if (FAILED(lRes))
                {
                    __leave;
                }

                lRes = RegOpenKeyEx(
                    HKEY_CURRENT_USER,
                    szMyReadersKey,
                    0,
                    KEY_READ,
                    &hMyReadersKey);

                if (ERROR_SUCCESS == lRes)
                {
                    lRes = RegOpenKeyEx(
                        hMyReadersKey,
                        szMyReadersName,
                        0,
                        KEY_READ,
                        &hMyNewReaderKey);

                    if (ERROR_SUCCESS == lRes)
                    {
                        PLOGCONTEXT pLogCtx = LogVerification(_T("Registry verification"), TRUE);
                        LogStop(pLogCtx, TRUE);
                    }
                    else
                    {
                        lRes = -1;
                        PLOGCONTEXT pLogCtx = LogVerification(_T("Registry verification"), FALSE);
                        LogString(pLogCtx, _T("                The resulting key couldn't be found:\n                HKCU\\"));
                        LogString(pLogCtx, szMyReadersKey);
                        LogString(pLogCtx, _T("\\"), szMyReadersName);
                        LogStop(pLogCtx, FALSE);
                    }
                }
                else
                {
                    lRes = -1;
                    PLOGCONTEXT pLogCtx = LogVerification(_T("Registry verification"), FALSE);
                    LogString(pLogCtx, _T("                The resulting key couldn't be found:\n                HKCU\\"), szMyReadersKey);
                    LogStop(pLogCtx, FALSE);
                }

                    // Test Cleanup
                lRes = LogSCardForgetReader(
                    hSCCtx,
                    szMyReadersName,
                    SCARD_S_SUCCESS
                    );

                break; 
            }
        }

        if (i == dwReaderCount)
        {
            lRes = -1;
            PLOGCONTEXT pLogCtx = LogVerification(_T("Card presence verification"), FALSE);
            LogString(pLogCtx, _T("                A card is required and none could be found in any reader!\n"));
            LogStop(pLogCtx, FALSE);
        }

        lRes = -2;      // Invalid error

    }
    __finally
    {
        if (lRes == 0)
        {
            LogThisOnly(_T("Test7: an exception occurred!"), FALSE);
            lRes = -1;
        }

        Test4.Cleanup();

        if (NULL != hMyReadersKey)
        {
            RegCloseKey(hMyReadersKey);
        }
        if (NULL != hMyNewReaderKey)
        {
            RegCloseKey(hMyNewReaderKey);
        }

        if (NULL != lpbyAttr)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)lpbyAttr,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != hCardHandle)
		{
			LogSCardDisconnect(
				hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}
 
        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    if (-2 == lRes)
	{
        lRes = 0;
	}

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\test4.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test4

Abstract:

    Test4 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/


#include "Test4.h"
#include <stdlib.h>
#include "LogSCard.h"

const LPCTSTR szMyCardsKey  = _T("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCards");
const LPCTSTR szCardName = _T("SCWUnnamed\0");

CTest4 Test4;

DWORD CTest4::Run()
{
    LONG lRes;
    SCARDCONTEXT hSCCtx = NULL;
	const BYTE rgAtr[] =     {0x3b, 0xd7, 0x13, 0x00, 0x40, 0x3a, 0x57, 0x69, 0x6e, 0x43, 0x61, 0x72, 0x64};
	const BYTE rgAtrMask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    LPTSTR pmszCards = NULL;
    DWORD cch = SCARD_AUTOALLOCATE;
    HKEY hMyCardsKey = NULL;
    HKEY hMyNewCardKey = NULL;

    __try {

        // Initial cleanup in case of previous aborted tests
        lRes = RegOpenKeyEx(
            HKEY_CURRENT_USER,
            szMyCardsKey,
            0,
            KEY_ALL_ACCESS,
            &hMyCardsKey);
        if (ERROR_SUCCESS == lRes)
        {
            // The key exists, delete szCardName
            RegDeleteKey(hMyCardsKey, szCardName);
            RegCloseKey(hMyCardsKey);
            hMyCardsKey = NULL;
        }

        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            __leave;
        }

		lRes = LogSCardIntroduceCardType(
			hSCCtx,
			szCardName,
			NULL, NULL, 0,
			rgAtr,
			rgAtrMask,
			sizeof(rgAtr),
			SCARD_S_SUCCESS
			);
		if (FAILED(lRes))
		{
			__leave;
		}

        fIntroed = TRUE;

        lRes = RegOpenKeyEx(
            HKEY_CURRENT_USER,
            szMyCardsKey,
            0,
            KEY_READ,
            &hMyCardsKey);

        if (ERROR_SUCCESS == lRes)
        {
            lRes = RegOpenKeyEx(
                hMyCardsKey,
                szCardName,
                0,
                KEY_READ,
                &hMyNewCardKey);
            if (ERROR_SUCCESS == lRes)
            {
                PLOGCONTEXT pLogCtx = LogVerification(_T("Registry verification"), TRUE);
                LogStop(pLogCtx, TRUE);
            }
            else
            {
                lRes = -1;
                PLOGCONTEXT pLogCtx = LogVerification(_T("Registry verification"), FALSE);
                LogString(pLogCtx, _T("                The resulting key couldn't be found:\n                HKCU\\"));
                LogString(pLogCtx, szMyCardsKey);
                LogString(pLogCtx, _T("\\"), szCardName);
                LogStop(pLogCtx, FALSE);
            }
        }
        else
        {
            PLOGCONTEXT pLogCtx = LogVerification(_T("Registry verification"), FALSE);
            LogString(pLogCtx, _T("                The resulting key couldn't be found:\n                HKCU\\"), szMyCardsKey);
            LogStop(pLogCtx, FALSE);
        }

            // Is the card listed (can actually work even if registry verif fails as
            // the card could be listed in SYSTEM scope)
        lRes = LogSCardListCards(
            hSCCtx,
            rgAtr,
			NULL,
			0,
            (LPTSTR)&pmszCards,
            &cch,
			SCARD_S_SUCCESS
			);

        lRes = -2;      // Invalid error

    }
    __finally
    {
        if (lRes == 0)
        {
            LogThisOnly(_T("Test4: an exception occurred!"), FALSE);
            lRes = -1;
        }

        if (NULL != hMyCardsKey)
        {
            RegCloseKey(hMyCardsKey);
        }
        if (NULL != hMyNewCardKey)
        {
            RegCloseKey(hMyNewCardKey);
        }

        if (NULL != pmszCards)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszCards,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    if (-2 == lRes)
	{
        lRes = 0;
	}

    return lRes;
}

DWORD CTest4::Cleanup()
{
    LONG lRes = 0;
    SCARDCONTEXT hSCCtx = NULL;

    if (fIntroed)
    {
        __try {

            lRes = LogSCardEstablishContext(
                SCARD_SCOPE_USER,
                NULL,
                NULL,
                &hSCCtx,
			    SCARD_S_SUCCESS
			    );
            if (FAILED(lRes))
            {
                __leave;
            }

		    lRes = LogSCardForgetCardType(
			    hSCCtx,
			    szCardName,
			    SCARD_S_SUCCESS
			    );

            lRes = -2;      // Invalid error

        }
        __finally
        {
            if (lRes == 0)
            {
                LogThisOnly(_T("Test4: an exception occurred!"), FALSE);
                lRes = -1;
            }

            if (NULL != hSCCtx)
		    {
                LogSCardReleaseContext(
				    hSCCtx,
				    SCARD_S_SUCCESS
				    );
		    }
        }

        if (-2 == lRes)
	    {
            lRes = 0;
	    }
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\testitem.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    TestItem

Abstract:

    Virtual test item declaration.

Author:

    Eric Perlin (ericperl) 06/07/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/


#ifndef _TestItem_H_DEF_
#define _TestItem_H_DEF_

#include "tchar.h"
#include "TString.h"
#include "Item.h"
#include <vector>

class CTestItem : public CItem
{
public:
	CTestItem(
		BOOL fInteractive,
		BOOL fFatal,
		LPCTSTR szDescription,
		LPCTSTR szPart
		);

	virtual DWORD Run() = 0;
	virtual DWORD Cleanup();
};

typedef CTestItem *PTESTITEM;						// Pointer to a test item
typedef std::vector<PTESTITEM> PTESTITEMVECTOR;		// Dynamic vector of CTestItem pointers


#endif // _TestItem_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\testitem.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    TestItem

Abstract:

    Virtual test item implementation.

Author:

    Eric Perlin (ericperl) 06/07/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include "Part.h"
#include "Log.h"

extern PPARTVECTOR g_pPartVector;

static DWORD l_dwTestCounter = 0;

using namespace std;

CTestItem::CTestItem(
	BOOL fInteractive,
	BOOL fFatal,
	LPCTSTR szDescription,
	LPCTSTR szPart
	) :	CItem(fInteractive, fFatal, szDescription)
{
	PPARTVECTOR::iterator theIterator, theEnd;
	BOOL fExisted = FALSE;

	SetTestNumber(++l_dwTestCounter);

	theEnd = g_pPartVector.end();
	for (theIterator = g_pPartVector.begin(); theIterator != theEnd ; theIterator++)
	{
		if (_tcscmp( ((*theIterator)->GetDescription()), szPart ) == 0)
		{
			(*theIterator)->AddTest(this);
			fExisted = TRUE;
			break;
		}
	}

	if (!fExisted)
	{
		PPART pNewPart = new CPart(szPart);
		if (pNewPart)
		{
			pNewPart->AddTest(this);
		}
	}
}

DWORD CTestItem::Cleanup()
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\test6.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test6

Abstract:

    Test6 implementation.

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include <stdio.h>
#include "LogSCard.h"

class CTest6 : public CTestItem
{
public:
	CTest6() : CTestItem(FALSE, FALSE, _T("Regression of SCardGetAttrib (D & F)"),
		_T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest6 Test6;

DWORD CTest6::Run()
{
    LONG lRes;
    SCARDCONTEXT hSCCtx = NULL;
    LPTSTR pmszReaders = NULL;
    LPTSTR pReader;
    LPSCARD_READERSTATE rgReaderStates = NULL;
	LPBYTE lpbyAttr = NULL;
    DWORD cch = SCARD_AUTOALLOCATE;
    DWORD dwReaderCount, i;
	SCARDHANDLE hCardHandle = NULL;
    BOOL fAtLeastOneCard = FALSE;

    __try {


        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            __leave;
        }

            // Retrieve the list the readers.
        lRes = LogSCardListReaders(
            hSCCtx,
            g_szReaderGroups,
            (LPTSTR)&pmszReaders,
            &cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            __leave;
        }

            // Display the list of readers
        pReader = pmszReaders;
        dwReaderCount = 0;
        while ( (TCHAR)'\0' != *pReader )
        {
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            dwReaderCount++;
        }

        if (dwReaderCount == 0)
        {
            PLOGCONTEXT pLogCtx = LogVerification(_T("Reader presence verification"), FALSE);
            LogString(pLogCtx, _T("                A reader is required and none could be found!\n"));
            LogStop(pLogCtx, FALSE);
            lRes = SCARD_F_UNKNOWN_ERROR;   // Shouldn't happen
            __leave;
        }

        rgReaderStates = (LPSCARD_READERSTATE)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            sizeof(SCARD_READERSTATE) * dwReaderCount
            );
        if (rgReaderStates == NULL)
        {
            PLOGCONTEXT pLogCtx = LogVerification(_T("HeapAlloc"), FALSE);
            LogString(pLogCtx, _T("                Allocating the array of SCARD_READERSTATE failed!\n"));
            LogStop(pLogCtx, FALSE);
            lRes = ERROR_OUTOFMEMORY;
            __leave;
        }

            // Setup the SCARD_READERSTATE array
        pReader = pmszReaders;
        cch = 0;
        while ( '\0' != *pReader )
        {
            rgReaderStates[cch].szReader = pReader;
            rgReaderStates[cch].dwCurrentState = SCARD_STATE_UNAWARE;
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            cch++;
        }

        lRes = LogSCardLocateCards(
            hSCCtx,
            _T("Schlumberger Cryptoflex 4k\0"),     // Any card would do...
            rgReaderStates,
            cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            __leave;
        }

        for (i=0 ; i<dwReaderCount ; i++)
        {
            if ((rgReaderStates[i].dwEventState & SCARD_STATE_PRESENT) &&
                !(rgReaderStates[i].dwEventState & SCARD_STATE_EXCLUSIVE))
            {
                DWORD dwProtocol;

                fAtLeastOneCard = TRUE;

		        lRes = LogSCardConnect(
			        hSCCtx,
			        rgReaderStates[i].szReader,
			        SCARD_SHARE_SHARED,
			        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
			        &hCardHandle,
			        &dwProtocol,
			        SCARD_S_SUCCESS);
                if (FAILED(lRes))
                {
                    __leave;
                }

                cch = SCARD_AUTOALLOCATE;
                lpbyAttr = NULL;
		        lRes = LogSCardGetAttrib(
			        hCardHandle,
			        SCARD_ATTR_ATR_STRING,
			        (LPBYTE)(&lpbyAttr),
			        &cch,
			        SCARD_S_SUCCESS
                    );

                if (NULL != lpbyAttr)
		        {
                    LogSCardFreeMemory(
				        hSCCtx, 
				        (LPCVOID)lpbyAttr,
				        SCARD_S_SUCCESS
				        );
		        }

                for (DWORD a = SCARD_ATTR_CURRENT_PROTOCOL_TYPE ; a <= SCARD_ATTR_EXTENDED_BWT ; a++)
                {
                    if (dwProtocol == SCARD_PROTOCOL_T0)
                    {
                        if (a >= SCARD_ATTR_CURRENT_IFSC)
                            break;
                    }

                    cch = SCARD_AUTOALLOCATE;
                    lpbyAttr = NULL;
		            lRes = LogSCardGetAttrib(
			            hCardHandle,
			            a,
			            (LPBYTE)(&lpbyAttr),
			            &cch,
			            SCARD_S_SUCCESS
                        );

                    if (NULL != lpbyAttr)
		            {
                        LogSCardFreeMemory(
				            hSCCtx, 
				            (LPCVOID)lpbyAttr,
				            SCARD_S_SUCCESS
				            );
		            }

                }

		        if (NULL != hCardHandle)
		        {
			        LogSCardDisconnect(
				        hCardHandle,
				        SCARD_LEAVE_CARD,
				        SCARD_S_SUCCESS
				        );

                    hCardHandle = NULL;
		        }
 
            }
        }

        if (!fAtLeastOneCard)
        {
            lRes = -1;
            PLOGCONTEXT pLogCtx = LogVerification(_T("Card presence verification"), FALSE);
            LogString(pLogCtx, _T("                A card is required and none could be found in any reader!\n"));
            LogStop(pLogCtx, FALSE);
        }

        lRes = -2;      // Invalid error

    }
    __finally
    {
        if (lRes == 0)
        {
            LogThisOnly(_T("Test6: an exception occurred!"), FALSE);
            lRes = -1;
        }

		if (NULL != hCardHandle)
		{
			LogSCardDisconnect(
				hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}
 
        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    if (-2 == lRes)
	{
        lRes = 0;
	}

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\testyyy.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Testyyy

Abstract:

    Testyyy implementation.

Author:

    Eric Perlin (ericperl) 10/18/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"

class CTestyyy : public CTestItem
{
public:
	CTestyyy() : CTestItem(FALSE, FALSE, _T("Default Name"), _T("Default Part"))
	{
	}

	DWORD Run();
};

CTestyyy Testyyy;

DWORD CTestyyy::Run()
{
    LONG lRes;
    SCARDCONTEXT hSCCtx = NULL;

    __try {

        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            __leave;
        }


        lRes = -2;      // Invalid error

    }
    __finally
    {
        if (lRes == 0)
        {
            LogThisOnly(_T("Testyyy: an exception occurred!"), FALSE);
            lRes = -1;
        }

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    if (-2 == lRes)
	{
        lRes = 0;
	}

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\svrapp\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1997

Module Name:

    makefile.inc.

!ENDIF

scappmsg.mc: ..\..\inc\scarderr.mc ..\..\server\scardsvr\scardmsg.mch
    copy ..\..\inc\scarderr.mc + ..\..\server\scardsvr\scardmsg.mch $@

scappmsg.h scappmsg.rc msg00001.bin: scappmsg.mc
    mc scappmsg.mc

svrapp.rc2: scappmsg.rc

scappmsg.rc: msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\svrapp\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SvrApp.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_SVRAPP_DIALOG               102
#define IDR_MAINFRAME                   128
#define IDC_START                       1000
#define IDC_STOP                        1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\transmit.c ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "MarshalPC.h"
#include <tchar.h>

#if (!defined(UNICODE) && !defined(_UNICODE))
#define SCARDSTATUS "SCardStatusA"
#define GETOPENCARDNAME "GetOpenCardNameA"
#else
#define SCARDSTATUS "SCardStatusW"
#define GETOPENCARDNAME "GetOpenCardNameW"
#endif

typedef LONG (WINAPI *LPFNSCARDESTABLISHCONTEXT)(DWORD, LPCVOID, LPCVOID, LPSCARDCONTEXT);
typedef LONG (WINAPI *LPFNSCARDSTATUS)(SCARDHANDLE, LPTSTR, LPDWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef LONG (WINAPI *LPFNGETOPENCARDNAME)(LPOPENCARDNAME);
typedef LONG (WINAPI *LPFNSCARDTRANSMIT)(SCARDHANDLE, LPCSCARD_IO_REQUEST, LPCBYTE, DWORD, LPSCARD_IO_REQUEST, LPBYTE, LPDWORD);
typedef LONG (WINAPI *LPFNDISCONNECT)(SCARDHANDLE, DWORD);
typedef LONG (WINAPI *LPFNSCARDRELEASECONTEXT)(SCARDCONTEXT);
typedef LONG (WINAPI *LPFNSCARDBEGINTRANSACTION)(SCARDHANDLE);
typedef LONG (WINAPI *LPFNSCARDENDTRANSACTION)(SCARDHANDLE, DWORD);

typedef struct {
	HINSTANCE hPCSCInst;		// winscard
	HINSTANCE hPCSCInst2;		// scarddlg
	LPFNSCARDESTABLISHCONTEXT lpfnEstablish;
	LPFNGETOPENCARDNAME lpfnOpenCard;
	LPFNSCARDSTATUS lpfnStatus;
	LPFNSCARDTRANSMIT lpfnSCardTransmit;
	LPFNDISCONNECT lpfnDisconnect;
	LPFNSCARDRELEASECONTEXT lpfnRelease;
	LPFNSCARDBEGINTRANSACTION lpfnSCardBeginTransaction;
	LPFNSCARDENDTRANSACTION lpfnSCardEndTransaction;
} PCSC_CTX;

#define REAL_PCSC	0
#define FAKE_PCSC	1

static PCSC_CTX axCtx[2] =	// Array of contexts for each PC/SC
{
	{NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
	{NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}
};

static LONG _GetCardHandle(LPCWSTR mszCardNames, LPMYSCARDHANDLE phCard);
static LONG WINAPI _MySCWTransmit(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut);
    // bEnd = 0 -> LITTLE_ENDIAN ; otherwise -> BIG_ENDIAN
static LONG WINAPI hScwSetEndianness(SCARDHANDLE hCard, BOOL bEnd);

#define MAX_NAME 256


SCODE WINAPI hScwAttachToCard(SCARDHANDLE hCard, LPCWSTR mszCardNames, LPSCARDHANDLE phCard)
{
	return hScwAttachToCardEx(hCard, mszCardNames, 0x00, phCard);
}

SCODE WINAPI hScwAttachToCardEx(SCARDHANDLE hCard, LPCWSTR mszCardNames, BYTE byINS, LPSCARDHANDLE phCard)
{
	LPMYSCARDHANDLE phTmp = NULL;
	SCODE ret = SCARD_S_SUCCESS;

	__try {

		if (phCard == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		phTmp = (LPMYSCARDHANDLE)HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, sizeof(MYSCARDHANDLE));

		if ((hCard == (SCARDHANDLE)NULL) && (mszCardNames == NULL)) // No PC/SC
		{
			phTmp->dwFlags = FLAG_NOT_PCSC;
			*phCard = (SCARDHANDLE)phTmp;
			return ret;
		}

		if ((hCard == (SCARDHANDLE)NULL) || (mszCardNames == NULL)) // real PC/SC
		{
				// In this case we will be using PC/SC so we init the structure
			if (axCtx[REAL_PCSC].hPCSCInst == NULL)
			{
				axCtx[REAL_PCSC].hPCSCInst = LoadLibrary(_T("winscard.dll"));
				axCtx[REAL_PCSC].hPCSCInst2 = LoadLibrary(_T("scarddlg.dll"));
			}

			if ((axCtx[REAL_PCSC].hPCSCInst == NULL) || (axCtx[REAL_PCSC].hPCSCInst2 == NULL))
				RaiseException(STATUS_NO_SERVICE, 0, 0, 0);

			if (axCtx[REAL_PCSC].lpfnEstablish == NULL)
			{
				// Set all calls to DLL once and for all
				axCtx[REAL_PCSC].lpfnEstablish = (LPFNSCARDESTABLISHCONTEXT)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardEstablishContext");
				if (axCtx[REAL_PCSC].lpfnEstablish == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[REAL_PCSC].lpfnOpenCard = (LPFNGETOPENCARDNAME)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst2, GETOPENCARDNAME);
				if (axCtx[REAL_PCSC].lpfnOpenCard == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[REAL_PCSC].lpfnStatus = (LPFNSCARDSTATUS)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, SCARDSTATUS);
				if (axCtx[REAL_PCSC].lpfnStatus == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[REAL_PCSC].lpfnSCardTransmit = (LPFNSCARDTRANSMIT)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardTransmit");
				if (axCtx[REAL_PCSC].lpfnSCardTransmit == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[REAL_PCSC].lpfnDisconnect = (LPFNDISCONNECT)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardDisconnect");
				if (axCtx[REAL_PCSC].lpfnDisconnect == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[REAL_PCSC].lpfnRelease = (LPFNSCARDRELEASECONTEXT)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardReleaseContext");
				if (axCtx[REAL_PCSC].lpfnRelease == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[REAL_PCSC].lpfnSCardBeginTransaction = (LPFNSCARDBEGINTRANSACTION)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardBeginTransaction");
				if (axCtx[REAL_PCSC].lpfnSCardBeginTransaction == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[REAL_PCSC].lpfnSCardEndTransaction = (LPFNSCARDENDTRANSACTION)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardEndTransaction");
				if (axCtx[REAL_PCSC].lpfnSCardEndTransaction == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
			}

			phTmp->dwFlags = FLAG_REALPCSC;

		}
		else if ((hCard == NULL_TX)	|| (mszCardNames == NULL_TX_NAME)) // PC/SC for simulator
		{
				// In this case we will be using PC/SC so we init the structure
			if (axCtx[FAKE_PCSC].hPCSCInst == NULL)
			{
				axCtx[FAKE_PCSC].hPCSCInst = LoadLibrary(_T("scwwinscard.dll"));
				axCtx[FAKE_PCSC].hPCSCInst2 = axCtx[FAKE_PCSC].hPCSCInst;
			}

			if (axCtx[FAKE_PCSC].hPCSCInst == NULL)
				RaiseException(STATUS_NO_SERVICE, 0, 0, 0);

			if (axCtx[FAKE_PCSC].lpfnEstablish == NULL)
			{
				// Set all calls to DLL once and for all
				axCtx[FAKE_PCSC].lpfnEstablish = (LPFNSCARDESTABLISHCONTEXT)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardEstablishContext");
				if (axCtx[FAKE_PCSC].lpfnEstablish == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[FAKE_PCSC].lpfnOpenCard = (LPFNGETOPENCARDNAME)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst2, GETOPENCARDNAME);
				if (axCtx[FAKE_PCSC].lpfnOpenCard == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[FAKE_PCSC].lpfnStatus = (LPFNSCARDSTATUS)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, SCARDSTATUS);
				if (axCtx[FAKE_PCSC].lpfnStatus == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[FAKE_PCSC].lpfnSCardTransmit = (LPFNSCARDTRANSMIT)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardTransmit");
				if (axCtx[FAKE_PCSC].lpfnSCardTransmit == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[FAKE_PCSC].lpfnDisconnect = (LPFNDISCONNECT)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardDisconnect");
				if (axCtx[FAKE_PCSC].lpfnDisconnect == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[FAKE_PCSC].lpfnRelease = (LPFNSCARDRELEASECONTEXT)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardReleaseContext");
				if (axCtx[FAKE_PCSC].lpfnRelease == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[FAKE_PCSC].lpfnSCardBeginTransaction = (LPFNSCARDBEGINTRANSACTION)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardBeginTransaction");
				if (axCtx[FAKE_PCSC].lpfnSCardBeginTransaction == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[FAKE_PCSC].lpfnSCardEndTransaction = (LPFNSCARDENDTRANSACTION)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardEndTransaction");
				if (axCtx[FAKE_PCSC].lpfnSCardEndTransaction == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
			}

			phTmp->dwFlags = FLAG_FAKEPCSC;
		}
		else
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((hCard == (SCARDHANDLE)NULL) || (hCard == NULL_TX))	// Dialog wanted
		{
			phTmp->dwFlags |= FLAG_MY_ATTACH;
			ret = (SCODE)_GetCardHandle(mszCardNames, phTmp);
		}
		else
			phTmp->hCard = hCard;

			// Get the protocol
		if (ret == SCARD_S_SUCCESS)
		{
			DWORD dwLenReader, dwState, dwATRLength;
			BYTE abyATR[32];
			TCHAR wszReader[MAX_NAME];

			dwLenReader = MAX_NAME;
			dwATRLength = 32;
			ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnStatus)(
				phTmp->hCard,
				wszReader,
				&dwLenReader,
				&dwState,
				&phTmp->dwProtocol,
				abyATR,
				&dwATRLength);

				// Set the default callback because we are in PC/SC config here
			if (ret == SCARD_S_SUCCESS)
			{
				phTmp->byINS = byINS;
				ret = hScwSetTransmitCallback((SCARDHANDLE)phTmp, _MySCWTransmit);
				if (ret == SCARD_S_SUCCESS)
					*phCard = (SCARDHANDLE)phTmp;
			}
			else
				RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);
		}
		else
			RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		if (phTmp)
			HeapFree(GetProcessHeap(), 0, phTmp);

		if (ret == SCARD_S_SUCCESS)
		{
			switch(GetExceptionCode())
			{
			case STATUS_INVALID_PARAM:
				ret = MAKESCODE(SCW_E_INVALIDPARAM);
				break;

			case STATUS_NO_MEMORY:
			case STATUS_ACCESS_VIOLATION:
				ret = MAKESCODE(SCW_E_BUFFERTOOSMALL);
				break;

			case STATUS_NO_SERVICE:
				ret = SCARD_E_NO_SERVICE;
				break;

			default:
				ret = SCARD_F_UNKNOWN_ERROR;
			}
		}		// Otherwise ret was set already
	}

    return ret;
}

SCODE WINAPI hScwDetachFromCard(SCARDHANDLE hCard)
{
	SCODE ret = SCARD_S_SUCCESS;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if (phTmp->dwFlags & FLAG_MY_ATTACH)
		{
			(*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnDisconnect)(phTmp->hCard, SCARD_LEAVE_CARD);
			(*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnRelease)(phTmp->hCtx);
		}

		HeapFree(GetProcessHeap(), 0, phTmp);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = MAKESCODE(SCW_E_INVALIDPARAM);
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

static LONG WINAPI hScwSetEndianness(SCARDHANDLE hCard, BOOL bEnd)
{
	SCODE ret = SCARD_S_SUCCESS;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if (bEnd)
			phTmp->dwFlags |= FLAG_BIGENDIAN;
		else
			phTmp->dwFlags &= ~FLAG_BIGENDIAN;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = MAKESCODE(SCW_E_INVALIDPARAM);
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

	// This is the right time to get proxy information
	// Is proxy supported, what's the endianness and the buffer size
SCODE WINAPI hScwSetTransmitCallback(SCARDHANDLE hCard, LPFNSCWTRANSMITPROC lpfnProc)
{
	SCODE ret = SCARD_S_SUCCESS;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	__try {

		if ((phTmp == NULL) || (lpfnProc == NULL))
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		phTmp->lpfnTransmit = lpfnProc;

				// Get the proxy info
		{
			ISO_HEADER xHdr;
			BYTE rgData[] = {2, 108, 0, 116, 0, 0};	// 2 param, 0 as UINT8 by ref, 0 as UINT16 by ref
			BYTE rgRes[1+1+2];	// RetCode + Endianness + TheBuffer size
			TCOUNT OutLen = sizeof(rgRes);
			UINT16 wSW;

			xHdr.CLA = 0;
			xHdr.INS = phTmp->byINS;
			xHdr.P1 = 0xFF;		// Get proxy config
			xHdr.P2 = 0x00;
			ret = hScwExecute(hCard, &xHdr, rgData, sizeof(rgData), rgRes, &OutLen, &wSW);
			if (SCARD_S_SUCCESS == ret)
			{		// Status OK & expected length & RC=SCW_S_OK
				if ((wSW == 0x9000) && (OutLen == sizeof(rgRes)) && (rgRes[0] == 0))	// Version 1.0
				{
					hScwSetEndianness(hCard, rgRes[1]);
					if (rgRes[1] == 0)	// LITTLE_ENDIAN
						phTmp->bResLen = rgRes[2] - 2;		// SW!!!
					else
						phTmp->bResLen = rgRes[3] - 2;		// SW!!!

					phTmp->dwFlags |= FLAG_ISPROXY;
					phTmp->dwFlags |= VERSION_1_0;
				}
				else if ((wSW == 0x9011) && (OutLen == sizeof(rgRes) - 1))	// Version 1.1
				{
					hScwSetEndianness(hCard, rgRes[0]);
					if (rgRes[0] == 0)	// LITTLE_ENDIAN
						phTmp->bResLen = rgRes[1] - 2;		// SW!!!
					else
						phTmp->bResLen = rgRes[2] - 2;		// SW!!!

					phTmp->dwFlags |= FLAG_ISPROXY;
					phTmp->dwFlags |= VERSION_1_1;
				}
				// else there will be no proxy support but you can still use the Dll
			}
			else	// There will be no proxy support though but you can still use the Dll
				ret = SCARD_S_SUCCESS;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = MAKESCODE(SCW_E_INVALIDPARAM);
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

LONG WINAPI SCWTransmit(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut)
{
	SCODE ret = SCARD_S_SUCCESS;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		ret = (*phTmp->lpfnTransmit)(hCard, lpbIn, dwIn, lpBOut, pdwOut);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = MAKESCODE(SCW_E_INVALIDPARAM);
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

const SCARD_IO_REQUEST
	g_xIORT0 = { SCARD_PROTOCOL_T0, sizeof(SCARD_IO_REQUEST) },
	g_xIORT1 = { SCARD_PROTOCOL_T1, sizeof(SCARD_IO_REQUEST) };

static LONG WINAPI _MySCWTransmit(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut)
{
	SCARD_IO_REQUEST xIOR;
	LONG ret = SCARD_S_SUCCESS;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if (phTmp->dwProtocol == SCARD_PROTOCOL_T1)
		{
			memcpy(&xIOR, &g_xIORT1, sizeof(xIOR));
			ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardTransmit)(phTmp->hCard,
				&xIOR, lpbIn, dwIn,
				&xIOR, lpBOut, pdwOut);
		}
		else
		{
			DWORD dwOut = *pdwOut;

			memcpy(&xIOR, &g_xIORT0, sizeof(xIOR));

			__try {

				ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardBeginTransaction)(phTmp->hCard);

				if (ret == SCARD_S_SUCCESS)
				{
					ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardTransmit)(phTmp->hCard,
						&xIOR, lpbIn, dwIn,
						&xIOR, lpBOut, &dwOut);
				}

				if (ret == SCARD_S_SUCCESS)
				{
					if ((dwOut == 2) && ((lpBOut[0] == 0x61) || (lpBOut[0] == 0x9F)))
					{
						BYTE abGR[] = {0x00, 0xC0, 0x00, 0x00, 0x00};

						abGR[4] = lpBOut[1];
						ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardTransmit)(phTmp->hCard,
							&xIOR, abGR, 5,
							&xIOR, lpBOut, pdwOut);
					}
					else
						*pdwOut = dwOut;
				}
			}
			__finally
			{
				(*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardEndTransaction)(phTmp->hCard, SCARD_LEAVE_CARD);
			}
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = MAKESCODE(SCW_E_INVALIDPARAM);
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

static TCHAR lpstrGroupNames[] = _TEXT("SCard$DefaultReaders\0");

static LONG _GetCardHandle(LPCWSTR mszCardNames, LPMYSCARDHANDLE phCard)
{
    LONG lRes;
    OPENCARDNAME xOCN;
    TCHAR wszReader[MAX_NAME];
    TCHAR wszCard[MAX_NAME];
	TCHAR wszCN[MAX_NAME];

	DWORD len;
	LPCWSTR lpwstr = mszCardNames;
	LPTSTR lpstrCardNames = wszCN;
	xOCN.nMaxCardNames = 0;

#if (!defined(UNICODE) && !defined(_UNICODE))
	while (*lpwstr)
	{
		wsprintf(lpstrCardNames, "%S", lpwstr);	// Conversion
		len = wcslen(lpwstr) + 1;		// Add the trailing 0
		xOCN.nMaxCardNames += len;
		lpwstr += len;
		lpstrCardNames += len;
	}
#else
	while (*lpwstr)
	{
		wcscpy(lpstrCardNames, lpwstr);
		len = wcslen(lpwstr) + 1;		// Add the trailing 0
		xOCN.nMaxCardNames += len;
		lpwstr += len;
		lpstrCardNames += len;
	}
#endif
	xOCN.nMaxCardNames++;		// Add the trailing 0
	*lpstrCardNames = 0;

    lRes = (*axCtx[phCard->dwFlags & FLAG_MASKPCSC].lpfnEstablish)(SCARD_SCOPE_USER, NULL, NULL, &phCard->hCtx);

    if (lRes == SCARD_S_SUCCESS)
    {
        xOCN.dwStructSize = sizeof(xOCN);
        xOCN.hwndOwner = NULL;      // probably called from console anyway
        xOCN.hSCardContext = phCard->hCtx;
        xOCN.lpstrGroupNames = lpstrGroupNames;
        xOCN.nMaxGroupNames = sizeof(lpstrGroupNames)/sizeof(TCHAR);
        xOCN.lpstrCardNames = wszCN;
        xOCN.rgguidInterfaces = NULL;
        xOCN.cguidInterfaces = 0;
        xOCN.lpstrRdr = wszReader;
        xOCN.nMaxRdr = MAX_NAME/sizeof(TCHAR);
        xOCN.lpstrCard = wszCard;
        xOCN.nMaxCard = MAX_NAME/sizeof(TCHAR);
        xOCN.lpstrTitle = _TEXT("Insert Card:");
        xOCN.dwFlags = SC_DLG_MINIMAL_UI;
        xOCN.pvUserData = NULL;
        xOCN.dwShareMode = SCARD_SHARE_SHARED;
        xOCN.dwPreferredProtocols = SCARD_PROTOCOL_T1 | SCARD_PROTOCOL_T0;
        xOCN.lpfnConnect = NULL;
        xOCN.lpfnCheck = NULL;
        xOCN.lpfnDisconnect = NULL;

        lRes = (*axCtx[phCard->dwFlags & FLAG_MASKPCSC].lpfnOpenCard)(&xOCN);
    }

    if (lRes == SCARD_S_SUCCESS)
    {
		phCard->hCard = xOCN.hCardHandle;
	}

    return lRes;
}

SCODE WINAPI hScwSCardBeginTransaction(SCARDHANDLE hCard)
{
	SCODE ret;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	if ((phTmp->dwFlags & FLAG_REALPCSC) == FLAG_REALPCSC)
		ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardBeginTransaction)(phTmp->hCard);
	else
		ret = SCARD_S_SUCCESS;	// No transactions on simulator

	return ret;
}

SCODE WINAPI hScwSCardEndTransaction(SCARDHANDLE hCard, DWORD dwDisposition)
{
	SCODE ret;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	if ((phTmp->dwFlags & FLAG_REALPCSC) == FLAG_REALPCSC)
		ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardEndTransaction)(phTmp->hCard, dwDisposition);
	else
		ret = SCARD_S_SUCCESS;	// No transactions on simulator

	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctrace\sctrace.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    scTrace

Abstract:

    This program performs analysis on a Calais I/O trace.

Author:

    Doug Barlow (dbarlow) 10/30/1997

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <stdlib.h>
#include <iostream.h>
#include <iomanip.h>
#include <calcom.h>


//
// This structure must match the one used by SCardSvr.
//

typedef struct {
    DWORD dwStructLen;      // Actual structure length
    SYSTEMTIME StartTime;   // Time request was posted
    SYSTEMTIME EndTime;     // Time request completed
    DWORD dwProcId;         // Process Id
    DWORD dwThreadId;       // Thread Id
    HANDLE hDevice;         // I/O handle
    DWORD dwIoControlCode;  // I/O control code issued
    DWORD nInBuffer;        // Offset to input buffer
    DWORD nInBufferSize;    // Input buffer size
    DWORD nOutBuffer;       // Offset to output buffer
    DWORD nOutBufferSize;   // Size of user's receive buffer
    DWORD nBytesReturned;   // Actual size of returned data
    DWORD dwStatus;         // Returned status code
                            // InBuffer and OutBuffer follow.
} RequestTrace;

typedef struct {
    DWORD dwValue;
    LPCTSTR szValue;
} ValueMap;

typedef struct
{
    SYSTEMTIME stLogTime;
    DWORD dwProcId;
    DWORD dwThreadId;
} LogStamp;

HANDLE g_hCalaisShutdown = NULL;

static void
ShowDriverLog(
    IN LPCTSTR szFile);

static void
ShowApiLog(
    IN LPCTSTR szFile);

static void
dump(
    const BYTE *pbData,
    DWORD cbLen,
    ostream &outStr);

static void
GeneralDump(
    ostream &outStr,
    const RequestTrace *prqTrace);

static void
SendDump(
    ostream &outStr,
    const RequestTrace *prqTrace);

static void
RecvDump(
    ostream &outStr,
    const RequestTrace *prqTrace);

static void
MapValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap);

static void
MaskValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap);

static void
MapInput(
    ostream &outStr,
    const RequestTrace *prqTrace,
    const ValueMap *rgMap);

static void
MapOutput(
    ostream &outStr,
    const RequestTrace *prqTrace,
    const ValueMap *rgMap);

static void
ShowSyntax(
    ostream &outStr);

CComObject *
ReceiveComObject(
    HANDLE hFile);

#define PHex(x) TEXT("0x") << hex << setw(8) << setfill(TEXT('0')) << (DWORD)(x)
#define PDec(x) dec << setw(0) << setfill(TEXT(' ')) << (x)
#define MAP(x) { x, TEXT(#x) }
#define PTime(x) dec \
    << setw(2) << setfill(TEXT('0')) << (x).wHour   << TEXT(":") \
    << setw(2) << setfill(TEXT('0')) << (x).wMinute << TEXT(":") \
    << setw(2) << setfill(TEXT('0')) << (x).wSecond << TEXT(".") \
    << setw(3) << setfill(TEXT('0')) << (x).wMilliseconds

static const ValueMap rgMapProto[]
    = { MAP(SCARD_PROTOCOL_UNDEFINED),      MAP(SCARD_PROTOCOL_T0),
        MAP(SCARD_PROTOCOL_T1),             MAP(SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1),
        MAP(SCARD_PROTOCOL_RAW),            MAP(SCARD_PROTOCOL_DEFAULT),
        { 0, NULL } };
static const ValueMap rgMapIoctl[]
    = { MAP(IOCTL_SMARTCARD_POWER),         MAP(IOCTL_SMARTCARD_GET_ATTRIBUTE),
        MAP(IOCTL_SMARTCARD_SET_ATTRIBUTE), MAP(IOCTL_SMARTCARD_CONFISCATE),
        MAP(IOCTL_SMARTCARD_TRANSMIT),      MAP(IOCTL_SMARTCARD_EJECT),
        MAP(IOCTL_SMARTCARD_SWALLOW),       MAP(IOCTL_SMARTCARD_IS_PRESENT),
        MAP(IOCTL_SMARTCARD_IS_ABSENT),     MAP(IOCTL_SMARTCARD_SET_PROTOCOL),
        MAP(IOCTL_SMARTCARD_GET_STATE),     MAP(IOCTL_SMARTCARD_GET_LAST_ERROR),
        { 0, NULL } };
static const ValueMap rgMapAttr[]
    = { MAP(SCARD_ATTR_VENDOR_NAME),            MAP(SCARD_ATTR_VENDOR_IFD_TYPE),
        MAP(SCARD_ATTR_VENDOR_IFD_VERSION),     MAP(SCARD_ATTR_VENDOR_IFD_SERIAL_NO),
        MAP(SCARD_ATTR_CHANNEL_ID),             MAP(SCARD_ATTR_DEFAULT_CLK),
        MAP(SCARD_ATTR_MAX_CLK),                MAP(SCARD_ATTR_DEFAULT_DATA_RATE),
        MAP(SCARD_ATTR_MAX_DATA_RATE),          MAP(SCARD_ATTR_MAX_IFSD),
        MAP(SCARD_ATTR_POWER_MGMT_SUPPORT),     MAP(SCARD_ATTR_USER_TO_CARD_AUTH_DEVICE),
        MAP(SCARD_ATTR_USER_AUTH_INPUT_DEVICE), MAP(SCARD_ATTR_CHARACTERISTICS),
        MAP(SCARD_ATTR_CURRENT_PROTOCOL_TYPE),  MAP(SCARD_ATTR_CURRENT_CLK),
        MAP(SCARD_ATTR_CURRENT_F),              MAP(SCARD_ATTR_CURRENT_D),
        MAP(SCARD_ATTR_CURRENT_N),              MAP(SCARD_ATTR_CURRENT_W),
        MAP(SCARD_ATTR_CURRENT_IFSC),           MAP(SCARD_ATTR_CURRENT_IFSD),
        MAP(SCARD_ATTR_CURRENT_BWT),            MAP(SCARD_ATTR_CURRENT_CWT),
        MAP(SCARD_ATTR_CURRENT_EBC_ENCODING),   MAP(SCARD_ATTR_EXTENDED_BWT),
        MAP(SCARD_ATTR_ICC_PRESENCE),           MAP(SCARD_ATTR_ICC_INTERFACE_STATUS),
        MAP(SCARD_ATTR_CURRENT_IO_STATE),       MAP(SCARD_ATTR_ATR_STRING),
        MAP(SCARD_ATTR_ICC_TYPE_PER_ATR),       MAP(SCARD_ATTR_ESC_RESET),
        MAP(SCARD_ATTR_ESC_CANCEL),             MAP(SCARD_ATTR_ESC_AUTHREQUEST),
        MAP(SCARD_ATTR_MAXINPUT),               MAP(SCARD_ATTR_DEVICE_UNIT),
        MAP(SCARD_ATTR_DEVICE_IN_USE),          MAP(SCARD_ATTR_DEVICE_FRIENDLY_NAME_A),
        MAP(SCARD_ATTR_DEVICE_SYSTEM_NAME_A),   MAP(SCARD_ATTR_DEVICE_FRIENDLY_NAME_W),
        MAP(SCARD_ATTR_DEVICE_SYSTEM_NAME_W),   MAP(SCARD_ATTR_SUPRESS_T1_IFS_REQUEST),
        { 0, NULL } };

static DWORD
    l_dwPid = 0,
    l_dwTid = 0;


/*++

main:

    This is the main entry point for the program.

Arguments:

    dwArgCount supplies the number of arguments.

    szrgArgs supplies the argument strings.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/30/1997

--*/

void _cdecl
main(
    IN DWORD dwArgCount,
    IN LPCTSTR szrgArgs[])
{
    LPCTSTR szInFile = NULL;
    LPTSTR szEnd;
    DWORD dwArgIndex = 0;
    enum TraceAction {
            Undefined = 0,
            ClearLog,
            ShowApiTrace,
            ShowDriverTrace
    } nTraceAction = Undefined;


    //
    // Check for command line options
    //

    while (NULL != szrgArgs[++dwArgIndex])
    {
        switch (SelectString(szrgArgs[dwArgIndex],
                    TEXT("CLEAR"),      TEXT("RESET"),
                    TEXT("DRIVER"),     TEXT("API"),
                    TEXT("-FILE"),      TEXT("-PID"),       TEXT("-TID"),
                    NULL))
        {
        case 1:     // clear
        case 2:     // reset
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = ClearLog;
            break;
        case 3:     // driver
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = ShowDriverTrace;
            break;
        case 4:     // api
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = ShowApiTrace;
            break;
        case 5:    // -file
            if (NULL != szInFile)
                ShowSyntax(cerr);
            szInFile = szrgArgs[++dwArgIndex];
            if (NULL == szInFile)
                ShowSyntax(cerr);
            break;
        case 6: // -pid <n>
            if (0 != l_dwPid)
                ShowSyntax(cerr);
            dwArgIndex += 1;
            l_dwPid = strtoul(szrgArgs[dwArgIndex], &szEnd, 0);
            if ((0 == l_dwPid) || (0 != *szEnd))
                ShowSyntax(cerr);
            break;
        case 7: // -tid <n>
            if (0 != l_dwTid)
                ShowSyntax(cerr);
            dwArgIndex += 1;
            l_dwTid = strtoul(szrgArgs[dwArgIndex], &szEnd, 0);
            if ((0 == l_dwTid) || (0 != *szEnd))
                ShowSyntax(cerr);
            break;
        default:
            ShowSyntax(cerr);
        }
    }


    //
    // Perform the request.
    //

    switch (nTraceAction)
    {
    case ClearLog:
    {
        HANDLE hLogFile;

        if (NULL == szInFile)
        {
            hLogFile = CreateFile(
                            TEXT("C:\\Calais.log"),
                            GENERIC_WRITE,
                            0,
                            NULL,
                            TRUNCATE_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
            if (INVALID_HANDLE_VALUE != hLogFile)
                CloseHandle(hLogFile);
            hLogFile = CreateFile(
                            TEXT("C:\\SCard.log"),
                            GENERIC_WRITE,
                            0,
                            NULL,
                            TRUNCATE_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
            if (INVALID_HANDLE_VALUE != hLogFile)
                CloseHandle(hLogFile);
        }
        else
        {
            hLogFile = CreateFile(
                            szInFile,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
            if (INVALID_HANDLE_VALUE == hLogFile)
            {
                DWORD dwError = GetLastError();
                cerr << TEXT("Failed to initialize file ")
                    << szInFile << TEXT(": ")
                    << CErrorString(dwError) << endl;
            }
            else
                CloseHandle(hLogFile);
        }
        break;
    }
    case Undefined:
    case ShowApiTrace:
        ShowApiLog(szInFile);
        break;
    case ShowDriverTrace:
        ShowDriverLog(szInFile);
        break;
    default:
        cerr << TEXT("Internal error") << endl;
    }

    exit(0);
}


/*++

ShowDriverLog:

    Explain the contents of the driver log.

Arguments:

    szFile supplies the name of the file to parse.  If this is NULL, the file
        C:\Calais.log is used.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 8/5/1998

--*/

static void
ShowDriverLog(
    IN LPCTSTR szFile)
{
    static const ValueMap rgMapPower[]
        = { MAP(SCARD_POWER_DOWN),
            MAP(SCARD_COLD_RESET),
            MAP(SCARD_WARM_RESET),
            { 0, NULL } };
    HANDLE hLogFile = NULL;
    DWORD cbStructLen = 0;
    LPBYTE pbStruct = NULL;
    LPCTSTR szInFile = TEXT("C:\\Calais.log");
    DWORD dwLen, dwRead;
    BOOL fSts;
    RequestTrace *prqTrace;
    LPBYTE pbInBuffer, pbOutBuffer;
    LPDWORD pdwInValue, pdwOutValue;


    //
    // Open the log file.
    //

    if (NULL != szFile)
        szInFile = szFile;
    hLogFile = CreateFile(
        szInFile,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (INVALID_HANDLE_VALUE == hLogFile)
    {
        cerr << TEXT("Can't open file ")
             << szInFile
             << ": "
             << ErrorString(GetLastError())
             << endl;
         goto ErrorExit;
    }


    //
    // Parse the file contents.
    //

    for (;;)
    {
        fSts = ReadFile(
                    hLogFile,
                    &dwLen,
                    sizeof(DWORD),
                    &dwRead,
                    NULL);
        if ((!fSts) || (0 == dwRead))
            goto ErrorExit;

        if (cbStructLen < dwLen)
        {
            if (NULL != pbStruct)
                LocalFree(pbStruct);
            pbStruct = (LPBYTE)LocalAlloc(LPTR, dwLen);
            cbStructLen = dwLen;
        }
        prqTrace = (RequestTrace *)pbStruct;
        prqTrace->dwStructLen = dwLen;
        fSts = ReadFile(
                    hLogFile,
                    &pbStruct[sizeof(DWORD)],
                    dwLen - sizeof(DWORD),
                    &dwRead,
                    NULL);
        if (!fSts)
        {
            cerr << "File read error: " << ErrorString(GetLastError()) << endl;
            goto ErrorExit;
        }
        if ((l_dwPid != 0) && (l_dwPid != prqTrace->dwProcId))
            continue;
        if ((l_dwTid != 0) && (l_dwTid != prqTrace->dwThreadId))
            continue;


        //
        // Parse the structure into bytesize chunks.
        //

        pbInBuffer  =   0 != prqTrace->nInBufferSize
                            ? (LPBYTE)prqTrace + prqTrace->nInBuffer
                            : NULL;
        pbOutBuffer =   0 != prqTrace->nBytesReturned
                            ? (LPBYTE)prqTrace + prqTrace->nOutBuffer
                            : NULL;
        pdwInValue  =    sizeof(DWORD) <= prqTrace->nInBufferSize
                            ? (LPDWORD)pbInBuffer
                            : NULL;
        pdwOutValue =    sizeof(DWORD) <= prqTrace->nBytesReturned
                            ? (LPDWORD)pbOutBuffer
                            : NULL;


        //
        // We've got the structure, now display the contents.
        //

        cout
            << TEXT("-----------------------------------------------------\n")
            << TEXT("P/T:    ") << PHex(prqTrace->dwProcId) << TEXT("/") << PHex(prqTrace->dwThreadId) << TCHAR('\n')
            << TEXT("Time:   ") << PTime(prqTrace->StartTime) << TEXT(" - ") << PTime(prqTrace->EndTime) << TCHAR('\n')
            << TEXT("Device: ") << PHex((ULONG)prqTrace->hDevice) << TCHAR('\n')
            << TEXT("Status: ") << ErrorString(prqTrace->dwStatus) << TCHAR('\n')
            << TEXT("RecLen: ") << PDec(prqTrace->nOutBufferSize) << TCHAR('\n')
            << flush;
        MapValue(cout, prqTrace->dwIoControlCode, TEXT("IOCTL:  "), rgMapIoctl);
        cout << flush;
        switch (prqTrace->dwIoControlCode)
        {
        case IOCTL_SMARTCARD_POWER:
            MapInput(cout, prqTrace, rgMapPower);
            cout << flush;
            MapOutput(cout, prqTrace, NULL);
            break;
        case IOCTL_SMARTCARD_GET_ATTRIBUTE:
            MapInput(cout, prqTrace, rgMapAttr);
            cout << flush;
            MapOutput(cout, prqTrace, NULL);
            break;
        case IOCTL_SMARTCARD_SET_ATTRIBUTE:
        {
            GeneralDump(cout, prqTrace);
            break;
        }
        case IOCTL_SMARTCARD_CONFISCATE:
            GeneralDump(cout, prqTrace);
            break;
        case IOCTL_SMARTCARD_TRANSMIT:
        {
            LPCSCARD_IO_REQUEST pIo;
            LPCBYTE pbPci, pbSdu;
            DWORD cbPci, cbSdu;

            if (sizeof(SCARD_IO_REQUEST) <= prqTrace->nInBufferSize)
            {
                pIo = (LPCSCARD_IO_REQUEST)pbInBuffer;
                pbPci = pbInBuffer + sizeof(LPCSCARD_IO_REQUEST);
                cbPci = min(pIo->cbPciLength, prqTrace->nInBufferSize);
                pbSdu = pbInBuffer + pIo->cbPciLength;
                cbSdu = prqTrace->nInBufferSize - cbPci;
                cbPci -= sizeof(SCARD_IO_REQUEST);

                MapValue(cout, pIo->dwProtocol, TEXT("Proto:  "), rgMapProto);
                if (0 < cbPci)
                {
                    cout
                        << TEXT("In PCI:  (") << PDec(cbPci) << TEXT(" bytes)\n")
                        << flush;
                    dump(pbPci, cbPci, cout);
                }
                cout
                    << TEXT("Sent:    (") << PDec(cbSdu) << TEXT(" bytes)\n")
                    << flush;
                dump(pbSdu, cbSdu, cout);
            }
            else
                SendDump(cout, prqTrace);
            if (sizeof(SCARD_IO_REQUEST) <= prqTrace->nBytesReturned)
            {
                pIo = (LPCSCARD_IO_REQUEST)pbOutBuffer;
                pbPci = pbOutBuffer + sizeof(LPCSCARD_IO_REQUEST);
                cbPci = min(pIo->cbPciLength, prqTrace->nBytesReturned);
                pbSdu = pbOutBuffer + pIo->cbPciLength;
                cbSdu = prqTrace->nBytesReturned - cbPci;
                cbPci -= sizeof(SCARD_IO_REQUEST);

                MapValue(cout, pIo->dwProtocol, TEXT("Proto:  "), rgMapProto);
                if (0 < cbPci)
                {
                    cout
                        << TEXT("Out PCI: (") << PDec(cbPci) << TEXT(" bytes)\n")
                        << flush;
                    dump(pbPci, cbPci, cout);
                }
                cout
                    << TEXT("Recd:    (") << PDec(cbSdu) << TEXT(" bytes)\n")
                    << flush;
                dump(pbSdu, cbSdu, cout);
            }
            else
                RecvDump(cout, prqTrace);
            break;
        }
        case IOCTL_SMARTCARD_EJECT:
            GeneralDump(cout, prqTrace);
            break;
        case IOCTL_SMARTCARD_SWALLOW:
            GeneralDump(cout, prqTrace);
            break;
        case IOCTL_SMARTCARD_IS_PRESENT:
            GeneralDump(cout, prqTrace);
            break;
        case IOCTL_SMARTCARD_IS_ABSENT:
            GeneralDump(cout, prqTrace);
            break;
        case IOCTL_SMARTCARD_SET_PROTOCOL:
            MapInput(cout, prqTrace, rgMapProto);
            cout << flush;
            MapOutput(cout, prqTrace, rgMapProto);
            break;
        case IOCTL_SMARTCARD_GET_STATE:
        {
            GeneralDump(cout, prqTrace);
            break;
        }
        case IOCTL_SMARTCARD_GET_LAST_ERROR:
        {
            GeneralDump(cout, prqTrace);
            break;
        }
        default:
            GeneralDump(cout, prqTrace);
            break;
        }
        cout << flush;
    }

ErrorExit:
    if (NULL == hLogFile)
        CloseHandle(hLogFile);
}


static void
dump(
    const BYTE *pbData,
    DWORD cbLen,
    ostream &outStr)
{
    unsigned long int
        b, i, lc;
    char
        buffer[8];


    lc = 0;
    while (0 < cbLen)
    {
        b = min(sizeof(buffer), cbLen);
        memcpy(buffer, pbData, b);
        pbData += b;
        cbLen -= b;
        if (0 < b)
        {
            outStr << TEXT("        ") << setw(8) << setfill(TEXT('0')) << hex << lc;
            for (i = 0; i < b; i += 1)
                outStr
                    << "  "
                    << setw(2) << setfill('0') << hex
                    << ((unsigned int)buffer[i] & 0xff);
            for (; i < sizeof(buffer) + 1; i += 1)
                outStr << "    ";
            for (i = 0; i < b; i += 1)
                outStr
                    << setw(0) << setfill(' ') << dec
                    << ((0 != iscntrl((int)(0x7f & buffer[i])))
                        ? TEXT('.')
                        : buffer[i]);
            outStr << endl;
            lc += b;
        }
    }
}

static void
GeneralDump(
    ostream &outStr,
    const RequestTrace *prqTrace)
{
    SendDump(outStr, prqTrace);
    outStr << flush;
    RecvDump(outStr, prqTrace);
}

static void
SendDump(
    ostream &outStr,
    const RequestTrace *prqTrace)
{
    outStr
        << TEXT("Sent:   (") << PDec(prqTrace->nInBufferSize) << TEXT(" bytes)\n")
        << flush;
    dump(
        (LPBYTE)prqTrace + prqTrace->nInBuffer,
        prqTrace->nInBufferSize,
        outStr);
}

static void
RecvDump(
    ostream &outStr,
    const RequestTrace *prqTrace)
{
    outStr
        << TEXT("Recd:   (") << PDec(prqTrace->nBytesReturned) << TEXT(" bytes)\n")
        << flush;
    dump(
        (LPBYTE)prqTrace + prqTrace->nOutBuffer,
        prqTrace->nBytesReturned,
        outStr);
}

static void
MapValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap)
{
    DWORD dwIndex;

    if (NULL != rgMap)
    {
        for (dwIndex = 0; NULL != rgMap[dwIndex].szValue; dwIndex += 1)
            if (rgMap[dwIndex].dwValue == dwValue)
                break;
        if (NULL != rgMap[dwIndex].szValue)
            outStr << szLeader << rgMap[dwIndex].szValue << TEXT('\n');
        else
            outStr << szLeader << PHex(dwValue) << TEXT('\n');
    }
    else
        outStr << szLeader << PHex(dwValue) << TEXT('\n');
}

static void
MaskValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap)
{
    DWORD dwIndex;
    BOOL fSpace = FALSE;

    if (NULL != rgMap)
    {
        if (NULL != szLeader)
            outStr << szLeader;

        for (dwIndex = 0; NULL != rgMap[dwIndex].szValue; dwIndex += 1)
        {
            if (rgMap[dwIndex].dwValue == (rgMap[dwIndex].dwValue & dwValue))
            {
                if (fSpace)
                    outStr << TEXT(' ');
                else
                    fSpace = TRUE;
                outStr << rgMap[dwIndex].szValue;
                dwValue &= ~rgMap[dwIndex].dwValue;
            }
        }
        if (0 != dwValue)
        {
            if (fSpace)
            {
                outStr << TEXT(' ');
                fSpace = TRUE;
            }
            outStr << PHex(dwValue);
        }
        else if (!fSpace)
            outStr << PHex(dwValue);
        outStr << endl;
    }
    else
        outStr << szLeader << PHex(dwValue) << endl;
}

static void
MapInput(
    ostream &outStr,
    const RequestTrace *prqTrace,
    const ValueMap *rgMap)
{
    DWORD dwValue;

    switch (prqTrace->nInBufferSize)
    {
    case 0:
        break;
    case sizeof(DWORD):
        dwValue = *(LPDWORD)((LPBYTE)prqTrace + prqTrace->nInBuffer);
        MapValue(outStr, dwValue, TEXT("Sent:   "), rgMap);
        break;
    default:
        SendDump(outStr, prqTrace);
    }
}

static void
MapOutput(
    ostream &outStr,
    const RequestTrace *prqTrace,
    const ValueMap *rgMap)
{
    DWORD dwValue;

    switch (prqTrace->nBytesReturned)
    {
    case 0:
        break;
    case sizeof(DWORD):
        dwValue = *(LPDWORD)((LPBYTE)prqTrace + prqTrace->nOutBuffer);
        MapValue(outStr, dwValue, TEXT("Recd:   "), rgMap);
        break;
    default:
        RecvDump(outStr, prqTrace);
    }
}

/*++

ShowSyntax:

    Display the command line usage model.

Arguments:

    None

Return Value:

    This routine calls exit(0), so it never returns.

Author:

    Doug Barlow (dbarlow) 5/16/1998

--*/

static void
ShowSyntax(
    ostream &outStr)
{
    outStr << TEXT("Usage:\n")
           << TEXT("------------------------\n")
           << TEXT("clear [-file <logFile>]\n")
           << TEXT("api [-file <logFile>] [-pid <pid>] [-tid <tid>]\n")
           << TEXT("driver [-file <logFile>] [-pid <pid>] [-tid <tid>]\n")
           << TEXT("------------------------\n")
           << TEXT("DRIVER logs to C:\\Calais.log\n")
           << TEXT("API logs to C:\\SCard.log\n")
           << endl;
    exit(1);
}


/*++

ShowApiLog:

    Explain the contents of the API log.

Arguments:

    szFile supplies the name of the file to parse.  If this is NULL, the file
        C:\SCard.log is used.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 8/5/1998

--*/

static void
ShowApiLog(
    IN LPCTSTR szFile)
{
    static const ValueMap rgMapStates[]
        = { MAP(SCARD_STATE_IGNORE),
            MAP(SCARD_STATE_CHANGED),
            MAP(SCARD_STATE_UNKNOWN),
            MAP(SCARD_STATE_UNAVAILABLE),
            MAP(SCARD_STATE_EMPTY),
            MAP(SCARD_STATE_PRESENT),
            MAP(SCARD_STATE_ATRMATCH),
            MAP(SCARD_STATE_EXCLUSIVE),
            MAP(SCARD_STATE_INUSE),
            MAP(SCARD_STATE_MUTE),
            MAP(SCARD_STATE_UNPOWERED),
            {0, NULL} };
    static const ValueMap rgMapDriverStates[]
        = {
            MAP(SCARD_UNKNOWN),
            MAP(SCARD_ABSENT),
            MAP(SCARD_PRESENT),
            MAP(SCARD_SWALLOWED),
            MAP(SCARD_POWERED),
            MAP(SCARD_NEGOTIABLE),
            MAP(SCARD_SPECIFIC),
            {0, NULL} };
    static const ValueMap rgMapShare[]
        = {
            MAP(SCARD_SHARE_EXCLUSIVE),
            MAP(SCARD_SHARE_SHARED),
            MAP(SCARD_SHARE_DIRECT),
            {0, NULL} };
    static const ValueMap rgMapDisposition[]
        = { MAP(SCARD_LEAVE_CARD),
            MAP(SCARD_RESET_CARD),
            MAP(SCARD_UNPOWER_CARD),
            MAP(SCARD_EJECT_CARD),
            {0, NULL} };
    HANDLE hLogFile = NULL;
    LPCTSTR szInFile = TEXT("C:\\SCard.log");
    CComObject *pCom = NULL;
    DWORD dwLen;


    //
    // Open the log file.
    //

    if (NULL != szFile)
        szInFile = szFile;
    hLogFile = CreateFile(
        szInFile,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);
    if (INVALID_HANDLE_VALUE == hLogFile)
    {
        cerr << TEXT("Can't open file ") << szInFile << ": "
             << ErrorString(GetLastError()) << endl;
         goto ErrorExit;
    }


    //
    // Parse the file contents.
    //

    try
    {
        for (;;)
        {
            LogStamp stamp;
            BOOL fSts;

            fSts = ReadFile(
                    hLogFile,
                    &stamp,
                    sizeof(stamp),
                    &dwLen,
                    NULL);
            ASSERT(fSts);
            pCom = ReceiveComObject(hLogFile);
            if (NULL == pCom)
                break;
            if ((l_dwPid != 0) && (l_dwPid != stamp.dwProcId))
                continue;
            if ((l_dwTid != 0) && (l_dwTid != stamp.dwProcId))
                continue;
            cout
                << TEXT("------------------------------------------------------------\n")
                << TEXT("Process/Thread:      ") << PHex(stamp.dwProcId) << TEXT("/") << PHex(stamp.dwThreadId) << TEXT("\n")
                << TEXT("Time:                ") << PTime(stamp.stLogTime) << endl;
            switch (pCom->Type())
            {
            case CComObject::EstablishContext_request:
            {
                ComEstablishContext::CObjEstablishContext_request *pReq
                    = (ComEstablishContext::CObjEstablishContext_request *)pCom->Request();
                cout
                    << TEXT("Establish Context request\n")
                    << TEXT("Requesting Process:  ") << PHex(pReq->dwProcId) << TEXT("\n")
                    << TEXT("Cancel Event:        ") << PHex(pReq->hCancelEvent) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::ReleaseContext_request:
            {
                ComReleaseContext::CObjReleaseContext_request *pReq =
                    (ComReleaseContext::CObjReleaseContext_request *)pCom->Request();
                cout
                    << TEXT("Release Context request\n")
                    << flush;
                break;
            }

            case CComObject::IsValidContext_request:
            {
                ComIsValidContext::CObjIsValidContext_request *pReq =
                    (ComIsValidContext::CObjIsValidContext_request *)pCom->Request();
                cout
                    << TEXT("Is Valid Context request\n")
                    << flush;
                break;
            }

            case CComObject::LocateCards_request:
            {
                DWORD cbTotAtrs, cbTotMasks, dwStateCount, dwIndex;
                LPCTSTR szReader;
                ComLocateCards::CObjLocateCards_request *pReq =
                    (ComLocateCards::CObjLocateCards_request *)pCom->Request();
                LPCBYTE pbAtrs = (LPCBYTE)pCom->Parse(pReq->dscAtrs, &cbTotAtrs);
                LPCBYTE pbMasks = (LPCBYTE)pCom->Parse(pReq->dscAtrMasks, &cbTotMasks);
                LPCTSTR mszReaders = (LPCTSTR)pCom->Parse(pReq->dscReaders);
                LPDWORD rgdwStates = (LPDWORD)pCom->Parse(pReq->dscReaderStates, &dwStateCount);
                cout
                    << TEXT("Locate Cards request\n")
                    << flush;
                if (0 == cbTotAtrs)
                {
                    cout << TEXT("ERROR -- Invalid ATR array") << endl;
                    continue;
                }
                else if (0 == cbTotMasks)
                {
                    cout << TEXT("ERROR -- Invalid Mask array") << endl;
                    continue;
                }
                else if (0 == dwStateCount)
                {
                    cout << TEXT("ERROR -- Invalid State array") << endl;
                    continue;
                }
                else if (0 != dwStateCount % sizeof(DWORD))
                {
                    cout << TEXT("ERROR -- Invalid State array length") << endl;
                    continue;
                }
                else if (0 == *mszReaders)
                {
                    cout << TEXT("ERROR -- Invalid Reader Name String") << endl;
                    continue;
                }
                dwStateCount /= sizeof(DWORD);
                cout
                    << TEXT("Looking for ATRs:\n")
                    << flush;
                while (0 < cbTotAtrs)
                {
                    DWORD cbLength;

                    cbLength = *pbAtrs++;
                    cout << TEXT("ATR:\n") << flush;
                    dump(pbAtrs, cbLength, cout);
                    pbAtrs += cbLength;
                    cbTotAtrs -= cbLength + 1;
                    cbLength = *pbMasks++;
                    cout << TEXT("Mask:\n") << flush;
                    dump(pbMasks, cbLength, cout);
                    pbMasks += cbLength;
                }
                cout
                    << TEXT("Looking in readers:\n")
                    << flush;
                for (dwIndex = 0, szReader = FirstString(mszReaders);
                     dwIndex < dwStateCount;
                     dwIndex += 1, szReader = NextString(szReader))
                {
                    cout
                        << TEXT("    ") << szReader << TEXT(":\n")
                        << TEXT("        ")
                        << flush;
                    if (0 == rgdwStates[dwIndex])
                        cout << TEXT("SCARD_STATE_UNAWARE\n") << flush;
                    else
                        MaskValue(cout, rgdwStates[dwIndex], NULL, rgMapStates);
                }
                break;
            }

            case CComObject::GetStatusChange_request:
            {
                DWORD dwIndex;
                LPCTSTR szReader;
                ComGetStatusChange::CObjGetStatusChange_request *pReq =
                    (ComGetStatusChange::CObjGetStatusChange_request *)pCom->Request();
                LPCTSTR mszReaders = (LPCTSTR)pCom->Parse(pReq->dscReaders);
                LPDWORD rgdwStates = (LPDWORD)pCom->Parse(pReq->dscReaderStates, &dwLen);
                cout
                    << TEXT("Get Status Change request\n")
                    << flush;
                if (0 == dwLen)
                {
                    cout << TEXT("ERROR -- Invalid State array") << endl;
                    continue;
                }
                else if (0 != dwLen % sizeof(DWORD))
                {
                    cout << TEXT("ERROR -- Invalid State array length") << endl;
                    continue;
                }
                else if (0 == *mszReaders)
                {
                    cout << TEXT("ERROR -- Invalid Reader Name String") << endl;
                    continue;
                }
                cout
                    << TEXT("Timeout:             ") << PDec(pReq->dwTimeout) << TEXT(" Milliseconds\n")
                    << TEXT("Monitoring readers:\n")
                    << flush;
                for (dwIndex = 0, szReader = FirstString(mszReaders);
                     NULL != szReader;
                     dwIndex += 1, szReader = NextString(szReader))
                {
                    cout
                        << TEXT("    ") << szReader << TEXT(":\n")
                        << flush;
                    if (0 == rgdwStates[dwIndex])
                        cout << TEXT("        SCARD_STATE_UNAWARE") << endl;
                    else
                        MaskValue(cout, rgdwStates[dwIndex], TEXT("        "), rgMapStates);
                }
                break;
            }

            case CComObject::ListReaders_request:
            {
                LPCTSTR szReader;
                ComListReaders::CObjListReaders_request *pReq =
                    (ComListReaders::CObjListReaders_request *)pCom->Request();
                LPCTSTR mszQueryReaders = (LPCTSTR)pCom->Parse(pReq->dscReaders);
                cout
                    << TEXT("List Readers request\n")
                    << TEXT("Readers:\n")
                    << flush;
                for (szReader = FirstString(mszQueryReaders);
                     NULL != szReader;
                     szReader = NextString(szReader))
                {
                    cout << TEXT("    ") << szReader << endl;
                }
                break;
            }

            case CComObject::Connect_request:
            {
                ComConnect::CObjConnect_request *pReq
                    = (ComConnect::CObjConnect_request *)pCom->Request();
                LPCTSTR szReader = (LPCTSTR)pCom->Parse(pReq->dscReader);
                cout
                    << TEXT("Connect request\n")
                    << TEXT("Reader:              ") << szReader << endl;
                MapValue(cout, pReq->dwPreferredProtocols,
                         TEXT("Protocols:           "), rgMapProto);
                MapValue(cout, pReq->dwShareMode,
                         TEXT("Sharing Mode:        "), rgMapShare);
                break;
            }

            case CComObject::Reconnect_request:
            {
                ComReconnect::CObjReconnect_request *pReq
                    = (ComReconnect::CObjReconnect_request *)pCom->Request();
                cout
                    << TEXT("Reconnect request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                MapValue(cout, pReq->dwInitialization,
                         TEXT("Disposition:         "), rgMapDisposition);
                MapValue(cout, pReq->dwPreferredProtocols,
                         TEXT("Protocols:           "), rgMapProto);
                MapValue(cout, pReq->dwShareMode,
                         TEXT("Sharing Mode:        "), rgMapShare);
                break;
            }

            case CComObject::Disconnect_request:
            {
                ComDisconnect::CObjDisconnect_request *pReq
                    = (ComDisconnect::CObjDisconnect_request *)pCom->Request();
                cout
                    << TEXT("Disconnect request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                MapValue(cout, pReq->dwDisposition,
                         TEXT("Disposition:         "), rgMapDisposition);
                break;
            }

            case CComObject::BeginTransaction_request:
            {
                ComBeginTransaction::CObjBeginTransaction_request *pReq
                    = (ComBeginTransaction::CObjBeginTransaction_request *)
                        pCom->Request();
                cout
                    << TEXT("Begin Transaction request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::EndTransaction_request:
            {
                ComEndTransaction::CObjEndTransaction_request *pReq
                    = (ComEndTransaction::CObjEndTransaction_request *)pCom->Request();
                cout
                    << TEXT("End Transaction request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                MapValue(cout, pReq->dwDisposition,
                       TEXT("Disposition:         "), rgMapDisposition);
                break;
            }

            case CComObject::Status_request:
            {
                ComStatus::CObjStatus_request *pReq
                    = (ComStatus::CObjStatus_request *)pCom->Request();
                cout
                    << TEXT("Status request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::Transmit_request:
            {
                DWORD cbPci, cbData;
                ComTransmit::CObjTransmit_request *pReq
                    = (ComTransmit::CObjTransmit_request *)pCom->Request();
                SCARD_IO_REQUEST *pioReq = (SCARD_IO_REQUEST *)pCom->Parse(pReq->dscSendPci, &cbPci);
                LPCBYTE pbSendData = (LPCBYTE)pCom->Parse(pReq->dscSendBuffer, &cbData);
                cout
                    << TEXT("Transmit request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << TEXT("PCI:\n")
                    << flush;
                dump((LPCBYTE)pioReq, cbPci, cout);
                cout
                    << TEXT("Data:\n")
                    << flush;
                dump(pbSendData, cbData, cout);
                cout
                    << TEXT("Return PCI Length:   ") << PDec(pReq->dwPciLength) << TEXT("\n")
                    << TEXT("Return Data Length:  ") << PDec(pReq->dwRecvLength) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::Control_request:
            {
                ComControl::CObjControl_request *pReq
                    = (ComControl::CObjControl_request *)pCom->Request();
                LPCBYTE pbInData = (LPCBYTE)pCom->Parse(pReq->dscInBuffer, &dwLen);
                cout
                    << TEXT("Control request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                MapValue(cout, pReq->dwControlCode,
                       TEXT("Control Code:        "), rgMapIoctl);
                cout << TEXT("Control Data:\n") << flush;
                dump(pbInData, dwLen, cout);
                cout
                    << TEXT("Return Data Length:  ") << PDec(pReq->dwOutLength) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::GetAttrib_request:
            {
                ComGetAttrib::CObjGetAttrib_request *pReq
                    = (ComGetAttrib::CObjGetAttrib_request *)pCom->Request();
                cout
                    << TEXT("Get Attribute request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                MapValue(cout, pReq->dwAttrId,
                       TEXT("Attribute:           "), rgMapAttr);
                cout
                    << TEXT("Return Data Length:  ") << PDec(pReq->dwOutLength) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::SetAttrib_request:
            {
                ComSetAttrib::CObjSetAttrib_request *pReq
                    = (ComSetAttrib::CObjSetAttrib_request *)pCom->Request();
                LPCBYTE pbAttr = (LPCBYTE)pCom->Parse(pReq->dscAttr, &dwLen);
                cout
                    << TEXT("Set Attribute request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                MapValue(cout, pReq->dwAttrId,
                       TEXT("Attribute:           "), rgMapAttr);
                cout << TEXT("Data:") << endl;
                dump(pbAttr, dwLen, cout);
                break;
            }

            case CComObject::EstablishContext_response:
            {
                ComEstablishContext::CObjEstablishContext_response *pRsp
                    = (ComEstablishContext::CObjEstablishContext_response *)pCom->Response();
                cout
                    << TEXT("Establish Context response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    LPCTSTR szCancelEvent = (LPCTSTR)pCom->Parse(pRsp->dscCancelEvent);
                    cout
                        << TEXT("Alt Event Name:      ") << szCancelEvent << TEXT("\n")
                        << flush;
                }
                break;
            }

            case CComObject::ReleaseContext_response:
            {
                ComReleaseContext::CObjReleaseContext_response *pRsp =
                    (ComReleaseContext::CObjReleaseContext_response *)pCom->Response();
                cout
                    << TEXT("Release Context response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::IsValidContext_response:
            {
                ComIsValidContext::CObjIsValidContext_response *pRsp =
                    (ComIsValidContext::CObjIsValidContext_response *)pCom->Response();
                cout
                    << TEXT("Is Valid Context response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::LocateCards_response:
            {
                DWORD dwIndex, dwAtrLen;
                ComLocateCards::CObjLocateCards_response *pRsp =
                    (ComLocateCards::CObjLocateCards_response *)pCom->Response();
                cout
                    << TEXT("Locate Cards response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    LPDWORD rgdwStates = (LPDWORD)pCom->Parse(pRsp->dscReaderStates, &dwLen);
                    LPCBYTE pbAtrs = (LPCBYTE)pCom->Parse(pRsp->dscAtrs);

                    dwLen /= sizeof(DWORD);
                    for (dwIndex = 0; dwIndex < dwLen; dwIndex += 1)
                    {
                        cout << TEXT("Mask:\n        ") << flush;
                        if (0 == rgdwStates[dwIndex])
                            cout << TEXT("SCARD_STATE_UNAWARE") << endl;
                        MaskValue(cout, rgdwStates[dwIndex], NULL, rgMapStates);
                        cout << TEXT("ATR:\n") << flush;
                        dwAtrLen = *pbAtrs++;
                        dump(pbAtrs, dwAtrLen, cout);
                        pbAtrs += dwAtrLen;
                    }
                }
                break;
            }

            case CComObject::GetStatusChange_response:
            {
                DWORD dwIndex, dwAtrLen;
                ComGetStatusChange::CObjGetStatusChange_response *pRsp =
                    (ComGetStatusChange::CObjGetStatusChange_response *)pCom->Response();
                cout
                    << TEXT("Get Status Change response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    LPDWORD rgdwStates = (LPDWORD)pCom->Parse(pRsp->dscReaderStates, &dwLen);
                    LPCBYTE pbAtrs = (LPCBYTE)pCom->Parse(pRsp->dscAtrs);

                    dwLen /= sizeof(DWORD);
                    for (dwIndex = 0; dwIndex < dwLen; dwIndex += 1)
                    {
                        cout << TEXT("Mask:\n") << flush;
                        if (0 == rgdwStates[dwIndex])
                            cout << TEXT("        SCARD_STATE_UNAWARE") << endl;
                        else
                            MaskValue(cout, rgdwStates[dwIndex], TEXT("        "), rgMapStates);
                        cout << TEXT("ATR:\n") << flush;
                        dwAtrLen = *pbAtrs++;
                        dump(pbAtrs, dwAtrLen, cout);
                        pbAtrs += dwAtrLen;
                    }
                }
                break;
            }

            case CComObject::ListReaders_response:
            {
                DWORD dwIndex;

                ComListReaders::CObjListReaders_response *pRsp =
                    (ComListReaders::CObjListReaders_response *)pCom->Response();
                cout
                    << TEXT("List Readers response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    LPDWORD pdwReaders = (LPDWORD)pCom->Parse(pRsp->dscReaders, &dwLen);
                    cout
                        << TEXT("Readers:\n")
                        << flush;
                    dwLen /= sizeof(DWORD);
                    for (dwIndex = 0; dwIndex < dwLen; dwIndex += 1)
                    {
                        if (0 != pdwReaders[dwIndex])
                            cout << TEXT("    Present") << endl;
                        else
                            cout << TEXT("    Offline") << endl;
                    }
                }
                break;
            }

            case CComObject::Connect_response:
            {
                ComConnect::CObjConnect_response *pRsp
                    = (ComConnect::CObjConnect_response *)pCom->Response();
                cout
                    << TEXT("Connect response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    cout
                        << TEXT("SCARDHANDLE:         ") << PHex(pRsp->hCard) << TEXT("\n")
                        << flush;
                    MapValue(cout, pRsp->dwActiveProtocol,
                        TEXT("Protocol:            "), rgMapProto);
                }
                break;
            }

            case CComObject::Reconnect_response:
            {
                ComReconnect::CObjReconnect_response *pRsp
                    = (ComReconnect::CObjReconnect_response *)pCom->Response();
                cout
                    << TEXT("Reconnect response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    MapValue(cout, pRsp->dwActiveProtocol,
                        TEXT("Protocol:            "), rgMapProto);
                }
                break;
            }

            case CComObject::Disconnect_response:
            {
                ComDisconnect::CObjDisconnect_response *pRsp
                    = (ComDisconnect::CObjDisconnect_response *)pCom->Response();
                cout
                    << TEXT("Disconnect response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::BeginTransaction_response:
            {
                ComBeginTransaction::CObjBeginTransaction_response *pRsp
                    = (ComBeginTransaction::CObjBeginTransaction_response *)
                        pCom->Response();
                cout
                    << TEXT("Begin Transaction response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::EndTransaction_response:
            {
                ComEndTransaction::CObjEndTransaction_response *pRsp
                    = (ComEndTransaction::CObjEndTransaction_response *)pCom->Response();
                cout
                    << TEXT("End Transaction response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::Status_response:
            {
                DWORD cbAtrLen;
                ComStatus::CObjStatus_response *pRsp
                    = (ComStatus::CObjStatus_response *)pCom->Response();
                cout
                    << TEXT("Status response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    LPCBYTE pbAtr = (LPCBYTE)pCom->Parse(pRsp->dscAtr, &cbAtrLen);
                    LPCTSTR szRdr = (LPCTSTR)pCom->Parse(pRsp->dscSysName);

                    MapValue(cout, pRsp->dwState,
                        TEXT("State:               "), rgMapDriverStates);
                    MapValue(cout, pRsp->dwProtocol,
                        TEXT("Protocol:            "), rgMapProto);
                    cout
                        << TEXT("ATR:\n")
                        << flush;
                    dump(pbAtr, cbAtrLen, cout);
                    cout
                        << TEXT("Reader Sys Name: ") << szRdr << endl;
                }
                break;
            }

            case CComObject::Transmit_response:
            {
                DWORD cbPci, cbData;
                ComTransmit::CObjTransmit_response *pRsp
                    = (ComTransmit::CObjTransmit_response *)pCom->Response();
                cout
                    << TEXT("Transmit response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    SCARD_IO_REQUEST *pioRsp = (SCARD_IO_REQUEST *)pCom->Parse(pRsp->dscRecvPci, &cbPci);
                    LPCBYTE pbRecvData = (LPCBYTE)pCom->Parse(pRsp->dscRecvBuffer, &cbData);
                    cout
                        << TEXT("PCI:\n")
                        << flush;
                    dump((LPCBYTE)pioRsp, cbPci, cout);
                    cout
                        << TEXT("Data:\n")
                        << flush;
                    dump(pbRecvData, cbData, cout);
                }
                break;
            }

            case CComObject::Control_response:
            {
                ComControl::CObjControl_response *pRsp
                    = (ComControl::CObjControl_response *)pCom->Response();
                LPCBYTE pbData = (LPCBYTE)pCom->Parse(pRsp->dscOutBuffer, &dwLen);
                cout
                    << TEXT("Control response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    LPCBYTE pbData = (LPCBYTE)pCom->Parse(pRsp->dscOutBuffer, &dwLen);
                    cout
                        << TEXT("Data:\n")
                        << flush;
                    dump(pbData, dwLen, cout);
                }
                break;
            }

            case CComObject::GetAttrib_response:
            {
                ComGetAttrib::CObjGetAttrib_response *pRsp
                    = (ComGetAttrib::CObjGetAttrib_response *)pCom->Response();
                cout
                    << TEXT("Get Attribute response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    LPCBYTE pbData = (LPCBYTE)pCom->Parse(pRsp->dscAttr, &dwLen);
                    cout
                        << TEXT("Data:\n")
                        << flush;
                    dump(pbData, dwLen, cout);
                }
                break;
            }

            case CComObject::SetAttrib_response:
            {
                ComSetAttrib::CObjSetAttrib_response *pRsp
                    = (ComSetAttrib::CObjSetAttrib_response *)pCom->Response();
                cout
                    << TEXT("Set Attribute response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                break;
            }

            default:
                if (0 == (1 & pCom->Type()))
                {
                    CComObject::CObjGeneric_request *pReq
                        = (CComObject::CObjGeneric_request *)pCom->Request();
                    cout
                        << TEXT("Unrecognized request\n")
                        << flush;
                }
                else
                {
                    CComObject::CObjGeneric_response *pRsp
                        = (CComObject::CObjGeneric_response *)pCom->Response();
                    cout
                        << TEXT("Unrecognized response\n")
                        << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                        << flush;
                }
            }

            delete pCom;
            pCom = NULL;
        }
    }
    catch (...)
    {
        if (NULL != pCom)
            delete pCom;
        cerr << TEXT("\n*** ERROR *** Exception parsing log file") << endl;
    }

ErrorExit:
    if (NULL != hLogFile)
        CloseHandle(hLogFile);
}


/*++

ReceiveComObject:

    This routine creates the proper CComObject child object for the data
    coming in from a log file.

Arguments:

    hFile supplies the file handle from which the data is to be extracted.

Return Value:

    The newly created CComObject child object.  This object must be cleaned up
    via the delete command.

Throws:

    ?exceptions?

Author:

    Doug Barlow (dbarlow) 11/13/1996

--*/

CComObject *
ReceiveComObject(
    HANDLE hFile)
{
    CComObject *pCom = NULL;

    try
    {
        DWORD rgdwInData[2];
        DWORD dwLen;
        BOOL fSts;


        //
        // See what's coming.
        //

        fSts = ReadFile(
                hFile,
                rgdwInData,
                sizeof(rgdwInData),
                &dwLen,
                NULL);
        if (!fSts)
        {
            DWORD dwSts = GetLastError();
            switch (dwSts)
            {
            case ERROR_HANDLE_EOF:
                throw dwSts;
                break;
            default:
                cerr << TEXT("Can't read input file: ")
                     << ErrorString(dwSts);
                throw dwSts;
            }
        }
        else if (0 == dwLen)
            throw (DWORD)ERROR_HANDLE_EOF;
        else if (dwLen != sizeof(rgdwInData))
            throw (DWORD)SCARD_F_COMM_ERROR;

        switch (rgdwInData[0])  // dwCommndId
        {
        case CComObject::EstablishContext_request:
            pCom = new ComEstablishContext;
            break;
        case CComObject::EstablishContext_response:
            pCom = new ComEstablishContext;
            break;
        case CComObject::ReleaseContext_request:
            pCom = new ComReleaseContext;
            break;
        case CComObject::ReleaseContext_response:
            pCom = new ComReleaseContext;
            break;
        case CComObject::IsValidContext_request:
            pCom = new ComIsValidContext;
            break;
        case CComObject::IsValidContext_response:
            pCom = new ComIsValidContext;
            break;
        case CComObject::ListReaders_request:
            pCom = new ComListReaders;
            break;
        case CComObject::ListReaders_response:
            pCom = new ComListReaders;
            break;
#if 0
        case CComObject::ListReaderGroups_request:
            pCom = new ComListReaderGroups;
            break;
        case CComObject::ListReaderGroups_response:
            pCom = new ComListReaderGroups;
            break;
        case CComObject::ListCards_request:
            pCom = new ComListCards;
            break;
        case CComObject::ListCards_response:
            pCom = new ComListCards;
            break;
        case CComObject::ListInterfaces_request:
            pCom = new ComListInterfaces;
            break;
        case CComObject::ListInterfaces_response:
            pCom = new ComListInterfaces;
            break;
        case CComObject::GetProviderId_request:
            pCom = new ComGetProviderId;
            break;
        case CComObject::GetProviderId_response:
            pCom = new ComGetProviderId;
            break;
        case CComObject::IntroduceReaderGroup_request:
            pCom = new ComIntroduceReaderGroup;
            break;
        case CComObject::IntroduceReaderGroup_response:
            pCom = new ComIntroduceReaderGroup;
            break;
        case CComObject::ForgetReaderGroup_request:
            pCom = new ComForgetReaderGroup;
            break;
        case CComObject::ForgetReaderGroup_response:
            pCom = new ComForgetReaderGroup;
            break;
        case CComObject::IntroduceReader_request:
            pCom = new ComIntroduceReader;
            break;
        case CComObject::IntroduceReader_response:
            pCom = new ComIntroduceReader;
            break;
        case CComObject::ForgetReader_request:
            pCom = new ComForgetReader;
            break;
        case CComObject::ForgetReader_response:
            pCom = new ComForgetReader;
            break;
        case CComObject::AddReaderToGroup_request:
            pCom = new ComAddReaderToGroup;
            break;
        case CComObject::AddReaderToGroup_response:
            pCom = new ComAddReaderToGroup;
            break;
        case CComObject::RemoveReaderFromGroup_request:
            pCom = new ComRemoveReaderFromGroup;
            break;
        case CComObject::RemoveReaderFromGroup_response:
            pCom = new ComRemoveReaderFromGroup;
            break;
        case CComObject::IntroduceCardType_request:
            pCom = new ComIntroduceCardType;
            break;
        case CComObject::IntroduceCardType_response:
            pCom = new ComIntroduceCardType;
            break;
        case CComObject::ForgetCardType_request:
            pCom = new ComForgetCardType;
            break;
        case CComObject::ForgetCardType_response:
            pCom = new ComForgetCardType;
            break;
        case CComObject::FreeMemory_request:
            pCom = new ComFreeMemory;
            break;
        case CComObject::FreeMemory_response:
            pCom = new ComFreeMemory;
            break;
        case CComObject::Cancel_request:
            pCom = new ComCancel;
            break;
        case CComObject::Cancel_response:
            pCom = new ComCancel;
            break;
#endif
        case CComObject::LocateCards_request:
            pCom = new ComLocateCards;
            break;
        case CComObject::LocateCards_response:
            pCom = new ComLocateCards;
            break;
        case CComObject::GetStatusChange_request:
            pCom = new ComGetStatusChange;
            break;
        case CComObject::GetStatusChange_response:
            pCom = new ComGetStatusChange;
            break;
        case CComObject::Connect_request:
            pCom = new ComConnect;
            break;
        case CComObject::Connect_response:
            pCom = new ComConnect;
            break;
        case CComObject::Reconnect_request:
            pCom = new ComReconnect;
            break;
        case CComObject::Reconnect_response:
            pCom = new ComReconnect;
            break;
        case CComObject::Disconnect_request:
            pCom = new ComDisconnect;
            break;
        case CComObject::Disconnect_response:
            pCom = new ComDisconnect;
            break;
        case CComObject::BeginTransaction_request:
            pCom = new ComBeginTransaction;
            break;
        case CComObject::BeginTransaction_response:
            pCom = new ComBeginTransaction;
            break;
        case CComObject::EndTransaction_request:
            pCom = new ComEndTransaction;
            break;
        case CComObject::EndTransaction_response:
            pCom = new ComEndTransaction;
            break;
        case CComObject::Status_request:
            pCom = new ComStatus;
            break;
        case CComObject::Status_response:
            pCom = new ComStatus;
            break;
        case CComObject::Transmit_request:
            pCom = new ComTransmit;
            break;
        case CComObject::Transmit_response:
            pCom = new ComTransmit;
            break;
        case CComObject::OpenReader_request:
            pCom = new ComOpenReader;
            break;
        case CComObject::OpenReader_response:
            pCom = new ComOpenReader;
            break;
        case CComObject::Control_request:
            pCom = new ComControl;
            break;
        case CComObject::Control_response:
            pCom = new ComControl;
            break;
        case CComObject::GetAttrib_request:
            pCom = new ComGetAttrib;
            break;
        case CComObject::GetAttrib_response:
            pCom = new ComGetAttrib;
            break;
        case CComObject::SetAttrib_request:
            pCom = new ComSetAttrib;
            break;
        case CComObject::SetAttrib_response:
            pCom = new ComSetAttrib;
            break;
        default:
            CalaisWarning(
                DBGT("ReceiveComObject"),
                DBGT("Invalid Comm Object Id on pipe"));
            throw (DWORD)SCARD_F_COMM_ERROR;
        }

        if (0 == (rgdwInData[0] & 0x01))    // Request or response?
            pCom->m_pbfActive = &pCom->m_bfRequest;
        else
            pCom->m_pbfActive = &pCom->m_bfResponse;


        //
        // Pull it in.
        //

        pCom->m_pbfActive->Resize(rgdwInData[1]);
        CopyMemory(
            pCom->m_pbfActive->Access(),
            rgdwInData,
            sizeof(rgdwInData));
        fSts = ReadFile(
                hFile,
                pCom->m_pbfActive->Access(sizeof(rgdwInData)),
                rgdwInData[1] - sizeof(rgdwInData),
                &dwLen,
                NULL);
        if (!fSts)
        {
            DWORD dwSts = GetLastError();
            cerr << TEXT("Can't read input file: ")
                 << ErrorString(dwSts);
            throw dwSts;
        }
    }

    catch (...)
    {
        if (NULL != pCom)
        {
            delete pCom;
            pCom = NULL;
        }
    }

    return pCom;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\sctest\sctest\wpscproxy.h ===
#ifndef _WPSCPROXY_H_DEF_
#define _WPSCPROXY_H_DEF_

#include <winscard.h>

// Basic types
typedef signed char    INT8;
typedef signed short   INT16;
typedef unsigned char  UINT8;
typedef unsigned short UINT16;

// Derived types for API
typedef UINT8   TCOUNT;
typedef UINT16  ADDRESS;
typedef UINT16  TOFFSET;
typedef UINT8   TUID;
typedef UINT8   HACL;

typedef WCHAR *WSTR;
typedef const WCHAR *WCSTR;

#include "wpscoserr.h"

#ifdef __cplusplus
extern "C" {
#endif

/* PC/SC */
typedef LONG (WINAPI *LPFNSCWTRANSMITPROC)(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut);

#define NULL_TX		((SCARDHANDLE)(-1))		// To indicate to use scwwinscard.dll vs winscard.dll
#define NULL_TX_NAME ((LPCWSTR)(-1))		// To indicate to use scwwinscard.dll vs winscard.dll

	// Different scenarios:
	// Non PC/SC apps: call hScwAttachToCard(NULL, NULL, &hCard), hScwSetTransmitCallback & hScwSetEndianness
	// PC/SC apps not connecting themselves: call hScwAttachToCard(NULL, mszCardNames, &hCard)
	// PC/SC apps connecting themselves: call hScwAttachToCard(hCard, NULL, &hCard)
	// For simulator use replace NULL by NULL_TX in the 2 above lines
	// PC/SC hScwAttachToCard will call hScwSetTransmitCallback & hScwSetEndianness (the ATR better
	// be compliant (endianness in 1st historical bytes) or call hScwSetEndianness with
	// appropriate value).
SCODE WINAPI hScwAttachToCard(SCARDHANDLE hCard, LPCWSTR mszCardNames, LPSCARDHANDLE phCard);
SCODE WINAPI hScwAttachToCardEx(SCARDHANDLE hCard, LPCWSTR mszCardNames, BYTE byINS, LPSCARDHANDLE phCard);
SCODE WINAPI hScwSetTransmitCallback(SCARDHANDLE hCard, LPFNSCWTRANSMITPROC lpfnProc);
SCODE WINAPI hScwDetachFromCard(SCARDHANDLE hCard);
SCODE WINAPI hScwSCardBeginTransaction(SCARDHANDLE hCard);
SCODE WINAPI hScwSCardEndTransaction(SCARDHANDLE hCard, DWORD dwDisposition);

/*
** Constants
*/

// File attribute Flags. Some are used by the system (defined below.) 
// The rest are available for application use
#define SCW_FILEATTR_DIRF  (UINT16)(0x8000)    // The file defined by this entry is a sub directory
#define SCW_FILEATTR_ACLF  (UINT16)(0x4000)    // The file defined by this entry is an ACL file
#define SCW_FILEATTR_ROMF  (UINT16)(0x2000)    // The file defined by this entry is in ROM
#define SCW_FILEATTR_RSRV2 (UINT16)(0x1000)   
// Bits that cannot be changed by ScwSetFileAttributes
#define SCW_FILEATTR_PBITS (UINT16)(SCW_FILEATTR_DIRF|SCW_FILEATTR_ACLF|SCW_FILEATTR_ROMF|SCW_FILEATTR_RSRV2)

/* File seek */
#define FILE_BEGIN      0
#define FILE_CURRENT    1
#define FILE_END        2

/* Access Control */
#define SCW_ACLTYPE_DISJUNCTIVE 0x00
#define SCW_ACLTYPE_CONJUNCTIVE 0x01

/*
** Maximum Known principals and Groups
*/
#define SCW_MAX_NUM_PRINCIPALS     40

/*
** Authentication Protocols
*/
#define SCW_AUTHPROTOCOL_AOK    0x00    // Always returns SCW_S_OK
#define SCW_AUTHPROTOCOL_PIN    0x01    // Personal Identification Number
#define SCW_AUTHPROTOCOL_DES	0x05	// DES authentication
#define SCW_AUTHPROTOCOL_3DES	0x06	// Triple DES authentication
#define SCW_AUTHPROTOCOL_RTE	0x07	// RTE applet as an auth. protocol
#define SCW_AUTHPROTOCOL_NEV    0xFF    // Always returns SCW_E_NOTAUTHENTICATED

/* Well-known UIDs */
#define SCW_PRINCIPALUID_INVALID        0x00    // Invalid UID
#define SCW_PRINCIPALUID_ANONYMOUS      0x01    

/* ResoureTypes */
#define SCW_RESOURCETYPE_FILE                   0x00
#define SCW_RESOURCETYPE_DIR                    0x10
#define SCW_RESOURCETYPE_COMMAND                0x20   // reserved for future use
#define SCW_RESOURCETYPE_CHANNEL                0x30   // reserved for future use
#define SCW_RESOURCETYPE_ANY                    0xE0

/* Resource Operation on RESOURCETYPE_FILE */
#define SCW_RESOURCEOPERATION_FILE_READ             (SCW_RESOURCETYPE_FILE | 0x01)
#define SCW_RESOURCEOPERATION_FILE_WRITE            (SCW_RESOURCETYPE_FILE | 0x02)
#define SCW_RESOURCEOPERATION_FILE_EXECUTE          (SCW_RESOURCETYPE_FILE | 0x03)
#define SCW_RESOURCEOPERATION_FILE_EXTEND           (SCW_RESOURCETYPE_FILE | 0x04)
#define SCW_RESOURCEOPERATION_FILE_DELETE           (SCW_RESOURCETYPE_FILE | 0x05)
#define SCW_RESOURCEOPERATION_FILE_GETATTRIBUTES    (SCW_RESOURCETYPE_FILE | 0x06)
#define SCW_RESOURCEOPERATION_FILE_SETATTRIBUTES    (SCW_RESOURCETYPE_FILE | 0x07)
#define SCW_RESOURCEOPERATION_FILE_CRYPTO	        (SCW_RESOURCETYPE_FILE | 0x08)
#define SCW_RESOURCEOPERATION_FILE_INCREASE	        (SCW_RESOURCETYPE_FILE | 0x09)
#define SCW_RESOURCEOPERATION_FILE_INVALIDATE       (SCW_RESOURCETYPE_FILE | 0x0A)
#define SCW_RESOURCEOPERATION_FILE_REHABILITATE     (SCW_RESOURCETYPE_FILE | 0x0B)


/* resourceOperation on RESOURCETYPE_DIR */
#define SCW_RESOURCEOPERATION_DIR_ACCESS            (SCW_RESOURCETYPE_DIR | 0x01)
#define SCW_RESOURCEOPERATION_DIR_CREATEFILE        (SCW_RESOURCETYPE_DIR | 0x02)
#define SCW_RESOURCEOPERATION_DIR_ENUM              (SCW_RESOURCETYPE_DIR | 0x03)
#define SCW_RESOURCEOPERATION_DIR_DELETE            (SCW_RESOURCETYPE_DIR | 0x04)
#define SCW_RESOURCEOPERATION_DIR_GETATTRIBUTES     (SCW_RESOURCETYPE_DIR | 0x05)
#define SCW_RESOURCEOPERATION_DIR_SETATTRIBUTES     (SCW_RESOURCETYPE_DIR | 0x06)

/* resourceOperation on any resource */
#define SCW_RESOURCEOPERATION_SETACL                ((BYTE)(SCW_RESOURCETYPE_ANY | 0x1D))
#define SCW_RESOURCEOPERATION_GETACL                ((BYTE)(SCW_RESOURCETYPE_ANY | 0x1E))
#define SCW_RESOURCEOPERATION_ANY                   ((BYTE)(SCW_RESOURCETYPE_ANY | 0x1F))

/* Cryptographic Mechanisms */
#define CM_SHA			0x80
#define CM_DES			0x90
#define CM_3DES			0xA0 // triple DES
#define CM_RSA			0xB0
#define CM_RSA_CRT		0xC0
#define CM_CRYPTO_NAME	0xF0 // mask for crypto mechanism names

#define CM_KEY_INFILE	0x01	// if key is passed in a file
#define CM_DATA_INFILE	0x02	// if data is passed in a file
#define CM_PROPERTIES	0x0F	// maks for crypto properites

// DES mode, keys and initial feedback buffer in cryptoBuffer
/* DES */

#define MODE_DES_ENCRYPT	0x00
#define MODE_DES_DECRYPT	0x20	//bit 5

#define MODE_DES_CBC		0x40	//bit 6
#define MODE_DES_MAC		0x10	//bit 4
#define MODE_DES_ECB		0x00

/* Triple DES */
#define MODE_TWO_KEYS_3DES		0x01	//bit 1 - if not set 3DES is working with 3 keys
#define MODE_THREE_KEYS_3DES	0x00

/* RSA */
#define MODE_RSA_SIGN		0x00
#define MODE_RSA_AUTH		0x01
#define MODE_RSA_KEYGEN		0x02

/* File System */
SCODE WINAPI hScwCreateFile(SCARDHANDLE hCard, WCSTR wszFileName, WCSTR wszAclFileName, HFILE *phFile);
SCODE WINAPI hScwCreateDirectory(SCARDHANDLE hCard, WCSTR wszDirName, WCSTR wszAclFileName);
SCODE WINAPI hScwDeleteFile(SCARDHANDLE hCard, WCSTR wszFileName);
SCODE WINAPI hScwCloseFile(SCARDHANDLE hCard, HFILE hFile);
SCODE WINAPI hScwReadFile(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, TCOUNT nRequestedBytes, TCOUNT *pnActualBytes);
SCODE WINAPI hScwWriteFile(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, TCOUNT nRequestedBytes, TCOUNT *pnActualBytes);
SCODE WINAPI hScwGetFileLength(SCARDHANDLE hCard, HFILE hFile, TOFFSET *pnFileLength);
SCODE WINAPI hScwSetFileLength(SCARDHANDLE hCard, HFILE hFile, TOFFSET nFileLength);
SCODE WINAPI hScwReadFile32(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, DWORD nRequestedBytes, DWORD *pnActualBytes);
SCODE WINAPI hScwWriteFile32(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, DWORD nRequestedBytes, DWORD *pnActualBytes);

SCODE WINAPI hScwGetFileAttributes(SCARDHANDLE hCard, WCSTR wszFileName, UINT16 *pnValue);
SCODE WINAPI hScwSetFileAttributes(SCARDHANDLE hCard, WCSTR wszFileName, UINT16 nValue);

SCODE WINAPI hScwSetFilePointer(SCARDHANDLE hCard, HFILE hFile, INT16 iDistance, BYTE bMode);
SCODE WINAPI hScwEnumFile(SCARDHANDLE hCard, WCSTR wszDirectoryName, UINT16 *pnFileCookie, WSTR wszFileName, TCOUNT nBufferSize);
SCODE WINAPI hScwSetFileACL(SCARDHANDLE hCard, WCSTR wszFileName, WCSTR wszAclFileName);
SCODE WINAPI hScwGetFileAclHandle(SCARDHANDLE hCard, WCSTR wszFileName, HFILE *phFile);

/* Access Control */
SCODE WINAPI hScwAuthenticateName(SCARDHANDLE hCard, WCSTR wszPrincipalName, BYTE *pbSupportData, TCOUNT nSupportDataLength);
SCODE WINAPI hScwDeauthenticateName(SCARDHANDLE hCard, WCSTR wszPrincipalName);
SCODE WINAPI hScwIsAuthenticatedName(SCARDHANDLE hCard, WCSTR wszPrincipalName);
SCODE WINAPI hScwIsAuthorized(SCARDHANDLE hCard, WCSTR wszResourceName, BYTE bOperation);
SCODE WINAPI hScwGetPrincipalUID(SCARDHANDLE hCard, WCSTR wszPrincipalName, TUID *pnPrincipalUID);
SCODE WINAPI hScwAuthenticateUID(SCARDHANDLE hCard, TUID nPrincipalUID, BYTE *pbSupportData, TCOUNT nSupportDataLength);
SCODE WINAPI hScwDeauthenticateUID(SCARDHANDLE hCard, TUID nPrincipalUID);
SCODE WINAPI hScwIsAuthenticatedUID(SCARDHANDLE hCard, TUID nPrincipalUID);

/* Runtime Environment (RTE) */
SCODE WINAPI hScwRTEExecute(SCARDHANDLE hCard, WCSTR wszCodeFileName, WCSTR wszDataFileName, UINT8 bRestart);

/* Cryptography */
SCODE WINAPI hScwCryptoInitialize(SCARDHANDLE hCard, BYTE bMechanism, BYTE *pbKeyMaterial);
SCODE WINAPI hScwCryptoAction(SCARDHANDLE hCard, BYTE *pbDataIn, TCOUNT nDataInLength, BYTE *pbDataOut, TCOUNT *pnDataOutLength);
SCODE WINAPI hScwCryptoUpdate(SCARDHANDLE hCard, BYTE *pbDataIn, TCOUNT nDataInLength);
SCODE WINAPI hScwCryptoFinalize(SCARDHANDLE hCard, BYTE *pbDataOut, TCOUNT *pnDataOutLength);
SCODE WINAPI hScwGenerateRandom(SCARDHANDLE hCard, BYTE *pbDataOut, TCOUNT nDataOutLength);

SCODE WINAPI hScwSetDispatchTable(SCARDHANDLE hCard, WCSTR wszFileName);

typedef struct {
	BYTE CLA;
	BYTE INS;
	BYTE P1;
	BYTE P2;
} ISO_HEADER;
typedef ISO_HEADER *LPISO_HEADER;
/*
	ScwExecute:
		I-:	lpxHdr (points to 4 bytes (CLA, INS, P1, P2))
		I-: InBuf (Incoming data from card's perspective (NULL -> no data in))
		I-: InBufLen (length of data pointed by InBuf)
		-O: OutBuf (Buffer that will receive the R-APDU (NULL -> no expected data))
		IO: pOutBufLen (I -> Size of OutBuf, O -> Number of bytes written in OutBuf)
		-O: pwSW (Card Status Word)
*/
SCODE WINAPI hScwExecute(SCARDHANDLE hCard, LPISO_HEADER lpxHdr, BYTE *InBuf, TCOUNT InBufLen, BYTE *OutBuf, TCOUNT *pOutBufLen, UINT16 *pwSW);

#ifdef __cplusplus
}
#endif

#endif	// ifndef _WPSCPROXY_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\svrapp\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	SvrApp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\svrapp\scappdev.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    scappdev

Abstract:

    This module provides the device-specific operations that must be performed
    by the controlling resource manager application.  Due to Plug 'n Play, there
    can't be a clean separation between device controller classes and the
    application driving them.  This module provides the hooks to isolate these
    interdependencies as much as possible.

Author:

    Doug Barlow (dbarlow) 4/3/1998

Environment:

    Win32, C++

Notes:

    ?Notes?

--*/

#include "stdafx.h"
#include <winsvc.h>
#include <dbt.h>
#include <scardlib.h>
#include <calmsgs.h>
#include "SvrApp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static const GUID l_guidSmartcards
                        = { // 50DD5230-BA8A-11D1-BF5D-0000F805F530
                            0x50DD5230,
                            0xBA8A,
                            0x11D1,
                            { 0xBF, 0x5D, 0x00, 0x00, 0xF8, 0x05, 0xF5, 0x30 } };

static HANDLE l_hService = NULL;
static DWORD l_dwType = 0;
static HDEVNOTIFY l_hIfDev = NULL;


/*++

AppInitializeDeviceRegistration:

    This routine is called by a controlling application in order to enable
    PnP and Power Management Events.

Arguments:

    hService supplies the handle to the service application.

    dwType supplies the type of handle supplied.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/

void
AppInitializeDeviceRegistration(
    HANDLE hService,
    DWORD dwType)
{

    //
    // Platform-specific initialization.
    //

    ASSERT(NULL == l_hService);
    DEV_BROADCAST_DEVICEINTERFACE dbcIfFilter;


    //
    // Save off the application information.
    //

    l_hService = hService;
    l_dwType = dwType;


    //
    // Register for PnP events.
    //

    ZeroMemory(&dbcIfFilter, sizeof(dbcIfFilter));
    dbcIfFilter.dbcc_size = sizeof(dbcIfFilter);
    dbcIfFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    // dbcIfFilter.dbcc_reserved = NULL;
    CopyMemory(
        &dbcIfFilter.dbcc_classguid,
        &l_guidSmartcards,
        sizeof(GUID));
    // dbcIfFilter.dbcc_name[1];

    l_hIfDev = RegisterDeviceNotification(
                    l_hService,
                    &dbcIfFilter,
                    l_dwType);
    if (NULL == l_hIfDev)
    {
        CalaisWarning(
            DBGT("Initialize device registration failed to register for PnP events: %1"),
            GetLastError());
    }
}


/*++

AppTerminateDeviceRegistration:

    This routine is called by a controlling application in order to terminate
    PnP and Power Management Events.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/

void
AppTerminateDeviceRegistration(
    void)
{

    //
    // Platform-specific initialization.
    //

        BOOL fSts;


    //
    // Unregister for PnP events.
    //

    if (NULL != l_hIfDev)
    {
        fSts = UnregisterDeviceNotification(l_hIfDev);
        if (!fSts)
        {
            CalaisWarning(
                DBGT("Terminate device registration failed to unregister from PnP events: %1"),
                GetLastError());
        }
    }

    l_hService = NULL;
    l_dwType = 0;
    l_hIfDev = NULL;
}


/*++

AppRegisterDevice:

    This routine is called by a Reader Device Object to inform the controlling
    application that it exists and is ready to follow the OS rules for removal.

Arguments:

    hReader supplies the handle to the open device.

    szReader supplies the name of the device.

    ppvAppState supplies a pointer to a storage location for this application
        associated with this device.  The use of this location is specific to
        the application.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/

void
AppRegisterDevice(
    HANDLE hReader,
    LPCTSTR szReader,
    LPVOID *ppvAppState)
{

    //
    // Platform-specific initialization.
    //

    DEV_BROADCAST_HANDLE dbcHandleFilter;
    HDEVNOTIFY *phDevNotify = (HDEVNOTIFY *)ppvAppState;


    //
    // Register for PnP events.
    //

    ASSERT(NULL == *phDevNotify);
    ZeroMemory(&dbcHandleFilter, sizeof(dbcHandleFilter));
    dbcHandleFilter.dbch_size = sizeof(dbcHandleFilter);
    dbcHandleFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
    dbcHandleFilter.dbch_handle = hReader;

    *phDevNotify = RegisterDeviceNotification(
                        l_hService,
                        &dbcHandleFilter,
                        l_dwType);
    if (NULL == *phDevNotify)
    {
        CalaisWarning(
            DBGT("Register device failed to register '%2' for PnP Device removal: %1"),
            GetLastError(),
            szReader);
    }
}


/*++

AppUnregisterDevice:

    This routine is called when a device wants to let the controlling
    application know that it is officially ceasing to exist.

Arguments:

    hReader supplies the handle to the open device.

    szReader supplies the name of the device.

    ppvAppState supplies a pointer to a storage location for this application
        associated with this device.  The use of this location is specific to
        the application.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/

void
AppUnregisterDevice(
    HANDLE hReader,
    LPCTSTR szReader,
    LPVOID *ppvAppState)
{


    //
    // Platform-specific initialization.
    //

    BOOL fSts;
    HDEVNOTIFY *phDevNotify = (HDEVNOTIFY *)ppvAppState;


    //
    // Unregister from PnP events.
    //

    if (NULL != *phDevNotify)
    {
        fSts = UnregisterDeviceNotification(*phDevNotify);
        if (!fSts)
        {
            CalaisWarning(
                DBGT("Unregister device failed to unregister '%2' from PnP Device removal: %1"),
                GetLastError(),
                szReader);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\svrapp\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\svrapp\svrapp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       svrapp.h
//
//--------------------------------------------------------------------------

// SvrApp.h : main header file for the SVRAPP application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CSvrAppApp:
// See SvrApp.cpp for the implementation of this class
//

class CSvrAppApp : public CWinApp
{
public:
	CSvrAppApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSvrAppApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CSvrAppApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\svrapp\svrapp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       svrapp.cpp
//
//--------------------------------------------------------------------------

// SvrApp.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "SvrApp.h"
#include "SvrAppDlg.h"
#include <SCardLib.h>
#include <CalServe.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSvrAppApp

BEGIN_MESSAGE_MAP(CSvrAppApp, CWinApp)
        //{{AFX_MSG_MAP(CSvrAppApp)
                // NOTE - the ClassWizard will add and remove mapping macros here.
                //    DO NOT EDIT what you see in these blocks of generated code!
        //}}AFX_MSG
        ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSvrAppApp construction

CSvrAppApp::CSvrAppApp()
{
        // TODO: add construction code here,
        // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CSvrAppApp object

CSvrAppApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CSvrAppApp initialization

BOOL CSvrAppApp::InitInstance()
{
        // Standard initialization
        // If you are not using these features and wish to reduce the size
        //  of your final executable, you should remove from the following
        //  the specific initialization routines you do not need.

#ifdef _AFXDLL
        Enable3dControls();                     // Call this when using MFC in a shared DLL
#else
        Enable3dControlsStatic();       // Call this when linking to MFC statically
#endif

        CSvrAppDlg dlg;
        m_pMainWnd = &dlg;
        int nResponse = dlg.DoModal();
        if (nResponse == IDOK)
        {
                // TODO: Place code here to handle when the dialog is
                //  dismissed with OK
        }
        else if (nResponse == IDCANCEL)
        {
                // TODO: Place code here to handle when the dialog is
                //  dismissed with Cancel
        }

        // Since the dialog has been closed, return FALSE so that we exit the
        //  application, rather than start the application's message pump.
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\svrapp\svrappdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       svrappdlg.h
//
//--------------------------------------------------------------------------

// SvrAppDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSvrAppDlg dialog

class CSvrAppDlg : public CDialog
{
// Construction
public:
    CSvrAppDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CSvrAppDlg)
    enum { IDD = IDD_SVRAPP_DIALOG };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSvrAppDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    HDEVNOTIFY m_hIfDev;
    HICON m_hIcon;
    CRITICAL_SECTION m_csMessageLock;

    // Generated message map functions
    //{{AFX_MSG(CSvrAppDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnStart();
    afx_msg void OnStop();
    afx_msg OnDeviceChange(UINT nEventType, DWORD_PTR dwData);
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\tclcrypt\cspdirct.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    cspDirect

Abstract:

    This file provides direct linkage to a CSP, so it does not have to be in a
    separate DLL.  This facilitates code generation and debugging.

Author:

    Doug Barlow (dbarlow) 5/8/1996

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#include <wincrypt.h>
#include "cspdirct.h"

#ifdef _CSPDIRECT_H_

#include <crtdbg.h>
#define ASSERT(x) _ASSERTE(x)
#define breakpoint _CrtDbgBreak()
// #define breakpoint

static int WINAPI
SayYes(
    IN LPCTSTR szImage,
    IN LPBYTE pbSignature)
{
    return TRUE;
}

static int WINAPI
GetWnd(
    HWND *phWnd)
{
    if (NULL != phWnd)
        *phWnd = NULL;
    return (int)NULL;
}

static VTableProvStruc
    VTable
        = { 2,                  // DWORD   Version;
            (FARPROC)SayYes,    // FARPROC FuncVerifyImage;
            (FARPROC)GetWnd,    // FARPROC FuncReturnhWnd;
            1,                  // DWORD   dwProvType;
            NULL,               // BYTE    *pbContextInfo;
            0 };                // DWORD   cbContextInfo;
static HCRYPTPROV
    g_hProv
        = NULL;


CSPBOOL
CSPAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags)
{
#ifdef UNICODE
    return CRYPT_FAILED;
#else
    BOOL fSts;
    breakpoint;
    fSts =
        CPAcquireContext(
            phProv,
            pszContainer,
            dwFlags,
            &VTable);
    g_hProv = *phProv;
    return fSts;
#endif
}

CSPBOOL
CSPAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags)
{
#ifdef UNICODE
    BOOL fSts;
    breakpoint;
    fSts =
        CPAcquireContext(
            phProv,
            pszContainer,
            dwFlags,
            &VTable);
    g_hProv = *phProv;
    return fSts;
#else
    return CRYPT_FAILED;
#endif
}

CSPBOOL
CSPReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags)
{
    ASSERT(g_hProv == hProv);
    g_hProv = NULL;
    breakpoint;
    return
        CPReleaseContext(
            hProv,
            dwFlags);
}

CSPBOOL
CSPGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPGenKey(
            hProv,
            Algid,
            dwFlags,
            phKey);
}

CSPBOOL
CSPDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPDeriveKey(
            hProv,
            Algid,
            hBaseData,
            dwFlags,
            phKey);
}

CSPBOOL
CSPDestroyKey(
    HCRYPTKEY hKey)
{
    breakpoint;
    return
        CPDestroyKey(
            g_hProv,
            hKey);
}

CSPBOOL
CSPSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags)
{
    breakpoint;
    return
        CPSetKeyParam(
            g_hProv,
            hKey,
            dwParam,
            pbData,
            dwFlags);
}

CSPBOOL
CSPGetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags)
{
    breakpoint;
    return
        CPGetKeyParam(
            g_hProv,
            hKey,
            dwParam,
            pbData,
            pdwDataLen,
            dwFlags);
}

CSPBOOL
CSPSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags)
{
    breakpoint;
    return
        CPSetHashParam(
            g_hProv,
            hHash,
            dwParam,
            pbData,
            dwFlags);
}

CSPBOOL
CSPGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags)
{
    breakpoint;
    return
        CPGetHashParam(
            g_hProv,
            hHash,
            dwParam,
            pbData,
            pdwDataLen,
            dwFlags);
}

CSPBOOL
CSPSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPSetProvParam(
            hProv,
            dwParam,
            pbData,
            dwFlags);
}

CSPBOOL
CSPGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPGetProvParam(
            hProv,
            dwParam,
            pbData,
            pdwDataLen,
            dwFlags);
}

CSPBOOL
CSPGenRandom(
    HCRYPTPROV hProv,
    DWORD dwLen,
    BYTE *pbBuffer)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPGenRandom(
            hProv,
            dwLen,
            pbBuffer);
}

CSPBOOL
CSPGetUserKey(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPGetUserKey(
            hProv,
            dwKeySpec,
            phUserKey);
}

CSPBOOL
CSPExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen)
{
    breakpoint;
    return
        CPExportKey(
            g_hProv,
            hKey,
            hExpKey,
            dwBlobType,
            dwFlags,
            pbData,
            pdwDataLen);
}

CSPBOOL
CSPImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPImportKey(
            hProv,
            pbData,
            dwDataLen,
            hPubKey,
            dwFlags,
            phKey);
}

CSPBOOL
CSPEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen)
{
    breakpoint;
    return
        CPEncrypt(
            g_hProv,
            hKey,
            hHash,
            Final,
            dwFlags,
            pbData,
            pdwDataLen,
            dwBufLen);
}

CSPBOOL
CSPDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen)
{
    breakpoint;
    return
        CPDecrypt(
            g_hProv,
            hKey,
            hHash,
            Final,
            dwFlags,
            pbData,
            pdwDataLen);
}

CSPBOOL
CSPCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPCreateHash(
            hProv,
            Algid,
            hKey,
            dwFlags,
            phHash);
}

CSPBOOL
CSPHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags)
{
    breakpoint;
    return
        CPHashData(
            g_hProv,
            hHash,
            pbData,
            dwDataLen,
            dwFlags);
}

CSPBOOL
CSPHashSessionKey(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags)
{
    breakpoint;
    return
        CPHashSessionKey(
            g_hProv,
            hHash,
            hKey,
            dwFlags);
}

/*
CSPBOOL
CSPGetHashValue(
    HCRYPTHASH hHash,
    DWORD dwFlags,
    BYTE *pbHash,
    DWORD *pdwHashLen)
{
    breakpoint;
    return
        CPGetHashValue(
            g_hProv,
            hHash,
            dwFlags,
            pbHash,
            pdwHashLen);
}
*/

CSPBOOL
CSPDestroyHash(
    HCRYPTHASH hHash)
{
    breakpoint;
    return
        CPDestroyHash(
            g_hProv,
            hHash);
}

CSPBOOL
CSPSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen)
{
#ifdef UNICODE
    return CRYPT_FAILED;
#else
    breakpoint;
    return
        CPSignHash(
            g_hProv,
            hHash,
            dwKeySpec,
            sDescription,
            dwFlags,
            pbSignature,
            pdwSigLen);
#endif
}

CSPBOOL
CSPSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen)
{
#ifdef UNICODE
    breakpoint;
    return
        CPSignHash(
            g_hProv,
            hHash,
            dwKeySpec,
            sDescription,
            dwFlags,
            pbSignature,
            pdwSigLen);
#else
    return CRYPT_FAILED;
#endif
}

CSPBOOL
CSPVerifySignatureA(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags)
{
#ifdef UNICODE
    return CRYPT_FAILED;
#else
    breakpoint;
    return
        CPVerifySignature(
            g_hProv,
            hHash,
            pbSignature,
            dwSigLen,
            hPubKey,
            sDescription,
            dwFlags);
#endif
}

CSPBOOL
CSPVerifySignatureW(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags)
{
#ifdef UNICODE
    breakpoint;
    return
        CPVerifySignature(
            g_hProv,
            hHash,
            pbSignature,
            dwSigLen,
            hPubKey,
            sDescription,
            dwFlags);
#else
    return CRYPT_FAILED;
#endif
}

CSPBOOL
CSPSetProviderA(
    LPCSTR pszProvName,
    DWORD dwProvType)
{
    breakpoint;
    return TRUE;
}

CSPBOOL
CSPSetProviderW(
    LPCWSTR pszProvName,
    DWORD dwProvType)
{
    breakpoint;
    return TRUE;
}

#endif // defined(_CSPDIRECT_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\svrapp\svrappdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       svrappdlg.cpp
//
//--------------------------------------------------------------------------

// SvrAppDlg.cpp : implementation file
//

#include "stdafx.h"
#include <winsvc.h>
#include <dbt.h>
#include "SvrApp.h"
#include "SvrAppDlg.h"
#include <CalServe.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define RSP_SIMPLE_SERVICE      0x00000001  // Registers the process as a
                                            // simple service process.
#define RSP_UNREGISTER_SERVICE  0x00000000  // Unregisters the process as a
                                            // service process.

typedef BOOL (WINAPI *LPREGISTER_SERIVCE)(DWORD, int);

static BOOL g_fStarted = FALSE;
static SERVICE_STATUS_HANDLE l_hService = NULL;
static const TCHAR l_szEventSource[] = TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\SCardApp");
static const TCHAR l_szServiceName[] = TEXT("SCardApp");
static const GUID l_guidSmartcards
                        = { // 50DD5230-BA8A-11D1-BF5D-0000F805F530
                            0x50DD5230,
                            0xBA8A,
                            0x11D1,
                            { 0xBF, 0x5D, 0x00, 0x00, 0xF8, 0x05, 0xF5, 0x30 } };


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSvrAppDlg dialog

CSvrAppDlg::CSvrAppDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CSvrAppDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CSvrAppDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
    m_hIfDev = NULL;
}

void CSvrAppDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSvrAppDlg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSvrAppDlg, CDialog)
    //{{AFX_MSG_MAP(CSvrAppDlg)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDC_START, OnStart)
    ON_BN_CLICKED(IDC_STOP, OnStop)
    //}}AFX_MSG_MAP
    ON_WM_DEVICECHANGE()
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSvrAppDlg message handlers

BOOL CSvrAppDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // Add "About..." menu item to system menu.

    // IDM_ABOUTBOX must be in the system command range.
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX < 0xF000);

    CMenu* pSysMenu = GetSystemMenu(FALSE);
    CString strAboutMenu;
    strAboutMenu.LoadString(IDS_ABOUTBOX);
    if (!strAboutMenu.IsEmpty())
    {
        pSysMenu->AppendMenu(MF_SEPARATOR);
        pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
    }

    // Set the icon for this dialog.  The framework does this automatically
    //  when the application's main window is not a dialog
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon

    // TODO: Add extra initialization here
    InitializeCriticalSection(&m_csMessageLock);

    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CSvrAppDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
    if ((nID & 0xFFF0) == IDM_ABOUTBOX)
    {
        CAboutDlg dlgAbout;
        dlgAbout.DoModal();
    }
    else
    {
        CDialog::OnSysCommand(nID, lParam);
    }
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CSvrAppDlg::OnPaint()
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CSvrAppDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

void CSvrAppDlg::OnStart()
{
    ASSERT(!g_fStarted);
    try
    {

        //
        // Initialize Event Logging.
        //

        DWORD dwStatus;
        TCHAR szModulePath[MAX_PATH];
        CRegistry
            rgSCardSvr(
                HKEY_LOCAL_MACHINE,
                l_szEventSource,
                KEY_ALL_ACCESS,
                REG_OPTION_NON_VOLATILE);


        //
        // Add our source name as a subkey under the Application
        // key in the EventLog service portion of the registry.
        //

        dwStatus = GetModuleFileName(
                        NULL,
                        szModulePath,
                        sizeof(szModulePath));
        if (0 == dwStatus)
        {
            dwStatus = GetLastError();
            CalaisWarning(
                DBGT("Smart Card Resource Manager cannot determine its module name:  %1"),
                dwStatus);
            lstrcpy(
                szModulePath,
#ifdef DBG
                TEXT("D:\\NT\\ISPU\\Calais\\bin\\objd\\i386\\SvrApp.exe"));
#else
                TEXT("D:\\NT\\ISPU\\Calais\\bin\\obj\\i386\\SvrApp.exe"));
#endif
        }
        rgSCardSvr.SetValue(
                TEXT("EventMessageFile"),
                szModulePath,
                REG_EXPAND_SZ);
        rgSCardSvr.SetValue(
            TEXT("TypesSupported"),
            (DWORD)(EVENTLOG_ERROR_TYPE
                    | EVENTLOG_WARNING_TYPE
                    | EVENTLOG_INFORMATION_TYPE));
        CalaisMessageInit(
            l_szServiceName,
            RegisterEventSource(NULL, l_szServiceName));
    }
    catch (...)
    {
        // No error logging!
    }

    AppInitializeDeviceRegistration(
        GetSafeHwnd(),
        DEVICE_NOTIFY_WINDOW_HANDLE);
    g_fStarted = (ERROR_SUCCESS == CalaisStart());
    if (!g_fStarted)
        AppTerminateDeviceRegistration();
    GetDlgItem(IDC_START)->EnableWindow(!g_fStarted);
    GetDlgItem(IDC_STOP)->EnableWindow(g_fStarted);
}

void CSvrAppDlg::OnStop()
{
    ASSERT(g_fStarted);
    CalaisStop();
    AppTerminateDeviceRegistration();
    CalaisMessageClose();
    g_fStarted = FALSE;
    GetDlgItem(IDC_START)->EnableWindow(!g_fStarted);
    GetDlgItem(IDC_STOP)->EnableWindow(g_fStarted);
}

void CSvrAppDlg::OnOK()
{
    if (g_fStarted)
        OnStop();
    DeleteCriticalSection(&m_csMessageLock);
    CDialog::OnOK();
}

afx_msg CSvrAppDlg::OnDeviceChange(UINT nEventType, DWORD_PTR EventData)
{
    int nRetVal = CDialog::OnDeviceChange(nEventType, EventData);
    try
    {
        CCritSect csLock(&m_csMessageLock);
        DWORD dwSts;
        LPCTSTR szReader = NULL;
        DEV_BROADCAST_HDR *pDevHdr = (DEV_BROADCAST_HDR *)EventData;

        switch (nEventType)
        {
        //
        // A device has been inserted and is now available.
        case DBT_DEVICEARRIVAL:
        {
            DEV_BROADCAST_DEVICEINTERFACE *pDev
                = (DEV_BROADCAST_DEVICEINTERFACE *)EventData;

            try
            {
                if (DBT_DEVTYP_DEVICEINTERFACE == pDev->dbcc_devicetype)
                {
                    CTextString tzReader;

                    ASSERT(sizeof(DEV_BROADCAST_DEVICEINTERFACE) < pDev->dbcc_size);
                    ASSERT(0 == memcmp(
                        &pDev->dbcc_classguid,
                        &l_guidSmartcards,
                        sizeof(GUID)));
                    ASSERT(0 != pDev->dbcc_name[0]);

                    if (0 == pDev->dbcc_name[1])
                        tzReader = (LPCWSTR)pDev->dbcc_name;
                    else
                        tzReader = (LPCTSTR)pDev->dbcc_name;
                    szReader = tzReader;
                    dwSts = CalaisAddReader(szReader);
                    if (ERROR_SUCCESS != dwSts)
                        throw dwSts;
                    CalaisWarning(
                        DBGT("New device '%1' added."),
                        szReader);
                }
                else
                    CalaisWarning(
                        DBGT("Spurious device arrival event."));
            }
            catch (DWORD dwError)
            {
                CalaisError(514, dwError, szReader);
            }
            catch (...)
            {
                CalaisError(517, szReader);
            }
        }

        //
        // Permission to remove a device is requested. Any application can deny
        // this request and cancel the removal.
        case DBT_DEVICEQUERYREMOVE:
        {
            DEV_BROADCAST_HANDLE *pDev = (DEV_BROADCAST_HANDLE *)EventData;

            try
            {
                if (DBT_DEVTYP_HANDLE == pDev->dbch_devicetype)
                {
                    ASSERT(FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_eventguid)
                        <= pDev->dbch_size);
                    ASSERT(NULL != pDev->dbch_handle);
                    ASSERT(NULL != pDev->dbch_hdevnotify);

                    if (NULL != pDev->dbch_handle)
                    {
                        if (!CalaisQueryReader(pDev->dbch_handle))
                        {
                            CalaisError(
                                520,
                                TEXT("DBT_DEVICEQUERYREMOVE/dbch_handle"));
                            nRetVal = BROADCAST_QUERY_DENY;
                        }
                        else
                        {
                            szReader = CalaisDisableReader(
                                (LPVOID)pDev->dbch_handle);
                            CalaisWarning(
                                DBGT("Device '%1' removal pending."),
                                szReader);
                        }
                    }
                    else
                    {
                        CalaisError(
                            519,
                            TEXT("DBT_DEVICEQUERYREMOVE/dbch_handle"));
                        nRetVal = BROADCAST_QUERY_DENY;
                    }
                }
                else
                {
                    CalaisWarning(
                        DBGT("Spurious device removal query event."));
                    nRetVal = TRUE;
                }
            }
            catch (DWORD dwError)
            {
                CalaisWarning(
                    DBGT("Error querying device busy state on reader %2: %1"),
                    dwError,
                    szReader);
                nRetVal = BROADCAST_QUERY_DENY;
            }
            catch (...)
            {
                CalaisWarning(
                    DBGT("Exception querying device busy state on reader %1"),
                    szReader);
                CalaisError(
                    518,
                    TEXT("DBT_DEVICEQUERYREMOVE"));
                nRetVal = BROADCAST_QUERY_DENY;
            }
            break;
        }

        //
        // Request to remove a device has been canceled.
        case DBT_DEVICEQUERYREMOVEFAILED:
        {
            CBuffer bfDevice;
            DEV_BROADCAST_HANDLE *pDev = (DEV_BROADCAST_HANDLE *)EventData;

            try
            {
                if (DBT_DEVTYP_HANDLE == pDev->dbch_devicetype)
                {
                    ASSERT(FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_eventguid)
                        <= pDev->dbch_size);
                    ASSERT(NULL != pDev->dbch_handle);
                    ASSERT(NULL != pDev->dbch_hdevnotify);

                    if (NULL != pDev->dbch_handle)
                    {
                        szReader = CalaisConfirmClosingReader(pDev->dbch_handle);
                        if (NULL != szReader)
                        {
                            bfDevice.Set(
                                (LPBYTE)szReader,
                                (lstrlen(szReader) + 1) * sizeof(TCHAR));
                            szReader = (LPCTSTR)bfDevice.Access();
                            CalaisWarning(
                                DBGT("Smart Card Resource Manager asked to cancel release of reader %1"),
                                szReader);
                            if (NULL != pDev->dbch_hdevnotify)
                            {
                                CalaisRemoveReader((LPVOID)pDev->dbch_hdevnotify);
                                if (NULL != szReader)
                                    dwSts = CalaisAddReader(szReader);
                            }
                        }
                        else
                            CalaisWarning(
                                DBGT("Smart Card Resource Manager asked to cancel release on unreleased reader"));
                    }
                    else
                        CalaisError(
                            519,
                            TEXT("DBT_DEVICEQUERYREMOVEFAILED/dbch_handle"));
                }
                else
                {
                    CalaisWarning(
                        DBGT("Spurious device removal query failure event."));
                }
            }
            catch (DWORD dwError)
            {
                CalaisWarning(
                    DBGT("Error cancelling removal on reader %2: %1"),
                    dwError,
                    szReader);
            }
            catch (...)
            {
                CalaisWarning(
                    DBGT("Exception cancelling removal on reader %1"),
                    szReader);
                CalaisError(
                    518,
                    TEXT("DBT_DEVICEQUERYREMOVEFAILED"));
            }
            break;
        }

        //
        // Device is about to be removed. Cannot be denied.
        case DBT_DEVICEREMOVEPENDING:
        {
            DEV_BROADCAST_HANDLE *pDev = (DEV_BROADCAST_HANDLE *)EventData;

            try
            {
                if (DBT_DEVTYP_HANDLE == pDev->dbch_devicetype)
                {
                    ASSERT(FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_eventguid)
                        <= pDev->dbch_size);
                    ASSERT(NULL != pDev->dbch_handle);
                    ASSERT(NULL != pDev->dbch_hdevnotify);

                    if (NULL != pDev->dbch_handle)
                    {
                        szReader = CalaisDisableReader(pDev->dbch_handle);
                        CalaisWarning(
                            DBGT("Device '%1' being removed."),
                            szReader);
                    }
                    else
                        CalaisError(
                            519,
                            TEXT("DBT_DEVICEREMOVEPENDING/dbch_handle"));
                }
                else
                {
                    CalaisWarning(
                        DBGT("Spurious device removal pending event."));
                }
            }
            catch (DWORD dwError)
            {
                CalaisWarning(
                    DBGT("Error removing reader %2: %1"),
                    dwError,
                    szReader);
            }
            catch (...)
            {
                CalaisWarning(
                    DBGT("Exception removing reader %1"),
                    szReader);
                CalaisError(
                    518,
                    TEXT("DBT_DEVICEREMOVEPENDING"));
            }
            break;
        }

        //
        // Device has been removed.
        case DBT_DEVICEREMOVECOMPLETE:
        {
            try
            {
                switch (pDevHdr->dbch_devicetype)
                {
                case DBT_DEVTYP_HANDLE:
                {
                    DEV_BROADCAST_HANDLE *pDev =
                        (DEV_BROADCAST_HANDLE *)EventData;
                    try
                    {
                        ASSERT(FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_eventguid) <= pDev->dbch_size);
                        ASSERT(DBT_DEVTYP_HANDLE == pDev->dbch_devicetype);
                        ASSERT(NULL != pDev->dbch_handle);
                        ASSERT(NULL != pDev->dbch_hdevnotify);

                        if ((NULL != pDev->dbch_handle)
                            && (NULL != pDev->dbch_hdevnotify))
                        {
                            szReader = CalaisDisableReader(
                                                pDev->dbch_handle);
                            CalaisRemoveReader(
                                (LPVOID)pDev->dbch_hdevnotify);
                            CalaisWarning(
                                DBGT("Device '%1' removed."),
                                szReader);
                        }
                        else
                        {
                            if (NULL == pDev->dbch_handle)
                                CalaisError(
                                    519,
                                    TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_HANDLE/dbch_handle"));
                            if (NULL == pDev->dbch_hdevnotify)
                                CalaisError(
                                    519,
                                    TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_HANDLE/dbch_hdevnotify"));
                        }
                    }
                    catch (DWORD dwError)
                    {
                        CalaisWarning(
                            DBGT("Error completing removal of reader %2: %1"),
                            dwError,
                            szReader);
                    }
                    catch (...)
                    {
                        CalaisWarning(
                            DBGT("Exception completing removal of reader %1"),
                            szReader);
                        CalaisError(
                            518,
                            TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_HANDLE"));
                    }
                    break;
                }
                case DBT_DEVTYP_DEVICEINTERFACE:
                {
                    DEV_BROADCAST_DEVICEINTERFACE *pDev
                        = (DEV_BROADCAST_DEVICEINTERFACE *)EventData;
                    try
                    {
                        CTextString tzReader;

                        ASSERT(sizeof(DEV_BROADCAST_DEVICEINTERFACE) < pDev->dbcc_size);
                        ASSERT(DBT_DEVTYP_DEVICEINTERFACE == pDev->dbcc_devicetype);
                        ASSERT(0 == memcmp(
                            &pDev->dbcc_classguid,
                            &l_guidSmartcards,
                            sizeof(GUID)));
                        ASSERT(0 != pDev->dbcc_name[0]);

                        if (0 == pDev->dbcc_name[1])
                            tzReader = (LPCWSTR)pDev->dbcc_name;
                        else
                            tzReader = (LPCTSTR)pDev->dbcc_name;
                        szReader = tzReader;
                        dwSts = CalaisRemoveDevice(szReader);
                        if (ERROR_SUCCESS == dwSts)
                            CalaisWarning(
                                DBGT("Device '%1' Removed."),
                                szReader);
                        else
                            CalaisWarning(
                                DBGT("Error removing device '%2': %1"),
                                dwSts,
                                szReader);
                    }
                    catch (DWORD dwError)
                    {
                        CalaisWarning(
                            DBGT("Error completing removal of reader %2: %1"),
                            dwError,
                            szReader);
                    }
                    catch (...)
                    {
                        CalaisWarning(
                            DBGT("Exception completing removal of reader %1"),
                            szReader);
                        CalaisError(
                            518,
                            TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_DEVICEINTERFACE"));
                    }
                    break;
                }
                default:
                    CalaisWarning(
                        DBGT("Unrecognized PnP Device Removal Type"));
                    break;
                }
            }
            catch (...)
            {
                CalaisError(
                    518,
                    TEXT("DBT_DEVICEREMOVECOMPLETE"));
            }
            break;
        }

        default:
            CalaisWarning(
                DBGT("Unrecognized PnP Event"));
            break;
        }
    }
    catch (DWORD dwError)
    {
        CalaisWarning(
            DBGT("Smart Card Resource Manager recieved error on device action: %1"),
            dwError);
    }
    catch (...)
    {
        CalaisWarning(
            DBGT("Smart Card Resource Manager recieved exception on device action"));
    }
    return nRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\tclcrypt\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tclcrypt.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\tclcrypt\scext.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       scext.h
//
//--------------------------------------------------------------------------

#include <tcl.h>
// #include "tcldllUtil.h"
#if 15 != _ANSI_ARGS_(15)
#error Missing argument definitions
#endif

extern int
Tclsc_cryptCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int argc,
    char *argv[]);

extern int
TclExt_tryCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int argc,
    char *argv[]);

extern int
TclExt_threadCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int argc,
    char *argv[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\tclcrypt\cspdirct.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    cspDirect

Abstract:

    This header file provides direct linkage to a CSP, so it does not have to be
in a separate DLL.  This facilitates code generation and debugging.

Author:

    Doug Barlow (dbarlow) 5/8/1996

Environment:

    Win32

Notes:

    ?Notes?

--*/


#ifdef CSP_DIRECT

#ifndef _CSPDIRECT_H_
#define _CSPDIRECT_H_
#ifdef __cplusplus
extern "C" {
#endif
#define CSPBOOL BOOL WINAPI

#undef CryptAcquireContext
#ifdef UNICODE
#define CryptAcquireContext CSPAcquireContextW
#else
#define CryptAcquireContext CSPAcquireContextA
#endif

#define CryptReleaseContext CSPReleaseContext
#define CryptGenKey CSPGenKey
#define CryptDeriveKey CSPDeriveKey
#define CryptDestroyKey CSPDestroyKey
#define CryptSetKeyParam CSPSetKeyParam
#define CryptGetKeyParam CSPGetKeyParam
#define CryptSetHashParam CSPSetHashParam
#define CryptGetHashParam CSPGetHashParam
#define CryptSetProvParam CSPSetProvParam
#define CryptGetProvParam CSPGetProvParam
#define CryptGenRandom CSPGenRandom
#define CryptGetUserKey CSPGetUserKey
#define CryptExportKey CSPExportKey
#define CryptImportKey CSPImportKey
#define CryptEncrypt CSPEncrypt
#define CryptDecrypt CSPDecrypt
#define CryptCreateHash CSPCreateHash
#define CryptHashData CSPHashData
#define CryptHashSessionKey CSPHashSessionKey
// #define CryptGetHashValue CSPGetHashValue
#define CryptDestroyHash CSPDestroyHash

#undef CryptSignHash
#ifdef UNICODE
#define CryptSignHash CSPSignHashW
#else
#define CryptSignHash CSPSignHashA
#endif

#undef CryptVerifySignature
#ifdef UNICODE
#define CryptVerifySignature CSPVerifySignatureW
#else
#define CryptVerifySignature CSPVerifySignatureA
#endif

#undef CryptSetProvider
#ifdef UNICODE
#define CryptSetProvider CSPSetProviderW
#else
#define CryptSetProvider CSPSetProviderA
#endif

extern CSPBOOL
CSPAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);

extern CSPBOOL
CSPAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);

extern CSPBOOL
CSPReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags);

extern CSPBOOL
CSPGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

extern CSPBOOL
CSPDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

extern CSPBOOL
CSPDestroyKey(
    HCRYPTKEY hKey);

extern CSPBOOL
CSPSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

extern CSPBOOL
CSPGetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

extern CSPBOOL
CSPSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

extern CSPBOOL
CSPGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

extern CSPBOOL
CSPSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

extern CSPBOOL
CSPGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

extern CSPBOOL
CSPGenRandom(
    HCRYPTPROV hProv,
    DWORD dwLen,
    BYTE *pbBuffer);

extern CSPBOOL
CSPGetUserKey(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey);

extern CSPBOOL
CSPExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

extern CSPBOOL
CSPImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

extern CSPBOOL
CSPEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

extern CSPBOOL
CSPDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

extern CSPBOOL
CSPCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash);

extern CSPBOOL
CSPHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags);

extern CSPBOOL
CSPHashSessionKey(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags);

/*
extern CSPBOOL
CSPGetHashValue(
    HCRYPTHASH hHash,
    DWORD dwFlags,
    BYTE *pbHash,
    DWORD *pdwHashLen);
*/

extern CSPBOOL
CSPDestroyHash(
    HCRYPTHASH hHash);

extern CSPBOOL
CSPSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

extern CSPBOOL
CSPSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

extern CSPBOOL
CSPVerifySignatureA(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags);

extern CSPBOOL
CSPVerifySignatureW(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags);

extern CSPBOOL
CSPSetProviderA(
    LPCSTR pszProvName,
    DWORD dwProvType);

extern CSPBOOL
CSPSetProviderW(
    LPCWSTR pszProvName,
    DWORD dwProvType);


//
// CSP Entry points.
//

extern BOOL WINAPI
CPAcquireContext(
    OUT HCRYPTPROV *phProv,
    LPCTSTR pszContainer,
    IN DWORD dwFlags,
    IN PVTableProvStruc pVTable);

extern BOOL WINAPI
CPAcquireContextEx(
    OUT HCRYPTPROV *phProv,
    LPCTSTR pszContainer,
    IN DWORD dwFlags,
    IN LPCVOID pvParams,
    IN PVTableProvStruc pVTable);

extern BOOL WINAPI
CPReleaseContext(
    IN HCRYPTPROV hProv,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGenKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey);

extern BOOL WINAPI
CPDeriveKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTHASH hHash,
    IN DWORD dwFlags,
    OUT HCRYPTKEY * phKey);

extern BOOL WINAPI
CPDestroyKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey);

extern BOOL WINAPI
CPSetKeyParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGetKeyParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN DWORD *pdwDataLen,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPSetProvParam(
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGetProvParam(
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPSetHashParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGetHashParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN DWORD *pdwDataLen,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPExportKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwBlobType,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen);

extern BOOL WINAPI
CPImportKey(
    IN HCRYPTPROV hProv,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey);

extern BOOL WINAPI
CPEncrypt(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwBufLen);

extern BOOL WINAPI
CPDecrypt(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen);

extern BOOL WINAPI
CPCreateHash(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTKEY hKey,
    IN DWORD dwFlags,
    OUT HCRYPTHASH *phHash);

extern BOOL WINAPI
CPHashData(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPHashSessionKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN  HCRYPTKEY hKey,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPSignHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwKeySpec,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags,
    OUT BYTE *pbSignature,
    IN OUT DWORD *pdwSigLen);

/*
extern BOOL WINAPI
CPGetHashValue(
    IN HCRYPTPROV g_hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwFlags,
    OUT BYTE *pbHash,
    IN OUT DWORD *pdwHashLen);
*/

extern BOOL WINAPI
CPDestroyHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash);

extern BOOL WINAPI
CPSignHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwKeySpec,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags,
    OUT BYTE *pbSignature,
    IN OUT DWORD *pdwSigLen);

extern BOOL WINAPI
CPVerifySignature(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbSignature,
    IN DWORD dwSigLen,
    IN HCRYPTKEY hPubKey,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGenRandom(
    IN HCRYPTPROV hProv,
    IN DWORD dwLen,
    IN OUT BYTE *pbBuffer);

extern BOOL WINAPI
CPGetUserKey(
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec,
    OUT HCRYPTKEY *phUserKey);

#ifdef __cplusplus
}
#endif
#endif
#endif // _CSPDIRECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\tclcrypt\tclappinit.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tclappinit.c
//
//--------------------------------------------------------------------------

/*
 * tclAppInit.c --
 *
 *      Provides a default version of the Tcl_AppInit procedure.
 *
 * Copyright (c) 1993 The Regents of the University of California.
 * All rights reserved.
 *
 * Permission is hereby granted, without written agreement and without
 * license or royalty fees, to use, copy, modify, and distribute this
 * software and its documentation for any purpose, provided that the
 * above copyright notice and the following two paragraphs appear in
 * all copies of this software.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
 * CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */

#ifndef lint
/* ++ */
static char rcsid[] = "Header: /user6/ouster/tcl/RCS/tclAppInit.c,v 1.6 93/08/26 14:34:55 ouster Exp  SPRITE (Berkeley)";
/* -- */
#endif /* not lint */

#ifndef __STDC__
#define __STDC__ 1
#endif
#include "tcl.h"
/* ++ */
#ifdef _WIN32
#include "tclNT.h"
#endif
#include "scExt.h"
/* -- */

/*
 * The following variable is a special hack that allows applications
 * to be linked using the procedure "main" from the Tcl library.  The
 * variable generates a reference to "main", which causes main to
 * be brought in from the library (and all of Tcl with it).
 */

/* ++ */
extern int CDECL main();
/* -- */
int *tclDummyMainPtr = (int *) main;

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AppInit --
 *
 *      This procedure performs application-specific initialization.
 *      Most applications, especially those that incorporate additional
 *      packages, will have their own version of this procedure.
 *
 * Results:
 *      Returns a standard Tcl completion code, and leaves an error
 *      message in interp->result if an error occurs.
 *
 * Side effects:
 *      Depends on the startup script.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_AppInit(interp)
    Tcl_Interp *interp;         /* Interpreter for application. */
{

    /*
     * Call Tcl_CreateCommand for application-specific commands.
     */

     Tcl_CreateCommand(interp, "try",    TclExt_tryCmd,     NULL, NULL);
     Tcl_CreateCommand(interp, "thread", TclExt_threadCmd,  NULL, NULL);
     Tcl_CreateCommand(interp, "crypt",  Tclsc_cryptCmd,    NULL, NULL);


     /*
     * Call the init procedures for included packages.  Each call should
     * look like this:
     *
     * if (Mod_Init(interp) == TCL_ERROR) {
     *     return TCL_ERROR;
     * }
     *
     * where "Mod" is the name of the module.
     */

    if (Tcl_Init(interp) == TCL_ERROR) {
        return TCL_ERROR;
    }


    /*
     * Specify a user-specific startup file to invoke if the application
     * is run interactively.  Typically the startup file is "~/.apprc"
     * where "app" is the name of the application.  If this line is deleted
     * then no user-specific startup file will be run under any conditions.
     */

    tcl_RcFileName = "~/.tclcrypt";
    return TCL_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\tclcrypt\tclcrypt.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    tclCrypt

Abstract:

    Tcl commands to support CryptoAPI CSP debugging.

Author:

    Doug Barlow (dbarlow) 03/13/1998

Environment:

    Tcl for Windows NT.

Notes:

--*/

// #ifndef WIN32_LEAN_AND_MEAN
// #define WIN32_LEAN_AND_MEAN
// #endif
// #include <windows.h>                    //  All the Windows definitions.
#include <afx.h>
#ifndef WINVER
#define WINVER 0x0400
#endif
#include <wincrypt.h>
#include <string.h>
#include <stdio.h>
#include <stddef.h>
#include <math.h>
#ifndef __STDC__
#define __STDC__ 1
#endif
extern "C" {
    #include "scext.h"
    #include "tclhelp.h"
}
#include "tclRdCmd.h"
#include "cspDirct.h"

typedef enum
{
    Undefined = 0,
    Provider,
    Key,
    Hash
} HandleType;

static const ValueMap vmProviderTypes[]
    = {
        { TEXT("PROV_RSA_FULL"),            PROV_RSA_FULL},
        { TEXT("PROV_RSA_SIG"),             PROV_RSA_SIG},
        { TEXT("PROV_DSS"),                 PROV_DSS},
        { TEXT("PROV_FORTEZZA"),            PROV_FORTEZZA},
        { TEXT("PROV_MS_EXCHANGE"),         PROV_MS_EXCHANGE},
        { TEXT("PROV_SSL"),                 PROV_SSL},
        { TEXT("PROV_RSA_SCHANNEL"),        PROV_RSA_SCHANNEL},
        { TEXT("PROV_DSS_DH"),              PROV_DSS_DH},
        { TEXT("PROV_EC_ECDSA_SIG"),        PROV_EC_ECDSA_SIG},
        { TEXT("PROV_EC_ECNRA_SIG"),        PROV_EC_ECNRA_SIG},
        { TEXT("PROV_EC_ECDSA_FULL"),       PROV_EC_ECDSA_FULL},
        { TEXT("PROV_EC_ECNRA_FULL"),       PROV_EC_ECNRA_FULL},
        { TEXT("PROV_DH_SCHANNEL"),         PROV_DH_SCHANNEL},
        { TEXT("PROV_SPYRUS_LYNKS"),        PROV_SPYRUS_LYNKS},
        { TEXT("PROV_RNG"),                 PROV_RNG},
        { TEXT("PROV_INTEL_SEC"),           PROV_INTEL_SEC},
        { TEXT("RSA"),                      PROV_RSA_FULL},
        { TEXT("SIGNATURE"),                PROV_RSA_SIG},
        { TEXT("DSS"),                      PROV_DSS},
        { TEXT("FORTEZZA"),                 PROV_FORTEZZA},
        { NULL, 0} };
static const ValueMap vmAcquireFlags[]
    = {
        { TEXT("CRYPT_VERIFYCONTEXT"),      CRYPT_VERIFYCONTEXT},
        { TEXT("CRYPT_NEWKEYSET"),          CRYPT_NEWKEYSET},
        { TEXT("CRYPT_DELETEKEYSET"),       CRYPT_DELETEKEYSET},
        { TEXT("CRYPT_MACHINE_KEYSET"),     CRYPT_MACHINE_KEYSET},
        { TEXT("CRYPT_SILENT"),             CRYPT_SILENT},
        { TEXT("VERIFYONLY"),               CRYPT_VERIFYCONTEXT},
        { TEXT("NEW"),                      CRYPT_NEWKEYSET},
        { TEXT("DELETE"),                   CRYPT_DELETEKEYSET},
        { TEXT("MACHINE"),                  CRYPT_MACHINE_KEYSET},
        { TEXT("SILENT"),                   CRYPT_SILENT},
        { NULL, 0} };
static const ValueMap vmGetFlags[]
    = {
        { TEXT("CRYPT_FIRST"),              CRYPT_FIRST},
        { TEXT("CRYPT_NEXT"),               CRYPT_NEXT},
        { TEXT("CRYPT_SGC_ENUM"),           CRYPT_SGC_ENUM},
        { NULL, 0} };
static const ValueMap vmGetProvParams[]
    = {
        { TEXT("PP_ENUMALGS"),              PP_ENUMALGS},
        { TEXT("PP_ENUMCONTAINERS"),        PP_ENUMCONTAINERS},
        { TEXT("PP_IMPTYPE"),               PP_IMPTYPE},
        { TEXT("PP_NAME"),                  PP_NAME},
        { TEXT("PP_VERSION"),               PP_VERSION},
        { TEXT("PP_CONTAINER"),             PP_CONTAINER},
        { TEXT("PP_CHANGE_PASSWORD"),       PP_CHANGE_PASSWORD},
        { TEXT("PP_KEYSET_SEC_DESCR"),      PP_KEYSET_SEC_DESCR},
        { TEXT("PP_CERTCHAIN"),             PP_CERTCHAIN},
        { TEXT("PP_KEY_TYPE_SUBTYPE"),      PP_KEY_TYPE_SUBTYPE},
        { TEXT("PP_PROVTYPE"),              PP_PROVTYPE},
        { TEXT("PP_KEYSTORAGE"),            PP_KEYSTORAGE},
        { TEXT("PP_APPLI_CERT"),            PP_APPLI_CERT},
        { TEXT("PP_SYM_KEYSIZE"),           PP_SYM_KEYSIZE},
        { TEXT("PP_SESSION_KEYSIZE"),       PP_SESSION_KEYSIZE},
        { TEXT("PP_UI_PROMPT"),             PP_UI_PROMPT},
        { TEXT("PP_ENUMALGS_EX"),           PP_ENUMALGS_EX},
        { TEXT("PP_ENUMMANDROOTS"),         PP_ENUMMANDROOTS},
        { TEXT("PP_ENUMELECTROOTS"),        PP_ENUMELECTROOTS},
        { TEXT("PP_KEYSET_TYPE"),           PP_KEYSET_TYPE},
        { TEXT("PP_ADMIN_PIN"),             PP_ADMIN_PIN},
        { TEXT("PP_KEYEXCHANGE_PIN"),       PP_KEYEXCHANGE_PIN},
        { TEXT("PP_SIGNATURE_PIN"),         PP_SIGNATURE_PIN},
        { TEXT("PP_SIG_KEYSIZE_INC"),       PP_SIG_KEYSIZE_INC},
        { TEXT("PP_KEYX_KEYSIZE_INC"),      PP_KEYX_KEYSIZE_INC},
        { TEXT("PP_UNIQUE_CONTAINER"),      PP_UNIQUE_CONTAINER},
        { TEXT("PP_SGC_INFO"),              PP_SGC_INFO},
        { TEXT("PP_USE_HARDWARE_RNG"),      PP_USE_HARDWARE_RNG},
        { TEXT("PP_KEYSPEC"),               PP_KEYSPEC},
        { TEXT("PP_ENUMEX_SIGNING_PROT"),   PP_ENUMEX_SIGNING_PROT},
        { TEXT("NAME"),                     PP_NAME},
        { TEXT("CONTAINER"),                PP_CONTAINER},
        { TEXT("KEYSET"),                   PP_CONTAINER},
        { NULL, 0} };
static const ValueMap vmSetProvParams[]
    = {
        { TEXT("PP_CLIENT_HWND"),           PP_CLIENT_HWND},
        { TEXT("PP_CONTEXT_INFO"),          PP_CONTEXT_INFO},
        { TEXT("PP_KEYEXCHANGE_KEYSIZE"),   PP_KEYEXCHANGE_KEYSIZE},
        { TEXT("PP_SIGNATURE_KEYSIZE"),     PP_SIGNATURE_KEYSIZE},
        { TEXT("PP_KEYEXCHANGE_ALG"),       PP_KEYEXCHANGE_ALG},
        { TEXT("PP_SIGNATURE_ALG"),         PP_SIGNATURE_ALG},
        { TEXT("PP_DELETEKEY"),             PP_DELETEKEY},
        { NULL, 0} };
static const ValueMap vmKeyParams[]
    = {
        { TEXT("KP_IV"),                    KP_IV},
        { TEXT("KP_SALT"),                  KP_SALT},
        { TEXT("KP_PADDING"),               KP_PADDING},
        { TEXT("KP_MODE"),                  KP_MODE},
        { TEXT("KP_MODE_BITS"),             KP_MODE_BITS},
        { TEXT("KP_PERMISSIONS"),           KP_PERMISSIONS},
        { TEXT("KP_ALGID"),                 KP_ALGID},
        { TEXT("KP_BLOCKLEN"),              KP_BLOCKLEN},
        { TEXT("KP_KEYLEN"),                KP_KEYLEN},
        { TEXT("KP_SALT_EX"),               KP_SALT_EX},
        { TEXT("KP_P"),                     KP_P},
        { TEXT("KP_G"),                     KP_G},
        { TEXT("KP_Q"),                     KP_Q},
        { TEXT("KP_X"),                     KP_X},
        { TEXT("KP_Y"),                     KP_Y},
        { TEXT("KP_RA"),                    KP_RA},
        { TEXT("KP_RB"),                    KP_RB},
        { TEXT("KP_INFO"),                  KP_INFO},
        { TEXT("KP_EFFECTIVE_KEYLEN"),      KP_EFFECTIVE_KEYLEN},
        { TEXT("KP_SCHANNEL_ALG"),          KP_SCHANNEL_ALG},
        { TEXT("KP_CLIENT_RANDOM"),         KP_CLIENT_RANDOM},
        { TEXT("KP_SERVER_RANDOM"),         KP_SERVER_RANDOM},
        { TEXT("KP_RP"),                    KP_RP},
        { TEXT("KP_PRECOMP_MD5"),           KP_PRECOMP_MD5},
        { TEXT("KP_PRECOMP_SHA"),           KP_PRECOMP_SHA},
        { TEXT("KP_CERTIFICATE"),           KP_CERTIFICATE},
        { TEXT("KP_CLEAR_KEY"),             KP_CLEAR_KEY},
        { TEXT("KP_PUB_EX_LEN"),            KP_PUB_EX_LEN},
        { TEXT("KP_PUB_EX_VAL"),            KP_PUB_EX_VAL},
        { TEXT("KP_KEYVAL"),                KP_KEYVAL},
        { TEXT("KP_ADMIN_PIN"),             KP_ADMIN_PIN},
        { TEXT("KP_KEYEXCHANGE_PIN"),       KP_KEYEXCHANGE_PIN},
        { TEXT("KP_SIGNATURE_PIN"),         KP_SIGNATURE_PIN},
        { TEXT("KP_PREHASH"),               KP_PREHASH},
        { TEXT("KP_OAEP_PARAMS"),           KP_OAEP_PARAMS},
        { TEXT("KP_CMS_KEY_INFO"),          KP_CMS_KEY_INFO},
        { TEXT("KP_CMS_DH_KEY_INFO"),       KP_CMS_DH_KEY_INFO},
        { TEXT("KP_PUB_PARAMS"),            KP_PUB_PARAMS},
        { TEXT("KP_VERIFY_PARAMS"),         KP_VERIFY_PARAMS},
        { TEXT("KP_HIGHEST_VERSION"),       KP_HIGHEST_VERSION},
        { NULL, 0} };
static const ValueMap vmKeyTypes[]
    = {
        { TEXT("AT_KEYEXCHANGE"),           AT_KEYEXCHANGE},
        { TEXT("AT_SIGNATURE"),             AT_SIGNATURE},
        { TEXT("KEYEXCHANGE"),              AT_KEYEXCHANGE},
        { TEXT("SIGNATURE"),                AT_SIGNATURE},
        { TEXT("EXCHANGE"),                 AT_KEYEXCHANGE},
        { NULL, 0} };
static const ValueMap vmHashParams[]
    = {
        { TEXT("HP_ALGID"),                 HP_ALGID},
        { TEXT("HP_HASHVAL"),               HP_HASHVAL},
        { TEXT("HP_HASHSIZE"),              HP_HASHSIZE},
        { TEXT("HP_HMAC_INFO"),             HP_HMAC_INFO},
        { TEXT("HP_TLS1PRF_LABEL"),         HP_TLS1PRF_LABEL},
        { TEXT("HP_TLS1PRF_SEED"),          HP_TLS1PRF_SEED},
        { NULL, 0} };
static const ValueMap vmKeyFlags[]
    = {
        { TEXT("CRYPT_EXPORTABLE"),         CRYPT_EXPORTABLE},
        { TEXT("CRYPT_USER_PROTECTED"),     CRYPT_USER_PROTECTED},
        { TEXT("CRYPT_CREATE_SALT"),        CRYPT_CREATE_SALT},
        { TEXT("CRYPT_UPDATE_KEY"),         CRYPT_UPDATE_KEY},
        { TEXT("CRYPT_NO_SALT"),            CRYPT_NO_SALT},
        { TEXT("CRYPT_PREGEN"),             CRYPT_PREGEN},
        { TEXT("CRYPT_RECIPIENT"),          CRYPT_RECIPIENT},
        { TEXT("CRYPT_INITIATOR"),          CRYPT_INITIATOR},
        { TEXT("CRYPT_ONLINE"),             CRYPT_ONLINE},
        { TEXT("CRYPT_SF"),                 CRYPT_SF},
        { TEXT("CRYPT_CREATE_IV"),          CRYPT_CREATE_IV},
        { TEXT("CRYPT_KEK"),                CRYPT_KEK},
        { TEXT("CRYPT_DATA_KEY"),           CRYPT_DATA_KEY},
        { TEXT("CRYPT_VOLATILE"),           CRYPT_VOLATILE},
        { TEXT("CRYPT_SGCKEY"),             CRYPT_SGCKEY},
        { NULL, 0} };
static const ValueMap vmAlgIds[]
    = {
        { TEXT("AT_KEYEXCHANGE"),           AT_KEYEXCHANGE},
        { TEXT("AT_SIGNATURE"),             AT_SIGNATURE},
        { TEXT("CALG_MD2"),                 CALG_MD2},
        { TEXT("CALG_MD4"),                 CALG_MD4},
        { TEXT("CALG_MD5"),                 CALG_MD5},
        { TEXT("CALG_SHA"),                 CALG_SHA},
        { TEXT("CALG_SHA1"),                CALG_SHA1},
        { TEXT("CALG_MAC"),                 CALG_MAC},
        { TEXT("CALG_RSA_SIGN"),            CALG_RSA_SIGN},
        { TEXT("CALG_DSS_SIGN"),            CALG_DSS_SIGN},
        { TEXT("CALG_RSA_KEYX"),            CALG_RSA_KEYX},
        { TEXT("CALG_DES"),                 CALG_DES},
        { TEXT("CALG_3DES_112"),            CALG_3DES_112},
        { TEXT("CALG_3DES"),                CALG_3DES},
        { TEXT("CALG_DESX"),                CALG_DESX},
        { TEXT("CALG_RC2"),                 CALG_RC2},
        { TEXT("CALG_RC4"),                 CALG_RC4},
        { TEXT("CALG_SEAL"),                CALG_SEAL},
        { TEXT("CALG_DH_SF"),               CALG_DH_SF},
        { TEXT("CALG_DH_EPHEM"),            CALG_DH_EPHEM},
        { TEXT("CALG_AGREEDKEY_ANY"),       CALG_AGREEDKEY_ANY},
        { TEXT("CALG_KEA_KEYX"),            CALG_KEA_KEYX},
        { TEXT("CALG_HUGHES_MD5"),          CALG_HUGHES_MD5},
        { TEXT("CALG_SKIPJACK"),            CALG_SKIPJACK},
        { TEXT("CALG_TEK"),                 CALG_TEK},
        { TEXT("CALG_CYLINK_MEK"),          CALG_CYLINK_MEK},
        { TEXT("CALG_SSL3_SHAMD5"),         CALG_SSL3_SHAMD5},
        { TEXT("CALG_SSL3_MASTER"),         CALG_SSL3_MASTER},
        { TEXT("CALG_SCHANNEL_MASTER_HASH"), CALG_SCHANNEL_MASTER_HASH},
        { TEXT("CALG_SCHANNEL_MAC_KEY"),    CALG_SCHANNEL_MAC_KEY},
        { TEXT("CALG_SCHANNEL_ENC_KEY"),    CALG_SCHANNEL_ENC_KEY},
        { TEXT("CALG_PCT1_MASTER"),         CALG_PCT1_MASTER},
        { TEXT("CALG_SSL2_MASTER"),         CALG_SSL2_MASTER},
        { TEXT("CALG_TLS1_MASTER"),         CALG_TLS1_MASTER},
        { TEXT("CALG_RC5"),                 CALG_RC5},
        { TEXT("CALG_HMAC"),                CALG_HMAC},
        { TEXT("CALG_TLS1PRF"),             CALG_TLS1PRF},
        { TEXT("MD5"),                      CALG_MD5},
        { TEXT("SHA"),                      CALG_SHA1},
        { NULL, 0} };
static const ValueMap vmClassTypes[]
    = {
        { TEXT("ALG_CLASS_ANY"),            ALG_CLASS_ANY},
        { TEXT("ALG_CLASS_SIGNATURE"),      ALG_CLASS_SIGNATURE},
        { TEXT("ALG_CLASS_MSG_ENCRYPT"),    ALG_CLASS_MSG_ENCRYPT},
        { TEXT("ALG_CLASS_DATA_ENCRYPT"),   ALG_CLASS_DATA_ENCRYPT},
        { TEXT("ALG_CLASS_HASH"),           ALG_CLASS_HASH},
        { TEXT("ALG_CLASS_KEY_EXCHANGE"),   ALG_CLASS_KEY_EXCHANGE},
        { TEXT("ALG_CLASS_ALL"),            ALG_CLASS_ALL},
        { NULL, 0} };
static const ValueMap vmHashDataFlags[]
    = {
        { TEXT("CRYPT_USERDATA"),           CRYPT_USERDATA},
        { NULL, 0} };
static const ValueMap vmSignVerifyFlags[]
    = {
        { TEXT("CRYPT_NOHASHOID"),          CRYPT_NOHASHOID},
        { NULL, 0} };
static const ValueMap vmBlobTypes[]
    = {
        { TEXT("SIMPLEBLOB"),               SIMPLEBLOB},
        { TEXT("PUBLICKEYBLOB"),            PUBLICKEYBLOB},
        { TEXT("PRIVATEKEYBLOB"),           PRIVATEKEYBLOB},
        { TEXT("PLAINTEXTKEYBLOB"),         PLAINTEXTKEYBLOB},
        { TEXT("OPAQUEKEYBLOB"),            OPAQUEKEYBLOB},
        { NULL, 0} };
static const ValueMap vmEmptyFlags[]
    = { { NULL, 0} };

static void
ExtractHandle(
    CTclCommand &tclCmd,
    LONG *phHandle,
    HandleType *pnHandleType,
    BOOL fMandatory = FALSE);

static void
ReturnHandle(
    CTclCommand &tclCmd,
    LONG_PTR hHandle,
    HandleType nHandleType);

static BOOL WINAPI
MyEnumProviders(
    DWORD dwIndex,        // in
    DWORD *pdwReserved,   // in
    DWORD dwFlags,        // in
    DWORD *pdwProvType,   // out
    LPTSTR pszProvName,   // out
    DWORD *pcbProvName);  // in/out


/*++

Tclsc_cryptCmd:

    This routine provides an access point to the various CryptoAPI
    object methods.

Arguments:

    Per Tcl standard commands.

Return Value:

    Per Tcl standard commands.

Author:

    Doug Barlow (dbarlow) 03/13/1998

--*/

int
Tclsc_cryptCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int argc,
    char *argv[])
{
    CTclCommand tclCmd(interp, argc, argv);
    int nTclStatus = TCL_OK;

    try
    {
        LONG hHandle;
        HandleType nHandleType;

        ExtractHandle(tclCmd, &hHandle, &nHandleType);
        switch (tclCmd.Keyword(
                              TEXT("LIST"), TEXT("ACQUIRE"), TEXT("RELEASE"),
                              TEXT("PARAMETER"), TEXT("GET"), TEXT("CREATE"),
                              TEXT("HASH"), TEXT("SIGNHASH"), TEXT("VERIFYSIGNATURE"),
                              TEXT("ENCRYPT"), TEXT("DECRYPT"), TEXT("IMPORT"),
                              TEXT("EXPORT"), TEXT("RSA"),
                              NULL))
        {

        //
        // ==================================================================
        //
        //  crypt [<handle>] list
        //      providers \
        //          [type <provType>]
        //      containers
        //      algorithms \
        //          [class <classId>] \
        //          [extended]
        //

        case 1:
            {
                BOOL fSts;
                DWORD dwIndex;

                switch (tclCmd.Keyword(
                                      TEXT("PROVIDERS"), TEXT("CONTAINERS"), TEXT("KEYSETS"),
                                      TEXT("ALGORITHMS"),
                                      NULL))
                {

                //
                // List all the providers known to the system
                //

                case 1:     // providers [type <n>];
                    {
                        CString szProvider;
                        DWORD dwProvType, dwTargetType = 0;
                        DWORD dwLength;
                        DWORD dwSts;

                        while (tclCmd.IsMoreArguments())
                        {
                            switch (tclCmd.Keyword(
                                                  TEXT("TYPE"),
                                                  NULL))
                            {
                            case 1: // Type
                                dwTargetType = (DWORD)tclCmd.MapValue(vmProviderTypes);
                                break;
                            default:
                                throw tclCmd.BadSyntax();
                            }
                        }
                        tclCmd.NoMoreArguments();

                        dwIndex = 0;
                        do
                        {
                            dwLength = 0;
                            fSts = MyEnumProviders(
                                         dwIndex,
                                         NULL,
                                         0,
                                         &dwProvType,
                                         NULL,
                                         &dwLength);
                            if (fSts)
                            {
                                fSts = MyEnumProviders(
                                                 dwIndex,
                                                 NULL,
                                                 0,
                                                 &dwProvType,
                                                 szProvider.GetBuffer(dwLength / sizeof(TCHAR)),
                                                 &dwLength);
                                dwSts = GetLastError();
                                szProvider.ReleaseBuffer();
                                if (!fSts)
                                {
                                    tclCmd.SetError(
                                                   TEXT("Can't obtain provider name: "),
                                                   dwSts);
                                    throw dwSts;
                                }
                                if ((0 == dwTargetType) || (dwTargetType == dwProvType))
                                    Tcl_AppendElement(tclCmd, SZ(szProvider));
                            }
                            else
                            {
                                dwSts = GetLastError();
                                if (ERROR_NO_MORE_ITEMS != dwSts)
                                {
                                    tclCmd.SetError(
                                                   TEXT("Can't obtain provider name length: "),
                                                   dwSts);
                                    throw dwSts;
                                }
                            }
                            dwIndex += 1;
                        } while (fSts);
                        break;
                    }


                    //
                    // List Containers in this provider.
                    //

                case 2: // CONTAINERS
                case 3: // KEYSETS
                    {
                        CBuffer bfKeyset;
                        DWORD dwLength = 0;
                        BOOL fDone = FALSE;
                        DWORD dwFlags = CRYPT_FIRST;

                        fSts = CryptGetProvParam(
                                                hHandle,
                                                PP_ENUMCONTAINERS,
                                                NULL,
                                                &dwLength,
                                                CRYPT_FIRST);
                        if (!fSts)
                        {
                            DWORD dwSts = GetLastError();
                            switch (dwSts)
                            {
                            case NTE_BAD_LEN:
                                ASSERT(ERROR_MORE_DATA == dwSts);
                                // fall through intentionally
                            case ERROR_MORE_DATA:
                                break;
                            case ERROR_NO_MORE_ITEMS:
                                fDone = TRUE;
                                dwLength = 0;
                                break;
                            default:
                                tclCmd.SetError(
                                               TEXT("Can't determine container buffer space requirements: "),
                                               dwSts);
                                throw (DWORD)TCL_ERROR;
                            }
                        }
                        bfKeyset.Presize(dwLength);

                        while (!fDone)
                        {
                            dwLength = bfKeyset.Space();
                            fSts = CryptGetProvParam(
                                                    hHandle,
                                                    PP_ENUMCONTAINERS,
                                                    bfKeyset.Access(),
                                                    &dwLength,
                                                    dwFlags);
                            if (!fSts)
                            {
                                DWORD dwSts = GetLastError();
                                switch (dwSts)
                                {
                                case NTE_BAD_LEN:
                                    ASSERT(ERROR_MORE_DATA == dwSts);
                                    // fall through intentionally
                                case ERROR_MORE_DATA:
                                    bfKeyset.Resize(dwLength);
                                    break;
                                case ERROR_NO_MORE_ITEMS:
                                    fDone = TRUE;
                                    break;
                                default:
                                    tclCmd.SetError(
                                                   TEXT("Can't obtain container name: "),
                                                   dwSts);
                                    throw (DWORD)TCL_ERROR;
                                }
                            }
                            else
                            {
                                bfKeyset.Resize(dwLength, TRUE);
                                Tcl_AppendElement(tclCmd, (LPSTR)bfKeyset.Access());
                                dwFlags = 0;
                            }
                        }
                        break;
                    }


                    //
                    // List algorithms supported by this provider.
                    //

                case 4: // ALGORITHMS
                    {
                        CBuffer bfAlgId;
                        DWORD dwLength = 0;
                        BOOL fDone = FALSE;
                        DWORD dwFlags = CRYPT_FIRST;
                        DWORD dwClassType = ALG_CLASS_ANY;
                        DWORD dwParam = PP_ENUMALGS;

                        while (tclCmd.IsMoreArguments())
                        {
                            switch (tclCmd.Keyword(
                                                  TEXT("CLASS"), TEXT("EXTENDED"),
                                                  NULL))
                            {
                            case 1: // Type
                                dwClassType = (DWORD)tclCmd.MapValue(vmClassTypes);
                                break;
                            case 2: // extended
                                dwParam = PP_ENUMALGS_EX;
                                break;
                            default:
                                throw tclCmd.BadSyntax();
                            }
                        }

                        fSts = CryptGetProvParam(
                                                hHandle,
                                                dwParam,
                                                NULL,
                                                &dwLength,
                                                CRYPT_FIRST);
                        if (!fSts)
                        {
                            DWORD dwSts = GetLastError();
                            switch (dwSts)
                            {
                            case NTE_BAD_LEN:
                                ASSERT(ERROR_MORE_DATA == dwSts);
                                dwSts = ERROR_MORE_DATA;
                                // fall through intentionally
                            case ERROR_MORE_DATA:
                                break;
                            default:
                                tclCmd.SetError(
                                               TEXT("Can't determine algorithm buffer space requirements: "),
                                               dwSts);
                                throw (DWORD)TCL_ERROR;
                            }
                        }
                        bfAlgId.Presize(dwLength);

                        while (!fDone)
                        {
                            dwLength = bfAlgId.Space();
                            fSts = CryptGetProvParam(
                                                    hHandle,
                                                    dwParam,
                                                    bfAlgId.Access(),
                                                    &dwLength,
                                                    dwFlags);
                            if (!fSts)
                            {
                                DWORD dwSts = GetLastError();
                                switch (dwSts)
                                {
                                case NTE_BAD_LEN:
                                    ASSERT(ERROR_MORE_DATA == dwSts);
                                    // fall through intentionally
                                case ERROR_MORE_DATA:
                                    bfAlgId.Resize(dwLength);
                                    break;
                                case ERROR_NO_MORE_ITEMS:
                                    fDone = TRUE;
                                    break;
                                default:
                                    tclCmd.SetError(
                                                   TEXT("Can't obtain algorithm: "),
                                                   dwSts);
                                    throw (DWORD)TCL_ERROR;
                                }
                            }
                            else
                            {
                                if (PP_ENUMALGS == dwParam)
                                {
                                    PROV_ENUMALGS *palgEnum
                                        = (PROV_ENUMALGS *)bfAlgId.Access();

                                    ASSERT(sizeof(PROV_ENUMALGS) == dwLength);
                                    if ((ALG_CLASS_ANY == dwClassType)
                                        || (GET_ALG_CLASS(palgEnum->aiAlgid) == dwClassType))
                                    {
                                        Tcl_AppendElement(
                                                         tclCmd,
                                                         palgEnum->szName);
                                    }
                                }
                                else
                                {
                                    PROV_ENUMALGS_EX *palgEnum
                                        = (PROV_ENUMALGS_EX *)bfAlgId.Access();

                                    ASSERT(sizeof(PROV_ENUMALGS_EX) == dwLength);
                                    if ((ALG_CLASS_ANY == dwClassType)
                                        || (GET_ALG_CLASS(palgEnum->aiAlgid) == dwClassType))
                                    {
                                        Tcl_AppendElement(
                                                         tclCmd,
                                                         palgEnum->szLongName);
                                    }
                                }
                                dwFlags = 0;
                            }
                        }
                        break;
                    }

                default:
                    throw tclCmd.BadSyntax();
                }
                break;
            }


            //
            // ==================================================================
            //
            //  crypt acquire \
            //      [provider <providerName>] \
            //      [type <provType>] \
            //      [container <containerName>] \
            //      [verifycontext] [newkeyset] [deletekeyset] [machine] [silent] \
            //      [flags {<acquireFlag> [<acquireFlag> [...]]]}
            //

        case 2:
            {
                DWORD dwFlags = 0;
                BOOL fProvValid = FALSE;
                BOOL fContValid = FALSE;
                BOOL fSts;
                CString szProvider;
                CString szContainer;
                DWORD dwProvType = 0;
                HCRYPTPROV hProv;

                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("PROVIDER"), TEXT("TYPE"),
                                          TEXT("CONTAINER"), TEXT("KEYSET"),
                                          TEXT("VERIFYCONTEXT"), TEXT("NEWKEYSET"),
                                          TEXT("DELETEKEYSET"), TEXT("MACHINE"),
                                          TEXT("SILENT"), TEXT("FLAGS"),
                                          NULL))
                    {
                    case 1: // PROVIDER
                        if (fProvValid)
                            throw tclCmd.BadSyntax();
                        tclCmd.NextArgument(szProvider);
                        fProvValid = TRUE;
                        break;
                    case 2: // TYPE
                        if (0 != dwProvType)
                            throw tclCmd.BadSyntax();
                        dwProvType = tclCmd.MapValue(vmProviderTypes);
                        break;
                    case 3: // CONTAINER
                    case 4: // KEYSET
                        if (fContValid)
                            throw tclCmd.BadSyntax();
                        tclCmd.NextArgument(szContainer);
                        fContValid = TRUE;
                        break;
                    case 5: // VERIFYCONTEXT
                        dwFlags |= CRYPT_VERIFYCONTEXT;
                        break;
                    case 6: // NEWKEYSET
                        dwFlags |= CRYPT_NEWKEYSET;
                        break;
                    case 7: // DELETEKEYSET
                        dwFlags |= CRYPT_DELETEKEYSET;
                        break;
                    case 8: // MACHINE
                        dwFlags |= CRYPT_MACHINE_KEYSET;
                        break;
                    case 9: // SILENT
                        dwFlags |= CRYPT_SILENT;
                        break;
                    case 10: // FLAGS
                        dwFlags |= tclCmd.MapFlags(vmAcquireFlags);
                        break;
                    default:
                        throw tclCmd.BadSyntax();
                    }
                }

                fSts = CryptAcquireContext(
                                          &hProv,
                                          fContValid ? (LPCTSTR)szContainer : (LPCTSTR)NULL,
                                          fProvValid ? (LPCTSTR)szProvider : (LPCTSTR)MS_DEF_PROV,
                                          0 != dwProvType ? dwProvType : PROV_RSA_FULL,
                                          dwFlags);
                if (!fSts)
                {
                    tclCmd.SetError(
                                   TEXT("Can't acquire context: "),
                                   GetLastError());
                    throw (DWORD)TCL_ERROR;
                }
                ReturnHandle(tclCmd, hProv, Provider);
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> release
            //      [flags {<emptyFlags> [<emptyFlags> [...]]}]
            //

        case 3:
            {
                DWORD dwFlags = 0;
                BOOL fSts;

                switch (nHandleType)
                {
                case Provider:
                    while (tclCmd.IsMoreArguments())
                    {
                        switch (tclCmd.Keyword(
                                              TEXT("FLAGS"),
                                              NULL))
                        {
                        case 1: // FLAGS
                            dwFlags |= tclCmd.MapFlags(vmEmptyFlags);
                            break;
                        default:
                            throw tclCmd.BadSyntax();
                        }
                    }
                    fSts = CryptReleaseContext(
                                              hHandle,
                                              dwFlags);
                    if (!fSts)
                    {
                        tclCmd.SetError(
                                       TEXT("Can't release context: "),
                                       GetLastError());
                        throw (DWORD)TCL_ERROR;
                    }
                    break;
                case Key:
                    tclCmd.NoMoreArguments();
                    fSts = CryptDestroyKey(hHandle);
                    if (!fSts)
                    {
                        tclCmd.SetError(
                                       TEXT("Can't release key: "),
                                       ErrorString(GetLastError()),
                                       NULL);
                        throw (DWORD)TCL_ERROR;
                    }
                    break;
                case Hash:
                    tclCmd.NoMoreArguments();
                    fSts = CryptDestroyHash(hHandle);
                    if (!fSts)
                    {
                        tclCmd.SetError(
                                       TEXT("Can't release hash: "),
                                       GetLastError());
                        throw (DWORD)TCL_ERROR;
                    }
                    break;
                default:
                    throw tclCmd.BadSyntax();
                }
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> parameter <paramId> \
            //      [output { text | hex | file <fileName> }] \
            //      [flags {<acquireFlag> [<acquireFlag> [...]]}] \
            //      [input { text | hex | file }] [value]
            //

        case 4:
            {
                DWORD dwFlags = 0;
                BOOL fSts;
                BOOL fForceRetry;
                BOOL fSetValue = FALSE;
                CBuffer bfValue;
                DWORD dwLength, dwSts;
                CBuffer bfData;
                DWORD dwParamId = 0;
                CRenderableData inData, outData;

                switch (nHandleType)
                {
                case Provider:
                    dwParamId = tclCmd.MapValue(vmGetProvParams);
                    break;
                case Key:
                    dwParamId = tclCmd.MapValue(vmKeyParams);
                    break;
                case Hash:
                    dwParamId = tclCmd.MapValue(vmHashParams);
                    break;
                default:
                    throw tclCmd.BadSyntax();
                }

                tclCmd.OutputStyle(outData);
                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("FLAGS"),
                                          NULL))
                    {
                    case 1: // FLAGS
                        dwFlags |= tclCmd.MapFlags(vmGetFlags);
                        break;
                    default:    // Value to set
                        if (fSetValue)
                            throw tclCmd.BadSyntax();
                        tclCmd.InputStyle(inData);
                        tclCmd.ReadData(inData);
                        fSetValue = TRUE;
                    }
                }


                //
                // If a value is supplied, set the parmeter to that value.
                // Otherwise, just return the current value of the parameter.
                //

                if (fSetValue)
                {
                    switch (nHandleType)
                    {
                    case Provider:
                        fSts = CryptSetProvParam(
                                                hHandle,
                                                dwParamId,
                                                (LPBYTE)inData.Value(),
                                                dwFlags);
                        break;
                    case Key:
                        fSts = CryptSetKeyParam(
                                               hHandle,
                                               dwParamId,
                                               (LPBYTE)inData.Value(),
                                               dwFlags);
                        break;
                    case Hash:
                        fSts = CryptSetHashParam(
                                                hHandle,
                                                dwParamId,
                                                (LPBYTE)inData.Value(),
                                                dwFlags);
                        break;
                    default:
                        throw (DWORD)SCARD_F_INTERNAL_ERROR;
                    }
                    if (!fSts)
                    {
                        dwSts = GetLastError();
                        tclCmd.SetError(
                                       TEXT("Can't set parameter: "),
                                       dwSts);
                        throw dwSts;
                    }
                }
                else
                {
                    do
                    {
                        dwLength = bfData.Space();
                        fForceRetry = (0 == dwLength);
                        switch (nHandleType)
                        {
                        case Provider:
                            fSts = CryptGetProvParam(
                                                    hHandle,
                                                    dwParamId,
                                                    bfData.Access(),
                                                    &dwLength,
                                                    dwFlags);
                            break;
                        case Key:
                            fSts = CryptGetKeyParam(
                                                   hHandle,
                                                   dwParamId,
                                                   bfData.Access(),
                                                   &dwLength,
                                                   dwFlags);
                            break;
                        case Hash:
                            fSts = CryptGetHashParam(
                                                    hHandle,
                                                    dwParamId,
                                                    bfData.Access(),
                                                    &dwLength,
                                                    dwFlags);
                            break;
                        default:
                            throw (DWORD)SCARD_F_INTERNAL_ERROR;
                        }
                        if (!fSts)
                        {
                            dwSts = GetLastError();
                            if (NTE_BAD_LEN == dwSts)
                            {
                                ASSERT(ERROR_MORE_DATA == dwSts);
                                dwSts = ERROR_MORE_DATA;
                            }
                        }
                        else
                        {
                            if (fForceRetry)
                                dwSts = ERROR_MORE_DATA;
                            else
                            {
                                ASSERT(bfData.Space() >= dwLength);
                                dwSts = ERROR_SUCCESS;
                            }
                        }
                        bfData.Resize(dwLength, fSts);
                    } while (ERROR_MORE_DATA == dwSts);
                    if (ERROR_SUCCESS != dwSts)
                    {
                        tclCmd.SetError(TEXT("Can't get parameter: "), dwSts);
                        throw (DWORD)TCL_ERROR;
                    }

                    outData.LoadData(bfData.Access(), bfData.Length());
                    tclCmd.Render(outData);
                }
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> get \
            //      key <keyId>
            //      random <length> \
            //          [output { text | hex | file <fileName> }]
            //

        case 5:
            {
                switch (tclCmd.Keyword(
                                      TEXT("KEY"), TEXT("RANDOM"),
                                      NULL))
                {
                case 1:     // key <keyId>
                    {
                        BOOL fSts;
                        HCRYPTKEY hKey = NULL;
                        DWORD dwKeyId;

                        dwKeyId = (DWORD)tclCmd.MapValue(vmKeyTypes);
                        fSts = CryptGetUserKey(hHandle, dwKeyId, &hKey);
                        if (!fSts)
                        {
                            DWORD dwSts = GetLastError();
                            tclCmd.SetError(
                                           TEXT("Can't get user key: "),
                                           dwSts);
                            throw dwSts;
                        }
                        ReturnHandle(tclCmd, hKey, Key);
                        break;
                    }
                case 2:     // random length <length>
                    {
                        DWORD dwLength = 0;
                        CBuffer bfData;
                        BOOL fSts;
                        BOOL fGotFormat = FALSE;
                        CRenderableData outData;

                        tclCmd.OutputStyle(outData);
                        while (tclCmd.IsMoreArguments())
                        {
                            switch (tclCmd.Keyword(
                                                  TEXT("LENGTH"),
                                                  NULL))
                            {
                            case 1: // length
                                dwLength = tclCmd.Value();
                                break;
                            default:    // Value to set
                                if (fGotFormat)
                                    throw tclCmd.BadSyntax();
                                tclCmd.OutputStyle(outData);
                                fGotFormat = TRUE;
                            }
                        }
                        bfData.Resize(dwLength);
                        fSts = CryptGenRandom(
                                             hHandle,
                                             dwLength,
                                             bfData.Access());
                        if (!fSts)
                        {
                            DWORD dwSts = GetLastError();
                            tclCmd.SetError(
                                           TEXT("Can't generate random data: "),
                                           dwSts);
                            throw dwSts;
                        }
                        outData.LoadData(bfData.Access(), bfData.Length());
                        tclCmd.Render(outData);
                        break;
                    }
                default:
                    throw tclCmd.BadSyntax();
                }
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> create
            //      hash \
            //          algorithm <algId> \
            //          [flags {<emptyFlag> [<emptyFlag> [...]]}]
            //      key \
            //          algorithm <algId>
            //          type <keytype>
            //          [hash <hHash>] \
            //          [flags {<emptyFlag> [<emptyFlag> [...]]}]
            //

        case 6:
            {
                switch (tclCmd.Keyword(
                                      TEXT("HASH"), TEXT("KEY"),
                                      NULL))
                {
                case 1: // hash
                    {
                        HCRYPTHASH hHash = NULL;
                        HCRYPTKEY hKey = NULL;
                        ALG_ID algId = 0;
                        DWORD dwFlags = 0;
                        BOOL fSts;
                        HandleType nHandleType;

                        while (tclCmd.IsMoreArguments())
                        {
                            switch (tclCmd.Keyword(
                                                  TEXT("ALGORITHM"), TEXT("FLAGS"), TEXT("KEY"),
                                                  NULL))
                            {
                            case 1: // algorithm
                                algId = tclCmd.MapValue(vmAlgIds);
                                break;
                            case 2: // key
                                ExtractHandle(
                                             tclCmd,
                                             (LPLONG)&hKey,
                                             &nHandleType,
                                             TRUE);
                                if (Key != nHandleType)
                                {
                                    tclCmd.SetError(TEXT("Invalid key handle"), NULL);
                                    throw (DWORD)TCL_ERROR;
                                }
                                break;
                            case 3: // flags
                                dwFlags |= tclCmd.MapFlags(vmEmptyFlags);
                                break;
                            default:
                                throw tclCmd.BadSyntax();
                            }
                        }

                        fSts = CryptCreateHash(
                                              hHandle,
                                              algId,
                                              hKey,
                                              dwFlags,
                                              &hHash);
                        if (!fSts)
                        {
                            DWORD dwSts = GetLastError();
                            tclCmd.SetError(
                                           TEXT("Can't create hash: "),
                                           dwSts);
                            throw dwSts;
                        }
                        ReturnHandle(tclCmd, hHash, Hash);
                        break;
                    }
                case 2: // key
                    {
                        ALG_ID algId = 0;
                        DWORD dwFlags = 0;
                        BOOL fSts;
                        HCRYPTKEY hKey = NULL;
                        HCRYPTHASH hHash = NULL;
                        HandleType nHandleType;

                        while (tclCmd.IsMoreArguments())
                        {
                            switch (tclCmd.Keyword(
                                                  TEXT("ALGORITHM"), TEXT("TYPE"),
                                                  TEXT("HASH"), TEXT("FLAGS"),
                                                  TEXT("KEY"),
                                                  NULL))
                            {
                            case 1: // algorithm
                                algId = tclCmd.MapValue(vmAlgIds);
                                break;
                            case 2: // type
                                algId = tclCmd.MapValue(vmKeyTypes);
                                break;
                            case 3: // hash
                                ExtractHandle(
                                             tclCmd,
                                             (LPLONG)&hHash,
                                             &nHandleType,
                                             TRUE);
                                if (Hash != nHandleType)
                                {
                                    tclCmd.SetError(TEXT("Invalid hash handle"), NULL);
                                    throw (DWORD)TCL_ERROR;
                                }
                                break;
                            case 4: // flags
                                dwFlags |= tclCmd.MapFlags(vmKeyFlags);
                                break;
                            case 5: // key
                                ExtractHandle(
                                             tclCmd,
                                             (LPLONG)&hKey,
                                             &nHandleType,
                                             TRUE);
                                if (Key != nHandleType)
                                {
                                    tclCmd.SetError(TEXT("Invalid key handle"), NULL);
                                    throw (DWORD)TCL_ERROR;
                                }
                                break;
                            default:
                                throw tclCmd.BadSyntax();
                            }
                        }

                        if (NULL != hHash)
                        {
                            fSts = CryptDeriveKey(
                                                 hHandle,
                                                 algId,
                                                 hHash,
                                                 dwFlags,
                                                 &hKey);
                        }
                        else
                        {
                            fSts = CryptGenKey(
                                              hHandle,
                                              algId,
                                              dwFlags,
                                              &hKey);
                        }

                        if (!fSts)
                        {
                            DWORD dwSts = GetLastError();
                            tclCmd.SetError(
                                           TEXT("Can't create key: "),
                                           dwSts);
                            throw dwSts;
                        }
                        ReturnHandle(tclCmd, hKey, Key);
                        break;
                    }
                default:
                    throw tclCmd.BadSyntax();
                }
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> hash \
            //      [flags {<hashFlag> [<hashFlag> [...]]}] \
            //      [key <keyId>]
            //      [data [-input { text | hex | file }] value]
            //

        case 7:
            {
                CRenderableData inData;
                BOOL fSts, fGotData = FALSE;
                DWORD dwFlags = 0;
                HCRYPTKEY hKey = NULL;
                HandleType nHandleType;

                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("FLAGS"), TEXT("KEY"), TEXT("DATA"),
                                          NULL))
                    {
                    case 1: // FLAGS
                        dwFlags |= tclCmd.MapFlags(vmHashDataFlags);
                        break;
                    case 2: // Key
                        if (fGotData || NULL != hKey)
                            throw tclCmd.BadSyntax();
                        ExtractHandle(
                                     tclCmd,
                                     (LPLONG)&hKey,
                                     &nHandleType,
                                     TRUE);
                        if (Key != nHandleType)
                        {
                            tclCmd.SetError(TEXT("Invalid key handle"), NULL);
                            throw (DWORD)TCL_ERROR;
                        }
                        break;
                    case 3: // data
                        {
                            if (fGotData || NULL != hKey)
                                throw tclCmd.BadSyntax();
                            tclCmd.InputStyle(inData);
                            tclCmd.ReadData(inData);
                            fGotData = TRUE;
                            break;
                        }
                    default:
                        throw tclCmd.BadSyntax();
                    }
                }

                if (fGotData)
                {
                    fSts = CryptHashData(
                                        hHandle,
                                        inData.Value(),
                                        inData.Length(),
                                        dwFlags);
                    if (!fSts)
                    {
                        DWORD dwSts = GetLastError();
                        tclCmd.SetError(
                                       TEXT("Can't hash data: "),
                                       dwSts);
                        throw dwSts;
                    }
                }
                else if (NULL != hKey)
                {
                    fSts = CryptHashSessionKey(
                                              hHandle,
                                              hKey,
                                              dwFlags);
                    if (!fSts)
                    {
                        DWORD dwSts = GetLastError();
                        tclCmd.SetError(
                                       TEXT("Can't hash session key: "),
                                       dwSts);
                        throw dwSts;
                    }
                }
                else
                    throw tclCmd.BadSyntax();
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> signhash \
            //      [output { text | hex | file <fileName> }] \
            //      key <keyId> \
            //      [description <desc>] \
            //      [flags {<signFlag> [<signFlag> [...]]}] \
            //

        case 8:
            {
                CBuffer bfSignature;
                DWORD dwLength;
                DWORD dwSts;
                BOOL fSts;
                BOOL fForceRetry;
                BOOL fGotDesc = FALSE;
                CString szDescription;
                DWORD dwKeyId = 0;
                DWORD dwFlags = 0;
                CRenderableData outData;

                tclCmd.OutputStyle(outData);
                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("FLAGS"), TEXT("DESCRIPTION"), TEXT("KEY"),
                                          NULL))
                    {
                    case 1: // FLAGS
                        dwFlags |= tclCmd.MapFlags(vmSignVerifyFlags);
                        break;
                    case 2: // Description
                        tclCmd.NextArgument(szDescription);
                        fGotDesc = TRUE;
                        break;
                    case 3: // Key
                        dwKeyId = (DWORD)tclCmd.MapValue(vmKeyTypes);
                        break;
                    default:
                        throw tclCmd.BadSyntax();
                    }
                }

                do
                {
                    dwLength = bfSignature.Space();
                    fForceRetry = (0 == dwLength);
                    fSts = CryptSignHash(
                                        hHandle,
                                        dwKeyId,
                                        fGotDesc ? (LPCTSTR)szDescription : NULL,
                                        dwFlags,
                                        bfSignature.Access(),
                                        &dwLength);
                    if (!fSts)
                    {
                        dwSts = GetLastError();
                        if (NTE_BAD_LEN == dwSts)
                        {
                            ASSERT(ERROR_MORE_DATA == dwSts);
                            dwSts = ERROR_MORE_DATA;
                        }
                    }
                    else
                    {
                        if (fForceRetry)
                            dwSts = ERROR_MORE_DATA;
                        else
                        {
                            ASSERT(bfSignature.Space() >= dwLength);
                            dwSts = ERROR_SUCCESS;
                        }
                    }
                    bfSignature.Resize(dwLength, fSts);
                } while (ERROR_MORE_DATA == dwSts);
                if (ERROR_SUCCESS != dwSts)
                {
                    tclCmd.SetError(TEXT("Can't sign hash: "), dwSts);
                    throw (DWORD)TCL_ERROR;
                }

                outData.LoadData(bfSignature.Access(), bfSignature.Length());
                tclCmd.Render(outData);
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> verifysignature \
            //      key <hPubKey> \
            //      [description <desc>] \
            //      [flags {<signFlag> [<signFlag> [...]]}] \
            //      [input { text | hex | file }] value
            //

        case 9:
            {
                BOOL fGotDesc = FALSE;
                BOOL fGotValue = FALSE;
                CString szDescription;
                DWORD dwFlags = 0;
                CRenderableData inData;
                HCRYPTKEY hPubKey = 0;
                HandleType nPubKeyType = Undefined;
                BOOL fSts;

                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("FLAGS"), TEXT("DESCRIPTION"), TEXT("KEY"),
                                          NULL))
                    {
                    case 1: // FLAGS
                        dwFlags |= tclCmd.MapFlags(vmSignVerifyFlags);
                        break;
                    case 2: // Description
                        tclCmd.NextArgument(szDescription);
                        fGotDesc = TRUE;
                        break;
                    case 3: // Key
                        ExtractHandle(
                                     tclCmd,
                                     (LPLONG)&hPubKey,
                                     &nPubKeyType,
                                     TRUE);
                        if (Key != nPubKeyType)
                        {
                            tclCmd.SetError(TEXT("Invalid key handle"), NULL);
                            throw (DWORD)TCL_ERROR;
                        }
                        break;
                    default:
                        if (fGotValue)
                            throw tclCmd.BadSyntax();
                        tclCmd.InputStyle(inData);
                        tclCmd.ReadData(inData);
                        fGotValue = TRUE;
                    }
                }

                fSts = CryptVerifySignature(
                                           hHandle,
                                           inData.Value(),
                                           inData.Length(),
                                           hPubKey,
                                           fGotDesc ? (LPCTSTR)szDescription : NULL,
                                           dwFlags);
                if (!fSts)
                {
                    DWORD dwSts = GetLastError();
                    tclCmd.SetError(
                                   TEXT("Can't verify signature: "),
                                   dwSts);
                    throw dwSts;
                }
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> encrypt \
            //      [output { text | hex | file <fileName> }] \
            //      [hash <hHash>] \
            //      [flags {<cryptFlag> [<cryptFlag> [...]]}] \
            //      [{more | final}] \
            //      [input { text | hex | file }] value
            //

        case 10:
            {
                BOOL fSts;
                BOOL fGotValue = FALSE;
                HCRYPTHASH hHash = NULL;
                HandleType nHashHandle;
                CRenderableData inData, outData;
                CBuffer bfCrypt;
                BOOL fFinal = TRUE;
                DWORD dwFlags = 0;
                DWORD dwLength, dwSts;

                tclCmd.OutputStyle(outData);
                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("HASH"), TEXT("MORE"), TEXT("FINAL"),
                                          NULL))
                    {
                    case 1: // Hash
                        ExtractHandle(
                                     tclCmd,
                                     (LPLONG)&hHash,
                                     &nHashHandle,
                                     TRUE);
                        if (Hash != nHashHandle)
                        {
                            tclCmd.SetError(TEXT("Invalid hash handle"), NULL);
                            throw (DWORD)TCL_ERROR;
                        }
                        break;
                    case 2: // More
                        fFinal = FALSE;
                        break;
                    case 3: // Final
                        fFinal = TRUE;
                        break;
                    case 4: // Flags
                        dwFlags |= tclCmd.MapFlags(vmEmptyFlags);
                        break;
                    default:
                        if (fGotValue)
                            throw tclCmd.BadSyntax();
                        tclCmd.InputStyle(inData);
                        tclCmd.ReadData(inData);
                        fGotValue = TRUE;
                    }
                }

                for (;;)
                {
                    dwLength = inData.Length();
                    bfCrypt.Set(inData.Value(), dwLength);
                    fSts = CryptEncrypt(
                                       hHandle,
                                       hHash,
                                       fFinal,
                                       dwFlags,
                                       bfCrypt.Access(),
                                       &dwLength,
                                       bfCrypt.Space());
                    if (!fSts)
                    {
                        dwSts = GetLastError();
                        switch (dwSts)
                        {
                        case NTE_BAD_LEN:
                            ASSERT(ERROR_MORE_DATA == dwSts);
                            // fall through intentionally
                        case ERROR_MORE_DATA:
                            bfCrypt.Presize(dwLength);
                            break;
                        default:
                            tclCmd.SetError(
                                           TEXT("Can't encrypt data: "),
                                           dwSts);
                            throw dwSts;
                        }
                    }
                    else
                    {
                        bfCrypt.Resize(dwLength, TRUE);
                        break;
                    }
                }
                outData.LoadData(bfCrypt.Access(), bfCrypt.Length());
                tclCmd.Render(outData);
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> decrypt \
            //      [output { text | hex | file <fileName> }] \
            //      [hash <hHash>] \
            //      [flags {<cryptFlag> [<cryptFlag> [...]]}] \
            //      [{more | final}] \
            //      [input { text | hex | file }] value
            //

        case 11:
            {
                BOOL fSts;
                BOOL fGotValue = FALSE;
                HCRYPTHASH hHash = NULL;
                HandleType nHashHandle;
                CRenderableData inData, outData;
                CBuffer bfCrypt;
                BOOL fFinal = TRUE;
                DWORD dwFlags = 0;
                DWORD dwLength, dwSts;

                tclCmd.OutputStyle(outData);
                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("HASH"), TEXT("MORE"), TEXT("FINAL"),
                                          NULL))
                    {
                    case 1: // Hash
                        ExtractHandle(
                                     tclCmd,
                                     (LPLONG)&hHash,
                                     &nHashHandle,
                                     TRUE);
                        if (Hash != nHashHandle)
                        {
                            tclCmd.SetError(TEXT("Invalid hash handle"), NULL);
                            throw (DWORD)TCL_ERROR;
                        }
                        break;
                    case 2: // More
                        fFinal = FALSE;
                        break;
                    case 3: // Final
                        fFinal = TRUE;
                        break;
                    case 4: // Flags
                        dwFlags |= tclCmd.MapFlags(vmEmptyFlags);
                        break;
                    default:
                        if (fGotValue)
                            throw tclCmd.BadSyntax();
                        tclCmd.InputStyle(inData);
                        tclCmd.ReadData(inData);
                        fGotValue = TRUE;
                    }
                }

                dwLength = inData.Length();
                bfCrypt.Set(inData.Value(), dwLength);
                fSts = CryptDecrypt(
                                   hHandle,
                                   hHash,
                                   fFinal,
                                   dwFlags,
                                   bfCrypt.Access(),
                                   &dwLength);
                if (!fSts)
                {
                    dwSts = GetLastError();
                    switch (dwSts)
                    {
                    case NTE_BAD_LEN:
                        ASSERT(ERROR_MORE_DATA == dwSts);
                        // fall through intentionally
                    case ERROR_MORE_DATA:
                        bfCrypt.Presize(dwLength);
                        break;
                    default:
                        tclCmd.SetError(
                                       TEXT("Can't encrypt data: "),
                                       dwSts);
                        throw dwSts;
                    }
                }
                else
                    bfCrypt.Resize(dwLength, TRUE);
                outData.LoadData(bfCrypt.Access(), bfCrypt.Length());
                tclCmd.Render(outData);
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> import \
            //      [key <hImpKey>] \
            //      [flags {<importFlag> [<importFlag> [...]]}] \
            //      [input { text | hex | file }] value
            //

        case 12:
            {
                BOOL fSts;
                BOOL fGotValue = FALSE;
                HCRYPTKEY hImpKey = NULL;
                HandleType nHandleType;
                HCRYPTKEY hKey;
                CRenderableData inData;
                DWORD dwFlags = 0;

                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("KEY"), TEXT("FLAGS"),
                                          NULL))
                    {
                    case 1: // Key
                        ExtractHandle(
                                     tclCmd,
                                     (LPLONG)&hImpKey,
                                     &nHandleType,
                                     TRUE);
                        if (Key != nHandleType)
                        {
                            tclCmd.SetError(TEXT("Invalid key handle"), NULL);
                            throw (DWORD)TCL_ERROR;
                        }
                        break;
                    case 2: // Flags
                        dwFlags |= tclCmd.MapFlags(vmKeyFlags);
                        break;
                    default:
                        if (fGotValue)
                            throw tclCmd.BadSyntax();
                        tclCmd.InputStyle(inData);
                        tclCmd.ReadData(inData);
                        fGotValue = TRUE;
                    }
                }

                fSts = CryptImportKey(
                                     hHandle,
                                     inData.Value(),
                                     inData.Length(),
                                     hImpKey,
                                     dwFlags,
                                     &hKey);
                if (!fSts)
                {
                    DWORD dwSts = GetLastError();
                    tclCmd.SetError(
                                   TEXT("Can't import key: "),
                                   dwSts);
                    throw dwSts;
                }
                ReturnHandle(tclCmd, hKey, Key);
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> export \
            //      [output { text | hex | file <fileName> }] \
            //      [key <keyId>] \
            //      [type <blobType>] \
            //      [flags {<exprtFlag> [<exportFlag> [...]]}] \
            //

        case 13:
            {
                BOOL fSts;
                HCRYPTKEY hExpKey = NULL;
                HandleType nHandleType;
                DWORD dwBlobType = 0;
                DWORD dwFlags = 0;
                CBuffer bfBlob;
                DWORD dwLength, dwSts;
                CRenderableData outData;

                tclCmd.OutputStyle(outData);
                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("KEY"), TEXT("FLAGS"), TEXT("TYPE"),
                                          NULL))
                    {
                    case 1: // Key
                        ExtractHandle(
                                     tclCmd,
                                     (LPLONG)&hExpKey,
                                     &nHandleType,
                                     TRUE);
                        if (Key != nHandleType)
                        {
                            tclCmd.SetError(TEXT("Invalid key handle"), NULL);
                            throw (DWORD)TCL_ERROR;
                        }
                        break;
                    case 2: // Flags
                        dwFlags |= tclCmd.MapFlags(vmEmptyFlags);
                        break;
                    case 3: // Type
                        dwBlobType = tclCmd.MapValue(vmBlobTypes);
                        break;
                    default:
                        throw tclCmd.BadSyntax();
                    }
                }

                for (;;)
                {
                    dwLength = bfBlob.Space();
                    fSts = CryptExportKey(
                                         hHandle,
                                         hExpKey,
                                         dwBlobType,
                                         dwFlags,
                                         bfBlob.Access(),
                                         &dwLength);
                    if (!fSts)
                    {
                        dwSts = GetLastError();
                        switch (dwSts)
                        {
                        case NTE_BAD_LEN:
                            ASSERT(ERROR_MORE_DATA == dwSts);
                            // fall through intentionally
                        case ERROR_MORE_DATA:
                            bfBlob.Presize(dwLength);
                            break;
                        default:
                            tclCmd.SetError(
                                           TEXT("Can't export key: "),
                                           dwSts);
                            throw dwSts;
                        }
                    }
                    else
                    {
                        bfBlob.Resize(dwLength, TRUE);
                        break;
                    }
                }
                outData.LoadData(bfBlob.Access(), bfBlob.Length());
                tclCmd.Render(outData);
                break;
            }


#if 0
            //
            // ==================================================================
            //
            // crypt <handle> rsa
            //      view \
            //          [input { text | hex | file }] \
            //          [output { text | hex | file <fileName> }] \
            //          <value>
            //

        case 14:
            {
                CRenderableData outData;

                tclCmd.OutputStyle(outData);
                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("VIEW"),
                                          NULL))
                    {
                    case 1: // view
                        {
                            CBuffer bfBlob;
                            CBuffer bfData;
                            CBuffer bfModulus;
                            CBuffer bfValue;
                            CRenderableData inData;
                            BOOL fSts;
                            DWORD dwLength, dwSts;

                            tclCmd.InputStyle(inData);
                            tclCmd.ReadData(inData);
                            tclCmd.NoMoreArguments();


                            //
                            // Get the public key
                            //

                            for (;;)
                            {
                                dwLength = bfBlob.Space();
                                fSts = CryptExportKey(
                                                     hHandle,
                                                     NULL,
                                                     PUBLICKEYBLOB,
                                                     0,
                                                     bfBlob.Access(),
                                                     &dwLength);
                                if (!fSts)
                                {
                                    dwSts = GetLastError();
                                    switch (dwSts)
                                    {
                                    case NTE_BAD_LEN:
                                        ASSERT(ERROR_MORE_DATA == dwSts);
                                        // fall through intentionally
                                    case ERROR_MORE_DATA:
                                        bfBlob.Presize(dwLength);
                                        break;
                                    default:
                                        tclCmd.SetError(
                                                       TEXT("Can't export RSA public key: "),
                                                       dwSts);
                                        throw dwSts;
                                    }
                                }
                                else
                                {
                                    bfBlob.Resize(dwLength, TRUE);
                                    break;
                                }
                            }


                            //
                            // Calculate the blob fields.
                            //

                            BLOBHEADER *pBlobHeader = (BLOBHEADER *)bfBlob.Access();
                            RSAPUBKEY *pRsaPubKey = (RSAPUBKEY *)bfBlob.Access(sizeof(BLOBHEADER));
                            LPDWORD pModulus = (LPDWORD)bfBlob.Access(sizeof(BLOBHEADER) + sizeof(RSAPUBKEY));
                            dwLength = pRsaPubKey->bitlen / 8 + sizeof(DWORD) * 3;
                            bfModulus.Resize(dwLength);
                            bfData.Resize(dwLength);
                            bfValue.Resize(dwLength);
                            ZeroMemory(bfModulus.Access(), dwLength);
                            ZeroMemory(bfData.Access(), dwLength);
                            ZeroMemory(bfValue.Access(), dwLength);
                            dwLength = pRsaPubKey->bitlen / 8;
                            bfModulus.Set((LPCBYTE)pModulus, dwLength);
                            bfValue.Set(inData.Value(), inData.Length());

                            BenalohModExp(
                                         (LPDWORD)bfData.Access(),
                                         (LPDWORD)bfValue.Access(),
                                         &pRsaPubKey->pubexp,
                                         (LPDWORD)bfModulus.Access(),
                                         (dwLength + sizeof(DWORD) - 1 ) / sizeof(DWORD));
                            bfData.Resize(dwLength, TRUE);
                            outData.LoadData(bfData.Access(), bfData.Length());
                            tclCmd.Render(outData);
                            break;
                        }

                    default:
                        throw tclCmd.BadSyntax();
                    }
                }
                break;
            }
#endif


            //
            // ==================================================================
            //
            // Not a recognized command.  Report an error.
            //

        default:
            throw tclCmd.BadSyntax();
        }
    }
    catch (DWORD)
    {
        nTclStatus = TCL_ERROR;
    }

    return nTclStatus;
}


/*++

ExtractHandle:

    This routine extracts a handle and type from the input stream, if there is
    one to extract.

Arguments:

    tclCmd supplies the tcl Command processor object.

    phHandle receives the extracted handle value, or zero if none is in the
        stream.

    pnHandleType receives the handle type, or Undefined if none is in the
        stream.

    fMandatory supplies a flag indicating whether or not the key value must
        exist in the input stream.  If this value is false, and no handle
        value can be found, then no error is declared, and zeroes are returned.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 5/24/1998

--*/

static void
ExtractHandle(
    CTclCommand &tclCmd,
    LONG *phHandle,
    HandleType *pnHandleType,
    BOOL fMandatory)
{
    CString szHandle;
    DWORD dwHandle = 0;
    HandleType nHandleType = Undefined;
    LPTSTR szTermChar;

    tclCmd.PeekArgument(szHandle);
    dwHandle = _tcstoul(szHandle, &szTermChar, 0);
    if (0 != dwHandle)
    {
        switch (poption(szTermChar,
                        TEXT("HASH"), TEXT("KEY"), TEXT("PROVIDER"),
                        NULL))
        {
        case 1:
            nHandleType = Hash;
            break;
        case 2:
            nHandleType = Key;
            break;
        case 3:
            nHandleType = Provider;
            break;
        default:
            dwHandle = 0;
        }
    }

    if (Undefined != nHandleType)
    {
        *pnHandleType = nHandleType;
        *phHandle = (LONG)dwHandle;
        tclCmd.NextArgument();
    }
    else if (!fMandatory)
    {
        *pnHandleType = Undefined;
        *phHandle = 0;
    }
    else
        throw tclCmd.BadSyntax();
    return;
}


/*++

ReturnHandle:

    This routine formats a handle and type into a string.

Arguments:

    tclCmd supplies the tcl Command processor object.

    hHandle supplies the handle value.

    nHandleType supplies the handle type.

Return Value:

    A String representation of the handle.

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 5/24/1998

--*/

static void
ReturnHandle(
    CTclCommand &tclCmd,
    LONG_PTR hHandle,
    HandleType nHandleType)
{
    static const LPCTSTR rgszTags[]
        = { NULL, TEXT("Prov"), TEXT("Key"), TEXT("Hash")};
    TCHAR szHandle[24];  // Seems enough for 0x0000000000000000Prov

    sprintf(szHandle, "0x%p%s", hHandle, rgszTags[nHandleType]);
    Tcl_AppendResult(tclCmd, szHandle, NULL);
}


/*++

MyEnumProviders:

    This routine provides a list of providers, akin to CryptEnumProviders.

Arguments:

    dwIndex - Index of the next provider to be enumerated.

    pdwReserved - Reserved for future use and must be NULL.

    dwFlags - Reserved for future use and must always be zero.

    pdwProvType - Address of the DWORD value designating the type of the
        enumerated provider.

    pszProvName - Pointer to a buffer that receives the data from the
        enumerated provider. This is a string including the terminating NULL
        character.  This parameter can be NULL to set the size of the name for
        memory allocation purposes.

    pcbProvName - Pointer to a DWORD specifying the size, in bytes, of the
        buffer pointed to by the pszProvName parameter. When the function
        returns, the DWORD contains the number of bytes stored in the buffer.

Return Value:

    TRUE - Success
    FALSE - An error occurred.  See GetLastError.

Remarks:

    This is here only for use on pre-Win2k systems.

Author:

    Doug Barlow (dbarlow) 4/16/1999

--*/

static BOOL WINAPI
MyEnumProviders(
    DWORD dwIndex,        // in
    DWORD *pdwReserved,   // in
    DWORD dwFlags,        // in
    DWORD *pdwProvType,   // out
    LPTSTR pszProvName,   // out
    DWORD *pcbProvName)   // in/out
{
    static TCHAR szKey[MAX_PATH];
    LONG nSts;
    HKEY hCrypt = NULL;
    FILETIME ft;
    DWORD dwLen;

    if (0 != dwFlags)
    {
        SetLastError(NTE_BAD_FLAGS);
        goto ErrorExit;
    }

    nSts = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider"),
                0,
                KEY_ENUMERATE_SUB_KEYS,
                &hCrypt);
    if (ERROR_SUCCESS != nSts)
    {
        SetLastError(NTE_FAIL);
        goto ErrorExit;
    }

    dwLen = sizeof(szKey) / sizeof(TCHAR);
    nSts = RegEnumKeyEx(
                hCrypt,
                dwIndex,
                szKey,
                &dwLen,
                NULL,
                NULL,
                NULL,
                &ft);
    if (ERROR_SUCCESS != nSts)
    {
        SetLastError(nSts);
        goto ErrorExit;
    }

    nSts = RegCloseKey(hCrypt);
    hCrypt = NULL;
    if (ERROR_SUCCESS != nSts)
    {
        SetLastError(NTE_FAIL);
        goto ErrorExit;
    }

    dwLen += sizeof(TCHAR);
    if (NULL == pszProvName)
        *pcbProvName = dwLen;
    else if (*pcbProvName < dwLen)
    {
        *pcbProvName = dwLen;
        SetLastError(ERROR_MORE_DATA);
        goto ErrorExit;
    }
    else
    {
        *pcbProvName = dwLen;
        lstrcpy(pszProvName, szKey);
    }

    return TRUE;

ErrorExit:
    if (NULL != hCrypt)
        RegCloseKey(hCrypt);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\tclcrypt\tclhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tclhelp.h
//
//--------------------------------------------------------------------------

#include <tcl.h>
// #include "tcldllUtil.h"
#if 15 != _ANSI_ARGS_(15)
#error Missing argument definitions
#endif

typedef enum {
    format_undefined,
    format_text,
    format_hexidecimal,
    format_file,
    format_octal,
    format_binary,
    format_decimal,
    format_empty
} formatType;

extern int
commonParams(
    Tcl_Interp *interp,
    int argc,
    char *argv[],
    DWORD *cmdIndex,
    formatType *inFormat,
    formatType *outFormat);

extern int
inParam(
    Tcl_Interp *interp,
    BYTE **output,
    BYTE *length,
    char *input,
    formatType format);

extern int
setResult(
    Tcl_Interp *interp,
    BYTE *aResult,
    BYTE aResultLen,
    formatType outFormat);

extern BOOL
ParamCount(
    Tcl_Interp *interp,
    DWORD argc,
    DWORD cmdIndex,
    DWORD dwCount);

extern void
badSyntax(
    Tcl_Interp *interp,
    char *argv[],
    DWORD cmdIndex);

extern void
cardError(
    Tcl_Interp *interp,
    DWORD sc_status,
    BYTE classId);

extern void
SetMultiResult(
    Tcl_Interp *interp,
    LPTSTR mszResult);

extern LPWSTR
Unicode(
    LPCSTR sz);

extern char
    outfile[FILENAME_MAX];
static const DWORD dwUndefined = (DWORD)(-1);

extern char *
ErrorString(
    long theError);

extern void
FreeErrorString(
    void);

extern int
poption(
    const char *opt,
    ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\tclcrypt\tclrdcmd.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    TclRdCmd

Abstract:

    This module provides the implementation for the Tcl command line reader.

Author:

    Doug Barlow (dbarlow) 3/14/1998

Environment:

    Win32, C++ w/ exceptions, Tcl

Notes:

    ?Notes?

--*/

// #ifndef WIN32_LEAN_AND_MEAN
// #define WIN32_LEAN_AND_MEAN
// #endif
// #include <windows.h>                    //  All the Windows definitions.
#include <afx.h>
#include <tchar.h>
extern "C"
{
    #include "tclHelp.h"
}
#include "tclRdCmd.h"                   // Our definitions


//
//==============================================================================
//
//  CTclCommand
//

/*++

CONSTRUCTOR:

    These are the constructors for a CTclCommand object.

Arguments:

    Per the standard Tcl command calling sequence, the parameters are:

    interp - The Tcl interpreter against which to report errors.

    argc - The number of command line arguments

    argv - The vector of command line arguments

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

CTclCommand::CTclCommand(
    void)
{
    Constructor();
}

CTclCommand::CTclCommand(
    Tcl_Interp *interp,
    int argc,
    char *argv[])
{
    Constructor();
    Initialize(interp, argc, argv);
}


/*++

Constructor:

    This is a constructor helper routine.  All constructors call this routine
    first to be sure internal properties are initialized.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

void
CTclCommand::Constructor(
    void)
{
    m_fErrorDeclared = FALSE;
    m_pInterp = NULL;
    m_dwArgCount = 0;
    m_dwArgIndex = 0;
    m_rgszArgs = NULL;
}


/*++

DESTRUCTOR:

    This is the destructor for the object.  It cleans up any outstanding
    resources.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

CTclCommand::~CTclCommand()
{
}


/*++

Initialize:

    This method initializes the object with the standard Tcl command parameters.

Arguments:

    Per the standard Tcl command calling sequence, the parameters are:

    interp - The Tcl interpreter against which to report errors.

    argc - The number of command line arguments

    argv - The vector of command line arguments

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

void
CTclCommand::Initialize(
    Tcl_Interp *interp,
    int argc,
    char *argv[])
{
    if (NULL != m_pInterp)
        throw (DWORD)ERROR_ALREADY_INITIALIZED;
    m_pInterp = interp;
    m_dwArgCount = (DWORD)argc;
    m_rgszArgs = argv;
    m_dwArgIndex = 1;
}


/*++

SetError:

    These routines establish an error message for the command, if one doesn't
    exist already.

Arguments:

    dwError supplies an error code who's message should be reported.

    szMessage supplies a text string to be reported.

    szMsg<n> supplies a list of text strings to be reported.  The last
        parameter must be NULL to terminate the list.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

void
CTclCommand::SetError(
    DWORD dwError)
{
    SetError(ErrorString(dwError), (LPCTSTR)NULL);
}

void
CTclCommand::SetError(
    LPCTSTR szMessage,
    DWORD dwError)
{
    SetError(szMessage, ErrorString(dwError), NULL);
}

void
CTclCommand::SetError(
    LPCTSTR szMsg1,
    ...)
{
    va_list vaArgs;
    LPCTSTR szMsg;

    va_start(vaArgs, szMsg1);
    szMsg = szMsg1;
    if (!m_fErrorDeclared)
    {
        Tcl_ResetResult(m_pInterp);
        while (NULL != szMsg)
        {
            Tcl_AppendResult(m_pInterp, szMsg, NULL);
            szMsg = va_arg(vaArgs, LPCTSTR);
        }
        m_fErrorDeclared = TRUE;
    }
    va_end(vaArgs);
}


/*++

TclError:

    This routine is called to note that Tcl has already filled in the error
    reason, and we should just pass it along.

Arguments:

    None

Return Value:

    TCL_ERROR (suitable for throwing)

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

DWORD
CTclCommand::TclError(
    void)
{
    m_fErrorDeclared = TRUE;
    return TCL_ERROR;
}


/*++

Keyword:

    This method converts a list of keywords into an integer identifying the
    keyword.  The list of keywords must be NULL-terminated (the last parameter
    must be NULL).

Arguments:

    szKeyword - supplies one or more keywords to be translated into an integer.
        The last keyword must be NULL to terminate the list.

Return Value:

    0  - None of the keywords matched the next input argument.
    -1 - More than one of the keywords matched the next input argument.
    n > 0 - Keyword 'n' (counting from one) matched the next input argument.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

LONG
CTclCommand::Keyword(
    IN LPCTSTR szKeyword, ...)
{
    va_list vaArgs;
    LPCTSTR szKey;
    CString szArg;
    DWORD dwLength;
    DWORD dwReturn = 0;
    DWORD dwCount = 0;

    PeekArgument(szArg);
    dwLength = szArg.GetLength();
    if (0 == dwLength)
        return 0;       // Empty strings don't match anything.

    va_start(vaArgs, szKeyword);
    szKey = szKeyword;

    while (NULL != szKey)
    {
        dwCount += 1;
        if (0 == _tcsncicmp(szArg, szKey, dwLength))
        {
            if (0 != dwReturn)
            {
                dwReturn = -1;
                break;
            }
            dwReturn = dwCount;
        }
        szKey = va_arg(vaArgs, LPCTSTR);
    }
    va_end(vaArgs);
    if (0 < dwReturn)
        NextArgument();
    return dwReturn;
}


/*++

GetArgument:

    This method obtains the specified argument in the command.

Arguments:

    szToken receives the specified argument of the command.

Return Value:

    None

Throws:

    TCL_ERROR - if there aren't enough arguments on the command line,
        preprepping the error string.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

void
CTclCommand::GetArgument(
    DWORD dwArgId,
    CString &szToken)
{
    if (dwArgId >= m_dwArgCount)
    {
        CString szCommand;

        GetArgument(0, szCommand);
        SetError(
            TEXT("Insufficient parameters to the '"),
            szCommand,
            TEXT("' command."),
            NULL);
        throw (DWORD)TCL_ERROR;
    }
    szToken = m_rgszArgs[dwArgId];
}


/*++

PeekArgument:

    This method obtains the next argument in the command without moving on to
    the next argument.

Arguments:

    szToken receives the next argument of the command.

Return Value:

    None

Throws:

    TCL_ERROR - if there are no more arguments on the command line, preprepping
        the error string.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

void
CTclCommand::PeekArgument(
    CString &szToken)
{
    GetArgument(m_dwArgIndex, szToken);
}


/*++

NextArgument:

    This method moves forward to the next argument.

Arguments:

    szToken receives the next argument of the command.

Return Value:

    None

Throws:

    TCL_ERROR - if there are no more arguments on the command line, preprepping
        the error string.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

void
CTclCommand::NextArgument(
    void)
{
    m_dwArgIndex += 1;
}

void
CTclCommand::NextArgument(
    CString &szToken)
{
    PeekArgument(szToken);
    NextArgument();
}


/*++

IsMoreArguments:

    This method obtains whether or not there are additional parameters to be
    processed.  It returns TRUE while parameters remain, and returns FALSE if
    none remain.  A minimum number of parameters may be specified, in which case
    it returns whether or not there are at least that number of parameters
    remaining.

Arguments:

    dwCount - If supplied, this provides a way to ask if 'dwCount' parameters
        remain.

Return Value:

    TRUE - At least dwCount parameters remain to be processed
    FALSE - less that dwCount parameters remain to be processed.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

BOOL
CTclCommand::IsMoreArguments(
    DWORD dwCount)
const
{
    return m_dwArgIndex + dwCount <= m_dwArgCount;
}

/*++

NoMoreArguments:

    This method asserts that there are no more arguments in the command line.  If there are,
    a BadSyntax error is thrown.

Arguments:

    None

Return Value:

    None

Throws:

    TCL_ERROR as a DWORD if more arguments remain on the command line

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

void
CTclCommand::NoMoreArguments(
    void)
{
    if (m_dwArgIndex < m_dwArgCount)
        throw BadSyntax();
}


/*++

BadSyntax:

    This method declares a syntax error.  It does not throw an error, but
    returns a DWORD suitable for throwing.

Arguments:

    szParam - Supplies the syntactic offender string, or NULL.

Return Value:

    A DWORD error code suitable for throwing.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

DWORD
CTclCommand::BadSyntax(
    LPCTSTR szOffender)
{
    DWORD dwIndex;

    if (NULL == szOffender)
        szOffender = m_rgszArgs[m_dwArgIndex];
    Tcl_ResetResult(m_pInterp);
    Tcl_AppendResult(
        m_pInterp,
        "Invalid option '",
        szOffender,
        "' to the '",
        NULL);
    for (dwIndex = 0; dwIndex < m_dwArgIndex; dwIndex += 1)
        Tcl_AppendResult(m_pInterp, m_rgszArgs[dwIndex], " ", NULL);
    Tcl_AppendResult(m_pInterp, "...' command.", NULL);
    m_fErrorDeclared = TRUE;
    return TCL_ERROR;
}


/*++

Value:

    This method extracts a LONG value from the argument list.

Arguments:

    lDefault supplies the default value.

Return Value:

    The value extracted.

Throws:

    If no default value is suppled and the next parameter is not an integer,
    TCL_ERROR is thrown as a DWORD.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

LONG
CTclCommand::Value(
    LONG lDefault)
{
    LONG lReturn;
    CString szValue;

    PeekArgument(szValue);
    if (TCL_OK == Tcl_ExprLong(m_pInterp, SZ(szValue), &lReturn))
        NextArgument();
    else
    {
        Tcl_ResetResult(m_pInterp);
        lReturn = lDefault;
    }
    return lReturn;
}

LONG
CTclCommand::Value(
    void)
{
    LONG lReturn;
    CString szValue;

    PeekArgument(szValue);
    if (TCL_OK != Tcl_ExprLong(m_pInterp, SZ(szValue), &lReturn))
        throw (DWORD)TCL_ERROR;
    NextArgument();
    return lReturn;
}


/*++

MapValue:

    This method converts text into a value, given a ValueMap structure.  The
    class member automatically extracts the keyword.

Arguments:

    rgvmMap supplies the value map array.  The last element's string value
        must be NULL.

    szString supplies the value to be parsed.

    fValueOk supplies a flag indicating whether or not an integral value may be
        supplied instead of a symbolic token.

Return Value:

    The value resulting from the map.

Throws:

    If no default value is suppled and the next parameter is not an integer,
    TCL_ERROR is thrown as a DWORD.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

LONG
CTclCommand::MapValue(
    const ValueMap *rgvmMap,
    BOOL fValueOk)
{
    CString szValue;
    LONG lReturn;

    PeekArgument(szValue);
    lReturn = MapValue(rgvmMap, szValue, fValueOk);
    NextArgument();
    return lReturn;
}

LONG
CTclCommand::MapValue(
    const ValueMap *rgvmMap,
    CString &szValue,
    BOOL fValueOk)
{
    LONG lReturn;
    LONG lMap = -1;
    DWORD dwIndex, dwLength;

    if (fValueOk && (TCL_OK != Tcl_ExprLong(m_pInterp, SZ(szValue), &lReturn)))
    {
        Tcl_ResetResult(m_pInterp);
        dwLength = szValue.GetLength();
        if (0 == dwLength)
            throw BadSyntax();
        for (dwIndex = 0; NULL != rgvmMap[dwIndex].szValue; dwIndex += 1)
        {
            if (0 == _tcsncicmp(
                        szValue,
                        rgvmMap[dwIndex].szValue,
                        dwLength))
            {
                if (-1 != lMap)
                    throw BadSyntax();
                lMap = (LONG)dwIndex;
                if (0 == rgvmMap[dwIndex].szValue[dwLength])
                    break;
            }
        }
        if (-1 == lMap)
            throw BadSyntax(szValue);
        lReturn = rgvmMap[lMap].lValue;
    }
    return lReturn;
}

/*++

MapFlags:

    This method converts a text list into a single value, given a ValueMap
    structure.  The list is taken as an array of flags.  The corresponding
    values are OR'ed together to obtain the return value.
    The class member automatically extracts the keyword.

Arguments:

    rgvmMap supplies the value map array.  The last element's string value
        must be NULL.

    fValueOk supplies a flag indicating whether or not an integral value may be
        supplied instead of a symbolic token.

Return Value:

    The value resulting from the map.

Throws:

    If no default value is suppled and the next parameter is not an integer,
    TCL_ERROR is thrown as a DWORD.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

DWORD
CTclCommand::MapFlags(
    const ValueMap *rgvmMap,
    BOOL fValueOk)
{
    CArgArray rgFlags(*this);
    CString szFlags;
    CString szFlag;
    DWORD dwFlags = 0;
    DWORD dwIndex = 0;

    NextArgument(szFlags);
    rgFlags.LoadList(szFlags);
    for (dwIndex = rgFlags.Count(); dwIndex > 0;)
    {
        rgFlags.Fetch(--dwIndex, szFlag);
        dwFlags |= MapValue(rgvmMap, szFlag);
    }
    return dwFlags;
}


/*++

OutputStyle:

    This method parses the common binary data output flags and prepares to
    properly render it on output.

Arguments:

    outData supplies the CRenderableData object with information on how to
        render its internal binary data.

Return Value:

    None

Throws:

    Errors are thrown as exceptions

Author:

    Doug Barlow (dbarlow) 5/5/1998

--*/

void
CTclCommand::OutputStyle(
    CRenderableData &outData)
{
    outData.SetDisplayType(CRenderableData::Undefined);
    if (IsMoreArguments())
    {
        switch (Keyword(TEXT("/OUTPUT"),        TEXT("-OUTPUT"),
            TEXT("/HEXIDECIMAL"),   TEXT("-HEXIDECIMAL"),
            TEXT("/TEXT"),          TEXT("-TEXT"),
            TEXT("/ANSI"),          TEXT("-ANSI"),
            TEXT("/UNICODE"),       TEXT("-UNICODE"),
            TEXT("/FILE"),          TEXT("-FILE"),
            NULL))
        {
        case 1:     // /OUTPUT
        case 2:     // -OUTPUT
            switch (Keyword(TEXT("HEXIDECIMAL"),    TEXT("TEXT"),
                TEXT("ANSI"),           TEXT("UNICODE"),
                TEXT("FILE"), NULL))
            {
            case 1:     // HEX
                outData.SetDisplayType(CRenderableData::Hexidecimal);
                break;
            case 2:     // TEXT
                outData.SetDisplayType(CRenderableData::Text);
                break;
            case 3:     // ANSI
                outData.SetDisplayType(CRenderableData::Ansi);
                break;
            case 4:     // UNICODE
                outData.SetDisplayType(CRenderableData::Unicode);
                break;
            case 5:     // FILE
                outData.SetDisplayType(CRenderableData::File);
                NextArgument(outData.m_szFile);
                break;
            default:
                throw BadSyntax();
            }
            break;
            case 3:     // /HEX
            case 4:     // -HEX
                outData.SetDisplayType(CRenderableData::Hexidecimal);
                break;
            case 5:     // /TEXT
            case 6:     // -TEXT
                outData.SetDisplayType(CRenderableData::Text);
                break;
            case 7:     // /ANSI
            case 8:     // -ANSI
                outData.SetDisplayType(CRenderableData::Ansi);
                break;
            case 9:     // /UNICODE
            case 10:    // -UNICODE
                outData.SetDisplayType(CRenderableData::Unicode);
                break;
            case 11:    // /FILE <name>
            case 12:    // -FILE <name>
                outData.SetDisplayType(CRenderableData::File);
                NextArgument(outData.m_szFile);
                break;
            default:
                ;   // No action
        }
    }
}


/*++

InputStyle:

    This method parses the common binary data input flags and prepares to
    properly interpret input data.

Arguments:

    inData supplies the CRenderableData object with information on how to
        interpret binary data.

Return Value:

    None

Throws:

    Errors are thrown as exceptions

Author:

    Doug Barlow (dbarlow) 5/5/1998

--*/

void
CTclCommand::InputStyle(
    CRenderableData &inData)
{
    inData.SetDisplayType(CRenderableData::Undefined);
    switch (Keyword(TEXT("/INPUT"),         TEXT("-INPUT"),
                    TEXT("/HEXIDECIMAL"),   TEXT("-HEXIDECIMAL"),
                    TEXT("/TEXT"),          TEXT("-TEXT"),
                    TEXT("/ANSI"),          TEXT("-ANSI"),
                    TEXT("/UNICODE"),       TEXT("-UNICODE"),
                    TEXT("/FILE"),          TEXT("-FILE"),
                    NULL))
    {
    case 1:     // /INPUT
    case 2:     // -INPUT
        switch (Keyword(TEXT("HEXIDECIMAL"),    TEXT("TEXT"),
                        TEXT("ANSI"),           TEXT("UNICODE"),
                        TEXT("FILE"), NULL))
        {
        case 1:     // HEX
            inData.SetDisplayType(CRenderableData::Hexidecimal);
            break;
        case 2:     // TEXT
            inData.SetDisplayType(CRenderableData::Text);
            break;
        case 3:     // ANSI
            inData.SetDisplayType(CRenderableData::Ansi);
            break;
        case 4:     // UNICODE
            inData.SetDisplayType(CRenderableData::Unicode);
            break;
        case 5:     // FILE
            inData.SetDisplayType(CRenderableData::File);
            break;
        default:
            throw BadSyntax();
        }
        break;
    case 3:     // /HEX
    case 4:     // -HEX
        inData.SetDisplayType(CRenderableData::Hexidecimal);
        break;
    case 5:     // /TEXT
    case 6:     // -TEXT
        inData.SetDisplayType(CRenderableData::Text);
        break;
    case 7:     // /ANSI
    case 8:     // -ANSI
        inData.SetDisplayType(CRenderableData::Ansi);
        break;
    case 9:     // /UNICODE
    case 10:    // -UNICODE
        inData.SetDisplayType(CRenderableData::Unicode);
        break;
    case 11:    // /FILE <name>
    case 12:    // -FILE <name>
        inData.SetDisplayType(CRenderableData::File);
        break;
    default:
        ;   // No action
    }
}


/*++

IOStyle:

    This method parses the common binary data input and output flags, and
    prepares to properly interpret and render data.

Arguments:

    outData supplies the CRenderableData object with information on how to
        render its internal binary data.

Return Value:

    None

Throws:

    Errors are thrown as exceptions

Author:

    Doug Barlow (dbarlow) 5/5/1998

--*/

void
CTclCommand::IOStyle(
    CRenderableData &inData,
    CRenderableData &outData)
{
    BOOL fInput, fOutput;

    outData.SetDisplayType(CRenderableData::Undefined);
    inData.SetDisplayType(CRenderableData::Undefined);
    fInput = fOutput = FALSE;
    do
    {
        switch (Keyword(TEXT("/OUTPUT"),        TEXT("-OUTPUT"),
                        TEXT("/INPUT"),         TEXT("-INPUT"),
                        NULL))
        {
        case 1:     // /OUTPUT
        case 2:     // -OUTPUT
            if (fOutput)
                throw BadSyntax();
            switch (Keyword(TEXT("HEXIDECIMAL"),    TEXT("TEXT"),
                            TEXT("ANSI"),           TEXT("UNICODE"),
                            TEXT("FILE"), NULL))
            {
            case 1:     // HEX
                outData.SetDisplayType(CRenderableData::Hexidecimal);
                break;
            case 2:     // TEXT
                outData.SetDisplayType(CRenderableData::Text);
                break;
            case 3:     // ANSI
                outData.SetDisplayType(CRenderableData::Ansi);
                break;
            case 4:     // UNICODE
                outData.SetDisplayType(CRenderableData::Unicode);
                break;
            case 5:     // FILE
                outData.SetDisplayType(CRenderableData::File);
                NextArgument(outData.m_szFile);
                break;
            default:
                throw BadSyntax();
            }
            fOutput = TRUE;
            break;
        case 3:     // /INPUT
        case 4:     // -INPUT
            if (fInput)
                throw BadSyntax();
            switch (Keyword(TEXT("HEXIDECIMAL"),    TEXT("TEXT"),
                            TEXT("ANSI"),           TEXT("UNICODE"),
                            TEXT("FILE"), NULL))
            {
            case 1:     // HEX
                inData.SetDisplayType(CRenderableData::Hexidecimal);
                break;
            case 2:     // TEXT
                inData.SetDisplayType(CRenderableData::Text);
                break;
            case 3:     // ANSI
                inData.SetDisplayType(CRenderableData::Ansi);
                break;
            case 4:     // UNICODE
                inData.SetDisplayType(CRenderableData::Unicode);
                break;
            case 5:     // FILE
                inData.SetDisplayType(CRenderableData::File);
                break;
            default:
                throw BadSyntax();
            }
            fInput = TRUE;
            break;
        default:
            fInput = fOutput = TRUE;
        }
    } while (!fInput || !fOutput);
}


/*++

Render:

    This method renders data from a CRenderableData object into the Tcl output
    buffer.

Arguments:

    outData supplies the CRenderableData object with information on how to
        render its internal binary data.

Return Value:

    None

Throws:

    Errors are thrown as exceptions

Author:

    Doug Barlow (dbarlow) 5/6/1998

--*/

void
CTclCommand::Render(
    CRenderableData &outData)
{
    try
    {
        Tcl_AppendResult(*this, outData.RenderData(), NULL);
    }
    catch (DWORD dwError)
    {
        SetError(
            TEXT("Failed to render output data: "),
            dwError);
        throw (DWORD)TCL_ERROR;
    }
}


/*++

ReadData:

    This method reads input data into a CRenderableData object from the Tcl
    input stream.

Arguments:

    inData supplies the CRenderableData object with information on how to
        read the next parameter into its internal binary data.

Return Value:

    None

Throws:

    Errors are thrown as exceptions

Author:

    Doug Barlow (dbarlow) 5/14/1998

--*/

void
CTclCommand::ReadData(
    CRenderableData &inData)
{
    CString szValue;

    try
    {
        PeekArgument(szValue);
        inData.LoadData(szValue);
        NextArgument();
    }
    catch (...)
    {
        throw BadSyntax();
    }
}


//
//==============================================================================
//
//  CRenderableData
//

/*++

CONSTRUCTOR:

    This is the constructor for a CRenderableData object.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 5/5/1998

--*/

CRenderableData::CRenderableData(
    void)
:   m_bfData(),
    m_szString(),
    m_szFile()
{
    m_dwType = Undefined;
}


/*++

DESTRUCTOR:

    This is the destructor for a CRenderableData object.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 5/5/1998

--*/

CRenderableData::~CRenderableData()
{
}


/*++

LoadData:

    This method loads data into the style buffer.  There are two forms, loading
    from a string, and direct binary loading.

Arguments:

    szData supplies the data to be loaded, in it's string format.

    dwType supplies the type of string data being loaded.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 5/5/1998

--*/

void
CRenderableData::LoadData(
    LPCTSTR szData,
    DisplayType dwType)
{
    if (Undefined == dwType)
        dwType = m_dwType;
    switch (dwType)
    {
    case Text:
        m_bfData.Set((LPCBYTE)szData, (lstrlen(szData) + 1) * sizeof(TCHAR));
        break;
    case Ansi:
    case Unicode:
        throw (DWORD)SCARD_F_INTERNAL_ERROR;
        break;
    case Undefined:     // Default output
    case Hexidecimal:
    {
        DWORD dwHex, dwLength, dwIndex;
        BYTE bHex;

        m_bfData.Reset();
        dwLength = lstrlen(szData);
        if (dwLength != _tcsspn(szData, TEXT("0123456789ABCDEFabcdef")))
            throw (DWORD)SCARD_E_INVALID_VALUE;
        m_bfData.Resize(dwLength / 2);
        for (dwIndex = 0; dwIndex < dwLength; dwIndex += 2)
        {
            _stscanf(&szData[dwIndex], TEXT(" %2lx"), &dwHex);
            bHex = (BYTE)dwHex;
            *m_bfData.Access(dwIndex / 2) = bHex;
        }
        break;
    }
    case File:
    {
        HANDLE hFile = INVALID_HANDLE_VALUE;
        BOOL fSts;
        DWORD dwLen;

        try
        {
            hFile = CreateFile(
                        szData,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
            if (INVALID_HANDLE_VALUE == hFile)
                throw GetLastError();
            m_bfData.Presize(GetFileSize(hFile, NULL));
            fSts = ReadFile(
                        hFile,
                        m_bfData.Access(),
                        m_bfData.Space(),
                        &dwLen,
                        NULL);
            if (!fSts)
                throw GetLastError();
            m_bfData.Resize(dwLen, TRUE);
            fSts = CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;
            if (!fSts)
                throw GetLastError();
        }
        catch (...)
        {
            if (INVALID_HANDLE_VALUE != hFile)
            {
                fSts = CloseHandle(hFile);
                ASSERT(fSts);
            }
            throw;
        }
        break;
    }
    default:
        throw (DWORD)SCARD_F_INTERNAL_ERROR;
    }
}

/*++

RenderData:

    This method converts the raw binary data stored in the stype to the
    provided display type.

Arguments:

    dwType supplies the type of string data to be returned.

Return Value:

    The rendered string

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 5/5/1998

--*/

LPCTSTR
CRenderableData::RenderData(
    DisplayType dwType)
{
    if (Undefined == dwType)
        dwType = m_dwType;
    switch (dwType)
    {
    case Text:
        m_bfData.Append((LPBYTE)TEXT("\000"), sizeof(TCHAR));
        m_szString = (LPCTSTR)m_bfData.Access();
        break;
    case Ansi:
        m_bfData.Append((LPBYTE)"\000", sizeof(CHAR));
        m_szString = (LPCSTR)m_bfData.Access();
        break;
    case Unicode:
        m_bfData.Append((LPBYTE)L"\000", sizeof(WCHAR));
        m_szString = (LPCWSTR)m_bfData.Access();
        break;
    case Undefined:     // Default output
    case Hexidecimal:
    {
        DWORD dwIndex;
        DWORD dwLength = m_bfData.Length();
        CBuffer bfString((dwLength * 2 + 1) * sizeof(TCHAR));

        for (dwIndex = 0; dwIndex < dwLength; dwIndex += 1)
            wsprintf(
                (LPTSTR)bfString.Access(dwIndex * 2 * sizeof(TCHAR)),
                TEXT("%02x"),
                m_bfData[dwIndex]);
        *(LPTSTR)bfString.Access(dwLength * 2 * sizeof(TCHAR)) = TEXT('\000');
        m_szString = (LPCTSTR)bfString.Access();
        break;
    }
    case File:
    {
        HANDLE hFile = INVALID_HANDLE_VALUE;
        BOOL fSts;
        DWORD dwLen;

        m_szString.Empty();
        try
        {
            if (m_szFile.IsEmpty())
                throw (DWORD)ERROR_INVALID_NAME;
            hFile = CreateFile(
                        m_szFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
            if (INVALID_HANDLE_VALUE == hFile)
                throw GetLastError();
            fSts = WriteFile(
                        hFile,
                        m_bfData.Access(),
                        m_bfData.Length(),
                        &dwLen,
                        NULL);
            if (!fSts)
                throw GetLastError();
            ASSERT(dwLen == m_bfData.Length());
            fSts = CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;
            if (!fSts)
                throw GetLastError();
        }
        catch (...)
        {
            if (INVALID_HANDLE_VALUE != hFile)
            {
                fSts = CloseHandle(hFile);
                ASSERT(fSts);
            }
            throw;
        }
        break;
    }
    default:
        throw (DWORD)SCARD_F_INTERNAL_ERROR;
    }
    return m_szString;
}


//
//==============================================================================
//
//  CArgArray
//

/*++

CONSTRUCTOR:

    This method is the default constructor for a CArgArray.

Arguments:

    None

Author:

    Doug Barlow (dbarlow) 5/14/1998

--*/

CArgArray::CArgArray(
    CTclCommand &tclCmd)
:   m_rgszElements()
{
    m_pTclCmd = &tclCmd;
    m_pszMemory = NULL;
    m_dwElements = 0;
}


/*++

DESTRUCTOR:

    This is the destructor method for the CArgArray.

Remarks:

    The string elements are automatically freed.

Author:

    Doug Barlow (dbarlow) 5/14/1998

--*/

CArgArray::~CArgArray()
{
    if (NULL != m_pszMemory)
        ckfree((LPSTR)m_pszMemory);
}


/*++

LoadList:

    Load a potential list of arguments into the argument list, so that they may
    be accessed individually.

Arguments:

    szList supplies the Tcl Text string that contains the individual arguments.

Return Value:

    None

Throws:

    Errors are thrown as DWORD exceptions.

Author:

    Doug Barlow (dbarlow) 5/14/1998

--*/

void
CArgArray::LoadList(
    LPCSTR szList)
{
    int nElements;
    DWORD dwIndex;

    Tcl_SplitList(*m_pTclCmd, (LPSTR)szList, &nElements, &m_pszMemory);
    m_dwElements = (DWORD)nElements;
    for (dwIndex = 0; dwIndex < m_dwElements; dwIndex += 1)
        m_rgszElements.Add(m_pszMemory[dwIndex]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\tclcrypt\tcldllutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tcldllutil.h
//
//--------------------------------------------------------------------------

#ifndef _TCLDLLUTIL_H_
#define _TCLDLLUTIL_H_
#include <stdlib.h>
#include <tcl.h>

extern int
toWin32List(                            /*  Convert a Tcl List to a Win32 multi-string.  */
    Tcl_Interp *interp,
    char *tclList,
    unsigned int *winListSize,
    char **winList);

extern int
fromWin32List(                          /*  Convert a Win32 multi-string to a list.  */
    Tcl_Interp *interp,
    char *winList);


/*
 *  Local symbols                                                             %locals%
 *
 *  Local Symbol Name                   Description
    -----------------                   --------------------------------------------*/
static char
    **TclEx_tmpArray                    /*  Storage for expanding string arrays.  */
        = NULL;
static unsigned int
    TclEx_tmpArraySize                  /*  How big we are so far.  */
        = 0;
static char
    *TclEx_tmpBuffer                    /*  Storage for expanding string buffers.  */
        = NULL;
static unsigned int
    TclEx_tmpBufferSize                 /*  How big we are so far.  */
        = 0;
static const char
    Space[]                             /*  A string of one space.  */
        = " ",
    Quote[]                             /*  A string of a quote symbol.  */
        = "\"";


/*
 *  Local routines                                                        %prototypes%
 *
 *  Local Function Name                 Description
    -------------------                 --------------------------------------------*/


/*
 *  Macro definitions                                                         %macros%
 *
 *      Macro Name                      Description
        ----------                      --------------------------------------------*/
//
//  Temporary buffer and array management.
//

#define TMP_BUFFER TclEx_tmpBuffer
#define TMP_BUFFER_SIZE TclEx_tmpBufferSize
#define TMP_ARRAY TclEx_tmpArray
#define TMP_ARRAY_SIZE TclEx_tmpArraySize

#ifdef _DEBUG

//
//  Get some temporary buffer.
#define NEED_TMP_BUFFER(sz) \
    if (0 != TclEx_tmpBufferSize) { \
        (void)fprintf(stderr, "TMP_BUFFER locked.\n"); \
        exit(1); } \
    else { \
        TclEx_tmpBuffer = (char *)ckalloc(sz); \
        TclEx_tmpBufferSize = (sz); }

//
//      Get more temporary buffer.
#define NEED_MORE_TMP_BUFFER(sz) \
    if (0 == TclEx_tmpBufferSize) { \
        (void)fprintf(stderr, "TMP_BUFFER not locked.\n"); \
        exit(1); } \
    else { if (TclEx_tmpBufferSize < (sz)) { \
            TclEx_tmpBuffer = (char *)ckrealloc(TclEx_tmpBuffer, (sz)); \
            TclEx_tmpBufferSize = (sz); } }

//
//      All done with the temporary buffer.
#define DONE_TMP_BUFFER \
    { if (NULL != TclEx_tmpBuffer) { \
        ckfree(TclEx_tmpBuffer); TclEx_tmpBuffer = NULL; TclEx_tmpBufferSize = 0; }}

//
//      Get a temporary array.
#define NEED_TMP_ARRAY(sz) \
    if (0 != TclEx_tmpArraySize) { \
        (void)fprintf(stderr, "TMP_ARRAY locked.\n"); \
        exit(1); } \
    else { \
        TclEx_tmpArray = (char **)ckalloc((sz) * sizeof(void *)); \
        TclEx_tmpArraySize = (sz); }

//
//      Get more temporary array.
#define NEED_MORE_TMP_ARRAY(sz) \
    if (0 == TclEx_tmpArraySize) { \
        (void)fprintf(stderr, "TMP_ARRAY not locked.\n"); \
        exit(1); } \
    else { if (TclEx_tmpArraySize < (sz)) { \
            TclEx_tmpArray = (char **)ckrealloc((char *)TclEx_tmpArray, (sz) * sizeof(void *)); \
            TclEx_tmpArraySize = (sz); } }

//
//      All done with the temporary array.
#define DONE_TMP_ARRAY \
    { ckfree((char *)TclEx_tmpArray); TclEx_tmpArray = NULL; TclEx_tmpArraySize = 0; }

#define TMP_RETURN TCL_VOLATILE

#else

//
//  Get some temporary buffer.
#define NEED_TMP_BUFFER(sz) \
    if (TclEx_tmpBufferSize < (sz)) { \
        if (0 == TclEx_tmpBufferSize) \
                { TclEx_tmpBuffer = (char *)ckalloc(sz); } \
        else \
            { TclEx_tmpBuffer = (char *)ckrealloc(TclEx_tmpBuffer, (sz)); } \
        TclEx_tmpBufferSize = (sz); }

//
//      Get more temporary buffer.
#define NEED_MORE_TMP_BUFFER(sz) \
    if (TclEx_tmpBufferSize < (sz)) { \
        TclEx_tmpBuffer = (char *)ckrealloc((char *)TclEx_tmpBuffer, (sz)); \
        TclEx_tmpBufferSize = (sz); }

//
//      All done with the temporary buffer.
#define DONE_TMP_BUFFER

//
//      Get a temporary array.
#define NEED_TMP_ARRAY(sz) \
    if (TclEx_tmpArraySize < (sz)) { \
        if (0 != TclEx_tmpArraySize) \
            ckfree(TclEx_tmpArray); \
        TclEx_tmpArray = (char **)ckalloc((sz) * sizeof(void *)); \
        TclEx_tmpArraySize = (sz); }

//
//      Get more temporary array.
#define NEED_MORE_TMP_ARRAY(sz) \
    if (TclEx_tmpArraySize < (sz)) { \
        TclEx_tmpArray = (char **)ckrealloc(TclEx_tmpArray, (sz) * sizeof(void *)); \
        TclEx_tmpArraySize = (sz); }

//
//      All done with the temporary array.
#define DONE_TMP_ARRAY

#define TMP_RETURN TCL_STATIC

#endif
#endif  /*  _TCLDLLUTIL_H_  */
/*  end tcldllUtil.h  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\smartcrd\tools\tclcrypt\tclhelp.c ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    tclHelp

Abstract:

    Routines to simplify Tcl command line parsing.

Author:

    Doug Barlow (dbarlow) 9/16/1997

Environment:

    Tcl for Windows NT.

Notes:

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>                    //  All the Windows definitions.
#ifndef __STDC__
#define __STDC__ 1
#endif
#include "tclhelp.h"
#include <stdio.h>
#include <string.h>
#include <stdarg.h>


char outfile[FILENAME_MAX];


int
commonParams(
    Tcl_Interp *interp,
    int argc,
    char *argv[],
    unsigned long int *cmdIndex,
    formatType *inFormat,
    formatType *outFormat)
{
    if (NULL != inFormat)
        *inFormat = format_hexidecimal;
    if (NULL != outFormat)
    {
        *outFormat = format_hexidecimal;
        outfile[0] = '\000';
    }

    while (*cmdIndex < (unsigned long int)argc)
    {
        switch (poption(argv[(*cmdIndex)++],
                    "-INPUT", "/INPUT", "-OUTPUT", "/OUTPUT", NULL))
        {
        case 1: // -input { text | hexidecimal | file }
        case 2:
            if (NULL == inFormat)
            {
                badSyntax(interp, argv, --(*cmdIndex));
                goto ErrorExit;
            }
            if (*cmdIndex == (unsigned long int)argc)
            {
                Tcl_AppendResult(interp, "Insufficient parameters", NULL);
                goto ErrorExit;
            }
            switch (poption(argv[(*cmdIndex)++],
                    "TEXT", "HEXIDECIMAL", "FILE", NULL))
            {
            case 1:
                *inFormat = format_text;
                break;
            case 2:
                *inFormat = format_hexidecimal;
                break;
            case 3:
                *inFormat = format_file;
                break;
            default:
                Tcl_AppendResult(interp, "Unknown input format", NULL);
                goto ErrorExit;
            }
            break;

        case 3: // -output { text | hexidecimal | file <filename> }
        case 4:
            if (NULL == outFormat)
            {
                badSyntax(interp, argv, --(*cmdIndex));
                goto ErrorExit;
            }
            if (*cmdIndex == (unsigned long int)argc)
            {
                Tcl_AppendResult(interp, "Insufficient parameters", NULL);
                goto ErrorExit;
            }
            switch (poption(argv[(*cmdIndex)++],
                    "TEXT", "HEXIDECIMAL", "FILE", "DROP", NULL))
            {
            case 1:
                *outFormat = format_text;
                break;
            case 2:
                *outFormat = format_hexidecimal;
                break;
            case 3:
                if (*cmdIndex == (unsigned long int)argc)
                {
                    Tcl_AppendResult(interp, "Insufficient parameters", NULL);
                    goto ErrorExit;
                }
                strcpy(outfile, argv[(*cmdIndex)++]);
                *outFormat = format_file;
                break;
            case 4:
                *outFormat = format_empty;
                break;
            default:
                Tcl_AppendResult(interp, "Unknown output format", NULL);
                goto ErrorExit;
            }
            break;

        default:
            *cmdIndex -= 1;
            return TCL_OK;
        }
    }
    return TCL_OK;

ErrorExit:
    return TCL_ERROR;
}


int
setResult(
    Tcl_Interp *interp,
    BYTE *aResult,
    BYTE aResultLen,
    formatType outFormat)
{
    static char
        hexbuf[514];
    DWORD
        index;
    FILE *
        fid
            = NULL;

    switch (outFormat)
    {
    case format_empty:
        break;

    case format_text:
        aResult[aResultLen] = '\000';
        Tcl_AppendResult(interp, aResult, NULL);
        break;

    case format_hexidecimal:
        for (index = 0; index < aResultLen; index += 1)
            sprintf(&hexbuf[index * 2], "%02x", aResult[index]);
        hexbuf[aResultLen * 2] = '\000';
        Tcl_AppendResult(interp, hexbuf, NULL);
        break;

    case format_file:
        if ('\000' == outfile[0])
        {
            Tcl_AppendResult(interp, "Illegal output format", NULL);
            goto ErrorExit;
        }
        fid = fopen(outfile, "wb");
        index = fwrite(aResult, sizeof(BYTE), aResultLen, fid);
        if (index != aResultLen)
        {
            Tcl_AppendResult(interp, ErrorString(GetLastError()), NULL);
            goto ErrorExit;
        }
        fclose(fid);
        Tcl_AppendResult(interp, outfile, NULL);
        break;

    default:
        Tcl_AppendResult(interp, "Unknown output format", NULL);
        goto ErrorExit;
    }
    return TCL_OK;

ErrorExit:
    if (NULL != fid)
        fclose(fid);
    return TCL_ERROR;
}


int
inParam(
    Tcl_Interp *interp,
    BYTE **output,
    BYTE *length,
    char *input,
    formatType format)
{
    static BYTE
        buffer[256];
    unsigned long int
        len, index, hex;
    FILE *
        fid = NULL;

    len = strlen(input);
    switch (format)
    {
    case format_text:
        if (255 < len)
        {
            Tcl_AppendResult(interp, "Input too long.", NULL);
            goto ErrorExit;
        }
        *output = (BYTE *)input;
        *length = (BYTE)len;
        break;

    case format_hexidecimal:
        if (510 < len)
        {
            Tcl_AppendResult(interp, "Input too long.", NULL);
            goto ErrorExit;
        }
        if (len != strspn(input, "0123456789ABCDEFabcdef"))
        {
            fprintf(stderr, "Invalid Hex number.\n");
            goto ErrorExit;
        }
        for (index = 0; index < len; index += 2)
        {
            sscanf(&input[index], " %2lx", &hex);
            buffer[index / 2] = (BYTE)hex;
        }
        *output = buffer;
        *length = (BYTE)((0 == (len & 0x01)) ? (len / 2) : (len / 2 + 1));
        break;

    case format_file:
        fid = fopen(input, "rb");
        if (NULL == fid)
        {
            Tcl_AppendResult(interp, ErrorString(GetLastError()), NULL);
            goto ErrorExit;
        }
        *length = (BYTE)fread(buffer, sizeof(BYTE), sizeof(buffer), fid);
        if (0 != ferror(fid))
        {
            Tcl_AppendResult(interp, ErrorString(GetLastError()), NULL);
            goto ErrorExit;
        }
        *output = buffer;
        fclose(fid);
        break;

    default:
        Tcl_AppendResult(interp, "Unknown input format", NULL);
        goto ErrorExit;
    }

    return TCL_OK;

ErrorExit:
    if (NULL != fid)
        fclose(fid);
    return TCL_ERROR;
}


BOOL
ParamCount(
    Tcl_Interp *interp,
    DWORD argc,
    DWORD cmdIndex,
    DWORD dwCount)
{
    BOOL fSts = TRUE;
    if (cmdIndex + dwCount > (unsigned long int)argc)
    {
        Tcl_AppendResult(interp, "Insufficient parameters", NULL);
        fSts = FALSE;
    }
    return fSts;
}

void
badSyntax(
    Tcl_Interp *interp,
    char *argv[],
    unsigned long int cmdIndex)
{
    unsigned long int
        index;

    Tcl_ResetResult(interp);
    Tcl_AppendResult(interp, "Invalid option '", NULL);
    Tcl_AppendResult(interp, argv[cmdIndex], NULL);
    Tcl_AppendResult(interp, "' to the '", NULL);
    for (index = 0; index < cmdIndex; index += 1)
        Tcl_AppendResult(interp, argv[index], " ", NULL);
    Tcl_AppendResult(interp, "...' command.", NULL);
}

void
SetMultiResult(
    Tcl_Interp *interp,
    LPTSTR mszResult)
{
    LPTSTR sz = mszResult;
    while (0 != *sz)
    {
        Tcl_AppendElement(interp, sz);
        sz += strlen(sz) + 1;
    }
}

LPWSTR
Unicode(
    LPCSTR sz)
{
    static WCHAR szUnicode[2048];
    int length;

    length =
        MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            sz,
            strlen(sz),
            szUnicode,
            sizeof(szUnicode) / sizeof(WCHAR));
    szUnicode[length] = 0;
    return szUnicode;
}


static char *
    ErrorBuffer
        = NULL;

char *
ErrorString(
    long theError)
{
    if (NULL != ErrorBuffer)
    {
        LocalFree(ErrorBuffer);
        ErrorBuffer = NULL;
    }
    if (0 == FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                theError,
                LANG_NEUTRAL,
                (LPTSTR)&ErrorBuffer,
                0,
                NULL))
    {
        if (0 == FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_FROM_HMODULE,
                    GetModuleHandle(NULL),
                    theError,
                    LANG_NEUTRAL,
                    (LPTSTR)&ErrorBuffer,
                    0,
                    NULL))
        {
            if (0 == FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE,
                        GetModuleHandle(TEXT("winscard")),
                        theError,
                        LANG_NEUTRAL,
                        (LPTSTR)&ErrorBuffer,
                        0,
                        NULL))
            {
                ErrorBuffer = Lo