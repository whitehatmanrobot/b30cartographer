e username and the password on a single open and close!
    // --------------------------------------------------
    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, (LPCTSTR)stMDEntry.szMDPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        dwReturnTemp = ERROR_SUCCESS;
        dwReturnTemp = cmdKey.SetData(stMDEntry.dwMDIdentifier,stMDEntry.dwMDAttributes,stMDEntry.dwMDUserType,stMDEntry.dwMDDataType,stMDEntry.dwMDDataLen,stMDEntry.pbMDData);
        if (FAILED(dwReturnTemp))
        {
            SetErrorFlag(__FILE__, __LINE__);
            iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), stMDEntry.dwMDIdentifier, dwReturnTemp));
            dwReturn = dwReturnTemp;
        }

        dwReturnTemp = ERROR_SUCCESS;
        dwReturnTemp = cmdKey.SetData(stMDEntry_Pass.dwMDIdentifier,stMDEntry_Pass.dwMDAttributes,stMDEntry_Pass.dwMDUserType,stMDEntry_Pass.dwMDDataType,stMDEntry_Pass.dwMDDataLen,stMDEntry_Pass.pbMDData);
        if (FAILED(dwReturnTemp))
        {
            SetErrorFlag(__FILE__, __LINE__);
            iisDebugOut((LOG_TYPE_ERROR, _T("SetMDEntry:SetData(%d), FAILED. Code=0x%x.End.\n"), stMDEntry_Pass.dwMDIdentifier, dwReturnTemp));
            dwReturn = dwReturnTemp;
        }

        cmdKey.Close();
    }

    return dwReturn;
}


// loop thru the custom errors and make sure they point to the right place
BOOL VerifyCustomErrors_WWW(CString csKeyPath)
{
    CMDKey  cmdKey;
    PVOID   pData = NULL;
    BOOL    bReturn = FALSE;
    CString csOneBlobEntry;
    TCHAR   szOneBlobEntry2[_MAX_PATH + 20];
    CString csCustomErrorEntry;
    int c = 0;

    int iCustomErrorEntryCount = 0;
    int iCustomErrorUpdatedCount = 0;
    int iPleaseCloseTheMetabase = FALSE;

    TCHAR szDrive_only[_MAX_DRIVE];
    TCHAR szPath_only[_MAX_PATH];
    TCHAR szPath_only2[_MAX_PATH];
    TCHAR szFilename_only[_MAX_PATH];
    TCHAR szFilename_ext_only[_MAX_EXT];

    DWORD dwAttr;
    DWORD dwUType;
    DWORD dwDType;
    DWORD dwLength;

    TCHAR*      pBlobEntry = NULL;
    DWORD       cbBuffer = 0;

    // open the key
    cmdKey.OpenNode(csKeyPath);
    // test for success.
    if ( (METADATA_HANDLE)cmdKey == NULL )
    {
        // if could not open the key maybe there is nothing there.
        goto VerifyCustomErrors_WWW_Exit;
    }
    iPleaseCloseTheMetabase = TRUE;


    dwAttr = METADATA_INHERIT;
    dwUType = IIS_MD_UT_FILE;
    dwDType = MULTISZ_METADATA;
    dwLength = 0;

    // we need to start this process by getting the existing multisz data from the metabase
    // first, figure out how much memory we will need to do this

    // make sure METADATA_INHERIT is NOT set!
    // otherwise becaues the entry exists at the root, we'll always get it.
    cmdKey.GetData(MD_CUSTOM_ERROR,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_NO_ATTRIBUTES,IIS_MD_UT_FILE,MULTISZ_METADATA);

    // unfortunatly, the above routine only returns TRUE or FALSE. And since we are purposefully
    // passing in a null ponter of 0 size in order to get the length of the data, it will always
    // return 0 whether it was because the metabase is inacessable, or there pointer was NULL,
    // which it is. So - I guess we assume it worked, allocate the buffer and attempt to read it
    // in again.
    cbBuffer = dwLength;

    // allocate the space, if it fails, we fail
    // note that GPTR causes it to be initialized to zero
    pData = GlobalAlloc( GPTR, cbBuffer );
    if ( !pData )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("VerifyCustomErrors_WWW.1.Failed to allocate memory.\n")));
        goto VerifyCustomErrors_WWW_Exit;
        }
    pBlobEntry = (TCHAR*)pData;

    // now get the data from the metabase
    iCustomErrorEntryCount = 0;
    bReturn = cmdKey.GetData(MD_CUSTOM_ERROR,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)pData,cbBuffer,METADATA_NO_ATTRIBUTES,IIS_MD_UT_FILE,MULTISZ_METADATA );
    // loop thru this list and add it to our array of entries.
    if (bReturn)
    {
        // got the entry, scan them now - pBlobEntry will be pointing at the second end \0
        // when it is time to exit the loop.
        csCustomErrorEntry = _T("");
        while ( *pBlobEntry )
            {
            csOneBlobEntry = pBlobEntry;
            _tcscpy(szOneBlobEntry2, csOneBlobEntry);

            // Grab the blob entry and make sure that it points to the new location.
            //"500,15,FILE,D:\WINNT\help\iisHelp\common\500-15.htm"
            //"500,100,URL,/iisHelp/common/500-100.asp"
            if ( SplitLineCommaDelimited(szOneBlobEntry2, 4) )
                {

                // Check if this is for a file type:
                if (_tcsicmp(g_field[2], _T("FILE")) == 0)
                    {
                        // Get the filename
                        // Trim off the filename and return only the path
                        _tsplitpath( g_field[3], szDrive_only, szPath_only, szFilename_only, szFilename_ext_only);

                        // Check if the path points to the old place...
                        CString     csFilePath;
                        csFilePath.Format(_T("%s\\help\\common\\file"), g_pTheApp->m_csWinDir);
                        _tsplitpath( csFilePath, NULL, szPath_only2, NULL, NULL);

                        if (_tcsicmp(szPath_only, szPath_only2) == 0)
                        {
                            // yes, it points to the old place.
                            // let's see if it exists in the new place first....
                            CString csFilePathNew;
                            csFilePathNew.Format(_T("%s\\help\\iishelp\\common"), g_pTheApp->m_csWinDir);
                            csFilePath.Format(_T("%s\\%s%s"), csFilePathNew, szFilename_only, szFilename_ext_only);
                            if (IsFileExist(csFilePath))
                            {
                                // yes, it does, then let's replace it.
                                csOneBlobEntry.Format(_T("%s,%s,%s,%s\\%s%s"), g_field[0], g_field[1], g_field[2], csFilePathNew, szFilename_only, szFilename_ext_only);
                                iCustomErrorUpdatedCount++;
                            }
                            else
                            {
                                // no it does not exist...
                                // see if there is a *.bak file with that name...
                                CString csFilePath2;
                                csFilePath2 = csFilePath;
                                csFilePath2 += _T(".bak");
                                if (IsFileExist(csFilePath2))
                                {
                                    // yes, it does, then let's replace it.
                                    csOneBlobEntry.Format(_T("%s,%s,%s,%s\\%s%s.bak"), g_field[0], g_field[1], g_field[2], csFilePathNew, szFilename_only, szFilename_ext_only);
                                    iCustomErrorUpdatedCount++;
                                }
                                else
                                {
                                    // They must be pointing to some other file which we don't have.
                                    // let's try to copy the old file from the old directory...
                                    TCHAR szNewFileName[_MAX_PATH];
                                    // rename file to *.bak and move it to the new location..
                                    _stprintf(szNewFileName, _T("%s\\%s%s"), csFilePathNew, szFilename_only, szFilename_ext_only);
                                    // move it
                                    if (IsFileExist(csFilePath))
                                    {
                                        if (MoveFileEx( g_field[3], szNewFileName, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH|MOVEFILE_REPLACE_EXISTING))
                                        {
                                            // yes, it does, then let's replace it.
                                            csOneBlobEntry.Format(_T("%s,%s,%s,%s"), g_field[0], g_field[1], g_field[2], szNewFileName);
                                            iCustomErrorUpdatedCount++;
                                        }
                                    }
                                    else
                                    {
                                        // Check if the file was renamed...
                                        TCHAR szNewFileName[_MAX_PATH];
                                        // rename file to *.bak and move it to the new location..
                                        _stprintf(szNewFileName, _T("%s\\%s%s.bak"), csFilePathNew, szFilename_only, szFilename_ext_only);
                                        // yes, it does, then let's replace it.
                                        if (IsFileExist(szNewFileName))
                                        {
                                            csOneBlobEntry.Format(_T("%s,%s,%s,%s"), g_field[0], g_field[1], g_field[2], szNewFileName);
                                            iCustomErrorUpdatedCount++;
                                        }
                                        else
                                        {
                                            // they must be pointing to some other file which we don't install.
                                            // so don't change this entry...
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            else
                {
                // failed to split the line
                SetErrorFlag(__FILE__, __LINE__);
                iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: Unable to split upgrade error INF line - %s"), szOneBlobEntry2));
                }

            // append on the "|" which we'll convert to a null later
            csCustomErrorEntry += csOneBlobEntry + _T("|");
            iCustomErrorEntryCount++;

            // increment pBlobEntry to the next string
            pBlobEntry = _tcsninc( pBlobEntry, _tcslen(pBlobEntry))+1;
            }

        // add the terminating second "|" character
        csCustomErrorEntry +=_T("|");
    }
    // close the handle to the metabase so that we can
    // open it to write the stuff out later!
    cmdKey.Close();
    iPleaseCloseTheMetabase = FALSE;

    // If we added any new entries to the metabase
    // the let's write out the new block of data, otherwise let's get out.
    if (iCustomErrorUpdatedCount > 0)
    {
        WriteToMD_CustomError_Entry(csKeyPath,csCustomErrorEntry);
    }

VerifyCustomErrors_WWW_Exit:
    // close the key
    if (TRUE == iPleaseCloseTheMetabase){cmdKey.Close();}
    if (pData){GlobalFree(pData);pData=NULL;}
    // the only time it should return FALSE is if it can't open the key
    return TRUE;
}

/*
"400,*,FILE,D:\WINNT\help\common\400.htm"
"401,1,FILE,D:\WINNT\help\common\401-1.htm"
"401,2,FILE,D:\WINNT\help\common\401-2.htm"
"401,3,FILE,D:\WINNT\help\common\401-3.htm"
"401,4,FILE,D:\WINNT\help\common\401-4.htm"
"401,5,FILE,D:\WINNT\help\common\401-5.htm"
"403,1,FILE,D:\WINNT\help\common\403-1.htm"
"403,2,FILE,D:\WINNT\help\common\403-2.htm"
"403,3,FILE,D:\WINNT\help\common\403-3.htm"
 "403,4,FILE,D:\WINNT\help\common\403-4.htm"
 "403,5,FILE,D:\WINNT\help\common\403-5.htm"
 "403,6,FILE,D:\WINNT\help\common\403-6.htm"
 "403,7,FILE,D:\WINNT\help\common\403-7.htm"
 "403,8,FILE,D:\WINNT\help\common\403-8.htm"
 "403,9,FILE,D:\WINNT\help\common\403-9.htm"
 "403,10,FILE,D:\WINNT\help\common\403-10.htm"
 "403,11,FILE,D:\WINNT\help\common\403-11.htm"
 "403,12,FILE,D:\WINNT\help\common\403-12.htm"
 "404,*,FILE,D:\WINNT\help\common\404b.htm"
 "405,*,FILE,D:\WINNT\help\common\405.htm"
 "406,*,FILE,D:\WINNT\help\common\406.htm"
 "407,*,FILE,D:\WINNT\help\common\407.htm"
 "412,*,FILE,D:\WINNT\help\common\412.htm"
 "414,*,FILE,D:\WINNT\help\common\414.htm"
 "403,13,FILE,D:\WINNT\help\iisHelp\common\403-13.htm"
 "403,15,FILE,D:\WINNT\help\iisHelp\common\403-15.htm"
 "403,16,FILE,D:\WINNT\help\iisHelp\common\403-16.htm"
 "403,17,FILE,D:\WINNT\help\iisHelp\common\403-17.htm"
 "500,12,FILE,D:\WINNT\help\iisHelp\common\500-12.htm"
 "500,13,FILE,D:\WINNT\help\iisHelp\common\500-13.htm"
 "500,15,FILE,D:\WINNT\help\iisHelp\common\500-15.htm"
 "500,100,URL,/iisHelp/common/500-100.asp"
*/
DWORD WriteToMD_CustomError_Entry(CString csKeyPath, CString csCustomErrorDelimitedList)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwReturnTemp = ERROR_SUCCESS;
    MDEntry stMDEntry;

    HGLOBAL hBlock = NULL;

    int nCustomErrorLength;
    nCustomErrorLength = csCustomErrorDelimitedList.GetLength() * sizeof(TCHAR);
    hBlock = GlobalAlloc(GPTR, nCustomErrorLength + sizeof(TCHAR));
    if (!hBlock)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("WriteToMD_CustomError_Entry.Failed to allocate memory.\n")));
        return E_FAIL;
    }

    TCHAR *p = (LPTSTR)hBlock;
    memcpy((LPVOID)hBlock, (LPVOID)(LPCTSTR)csCustomErrorDelimitedList, nCustomErrorLength + sizeof(TCHAR));

    //  replace all '|' which a null
    while (*p)
    {
        if (*p == _T('|'))
        {
            *p = _T('\0');
        }
        p = _tcsinc(p);
    }

    // write the new errors list back out to the metabase
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_CUSTOM_ERROR;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = MULTISZ_METADATA;
    stMDEntry.dwMDDataLen = nCustomErrorLength;
    stMDEntry.pbMDData = (LPBYTE)hBlock;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    if (hBlock){GlobalFree(hBlock);hBlock=NULL;}
    return dwReturn;
}


void VerifyAllCustomErrorsRecursive_SlowWay(const CString& csTheNode)
{
    int iReturn = FALSE;
    CMDKey cmdKey;
    CStringArray arrayInstance;
    int nArray = 0, i = 0;

    // get all instances into an array
    cmdKey.OpenNode(csTheNode);
    if ( !(METADATA_HANDLE) cmdKey ) {goto VerifyAllCustomErrorsRecursive_SlowWay_Exit;}
    cmdKey.Close();

    // Let's see if there are any CustomError entries to upgrade...
    VerifyCustomErrors_WWW(csTheNode);

    cmdKey.OpenNode(csTheNode);
    if ( (METADATA_HANDLE) cmdKey )
        {
        // enumerate thru this key for other keys...
        CMDKeyIter cmdKeyEnum(cmdKey);
        CString csKeyName;
        while (cmdKeyEnum.Next(&csKeyName) == ERROR_SUCCESS)
        {
            //if (IsValidNumber((LPCTSTR)csKeyName))
            //{
                arrayInstance.Add(csKeyName);
            //}
        }
        cmdKey.Close();

        nArray = (int)arrayInstance.GetSize();
        for (i=0; i<nArray; i++)
        {
            /*
            // Recurse Thru This nodes entries
            // Probably look something like these...
            [/W3SVC]
            [/W3SVC/1/ROOT/IISSAMPLES/ExAir]
            [/W3SVC/1/ROOT/IISADMIN]
            [/W3SVC/1/ROOT/IISHELP]
            [/W3SVC/1/ROOT/specs]
            [/W3SVC/2/ROOT]
            [/W3SVC/2/ROOT/IISADMIN]
            [/W3SVC/2/ROOT/IISHELP]
            etc...
            */
            CString csPath;
            csPath = csTheNode;
            csPath += _T("/");
            csPath += arrayInstance[i];
            VerifyAllCustomErrorsRecursive_SlowWay(csPath);
        }
    }

VerifyAllCustomErrorsRecursive_SlowWay_Exit:
    return;
}


void MoveOldHelpFilesToNewLocation(void)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindFileData;
    TCHAR szDirNameTemp[_MAX_PATH];
    TCHAR szTempHelpHTMFilesDir1[_MAX_PATH];
    TCHAR szTempHelpHTMFilesDir2[_MAX_PATH];

    GetWindowsDirectory( szTempHelpHTMFilesDir1, _MAX_PATH);
    AddPath(szTempHelpHTMFilesDir1, _T("help\\common"));

    GetWindowsDirectory( szTempHelpHTMFilesDir2, _MAX_PATH);
    AddPath(szTempHelpHTMFilesDir2, _T("help\\iishelp\\common"));

    // Check if the old directory exists...
    if (!IsFileExist(szTempHelpHTMFilesDir1))
    {
        return;
    }

    // The old directory does exist..
    // let's rename all the files to *.bak, then move them over.
    // *.htm to *.htm.bak
    // *.asp to *.asp.bak
    // *.asa to *.asa.bak
    // *.inc to *.inc.bak
    //
    // 1st let's delete any *.bak files they may already have...
    //DeleteFilesWildcard(szTempHelpHTMFilesDir1, _T("*.bak"));

    // ok, this is a directory,
    // so tack on the *.* deal
    _stprintf(szDirNameTemp, _T("%s\\*.*"), szTempHelpHTMFilesDir1);
    hFile = FindFirstFile(szDirNameTemp, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        do {
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        // this is a directory, so let's skip it
                    }
                    else
                    {
                        // this is a file, let's check if it's one of the ones we care about.
                        TCHAR szFilename_ext_only[_MAX_EXT];
                        _tsplitpath( FindFileData.cFileName, NULL, NULL, NULL, szFilename_ext_only);
                        int iYesFlag = FALSE;

                        if (szFilename_ext_only)
                        {
                            if ( _tcsicmp(szFilename_ext_only, _T(".htm")) == 0) {iYesFlag = TRUE;}
                            if ( _tcsicmp(szFilename_ext_only, _T(".html")) == 0) {iYesFlag = TRUE;}
                            if ( _tcsicmp(szFilename_ext_only, _T(".asp")) == 0) {iYesFlag = TRUE;}
                            if ( _tcsicmp(szFilename_ext_only, _T(".asa")) == 0) {iYesFlag = TRUE;}
                            if ( _tcsicmp(szFilename_ext_only, _T(".inc")) == 0) {iYesFlag = TRUE;}

                            if (TRUE == iYesFlag)
                            {
                                TCHAR szOldFileName[_MAX_PATH];
                                TCHAR szNewFileName[_MAX_PATH];
                                // rename to filename.*.bak
                                _stprintf(szOldFileName, _T("%s\\%s"), szTempHelpHTMFilesDir1, FindFileData.cFileName);
                                // rename file to *.bak and move it to the new location..
                                _stprintf(szNewFileName, _T("%s\\%s.bak"), szTempHelpHTMFilesDir2, FindFileData.cFileName);
                                // move it
                                MoveFileEx( szOldFileName, szNewFileName, MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH|MOVEFILE_REPLACE_EXISTING);
                            }
                        }
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) )
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }

    return;
}


void WriteToMD_ForceMetabaseToWriteToDisk(void)
{
    if (CheckifServiceExist(_T("IISADMIN")) == 0 )
    {
        CMDKey cmdKey;
        cmdKey.ForceWriteMetabaseToDisk();

        //cmdKey.OpenNode(_T("/"));
        //if ( (METADATA_HANDLE)cmdKey )
        //{
        //    cmdKey.ForceWriteMetabaseToDisk();
        //    cmdKey.Close();
        //}
    }
    return;
}


DWORD WriteToMD_DefaultLoadFile(CString csKeyPath,CString csData)
{
    DWORD dwReturnTemp = ERROR_SUCCESS;
    DWORD dwReturn = ERROR_SUCCESS;

    MDEntry stMDEntry;

    //stMDEntry.szMDPath = _T("LM/W3SVC");
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR) csKeyPath;

    stMDEntry.dwMDIdentifier = MD_DEFAULT_LOAD_FILE;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csData.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csData;
    dwReturnTemp = SetMDEntry(&stMDEntry);
    if (dwReturnTemp != ERROR_SUCCESS){dwReturn = dwReturnTemp;}

    return dwReturn;
}


//
// Returns the amount of entries that we added.
//
int AddRequiredDefaultLoad(CStringArray& arrayName,IN LPCTSTR szSection)
{
    int c = 0;
    CStringList strList;

    CString csTheSection = szSection;
    if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTheSection))
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, csTheSection))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos = NULL;
            CString csEntry;

            pos = strList.GetHeadPosition();
            while (pos)
            {
                csEntry = _T("");
                csEntry = strList.GetAt(pos);

                // Add it to our array...
                // iisDebugOut((LOG_TYPE_TRACE, _T("Add default load Entry:%s:%s\n"),csName, csPath));
                arrayName.Add(csEntry);
                c++;

                strList.GetNext(pos);
            }
        }
    }
    }

    return c;
}


void VerifyMD_DefaultLoadFile_WWW(IN LPCTSTR szSection, CString csKeyPath)
{
    iisDebugOut_Start(_T("VerifyMD_DefaultLoadFile_WWW"), LOG_TYPE_TRACE);

    CMDKey cmdKey;
    BOOL bReturn = FALSE;
    BOOL fAddComma = FALSE;
    int i = 0;

    CStringArray arrayDefaultValues;
    int nArrayItems = 0;

    CString csFinalEntryToWrite;

    int iNewlyAdded_Count = 0;

    // open the key
    // cmdKey.OpenNode(_T("LM/W3SVC"));
    cmdKey.OpenNode(csKeyPath);

    // test for success.
    if ( (METADATA_HANDLE)cmdKey )
    {
        DWORD dwAttr = METADATA_INHERIT;
        DWORD dwUType = IIS_MD_UT_FILE;
        DWORD dwDType = STRING_METADATA;
        DWORD dwLength = 0;
        // we need to start this process by getting the existing multisz data from the metabase
        // first, figure out how much memory we will need to do this
        cmdKey.GetData( MD_DEFAULT_LOAD_FILE,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA);
        if (dwLength > 0)
        {
            // now get the real data from the metabase
            bReturn = cmdKey.GetData( MD_DEFAULT_LOAD_FILE,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)csFinalEntryToWrite.GetBuffer( dwLength ),dwLength,METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA );
            csFinalEntryToWrite.ReleaseBuffer();
        }
        // the data doesn't get written out here, so close the metabase key
        cmdKey.Close();
        // if reading the value from the metabase didn't work, zero out the string
        if ( !bReturn ){csFinalEntryToWrite.Empty();}
    }
    // if there is something in the order string from the upgrade, then we need to start adding commas
    if ( !csFinalEntryToWrite.IsEmpty() )
    {
        fAddComma = TRUE;
        iisDebugOut((LOG_TYPE_TRACE, _T("VerifyMD_DefaultLoadFile_WWW:InitialEntry=%s.\n"),csFinalEntryToWrite));
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("VerifyMD_DefaultLoadFile_WWW:InitialEntry=None.\n")));
    }

    // Add Required Filters to the arrayDefaultValues
    AddRequiredDefaultLoad(arrayDefaultValues, szSection);
    nArrayItems = (int)arrayDefaultValues.GetSize();
    if ( nArrayItems == 0 ) {goto VerifyMD_DefaultLoadFile_WWW_Exit;}

    // now loop thru this list
    // and check if our isapi dll's are in this list.
    // if they are not, then we add them to the end.
    iNewlyAdded_Count = 0;
    for ( i = 0; i < nArrayItems; i++ )
    {
        // if the name in the array is already in the filter order list,
        // then continue to the next one
        if ( csFinalEntryToWrite.Find( arrayDefaultValues[i] ) >= 0 )
            {continue;}

        if (fAddComma == TRUE){csFinalEntryToWrite += _T(",");}
        else{fAddComma = TRUE;}

        // Add this entry to our list!
        csFinalEntryToWrite += arrayDefaultValues[i];

        iNewlyAdded_Count++;
    }

    // If we added any new entries to the metabase
    // the let's write out the new block of data, otherwise let's get out.
    if (iNewlyAdded_Count > 0)
    {
        WriteToMD_DefaultLoadFile(csKeyPath,csFinalEntryToWrite);
        iisDebugOut((LOG_TYPE_TRACE, _T("VerifyMD_DefaultLoadFile_WWW:NewEntry=%s.\n"),csFinalEntryToWrite));
    }

VerifyMD_DefaultLoadFile_WWW_Exit:
    iisDebugOut_End(_T("VerifyMD_DefaultLoadFile_WWW"),LOG_TYPE_TRACE);
    return;
}


INT Register_iis_www_handleScriptMap()
{
    int iReturn = TRUE;
    HRESULT         hRes;

    ACTION_TYPE atWWW = GetSubcompAction(_T("iis_www"),FALSE);

    ScriptMapNode ScriptMapList = {0};
    // make it a sentinel
    ScriptMapList.next = &ScriptMapList;
    ScriptMapList.prev = &ScriptMapList;
    if (atWWW == AT_INSTALL_FRESH || atWWW == AT_INSTALL_REINSTALL)
    {
        GetScriptMapListFromClean(&ScriptMapList, _T("ScriptMaps_CleanList"));
    }
    if (atWWW == AT_INSTALL_UPGRADE)
    {
        switch (g_pTheApp->m_eUpgradeType)
        {
            case UT_50:
            case UT_51:
            case UT_60:
                //GetScriptMapListFromClean(&ScriptMapList, _T("ScriptMaps_CleanList"));
		GetScriptMapListFromMetabase(&ScriptMapList, g_pTheApp->m_eUpgradeType);
                break;
            case UT_40:
                GetScriptMapListFromMetabase(&ScriptMapList, g_pTheApp->m_eUpgradeType);
                break;
            case UT_10_W95:
            case UT_351:
            case UT_10:
            case UT_20:
            case UT_30:
            default:
                GetScriptMapListFromRegistry(&ScriptMapList);
                break;
        }
    }
    WriteScriptMapListToMetabase(&ScriptMapList, _T("LM/W3SVC"), MD_SCRIPTMAPFLAG_SCRIPT);

    if (atWWW == AT_INSTALL_UPGRADE)
    {
        //DumpScriptMapList();

        // invert the script map verbs
        CInvertScriptMaps   inverter;
        hRes = inverter.Update( _T("LM/W3SVC") );
        if ( FAILED(hRes) )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("inverter.Update():FAILED Invert script map verbs =%x.\n"),hRes));
        }

        // fix the IPSec reference bit flags
        CIPSecRefBitAdder   refFixer;
        hRes = refFixer.Update( _T("LM/W3SVC") );
        if ( FAILED(hRes) )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("refFixer.Update(): FAILED Fix IPSEC ref flag =%x.\n"),hRes));
        }
        //DumpScriptMapList();
    }

    //
    // Whack the old Script Map RegKey
    //
    CRegKey regMachine = HKEY_LOCAL_MACHINE;
    CRegKey regWWWParam( REG_WWWPARAMETERS, regMachine );
    if ((HKEY) regWWWParam ) {regWWWParam.DeleteTree(_T("Script Map"));}

    FreeScriptMapList(&ScriptMapList);
    return iReturn;
}

int ReOrderFiltersSpecial(int nArrayItems,CStringArray& arrayName,CString& csOrder)
{
    int bFound = FALSE;
    int i = 0;
    CString csOrderTemp;
    CString csOrderTemp2;

    CStringList     cslStringListTemp;
    CString         csOneEntry;
    POSITION        pos;
    int             numInList;

    // make a copy of string we'll be working with
    csOrderTemp = csOrder;


    // scan through the list of filters we want to add/makesureisthere.

    //
    //       SPECIAL HANDLING FOR SSPIFILT
    //
    // if we want to add the sspifilt then apply these rules:
    //	  if sspifilt is on the list then just leave it there.
    //	  if sspifilt is not on the list then stick it in first position.
    //
    bFound = FALSE;
    for ( i = 0; i < nArrayItems; i++ )
    {
        if (_tcsicmp(arrayName[i], _T("SSPIFILT")) == 0)
            {bFound = TRUE;}
    }
    // we found sspifilt in the value's list that we want to add
    if (bFound)
    {
        csOrderTemp2 = csOrderTemp;
        csOrderTemp2.MakeUpper();
        csOrderTemp2.TrimLeft();
        csOrderTemp2.TrimRight();

        // now check if it's in the existing users list.
        if ( csOrderTemp2.Find( _T("SSPIFILT") ) >= 0 )
        {
            // yes, it's already there. just leave it there.
        }
        else
        {
            // changes csOrderTemp
            AddFilter1ToFirstPosition(csOrderTemp, _T("sspifilt"));
        }
    }

    //       SPECIAL HANDLING FOR Compression FILTER
    //
    // if we want to add the Compression filter then apply these rules:
    //	 if compression is on the list, then just make sure it's after sspifilt.  (re-order they're existing loadorder)
    //	 if compression is not on the list then stick it after sspifilt. (insert it in the existing list)
    //
    bFound = FALSE;
    for ( i = 0; i < nArrayItems; i++ )
    {
        if (_tcsicmp(arrayName[i], _T("COMPRESSION")) == 0)
            {bFound = TRUE;}
    }
    // we found compression in the value's list that we want to add
    if (bFound)
    {
        // now check if it's in the existing users list.
        csOrderTemp2 = csOrderTemp;
        csOrderTemp2.MakeUpper();
        csOrderTemp2.TrimLeft();
        csOrderTemp2.TrimRight();
        if ( csOrderTemp2.Find( _T("COMPRESSION") ) >= 0 )
        {
            // Make sure it's after sspifilt!
            // yucky!

            // 1. check if it's already after sspifilt.
            //    a. if it is cool, get out.
            //    b. if not then reorder it so that it is
            CString csOrderTemp2 = csOrderTemp;
            csOrderTemp2.MakeUpper();
            csOrderTemp2.TrimLeft();
            csOrderTemp2.TrimRight();

            int numInList1 = csOrderTemp2.Find(_T("COMPRESSION"));
            int numInList2 = csOrderTemp2.Find(_T("SSPIFILT"));
            if (numInList2 != -1)
            {
                if (numInList1 < numInList2)
                {
                    // if compression is before sspifilt, then we'll have to remove it
                    numInList = ConvertSepLineToStringList(csOrderTemp,cslStringListTemp,_T(","));
                    bFound = FALSE;
                    pos = cslStringListTemp.GetHeadPosition();
                    while (pos)
                    {
                        csOneEntry = cslStringListTemp.GetAt(pos);
                        csOneEntry.TrimLeft();
                        csOneEntry.TrimRight();
                        // Does this contain sspifilt?
                        if (_tcsicmp(csOneEntry, _T("COMPRESSION")) == 0)
                        {
                            // Here it is, let's delete it.
                            if ( NULL != pos )
                                {cslStringListTemp.RemoveAt(pos);}
                            // break out of the loop
                            bFound = TRUE;
                            break;
                        }
                        // get the next one
                        cslStringListTemp.GetNext(pos);
                    }
                    if (bFound)
                    {
                        // convert the stringlist back into the comma delimited cstring.
                        ConvertStringListToSepLine(cslStringListTemp,csOrderTemp,_T(","));
                    }

                    // loop thru and add Compression after sspifilt
                    //it is not in the users list, let's stick it after sspifilt.
                    AddFilter1AfterFilter2(csOrderTemp, _T("Compression"), _T("sspifilt"));
                }
            }
            else
            {
                // sspifilt was not found.
                //it is not in the users list, let's stick it in the first position.
                // changes csOrderTemp
                AddFilter1ToFirstPosition(csOrderTemp, _T("sspifilt"));
            }
        }
        else
        {
            // it is not in the users list, let's stick it after sspifilt.
            // check if sspifilt already exists..
            AddFilter1AfterFilter2(csOrderTemp, _T("Compression"), _T("sspifilt"));
        }
    }

    csOrder = csOrderTemp;
    return TRUE;
}

void AddFilter1ToFirstPosition(CString& csOrder,LPTSTR szFilter1)
{
    CString csNewOrder;

    //it is not in the users list, let's stick it in the first position.
    csNewOrder = szFilter1;
    if (!csOrder.IsEmpty())
    {
        csNewOrder += _T(",");
        csNewOrder += csOrder;
    }
    // set it back to csOrderTemp
    csOrder = csNewOrder;
}

void AddFilter1AfterFilter2(CString& csOrder,LPTSTR szFilter1,LPTSTR szFilter2)
{
    int bFound = FALSE;
    CStringList     cslStringListTemp;
    CString         csOneEntry;
    POSITION        pos;
    int             numInList;

    CString csOrderTemp;
    CString csNewOrder;

    csOrderTemp = csOrder;

    // we have already determined that filter1 is not in the list
    // add filter1 after filter2.

    // split up the comma delimited csOrder entry into string list.
    numInList = ConvertSepLineToStringList(csOrderTemp,cslStringListTemp,_T(","));

    bFound = FALSE;
    pos = cslStringListTemp.GetHeadPosition();
    while (pos)
    {
        csOneEntry = cslStringListTemp.GetAt(pos);
        csOneEntry.TrimLeft();
        csOneEntry.TrimRight();

        // Does this contain filter#2?
        if (_tcsicmp(csOneEntry, szFilter2) == 0)
        {
            // Here it is, so insert compression after this one...
            cslStringListTemp.InsertAfter(pos, (CString) szFilter1);
            // break out of the loop
            bFound = TRUE;
            break;
        }

        // get the next one
        cslStringListTemp.GetNext(pos);
    }
    if (bFound)
    {
        // convert the stringlist back into the comma delimited cstring.
        ConvertStringListToSepLine(cslStringListTemp,csOrderTemp,_T(","));
    }
    else
    {
        // we didn't find sspifilt,
        //it is not in the users list, let's stick it in the first position.
        csNewOrder = szFilter2;
        csNewOrder += _T(",");
        csNewOrder += szFilter1;

        if (!csOrderTemp.IsEmpty())
        {
            csNewOrder += _T(",");
            csNewOrder += csOrderTemp;
        }
        // set it back to csOrderTemp
        csOrderTemp = csNewOrder;
    }

    csOrder = csOrderTemp;
    return;
}

int GetScriptMapAllInclusionVerbs(CString &csTheVerbList)
{
    int iReturn = FALSE;
    int c = 0;
    CStringArray arrayName;
    CStringList strList;

    CString csTheSection = _T("ScriptMaps_All_Included_Verbs");
    if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTheSection))
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, csTheSection))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos = NULL;
            pos = strList.GetHeadPosition();
            if (pos)
            {
                // Set it to the 1st value in the list and that's all
                csTheVerbList = strList.GetAt(pos);

                iReturn = TRUE;
            }
       }
    }
    }

    return iReturn;
}



void GetScriptMapListFromClean(ScriptMapNode *pList, IN LPCTSTR szSection)
{
    iisDebugOut_Start1(_T("GetScriptMapListFromClean"), (LPTSTR) szSection, LOG_TYPE_TRACE);

    CString csExtention = _T("");
    CString csBinaryPath = _T("");
    CString csVerbs = _T("");
    CStringList strList;

    ScriptMapNode *pNode;

    CString csTheSection = szSection;
    if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTheSection))
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, csTheSection))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            int numParts;
            CString     csEntry;
            CStringList cslEntryList;
            CString     szDelimiter = _T("|");
            CString     csTemp;
            DWORD       dwFlags;
            POSITION    posEntryList;

            POSITION pos = NULL;
            pos = strList.GetHeadPosition();
            while (pos)
            {
                csEntry = _T("");
                csEntry = strList.GetAt(pos);

                // entry should look something like this.
                //.asp|c:\winnt\system32\inetsrv\asp.dll|GET,HEAD,POST,TRACE

                // break into a string list
                numParts = ConvertSepLineToStringList(csEntry,cslEntryList,szDelimiter);

                posEntryList = cslEntryList.FindIndex(0);
                if (NULL != posEntryList)
                {
                    csExtention = cslEntryList.GetNext( posEntryList );
                    // no whitespace before or after
                    csExtention.TrimLeft();
                    csExtention.TrimRight();
                }
                if (NULL != posEntryList)
                {
                    csBinaryPath = cslEntryList.GetNext( posEntryList );
                    // no whitespace before or after
                    csBinaryPath.TrimLeft();
                    csBinaryPath.TrimRight();
                }
                if (NULL != posEntryList)
                {
                    csVerbs = cslEntryList.GetNext( posEntryList );
                    // make sure the verb is normalized to capitals and
                    // no whitespace before or after
                    csVerbs.MakeUpper();
                    csVerbs.TrimLeft();
                    csVerbs.TrimRight();
                }

                dwFlags = 0;

                // Check to see if there is a additional flag that will be used for the script map.
                if (NULL != posEntryList)
                {
                    csTemp = cslEntryList.GetNext( posEntryList );
                    // make sure there are no whitespaces before or after
                    csTemp.TrimLeft();
                    csTemp.TrimRight();
                    
                    if (!csTemp.IsEmpty())
                    {
                        dwFlags = atodw(csTemp.GetBuffer(1));
                    }
                }

                // Add this script map to our list.
                if (csExtention && csBinaryPath)
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("GetScriptMapListFromClean(%s).entry=%s|%s|%s.\n"),csTheSection,csExtention,csBinaryPath,csVerbs));
                    pNode = AllocNewScriptMapNode((LPTSTR)(LPCTSTR) csExtention, (LPTSTR)(LPCTSTR) csBinaryPath, MD_SCRIPTMAPFLAG_SCRIPT | dwFlags, (LPTSTR)(LPCTSTR) csVerbs);
                    InsertScriptMapList(pList, pNode, TRUE);
                }

                strList.GetNext(pos);
            }
        }
    }
    }

    iisDebugOut_End1(_T("GetScriptMapListFromClean"),csTheSection,LOG_TYPE_TRACE);
    return;
}


DWORD WriteToMD_IDRegistration(CString csKeyPath)
{
    iisDebugOut_Start1(_T("WriteToMD_IDRegistration"), csKeyPath, LOG_TYPE_TRACE);

    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    TCHAR szData[_MAX_PATH];
    memset( (PVOID)szData, 0, sizeof(szData));

    //_tcscpy(szData, _T("0-65535;Microsoft Reserved|65536-524288;Microsoft IIS Admin Objects Reserved"));

    CStringList strList;
    CString csTheSection = _T("IIS_Metabase_IDRegistration");

    if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTheSection))
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, csTheSection))
    {
        _tcscpy(szData, _T(""));

        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            int c = 0;
            POSITION pos = NULL;
            CString csEntry;
            pos = strList.GetHeadPosition();
            while (pos)
            {
                csEntry = _T("");
                csEntry = strList.GetAt(pos);

                iisDebugOut((LOG_TYPE_TRACE, _T("WriteToMD_IDRegistration().csEntry=%s.\n"),csEntry));

                // concatenate to our big string
                if (c > 0){_tcscat(szData, _T("|"));}
                _tcscat(szData, csEntry);

                // increment the counter
                c++;
                strList.GetNext(pos);
            }
        }
    }
    }

    if (szData)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("WriteToMD_IDRegistration().Data=%s.\n"),szData));

        TCHAR *p = (LPTSTR) szData;
        while (*p)
        {
            //  replace all '|' with a null
            if (*p == _T('|'))
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("WriteToMD_IDRegistration().Data[...]=%c.\n"),*p));
                *p = _T('\0');
            }
            p = _tcsinc(p);
        }

        stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
        stMDEntry.dwMDIdentifier = MD_METADATA_ID_REGISTRATION;
        stMDEntry.dwMDAttributes = METADATA_INHERIT;
        stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
        stMDEntry.dwMDDataType = MULTISZ_METADATA;
        stMDEntry.dwMDDataLen = GetMultiStrSize(szData) * sizeof(TCHAR);
        stMDEntry.pbMDData = (LPBYTE)szData;
        dwReturn = SetMDEntry_Wrap(&stMDEntry);
    }

    iisDebugOut_End1(_T("WriteToMD_IDRegistration"),csKeyPath,LOG_TYPE_TRACE);
    return dwReturn;
}




DWORD WriteToMD_AspCodepage(CString csKeyPath, DWORD dwValue, int iOverWriteAlways)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    // LM/W3SVC/2/ROOT
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_ASP_CODEPAGE;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = ASP_MD_UT_APP;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwValue;
    if (iOverWriteAlways)
    {
        dwReturn = SetMDEntry(&stMDEntry);
    }
    else
    {
        dwReturn = SetMDEntry_NoOverWrite(&stMDEntry);
    }
    iisDebugOut((LOG_TYPE_TRACE, _T("WriteToMD_AspCodepage:%s:%d:%d.\n"),csKeyPath, dwValue, iOverWriteAlways));
    return dwReturn;
}


//     HttpCustom                    : [IF]    (MULTISZ) "Content-Type: Text/html; Charset=UTF-8"
DWORD WriteToMD_HttpCustom(CString csKeyPath, CString csData, int iOverWriteAlways)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;

    TCHAR szData[_MAX_PATH];
    memset( (PVOID)szData, 0, sizeof(szData));
    _stprintf(szData, _T("%s"), csData);

    // LM/W3SVC/2/ROOT
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_HTTP_CUSTOM;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = MULTISZ_METADATA;
    stMDEntry.dwMDDataLen = GetMultiStrSize(szData) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)szData;
    if (iOverWriteAlways)
    {
        dwReturn = SetMDEntry(&stMDEntry);
    }
    else
    {
        dwReturn = SetMDEntry_NoOverWrite(&stMDEntry);
    }
    iisDebugOut((LOG_TYPE_TRACE, _T("WriteToMD_HttpCustom:%s:%s:%d.\n"),csKeyPath, csData, iOverWriteAlways));
    return dwReturn;
}


DWORD WriteToMD_EnableParentPaths_WWW(CString csKeyPath, BOOL bEnableFlag)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwData = 0;

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_ASP_ENABLEPARENTPATHS;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = ASP_MD_UT_APP;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    // turn it on
    if (bEnableFlag)
    {
        dwData = 0x1;
    }
    else
    {
        dwData = 0x0;
    }
    stMDEntry.pbMDData = (LPBYTE)&dwData;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


void EnforceMaxConnections(void)
{
    // if this is not workstation then get out.
    if (g_pTheApp->m_eNTOSType == OT_NTW)
    {
        //iisDebugOut((LOG_TYPE_TRACE, _T("EnforceMaxConnections: Start.\n")));
        HRESULT hRes;
        CEnforceMaxConnection MaxConnectionEnforcer;

        // loop thru the metabase and get all places where MaxConnections is found.
        // if these are larger than 10 then set it to 10.
        iisDebugOut((LOG_TYPE_TRACE, _T("EnforceMaxConnections: Before.\n")));
        hRes = MaxConnectionEnforcer.Update(_T("LM/W3SVC"));
        if (FAILED(hRes))
            {iisDebugOut((LOG_TYPE_WARN, _T("EnforceMaxConnections.Update(LM/W3SVC):FAILED= %x.\n"),hRes));}

        hRes = MaxConnectionEnforcer.Update(_T("LM/MSFTPSVC"));
        if (FAILED(hRes))
            {iisDebugOut((LOG_TYPE_WARN, _T("EnforceMaxConnections.Update(LM/MSFTPSVC):FAILED= %x.\n"),hRes));}

        //iisDebugOut((LOG_TYPE_TRACE, _T("EnforceMaxConnections: End.\n")));
    }
    return;
}

DWORD WriteToMD_DwordEntry(CString csKeyPath,DWORD dwID,DWORD dwAttrib,DWORD dwUserType,DWORD dwTheData,INT iOverwriteFlag)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    DWORD dwCopyOfTheData = dwTheData;

    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = dwID;
    stMDEntry.dwMDAttributes = dwAttrib;
    stMDEntry.dwMDUserType = dwUserType;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwCopyOfTheData;
    if (iOverwriteFlag)
    {
        dwReturn = SetMDEntry(&stMDEntry);
    }
    else
    {
        dwReturn = SetMDEntry_NoOverWrite(&stMDEntry);
    }
    return dwReturn;
}

#define REASONABLE_TIMEOUT 1000

HRESULT
RemoveVirtualDir(
    IMSAdminBase *pIMSAdminBase,
    WCHAR * pwszMetabasePath,
    WCHAR * pwszVDir
)
{
    METADATA_HANDLE hMetabase = NULL;
    HRESULT hr = E_FAIL;

    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         pwszMetabasePath,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         REASONABLE_TIMEOUT,
                         &hMetabase );

    if( FAILED( hr )) {
        iisDebugOut((LOG_TYPE_ERROR, _T("RemoveVirtualDir:FAILED 0x%x\n"),hr));
        return hr; 
    }

    // We don't check the return value since the key may already 
    // not exist and we could get an error for that reason.
    pIMSAdminBase->DeleteKey( hMetabase, pwszVDir );
    pIMSAdminBase->CloseKey( hMetabase );    
    return hr;
}


HRESULT
AddVirtualDir(
    IMSAdminBase *pIMSAdminBase,
    WCHAR * pwszMetabasePath,
    WCHAR * pwszVDir,
    WCHAR * pwszPhysicalPath,
    DWORD dwPermissions,
    INT   iApplicationType
)
{
    HRESULT hr;
    METADATA_HANDLE hMetabase = NULL;       // handle to metabase
    WCHAR   szTempPath[MAX_PATH];
    DWORD   dwMDRequiredDataLen = 0;
    DWORD   dwAccessPerm = 0;
    METADATA_RECORD mr;
    
    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         pwszMetabasePath,
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         REASONABLE_TIMEOUT,
                         &hMetabase );

    // Create the key if it does not exist.
    if( FAILED( hr )) {goto AddVirtualDir_Exit;}

    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = 0;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = sizeof( szTempPath );
    mr.pbMDData       = reinterpret_cast<unsigned char *>(szTempPath);

    // see if MD_VR_PATH exists.
    hr = pIMSAdminBase->GetData( hMetabase, pwszVDir, &mr, &dwMDRequiredDataLen );
    if( FAILED( hr )) 
    {
        if( hr == MD_ERROR_DATA_NOT_FOUND || HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND ) 
        {

            // Write both the key and the values if GetData() failed with any of the two errors.

            pIMSAdminBase->AddKey( hMetabase, pwszVDir );

            mr.dwMDIdentifier = MD_VR_PATH;
            mr.dwMDAttributes = METADATA_INHERIT;
            mr.dwMDUserType   = IIS_MD_UT_FILE;
            mr.dwMDDataType   = STRING_METADATA;
            mr.dwMDDataLen    = (wcslen(pwszPhysicalPath) + 1) * sizeof(WCHAR);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(pwszPhysicalPath);

            // Write MD_VR_PATH value
            hr = pIMSAdminBase->SetData( hMetabase, pwszVDir, &mr );
        }
    }

    // set the key type to say this is a www vdir!
    if(SUCCEEDED(hr))
    {
        PWCHAR  szKeyType = IIS_CLASS_WEB_VDIR_W;

        mr.dwMDIdentifier = MD_KEY_TYPE;
        mr.dwMDAttributes = 0;   // no need for inheritence
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = (wcslen(szKeyType) + 1) * sizeof(WCHAR);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szKeyType);

        // Write value
        hr = pIMSAdminBase->SetData( hMetabase, pwszVDir, &mr );
    }

    // set access permissions
    if (dwPermissions != -1)
    {
        if(SUCCEEDED(hr)) 
        {
            dwAccessPerm = dwPermissions;

            mr.dwMDIdentifier = MD_ACCESS_PERM;
            mr.dwMDAttributes = METADATA_INHERIT;    // Make it inheritable so all subdirectories will have the same rights.
            mr.dwMDUserType   = IIS_MD_UT_FILE;
            mr.dwMDDataType   = DWORD_METADATA;
            mr.dwMDDataLen    = sizeof(DWORD);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAccessPerm);

            // Write MD_ACCESS_PERM value
            hr = pIMSAdminBase->SetData( hMetabase, pwszVDir, &mr );
        }
    }

    // if all that succeeded, then try to create the application, if they wanted one
    if (iApplicationType != -1)
    {
        if(SUCCEEDED(hr)) 
        {
            // Create the path
            // create an in process application
            CString csThePath;
            csThePath = pwszMetabasePath;
            csThePath += _T('/');
            csThePath += pwszVDir;

            if (iApplicationType == 1)
            {
                CreateInProc(csThePath, FALSE);
            }
            else
            {
                // create a pooled application
                CreateInProc(csThePath, TRUE);
            }
        }
    }

    pIMSAdminBase->CloseKey( hMetabase );

AddVirtualDir_Exit:
    if FAILED(hr)
        {iisDebugOut((LOG_TYPE_ERROR, _T("AddVirtualDir:FAILED 0x%x\n"),hr));}
    return hr;
}

int RemoveMetabaseFilter(TCHAR * szFilterName, int iRemoveMetabaseNodes)
{
    iisDebugOut_Start(_T("RemoveMetabaseFilter"),LOG_TYPE_TRACE);
    int iReturn = FALSE;
    CString csOrder;
    CString csLookingFor;
    CMDKey  cmdKey;

    // zero out the order string
    csOrder.Empty();

    // open the key to the virtual server, which is what is passed in as a parameter
    cmdKey.OpenNode( _T("LM/W3SVC/Filters") );
    if ( (METADATA_HANDLE)cmdKey )
    {
		BOOL    bReturn;
        DWORD dwAttr = METADATA_NO_ATTRIBUTES;
        DWORD dwUType = IIS_MD_UT_SERVER;
        DWORD dwDType = STRING_METADATA;
        DWORD dwLength = 0;

        // we need to start this process by getting the existing multisz data from the metabase
        // first, figure out how much memory we will need to do this
        cmdKey.GetData( MD_FILTER_LOAD_ORDER,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA);

        // give the buffer some head space
        // dwLength += 2;
        bReturn = FALSE;
        if (dwLength > 0)
        {
            // now get the real data from the metabase
            bReturn = cmdKey.GetData( MD_FILTER_LOAD_ORDER,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)csOrder.GetBuffer( dwLength ),dwLength,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA );
            csOrder.ReleaseBuffer();
        }

        // the data doesn't get written out here, so close the metabase key
        cmdKey.Close();

        // if reading the value from the metabase didn't work, zero out the string
        if ( !bReturn )
            {csOrder.Empty();}
    }

    // if there is something in the order string from the upgrade
	// then we need to look thru it
    if ( !csOrder.IsEmpty() )
    {
		csOrder.MakeLower();
        csLookingFor = szFilterName;
        csLookingFor.MakeLower();
		if (csOrder.Find(csLookingFor) != -1)
		{
			CStringList     cslStringListTemp;
			CString         csOneEntry;
			POSITION        pos;
			int             numInList;
			int             bFound;

			numInList = ConvertSepLineToStringList(csOrder,cslStringListTemp,_T(","));
			bFound = FALSE;
			pos = cslStringListTemp.GetHeadPosition();
			while (pos)
			{
                csOneEntry = cslStringListTemp.GetAt(pos);
				csOneEntry.TrimLeft();
				csOneEntry.TrimRight();
				// Does this contain our filter?
				if (_tcsicmp(csOneEntry, szFilterName) == 0)
				{
					// Here it is, let's delete it.
					if ( NULL != pos )
						{
                        cslStringListTemp.RemoveAt(pos);
                        }
					// break out of the loop
					bFound = TRUE;
					break;
				}
				// get the next one
				cslStringListTemp.GetNext(pos);
			}

			// if we found and deleted it then
			// go and write out the new string!
			if (bFound)
			{
				// convert the stringlist back into the comma delimited cstring.
				ConvertStringListToSepLine(cslStringListTemp,csOrder,_T(","));
				// write it out
				WriteToMD_Filters_List_Entry(csOrder);
			}
		}
    }

	if (iRemoveMetabaseNodes)
	{
		// let's remove the metabase node as well!

		// delete the metabase node.
		if (CheckifServiceExist(_T("IISADMIN")) == 0 ) 
		{

			cmdKey.OpenNode(_T("LM/W3SVC/Filters"));
			if ( (METADATA_HANDLE)cmdKey ) 
			{
				cmdKey.DeleteNode(szFilterName);
				cmdKey.Close();
			}
		}
	}


//RemoveMetabaseFilter_Exit:
    iisDebugOut_End1(_T("RemoveMetabaseFilter"),csOrder,LOG_TYPE_TRACE);
	return iReturn;
}


int GetIncompatibleFilters(CString csTheSection, CStringArray& arrayName,CStringArray& arrayPath)
{
    int c = 0;
    CString csName = _T("");
    CString csPath = _T("");

    CStringList strList;

    iisDebugOut((LOG_TYPE_TRACE, _T("ProcessFilters:%s\n"),csTheSection));
    if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTheSection))
    {
    if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, csTheSection))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos = NULL;
            CString csEntry;
            pos = strList.GetHeadPosition();
            while (pos)
            {
                csEntry = _T("");
                csEntry = strList.GetAt(pos);
                // Split into name, and value. look for ","
                int i;
                i = csEntry.ReverseFind(_T(','));
                if (i != -1)
                {
                    int len =0;
                    len = csEntry.GetLength();
                    csPath = csEntry.Right(len - i - 1);
                    csName = csEntry.Left(i);

                    // Add it to our array...
                    arrayName.Add(csName);
                    arrayPath.Add(csPath);
                    c++;
                }
                else
                {
                    // Add it to our array...
                    arrayName.Add(csEntry);
                    arrayPath.Add(csEntry);
                    c++;
                }

                strList.GetNext(pos);
            }
        }
    }
    }
    return c;
}

BOOL IsStringInArray(CString csItem, CStringArray &arrayInput)
{
    BOOL bReturn = FALSE;
    int nArrayItems = (int) arrayInput.GetSize();

    if (nArrayItems <= 0)
    {
        goto IsCStringInArray_Exit;
    }

    // Does this contain our filtername?
    for (int iCount=0; iCount<nArrayItems; iCount++)
	{
        if (_tcsicmp(csItem, arrayInput[iCount]) == 0)
        {
            // we found the entry
            bReturn =  TRUE;
            goto IsCStringInArray_Exit;
        }
    }
    bReturn = FALSE;

IsCStringInArray_Exit:
    return bReturn;
}

int RemoveIncompatibleMetabaseFilters(CString csSectionName,int iRemoveMetabaseNodes)
{
    DWORD dwReturn = ERROR_SUCCESS;
    CMDKey cmdKey;
    int iBadFiltersCount=0,iCount=0;
    CString csOrder;
    CString csOneEntry;
    CString csRemovedFilters;
    CStringList cslStringListTemp;
    CStringArray arrayName, arrayPath;
    BOOL bFound = FALSE;
    POSITION pos1,pos2 = NULL;
    INT     nArrayItems;

	BOOL  bReturn = FALSE;
	DWORD dwAttr = METADATA_NO_ATTRIBUTES;
	DWORD dwUType = IIS_MD_UT_SERVER;
	DWORD dwDType = STRING_METADATA;
	DWORD dwLength = 0;

    iisDebugOut_Start(_T("RemoveIncompatibleMetabaseFilters"),LOG_TYPE_TRACE);

    // Add Required Filters to the arrayName
    csOrder.Empty();
    iBadFiltersCount = GetIncompatibleFilters(csSectionName, arrayName, arrayPath);
    nArrayItems = (INT)arrayName.GetSize();
    if (nArrayItems <= 0)
    {
        goto RemoveIncompatibleMetabaseFilters_Exit;
    }
       
	// open the existing key in the metabase and get that value
	cmdKey.OpenNode( _T("LM/W3SVC/Filters") );
	if ( !(METADATA_HANDLE)cmdKey )
	{
		goto RemoveIncompatibleMetabaseFilters_Exit;
	}

	// we need to start this process by getting the existing multisz data from the metabase
	// first, figure out how much memory we will need to do this
	cmdKey.GetData( MD_FILTER_LOAD_ORDER,&dwAttr,&dwUType,&dwDType,&dwLength,NULL,0,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA);
	bReturn = FALSE;
	if (dwLength > 0)
	{
		// now get the real data from the metabase
		bReturn = cmdKey.GetData( MD_FILTER_LOAD_ORDER,&dwAttr,&dwUType,&dwDType,&dwLength,(PUCHAR)csOrder.GetBuffer( dwLength ),dwLength,METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA );
		csOrder.ReleaseBuffer();
	}
	cmdKey.Close();
	if ( !bReturn ) 
	{
		csOrder.Empty();
		goto RemoveIncompatibleMetabaseFilters_Exit;
	}
	
	// if there is nothing in order then get out
    if ( csOrder.IsEmpty() )
    {
        goto RemoveIncompatibleMetabaseFilters_Exit;
    }

    // split up the comma delimited csOrder entry into string list.
	bFound = FALSE;
    ConvertSepLineToStringList(csOrder,cslStringListTemp,_T(","));

    for( pos1 = cslStringListTemp.GetHeadPosition(); ( pos2 = pos1 ) != NULL; )
    {
        csOneEntry = cslStringListTemp.GetNext(pos1);
        csOneEntry.TrimLeft();
        csOneEntry.TrimRight();
        // Does this contain our filtername?
        if (TRUE == IsStringInArray(csOneEntry,arrayName))
        {
            csRemovedFilters += _T(',') + csOneEntry;
            cslStringListTemp.RemoveAt(pos2);
            bFound = TRUE;
        }
    }

    // now we have csOrder=f1,f2,f3,sspifilt
    if (bFound)
    {
        if (cslStringListTemp.IsEmpty())
        {
            // hardcode this entry in
            csOrder = _T(" ");
            dwReturn = WriteToMD_Filters_List_Entry(csOrder);
        }
        else
        {
            // convert the stringlist back into the comma delimited cstring.
            ConvertStringListToSepLine(cslStringListTemp,csOrder,_T(","));

            dwReturn = WriteToMD_Filters_List_Entry(csOrder);
        }
	    if (iRemoveMetabaseNodes)
	    {
            if (ERROR_SUCCESS == dwReturn)
            {
		        // let's remove the metabase node as well!
		        // delete the metabase node.
		        if (CheckifServiceExist(_T("IISADMIN")) == 0 ) 
		        {
                    int i = 0;
                    // loop thru the list of bad filters to remove and remove them.
                    i = csRemovedFilters.ReverseFind(_T(','));
                    while (i != -1)
                    {
                        int len = csRemovedFilters.GetLength();
                        csOneEntry = csRemovedFilters.Right(len - i - 1);

                        if (_tcsicmp(csOneEntry, _T("")) != 0)
                        {
			                cmdKey.OpenNode(_T("LM/W3SVC/Filters"));
			                if ( (METADATA_HANDLE)cmdKey ) 
			                {
				                cmdKey.DeleteNode(csOneEntry);
				                cmdKey.Close();
			                }
                        }
                        csRemovedFilters = csRemovedFilters.Left(i);
                        i = csRemovedFilters.ReverseFind(_T(','));
                    }
		        }
            }
        }
    }

RemoveIncompatibleMetabaseFilters_Exit:
    iisDebugOut_End(_T("RemoveIncompatibleMetabaseFilters"),LOG_TYPE_TRACE);
    return dwReturn;
}

int DoesAppIsolatedExist(CString csKeyPath)
{
    int iReturn = false;
    MDEntry stMDEntry;
    DWORD dwValue = 0;

    // LM/W3SVC/1/ROOT/something
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_APP_ISOLATED;
    stMDEntry.dwMDAttributes = METADATA_INHERIT;
    stMDEntry.dwMDUserType = IIS_MD_UT_FILE;
    stMDEntry.dwMDDataType = DWORD_METADATA;
    stMDEntry.dwMDDataLen = sizeof(DWORD);
    stMDEntry.pbMDData = (LPBYTE)&dwValue;

    if (ChkMdEntry_Exist(&stMDEntry))
    {
        iReturn = TRUE;
    }
    return iReturn;
}


DWORD WriteToMD_RootKeyType(void)
{
    DWORD dwReturn = ERROR_SUCCESS;
    MDEntry stMDEntry;
    CString csKeyType;
    CString csKeyPath = _T("/");

    csKeyType = _T("IIS_ROOT");
    stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csKeyPath;
    stMDEntry.dwMDIdentifier = MD_KEY_TYPE;
    stMDEntry.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
    stMDEntry.dwMDDataType = STRING_METADATA;
    stMDEntry.dwMDDataLen = (csKeyType.GetLength() + 1) * sizeof(TCHAR);
    stMDEntry.pbMDData = (LPBYTE)(LPCTSTR)csKeyType;
    dwReturn = SetMDEntry(&stMDEntry);

    return dwReturn;
}


void UpgradeFilters(CString csTheSection)
{
    if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
    {
        VerifyMD_Filters_WWW(csTheSection);
    }
    else
    {
        WriteToMD_Filters_WWW(csTheSection);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\massupdt.h ===
#ifndef _MASSUPDT_H_
#define _MASSUPDT_H_


//---------------------------------------------------------------
// Abstract class for mass property updates
class CMassPropertyUpdater : public CMDKey
{
public:
    CMassPropertyUpdater(DWORD dwMDIdentifier, DWORD dwMDDataType );
    ~CMassPropertyUpdater();

    // pass in the starting node
    virtual HRESULT Update( LPCTSTR strStartNode, BOOL fStopOnErrors = FALSE );

protected:
    // update at a certain path
    virtual HRESULT UpdateOne( LPWSTR strPath ) = 0;

    DWORD       m_dwMDIdentifier;
    DWORD       m_dwMDDataType;

    CStringList m_pathList;
};


//---------------------------------------------------------------
class CInvertScriptMaps : public CMassPropertyUpdater
{
public:
    CInvertScriptMaps():
        CMassPropertyUpdater(MD_SCRIPT_MAPS, MULTISZ_METADATA) {;}
    ~CInvertScriptMaps() {;}

protected:
    #define SZ_INVERT_ALL_VERBS  _T("OPTIONS,GET,HEAD,POST,PUT,DELETE,TRACE")

    // update at a certain path
    virtual HRESULT UpdateOne( LPWSTR strPath );
    HRESULT InvertOneScriptMap( CString& csMap );
};


//---------------------------------------------------------------
class CIPSecRefBitAdder : public CMassPropertyUpdater
{
public:
    CIPSecRefBitAdder():
        CMassPropertyUpdater(MD_IP_SEC, BINARY_METADATA) {;}
    ~CIPSecRefBitAdder() {;}

protected:
    // update at a certain path
    virtual HRESULT UpdateOne( LPWSTR strPath );
};


//---------------------------------------------------------------
// use this one for c:\windows\system type paths
class CPhysicalPathFixer : public CMassPropertyUpdater
{
public:
    CPhysicalPathFixer( CString& szOldSysPath, CString &szNewSysPath );
    ~CPhysicalPathFixer() {;}

    void SetPaths( CString& szOldSysPath, CString &szNewSysPath )
    { m_szOldSysPath = szOldSysPath; m_szNewSysPath = szNewSysPath; }

    // pass in the starting node
    virtual HRESULT Update( LPCTSTR strStartNode, BOOL fStopOnErrors = FALSE );

protected:
    // update at a certain path
    virtual HRESULT UpdateOne( LPWSTR strPath );
    HRESULT UpdateOneMULTISZ_DATA( LPWSTR strPath );
    HRESULT UpdateOneSTRING_DATA( LPWSTR strPath );
    HRESULT UpdateOneSTRING_DATA_EXPAND( LPWSTR strPath );

    HRESULT UpdateOnePath( CString& csPath );

    // instance variables
    CString     m_szOldSysPath;
    CString     m_szNewSysPath;
};

//---------------------------------------------------------------
// use this one for c:\windows type paths
class CPhysicalPathFixer2 : public CPhysicalPathFixer
{
public:
    CPhysicalPathFixer2( CString& szOldSysPath, CString &szNewSysPath ):
      CPhysicalPathFixer( szOldSysPath , szNewSysPath )
      {;}
    ~CPhysicalPathFixer2() {;}

    // pass in the starting node
    virtual HRESULT Update( LPCTSTR strStartNode, BOOL fStopOnErrors = FALSE );
};



//---------------------------------------------------------------
class CFixCustomErrors : public CMassPropertyUpdater
{
public:
    CFixCustomErrors():
        CMassPropertyUpdater(MD_CUSTOM_ERROR, MULTISZ_METADATA) {;}
    ~CFixCustomErrors() {;}

protected:

    // update at a certain path
    virtual HRESULT UpdateOne( LPWSTR strPath );
};



//---------------------------------------------------------------
class CEnforceMaxConnection : public CMassPropertyUpdater
{
public:
    CEnforceMaxConnection():
        CMassPropertyUpdater(MD_MAX_CONNECTIONS, DWORD_METADATA) {;}
    ~CEnforceMaxConnection() {;}

protected:

    // update at a certain path
    virtual HRESULT UpdateOne( LPWSTR strPath );
};




#endif //_MASSUPDT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\qfetools\spiisupd\spiisupd.cpp ===
//
//  This program was created to mirror the functions of the spiisupd.js file,
//  but as a standalone EXE, due to problems with AV programs and wscript
//  initialization during clean installs.
//


#include <stdio.h>
#include <io.h>
#include <malloc.h>
#include <windows.h>

#include <ntverp.h>


#define countof( a )    ( sizeof( (a) ) / sizeof( (a)[ 0 ] ) )

CHAR BadString1[] = "\tdocument.write('<A HREF=\"' + urlresult + '\">' + displayresult + \"</a>\");";
/* fixed again to NewString9
CHAR NewString1[] = "\tdocument.write( '<A HREF=\"' + escape(urlresult) + '\">\' + displayresult + \"</a>\");";
*/

CHAR BadString2[] = "    Response.Write \"?\" & Left(Request.QueryString, (lngPos - 1))";
CHAR NewString2[] = "    Response.Write \"?\" & Server.HTMLEncode(Left(Request.QueryString, (lngPos - 1)))";

CHAR BadString13[] = "<%= Request.ServerVariables(\"HTTP_USER_AGENT\") %>";
CHAR NewString13[] = "<%= Server.HTMLEncode(Request.ServerVariables(\"HTTP_USER_AGENT\")) %>";

// fix query.asp by shipping its new version
// string 4, 5, 6, 7, 8 are from query.asp
/*

CHAR BadString4[] = "        No documents matched the query <%=SearchString%>.<br><br>";
CHAR NewString4[] = "        No documents matched the query <%=Server.HTMLEncode(SearchString)%>.<br><br>";

CHAR BadString5[] = "*<%=CompSearch%>*";
CHAR NewString5[] = "*<%=Server.HTMLEncode(CompSearch)%>*";

CHAR BadString6[] = "        Session(\"SearchStringDisplay\")=SearchString";
CHAR NewString6[] = "        Session(\"SearchStringDisplay\")=Server.HTMLEncode(SearchString)";

CHAR BadString7[] = "            <INPUT TYPE=\"HIDDEN\" NAME=\"SearchString\" VALUE=\"<%=SearchString%>\">";
CHAR NewString7[] = "            <INPUT TYPE=\"HIDDEN\" NAME=\"SearchString\" VALUE=\"<%=Server.HTMLEncode(SearchString)%>\">";

CHAR BadString8[] = "\t<UL><LI>Let us know about this <a href=\"mailto:iisdocs@microsoft.com?subject=<%=SearchString%>-search%20term%20not%20matched&body=The%20term%20'<%=SearchString%>'%20produced%20no%20matches.\">(mailto:iisdocs@microsoft.com)</a> so that we can improve Search in future releases.";
CHAR NewString8[] = "\t<UL><LI>Let us know about this <a href=\"mailto:iisdocs@microsoft.com?subject=<%=Server.HTMLEncode(SearchString)%>-search%20term%20not%20matched&body=The%20term%20'<%=Server.HTMLEncode(SearchString)%>'%20produced%20no%20matches.\">(mailto:iisdocs@microsoft.com)</a> so that we can improve Search in future releases.";

*/

//{ WinSE 26475: CSS bug in custom error pages

CHAR BadString9[] = "\tdocument.write( '<A HREF=\"' + escape(urlresult) + '\">' + displayresult + \"</a>\");";
CHAR NewString9[] = "\tInsertElementAnchor(urlresult, displayresult);";

CHAR InsertCodeBefore1[] = "//-->";
CHAR InsertCodeBefore2[] = "</script>";

CHAR InsertCode9[] =
"\r\n"
"function HtmlEncode(text)\r\n"
"{\r\n"
"    return text.replace(/&/g, '&amp').replace(/'/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n"
"}\r\n"
"\r\n"
"function TagAttrib(name, value)\r\n"
"{\r\n"
"    return ' '+name+'=\"'+HtmlEncode(value)+'\"';\r\n"
"}\r\n"
"\r\n"
"function PrintTag(tagName, needCloseTag, attrib, inner){\r\n"
"    document.write( '<' + tagName + attrib + '>' + HtmlEncode(inner) );\r\n"
"    if (needCloseTag) document.write( '</' + tagName +'>' );\r\n"
"}\r\n"
"\r\n"
"function URI(href)\r\n"
"{\r\n"
"    IEVer = window.navigator.appVersion;\r\n"
"    IEVer = IEVer.substr( IEVer.indexOf('MSIE') + 5, 3 );\r\n"
"\r\n"
"    return (IEVer.charAt(1)=='.' && IEVer >= '5.5') ?\r\n"
"        encodeURI(href) :\r\n"
"        escape(href).replace(/%3A/g, ':').replace(/%3B/g, ';');\r\n"
"}\r\n"
"\r\n"
"function InsertElementAnchor(href, text)\r\n"
"{\r\n"
"    PrintTag('A', true, TagAttrib('HREF', URI(href)), text);\r\n"
"}\r\n"
"\r\n";


//} WinSE 26475

//{ German fixes
CHAR BadGoto[] = "  on error go to 0";
CHAR NewGoto[] = "  on error goto 0";

CHAR BadThen[] = "  If objASPError.ASPDescription > \"\" Then Response.Write Server.HTMLEncode(objASPError.ASPDescription) & \"<br>\"";
CHAR NewThen[] = "  If objASPError.ASPDescription > \"\" Then\r\n\tResponse.Write Server.HTMLEncode(objASPError.ASPDescription) & \"<br>\"";

//}

//{ winse 29084: css fixes for admin/document pages
// these are partial lines
CHAR BadDoc1[] = "= Request(";
CHAR BadDoc2[] = "= Request.Form(";
CHAR BadDoc3[] = "= Request.QueryString(";
CHAR BadDoc4[] = "= Request.Cookies(";
CHAR BadDoc5[] = "=Request(";
CHAR BadDoc6[] = "=Request.Form(";
CHAR BadDoc7[] = "=Request.QueryString(";
CHAR BadDoc8[] = "=Request.Cookies(";
CHAR BadDoc9[] = "= request.QueryString(";
CHAR BadDoc10[] = "& Request.QueryString(";
CHAR BadDoc11[] = "Response.write Request.Querystring";

CHAR FixDocCall1[] = "= NoAngles(Request(";
CHAR FixDocCall2[] = "= NoAngles(Request.Form(";
CHAR FixDocCall3[] = "= NoAngles(Request.QueryString(";
CHAR FixDocCall4[] = "= NoAngles(Request.Cookies(";
#define FixDocCall5 FixDocCall1
#define FixDocCall6 FixDocCall2
#define FixDocCall7 FixDocCall3
#define FixDocCall8 FixDocCall4
#define FixDocCall9 FixDocCall3
CHAR FixDocCall10[] = "& NoAngles(Request.QueryString(";
CHAR FixDocCall11[] = "";   // delete this junk

CHAR FixDocCallEnd[] = ")";		// place it after original ")" after Request call
CHAR FixDocNewFuncName[] = "NoAngles(str)";
CHAR FixDocNewFunc[] =			// place it at the end of the file if the above line isn't found in file
		"\r\n<%\r\n"
		"function NoAngles(str)\r\n"
		"  NoAngles = replace( replace(str, \"<\", \"\"), \">\", \"\")\r\n"
		"end function\r\n"
		"%>\r\n";

CHAR * DocFilesToFix[] = {

// file list is different for XP and Win2K, and NTOP

#if (VER_PRODUCTVERSION_W == 0x501)

    // list for IIS 5.1 (WinXP)
    "system32\\inetsrv\\iisadmpwd\\aexp2.asp",
    "system32\\inetsrv\\iisadmpwd\\aexp2b.asp",
    "system32\\inetsrv\\iisadmpwd\\aexp4.asp",

#elif (VER_PRODUCTVERSION_W == 0x400)

    // list for IIS 4
    "Help\\iis\\htm\\asp\\iiatmd1.asp",
    "Help\\iis\\htm\\asp\\iiatmd2.asp",
    "Help\\iis\\htm\\asp\\iiatmd3.asp",
    "Help\\iis\\htm\\asp\\iiselect.asp",
    "Help\\iis\\htm\\asp\\script1.asp",
    "Help\\iis\\htm\\asp\\script1a.asp",
    "Help\\iis\\htm\\tutorial\\script1.asp",
    "system32\\inetsrv\\iisadmin\\default.asp",
    "system32\\inetsrv\\iisadmin\\iiaction.asp",
    "system32\\inetsrv\\iisadmin\\iicache.asp",
    "system32\\inetsrv\\iisadmin\\iichkpath.asp",
    "system32\\inetsrv\\iisadmin\\iihdn.asp",
    "system32\\inetsrv\\iisadmin\\iipop.asp",
    "system32\\inetsrv\\iisadmin\\iipophd.asp",
    "system32\\inetsrv\\iisadmin\\iirename.asp",
    "system32\\inetsrv\\iisadmin\\iirtels.asp",
    "system32\\inetsrv\\iisadmin\\iiscript.asp",
    "system32\\inetsrv\\iisadmin\\iisess.asp",
    "system32\\inetsrv\\iisadmin\\iiset.asp",
    "system32\\inetsrv\\iisadmin\\iislider.asp",
    "system32\\inetsrv\\iisadmin\\iistat.asp",
    "system32\\inetsrv\\iisadmin\\jsbrowser\\jsbrwpop.asp",

#else

    // list for Win2K
	"Help\\iisHelp\\iis\\htm\\asp\\iiatmd1.asp",
	"Help\\iisHelp\\iis\\htm\\asp\\iiatmd2.asp",
	"Help\\iisHelp\\iis\\htm\\asp\\iiatmd3.asp",
	"Help\\iisHelp\\iis\\htm\\asp\\iiselect.asp",
	"Help\\iisHelp\\iis\\htm\\tutorial\\script1.asp",
	"system32\\inetsrv\\iisadmin\\default.asp",
	"system32\\inetsrv\\iisadmin\\iiaddnew.asp",
	"system32\\inetsrv\\iisadmin\\iicache.asp",
	"system32\\inetsrv\\iisadmin\\iicache2.asp",
	"system32\\inetsrv\\iisadmin\\iichknname.asp",
	"system32\\inetsrv\\iisadmin\\iichkpath.asp",
	"system32\\inetsrv\\iisadmin\\iichkuser.asp",
	"system32\\inetsrv\\iisadmin\\iihdn.asp",
	"system32\\inetsrv\\iisadmin\\iipop.asp",
	"system32\\inetsrv\\iisadmin\\iipophd.asp",
	"system32\\inetsrv\\iisadmin\\iirename.asp",
	"system32\\inetsrv\\iisadmin\\iiscript.asp",
	"system32\\inetsrv\\iisadmin\\iisess.asp",
	"system32\\inetsrv\\iisadmin\\iiset.asp",
	"system32\\inetsrv\\iisadmin\\iislider.asp",
	"system32\\inetsrv\\iisadmin\\iistat.asp",
	"system32\\inetsrv\\iisadmin\\jsbrowser\\jsbrwpop.asp",

#endif
	NULL
};

//}

CHAR BadKanaler[] = "<h2><a name=\"H2_37780216\"><a name=\"channels\">Skapa dynamiska analer</a></a></h2>";
CHAR NewKanaler[] = "<h2><a name=\"H2_37780216\"><a name=\"channels\">Skapa dynamiska kanaler</a></a></h2>";

CHAR KanalerPath[ MAX_PATH ] = { '\0' };


void
LogMessage( CHAR *msg, ...)
{
    static char buf[200];
    va_list args;
    va_start(args, msg);
    vsprintf(buf, msg, args);
    OutputDebugString(buf);
}

class TextFile {

public:

    TextFile( void );
    BOOL Open( CHAR * pszFileName );
    BOOL GetLine( CHAR * pszBuffer, int cchBuffer );
    void Close( void );
    ~TextFile();

private:

    FILE * m_File;
    BOOL   m_fUnicode;
};


TextFile::TextFile( void )
{
    m_File = NULL;
}


TextFile::~TextFile()
{
    Close();
}


void
TextFile::Close( void )
{
    if ( m_File != NULL ) {

        fclose( m_File );
        m_File = NULL;
        }
}


BOOL
TextFile::Open(
    CHAR * pszFileName
    )
{
    Close();

    m_File = fopen( pszFileName, "rb" );

    if ( m_File == NULL ) {

        return( FALSE );
        }

    if (( fgetc( m_File ) == 0xFF ) &&
        ( fgetc( m_File ) == 0xFE )) {

        m_fUnicode = TRUE;
        }
    else {

        fseek( m_File, 0, SEEK_SET );
        m_fUnicode = FALSE;
        }

    return( TRUE );
}


BOOL
TextFile::GetLine( CHAR * pszBuffer, int cchBuffer )
{
    int c = EOF;
    int fSomethingRead = FALSE;

    if (( m_File == NULL ) ||
        ( cchBuffer == 0 )) {

        return FALSE;
        }

    while ( cchBuffer > 1 ) {

        c = fgetc( m_File );

        if ( m_fUnicode && ( c != EOF )) {

            c += ( fgetc( m_File ) << 8 );
            }

        if (( c == EOF ) || ( c == '\n' )) {

            break;
            }

        if ( c == '\r' ) {

            continue;
            }

        *pszBuffer++ = (CHAR) c;
        cchBuffer--;        
        fSomethingRead = TRUE;
        }

    *pszBuffer = '\0';

    if ( c == EOF ) {

        return( fSomethingRead );
        }

    return( TRUE );
}


void
TrimString(
    CHAR * StrLine
    )
{
    CHAR * StrOut = StrLine;
    BOOL fQuoted = FALSE;

    while ( *StrLine ) {

        switch ( *StrLine ) {

        case '"':

            *StrOut++ = *StrLine++;
            fQuoted = !fQuoted;
            break;

        case ' ':
        case '\t':

            if ( fQuoted ) {

                *StrOut++ = *StrLine++;
                }

            else {

                StrLine++;
                }
            break;

        case ';':

            if ( fQuoted ) {

                *StrOut++ = *StrLine++;
                }

            else {

                *StrLine = '\0';
                }
            break;

        case '\r':
        case '\n':

            *StrLine = '\0';
            break;

        default:

            *StrOut++ = *StrLine++;
            }
        }

    *StrOut = '\0';

    return;
}


CHAR *
GetErrLocation(
    CHAR * WinDir
    )
{
    CHAR filename[ MAX_PATH ];

    strcpy( filename, WinDir );
    strcat( filename, "\\inf\\iis.inf" );

    CHAR FoundPath[ MAX_PATH ] = { '\0' };

    TextFile objFile;

    if ( objFile.Open( filename ) ) {

        CHAR StrLine[ 3000 ];
        BOOL SectionOpened = FALSE;

        while ( objFile.GetLine( StrLine, sizeof( StrLine ))) {

            TrimString( StrLine );

            _strlwr( StrLine );

            if ( ! SectionOpened ) {

                if ( strcmp( StrLine, "[destinationdirs]" ) == 0 ) {

                    SectionOpened = TRUE;
                    }
                }

            else {

                if ( StrLine[ 0 ] == '[' ) {

                    SectionOpened = FALSE;
                    break;
                    }

                if ( strncmp( StrLine, "iisdoc_files_common=18,", 23 ) == 0 ) {

                    strcpy( FoundPath, StrLine + 23 );
                    }

                if ( strncmp( StrLine, "iisdoc_files_asp=18,", 20 ) == 0 ) {

                    strcpy( KanalerPath, WinDir );
                    strcat( KanalerPath, "\\help\\" );
                    strcat( KanalerPath, StrLine + 20 );
                    }
                }
            }

        objFile.Close();
        }

    static CHAR szResult[ MAX_PATH ];

    strcpy( szResult, WinDir );
    strcat( szResult, "\\help\\" );
    strcat( szResult, FoundPath );

    return( szResult );
}


CHAR **
GetErrArray(
    CHAR * WinDir
    )
{
    CHAR filename[ MAX_PATH ];

    strcpy( filename, WinDir );
    strcat( filename, "\\inf\\iis.inf" );

    static CHAR * ArrayFiles[ 50 ];

    int i = 0;

    TextFile objFile;

    if ( objFile.Open( filename ) ) {

        CHAR StrLine[ 3000 ];
        BOOL SectionOpened = FALSE;

        while ( objFile.GetLine( StrLine, sizeof( StrLine ))) {

            TrimString( StrLine );

            _strlwr( StrLine );

            if ( ! SectionOpened ) {

                if ( strcmp( StrLine, "[iis_www_files_custerr]" ) == 0 ) {

                    SectionOpened = TRUE;
                    }
                }

            else {

                if ( StrLine[ 0 ] == '[' ) {

                    SectionOpened = FALSE;
                    break;
                    }

                CHAR * Comma = strchr( StrLine, ',' );

                if ( Comma != NULL ) {

                    *Comma = '\0';

                    if ( strcmp( StrLine, "htmla.htm" ) != 0 ) {

                        ArrayFiles[ i++ ] = _strdup( StrLine );

                        if ( i >= ( countof( ArrayFiles ) - 1 )) {

                            break;
                            }
                        }
                    }
                }
            }

        objFile.Close();
        }

    ArrayFiles[ i ] = NULL;

    return ArrayFiles;
}

#define MATCHED( BadText )                                              \
                                                                        \
    (( LineLength == strlen( BadText )) &&                            \
     ( strncmp( LineStart, BadText, strlen( BadText )) == 0 ))        \


#define REPLACE( BadText, GoodText ) {                                  \
                                                                        \
    int NetChange = int(strlen( GoodText ) - strlen( BadText ));    \
    int FileRemaining = int(FileEnd - LineEnd);                         \
                                                                        \
    memmove( LineEnd + NetChange,                                       \
             LineEnd,                                                   \
             FileRemaining + 1                                          \
             );                                                         \
                                                                        \
    memmove( LineStart,                                                 \
             GoodText,                                                  \
             strlen( GoodText )                                       \
             );                                                         \
                                                                        \
    FileSize += NetChange;                                              \
    LineEnd  += NetChange;                                              \
    FileEnd  += NetChange;                                              \
    }

#define INSERT( NewText )	{		                                  \
                                                                        \
    int NetChange = int(strlen( NewText ));							\
    int FileRemaining = int(FileEnd - LineStart);                         \
                                                                        \
    memmove( LineStart + NetChange,                                       \
             LineStart,                                                   \
             FileRemaining + 1                                          \
             );                                                         \
                                                                        \
    memmove( LineStart,                                                 \
             NewText,                                                  \
             strlen( NewText )                                        \
             );                                                         \
                                                                        \
    FileSize += NetChange;                                              \
    LineEnd  += NetChange;                                              \
    FileEnd  += NetChange;                                              \
    }

DWORD
ReadTargetFile(
	CHAR * Base,
	CHAR * Filename,
	CHAR * buffer,
	DWORD  size)
{
	DWORD fileSize=0;
	DWORD readSize=0;

    CHAR filename[ MAX_PATH ];

    strcpy( filename, Base );
    strcat( filename, "\\" );
    strcat( filename, Filename );

    LogMessage( "Reading :%s\n", filename );

    FILE * objFile = fopen( filename, "rb" );

    if ( objFile != NULL ) {

        fileSize = _filelength( _fileno( objFile ));

        if (( fileSize > 0 ) &&
            ( fileSize < size-2000 ) &&
            ( fileSize != -1L )) {

            buffer[ fileSize ] = 0;

            if ( fread( buffer, 1, fileSize, objFile ) == fileSize )
			{
				readSize = fileSize+1;	// one byte for null terminator
			}
		}

		fclose(objFile);
	}

	return readSize;
}


bool
WriteTargetFile(
	CHAR * Base,
	CHAR * Filename,
	CHAR * content,
	DWORD  size)
{
	if (size == 0) return false;
	size--;		// exclude null terminator

    CHAR filename[ MAX_PATH ];

    strcpy( filename, Base );
    strcat( filename, "\\" );
    strcat( filename, Filename );

    LogMessage( "Writing :%s\n", filename );

    FILE *objFile = fopen( filename, "wb" );

    if ( objFile != NULL ) {

        fwrite( content, 1, size, objFile );
        fclose( objFile );
		return true;
        }

    else {

        LogMessage( "Unable to open %s\n", filename );
		return false;
        }
}


bool
PatchFile(
    CHAR * Base,
    CHAR * Filename,
    CHAR * BadStrings[],
    CHAR * NewStrings[]
    )
{
    long FileSize;
    CHAR FileBuffer[41000];		// max file to patch: 40K

	FileSize = ReadTargetFile(Base, Filename, FileBuffer, sizeof(FileBuffer));

	if (FileSize==0) return false;

    BOOL FoundBad = FALSE;
    int  Insert9 = 0;

    CHAR * LineStart = FileBuffer;
    CHAR * FileEnd = FileBuffer + FileSize;

    while ( LineStart < FileEnd )
    {

        while (( LineStart < FileEnd ) &&
               (( *LineStart == '\r' ) || ( *LineStart == '\n' ))) {

            LineStart++;
            }

        CHAR * LineEnd = LineStart;

        while (( LineEnd < FileEnd ) &&
               ( *LineEnd != '\r' ) &&
               ( *LineEnd != '\n' )) {

            LineEnd++;
            }

        if ( LineEnd < FileEnd )
        {

            DWORD LineLength = int(LineEnd - LineStart);

            CHAR **Bad = BadStrings;
            CHAR **New = NewStrings;

            while (*Bad)
            {
                if ( MATCHED( *Bad ))
                {

                    REPLACE( *Bad, *New );

                    FoundBad = TRUE;

                    // replacing bad strings #9 require us to insert function
                    if (*New == NewString9)
                    {
                        Insert9 |= 1;
                    }

                    break;
                    
                }

                Bad++;
                New++;
                
            }
            
            if (! *Bad)
            {
                // insert code at the end of script block, if we have code to insert
                if (Insert9==1)
                {
                    if ( MATCHED( InsertCodeBefore1 ) || MATCHED( InsertCodeBefore2 ) )
                    {
                        INSERT( InsertCode9 );

                        // flag as inserted
                        Insert9=2;
                    }
                }
            }

        }

        LineStart = LineEnd;
    }

    if ( FoundBad )
	{
		return WriteTargetFile(Base, Filename, FileBuffer, FileSize);
    }

    return true;
}

bool
PatchFile2(
    CHAR * Base,
    CHAR * Filename,
    CHAR * BadStrings[],
    CHAR * NewStrings[],
	CHAR * newStringAtEndCall,
	CHAR * newFunctionName,
	CHAR * newFunction
    )
{
	bool foundBad = false;

	CHAR content[41000];	// max file size to patch: 40K
	DWORD fileSize = ReadTargetFile(Base, Filename, content, sizeof(content));

	if (fileSize==0) return false;

	bool newFuncExists = (strstr(content, newFunctionName)!=NULL);

	CHAR ** pBad = BadStrings;
	CHAR ** pFix = NewStrings;

	while (*pBad!=NULL)
	{
		int sizeOld = strlen( *pBad );
		int sizeNew = strlen( *pFix );
	    int sizeDiff = sizeNew - sizeOld;

		// scan through the whole content
		char *p = content;

		while ( (p=strstr(p, *pBad)) != NULL)
		{
			foundBad = true;

			// replace old string with new string
			memmove(p+sizeNew, p+sizeOld, fileSize-(p+sizeOld-content));
			memmove(p, *pFix, sizeNew);
			fileSize += sizeDiff;

			p += sizeNew;

            // if we have a newStringAtEndCall
            // and we are not deleting this string (*pFix is empty string)
			if (newStringAtEndCall && *newStringAtEndCall && **pFix)
			{
				char *pEndCall = strchr(p, ')');

				if ( pEndCall )
				{
					// insert new string at end of function call
					++pEndCall;
					int sizeDiff = strlen(newStringAtEndCall);
					memmove(pEndCall+sizeDiff, pEndCall, fileSize-(pEndCall-content));
					memmove(pEndCall, newStringAtEndCall, sizeDiff);
					fileSize += sizeDiff;

					p = pEndCall+sizeDiff;
				}
			}
		}

		pBad++;
		pFix++;
	}

	if (foundBad)
	{
		if (! newFuncExists)
		{
			strcat(content, newFunction);
			fileSize += strlen(newFunction);
		}

		return WriteTargetFile(Base, Filename, content, fileSize);
	}

	return true;
}


int WINAPI
WinMain(
    HINSTANCE hInstance, 
    HINSTANCE hPrevInstance, 
    LPSTR lpCmdLine, 
    int nShowCmd )
{
    int i;

    CHAR StrWINDIR[ MAX_PATH ];

    GetEnvironmentVariable( "WINDIR",
                            StrWINDIR,
                            sizeof( StrWINDIR )
                            );

    CHAR *BadStrings[20];
    CHAR *NewStrings[20];

	// == fixing custom error pages ==
#if !(VER_PRODUCTVERSION_W == 0x400)

    BadStrings[0] = BadString1;
    NewStrings[0] = NewString9;
    BadStrings[1] = BadString2;
    NewStrings[1] = NewString2;
    BadStrings[2] = BadGoto;
    NewStrings[2] = NewGoto;
    BadStrings[3] = BadString9;
    NewStrings[3] = NewString9;
    BadStrings[4] = BadString13;
    NewStrings[4] = NewString13;
    BadStrings[5] = BadThen;
    NewStrings[5] = NewThen;
    BadStrings[6] = NULL;

    CHAR * BasePath = GetErrLocation( StrWINDIR );
    CHAR ** ArrayNames = GetErrArray( StrWINDIR );

    LogMessage( "Processing %s\n", BasePath );

    for ( i = 0; ArrayNames[ i ] != NULL; i++ ) {

        __try {

            PatchFile( BasePath, ArrayNames[ i ], BadStrings, NewStrings );
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {

            }
        }

    if ( KanalerPath[ 0 ] != '\0' ) {

        BadStrings[0] = BadKanaler;
        NewStrings[0] = NewKanaler;
        BadStrings[1] = BadGoto;
        NewStrings[1] = NewGoto;
        BadStrings[2] = NULL;

        LogMessage( "Processing %s\n", KanalerPath );

        __try {

            PatchFile( KanalerPath, "iiwacont.htm", BadStrings, NewStrings );
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {

            }
        }

#endif // !(VER_PRODUCTVERSION_W == 0x400)

// fix query.asp by shipping its new version
/*
    BadStrings[0] = BadString4;
    NewStrings[0] = NewString4;
    BadStrings[1] = BadString5;
    NewStrings[1] = NewString5;
    BadStrings[2] = BadString6;
    NewStrings[2] = NewString6;
    BadStrings[3] = BadString7;
    NewStrings[3] = NewString7;
    BadStrings[4] = BadString8;
    NewStrings[4] = NewString8;
    BadStrings[5] = NULL;

    __try {

        PatchFile( BasePath, "..\\iis\\misc\\query.asp", BadStrings, NewStrings );
        }

    __except( EXCEPTION_EXECUTE_HANDLER ) {

        }
*/

	// == fixing asp help docs and admin pages ==

	BadStrings[0] = BadDoc1;
	NewStrings[0] = FixDocCall1;
	BadStrings[1] = BadDoc2;
	NewStrings[1] = FixDocCall2;
	BadStrings[2] = BadDoc3;
	NewStrings[2] = FixDocCall3;
	BadStrings[3] = BadDoc4;
	NewStrings[3] = FixDocCall4;
	BadStrings[4] = BadDoc5;
	NewStrings[4] = FixDocCall5;
	BadStrings[5] = BadDoc6;
	NewStrings[5] = FixDocCall6;
	BadStrings[6] = BadDoc7;
	NewStrings[6] = FixDocCall7;
	BadStrings[7] = BadDoc8;
	NewStrings[7] = FixDocCall8;
	BadStrings[8] = BadDoc9;
	NewStrings[8] = FixDocCall9;
	BadStrings[9] = BadDoc10;
	NewStrings[9] = FixDocCall10;
	BadStrings[10] = BadDoc11;
	NewStrings[10] = FixDocCall11;
	BadStrings[11] = NULL;

	for (CHAR **pDocFiles=DocFilesToFix; *pDocFiles; pDocFiles++)
	{
		__try {

			PatchFile2( StrWINDIR, *pDocFiles, BadStrings, NewStrings, FixDocCallEnd, FixDocNewFuncName, FixDocNewFunc );
			}

		__except( EXCEPTION_EXECUTE_HANDLER ) {

			}
	}

    LogMessage( "Done" );

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\mdentry.h ===
#ifndef _MDENTRY_H_
#define _MDENTRY_H_

class CDWord : public CObject
{
protected:
    DWORD m_dwData;

public:
    CDWord(DWORD dwData) { m_dwData = dwData; }
    ~CDWord() {};

    operator DWORD () { return m_dwData; }
};

// fMigrate, fKeepOldReg, hRegRootKey, szRegSubKey, szRegValueName, 
// szMDPath, dwMDId, dwMDAttr, dwMDuType, dwMDdType, dwMDDataLen, szMDData 

typedef struct _MDEntry {
    LPTSTR szMDPath;
    DWORD dwMDIdentifier;
    DWORD dwMDAttributes;
    DWORD dwMDUserType;
    DWORD dwMDDataType;
    DWORD dwMDDataLen;
    LPBYTE pbMDData;
} MDEntry;

DWORD atodw(LPCTSTR lpszData);
BOOL SplitLine(LPTSTR szLine, INT iExpectedNumOfFields);
INT  GetMDEntryFromInfLine(LPTSTR szLine, MDEntry *pMDEntry);
int  WWW_Upgrade_RegToMetabase(HINF hInf);
int  FTP_Upgrade_RegToMetabase(HINF hInf);
void CreateWWWVRMap(CMapStringToOb *pMap);
void CreateFTPVRMap(CMapStringToOb *pMap);
void EmptyMap(CMapStringToOb *pMap);
void AddVRootsToMD(LPCTSTR szSvcName);
void AddVRMapToMD(LPCTSTR szSvcName, CMapStringToOb *pMap);
int  GetPortNum(LPCTSTR szSvcName);
void ApplyGlobalToMDVRootTree(CString csKeyPath, CMapStringToString *pGlobalObj);

void AddMDVRootTree(CString csKeyPath, CString csName, CString csValue, LPCTSTR pszIP, UINT nProgressBarTextWebInstance);
void CreateMDVRootTree(CString csKeyPath, CString csName, CString csValue, LPCTSTR pszIP);
void SplitVRString(CString csValue, LPTSTR szPath, LPTSTR szUserName, DWORD *pdwPerm);
UINT GetInstNumber(LPCTSTR szMDPath, UINT i);
int  MigrateInfSectionToMD(HINF hInf, LPCTSTR szSection);

BOOL CreateMimeMapFromRegistry(CMapStringToString *pMap);
BOOL CreateMimeMapFromInfSection(CMapStringToString *pMap, HINF hFile, LPCTSTR szSection);
void ReadMimeMapFromInfSection(CMapStringToString *pMap, HINF hFile, LPCTSTR szSection, BOOL fAction);

void SetLogPlugInOrder(LPCTSTR lpszSvc);

DWORD GetSizeBasedOnMetaType(DWORD dwDataType,LPTSTR szString);
BOOL MDEntry_MoveValue(LPTSTR szLine);

void ReadMultiSZFromInfSection(CString *pcsMultiSZ, HINF hFile, LPCTSTR szSection);
void ReadMimeMapFromMetabase(CMapStringToString *pMap);
void IntegrateNewErrorsOnUpgrade( IN HINF hFile, IN LPCTSTR szSection );

BOOL ConfirmLocalHost(LPCTSTR lpszVirtServer);
void RemoveCannotDeleteVR( LPCTSTR pszService );

void UpdateVDCustomErrors();
DWORD UpgradeCryptoKeys(void);

DWORD SetMDEntry(MDEntry *pMDEntry);
DWORD SetMDEntry_NoOverWrite(MDEntry *pMDEntry);
DWORD SetMDEntry_Wrap(MDEntry *pMDEntry);

void  UpgradeFilters(CString csTheSection);
DWORD VerifyMD_Filters_WWW(CString csTheSection);
DWORD WriteToMD_Filters_WWW(CString csTheSection);
DWORD WriteToMD_Filters_List_Entry(CString csOrder);

DWORD WriteToMD_Filter_Entry(CString csFilter_Name, CString csFilter_Path);

BOOL VerifyMD_InProcessISAPIApps_WWW(IN LPCTSTR szSection);
DWORD WriteToMD_InProcessISAPIApps_WWW(IN LPCTSTR szSection);
DWORD WriteToMD_ISAPI_Entry(CString csISAPIDelimitedList);


DWORD WriteToMD_NTAuthenticationProviders_WWW(void);
DWORD VerifyMD_NTAuthenticationProviders_WWW(void);
DWORD WriteToMD_NTAuthenticationProviders_WWW(CString);
DWORD WriteToMD_Capabilities(LPCTSTR lpszSvc);

UINT  AddVirtualServer( LPCTSTR szSvcName, UINT i, CMapStringToString *pObj, CString& csRoot, CString& csIP);
void  CreateMDVRootTree(CString csKeyPath, CString csName, CString csValue, LPCTSTR pszIP, UINT nProgressBarTextWebInstance);
int   VerifyVRoots(LPCTSTR szSvcName);
DWORD WriteToMD_CertMapper(CString csKeyPath);
DWORD WriteToMD_AdminInstance(CString csKeyPath,CString& csInstNumber);
DWORD WriteToMD_Authorization(CString csKeyPath, DWORD dwValue);
DWORD WriteToMD_IIsWebServerInstance_WWW(CString csKeyPath);
DWORD WriteToMD_NotDeleteAble(CString csKeyPath);
DWORD WriteToMD_ServerSize(CString csKeyPath);
DWORD WriteToMD_ServerComment(CString csKeyPath, UINT iCommentID);
DWORD WriteToMD_ServerBindings_HTMLA(CString csKeyPath, UINT iPort);
DWORD HandleSecurityTemplates(LPCTSTR szSvcName);
DWORD WriteToMD_IPsec_GrantByDefault(CString csKeyPath);
DWORD WriteToMD_HttpExpires(CString csData);
DWORD WriteToMD_AnonymousOnly_FTP(CString csKeyPath);
DWORD WriteToMD_AllowAnonymous_FTP(CString csKeyPath);

DWORD WriteToMD_AnonymousUserName_FTP(int iUpgradeScenarioSoOnlyOverWriteIfAlreadyThere);
DWORD WriteToMD_AnonymousUserName_WWW(int iUpgradeScenarioSoOnlyOverWriteIfAlreadyThere);

int   AddRequiredISAPI(CStringArray& arrayName,CStringArray& arrayPath,IN LPCTSTR szSection);

BOOL  ChkMdEntry_Exist(MDEntry *pMDEntry);
DWORD WriteToMD_IWamUserName_WWW(void);
DWORD WriteToMD_CustomError_Entry(CString csKeyPath, CString csCustomErrorDelimitedList);
BOOL  VerifyCustomErrors_WWW(CString csKeyPath);
void  VerifyAllCustomErrorsRecursive(const CString& csTheNode);
void  MoveOldHelpFilesToNewLocation(void);
DWORD DeleteMDEntry(MDEntry *pMDEntry);
void  WriteToMD_ForceMetabaseToWriteToDisk(void);
void  VerifyMD_DefaultLoadFile_WWW(IN LPCTSTR szSection, CString csKeyPath);
INT Register_iis_www_handleScriptMap(void);
DWORD DoesAdminACLExist(CString csKeyPath);

int ReOrderFiltersSpecial(int nArrayItems, CStringArray& arrayName, CString& csOrder);
void AddFilter1ToFirstPosition(CString& csOrder,LPTSTR szFilter1);
void AddFilter1AfterFilter2(CString& csOrder,LPTSTR szFilter1,LPTSTR szFilter2);
void GetScriptMapListFromClean(ScriptMapNode *pList, IN LPCTSTR szSection);
int RemoveMetabaseFilter(TCHAR * szFilterName, int iRemoveMetabaseNodes);

DWORD WriteToMD_IDRegistration(CString csKeyPath);
DWORD WriteToMD_AspCodepage(CString csKeyPath, DWORD dwValue, int iOverWriteAlways);
DWORD WriteToMD_HttpCustom(CString csKeyPath, CString csData, int iOverWriteAlways);
DWORD WriteToMD_EnableParentPaths_WWW(CString csKeyPath, BOOL bEnableFlag);

void  EnforceMaxConnections(void);
DWORD WriteToMD_DwordEntry(CString csKeyPath,DWORD dwID,DWORD dwAttrib,DWORD dwUserType,DWORD dwTheData,INT iOverwriteFlag);
int RemoveIncompatibleMetabaseFilters(CString csSectionName,int iRemoveMetabaseNodes);

DWORD WriteToMD_RootKeyType(void);
DWORD MDDumpAdminACL(CString csKeyPath);

int DoesAppIsolatedExist(CString csKeyPath);
HRESULT WINAPI Add_WWW_VDirW(WCHAR * pwszMetabasePath, WCHAR * pwszVDirName,WCHAR * pwszPhysicalPath, DWORD dwPermissions, DWORD iApplicationType);
HRESULT WINAPI Add_WWW_VDirA(CHAR * pwszMetabasePath, CHAR * pwszVDirName,CHAR * pwszPhysicalPath, DWORD dwPermissions, DWORD iApplicationType);
HRESULT WINAPI Remove_WWW_VDirW(WCHAR * pwszMetabasePath, WCHAR * pwszVDirName);
HRESULT WINAPI Remove_WWW_VDirA(CHAR * pwszMetabasePath, CHAR * pwszVDirName);
HRESULT AddVirtualDir(IMSAdminBase *pIMSAdminBase,WCHAR * pwszMetabasePath,WCHAR * pwszVDir,WCHAR * pwszPhysicalPath, DWORD dwPermissions, INT iApplicationType);
HRESULT RemoveVirtualDir(IMSAdminBase *pIMSAdminBase,WCHAR * wszMetabaseKey,WCHAR * wszVDir);

#endif // _MDENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\mdkey.h ===
#ifndef _MDKEY_H_
#define _MDKEY_H_


class CMDValue
{
protected:
    DWORD m_dwId;
    DWORD m_dwAttributes;
    DWORD m_dwUserType;
    DWORD m_dwDataType;
    DWORD m_cbDataLen;
    BUFFER m_bufData;

public:
    CMDValue();
    ~CMDValue();
    DWORD SetValue(DWORD dwId,
                    DWORD dwAttributes,
                    DWORD dwUserType,
                    DWORD dwDataType,
                    DWORD dwDataLen,
                    LPVOID pbData);
    DWORD SetValue(DWORD dwId,
                    DWORD dwAttributes,
                    DWORD dwUserType,
                    DWORD dwDataType,
                    DWORD dwDataLen,
                    LPTSTR szDataString);

    DWORD GetId()                      { return m_dwId; }
    DWORD GetAttributes()              { return m_dwAttributes; }
    DWORD GetUserType()                { return m_dwUserType; }
    DWORD GetDataType()                { return m_dwDataType; }
    DWORD GetDataLen()                 { return m_cbDataLen; }
    PVOID GetData()                    { return m_bufData.QueryPtr(); }
    BOOL  IsEqual(DWORD dwDataType, DWORD cbDataLen, LPVOID pbData);
    BOOL  IsEqual(DWORD dwDataType, DWORD cbDataLen, DWORD dwData);
                    
};

class CMDKey : public CObject
{
protected:
    IMSAdminBase * m_pcCom;
    METADATA_HANDLE m_hKey;
    LPTSTR pszFailedAPI;

public:
    CMDKey();
    ~CMDKey();

    TCHAR  m_szCurrentNodeName[_MAX_PATH];

    // allow CMDKey to be used where type METADATA_HANDLE is required
    operator METADATA_HANDLE () {return m_hKey;}
    METADATA_HANDLE GetMDKeyHandle() {return m_hKey;}
    IMSAdminBase *GetMDKeyICOM() {return m_pcCom;}

    // open an existing MD key
    HRESULT OpenNode(LPCTSTR pchSubKeyPath);
    // to open an existing MD key, or create one if doesn't exist
    HRESULT CreateNode(METADATA_HANDLE hKeyBase, LPCTSTR pchSubKeyPath);
    // close node opened/created by OpenNode() or CreateNode()
    HRESULT Close();

    HRESULT ForceWriteMetabaseToDisk();
    
    HRESULT DeleteNode(LPCTSTR pchSubKeyPath);

    BOOL IsEmpty( PWCHAR pszSubString = L"" );
    int GetNumberOfSubKeys( PWCHAR pszSubString = L"" );

    // get all the sub keys that have a certain property on them and return the
    // sub-paths in a cstring list object. The cstring list should be instantiated
    // by the caller and deleted by the same.
    HRESULT GetDataPaths( 
        DWORD dwMDIdentifier,
        DWORD dwMDDataType,
        CStringList& szPathList,
        PWCHAR pszSubString = L"" );

    HRESULT GetMultiSzAsStringList (
        DWORD dwMDIdentifier,
        DWORD *uType,
        DWORD *attributes,
        CStringList& szStrList,
        PWCHAR pszSubString = L"" );

    HRESULT SetMultiSzAsStringList (
        DWORD dwMDIdentifier,
        DWORD uType,
        DWORD attributes,
        CStringList& szStrList,
        PWCHAR pszSubString = L"" );


    HRESULT GetStringAsCString (
        DWORD dwMDIdentifier,
        DWORD uType,
        DWORD attributes,
        CString& szStrList,
        PWCHAR pszSubString = L"",
        int iStringType = 0);

    HRESULT SetCStringAsString (
        DWORD dwMDIdentifier,
        DWORD uType,
        DWORD attributes,
        CString& szStrList,
        PWCHAR pszSubString = L"",
        int iStringType = 0);

    HRESULT GetDword(
        DWORD dwMDIdentifier,
        DWORD uType,
        DWORD attributes,
        DWORD& MyDword,
        PWCHAR pszSubString = L"");

    HRESULT SetData(
        DWORD id,
        DWORD attr,
        DWORD uType,
        DWORD dType,
        DWORD cbLen,
        LPBYTE pbData,
        PWCHAR pszSubString = L"" );

    BOOL GetData(DWORD id,
        DWORD *pdwAttr,
        DWORD *pdwUType,
        DWORD *pdwDType,
        DWORD *pcbLen,
        LPBYTE pbData,
        DWORD BufSize,
        PWCHAR pszSubString = L"" );

    BOOL GetData(DWORD id,
        DWORD *pdwAttr,
        DWORD *pdwUType,
        DWORD *pdwDType,
        DWORD *pcbLen,
        LPBYTE pbData,
        DWORD BufSize,
        DWORD  dwAttributes,
        DWORD  dwUType,
        DWORD  dwDType,
        PWCHAR pszSubString = L"" );

    HRESULT DeleteData(DWORD id, DWORD dType, PWCHAR pszSubString = L"" );

    HRESULT RenameNode(LPCTSTR pszMDPath,LPCTSTR pszMDNewName);

    BOOL GetData(CMDValue &Value,
                DWORD id,
                PWCHAR pszSubString = L"" );

    BOOL SetData(CMDValue &Value,
                DWORD id,
                PWCHAR pszSubString = L"" );
private:

    HRESULT DoCoInitEx();
    void DoCoUnInit();

    // a count of the calls to coinit
    INT m_cCoInits;
};

class CMDKeyIter : public CObject
{
protected:
    IMSAdminBase * m_pcCom;
    METADATA_HANDLE m_hKey;
    LPWSTR m_pBuffer;
    DWORD m_dwBuffer;

public:
    CMDKeyIter(CMDKey &cmdKey);
    ~CMDKeyIter();

    LONG Next(CString *pcsName, PWCHAR pwcsSubString = L"");

    void Reset() {m_index = 0;}


    DWORD m_index;
};

#endif // _MDKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\ocpages.cpp ===
#include "stdafx.h"
#include "log.h"
#include "browsedi.h"
#include "dllmain.h"
#include "ocpages.h"
#pragma hdrstop


#ifndef ENABLE_OC_PAGES 
    // there are no globals here
#else
    // OcManage globals
    extern OCMANAGER_ROUTINES gHelperRoutines;

    // Globals for us
    HWND g_hParentSheet = NULL;
    BOOL g_bFTP, g_bWWW;
    HWND g_hFTPEdit, g_hWWWEdit;
#endif


#ifndef ENABLE_OC_PAGES  //ENABLE_OC_PAGES

    DWORD_PTR OC_REQUEST_PAGES_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
    {
        DWORD_PTR dwOcEntryReturn = 0;

        WizardPagesType PageType;
        PSETUP_REQUEST_PAGES pSetupRequestPages = NULL;
        UINT MaxPages;
        HPROPSHEETPAGE pPage;

        PageType = (WizardPagesType)Param1;
        dwOcEntryReturn = 0;

    //OC_REQUEST_PAGES_Func_Exit:
        TCHAR szPageType_Desc[30] = _T("");
        if (PageType == 0) {_tcscpy(szPageType_Desc, _T("WizPagesWelcome"));}
        if (PageType == 1) {_tcscpy(szPageType_Desc, _T("WizPagesMode"));}
        if (PageType == 2) {_tcscpy(szPageType_Desc, _T("WizPagesEarly"));}
        if (PageType == 3) {_tcscpy(szPageType_Desc, _T("WizPagesPrenet"));}
        if (PageType == 4) {_tcscpy(szPageType_Desc, _T("WizPagesPostnet"));}
        if (PageType == 5) {_tcscpy(szPageType_Desc, _T("WizPagesLate"));}
        if (PageType == 6) {_tcscpy(szPageType_Desc, _T("WizPagesFinal"));}
        if (PageType == 7) {_tcscpy(szPageType_Desc, _T("WizPagesTypeMax"));}

        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. PageType=%d (%s) Return=%d RegisteredPages\n"), ComponentId, SubcomponentId, PageType, szPageType_Desc, dwOcEntryReturn));
        return dwOcEntryReturn;
    }


#else   //ENABLE_OC_PAGES

    DWORD_PTR OC_REQUEST_PAGES_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2)
    {
        DWORD_PTR dwOcEntryReturn = 0;

        WizardPagesType PageType;
        PSETUP_REQUEST_PAGES pSetupRequestPages = NULL;
        UINT MaxPages;
        HPROPSHEETPAGE pPage;

        PageType = (WizardPagesType)Param1;

        if ( PageType == WizPagesWelcome )
        {
            // No Welcome page if installing on NT5
            if (g_pTheApp->m_fInvokedByNT)
            {
                dwOcEntryReturn = 0;
    //OC_REQUEST_PAGES_Func_Exit:
            }
            else
            {
                pSetupRequestPages = (PSETUP_REQUEST_PAGES)Param2;
                MaxPages = pSetupRequestPages->MaxPages;
                pPage = CreatePage(IDD_PROPPAGE_WELCOME, pWelcomePageDlgProc);
                pSetupRequestPages->MaxPages = 1;
                pSetupRequestPages->Pages[0] = pPage;
                dwOcEntryReturn = 1;
            }
            goto OC_REQUEST_PAGES_Func_Exit;
        }

        if ( PageType == WizPagesMode )
        {
            pSetupRequestPages = (PSETUP_REQUEST_PAGES)Param2;
            MaxPages = pSetupRequestPages->MaxPages;
            switch (g_pTheApp->m_eInstallMode)
            {
            case IM_UPGRADE:
                // No Eula page if installing on NT5
                if (g_pTheApp->m_fInvokedByNT)
                {
                    // Don't show any pages
                    g_pTheApp->m_fEULA = TRUE;
                    // Set to upgrade only -- (not upgrade and add extra components afterwards)
                    //SetIISSetupMode(SETUPMODE_UPGRADEONLY);
                    dwOcEntryReturn = 0;
                    pSetupRequestPages->MaxPages = 0;
                }
                else
                {
                    pPage = CreatePage(IDD_PROPPAGE_EULA, pEULAPageDlgProc);
                    pSetupRequestPages->Pages[0] = pPage;
                    pPage = CreatePage(IDD_PROPPAGE_MODE_UPGRADE, pUpgradePageDlgProc);
                    pSetupRequestPages->Pages[1] = pPage;
                    pSetupRequestPages->MaxPages = 2;
                    dwOcEntryReturn = pSetupRequestPages->MaxPages;
                }
                break;
            case IM_MAINTENANCE:
                if (g_pTheApp->m_fInvokedByNT)
                {
                    // Don't show any pages
                    g_pTheApp->m_bRefreshSettings = TRUE;
                    dwOcEntryReturn = 0;
                    pSetupRequestPages->MaxPages = 0;
                }
                else
                {
                    pPage = CreatePage(IDD_PROPPAGE_MODE_MAINTENANCE, pMaintenancePageDlgProc);
                    pSetupRequestPages->Pages[0] = pPage;
                    pPage = CreatePage(IDD_PROPPAGE_SRC_PATH, pSrcPathPageDlgProc);
                    pSetupRequestPages->Pages[1] = pPage;
                    pSetupRequestPages->MaxPages = 2;
                    dwOcEntryReturn = pSetupRequestPages->MaxPages;
                }
                break;
            case IM_FRESH:
                // No Eula page if installing on NT5
                if (g_pTheApp->m_fInvokedByNT)
                {
                    // Don't show any pages
                    // just proceed with installation
                    g_pTheApp->m_fEULA = TRUE;
                    dwOcEntryReturn = 0;
                    pSetupRequestPages->MaxPages = 0;
                }
                else
                {
                    pPage = CreatePage(IDD_PROPPAGE_EULA, pEULAPageDlgProc);
                    pSetupRequestPages->Pages[0] = pPage;
                    pPage = CreatePage(IDD_PROPPAGE_MODE_FRESH, pFreshPageDlgProc);
                    pSetupRequestPages->Pages[1] = pPage;
                    pSetupRequestPages->MaxPages = 2;
                    dwOcEntryReturn = pSetupRequestPages->MaxPages;
                }
                break;
            default:
                iisDebugOut((LOG_TYPE_TRACE, _T("Should never reach this branch: IM_DEGRADE.\n")));
                pSetupRequestPages->MaxPages = 0;
                break;
            }

            dwOcEntryReturn = pSetupRequestPages->MaxPages;
            goto OC_REQUEST_PAGES_Func_Exit;
        }

        if ( PageType == WizPagesEarly )
        {
            pSetupRequestPages = (PSETUP_REQUEST_PAGES)Param2;
            MaxPages = pSetupRequestPages->MaxPages;
            pPage = CreatePage(IDD_PROPPAGE_PUBLISH_DIR, pEarlyPageDlgProc);
            pSetupRequestPages->MaxPages = 1;
            pSetupRequestPages->Pages[0] = pPage;
            dwOcEntryReturn = 1;
            goto OC_REQUEST_PAGES_Func_Exit;
        }


        if ( PageType == WizPagesFinal )
        {
            // No Final page if invoked by NT
            if (g_pTheApp->m_fInvokedByNT)
            {
                pSetupRequestPages = (PSETUP_REQUEST_PAGES)Param2;
                // Don't show any pages just proceed with installation
                dwOcEntryReturn = 0;
                pSetupRequestPages->MaxPages = 0;
            }
            else
            {
                pSetupRequestPages = (PSETUP_REQUEST_PAGES)Param2;
                MaxPages = pSetupRequestPages->MaxPages;
                pPage = CreatePage(IDD_PROPPAGE_END, pEndPageDlgProc);
                pSetupRequestPages->MaxPages = 1;
                pSetupRequestPages->Pages[0] = pPage;
                dwOcEntryReturn = 1;
            }
            goto OC_REQUEST_PAGES_Func_Exit;
        }

    OC_REQUEST_PAGES_Func_Exit:
        TCHAR szPageType_Desc[30] = _T("");
        if (PageType == 0) {_tcscpy(szPageType_Desc, _T("WizPagesWelcome"));}
        if (PageType == 1) {_tcscpy(szPageType_Desc, _T("WizPagesMode"));}
        if (PageType == 2) {_tcscpy(szPageType_Desc, _T("WizPagesEarly"));}
        if (PageType == 3) {_tcscpy(szPageType_Desc, _T("WizPagesPrenet"));}
        if (PageType == 4) {_tcscpy(szPageType_Desc, _T("WizPagesPostnet"));}
        if (PageType == 5) {_tcscpy(szPageType_Desc, _T("WizPagesLate"));}
        if (PageType == 6) {_tcscpy(szPageType_Desc, _T("WizPagesFinal"));}
        if (PageType == 7) {_tcscpy(szPageType_Desc, _T("WizPagesTypeMax"));}

        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s,%s] End. PageType=%d (%s) Return=%d RegisteredPages\n"), ComponentId, SubcomponentId, PageType, szPageType_Desc, dwOcEntryReturn));
        return dwOcEntryReturn;
    }

    HPROPSHEETPAGE CreatePage(int nID, DLGPROC pDlgProc)
    {
        PROPSHEETPAGE Page;
        HPROPSHEETPAGE PageHandle = NULL;

        Page.dwSize = sizeof(PROPSHEETPAGE);
        Page.dwFlags = PSP_DEFAULT;
        Page.hInstance = (HINSTANCE)g_MyModuleHandle;
        Page.pszTemplate = MAKEINTRESOURCE(nID);
        Page.pfnDlgProc = pDlgProc;

        iisDebugOut_Start(_T("comdlg32:CreatePropertySheetPage()"));
        PageHandle = CreatePropertySheetPage(&Page);
        iisDebugOut_End(_T("comdlg32:CreatePropertySheetPage()"));

        return(PageHandle);
    }

    HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors)
    {
        LPBITMAPINFOHEADER  lpbi;
        LPLOGPALETTE     lpPal;
        HANDLE           hLogPal = NULL;
        HPALETTE         hPal = NULL;
        int              i;

        lpbi = (LPBITMAPINFOHEADER)lpbmi;
        if (lpbi->biBitCount <= 8)
            {*lpiNumColors = (1 << lpbi->biBitCount);}
        else
            {*lpiNumColors = 0;}  // No palette needed for 24 BPP DIB

        if (lpbi->biClrUsed > 0)
            {*lpiNumColors = lpbi->biClrUsed;}  // Use biClrUsed

        if (*lpiNumColors)
        {
            hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) + sizeof (PALETTEENTRY) * (*lpiNumColors));
            if (hLogPal)
            {
                lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
                lpPal->palVersion    = 0x300;
                lpPal->palNumEntries = (WORD)*lpiNumColors;

                for (i = 0;  i < *lpiNumColors;  i++)
                {
                    lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
                    lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
                    lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
                    lpPal->palPalEntry[i].peFlags = 0;
                }
                hPal = CreatePalette (lpPal);
                GlobalUnlock (hLogPal);
                GlobalFree   (hLogPal);
            }
        }
       return hPal;
    }

    HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPCTSTR lpString, HPALETTE FAR* lphPalette)
    {
        HRSRC  hRsrc = NULL;
        HGLOBAL hGlobal = NULL;
        HBITMAP hBitmapFinal = NULL;
        LPBITMAPINFOHEADER  lpbi = NULL;
        HDC hdc;
        int iNumColors;

        if (hRsrc = FindResource(hInstance, lpString, RT_BITMAP))
        {
           hGlobal = LoadResource(hInstance, hRsrc);
           if (hGlobal)
           {
             lpbi = (LPBITMAPINFOHEADER)LockResource(hGlobal);
             if (lpbi)
             {
               hdc = GetDC(NULL);
               if (hdc)
               {
                 *lphPalette =  CreateDIBPalette ((LPBITMAPINFO)lpbi, &iNumColors);
                 if (*lphPalette)
                 {
                    SelectPalette(hdc,*lphPalette,FALSE);
                    RealizePalette(hdc);
                 }

                 hBitmapFinal = CreateDIBitmap(hdc,(LPBITMAPINFOHEADER)lpbi,(LONG)CBM_INIT,(LPSTR)lpbi + lpbi->biSize + iNumColors * sizeof(RGBQUAD),(LPBITMAPINFO)lpbi,DIB_RGB_COLORS );
                 ReleaseDC(NULL,hdc);
               }
               UnlockResource(hGlobal);
             }
             FreeResource(hGlobal);
           }
        }
        return (hBitmapFinal);
    }

    //----------------------------------------------------------------------------
    void PaintTextInRect( HDC hdc, LPCTSTR psz, RECT* pRect, COLORREF color,LONG lfHeight, LONG lfWeight, BYTE lfPitchAndFamily )
        {
        HFONT hfontOld = NULL;

        // create the font we will use for this
        HFONT hfontDraw = CreateFont(
            lfHeight,           // logical height of font
            0,                  // logical average character width
            0,                  // angle of escapement
            0,                  // base-line orientation angle
            lfWeight,           // font weight
            FALSE,              // italic attribute flag
            FALSE,              // underline attribute flag
            FALSE,              // strikeout attribute flag
            DEFAULT_CHARSET,    // character set identifier
            OUT_DEFAULT_PRECIS, // output precision
            CLIP_DEFAULT_PRECIS,// clipping precision
            DEFAULT_QUALITY,    // output quality
            lfPitchAndFamily,   // pitch and family
            NULL                // pointer to typeface name string
            );

        if (hfontDraw)
        {
          // set the font into place
          hfontOld = (HFONT)SelectObject( hdc, hfontDraw );
        }

        // prevent the character box from being erased
        int oldBkMode = SetBkMode(hdc, TRANSPARENT);

        // set the text color
        COLORREF oldTextColor = SetTextColor( hdc, color );

        // draw the text
        DrawText(
            hdc,                // handle to device context
            psz,                // pointer to string to draw
            -1,                 // string length, in characters
            pRect,              // pointer to structure with formatting dimensions
            DT_LEFT|DT_TOP      // text-drawing flags
            );

        // restore hdc settings
        SetBkMode( hdc, oldBkMode );
        SetTextColor( hdc, oldTextColor );
        if (hfontDraw)
          {
          SelectObject( hdc, hfontOld );
          // clean up the font
          DeleteObject( hfontDraw );
          }
        }

    //----------------------------------------------------------------------------
    // this routine gets the rect from the frame and  calls PaintTextInRect
    void PaintTextInFrame( HDC hdc, LPCTSTR psz, HWND hDlg, UINT nID, COLORREF color,LONG lfHeight, LONG lfWeight, BYTE lfPitchAndFamily )
        {
        RECT    rect;
        GetWindowRect( GetDlgItem(hDlg, nID), &rect );
        MapWindowPoints( HWND_DESKTOP, hDlg, (LPPOINT)&rect, 2 );
        PaintTextInRect( hdc, psz, &rect, color, lfHeight, lfWeight, lfPitchAndFamily );
        }

    void OnPaintBitmap(HWND hdlg, HDC hdc, int n, RECT *hRect)
    {
       HBITMAP hBitmap,hOldBitmap;
       HPALETTE hPalette;
       HDC hMemDC;
       BITMAP bm;
       int nID;

        // n:
        // 0 = welcome page
        // 1 = all other pages
        // 2 = IIS "input path's page"

        // Load the bitmap resource
    /*
        if (n == 0){nID = IDB_WELCOMES;}
        else{nID = IDB_BANNERS;}
        hBitmap = LoadResourceBitmap(g_MyModuleHandle, MAKEINTRESOURCE(nID), &hPalette);
        GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
        hMemDC = CreateCompatibleDC(hdc);
        SelectPalette(hdc,hPalette,FALSE);
        RealizePalette(hdc);
        SelectPalette(hMemDC,hPalette,FALSE);
        RealizePalette(hMemDC);
        hOldBitmap = (HBITMAP)SelectObject(hMemDC,hBitmap);
        StretchBlt( hdc, 0, 0, hRect->right, hRect->bottom, hMemDC, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY );
        DeleteObject(SelectObject(hMemDC,hOldBitmap));
        DeleteDC(hMemDC);
        DeleteObject(hPalette);
    */
        CString csMS, csTitle;

        if (n==0)
        {
            if (g_pTheApp->m_eOS == OS_W95)
            {
            // On the welcome page, show "Microsoft(R)"
            MyLoadString(IDS_BITMAP_MS_TRADEMARK_OTHER, csMS);
            }
            else
            {
            // On the welcome page, show "Microsoft"
            MyLoadString(IDS_BITMAP_MS_TRADEMARK, csMS);
            }
        }
        else
        {
            // no trademark on other pages
            MyLoadString(IDS_BITMAP_MS, csMS);
        }

        // If were on the (2 = IIS "input path's page") then
        // make sure the banner is says "IIS", or "PWS" not "NT Option Pack"
        if (n==2)
        {
            MyLoadString(IDS_BITMAP_TITLE, csTitle);
        }
        else
        {
            if (g_pTheApp->m_eNTOSType == OT_NTW)
            {
                if (n == 0)
                {
                    // on the welcome page make sure to show the "NT(R)" one
                    // Only applies to NT and should only be shown the first time you see "NT".
                    MyLoadString(IDS_BITMAP_TITLE_TRADEMARK, csTitle);
                }
                else
                {
                    MyLoadString(IDS_BITMAP_TITLE, csTitle);
                }
            }
            else
            {
                if (n == 0)
                {
                    // on the welcome page make sure to show the "NT(R)" one
                    // Only applies to NT and should only be shown the first time you see "NT".
                    MyLoadString(IDS_BITMAP_TITLE_TRADEMARK, csTitle);
                }
                else
                {
                    MyLoadString(IDS_BITMAP_TITLE, csTitle);
                }
            }
        }

       if (n==0)
       {
           // On the welcome page
            CString csIntro, csFeature;
            if (g_pTheApp->m_eOS == OS_W95)
            {
               MyLoadString(IDS_WELCOMEC_INTRO, csIntro);
               MyLoadString(IDS_WELCOMEC_FEATURE, csFeature);
            }
            else if (g_pTheApp->m_eNTOSType == OT_NTW)
            {
               MyLoadString(IDS_WELCOMEW_INTRO, csIntro);
               MyLoadString(IDS_WELCOMEW_FEATURE, csFeature);
            }
            else
            {
               MyLoadString(IDS_WELCOMES_INTRO, csIntro);
               MyLoadString(IDS_WELCOMES_FEATURE, csFeature);
            }
            PaintTextInFrame(hdc, csMS, hdlg, IDC_FRAME_WELCOME_MS, 0x0, 16, FW_NORMAL, DEFAULT_PITCH | FF_DONTCARE);
            PaintTextInFrame(hdc, csTitle, hdlg, IDC_FRAME_WELCOME_TITLE, 0x0, 24, FW_HEAVY, DEFAULT_PITCH | FF_DONTCARE);
            PaintTextInFrame(hdc, csIntro, hdlg, IDC_FRAME_WELCOME_INTRO, 0x0, 14, FW_NORMAL, DEFAULT_PITCH | FF_DONTCARE);
            PaintTextInFrame(hdc, csFeature, hdlg, IDC_FRAME_WELCOME_FEATURE, 0x0, 14, FW_NORMAL, DEFAULT_PITCH | FF_DONTCARE);
       }
       else
       {
            PaintTextInFrame(hdc, csMS, hdlg, IDC_FRAME_BANNER_MS, 0x0, 16, FW_NORMAL, DEFAULT_PITCH | FF_DONTCARE);
            PaintTextInFrame(hdc, csTitle, hdlg, IDC_FRAME_BANNER_TITLE, 0x0, 24, FW_HEAVY, DEFAULT_PITCH | FF_DONTCARE);
       }

       return;
    }

    INT_PTR CALLBACK pWelcomePageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        INT_PTR bReturn = TRUE;
        LPNMHDR pnmh;
        HWND hSheet = NULL;
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("pWelcomePageDlgProc:"));
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

        switch(msg)
        {
        case WM_NOTIFY:
            pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                // don't set on nt5 
                //SetWindowText(GetParent(hdlg), g_pTheApp->m_csSetupTitle);
                if (g_pTheApp->m_fUnattended)
                {
                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                }
                else
                {
                    iisDebugOut_Start(_T("pWelcomePageDlgProc()"));
                    hSheet = GetParent(hdlg);
                    g_hParentSheet = hSheet;
                    PropSheet_SetWizButtons(hSheet, PSWIZB_NEXT);
                }
                break;
            default:
                break;
            }
            break;
        case WM_PAINT:
            {
                HDC hdc = NULL;
                PAINTSTRUCT ps;
                RECT rect;
                HWND hFrame = NULL;
                hdc = BeginPaint(hdlg, &ps);
                if (hdc)
                {
                  hFrame = GetDlgItem(hdlg, IDC_FRAME_WELCOME);
                  if (hFrame)
                  {
                    GetClientRect(hFrame, &rect);
                    OnPaintBitmap(hdlg, hdc, 0, &rect);
                  }
                  EndPaint(hdlg, &ps);
                }
            }
            break;
        default:
            bReturn = FALSE;
            break;
        }

        return(bReturn);
    }

    BOOL InsertEULAText(HWND hEdit)
    {
        BOOL fReturn = FALSE;
        CString csFile = g_pTheApp->m_csPathSource + _T("\\license.txt");

        HANDLE hFile = CreateFile(csFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD   dwSize = GetFileSize(hFile, NULL);
            BYTE    *chBuffer = (BYTE *)HeapAlloc(GetProcessHeap(), 0, dwSize+1 );

            if (chBuffer)
            {
                ReadFile(hFile, chBuffer, dwSize, &dwSize, NULL);
                chBuffer[dwSize] = '\0';
                SendMessage (hEdit, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                SendMessageA(hEdit, EM_REPLACESEL, 0, (LPARAM)chBuffer);
                SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM)0);
                HeapFree(GetProcessHeap(), 0, chBuffer);
                fReturn = TRUE;
            }

            CloseHandle(hFile);
        }

        return fReturn;
    }

    INT_PTR CALLBACK pEULAPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        INT_PTR bReturn = TRUE;
        LPNMHDR pnmh;
        HWND hSheet = NULL, hNext = NULL;
        HWND hEULAText = NULL;
        HWND hEULAAccept = NULL, hEULADecline = NULL;
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("pEULAPageDlgProc:"));
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

        switch(msg)
        {
        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                hSheet = GetParent(hdlg);
                switch (LOWORD(wParam))
                {
                    case IDC_EULA_ACCEPT:
                        g_pTheApp->m_fEULA = TRUE;
                        SetCursor(LoadCursor(NULL,IDC_WAIT ));
                        PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto mode page
                        PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                        return TRUE;
                    case IDC_EULA_DECLINE:
                        {
                            // cancel setup
                            MyMessageBox(NULL, IDS_EULA_DECLINED, MB_OK | MB_SETFOREGROUND);
                            PropSheet_PressButton(hSheet, PSBTN_CANCEL);
                        }
                        return TRUE;
                    default:
                        break;
                }
            }
            if (HIWORD(wParam) == EN_SETFOCUS)
            {
                hEULAText = GetDlgItem(hdlg, IDC_LICENSE_TEXT);
                SendMessage (hEULAText, EM_SETSEL, (WPARAM)-1, (LPARAM)0);
            }
            break;
        case WM_NOTIFY:
            pnmh = (LPNMHDR)lParam;
            hSheet = GetParent(hdlg);
            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                // don't set on nt5
                //SetWindowText(GetParent(hdlg), g_pTheApp->m_csSetupTitle);
                PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                if (g_pTheApp->m_fUnattended || g_pTheApp->m_fEULA) 
                {
                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                }
                else
                {
                    hEULAText = GetDlgItem(hdlg, IDC_LICENSE_TEXT);
                    if (!InsertEULAText(hEULAText))
                    {
                        SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                    }
                    else
                    {
                        hEULAAccept = GetDlgItem(hdlg, IDC_EULA_ACCEPT);
                        hEULADecline = GetDlgItem(hdlg, IDC_EULA_DECLINE);
                        EnableWindow(hEULAAccept, TRUE);
                        EnableWindow(hEULADecline, TRUE);
                        PropSheet_SetWizButtons(hSheet, PSWIZB_BACK);
                    }
                }
                break;
            default:
                break;
            }
            break;

        case WM_PAINT:
            {
                HDC hdc = NULL;
                PAINTSTRUCT ps;
                RECT rect;
                HWND hFrame = NULL;
                hdc = BeginPaint(hdlg, &ps);
                if (hdc)
                {
                  hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
                  if (hFrame)
                  {
                    GetClientRect(hFrame, &rect);
                    OnPaintBitmap(hdlg, hdc, 1, &rect);
                  }
                  EndPaint(hdlg, &ps);
                }
            }
            break;
        default:
            bReturn = FALSE;
            break;
        }

        return(bReturn);
    }


    INT_PTR CALLBACK pFreshPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        INT_PTR bReturn = TRUE;
        LPNMHDR pnmh;
        HWND hSheet = GetParent(hdlg);
        HWND hMinimum = NULL, hTypical = NULL, hCustom = NULL;
        HWND hMinimumBox = NULL, hTypicalBox = NULL, hCustomBox = NULL;
        CString csMinimumString, csTypicalString, csCustomString;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("pFreshPageDlgProc:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

        SetIISSetupMode(SETUPMODE_CUSTOM);

        switch(msg)
        {
        case WM_NOTIFY:
            pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                break;
            default:
                break;
            }
            break;
        case WM_PAINT:
            {
                HDC hdc = NULL;
                PAINTSTRUCT ps;
                RECT rect;
                HWND hFrame = NULL;
                hdc = BeginPaint(hdlg, &ps);
                if (hdc)
                {
                  hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
                  if (hFrame)
                  {
                    GetClientRect(hFrame, &rect);
                    OnPaintBitmap(hdlg, hdc, 1, &rect);
                  }
                  EndPaint(hdlg, &ps);
                }
            }
            break;
        default:
            bReturn = FALSE;
            break;
        }

        return(bReturn);
    }

    /*
    // old code used when we had the fresh page.
    // kept around in this comment block just in case we need it in the future.
    #define WM_FINISH_INIT (WM_USER + 5000)
    INT_PTR CALLBACK pFreshPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        INT_PTR bReturn = TRUE;
        LPNMHDR pnmh;
        HWND hSheet = GetParent(hdlg);
        HWND hMinimum = NULL, hTypical = NULL, hCustom = NULL;
        HWND hMinimumBox = NULL, hTypicalBox = NULL, hCustomBox = NULL;
        CString csMinimumString, csTypicalString, csCustomString;
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("pFreshPageDlgProc:"));
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

        switch(msg)
        {
        case WM_INITDIALOG:
            hMinimum = GetDlgItem(hdlg, IDC_MINIMUM);
            hTypical = GetDlgItem(hdlg, IDC_TYPICAL);
            hCustom = GetDlgItem(hdlg, IDC_CUSTOM);
            hMinimumBox = GetDlgItem(hdlg, IDC_FRESH_MINIMUM_STATIC);
            hTypicalBox = GetDlgItem(hdlg, IDC_FRESH_TYPICAL_STATIC);
            hCustomBox = GetDlgItem(hdlg, IDC_FRESH_CUSTOM_STATIC);

            MyLoadString(IDS_FRESH_MINIMUM_STRING, csMinimumString);
            MyLoadString(IDS_FRESH_TYPICAL_STRING, csTypicalString);
            MyLoadString(IDS_FRESH_CUSTOM_STRING, csCustomString);

            SetWindowText(hMinimumBox, csMinimumString);
            SetWindowText(hTypicalBox, csTypicalString);
            SetWindowText(hCustomBox, csCustomString);
            break;
        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_MINIMUM:
                        // check if tcpip is installed
                        g_pTheApp->IsTCPIPInstalled();
                        if (g_pTheApp->m_fTCPIP == FALSE && g_pTheApp->MsgBox(hSheet, IDS_NEED_TCPIP_WARNING, MB_OKCANCEL | MB_DEFBUTTON2, TRUE) == IDCANCEL)
                        {
                            SendMessage(hSheet, WM_COMMAND, MAKEWPARAM(IDCANCEL, BN_CLICKED), 0);
                            break;
                        }
                        // set minimum default selections
                        SetIISSetupMode(SETUPMODE_MINIMAL);
                        SetCursor(LoadCursor(NULL,IDC_WAIT ));
                        PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto setup page
                        PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                        return TRUE;
                    case IDC_TYPICAL:
                        // check if tcpip is installed
                        g_pTheApp->IsTCPIPInstalled();
                        if (g_pTheApp->m_fTCPIP == FALSE && g_pTheApp->MsgBox(hSheet, IDS_NEED_TCPIP_WARNING, MB_OKCANCEL | MB_DEFBUTTON2, TRUE) == IDCANCEL)
                        {
                            SendMessage(hSheet, WM_COMMAND, MAKEWPARAM(IDCANCEL, BN_CLICKED), 0);
                            break;
                        }
                        // set typical default selections
                        SetIISSetupMode(SETUPMODE_TYPICAL);
                        SetCursor(LoadCursor(NULL,IDC_WAIT ));
                        PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto setup page
                        PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                        return TRUE;
                    case IDC_CUSTOM:
                        // check if tcpip is installed
                        g_pTheApp->IsTCPIPInstalled();
                        if (g_pTheApp->m_fTCPIP == FALSE && g_pTheApp->MsgBox(hSheet, IDS_NEED_TCPIP_WARNING, MB_OKCANCEL | MB_DEFBUTTON2, TRUE) == IDCANCEL)
                        {
                            SendMessage(hSheet, WM_COMMAND, MAKEWPARAM(IDCANCEL, BN_CLICKED), 0);
                            break;
                        }
                        // set typical default selections
                        SetIISSetupMode(SETUPMODE_CUSTOM);
                        SetCursor(LoadCursor(NULL,IDC_WAIT ));
                        PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto OC page
                        PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                        return TRUE;
                    default:
                        break;
                }
            }
            break;
        case WM_NOTIFY:
            pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                // don't set on nt5
                //SetWindowText(GetParent(hdlg), g_pTheApp->m_csSetupTitle);
                if (g_pTheApp->m_eInstallMode == IM_FRESH)
                {
                    if (g_pTheApp->m_fUnattended) 
                    {
                        TCHAR szMode[_MAX_PATH] = _T("");
                        INFCONTEXT Context;
                        if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, _T("Global"), _T("FreshMode"), &Context) ) 
                        {
                            SetupGetStringField(&Context, 1, szMode, _MAX_PATH, NULL);
                        }
                        if (_tcsicmp(szMode, _T("Minimal")) == 0) 
                        {
                            SetIISSetupMode(SETUPMODE_MINIMAL);
                        }
                        else if (_tcsicmp(szMode, _T("Custom")) == 0) 
                        {
                            SetIISSetupMode(SETUPMODE_CUSTOM);
                        }
                        else 
                        {
                            SetIISSetupMode(SETUPMODE_TYPICAL);
                        }
                    }

                    // Check if -m or -t or -f was passed in!
                    BOOL fGot = FALSE;
                    if (g_CmdLine_Set_M == TRUE) {SetIISSetupMode(SETUPMODE_MINIMAL);fGot = TRUE;}
                    if (g_CmdLine_Set_T == TRUE) {SetIISSetupMode(SETUPMODE_TYPICAL);fGot = TRUE;}
                    if (g_CmdLine_Set_F == TRUE) {SetIISSetupMode(SETUPMODE_CUSTOM);fGot = TRUE;}

                    if (fGot || g_pTheApp->m_fUnattended) {
                        SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                    }
                    else 
                    {
                        PropSheet_SetWizButtons(hSheet, PSWIZB_BACK);
                        SetWindowLongPtr(hdlg, DWLP_MSGRESULT, 0);
                        PostMessage(hdlg, WM_FINISH_INIT, 0, 0 );
                        PostMessage(hdlg, DM_SETDEFID, (WPARAM)IDC_TYPICAL, 0);
                    }
                }
                break;

            default:
                break;
            }
            break;
        case WM_FINISH_INIT:
            hTypical = GetDlgItem(hdlg, IDC_TYPICAL);
            SetFocus(hTypical);
            break;
        case WM_PAINT:
            {
                HDC hdc = NULL;
                PAINTSTRUCT ps;
                RECT rect;
                HWND hFrame = NULL;
                hdc = BeginPaint(hdlg, &ps);
                if (hdc)
                {
                  hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
                  if (hFrame)
                  {
                    GetClientRect(hFrame, &rect);
                    OnPaintBitmap(hdlg, hdc, 1, &rect);
                  }
                  EndPaint(hdlg, &ps);
                }
            }
            break;
        default:
            bReturn = FALSE;
            break;
        }

        return(bReturn);
    }
    */

    INT_PTR CALLBACK pMaintenancePageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        INT_PTR bReturn = TRUE;
        LPNMHDR pnmh;
        HWND hSheet = GetParent(hdlg);
        HWND hAddRemove = NULL, hReinstall = NULL, hRemoveAll = NULL;

        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("pMaintenancePageDlgProc:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

        SetIISSetupMode(SETUPMODE_ADDREMOVE);

        switch(msg)
        {
        case WM_NOTIFY:
            pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                break;
            default:
                break;
            }
            break;
        case WM_PAINT:
            {
                HDC hdc = NULL;
                PAINTSTRUCT ps;
                RECT rect;
                HWND hFrame = NULL;
                hdc = BeginPaint(hdlg, &ps);
                if (hdc)
                {
                  hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
                  if (hFrame)
                  {
                    GetClientRect(hFrame, &rect);
                    OnPaintBitmap(hdlg, hdc, 1, &rect);
                  }
                  EndPaint(hdlg, &ps);
                }
            }
            break;
        default:
            bReturn = FALSE;
            break;
        }

        return(bReturn);
    }

    /*
    // old code used when we had the maintenence page.
    // kept around in this comment block just in case we need it in the future.
    INT_PTR CALLBACK pMaintenancePageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        INT_PTR bReturn = TRUE;
        LPNMHDR pnmh;
        HWND hSheet = GetParent(hdlg);
        HWND hAddRemove = NULL, hReinstall = NULL, hRemoveAll = NULL;
        BOOL iSaveOld_AllowMessageBoxPopups = FALSE;

        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("pMaintenancePageDlgProc:"));
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

        switch(msg)
        {
        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_ADDREMOVE:
                        // set minimum default selections
                        SetIISSetupMode(SETUPMODE_ADDREMOVE);
                        SetCursor(LoadCursor(NULL,IDC_WAIT ));
                        PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto OC page
                        PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                        return TRUE;
                    case IDC_REINSTALL:
                        // set typical default selections
                        SetIISSetupMode(SETUPMODE_REINSTALL);
                        SetCursor(LoadCursor(NULL,IDC_WAIT ));
                        PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto setup page
                        PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                        return TRUE;
                    case IDC_REMOVEALL:
                        // set typical default selections
                        iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;
                        if (g_pTheApp->MsgBox(NULL, IDS_REMOVEALL_WARNING, MB_YESNO | MB_DEFBUTTON2, TRUE) == IDNO)
                            {
                            g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;
                            break;
                            }
                        g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;
                        SetIISSetupMode(SETUPMODE_REMOVEALL);
                        SetCursor(LoadCursor(NULL,IDC_WAIT ));
                        PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto setup page
                        PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                        return TRUE;
                    default:
                        break;
                }
            }
            break;
        case WM_NOTIFY:
            pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                // don't set on nt5
                //SetWindowText(GetParent(hdlg), g_pTheApp->m_csSetupTitle);
                if (g_pTheApp->m_fUnattended) {
                    TCHAR szMode[_MAX_PATH] = _T("");
                    INFCONTEXT Context;
                    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, _T("Global"), _T("MaintenanceMode"), &Context) )                {
                        SetupGetStringField(&Context, 1, szMode, _MAX_PATH, NULL);
                    }
                    if (_tcsicmp(szMode, _T("AddRemove")) == 0)
                    {
                        SetIISSetupMode(SETUPMODE_ADDREMOVE);
                    }
                    else if (_tcsicmp(szMode, _T("RemoveAll")) == 0)
                    {
                        SetIISSetupMode(SETUPMODE_REMOVEALL);
                    }
                    else
                    {
                        // Heck i don't know what type of mode this is. put up an error message.
                        if ( gHelperRoutines.ReportExternalError )
                        {
                            CString csFormat, csMsg;
                            MyLoadString(IDS_UNATTEND_UNSUPPORTED, csFormat);
                            csMsg.Format( csFormat, szMode);
                            gHelperRoutines.ReportExternalError(
                                gHelperRoutines.OcManagerContext,
                                _T("IIS"),
                                NULL,
                                (DWORD_PTR)(LPCTSTR) csMsg,
                                ERRFLG_PREFORMATTED);
                        }
                        PropSheet_PressButton(hSheet, PSBTN_CANCEL);
                        break;
                    }

                    //The old code
                    //else if (_tcsicmp(szMode, _T("ReinstallFile")) == 0) {
                    //    SetIISSetupMode(SETUPMODE_REINSTALL);
                    //    g_pTheApp->m_bRefreshSettings = FALSE;
                    //} else {
                    //    SetIISSetupMode(SETUPMODE_REINSTALL);
                    //    g_pTheApp->m_bRefreshSettings = TRUE;
                    //}
                }
            
                if (g_pTheApp->m_fUnattended) {
                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                } else {
                    PropSheet_SetWizButtons(hSheet, PSWIZB_BACK);
                    PostMessage(hdlg, WM_FINISH_INIT, 0, 0 );
                    PostMessage(hdlg, DM_SETDEFID, (WPARAM)IDC_ADDREMOVE, 0);
                }
                break;
            default:
                break;
            }
            break;
        case WM_FINISH_INIT:
            hAddRemove = GetDlgItem(hdlg, IDC_ADDREMOVE);
            SetFocus(hAddRemove);
            break;
        case WM_PAINT:
            {
                HDC hdc = NULL;
                PAINTSTRUCT ps;
                RECT rect;
                HWND hFrame = NULL;
                hdc = BeginPaint(hdlg, &ps);
                if (hdc)
                {
                  hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
                  if (hFrame)
                  {
                    GetClientRect(hFrame, &rect);
                    OnPaintBitmap(hdlg, hdc, 1, &rect);
                  }
                  EndPaint(hdlg, &ps);
                }
            }
            break;
        default:
            bReturn = FALSE;
            break;
        }

        return(bReturn);
    }
    */

    INT_PTR CALLBACK pSrcPathPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        INT_PTR bReturn = TRUE;
        LPNMHDR pnmh;
        HWND hSheet = GetParent(hdlg);
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("pSrcPathPageDlgProc:"));
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

        switch(msg)
        {
        case WM_INITDIALOG:
            CheckRadioButton(hdlg,IDC_REINSTALL_REFRESH_FILES,IDC_REINSTALL_REFRESH_SETTINGS,IDC_REINSTALL_REFRESH_FILES);
            break;
        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                switch (LOWORD(wParam)) {
                case IDC_REINSTALL_REFRESH_FILES:
                case IDC_REINSTALL_REFRESH_SETTINGS:
                    CheckRadioButton(hdlg,IDC_REINSTALL_REFRESH_FILES,IDC_REINSTALL_REFRESH_SETTINGS,LOWORD(wParam));
                    break;
                default:
                    break;
                }
            }
            break;
        case WM_NOTIFY:
            pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                // don't set on nt5
                //SetWindowText(GetParent(hdlg), g_pTheApp->m_csSetupTitle);
                if (g_pTheApp->m_dwSetupMode == SETUPMODE_REINSTALL && !g_pTheApp->m_fUnattended)
                {
                     // accept the activation
                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, 0);
                }
                else
                {
                    // don't display this wizard page
                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                }
                break;
            case PSN_WIZNEXT:
                {
                    DWORD dwValue;
                    if (IsDlgButtonChecked(hdlg, IDC_REINSTALL_REFRESH_SETTINGS) == BST_CHECKED)
                        {g_pTheApp->m_bRefreshSettings = TRUE;}
                    else
                        {g_pTheApp->m_bRefreshSettings = FALSE;}

                    dwValue = (DWORD)(g_pTheApp->m_bRefreshSettings);
                    gHelperRoutines.SetPrivateData(gHelperRoutines.OcManagerContext,_T("ReinstallRefreshSettings"),(PVOID)&dwValue,sizeof(DWORD),REG_DWORD);
                    SetCursor(LoadCursor(NULL,IDC_WAIT ));
                }
                break;
            default:
                break;
            }
            break;
        case WM_PAINT:
            {
                HDC hdc = NULL;
                PAINTSTRUCT ps;
                RECT rect;
                HWND hFrame = NULL;
                hdc = BeginPaint(hdlg, &ps);
                if (hdc)
                {
                  hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
                  if (hFrame)
                  {
                    GetClientRect(hFrame, &rect);
                    OnPaintBitmap(hdlg, hdc, 1, &rect);
                  }
                  EndPaint(hdlg, &ps);
                }
            }
            break;
        default:
            bReturn = FALSE;
            break;
        }

        return(bReturn);
    }


    INT_PTR CALLBACK pUpgradePageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        INT_PTR bReturn = TRUE;
        LPNMHDR pnmh;
        HWND hSheet = GetParent(hdlg);
        HWND hUpgradeOnly = NULL, hAddExtraComps = NULL;
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("pUpgradePageDlgProc:"));
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

        SetIISSetupMode(SETUPMODE_ADDEXTRACOMPS);

        switch(msg)
        {
        case WM_NOTIFY:
            pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                break;
            default:
                break;
            }
            break;
        case WM_PAINT:
            {
                HDC hdc = NULL;
                PAINTSTRUCT ps;
                RECT rect;
                HWND hFrame = NULL;
                hdc = BeginPaint(hdlg, &ps);
                if (hdc)
                {
                  hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
                  if (hFrame)
                  {
                    GetClientRect(hFrame, &rect);
                    OnPaintBitmap(hdlg, hdc, 1, &rect);
                  }
                  EndPaint(hdlg, &ps);
                }
            }
            break;
        default:
            bReturn = FALSE;
            break;
        }

        return(bReturn);
    }

    /*
    // old code used when we had the upgrade page.
    // kept around in this comment block just in case we need it in the future.
    INT_PTR CALLBACK pUpgradePageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        INT_PTR bReturn = TRUE;
        LPNMHDR pnmh;
        HWND hSheet = GetParent(hdlg);
        HWND hUpgradeOnly = NULL, hAddExtraComps = NULL;
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("pUpgradePageDlgProc:"));
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

        switch(msg)
        {
        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_UPGRADEONLY:
                        // upgrade those previously installed components
                        SetIISSetupMode(SETUPMODE_UPGRADEONLY);
                        SetCursor(LoadCursor(NULL,IDC_WAIT ));
                        PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto setup page
                        PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                        return TRUE;
                    case IDC_ADDEXTRACOMPS:
                        // upgrade those previously installed components + add extra components
                        SetIISSetupMode(SETUPMODE_ADDEXTRACOMPS);
                        SetCursor(LoadCursor(NULL,IDC_WAIT ));
                        PropSheet_PressButton(hSheet, PSBTN_NEXT); // goto OC page
                        PropSheet_SetWizButtons(hSheet, PSWIZB_BACK | PSWIZB_NEXT);
                        return TRUE;
                    default:
                        break;
                }
            }
            break;
        case WM_NOTIFY:
            pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                // don't set on nt5
                //SetWindowText(GetParent(hdlg), g_pTheApp->m_csSetupTitle);
                if (g_pTheApp->m_fUnattended)
                {
                    TCHAR szMode[_MAX_PATH] = _T("");
                    INFCONTEXT Context;
                    if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, _T("Global"), _T("UpgradeMode"), &Context) )
                    {
                        SetupGetStringField(&Context, 1, szMode, _MAX_PATH, NULL);
                    }
                    if (_tcsicmp(szMode, _T("AddExtraComps")) == 0)
                    {
                        SetIISSetupMode(SETUPMODE_ADDEXTRACOMPS);
                    }
                    else
                    {
                        SetIISSetupMode(SETUPMODE_UPGRADEONLY);
                    }
                }
            
                if (g_pTheApp->m_fUnattended) 
                {
                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                }
                else
                {
                    PropSheet_SetWizButtons(hSheet, PSWIZB_BACK);
                    PostMessage(hdlg, WM_FINISH_INIT, 0, 0 );
                    PostMessage(hdlg, DM_SETDEFID, (WPARAM)IDC_UPGRADEONLY, 0);
                }
                break;
            default:
                break;
            }
            break;
        case WM_FINISH_INIT:
            hUpgradeOnly = GetDlgItem(hdlg, IDC_UPGRADEONLY);
            SetFocus(hUpgradeOnly);
            break;
        case WM_PAINT:
            {
                HDC hdc = NULL;
                PAINTSTRUCT ps;
                RECT rect;
                HWND hFrame = NULL;
                hdc = BeginPaint(hdlg, &ps);
                if (hdc)
                {
                  hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
                  if (hFrame)
                  {
                    GetClientRect(hFrame, &rect);
                    OnPaintBitmap(hdlg, hdc, 1, &rect);
                  }
                  EndPaint(hdlg, &ps);
                }
            }
            break;
        default:
            bReturn = FALSE;
            break;
        }

        return(bReturn);
    }
    */


    INT_PTR CALLBACK pEarlyPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        INT_PTR bReturn = TRUE;
        LPNMHDR pnmh;
        HWND hSheet = NULL;
        HWND hFTPGroup, hWWWGroup, hFTPBrowse, hWWWBrowse;
        TCHAR szFTPRoot[_MAX_PATH], szWWWRoot[_MAX_PATH];
        BOOL bShowTheDialogPage = TRUE;
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("pEarlyPageDlgProc:"));
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

        TCHAR szSectionName[_MAX_PATH];
        TCHAR szValue[_MAX_PATH] = _T("");
        TCHAR szValue0[_MAX_PATH] = _T("");

        _tcscpy(szSectionName, _T("InternetServer"));

        switch(msg)
        {
        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                TCHAR buf[_MAX_PATH];
                TCHAR szPath[_MAX_PATH];
                switch (LOWORD(wParam))
                {
                    case IDC_WWW_PUB_BROWSE:
                        g_hWWWEdit = GetDlgItem(hdlg, IDC_WWW_PUB_EDIT);
                        GetWindowText(g_hWWWEdit, szPath, _MAX_PATH);
                        if ( BrowseForDirectory( GetParent(hdlg), szPath,buf, _MAX_PATH, NULL, TRUE ))
                        {
                            SetWindowText(g_hWWWEdit, buf);
                        }
                        break;
                    case IDC_FTP_PUB_BROWSE:
                        g_hFTPEdit = GetDlgItem(hdlg, IDC_FTP_PUB_EDIT);
                        GetWindowText(g_hFTPEdit, szPath, _MAX_PATH);
                        if ( BrowseForDirectory( GetParent(hdlg), szPath,buf, _MAX_PATH, NULL, TRUE ))
                        {
                            SetWindowText(g_hFTPEdit, buf);
                        }
                        break;
                }
            }
            break;
        case WM_NOTIFY:
            pnmh = (LPNMHDR)lParam;
            hSheet = GetParent(hdlg);
            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                {
                g_bFTP = ToBeInstalled(TEXT("iis"), TEXT("iis_ftp"));
                g_bWWW = ToBeInstalled(TEXT("iis"), TEXT("iis_www"));

                BOOL bDisplay = FALSE; // display this wizard or not
                if (g_pTheApp->m_fUnattended)
                {
                    INFCONTEXT Context;
                    if (g_bFTP)
                    {
                        // Default it incase SetupFindFirstLine fails
                        _tcscpy(szValue, g_pTheApp->m_csPathFTPRoot);

                        if (g_pTheApp->m_hUnattendFile != INVALID_HANDLE_VALUE && g_pTheApp->m_hUnattendFile != NULL)
                        {
                            if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, _T("PathFTPRoot"), &Context) ) 
                            {
                                SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);
                            }
                            if (*szValue)
                            {
                                _tcscpy(szValue0, szValue);
                                if (!ExpandEnvironmentStrings( (LPCTSTR)szValue0, szValue, sizeof(szValue)/sizeof(TCHAR)))
                                    {_tcscpy(szValue,szValue0);}

                                if (!IsValidDirectoryName(szValue))
                                    bDisplay = TRUE;
                                else
                                    CustomFTPRoot(szValue);
                            }
                        }
                    }
                    if (g_bWWW)
                    {
                        // Default it incase SetupFindFirstLine fails
                        _tcscpy(szValue, g_pTheApp->m_csPathWWWRoot);

                        if (g_pTheApp->m_hUnattendFile != INVALID_HANDLE_VALUE && g_pTheApp->m_hUnattendFile != NULL)
                        {
                            if ( SetupFindFirstLine_Wrapped(g_pTheApp->m_hUnattendFile, szSectionName, _T("PathWWWRoot"), &Context) ) 
                            {
                                SetupGetStringField(&Context, 1, szValue, _MAX_PATH, NULL);
                            }
                            _tcscpy(szValue0, szValue);
                            if (!ExpandEnvironmentStrings( (LPCTSTR)szValue0, szValue, sizeof(szValue)/sizeof(TCHAR)))
                                {_tcscpy(szValue,szValue0);}
                            if (*szValue)
                            {
                                if (!IsValidDirectoryName(szValue))
                                    bDisplay = TRUE;
                                else
                                    CustomWWWRoot(szValue);
                            }
                        }
                    }

                    if (bDisplay)
                    {
                        g_pTheApp->MsgBox(NULL, IDS_NEED_VALID_PATH_UNATTENDED, MB_OK, FALSE);
                        PropSheet_SetWizButtons(hSheet, PSWIZB_NEXT);
                    }

                } // end of unattended


                bShowTheDialogPage = FALSE;
                if ( g_pTheApp->m_fUnattended)
                {
                    if (bDisplay) bShowTheDialogPage = TRUE;
                }
                else
                {
                    // this is attended mode, either gui or standalone
                    if (g_pTheApp->m_fInvokedByNT)
                    {
                        // if attended guimode then don't show this dialog page
                        bShowTheDialogPage = FALSE;
                    }
                    else
                    {
                        // If it's attended mode, then show this page
                        if ( g_bFTP || g_bWWW ) {bShowTheDialogPage = TRUE;} 
                    }
                }

                if (bShowTheDialogPage)
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("showpage.bShowTheDialogPage")));
                    hFTPGroup = GetDlgItem(hdlg, IDC_FTP_PUB_GROUP);
                    hWWWGroup = GetDlgItem(hdlg, IDC_WWW_PUB_GROUP);
                    g_hFTPEdit = GetDlgItem(hdlg, IDC_FTP_PUB_EDIT);
                    g_hWWWEdit = GetDlgItem(hdlg, IDC_WWW_PUB_EDIT);
                    hFTPBrowse = GetDlgItem(hdlg, IDC_FTP_PUB_BROWSE);
                    hWWWBrowse = GetDlgItem(hdlg, IDC_WWW_PUB_BROWSE);

                    EnableWindow(hFTPGroup, g_bFTP);
                    EnableWindow(g_hFTPEdit, g_bFTP);
                    EnableWindow(hFTPBrowse, g_bFTP);
                    if (g_bFTP)
                        {SetWindowText(g_hFTPEdit, g_pTheApp->m_csPathFTPRoot);}
                    else
                        {SetWindowText(g_hFTPEdit, TEXT(""));}

                    EnableWindow(hWWWGroup, g_bWWW);
                    EnableWindow(g_hWWWEdit, g_bWWW);
                    EnableWindow(hWWWBrowse, g_bWWW);
                    if (g_bWWW)
                        {SetWindowText(g_hWWWEdit, g_pTheApp->m_csPathWWWRoot);}
                    else
                        {SetWindowText(g_hWWWEdit, TEXT(""));}

                     // accept the activation
                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, 0);
                }
                else
                {
                    // check if inetsrv is a valid directory
                    TCHAR szInetsrv[_MAX_PATH];
                    _tcscpy(szInetsrv, g_pTheApp->m_csPathInetsrv);
                    while (!IsValidDirectoryName(szInetsrv))
                    {
                        MyMessageBox(NULL, IDS_INVALID_DIR_INETSRV, g_pTheApp->m_csPathInetsrv, MB_OK | MB_SETFOREGROUND);
                    }
                    // don't display this wizard page
                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                }
                break;
                }
            case PSN_WIZNEXT:
                if (g_bFTP)
                {
                    GetWindowText(g_hFTPEdit, szFTPRoot, _MAX_PATH);
                    CleanPathString(szFTPRoot);
                    if (!IsValidDirectoryName(szFTPRoot))
                    {
                        g_pTheApp->MsgBox(NULL, IDS_NEED_INPUT_FTP, MB_OK, FALSE);
                        SetWindowText(g_hFTPEdit, g_pTheApp->m_csPathFTPRoot);
                        SetFocus(g_hFTPEdit);
                        SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                        break;
                    }
                }
                if (g_bWWW)
                {
                    GetWindowText(g_hWWWEdit, szWWWRoot, _MAX_PATH);
                    CleanPathString(szWWWRoot);
                    if (!IsValidDirectoryName(szWWWRoot))
                    {
                        g_pTheApp->MsgBox(NULL, IDS_NEED_INPUT_WWW, MB_OK, FALSE);
                        SetWindowText(g_hWWWEdit, g_pTheApp->m_csPathWWWRoot);
                        SetFocus(g_hWWWEdit);
                        SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                        break;
                    }
                }

                if (g_bFTP) {CustomFTPRoot(szFTPRoot);}
                if (g_bWWW) {CustomWWWRoot(szWWWRoot);}

                // check if inetsrv is a valid directory
                TCHAR szInetsrv[_MAX_PATH];
                _tcscpy(szInetsrv, g_pTheApp->m_csPathInetsrv);
                while (!IsValidDirectoryName(szInetsrv))
                {
                    MyMessageBox(NULL, IDS_INVALID_DIR_INETSRV, g_pTheApp->m_csPathInetsrv, MB_OK | MB_SETFOREGROUND);
                }
                break;
            default:
                break;
            }
            break;
        case WM_PAINT:
            {
                HDC hdc = NULL;
                PAINTSTRUCT ps;
                RECT rect;
                HWND hFrame = NULL;
                hdc = BeginPaint(hdlg, &ps);
                if (hdc)
                {
                  hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
                  if (hFrame)
                  {
                    GetClientRect(hFrame, &rect);
                    OnPaintBitmap(hdlg, hdc, 2, &rect);
                  }
                  EndPaint(hdlg, &ps);
                }
            }
            break;
        default:
            bReturn = FALSE;
            break;
        }

        return(bReturn);
    }


    INT_PTR CALLBACK pEndPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        INT_PTR bReturn = TRUE;
        LPNMHDR pnmh;
        HWND hSheet = NULL;
        HWND hCancel = NULL;
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("pEndPageDlgProc:"));
        //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

        switch(msg)
        {
        case WM_INITDIALOG:
            // display running services in case our services need other services to be running!
            //StartInstalledServices();
            break;
        case WM_COMMAND:
            break;
        case WM_NOTIFY:
            pnmh = (LPNMHDR)lParam;
            hSheet = GetParent(hdlg);
            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                if (g_pTheApp->m_fUnattended)
                {
                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                    //PropSheet_PressButton(hSheet, PSBTN_NEXT);
                    PropSheet_PressButton(hSheet, PSBTN_FINISH);
                }
                else
                {
                    if (g_pTheApp->m_fInvokedByNT)
                    {
                        SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
                        //PropSheet_PressButton(hSheet, PSBTN_NEXT);
                        PropSheet_PressButton(hSheet, PSBTN_FINISH);
                    }
                    else
                    {
                        // don't set on nt5
                        //SetWindowText(GetParent(hdlg), g_pTheApp->m_csSetupTitle);
                        // enable buttons
                        PropSheet_SetWizButtons(hSheet, PSWIZB_FINISH);
                        hCancel = GetDlgItem(hSheet, IDCANCEL);
                        if (hCancel){EnableWindow(hCancel, FALSE);}
                    }
                }
                break;
            default:
                break;
            }
            break;
        case WM_PAINT:
            {
                HDC hdc = NULL;
                PAINTSTRUCT ps;
                RECT rect;
                HWND hFrame = NULL;
                hdc = BeginPaint(hdlg, &ps);
                if (hdc)
                {
                  hFrame = GetDlgItem(hdlg, IDC_FRAME_BANNER);
                  if (hFrame)
                  {
                    GetClientRect(hFrame, &rect);
                    OnPaintBitmap(hdlg, hdc, 1, &rect);
                  }
                  EndPaint(hdlg, &ps);
                }
            }
            break;
        default:
            bReturn = FALSE;
            break;
        }

        return(bReturn);
    }
#endif // ENABLE_OC_PAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\mdkey.cpp ===
// MdKey.cpp

#include "stdafx.h"

#define INITGUID
#define _WIN32_DCOM
#undef DEFINE_GUID      // Added for NT5 migration
#include <ole2.h>
#include <coguid.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "iwamreg.h"
#include "strfn.h"

#define TIMEOUT_VALUE 5000

INT_PTR CALLBACK pSecureRetryIgnoreAllDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
extern BOOL g_bGlobalWriteUnSecuredIfFailed_All;

CMDKey::CMDKey():
    m_cCoInits(0)
{
    m_pcCom = NULL;
    m_hKey = NULL;
    _tcscpy(m_szCurrentNodeName, _T(""));
}

CMDKey::~CMDKey()
{
    this->Close();

    // while there are outstanding coinits, close them
    while ( m_cCoInits > 0 && !(m_cCoInits < 0) )
        DoCoUnInit();
}

HRESULT CMDKey::DoCoInitEx()
{
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    // track our calls to coinit
    if ( SUCCEEDED(hRes) )
    {
        m_cCoInits++;
    }

    return hRes;
}

void CMDKey::DoCoUnInit()
{
    HRESULT hRes = NOERROR;

    // if there are outstanding coinits, uninit one
    if ( m_cCoInits > 0 )
    {
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().Start.")));
        CoUninitialize();
        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().End.")));
        m_cCoInits--;
    }

    // we shouldn't ever have a negative count. But just in case...
    ASSERT( m_cCoInits >= 0 );
    if ( m_cCoInits < 0 )
    {
        // something is seriously wrong here. Prevent looping
        // by going straight to zero, and write an error to the log.
        m_cCoInits = 0;
        iisDebugOut((LOG_TYPE_WARN, _T("WARNING: CoInits in mdkey have gone negative")));
    }
}

HRESULT CMDKey::OpenNode(LPCTSTR pchSubKeyPath)
{
    HRESULT hRes = ERROR_SUCCESS;
    IClassFactory * pcsfFactory = NULL;
    BOOL b = FALSE;
    m_pcCom = NULL;
    m_hKey = NULL;
    WCHAR szSubKeyPath[_MAX_PATH];

    pszFailedAPI = NULL;

    _tcscpy(m_szCurrentNodeName, pchSubKeyPath);

    if ( !pchSubKeyPath || !(*pchSubKeyPath) ) 
    {
        *szSubKeyPath = L'\0';
    }
    else 
    {
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH);
#endif
    }

    hRes = DoCoInitEx();
    if (FAILED(hRes))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CoInitializeEx() failed, hRes=%x\n"), hRes));
    }

    hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hRes)) 
    {
        MyMessageBox(NULL, _T("CoGetClassObject"), hRes, MB_OK | MB_SETFOREGROUND);
    }
    else 
    {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
        pcsfFactory->Release();
        if (FAILED(hRes)) 
        {
            MyMessageBox(NULL, _T("CoCreateInstance"), hRes, MB_OK | MB_SETFOREGROUND);
        }
        else 
        {
            _tcscpy(m_szCurrentNodeName, pchSubKeyPath);
            hRes = m_pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,szSubKeyPath,METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,TIMEOUT_VALUE,&m_hKey);
            if (FAILED(hRes)) 
            {
                if (hRes != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) 
                {
                    MyMessageBox(NULL, _T("OpenKey"), hRes, MB_OK | MB_SETFOREGROUND);
                }
            }
            else 
            {
                b = TRUE;
            }
        } // end of CoCreateInstance
    } // end of CoGetClassObject

    if (!b) {this->Close();}
    return hRes;
}

HRESULT CMDKey::CreateNode(METADATA_HANDLE hKeyBase, LPCTSTR pchSubKeyPath)
{
    HRESULT hRes = ERROR_SUCCESS;
    IClassFactory * pcsfFactory = NULL;
    BOOL b = FALSE;
    m_pcCom = NULL;
    m_hKey = NULL;
    WCHAR szSubKeyPath[_MAX_PATH];

    _tcscpy(m_szCurrentNodeName, pchSubKeyPath);

    pszFailedAPI = NULL;

    if ( !pchSubKeyPath || !(*pchSubKeyPath) ) 
    {
        *szSubKeyPath = L'\0';
    }
    else 
    {
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH);
#endif
    }

    hRes = DoCoInitEx();
    if (FAILED(hRes))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CoInitializeEx() failed, hRes=%x\n"), hRes));
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoGetClassObject().Start.")));
    hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoGetClassObject().End.")));
    if (FAILED(hRes)) 
    {
        MyMessageBox(NULL, _T("CoGetClassObject"), hRes, MB_OK | MB_SETFOREGROUND);
    }
    else 
    {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
        pcsfFactory->Release();
        if (FAILED(hRes)) 
        {
            MyMessageBox(NULL, _T("CreateInstance"), hRes, MB_OK | MB_SETFOREGROUND);
        }
        else 
        {
            _tcscpy(m_szCurrentNodeName, pchSubKeyPath);
            hRes = m_pcCom->OpenKey(hKeyBase,szSubKeyPath,METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,TIMEOUT_VALUE,&m_hKey);
            if (FAILED(hRes)) 
            {
                if (hRes == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) 
                {
                    METADATA_HANDLE RootHandle;
                    _tcscpy(m_szCurrentNodeName, pchSubKeyPath);
                    hRes = m_pcCom->OpenKey(hKeyBase,L"",METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,TIMEOUT_VALUE,&RootHandle);
                    hRes = m_pcCom->AddKey(RootHandle, szSubKeyPath);
                    if (FAILED(hRes)) 
                    {
                        MyMessageBox(NULL, _T("AddKey"), hRes, MB_OK | MB_SETFOREGROUND);
                    }
                    hRes = m_pcCom->CloseKey(RootHandle);
                    if (FAILED(hRes)) 
                    {
                        MyMessageBox(NULL, _T("CloseKey of the AddKey"), hRes, MB_OK | MB_SETFOREGROUND);
                    }
                    else 
                    {
                        // open it again to set m_hKey
                        _tcscpy(m_szCurrentNodeName, pchSubKeyPath);
                        hRes = m_pcCom->OpenKey(hKeyBase,szSubKeyPath,METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,TIMEOUT_VALUE,&m_hKey);
                        if (FAILED(hRes)) 
                        {
                            MyMessageBox(NULL, _T("OpenKey"), hRes, MB_OK | MB_SETFOREGROUND);
                        }
                        else 
                        {
                            b = TRUE;
                        }
                    }
                }
                else 
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("calling OpenKey()...failed....something other than ERROR_PATH_NOT_FOUND\n")));
                    MyMessageBox(NULL, _T("OpenKey"), hRes, MB_OK | MB_SETFOREGROUND);
                }
            }
            else 
            {
                b = TRUE;
            } // end of OpenKey
        } // end of CoCreateInstance
    } // end of CoGetClassObject

    if (!b) {this->Close();}

    return hRes;
}

HRESULT CMDKey::ForceWriteMetabaseToDisk()
{
    HRESULT hRes = ERROR_SUCCESS;
    IClassFactory * pcsfFactory = NULL;
    m_pcCom = NULL;

    hRes = DoCoInitEx();
    if (FAILED(hRes))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CoInitializeEx() failed, hRes=%x\n"), hRes));
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoGetClassObject().Start.")));
    hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoGetClassObject().End.")));
    if (FAILED(hRes)) 
    {
        MyMessageBox(NULL, _T("CoGetClassObject"), hRes, MB_OK | MB_SETFOREGROUND);
    }
    else 
    {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
        pcsfFactory->Release();
        if (FAILED(hRes)) 
        {
            MyMessageBox(NULL, _T("CoCreateInstance"), hRes, MB_OK | MB_SETFOREGROUND);
        }
        else 
        {
            if (m_pcCom) 
            {
                hRes = m_pcCom->SaveData();
                iisDebugOut((LOG_TYPE_TRACE, _T("CMDKey::ForceWriteMetabaseToDisk():Return=0x%x.\n"),hRes));
            }
        } // end of CoCreateInstance
    } // end of CoGetClassObject

    return hRes;
}

HRESULT CMDKey::Close()
{
    HRESULT hRes = ERROR_SUCCESS;
    if (m_pcCom) 
    {
        if (m_hKey){hRes = m_pcCom->CloseKey(m_hKey);}
        hRes = m_pcCom->Release();
    }
    DoCoUnInit();
    m_pcCom = NULL;
    m_hKey = NULL;
    _tcscpy(m_szCurrentNodeName, _T(""));

    return hRes;
}

BOOL CMDKey::IsEmpty( PWCHAR pszSubString )
{
    int ReturnIndex;
    METADATA_RECORD mdrData;
    DWORD dwRequiredDataLen = 0;
    HRESULT hRes = ERROR_SUCCESS;
    UCHAR ReturnBuf[256];

    for(ReturnIndex=0;ReturnIndex<sizeof(ReturnBuf);ReturnIndex++)ReturnBuf[ReturnIndex]=0xff;
    
    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
    hRes = m_pcCom->EnumData(m_hKey, pszSubString, &mdrData, 0, &dwRequiredDataLen);
    if (FAILED(hRes)) 
    {
        if(hRes == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS) || hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER) ) 
        {
            return TRUE;
        }
        else 
        {
            MyMessageBox(NULL, _T("EnumData"), hRes, MB_OK | MB_SETFOREGROUND);
        }
    }
    return (hRes != ERROR_SUCCESS);
}

int CMDKey::GetNumberOfSubKeys( PWCHAR pszSubString )
{
    int i=0;
    HRESULT hRes = ERROR_SUCCESS;
    WCHAR NameBuf[METADATA_MAX_NAME_LEN];
    while (hRes == ERROR_SUCCESS) 
    {
        hRes = m_pcCom->EnumKeys(m_hKey, pszSubString, NameBuf, i++);
    }
    if (hRes == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS))
    {
        return (--i);
    }
    else 
    {
        MyMessageBox(NULL, _T("EnumKeys"), hRes, MB_OK | MB_SETFOREGROUND);
        return (0);
    }
}

#if !defined(UNICODE) && !defined(_UNICODE)

void MyMultiByteToWideChar( char *sData, WCHAR *wData, int cbBufSize, BOOL fMultiSZ)
{
    MultiByteToWideChar( CP_ACP, 0, sData, -1, wData, cbBufSize );
    while (fMultiSZ) 
    {
        sData = _tcsninc( sData, _tcslen(sData)) + 1;
        while (*wData++);
        if (*sData)
        {
            MultiByteToWideChar( CP_ACP, 0, sData, -1, wData, cbBufSize );
        }
        else 
        {
            *wData = L'\0';
            break;
        }
    }
    return;
}

void MyWideCharToMultiByte( WCHAR *wData, char *sData, int cbBufSize, BOOL fMultiSZ)
{
    WideCharToMultiByte( CP_ACP, 0, wData, -1, sData, cbBufSize, NULL, NULL );
    while (fMultiSZ) 
    {
        while (*wData++);
        sData = _tcsninc( sData, _tcslen(sData)) + 1;
        if (*wData)
        {
            WideCharToMultiByte( CP_ACP, 0, wData, -1, sData, cbBufSize, NULL, NULL );
        }
        else 
        {
            *sData = '\0';
            break;
        }
    }
    return;
}

#endif      // not unicode

HRESULT CMDKey::SetData(DWORD id,DWORD attr,DWORD uType,DWORD dType,DWORD cbLen, LPBYTE pbData,PWCHAR pszSubString )
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    BUFFER bufData;
    WCHAR *pData = (WCHAR *)pbData;
    int iPlsDoNoEncryption = FALSE;

    switch (dType) 
    {
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
            pData = (WCHAR *)pbData;
#else
            if ( ! (bufData.Resize(cbLen * sizeof(WCHAR))) )
            {
                // insufficient memory
                iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::SetData() failed to allocate memory.\n")));
                hRes = RETURNCODETOHRESULT(GetLastError());
                goto SetData_Exit;
            }

            pData = (WCHAR *)(bufData.QueryPtr());
            MyMultiByteToWideChar( (LPTSTR)pbData, pData, cbLen, FALSE);
            cbLen = cbLen * sizeof(WCHAR);
#endif
            break;

        case MULTISZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
            pData = (WCHAR *)pbData;
#else
            if ( ! (bufData.Resize(cbLen * sizeof(WCHAR))) )
            {
                // insufficient memory
                iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::SetData() failed to allocate memory.\n")));
                hRes = RETURNCODETOHRESULT(GetLastError());
                goto SetData_Exit;
            }
            pData = (WCHAR *)(bufData.QueryPtr());
            MyMultiByteToWideChar( (LPTSTR)pbData, pData, cbLen, TRUE );
            cbLen = cbLen * sizeof(WCHAR);
#endif
            break;

        default:
            break;

    }

    //DisplayStringForMetabaseID(id);
    //_tcscpy(m_szCurrentNodeName, _T(""));

    TCHAR lpReturnString[50];
    ReturnStringForMetabaseID(id, lpReturnString);
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("CMDKey::SetData[%s:%d:%s].\n"), m_szCurrentNodeName, id, lpReturnString));

    MD_SET_DATA_RECORD(&mdrData, id, attr, uType, dType, cbLen, (LPBYTE)pData);
    hRes = m_pcCom->SetData(m_hKey, pszSubString, &mdrData);

    if (FAILED(hRes))
    {
        // Check if it failed...
        // if it failed and the METADATA_SECURE flag is set, then
        // check if we can retry without the METADATA_SECURE flag!
        if ( attr & METADATA_SECURE )
        {
            if (TRUE == g_bGlobalWriteUnSecuredIfFailed_All)
            {
                iPlsDoNoEncryption = TRUE;
            }
            else
            {
                if (TRUE == DialogBoxParam((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDD_ENCRYPTED_WRITE_ERROR_DIALOG), NULL, pSecureRetryIgnoreAllDlgProc, (LPARAM)hRes))
                {
                    iPlsDoNoEncryption = TRUE;
                }
            }

            if (TRUE == iPlsDoNoEncryption)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::SetData() failed on a encrypt entry.  try to write it out unencrypted.\n")));
                attr &= ~METADATA_SECURE;
                MD_SET_DATA_RECORD(&mdrData, id, attr, uType, dType, cbLen, (LPBYTE)pData);
                hRes = m_pcCom->SetData(m_hKey, pszSubString, &mdrData);
                if (FAILED(hRes))
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::SetData() failed on write on encrypt entry as unencrypted.\n")));
                }
                else
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("CMDKey::SetData() success on write on encrypt entry as unencrypted.\n")));
                }
                // set the attr back to what it was
                attr &= ~METADATA_SECURE;
            }
        }
    }
    goto SetData_Exit;

SetData_Exit:
    if (FAILED(hRes)) 
    {
        MyMessageBox(NULL, IDS_SETDATA_ERROR, (int) hRes, MB_OK | MB_SETFOREGROUND);
    }
    return hRes;
}

BOOL CMDKey::GetData(DWORD id,DWORD *pdwAttr,DWORD *pdwUType,DWORD *pdwDType,DWORD *pcbLen,LPBYTE pbData,DWORD BufSize,PWCHAR pszSubString )
{
    return GetData(id,pdwAttr,pdwUType,pdwDType,pcbLen,pbData,BufSize,0,0,0,pszSubString);
}

BOOL
CMDKey::GetData(CMDValue &Value, DWORD dwId, PWCHAR pszSubString )
{
    DWORD       dwAttr;
    DWORD       dwUType;
    DWORD       dwDType;
    DWORD       cbLen;
    BUFFER      bufData;

    if (!GetData(dwId,&dwAttr,&dwUType,&dwDType,&cbLen,(LPBYTE) bufData.QueryPtr(),bufData.QuerySize(),0,0,0,pszSubString))
    {
        // Resize to Accomodate the big value
        if (!bufData.Resize(cbLen))
        {
            return FALSE;
        }

        if (!GetData(dwId,&dwAttr,&dwUType,&dwDType,&cbLen,(LPBYTE) bufData.QueryPtr(),bufData.QuerySize(),0,0,0,pszSubString))
        {
            // Even with the new size buffer we could not retrieve the value
            return FALSE;
        }    
    }

    return ( Value.SetValue(dwId,dwAttr,dwUType,dwDType,cbLen,(LPVOID) bufData.QueryPtr()) );
}

BOOL
CMDKey::SetData(CMDValue &Value, DWORD dwId, PWCHAR pszSubString )
{
  return SUCCEEDED( SetData(dwId,
                    Value.GetAttributes(),
                    Value.GetUserType(),
                    Value.GetDataType(),
                    Value.GetDataLen(),
                    (LPBYTE) Value.GetData(),
                    pszSubString ) );
}

// Note: only use to access the AnonyName and AnonyPassword,
// buffer size 256 is big enough here
BOOL CMDKey::GetData(DWORD id,DWORD *pdwAttr,DWORD *pdwUType,DWORD *pdwDType,DWORD *pcbLen,LPBYTE pbData,DWORD  BufSize,DWORD  dwAttributes,DWORD  dwUType,DWORD  dwDType,PWCHAR pszSubString )
{
    int ReturnIndex;
    BOOL fReturn = FALSE;
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    DWORD dwRequiredDataLen = 0;
    LPBYTE ReturnBuf=NULL;
    int ReturnBufSize;

    // if we are just trying to get the size of the field, just do that.
    if ( !pbData || (BufSize == 0) )
    {
        MD_SET_DATA_RECORD(&mdrData, id, dwAttributes, dwUType, dwDType, 0, NULL);
        hRes = m_pcCom->GetData(m_hKey, pszSubString, &mdrData, &dwRequiredDataLen);
        *pcbLen = dwRequiredDataLen;
        fReturn = (hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER));
        goto GetData_Exit;
    }

#if defined(UNICODE) || defined(_UNICODE)
    ReturnBufSize = BufSize;
#else
    ReturnBufSize = 2 * BufSize;
#endif
    ReturnBuf = (LPBYTE)LocalAlloc(LPTR, ReturnBufSize);
    if (!ReturnBuf)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::GetData() failed to allocate memory.\n")));
        ReturnBuf = NULL;
        goto GetData_Exit;
    }

    //DisplayStringForMetabaseID(id);

    TCHAR lpReturnString[50];
    ReturnStringForMetabaseID(id, lpReturnString);
    iisDebugOut((LOG_TYPE_TRACE, _T("CMDKey::GetData[%s:%d:%s].\n"), m_szCurrentNodeName, id, lpReturnString));

    MD_SET_DATA_RECORD(&mdrData, id, dwAttributes, dwUType, dwDType, ReturnBufSize, (PBYTE) ReturnBuf);
    hRes = m_pcCom->GetData(m_hKey, pszSubString, &mdrData, &dwRequiredDataLen);
    if (FAILED(hRes)) 
    {
        if (hRes == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) 
        {
#if defined(UNICODE) || defined(_UNICODE)
            *pcbLen = dwRequiredDataLen;
#else
            *pcbLen = dwRequiredDataLen / 2;
#endif
        }
        else 
        {
            *pcbLen = 0;
            if (hRes != MD_ERROR_DATA_NOT_FOUND)
            {
                MyMessageBox(NULL, IDS_GETDATA_ERROR, (int) hRes, MB_OK | MB_SETFOREGROUND);
            }
        }
        goto GetData_Exit;
    }

    // --------
    // We have successfully retrieved the data at this point
    // --------
    *pdwAttr = mdrData.dwMDAttributes;
    *pdwUType = mdrData.dwMDUserType;
    *pdwDType = mdrData.dwMDDataType;
    *pcbLen = mdrData.dwMDDataLen; // number of SBCS chars + ending \0
    switch (*pdwDType) 
    {
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
            memcpy(pbData, mdrData.pbMDData, *pcbLen);
#else
            *pcbLen = (*pcbLen) / sizeof(WCHAR);
            WideCharToMultiByte(CP_ACP,0,(WCHAR *)(mdrData.pbMDData),-1,(LPSTR)pbData,*pcbLen, NULL, NULL);
#endif
            fReturn = TRUE;
            break;
        case MULTISZ_METADATA:
#if defined(UNICODE) || defined(_UNICODE)
            memcpy(pbData, mdrData.pbMDData, *pcbLen);
#else
            *pcbLen = (*pcbLen) / sizeof(WCHAR);
            MyWideCharToMultiByte((WCHAR *)(mdrData.pbMDData),(LPSTR)pbData, *pcbLen, TRUE);
#endif
            fReturn = TRUE;
            break;
        default:
            memcpy(pbData, mdrData.pbMDData, *pcbLen);
            fReturn = TRUE;
            break;
    }

GetData_Exit:
    if(ReturnBuf) {LocalFree(ReturnBuf);}
    return fReturn;
}

HRESULT CMDKey::DeleteData(DWORD id, DWORD dType, PWCHAR pszSubString)
{
    HRESULT hRes = ERROR_SUCCESS;

    TCHAR lpReturnString[50];
    ReturnStringForMetabaseID(id, lpReturnString);
    iisDebugOut((LOG_TYPE_TRACE, _T("CMDKey::DeleteData[%s:%d:%s].\n"), m_szCurrentNodeName, id, lpReturnString));

    hRes = m_pcCom->DeleteData(m_hKey, pszSubString, id, dType);
    return hRes;
}

HRESULT CMDKey::DeleteNode(LPCTSTR pchSubKeyPath)
{
    HRESULT hRes = ERROR_SUCCESS;
    WCHAR szSubKeyPath[_MAX_PATH];

    if ( pchSubKeyPath && (*pchSubKeyPath) ) 
    {
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH );
#endif

        iisDebugOut((LOG_TYPE_TRACE, _T("CMDKey::DeleteNode[%s:%s].\n"), m_szCurrentNodeName, szSubKeyPath));
        hRes = m_pcCom->DeleteKey(m_hKey, szSubKeyPath);
    }

    return hRes;
}

CMDKeyIter::CMDKeyIter(CMDKey &cmdKey)
{
    m_hKey = cmdKey.GetMDKeyHandle();
    m_pcCom = cmdKey.GetMDKeyICOM();

    m_dwBuffer = _MAX_PATH;

    Reset();

    m_pBuffer = new WCHAR [m_dwBuffer];
}

CMDKeyIter::~CMDKeyIter()
{
    delete [] m_pBuffer;
}

LONG CMDKeyIter::Next(CString *pcsName, PWCHAR pwcsSubString)
{
    TCHAR tchData[_MAX_PATH];
    HRESULT hRes = ERROR_SUCCESS;
    hRes = m_pcCom->EnumKeys(m_hKey, pwcsSubString, m_pBuffer, m_index);
    if (FAILED(hRes)) 
    {
        return 1;
    }
    else 
    {
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(tchData, m_pBuffer);
#else
        WideCharToMultiByte(CP_ACP,0,m_pBuffer,-1,(LPSTR)tchData,_MAX_PATH, NULL, NULL);
#endif
        *pcsName = tchData;
        m_index++;
        return 0;
    }
}

int CreateInProc(LPCTSTR lpszPath, int iUseOOPPool)
{
    int iReturn = FALSE;
    TCHAR lpszKeyPath[_MAX_PATH];
    WCHAR wchKeyPath[_MAX_PATH];
    HRESULT         hr = NOERROR;
    IWamAdmin2*        pIWamAdmin = NULL;

    DWORD dwAppMode = eAppRunInProc;

    if (iUseOOPPool) {dwAppMode = eAppRunOutProcInDefaultPool;}

    if (lpszPath[0] == _T('/')) 
    {
        _tcscpy(lpszKeyPath, lpszPath);
    }
    else 
    {
        lpszKeyPath[0] = _T('/');
        _tcscpy(_tcsinc(lpszKeyPath), lpszPath);
    }

    if (lpszKeyPath[(_tcslen(lpszKeyPath)-1)] != _T('/')) {_tcscat(lpszKeyPath, _T("/"));}

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wchKeyPath, lpszKeyPath);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lpszKeyPath, -1, (LPWSTR)wchKeyPath, _MAX_PATH);
#endif

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoInitializeEx().Start.")));
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoInitializeEx().End.")));

    if (FAILED(hr))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CreateInProc: CoInitializeEx() failed, hr=%x\n"), hr));
        MesssageBoxErrors_MTS(IDS_MTS_DOING_CREATEINPROC,hr);
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoCreateInstance().Start.")));
    hr = CoCreateInstance(CLSID_WamAdmin,NULL,CLSCTX_SERVER,IID_IWamAdmin2,(void **)&pIWamAdmin);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoCreateInstance().End.")));
    if (SUCCEEDED(hr))
    {
        hr = pIWamAdmin->AppCreate2(wchKeyPath, dwAppMode);
        pIWamAdmin->Release();
        if (FAILED(hr)) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("Create in-proc(type=%d) app on path %s failed, err=%x.\n"), dwAppMode, lpszKeyPath, hr));
            MyMessageBox(NULL, _T("CreateInProc:Error Creating Transaction Server InProc App."), hr, MB_OK | MB_SETFOREGROUND);
            MesssageBoxErrors_MTS(IDS_MTS_DOING_CREATEINPROC,hr);
        }
        else
        {
            iReturn = TRUE;
        }
    }
    else 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("Failed to CoCreateInstance of WamAdmin object. err=%x.\n"), hr));
        MyMessageBox(NULL, _T("CreateInProc:CoCreateInstance"), hr, MB_OK | MB_SETFOREGROUND);
        MesssageBoxErrors_MTS(IDS_MTS_DOING_CREATEINPROC,hr);
    }

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().Start.")));
    CoUninitialize();
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().End.")));

    return iReturn;
}

void CreateInProc_Wrap(LPCTSTR lpszPath, int iUseOOPPool)
{
    BOOL bDisplayMsgOnErrFlag = TRUE;
    int iReturn = FALSE;
	int bFinishedFlag = FALSE;
	UINT iMsg = NULL;
	do
	{
		iisDebugOut((LOG_TYPE_TRACE, _T("CreateInProc_Wrap(): %s\n"), lpszPath));
        
        iReturn = CreateInProc(lpszPath, iUseOOPPool);
		if (iReturn == TRUE)
		{
			break;
		}
		else
		{
			if (bDisplayMsgOnErrFlag == TRUE)
			{
				iMsg = MyMessageBox( NULL, IDS_RETRY, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
				switch ( iMsg )
				{
				case IDIGNORE:
					iReturn = TRUE;
					goto CreateInProc_Wrap_Exit;
				case IDABORT:
					iReturn = FALSE;
					goto CreateInProc_Wrap_Exit;
				case IDRETRY:
					break;
				default:
					break;
				}
			}
			else
			{
				// return whatever err happened
				goto CreateInProc_Wrap_Exit;
			}

		}
	} while (iReturn  != TRUE);

CreateInProc_Wrap_Exit:
	return;
}

void DeleteInProc(LPCTSTR lpszPath)
{
    TCHAR lpszKeyPath[_MAX_PATH];
    WCHAR wchKeyPath[_MAX_PATH];
    HRESULT         hr = NOERROR;
    IWamAdmin*        pIWamAdmin = NULL;

    iisDebugOut((LOG_TYPE_TRACE, _T("DeleteInProc():Start.%s\n"), lpszPath));
    

    if (lpszPath[0] == _T('/')) 
    {
        _tcscpy(lpszKeyPath, lpszPath);
    }
    else 
    {
        lpszKeyPath[0] = _T('/');
        _tcscpy(_tcsinc(lpszKeyPath), lpszPath);
    }

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wchKeyPath, lpszKeyPath);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lpszKeyPath, -1, (LPWSTR)wchKeyPath, _MAX_PATH);
#endif

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoInitializeEx().Start.")));
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoInitializeEx().End.")));
    if (FAILED(hr))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("DeleteInProc: CoInitializeEx() failed, hr=%x\n"), hr));
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoCreateInstance().Start.")));
    hr = CoCreateInstance(CLSID_WamAdmin,NULL,CLSCTX_SERVER,IID_IWamAdmin,(void **)&pIWamAdmin);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoCreateInstance().End.")));
    if (SUCCEEDED(hr))
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("DeleteInProc():Calling AppDelete now.%s\n"), lpszKeyPath));
        hr = pIWamAdmin->AppDelete(wchKeyPath, TRUE);
        pIWamAdmin->Release();
        if (FAILED(hr))
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("Delete in-proc app on path %s failed, err=%x.\n"), lpszKeyPath, hr));
        }
    }
    else 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("DeleteInProc:CoCreateInstance() failed. err=%x.\n"), hr));
    }

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().Start.")));
    CoUninitialize();
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().End.")));

    iisDebugOut_End1(_T("DeleteInProc"),(LPTSTR) lpszPath,LOG_TYPE_TRACE);
    return;
}

INT_PTR CALLBACK pSecureRetryIgnoreAllDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND hTextWording = NULL;
    CString csErrMsg;
    HRESULT hErrorCode;
    TCHAR pMsg[_MAX_PATH] = _T("");
    HRESULT nNetErr;
    DWORD dwFormatReturn = 0;

    switch (msg)
    {
        case WM_INITDIALOG:
			uiCenterDialog(hDlg);
            hTextWording = GetDlgItem(hDlg, IDC_STATIC2);

            hErrorCode = (HRESULT) lParam;
            nNetErr = (HRESULT) hErrorCode;
            dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, hErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
            if ( dwFormatReturn == 0) 
            {
                if (nNetErr >= NERR_BASE) 
		        {
                    HMODULE hDll = (HMODULE)LoadLibrary(_T("netmsg.dll"));
                    if (hDll) 
			        {
                        dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,hDll, hErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
                        FreeLibrary(hDll);
                    }
                }
            }

            if (dwFormatReturn) {csErrMsg.Format(_T("0x%x=%s"), hErrorCode, pMsg);}
            else{csErrMsg.Format(_T("%s\n\nErrorCode=0x%x."), hErrorCode);}
           
            SetWindowText(hTextWording, csErrMsg);
            UpdateWindow(hDlg);
            break;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDCANCEL:
                    EndDialog(hDlg, (int)wParam);
                    return FALSE;
                case IDRETRY:
                    EndDialog(hDlg, (int)wParam);
                    return FALSE;
                    break;
                case IDWRITEUNENCRYPTED:
                    EndDialog(hDlg, (int)wParam);
                    return TRUE;
                    break;
                case IDWRITEUNENCRYPTEDALL:
                    g_bGlobalWriteUnSecuredIfFailed_All = TRUE;
                    EndDialog(hDlg, (int)wParam);
                    return TRUE;
                    break;
            }
            break;
    }
    return FALSE;
}

//-----------------------------------------------------------------------------
// get a multi-sz data block and immediately parse it into a CStringList
HRESULT CMDKey::GetMultiSzAsStringList (
    DWORD dwMDIdentifier,
    DWORD *uType,
    DWORD *attributes,
    CStringList& szStrList,
    PWCHAR pszSubString         OPTIONAL )
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    DWORD   cbBuffer;

    // make sure the key is open
    if ( NULL == m_hKey )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: GetMultiSzAsStringList on unopened node.%s\n"), _T("")));
        return -1;
    }


    // get the paths. The loop accounts for a buffer that is too small...
    DWORD  dwMDBufferSize = 1024;
    PWCHAR pwchBuffer = NULL;
    do
    {
        if ( pwchBuffer )
        {
            delete pwchBuffer;
            pwchBuffer = NULL;
        }

        pwchBuffer = new WCHAR[dwMDBufferSize];
        if (pwchBuffer == NULL)
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        // prepare the metadata parameter block
        MD_SET_DATA_RECORD(&mdrData, dwMDIdentifier, *attributes,
                *uType, MULTISZ_METADATA, dwMDBufferSize, pwchBuffer);

        // make the call to get the data
        // If the buffer is too small, the correct size will be put into dwMDBufferSize
        hRes = m_pcCom->GetData(
            m_hKey,
            pszSubString,
            &mdrData,
            &dwMDBufferSize
            );

        // Set the attributes return.
        *attributes = mdrData.dwMDAttributes;
        *uType = mdrData.dwMDUserType;
    }
    while( HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER);

    // if there were any failures, go to the cleanup code now...
    if ( SUCCEEDED(hRes) )
    {
        // at this point, we have the data we want. Time to convert it into a CString list.
        if (pwchBuffer)
        {
            // to make prefix stop yelling at me
            if (pwchBuffer[0])
            {
                ConvertWDoubleNullListToStringList(pwchBuffer, szStrList);
            }
        }
    }

    // clean up
    if ( pwchBuffer )
        delete pwchBuffer;

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::GetMultiSzAsStringList() failed. err=%x.\n"), hRes));
    }

    return hRes;
}

//-----------------------------------------------------------------------------
// take a CStringList and set it into metadata as a multi-sz
HRESULT CMDKey::SetMultiSzAsStringList (
    DWORD dwMDIdentifier,
    DWORD uType,
    DWORD attributes,
    CStringList& szStrList,
    PWCHAR pszSubString         OPTIONAL )
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    DWORD   cbBuffer;

    // make sure the key is open
    if ( NULL == m_hKey )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: SetMultiSzAsStringList on unopened node.%s\n"), _T("")));
        return -1;
    }


    DWORD  dwMDBufferSize = 0;
    PWCHAR pwchBuffer = NULL;

    // convert the cstringlist into a wide multisz data block.
    hRes = ConvertStringListToWDoubleNullList(
        szStrList,
        dwMDBufferSize,
        pwchBuffer
        );
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: SetMultiSzAsStringList Convert to null list.%x\n"), hRes));
        return hRes;
    }

    // the buffer is expressed in wide characters. Change it to bytes...
    dwMDBufferSize *= sizeof(WCHAR);

    // prepare the metadata parameter block
    MD_SET_DATA_RECORD(&mdrData, dwMDIdentifier, attributes,
            uType, MULTISZ_METADATA, dwMDBufferSize, pwchBuffer);

    // make the call to get the data
    hRes = m_pcCom->SetData(
        m_hKey,
        pszSubString,
        &mdrData
        );

    // clean up
    FreeMem( pwchBuffer );

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::SetMultiSzAsStringList()-SetData failed. err=%x.\n"), hRes));
    }

    return hRes;
}

//-----------------------------------------------------------------------------
// get all the sub keys that have a certain property on them and return the
// sub-paths in a cstring list object. The cstring list should be instantiated
// by the caller and deleted by the same.
HRESULT CMDKey::GetDataPaths( 
    DWORD dwMDIdentifier,
    DWORD dwMDDataType,
    CStringList& szPathList,
    PWCHAR pszSubString )
{
    HRESULT hRes = ERROR_SUCCESS;
    DWORD   cbBuffer;

    // make sure the key is open
    if ( NULL == m_hKey )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: GetDataPaths on unopened node.%s\n"), _T("")));
        return -1;
    }

    // get the paths. The loop accounts for a buffer that is too small...
    DWORD  dwMDBufferSize = 512;
    PWCHAR pwchBuffer = NULL;
    do
    {
        if ( pwchBuffer )
        {
            delete pwchBuffer;
            pwchBuffer = NULL;
        }

        pwchBuffer = new WCHAR[dwMDBufferSize];
        if (pwchBuffer == NULL)
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        // If the buffer is too small, the correct size will be put into dwMDBufferSize
        hRes = m_pcCom->GetDataPaths(
            m_hKey,
            pszSubString,
            dwMDIdentifier,
            dwMDDataType,
            dwMDBufferSize,
            pwchBuffer,
            &dwMDBufferSize
            );
    }
    while( HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER);

    // if there were any failures, go to the cleanup code now...
    if ( SUCCEEDED(hRes) )
    {
        // at this point, we have the data we want. Time to convert it into a CString list.
        ConvertWDoubleNullListToStringList(pwchBuffer, szPathList);
    }

    // clean up
    if ( pwchBuffer )
        delete pwchBuffer;

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::GetDataPaths() failed. err=%x.\n"), hRes));
    }

    return hRes;
}

//-----------------------------------------------------------------------------
// get a multi-sz data block and immediately parse it into a CStringList
HRESULT CMDKey::GetStringAsCString (
    DWORD dwMDIdentifier,
    DWORD uType,
    DWORD attributes,
    CString& szStr,
    PWCHAR pszSubString OPTIONAL,
    int iStringType OPTIONAL)
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    DWORD   cbBuffer;

    // make sure the key is open
    if ( NULL == m_hKey )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: GetStringAsCString on unopened node.%s\n"), _T("")));
        return -1;
    }

    // get the string. The loop accounts for a buffer that is too small...
    DWORD  dwMDBufferSize = 255;
    PWCHAR pwchBuffer = NULL;
    do
    {
        if ( pwchBuffer )
        {
            delete pwchBuffer;
            pwchBuffer = NULL;
        }

        pwchBuffer = new WCHAR[dwMDBufferSize + 1];
        ZeroMemory( pwchBuffer, (dwMDBufferSize + 1) * sizeof(WCHAR) );
        if (pwchBuffer == NULL)
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        // prepare the metadata parameter block
        MD_SET_DATA_RECORD(&mdrData, dwMDIdentifier, attributes,
                uType, STRING_METADATA, dwMDBufferSize, pwchBuffer);

        // make the call to get the data
        // If the buffer is too small, the correct size will be put into dwMDBufferSize
        hRes = m_pcCom->GetData(
            m_hKey,
            pszSubString,
            &mdrData,
            &dwMDBufferSize
            );
    }
    while( HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER);

    // if there were any failures, go to the cleanup code now...
    if ( SUCCEEDED(hRes) )
    {
        // at this point, we have the data we want. Time to convert it into a CString.
        szStr = pwchBuffer;
    }

    // clean up
    if ( pwchBuffer )
        delete pwchBuffer;

    if ( FAILED(hRes) && !MD_ERROR_DATA_NOT_FOUND)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::GetStringAsCString() failed. err=%x.\n"), hRes));
    }

    return hRes;
}

//-----------------------------------------------------------------------------
// take a CStringList and set it into metadata as a multi-sz
HRESULT CMDKey::SetCStringAsString (
    DWORD dwMDIdentifier,
    DWORD uType,
    DWORD attributes,
    CString& szStr,
    PWCHAR pszSubString OPTIONAL,
    int iStringType OPTIONAL)
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    DWORD   cbBuffer;

    // make sure the key is open
    if ( NULL == m_hKey )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: SetCStringAsString on unopened node.%s\n"), _T("")));
        return -1;
    }

    DWORD  dwMDBufferSize = 0;
    PWCHAR pwchBuffer = NULL;

    // convert the cstring into a wide string data block.
    pwchBuffer = AllocWideString( (LPCTSTR)szStr );

    // Calculate the size of the buffer in bytes, not wide characters....
    dwMDBufferSize = (szStr.GetLength() + 1) * sizeof(WCHAR);

    // prepare the metadata parameter block
    MD_SET_DATA_RECORD(&mdrData, dwMDIdentifier, attributes,
            uType, STRING_METADATA, dwMDBufferSize, pwchBuffer);

    // make the call to get the data
    hRes = m_pcCom->SetData(
        m_hKey,
        pszSubString,
        &mdrData
        );

    // clean up
    FreeMem( pwchBuffer );

    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::SetCStringAsString()-SetData failed. err=%x.\n"), hRes));
    }

    return hRes;
}

HRESULT CMDKey::GetDword(
    DWORD dwMDIdentifier,
    DWORD uType,
    DWORD attributes,
    DWORD& MyDword,
    PWCHAR pszSubString OPTIONAL
    )
{
    HRESULT hRes = ERROR_SUCCESS;
    METADATA_RECORD mdrData;
    DWORD   cbBuffer;
    DWORD   dwMDBufferSize = 255;
    LPBYTE  Buffer = NULL;

    // make sure the key is open
    if ( NULL == m_hKey )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: GetDword on unopened node.\n")));
        return -1;
    }

    // get the data. The loop accounts for a buffer that is too small...
    do
    {
        if ( Buffer )
        {
            delete Buffer;
            Buffer = NULL;
        }

        Buffer = (LPBYTE)LocalAlloc(LPTR, dwMDBufferSize);
        if (Buffer == NULL)
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        // prepare the metadata parameter block
        MD_SET_DATA_RECORD(&mdrData, dwMDIdentifier, attributes, uType, DWORD_METADATA, dwMDBufferSize, Buffer);

        // make the call to get the data
        // If the buffer is too small, the correct size will be put into dwMDBufferSize
        hRes = m_pcCom->GetData(m_hKey,pszSubString,&mdrData,&dwMDBufferSize);
    }
    while( HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER);

    // if there were any failures, go to the cleanup code now...
    if ( SUCCEEDED(hRes) )
    {
        // at this point, we have the data we want. Time to convert it into a dword.
        MyDword = (DWORD) *mdrData.pbMDData;
    }
    
    // clean up
    if ( Buffer )
        delete Buffer;

    if ( FAILED(hRes) && !MD_ERROR_DATA_NOT_FOUND)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CMDKey::GetDword() failed. err=%x.\n"), hRes));
    }

    return hRes;
}


HRESULT CMDKey::RenameNode(LPCTSTR pszMDPath,LPCTSTR pszMDNewName)
{
    HRESULT hRes = ERROR_SUCCESS;
    if (m_pcCom) 
    {
        WCHAR wszPath1[_MAX_PATH];
        WCHAR wszPath2[_MAX_PATH];
        
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(wszPath1, pszMDPath);
        _tcscpy(wszPath2, pszMDNewName);
#else
        MultiByteToWideChar( CP_ACP, 0, pszMDPath, -1, wszPath1, _MAX_PATH);
        MultiByteToWideChar( CP_ACP, 0, pszMDNewName, -1, wszPath2, _MAX_PATH);
#endif
        hRes = m_pcCom->RenameKey(m_hKey,wszPath1,wszPath2);
        if ( FAILED(hRes) && !MD_ERROR_DATA_NOT_FOUND)
        {
            iisDebugOut((LOG_TYPE_WARN, _T("CMDKey::RenameNode(%s,%s) failed. err=%x.\n"), pszMDPath,pszMDNewName,hRes));
        }
   }
    return hRes;
};

CMDValue::CMDValue()
    :
    m_dwId(0),
    m_dwAttributes(0),
    m_dwUserType(0),
    m_dwDataType(0),
    m_cbDataLen(0)
{

}

CMDValue::~CMDValue()
{

}

// function: CMDValue::SetValue
//
// Set the value of the class to what the pointer points to
//
DWORD 
CMDValue::SetValue(DWORD dwId,
                    DWORD dwAttributes,
                    DWORD dwUserType,
                    DWORD dwDataType,
                    DWORD cbDataLen,
                    LPVOID pbData)
{
    if ( cbDataLen > m_bufData.QuerySize() )
    {
        if (!m_bufData.Resize(cbDataLen))
        {
            // Failed to Resize Data
            return FALSE;
        }
    }

    memcpy( m_bufData.QueryPtr(), pbData, cbDataLen );

    m_dwId = dwId;
    m_dwAttributes = dwAttributes;
    m_dwUserType = dwUserType;
    m_dwDataType = dwDataType;
    m_cbDataLen = cbDataLen;

    return TRUE;
}

// function: CMDValue::SetValue
//
// Set the value of the class the value of the string.  So if
// dwDataType is DWORD, we must first convert to DWORD before
// Setting the value
//
DWORD 
CMDValue::SetValue(DWORD dwId,
                    DWORD dwAttributes,
                    DWORD dwUserType,
                    DWORD dwDataType,
                    DWORD cbDataLen,
                    LPTSTR szDataString)
{
    if (dwDataType == DWORD_METADATA)
    {
        DWORD dwValue;

        dwValue = _ttoi(szDataString);

        return SetValue(dwId, dwAttributes, dwUserType, dwDataType, sizeof(DWORD), (LPVOID) &dwValue);
    }

    return SetValue(dwId, dwAttributes, dwUserType, dwDataType, cbDataLen, (LPVOID) szDataString);
}

BOOL  
CMDValue::IsEqual(DWORD dwDataType, DWORD cbDataLen, LPVOID pbData)
{
    if ( (dwDataType != m_dwDataType) ||
         ( cbDataLen != m_cbDataLen )
         )
    {
        return FALSE;
    }

    return ( memcmp(pbData,m_bufData.QueryPtr(),cbDataLen) == 0 );
}

BOOL  
CMDValue::IsEqual(DWORD dwDataType, DWORD cbDataLen, DWORD dwData)
{
    return IsEqual(dwDataType,cbDataLen,(LPVOID) &dwData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\ocpages.h ===
#include "stdafx.h"

//#define ENABLE_OC_PAGES

DWORD_PTR OC_REQUEST_PAGES_Func(IN LPCTSTR ComponentId,IN LPCTSTR SubcomponentId,IN UINT Function,IN UINT_PTR Param1,IN OUT PVOID Param2);

// Function Prototypes
#ifdef ENABLE_OC_PAGES
    HPROPSHEETPAGE CreatePage(int nID, DLGPROC pDlgProc);
    INT_PTR CALLBACK pWelcomePageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK pUpgradePageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK pMaintenancePageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK pSrcPathPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK pEULAPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK pFreshPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK pEarlyPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK pEndPageDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\oldcode.cpp ===
//
// checker.h <start>
//
#include <lmaccess.h>
#include <lmserver.h>
#include <lmapibuf.h>
#include <lmerr.h>

#define SECURITY_WIN32
#define ISSP_LEVEL  32
#define ISSP_MODE   1
#include <sspi.h>


#ifndef _CHICAGO_
    int CheckConfig_DoIt(HWND hDlg, CStringList &strListOfWhatWeDid);
    BOOL ValidatePassword(IN LPCWSTR UserName,IN LPCWSTR Domain,IN LPCWSTR Password);
#endif
DWORD WINAPI ChkConfig_MessageDialogThread(void *p);
BOOL CALLBACK ChkConfig_MessageDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
void CheckConfig(void);
int g_BigCancel = FALSE;
//
// checker.h  <end>
//

#ifndef _CHICAGO_
BOOL ValidatePassword(IN LPCWSTR UserName,IN LPCWSTR Domain,IN LPCWSTR Password)
/*++
Routine Description:
    Uses SSPI to validate the specified password
Arguments:
    UserName - Supplies the user name
    Domain - Supplies the user's domain
    Password - Supplies the password
Return Value:
    TRUE if the password is valid.
    FALSE otherwise.
--*/
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle ClientCredHandle;
    CredHandle ServerCredHandle;
    BOOL ClientCredAllocated = FALSE;
    BOOL ServerCredAllocated = FALSE;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    PSecPkgInfo PackageInfo = NULL;
    ULONG ClientFlags;
    ULONG ServerFlags;
    TCHAR TargetName[100];
    SEC_WINNT_AUTH_IDENTITY_W AuthIdentity;
    BOOL Validated = FALSE;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    AuthIdentity.User = (LPWSTR)UserName;
    AuthIdentity.UserLength = lstrlenW(UserName);
    AuthIdentity.Domain = (LPWSTR)Domain;
    AuthIdentity.DomainLength = lstrlenW(Domain);
    AuthIdentity.Password = (LPWSTR)Password;
    AuthIdentity.PasswordLength = lstrlenW(Password);
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( _T("NTLM"), &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }

    //
    // Acquire a credential handle for the server side
    //
    SecStatus = AcquireCredentialsHandle(
                    NULL,
                    _T("NTLM"),
                    SECPKG_CRED_INBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ServerCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ServerCredAllocated = TRUE;

    //
    // Acquire a credential handle for the client side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    _T("NTLM"),
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ClientCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ClientCredAllocated = TRUE;

    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        goto error_exit;
    }

    ClientFlags = ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT;

    InitStatus = InitializeSecurityContext(
                    &ClientCredHandle,
                    NULL,               // No Client context yet
                    NULL,
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( !NT_SUCCESS(InitStatus) ) {
        goto error_exit;
    }

    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        goto error_exit;
    }
    ServerFlags = ASC_REQ_EXTENDED_ERROR;

    AcceptStatus = AcceptSecurityContext(
                    &ServerCredHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( !NT_SUCCESS(AcceptStatus) ) {
        goto error_exit;
    }

    if (InitStatus != STATUS_SUCCESS)
    {

        //
        // Get the AuthenticateMessage (ClientSide)
        //

        ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
        AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
        if ( AuthenticateBuffer.pvBuffer == NULL ) {
            goto error_exit;
        }

        SecStatus = InitializeSecurityContext(
                        NULL,
                        &ClientContextHandle,
                        TargetName,
                        0,
                        0,                      // Reserved 1
                        SECURITY_NATIVE_DREP,
                        &ChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &AuthenticateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ( !NT_SUCCESS(SecStatus) ) {
            goto error_exit;
        }

        if (AcceptStatus != STATUS_SUCCESS) {

            //
            // Finally authenticate the user (ServerSide)
            //

            AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

            SecStatus = AcceptSecurityContext(
                            NULL,
                            &ServerContextHandle,
                            &AuthenticateDesc,
                            ServerFlags,
                            SECURITY_NATIVE_DREP,
                            &ServerContextHandle,
                            NULL,
                            &ContextAttributes,
                            &Lifetime );

            if ( !NT_SUCCESS(SecStatus) ) {
                goto error_exit;
            }
            Validated = TRUE;

        }

    }

error_exit:
    if (ServerCredAllocated) {
        FreeCredentialsHandle( &ServerCredHandle );
    }
    if (ClientCredAllocated) {
        FreeCredentialsHandle( &ClientCredHandle );
    }

    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
    return(Validated);
}
#endif

DWORD WINAPI ChkConfig_MessageDialogThread(void *p)
{
    HWND hDlg = (HWND)p;
	int iReturn = TRUE;
    CStringList strWhatWeDidList;
    CString csBigString;

	SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Scanning..."));

    // call our function
#ifndef _CHICAGO_
    CheckConfig_DoIt(hDlg, strWhatWeDidList);
#endif

    // check for cancellation
    if (g_BigCancel == TRUE) goto ChkConfig_MessageDialogThread_Cancelled;

	SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Completed."));

	// Hide the Search window
	ShowWindow(hDlg, SW_HIDE);

    // Loop thru the what we did list and display the messages:
    //strWhatWeDidList
    if (strWhatWeDidList.IsEmpty() == FALSE)
    {
        POSITION pos = NULL;
        CString csEntry;
        pos = strWhatWeDidList.GetHeadPosition();
        while (pos) 
        {
            csEntry = strWhatWeDidList.GetAt(pos);
            //iisDebugOutSafeParams((LOG_TYPE_WARN, _T("%1!s!\n"), csEntry));
            csBigString = csBigString + csEntry;
            csBigString = csBigString + _T("\n");

            strWhatWeDidList.GetNext(pos);
        }
    }
    else
    {
        csBigString = _T("No changes.");
    }

    TCHAR szBiggerString[_MAX_PATH];
    _stprintf(szBiggerString, _T("Changes:\n%s"), csBigString);

	MyMessageBox((HWND) GetDesktopWindow(), szBiggerString, _T("Check Config Done"), MB_OK);

ChkConfig_MessageDialogThread_Cancelled:
	PostMessage(hDlg, WM_COMMAND, IDCANCEL, 0);
	return iReturn;
}


//***************************************************************************
//*                                                                         
//* purpose: display the wait dailog and spawn thread to do stuff
//*
//***************************************************************************
BOOL CALLBACK ChkConfig_MessageDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    static HANDLE  hProc = NULL;
    DWORD   id;

    switch (uMsg)
    {
        case WM_INITDIALOG:
			uiCenterDialog(hDlg);
            hProc = CreateThread(NULL, 0, ChkConfig_MessageDialogThread, (LPVOID)hDlg, 0, &id);
            if (hProc == NULL)
            {
				MyMessageBox((HWND) GetDesktopWindow(), _T("Failed to CreateThread MessageDialogThread.\n"), MB_ICONSTOP);
                EndDialog(hDlg, -1);
            }
            UpdateWindow(hDlg);
            break;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDOK:
                case IDCANCEL:
					g_BigCancel = TRUE;
                    EndDialog(hDlg, (int)wParam);
                    return TRUE;
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}

void CheckConfig(void)
{
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("CheckConfig:"));
	DWORD err = FALSE;
    
	// Search for the ie setup program
	g_BigCancel = FALSE;
	if (-1 == DialogBox((HINSTANCE) g_MyModuleHandle, MAKEINTRESOURCE(IDD_DIALOG_MSG), NULL, (DLGPROC) ChkConfig_MessageDialogProc))
		{
        GetErrorMsg(GetLastError(), _T(": on CheckConfig"));
        }

    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
	return;
}


//
//  Function will open the metabase and check the iusr_ and iwam_ usernames.  
//  it will check if the names are still valid and if the passwords are still valid.
//
#ifndef _CHICAGO_
#define CheckConfig_DoIt_log _T("CheckConfig_DoIt")
int CheckConfig_DoIt(HWND hDlg, CStringList &strListOfWhatWeDid)
{
    int iReturn = FALSE;
    iisDebugOut_Start(CheckConfig_DoIt_log,LOG_TYPE_PROGRAM_FLOW);

    TCHAR szAnonyName_WAM[_MAX_PATH];
    TCHAR szAnonyPass_WAM[LM20_PWLEN+1];
    TCHAR szAnonyName_WWW[_MAX_PATH];
    TCHAR szAnonyPass_WWW[LM20_PWLEN+1];
    TCHAR szAnonyName_FTP[_MAX_PATH];
    TCHAR szAnonyPass_FTP[LM20_PWLEN+1];
    int iGotName_WWW = FALSE;
    int iGotPass_WWW = FALSE;
    int iGotName_WAM = FALSE;
    int iGotPass_WAM = FALSE;
    int iGotName_FTP = FALSE;
    int iGotPass_FTP = FALSE;

    INT iUserWasNewlyCreated = 0;

    TCHAR szEntry[_MAX_PATH];

    // Call CreatePassword to fill
    LPTSR pszPassword = NULL;
    pszPassword = CreatePassword(LM20_PWLEN+1);
    if (!pszPassword)
    {
        goto CheckConfig_DoIt_Exit;
    }

    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Checking for IISADMIN Service..."));

    if (CheckifServiceExist(_T("IISADMIN")) != 0 ) 
    {
        // the iisadmin service does not exist
        // so there is no way we can do anything with the metabase.
        goto CheckConfig_DoIt_Exit;
    }

    //
    // Get the WAM username and password
    //
    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Lookup iWam username..."));
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (TRUE == GetDataFromMetabase(_T("LM/W3SVC"), MD_WAM_USER_NAME, (PBYTE)szAnonyName_WAM, _MAX_PATH))
        {iGotName_WAM = TRUE;}
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (TRUE == GetDataFromMetabase(_T("LM/W3SVC"), MD_WAM_PWD, (PBYTE)szAnonyPass_WAM, _MAX_PATH))
        {iGotPass_WAM = TRUE;}

    //
    // Get the WWW username and password
    //
    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Lookup iUsr username..."));
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (TRUE == GetDataFromMetabase(_T("LM/W3SVC"), MD_ANONYMOUS_USER_NAME, (PBYTE)szAnonyName_WWW, _MAX_PATH))
        {iGotName_WWW = TRUE;}
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (TRUE == GetDataFromMetabase(_T("LM/W3SVC"), MD_ANONYMOUS_PWD, (PBYTE)szAnonyPass_WWW, _MAX_PATH))
        {iGotPass_WWW = TRUE;}

    //
    // Get the FTP username and password
    //
    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Lookup iUsr (ftp) username..."));
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (TRUE == GetDataFromMetabase(_T("LM/MSFTPSVC"), MD_ANONYMOUS_USER_NAME, (PBYTE)szAnonyName_FTP, _MAX_PATH))
        {iGotName_FTP = TRUE;}
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (TRUE == GetDataFromMetabase(_T("LM/MSFTPSVC"), MD_ANONYMOUS_PWD, (PBYTE)szAnonyPass_FTP, _MAX_PATH))
        {iGotPass_FTP = TRUE;}

    // Now check if the actual user accounts actually exist....
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (iGotName_WAM)
    {
        // check if username is blank
        if (szAnonyName_WAM)
        {
            // Check if this user actually exists...
            SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Checking if Wam user exists..."));
            if (IsUserExist(szAnonyName_WAM))
            {
                // Fine, the user exists.... let's validate the password too

                // Let's validate that the user has at least the appropriate rights...
                if (iGotPass_WAM)
                {
                    ChangeUserPassword((LPTSTR) szAnonyName_WAM, (LPTSTR) szAnonyPass_WAM);
                }
            }
            else
            {
                if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
                // the user does not exist, so let's create it
                SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Creating Wam Account..."));

                // Add it if it is not already there.
                _stprintf(szEntry,_T("Created the iwam_ account = %s."),szAnonyName_WAM);
                if (TRUE != IsThisStringInThisCStringList(strListOfWhatWeDid, szEntry))
                    {strListOfWhatWeDid.AddTail(szEntry);}
                if (iGotPass_WAM)
                {
                    // We were able to get the password from the metabase
                    // so lets create the user with that password
                    CreateIWAMAccount(szAnonyName_WAM,szAnonyPass_WAM,&iUserWasNewlyCreated);
                    if (1 == iUserWasNewlyCreated)
                    {
                        // Add to the list
                        g_pTheApp->UnInstallList_Add(_T("IUSR_WAM"),szAnonyName_WAM);
                    }
                }
                else
                {
                    // we were not able to get the password from the metabase
                    // so let's just create one and write it back to the metabase
                    CreateIWAMAccount(szAnonyName_WAM,pszPassword,&iUserWasNewlyCreated);
                    if (1 == iUserWasNewlyCreated)
                    {
                        // Add to the list
                        g_pTheApp->UnInstallList_Add(_T("IUSR_WAM"),szAnonyName_WAM);
                    }
                    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;

                    // write it to the metabase.
                    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Writing Wam Account to Metabase..."));
                    g_pTheApp->m_csWAMAccountName = szAnonyName_WAM;
                    g_pTheApp->m_csWAMAccountPassword = pszPassword;
                    WriteToMD_IWamUserName_WWW();
                }

                // Do Dcomcnfg?????
            }
        }
    }


    // Now check if the actual user accounts actually exist....
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (iGotName_WWW)
    {
        // check if username is blank
        if (szAnonyName_WWW)
        {
            // Check if this user actually exists...
            SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Checking if iUsr user exists..."));
            if (IsUserExist(szAnonyName_WWW))
            {
                // Fine, the user exists.... let's validate the password too

                // Let's validate that the user has at least the appropriate rights...
                if (iGotPass_WWW)
                {
                    ChangeUserPassword((LPTSTR) szAnonyName_WWW, (LPTSTR) szAnonyPass_WWW);
                }
            }
            else
            {
                if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
                // the user does not exist, so let's create it
                SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Creating iUsr Account..."));
                // Add it if it is not already there.
                _stprintf(szEntry,_T("Created the iusr_ account = %s."),szAnonyName_WWW);
                if (TRUE != IsThisStringInThisCStringList(strListOfWhatWeDid, szEntry))
                    {strListOfWhatWeDid.AddTail(szEntry);}

                if (iGotPass_WWW)
                {
                    // We were able to get the password from the metabase
                    // so lets create the user with that password
                    CreateIUSRAccount(szAnonyName_WWW,szAnonyPass_WWW,&iUserWasNewlyCreated);
                    if (1 == iUserWasNewlyCreated)
                    {
                        // Add to the list
                        g_pTheApp->UnInstallList_Add(_T("IUSR_WWW"),szAnonyName_WWW);
                    }
                }
                else
                {
                    // see if we can enumerate thru the lower nodes to find the password??????

                    // check if maybe the ftp stuff has the password there????

                    // we were not able to get the password from the metabase
                    // so let's just create one and write it back to the metabase
                    CreateIUSRAccount(szAnonyName_WWW,pszPassword,&iUserWasNewlyCreated);
                    if (1 == iUserWasNewlyCreated)
                    {
                        // Add to the list
                        g_pTheApp->UnInstallList_Add(_T("IUSR_WWW"),szAnonyName_WWW);
                    }
                    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;

                    // write it to the metabase.
                    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Writing iUsr Account to Metabase..."));
                    g_pTheApp->m_csWWWAnonyName = szAnonyName_WAM;
                    g_pTheApp->m_csWWWAnonyPassword = pszPassword;
                    WriteToMD_AnonymousUserName_WWW(FALSE);
                }

                // Do Dcomcnfg?????
            }
        }
    }

    // Now check if the actual user accounts actually exist....
    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;
    if (iGotName_FTP)
    {
        // check if username is blank
        if (szAnonyName_FTP)
        {
            // Check if this user actually exists...
            SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Checking if iUsr (ftp) user exists..."));
            if (IsUserExist(szAnonyName_FTP))
            {
                // Fine, the user exists.... let's validate the password too

                // Let's validate that the user has at least the appropriate rights...
                if (iGotPass_FTP)
                {
                    ChangeUserPassword((LPTSTR) szAnonyName_FTP, (LPTSTR) szAnonyPass_FTP);
                }
            }
            else
            {
                SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Creating iUsr (ftp) Account..."));
                if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;

                // Add it if it is not already there.
                _stprintf(szEntry,_T("Created the iusr_ account = %s."),szAnonyName_FTP);
                if (TRUE != IsThisStringInThisCStringList(strListOfWhatWeDid, szEntry))
                    {strListOfWhatWeDid.AddTail(szEntry);}

                // the user does not exist, so let's create it
                if (iGotPass_FTP)
                {
                    // We were able to get the password from the metabase
                    // so lets create the user with that password
                    CreateIUSRAccount(szAnonyName_FTP,szAnonyPass_FTP,&iUserWasNewlyCreated);
                    if (1 == iUserWasNewlyCreated)
                    {
                        // Add to the list
                        g_pTheApp->UnInstallList_Add(_T("IUSR_FTP"),szAnonyName_FTP);
                    }
                }
                else
                {
                    // see if we can enumerate thru the lower nodes to find the password??????

                    // check if maybe the www stuff has the password there????

                    // we were not able to get the password from the metabase
                    // so let's just create one and write it back to the metabase
                    CreateIUSRAccount(szAnonyName_FTP,pszPassword,&iUserWasNewlyCreated);
                    if (1 == iUserWasNewlyCreated)
                    {
                        // Add to the list
                        g_pTheApp->UnInstallList_Add(_T("IUSR_FTP"),szAnonyName_FTP);
                    }
                    if (g_BigCancel == TRUE) goto CheckConfig_DoIt_Exit;

                    // write it to the metabase.
                    SetWindowText(GetDlgItem(hDlg, IDC_STATIC_TOPLINE), _T("Writing iUsr (ftp) Account to Metabase..."));
                    g_pTheApp->m_csFTPAnonyName = szAnonyName_WAM;
                    g_pTheApp->m_csFTPAnonyPassword = pszPassword;
                    WriteToMD_AnonymousUserName_FTP(FALSE);
                }

                // Do Dcomcnfg?????
            }
        }
    }

    // If we did anything, then popup a messagebox to the user
    // about the warnings: changes....

CheckConfig_DoIt_Exit:
    if (pszPassword) {GlobalFree(pszPassword);pszPassword = NULL;}
    iisDebugOut_End(CheckConfig_DoIt_log,LOG_TYPE_PROGRAM_FLOW);
    return iReturn;
}
#endif

const TCHAR REG_MTS_INSTALLED_KEY1[] = _T("SOFTWARE\\Microsoft\\Transaction Server\\Setup(OCM)");
const TCHAR REG_MTS_INSTALLED_KEY2[] = _T("SOFTWARE\\Microsoft\\Transaction Server\\Setup");
int ReturnTrueIfMTSInstalled(void)
{
    int iReturn = TRUE;

    if (!g_pTheApp->m_fInvokedByNT)
    {
        int bMTSInstalledFlag = FALSE;
        CRegKey regMTSInstalledKey1( HKEY_LOCAL_MACHINE, REG_MTS_INSTALLED_KEY1, KEY_READ);
        CRegKey regMTSInstalledKey2( HKEY_LOCAL_MACHINE, REG_MTS_INSTALLED_KEY2, KEY_READ);

        if ( (HKEY)regMTSInstalledKey1 ) {bMTSInstalledFlag = TRUE;}
        if ( (HKEY)regMTSInstalledKey2 ) {bMTSInstalledFlag = TRUE;}
        if (bMTSInstalledFlag == TRUE)
        {
            // check if we can get to the MTS catalog object
            if (NOERROR != DoesMTSCatalogObjectExist())
            {
                bMTSInstalledFlag = FALSE;
                iReturn = FALSE;
                MyMessageBox(NULL, IDS_MTS_INCORRECTLY_INSTALLED, MB_OK | MB_SETFOREGROUND);
                goto ReturnTrueIfMTSInstalled_Exit;
            }
        }

        if (bMTSInstalledFlag != TRUE)
        {
            iReturn = FALSE;
            MyMessageBox(NULL, IDS_MTS_NOT_INSTALLED, MB_OK | MB_SETFOREGROUND);
            goto ReturnTrueIfMTSInstalled_Exit;
        }
    }

ReturnTrueIfMTSInstalled_Exit:
    return iReturn;
}


#ifndef _CHICAGO_
/*===================================================================
DoGoryCoInitialize

  Description:
     CoInitialize() of COM is extremely funny function. It can fail
     and respond with S_FALSE which is to be ignored by the callers!
     On other error conditions it is possible that there is a threading
     mismatch. Rather than replicate the code in multiple places, here
     we try to consolidate the functionality in some rational manner.


  Arguments:
     None

  Returns:
     HRESULT = NOERROR on (S_OK & S_FALSE)
      other errors if any failure
===================================================================*/
HRESULT DoGoryCoInitialize(void)
{
    HRESULT hr;

    // do the call to CoInitialize()
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoInitializeEx().Start.")));
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoInitializeEx().End.")));
    //
    // S_FALSE and S_OK are success.  Everything else is a failure and you don't need to call CoUninitialize.
    //
    if ( S_OK == hr || S_FALSE == hr) 
        {
            //
            // It is okay to have failure (S_FALSE) in CoInitialize()
            // This error is to be ignored and balanced with CoUninitialize()
            //  We will reset the hr so that subsequent use is rational
            //
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("DoGoryCoInitialize found duplicate CoInitialize\n")));
            hr = NOERROR;
        }
    else if (FAILED (hr)) 
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("DoGoryCoInitialize found Failed error 0x%x\n"), hr));
        }

    return ( hr);
}
#endif // _CHICAGO_



HRESULT DoesMTSCatalogObjectExist(void)
{
    HRESULT hr = NOERROR;
#ifndef _CHICAGO_
    ICatalog*             m_pCatalog = NULL;
    ICatalogCollection* m_pPkgCollection = NULL;

    hr = DoGoryCoInitialize();
    if ( FAILED(hr)) {return ( hr);}

    // Create instance of the catalog object
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoCreateInstance().Start.")));
    hr = CoCreateInstance(CLSID_Catalog, NULL, CLSCTX_SERVER, IID_ICatalog, (void**)&m_pCatalog);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoCreateInstance().End.")));
    if (FAILED(hr)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("Failed to CoCreateInstance of Catalog Object.,hr = %08x\n"), hr));
    }
    else 
    {
        BSTR  bstr;
        //
        // Get the Packages collection
        //
        bstr = SysAllocString(L"Packages");
        if (bstr)
        {
            hr = m_pCatalog->GetCollection(bstr, (IDispatch**)&m_pPkgCollection);
            FREEBSTR(bstr);
            if (FAILED(hr)) 
                {
                iisDebugOut((LOG_TYPE_ERROR, _T("m_pCatalog(%08x)->GetCollection() failed, hr = %08x\n"), m_pCatalog, hr));
                }
            else
                {
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("m_pCatalog(%08x)->GetCollection() Succeeded!, hr = %08x\n"), m_pCatalog, hr));
                //DBG_ASSERT( m_pPkgCollection != NULL);
                }
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("m_pCatalog(%08x)->GetCollection() failed.  out of memory!\n"), m_pCatalog));
        }
            
    }

    if (m_pPkgCollection != NULL ) 
    {
        RELEASE(m_pPkgCollection);
        m_pPkgCollection = NULL;
    }

    if (m_pCatalog != NULL ) 
    {
        RELEASE(m_pCatalog);
        m_pCatalog = NULL;
    }

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().Start.")));
    CoUninitialize();
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ole32:CoUninitialize().End.")));
#endif // _CHICAGO_
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\product.cpp ===
#include "stdafx.h"
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "mdentry.h"
#include "mdacl.h"
#include "helper.h"
#include "ocmanage.h"
#include "dllmain.h"

INT Register_iis_common()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_common__before"));

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("register_iis_common_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_common_after"));
    return (0);
}

INT Unregister_iis_common()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_common__before"));

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("unregister_iis_common_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_common_after"));
    return (0);

}

INT Register_iis_inetmgr()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];
    ACTION_TYPE atINETMGR = GetSubcompAction(_T("iis_inetmgr"), TRUE);

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_inetmgr_before"));

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("register_iis_inetmgr_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_inetmgr_after"));
    return (0);
}

INT Unregister_iis_inetmgr()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_inetmgr_before"));

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("unregister_iis_inetmgr_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_inetmgr_after"));
    return (0);
}



INT Register_iis_doc()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_doc__before"));

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("register_iis_doc_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_doc_after"));
    return (0);
    return 0;
}


// for backward compat
#define     PWS_TRAY_WINDOW_CLASS       _T("PWS_TRAY_WINDOW")

INT Register_iis_pwmgr()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];
    ACTION_TYPE atPWMGR = GetSubcompAction(_T("iis_pwmgr"),TRUE);

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_pwmgr_before"));

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("register_iis_pwmgr_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_pwmgr_after"));
    return (0);


    return (0);
}

INT Unregister_iis_pwmgr()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_pwmgr_before"));

    // kill pwstray.exe
    HWND hwndTray = NULL;
    hwndTray = FindWindow(PWS_TRAY_WINDOW_CLASS, NULL);
    if ( hwndTray ){::PostMessage( hwndTray, WM_CLOSE, 0, 0 );}

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("unregister_iis_pwmgr_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);
        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_pwmgr_after"));
    return (0);
}



//
// (un)register-Order is important here
//
#define Register_iis_core_log _T("Register_iis_core")
INT Register_iis_core()
{
    INT err = 0;
    int iTempFlag = FALSE;
    INT iUserWasNewlyCreated = 0;
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    iisDebugOut_Start(Register_iis_core_log, LOG_TYPE_PROGRAM_FLOW);
    ACTION_TYPE atCORE = GetIISCoreAction(TRUE);
    ACTION_TYPE atFTP = GetSubcompAction(_T("iis_ftp"), FALSE);
    ACTION_TYPE atWWW = GetSubcompAction(_T("iis_www"), FALSE);

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_core_before"));
    AdvanceProgressBarTickGauge();

#ifndef _CHICAGO_
    if ( atCORE == AT_INSTALL_FRESH ||  g_pTheApp->m_bWin95Migration || (atCORE == AT_INSTALL_REINSTALL && g_pTheApp->m_bRefreshSettings) ) 
    {
        int iSomethingWasSet = FALSE;
        g_pTheApp->m_csWWWAnonyName = g_pTheApp->m_csGuestName;
        g_pTheApp->m_csWWWAnonyPassword = g_pTheApp->m_csGuestPassword;
        g_pTheApp->m_csFTPAnonyName = g_pTheApp->m_csGuestName;
        g_pTheApp->m_csFTPAnonyPassword = g_pTheApp->m_csGuestPassword;

        // Check if there were any specified unattended users
        // if they specified a www user, then we'll try to use that one.
        
        // if www was specified to be install, then check for that specified name...
        if (atWWW == AT_INSTALL_FRESH) 
        {
            if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_NAME)
            {
                if (_tcsicmp(g_pTheApp->m_csWWWAnonyName_Unattend,_T("")) != 0)
                {
                    g_pTheApp->m_csWWWAnonyName = g_pTheApp->m_csWWWAnonyName_Unattend;
                    iSomethingWasSet = TRUE;
                }
            }
            if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_PASS)
            {
                g_pTheApp->m_csWWWAnonyPassword = g_pTheApp->m_csWWWAnonyPassword_Unattend;
                iSomethingWasSet = TRUE;
            }
        }


        if (TRUE == iSomethingWasSet)
            {
                CreateIUSRAccount(g_pTheApp->m_csWWWAnonyName, g_pTheApp->m_csWWWAnonyPassword,&iUserWasNewlyCreated);
                if (1 == iUserWasNewlyCreated)
                {
                    // Add to the list
                    g_pTheApp->UnInstallList_Add(_T("IUSR_WWW"),g_pTheApp->m_csWWWAnonyName);
                }
            }
        else
        {
            // check if we're setting up ftp
            // if ftp was specified to be install, then check for that specified name...
            if (atFTP == AT_INSTALL_FRESH) 
            {

                if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_NAME)
                {
                    if (_tcsicmp(g_pTheApp->m_csFTPAnonyName_Unattend,_T("")) != 0)
                    {
                        g_pTheApp->m_csFTPAnonyName = g_pTheApp->m_csFTPAnonyName_Unattend;
                        iSomethingWasSet = TRUE;
                    }
                }

                if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_FTP_USER_PASS)
                {
                    g_pTheApp->m_csFTPAnonyPassword = g_pTheApp->m_csFTPAnonyPassword_Unattend;
                    iSomethingWasSet = TRUE;
                }
            }
            if (TRUE == iSomethingWasSet)
            {
                CreateIUSRAccount(g_pTheApp->m_csFTPAnonyName, g_pTheApp->m_csFTPAnonyPassword,&iUserWasNewlyCreated);
                if (1 == iUserWasNewlyCreated)
                {
                    // Add to the list
                    g_pTheApp->UnInstallList_Add(_T("IUSR_FTP"),g_pTheApp->m_csFTPAnonyName);
                }
            }
            else
            {
                // Ah, nothing specified by user.  
                // just Create IUSR_ account, with defaults!
                CreateIUSRAccount(g_pTheApp->m_csGuestName, g_pTheApp->m_csGuestPassword,&iUserWasNewlyCreated);
            }
        }

        AdvanceProgressBarTickGauge();
    }
#endif // _CHICAGO_

    SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle, 33000, g_pTheApp->m_csGuestName);

    iCount = 0;
    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("register_iis_core_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);

        AdvanceProgressBarTickGauge();
    }


    // Add special property registry key
    WriteToMD_IDRegistration(_T("LM/IISADMIN/PROPERTYREGISTRATION"));

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_core_after"));

    iisDebugOut_End(Register_iis_core_log, LOG_TYPE_PROGRAM_FLOW);
    return (err);
}

#define Unregister_iis_core_log _T("Unregister_iis_core")
INT Unregister_iis_core()
{
    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    iisDebugOut_Start(Unregister_iis_core_log, LOG_TYPE_PROGRAM_FLOW);

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_core_before"));
    AdvanceProgressBarTickGauge();

    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;
        _stprintf(szTempSection, _T("unregister_iis_core_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);

        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_core_after"));
    AdvanceProgressBarTickGauge();
    ShowIfModuleUsedForGroupOfSections(g_pTheApp->m_hInfHandle, TRUE);
    AdvanceProgressBarTickGauge();

    iisDebugOut_End(Unregister_iis_core_log, LOG_TYPE_PROGRAM_FLOW);
    return 0;
}


#define Unregister_old_asp_log _T("Unregister_old_asp")
INT Unregister_old_asp()
{
    //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("Unreg_old_asp:"));
    iisDebugOut_Start(Unregister_old_asp_log, LOG_TYPE_TRACE);

    CRegKey regASPUninstall(HKEY_LOCAL_MACHINE, REG_ASP_UNINSTALL, KEY_READ);
    if ((HKEY)regASPUninstall) 
    {
        // old asp exists
        ProcessSection(g_pTheApp->m_hInfHandle, _T("Unregister_old_asp"));

        // do not remove these dirs, aaronl
        //RecRemoveDir(g_pTheApp->m_csPathAdvWorks);
        //RecRemoveDir(g_pTheApp->m_csPathASPSamp);
        CRegKey regWWWVRoots( HKEY_LOCAL_MACHINE, REG_WWWVROOTS);
        if ((HKEY)regWWWVRoots) 
        {
            regWWWVRoots.DeleteValue(_T("/IASDocs"));
            // delete "/IASDocs," or "/IASDocs,<ip>"
            CRegValueIter regEnum( regWWWVRoots );
            CString csName, csValue;
            while ( regEnum.Next( &csName, &csValue ) == ERROR_SUCCESS ) 
            {
                csName.MakeUpper();
                if (csName.Left(9) == _T("/IASDOCS,"))
                    {
                    regWWWVRoots.DeleteValue((LPCTSTR)csName);
                    // tell the iterator to account for the item we just deleted
                    regEnum.Decrement();
                    }
            }
            // do not remove these vroots,aaronl
            //regWWWVRoots.DeleteValue(_T("/AdvWorks"));
            //regWWWVRoots.DeleteValue(_T("/ASPSamp"));
        }
    }
    iisDebugOut_End(Unregister_old_asp_log, LOG_TYPE_TRACE);
    //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\other.cpp ===
#include "stdafx.h"
#include "lzexpand.h"
#include <loadperf.h>
#include "setupapi.h"
#include <ole2.h>
#include <iis64.h>
#include "iadmw.h"
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "dcomperm.h"
#include "ocmanage.h"
#include "log.h"
#include "kill.h"
#include "svc.h"
#include "other.h"


extern OCMANAGER_ROUTINES gHelperRoutines;
extern int g_GlobalDebugLevelFlag;
extern int g_GlobalDebugCallValidateHeap;

// stuff for finding out architecture type of a file
#define IMAGE_BASE_TO_DOS_HEADER(b) ((PIMAGE_DOS_HEADER)(b))
#define IMAGE_BASE_TO_NT_HEADERS(b) ((PIMAGE_NT_HEADERS)( (DWORD_PTR)(b) + ((PIMAGE_DOS_HEADER)(b))->e_lfanew ))
#define IMAGE_BASE_TO_FILE_HEADER(b) ((PIMAGE_FILE_HEADER)( &IMAGE_BASE_TO_NT_HEADERS(b)->FileHeader ))

//
// PSAPI.DLL
//
HINSTANCE g_hInstLib_PSAPI = NULL;
// PSAPI.DLL "EnumProcessModules"
typedef BOOL  (WINAPI *PfnEnumProcessModules)(HANDLE hProcess, HMODULE * lphModule, DWORD cb, LPDWORD lpcbNeeded);
BOOL  (WINAPI *g_lpfEnumProcessModules)(HANDLE hProcess, HMODULE * lphModule, DWORD cb, LPDWORD lpcbNeeded);
// PSAPI.DLL "GetModuleFileNameExA","GetModuleFileNameExW"
typedef BOOL  (WINAPI *PfnGetModuleFileNameEx)(HANDLE hProcess, HMODULE lphModule, LPTSTR lpFileName, DWORD dwSize);
BOOL  (WINAPI *g_lpfGetModuleFileNameEx)(HANDLE hProcess, HMODULE lphModule, LPTSTR lpFileName, DWORD dwSize);


DWORD LogHeapState(BOOL bLogSuccessStateToo, char *szFileName, int iLineNumber)
{
    DWORD dwReturn = E_FAIL;

    if (!g_GlobalDebugCallValidateHeap)
    {
        // don't even call RtlValidateHeap
        dwReturn = ERROR_SUCCESS;
        return dwReturn;
    }

#ifndef _CHICAGO_
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ntdll:RtlProcessHeap().Start.")));
    if ( RtlValidateHeap( RtlProcessHeap(), 0, NULL ) )
    {
        // HEAP IS GOOD
        dwReturn = ERROR_SUCCESS;
	    if (bLogSuccessStateToo) {iisDebugOut((LOG_TYPE_TRACE, _T("RtlValidateHeap(): Good.\n")));}
    }
    else
    {
#if defined(UNICODE) || defined(_UNICODE)
        LPWSTR  pwsz = NULL;
        pwsz = MakeWideStrFromAnsi(szFileName);
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("RtlValidateHeap(): Corrupt!!! %1!s!:Line %2!d!.  FAILURE!\n"), pwsz, iLineNumber));

        if (pwsz)
        {
            //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ntdll:CoTaskMemFree().Start.")));
            CoTaskMemFree(pwsz);
            //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ntdll:CoTaskMemFree().End.")));
        }
#else
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("RtlValidateHeap(): Corrupt!!! %1!s!:Line %2!d!.  FAILURE!\n"), szFileName, iLineNumber));
#endif
    }
#endif
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ntdll:RtlProcessHeap().End.")));
    return dwReturn;
}


DWORD LogPendingReBootOperations(void)
// Returns !ERROR_SUCCESS if there are reboot operations which
// need to get taken are of before we can run setup.
{
	DWORD dwReturn = ERROR_SUCCESS;
    CString csFormat, csMsg;

    // If any of the services that we install
    // is in the funky state = ERROR_SERVICE_MARKED_FOR_DELETE
    // That means that the user needs to reboot before we can
    // reinstall the service!  otherwise setup will be hosed!

    int iSaveOld_AllowMessageBoxPopups = g_pTheApp->m_bAllowMessageBoxPopups;
    g_pTheApp->m_bAllowMessageBoxPopups = TRUE;


#ifndef _CHICAGO_
    // Check if the HTTP drive is marked for deletion
    if (TRUE == CheckifServiceMarkedForDeletion(_T("HTTP")))
    {
        MyMessageBox(NULL, IDS_SERVICE_IN_DELETE_STATE, _T("SPUD"),ERROR_SERVICE_MARKED_FOR_DELETE, MB_OK | MB_SETFOREGROUND);
        dwReturn = !ERROR_SUCCESS;
    }

    // Check if the spud driver is marked for deletion
    if (TRUE == CheckifServiceMarkedForDeletion(_T("SPUD")))
    {
        MyMessageBox(NULL, IDS_SERVICE_IN_DELETE_STATE, _T("SPUD"),ERROR_SERVICE_MARKED_FOR_DELETE, MB_OK | MB_SETFOREGROUND);
        dwReturn = !ERROR_SUCCESS;
    }

    // Check if the iisadmin service is marked for deletion
    if (TRUE == CheckifServiceMarkedForDeletion(_T("IISADMIN")))
    {
        MyMessageBox(NULL, IDS_SERVICE_IN_DELETE_STATE, _T("IISADMIN"),ERROR_SERVICE_MARKED_FOR_DELETE, MB_OK | MB_SETFOREGROUND);
        dwReturn = !ERROR_SUCCESS;
    }

    // Check if the W3SVC service is marked for deletion
    if (TRUE == CheckifServiceMarkedForDeletion(_T("W3SVC")))
    {
        MyMessageBox(NULL, IDS_SERVICE_IN_DELETE_STATE, _T("W3SVC"),ERROR_SERVICE_MARKED_FOR_DELETE, MB_OK | MB_SETFOREGROUND);
        dwReturn = !ERROR_SUCCESS;
    }

    // Check if the MSFTPSVC service is marked for deletion
    if (TRUE == CheckifServiceMarkedForDeletion(_T("MSFTPSVC")))
    {
        MyMessageBox(NULL, IDS_SERVICE_IN_DELETE_STATE, _T("MSFTPSVC"),ERROR_SERVICE_MARKED_FOR_DELETE, MB_OK | MB_SETFOREGROUND);
        dwReturn = !ERROR_SUCCESS;
    }

#endif //_CHICAGO_

    g_pTheApp->m_bAllowMessageBoxPopups = iSaveOld_AllowMessageBoxPopups;

	return dwReturn;
}

// Get the .inf section.  which has the file names
// get the corresponding directory
// print out the file date and versions of these files.
DWORD LogFileVersionsForThisINFSection(IN HINF hFile, IN LPCTSTR szSection)
{
    DWORD dwReturn = ERROR_SUCCESS;
    LPTSTR  szLine = NULL;
    DWORD   dwRequiredSize;
    BOOL    b = FALSE;
    CString csFile;
    DWORD   dwMSVer, dwLSVer;

    INFCONTEXT Context;

    TCHAR buf[_MAX_PATH];
    GetSystemDirectory( buf, _MAX_PATH);

    // go to the beginning of the section in the INF file
    b = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if (!b)
        {
        dwReturn = !ERROR_SUCCESS;
        goto LogFileVersionsForThisINFSection_Exit;
        }

    // loop through the items in the section.
    while (b) {
        // get the size of the memory we need for this
        b = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

        // prepare the buffer to receive the line
        szLine = (LPTSTR)GlobalAlloc( GPTR, dwRequiredSize * sizeof(TCHAR) );
        if ( !szLine )
            {
            goto LogFileVersionsForThisINFSection_Exit;
            }

        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
            {
            goto LogFileVersionsForThisINFSection_Exit;
            }

        // Attach the path to the from of this...
        // check in this directory:
        // 1. winnt\system32
        // --------------------------------------

        // may look like this "iisrtl.dll,,4"
        // so get rid of the ',,4'
        LPTSTR pch = NULL;
        pch = _tcschr(szLine, _T(','));
        if (pch) {_tcscpy(pch, _T(" "));}

        // Remove any trailing spaces.
        StripLastBackSlash(szLine);

        // Get the system dir
        csFile = buf;

        csFile = AddPath(csFile, szLine);

        LogFileVersion(csFile, TRUE);

        // find the next line in the section. If there is no next line it should return false
        b = SetupFindNextLine(&Context, &Context);

        // free the temporary buffer
        GlobalFree( szLine );
        szLine = NULL;
    }
    if (szLine) {GlobalFree(szLine);szLine=NULL;}


LogFileVersionsForThisINFSection_Exit:
    return dwReturn;
}

int LogFileVersion(IN LPCTSTR lpszFullFilePath, INT bShowArchType)
{
    int iReturn = FALSE;
    DWORD  dwMSVer, dwLSVer;

    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    SYSTEMTIME st;
    TCHAR szDate[40];
    TCHAR szTime[20];
    TCHAR szLocalizedVersion[100] = _T("");
    TCHAR szFileAttributes[20] = _T("----");
    DWORD dwFileSize = 0;

    BOOL bThisIsABinary = FALSE;
    BOOL bGotTime = FALSE;
    BOOL bGotFileSize = FALSE;

    if (!(lpszFullFilePath))
    {
        iisDebugOut((LOG_TYPE_WARN, _T("LogFileVersion(string fullfilepath, int showarchtype).  Invalid Parameter.")));
        return iReturn;
    }

    __try
    {
        if (IsFileExist(lpszFullFilePath))
        {
            TCHAR szExtensionOnly[_MAX_EXT] = _T("");
            _tsplitpath(lpszFullFilePath, NULL, NULL, NULL, szExtensionOnly);

            // Get version info for dll,exe,ocx only
            if (_tcsicmp(szExtensionOnly, _T(".exe")) == 0){bThisIsABinary=TRUE;}
            if (_tcsicmp(szExtensionOnly, _T(".dll")) == 0){bThisIsABinary=TRUE;}
            if (_tcsicmp(szExtensionOnly, _T(".ocx")) == 0){bThisIsABinary=TRUE;}

            // If this is the metabase.bin file then show the filesize!
            if (_tcsicmp(szExtensionOnly, _T(".bin")) == 0)
            {
                dwFileSize = ReturnFileSize(lpszFullFilePath);
                if (dwFileSize != 0xFFFFFFFF)
                {
                    // If we were able to get the file size.
                    bGotFileSize = TRUE;
                }
            }

            // If this is the metabase.xml file then show the filesize!
            if (_tcsicmp(szExtensionOnly, _T(".xml")) == 0)
            {
                dwFileSize = ReturnFileSize(lpszFullFilePath);
                if (dwFileSize != 0xFFFFFFFF)
                {
                    // If we were able to get the file size.
                    bGotFileSize = TRUE;
                }
            }

            // get the fileinformation
            // includes version and localizedversion
            MyGetVersionFromFile(lpszFullFilePath, &dwMSVer, &dwLSVer, szLocalizedVersion);

            hFile = FindFirstFile(lpszFullFilePath, &FindFileData);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                // Try to get the systemtime.
                if ( FileTimeToSystemTime( &FindFileData.ftCreationTime, &st) )
                {
                    GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, szDate, 64);
                    GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT | TIME_NOTIMEMARKER, &st, NULL, szTime, 64);
                    bGotTime = TRUE;
                }

                // Get the file attributes.
                _stprintf(szFileAttributes, _T("%s%s%s%s%s%s%s%s"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE ? _T("A") : _T("_"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED ? _T("C") : _T("_"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ? _T("D") : _T("_"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED ? _T("E") : _T("_"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN ? _T("H") : _T("_"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_NORMAL ? _T("N") : _T("_"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_READONLY ? _T("R") : _T("_"),
                    FindFileData.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM ? _T("S") : _T("_")
                    );

                if (bGotTime)
                {
                    if (bThisIsABinary)
                    {
                        if (bShowArchType)
                        {
                            TCHAR szFileArchType[30] = _T("");
                            LogFileArchType(lpszFullFilePath, szFileArchType);
                            if (szFileArchType)
                            {
                                // show everything
                                if (bGotFileSize)
                                {
                                    iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %d.%d.%d.%d: %s: %s: %s: %d"), szDate, szTime, szFileAttributes, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, szFileArchType, lpszFullFilePath, dwFileSize));
                                }
                                else
                                {
                                    iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %d.%d.%d.%d: %s: %s: %s"), szDate, szTime, szFileAttributes, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, szFileArchType, lpszFullFilePath));
                                }
                            }
                            else
                            {
                                // show without arch type
                                if (bGotFileSize)
                                {
                                    iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %d.%d.%d.%d: %s: %s: %d"), szDate, szTime, szFileAttributes, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, lpszFullFilePath, dwFileSize));
                                }
                                else
                                {
                                    iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %d.%d.%d.%d: %s: %s"), szDate, szTime, szFileAttributes, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, lpszFullFilePath));
                                }
                            }
                        }
                        else
                        {
                            // show without arch type
                            if (bGotFileSize)
                            {
                                iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %d.%d.%d.%d: %s: %s: %d"), szDate, szTime, szFileAttributes, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, lpszFullFilePath, dwFileSize));

                            }
                            else
                            {
                                iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %d.%d.%d.%d: %s: %s"), szDate, szTime, szFileAttributes, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, lpszFullFilePath));
                            }
                        }
                    }
                    else
                    {
                        // This is not a binary file, must be like a text file.
                        if (bGotFileSize)
                        {
                            iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %s: %d"), szDate, szTime, szFileAttributes, lpszFullFilePath, dwFileSize));
                        }
                        else
                        {
                            iisDebugOut((LOG_TYPE_TRACE, _T("%s %s %s %s"), szDate, szTime, szFileAttributes, lpszFullFilePath));
                        }
                   }
                }
                else
                {
                    // Show without filetime, since we couldn't get it
                    iisDebugOut((LOG_TYPE_TRACE, _T("%s %d.%d.%d.%d: %s: %s"), szFileAttributes, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, lpszFullFilePath));
                }

                FindClose(hFile);
            }
            iReturn = TRUE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("\r\nException Caught in LogFileVersion(%1!s!). GetExceptionCode()=0x%2!x!\r\n"), lpszFullFilePath, GetExceptionCode()));
    }

    return iReturn;
}

BOOL LogFilesInThisDir(LPCTSTR szDirName)
{
    BOOL bReturn = FALSE;
    DWORD retCode;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szTempFileName[_MAX_PATH] = _T("");
    TCHAR szDirNameCopy[_MAX_PATH] = _T("");
    TCHAR szDirName2[_MAX_PATH] = _T("");

    if (szDirName)
    {
        _tcscpy(szDirNameCopy, szDirName);
    }
    else
    {
        // get currentdir
        GetCurrentDirectory(_MAX_PATH, szDirNameCopy);
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("LogFilesInThisDir()=%1!s!.  No parameter specified, so using current dir.\n"), szDirNameCopy));
    }

    retCode = GetFileAttributes(szDirNameCopy);
    if (retCode == 0xFFFFFFFF){goto LogFilesInThisDir_Exit;}

    // if this is a file, then
    // do this for only this one file.
    if (!(retCode & FILE_ATTRIBUTE_DIRECTORY))
    {
        bReturn = LogFileVersion(szDirNameCopy, TRUE);
        goto LogFilesInThisDir_Exit;
    }

    // ok, this is a directory,
    // so tack on the *.* deal
    _stprintf(szDirName2, _T("%s\\*.*"), szDirNameCopy);
    hFile = FindFirstFile(szDirName2, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        do {
                // display the filename, if it is not a directory.
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        // this is a directory, so let's skip it
                    }
                    else
                    {
                        // this is a file, so let's output the info.
                        _stprintf(szTempFileName, _T("%s\\%s"), szDirNameCopy, FindFileData.cFileName);
                        if (LogFileVersion(szTempFileName, TRUE) == TRUE) {bReturn = TRUE;}
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) )
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }


LogFilesInThisDir_Exit:
    return bReturn;
}



/*----------------------------------------------------------------------------*\
  Function: StripLastBackSlash (TCHAR *)
  ----------------------------------------------------------------------------
  Description: StripLastBackSlash strips the last backslash in a path string
    NOTE: this code can be very easily broken as it lives under the assumption
         that the input string is a valid path (i.e. string of length two or greater)
\*----------------------------------------------------------------------------*/
TCHAR *StripLastBackSlash(TCHAR * i_szDir)
{
	TCHAR	* iszDir;
	iszDir = i_szDir + lstrlen(i_szDir);
	do
	{
		iszDir = CharPrev(i_szDir , iszDir);
	}
	while (((*iszDir == _T(' ')) || (*iszDir == _T('\\'))) && (iszDir != i_szDir));

	// If we came out of the loop and the current pointer still points to
	// a space or a backslash then all the string contains is some combination
	// of spaces and backspaces
	if ((*iszDir == _T(' ')) || (*iszDir == _T('\\')))
	{
		*i_szDir = _T('\0');
		return(i_szDir);
	}

	iszDir = CharNext(iszDir);
	*iszDir = _T('\0');
	return(i_szDir);
}


void LogCurrentProcessIDs(void)
{
    DWORD          numTasks = 0;
    PTASK_LIST     The_TList = NULL;

    // Allocate the TASK_LIST in the heap and not on the stack!
    The_TList = (PTASK_LIST) HeapAlloc(GetProcessHeap(), 0, sizeof(TASK_LIST) * MAX_TASKS);
    if (NULL == The_TList){goto LogCurrentProcessIDs_Exit;}

    // Get the task list for the system, store it in The_TList
    numTasks = GetTaskList( The_TList, MAX_TASKS);
    for (DWORD i=0; i<numTasks; i++)
    {
        TCHAR szTempString[_MAX_PATH];

#if defined(UNICODE) || defined(_UNICODE)
        MultiByteToWideChar( CP_ACP, 0, (char*) The_TList[i].ProcessName, -1, szTempString, _MAX_PATH);
#else
        _tcscpy(szTempString, The_TList[i].ProcessName);
#endif
        iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%4d] %s\n"), The_TList[i].dwProcessId, szTempString));
    }
LogCurrentProcessIDs_Exit:
    if (The_TList){HeapFree(GetProcessHeap(), 0, The_TList);The_TList = NULL;}
    return;
}


VOID LogFileArchType(LPCTSTR Filename, TCHAR * ReturnMachineType)
{
    HANDLE                 fileHandle;
    HANDLE                 mapHandle;
    DWORD                  fileLength;
    PVOID                  view;
    TCHAR                  szReturnedString[30] = _T("");

    //
    // Open the file.
    //
    fileHandle = CreateFile(Filename,GENERIC_READ,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    if( fileHandle == INVALID_HANDLE_VALUE )
		{
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("LogFileArchType: FAILURE: Cannot open %1!s!.\n"), Filename));
        return;
		}

    //
    // Get its size.
    //
    fileLength = GetFileSize(fileHandle,NULL);
    if( ( fileLength == (DWORD)-1L ) &&( GetLastError() != NO_ERROR ) )
		{
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("LogFileArchType: failure. cannot get size of %1!s!.\n"), Filename));
        CloseHandle( fileHandle );
        return;
		}
    if( fileLength < sizeof(IMAGE_DOS_HEADER) )
		{
        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("LogFileArchType: failure. %1!s! is an invalid image.\n"), Filename));
        CloseHandle( fileHandle );
        return;
		}

    //
    // Create the mapping.
    //
    mapHandle = CreateFileMapping(fileHandle,NULL,PAGE_READONLY,0,0,NULL);
    if( mapHandle == NULL )
		{
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("LogFileArchType: failure. Cannot create mapping for %1!s!.\n"), Filename));
        CloseHandle( fileHandle );
        return;
		}

    //
    // Map it in.
    //
    view = MapViewOfFile(mapHandle,FILE_MAP_READ,0,0,0);
    if( view == NULL )
		{
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("LogFileArchType: failure. Cannot map %1!s!.\n"), Filename));
        CloseHandle( mapHandle );
        CloseHandle( fileHandle );
        return;
		}

    //
    // Dump the image info.
    //
    _tcscpy(ReturnMachineType, _T(""));
    DumpFileArchInfo(Filename,view,fileLength, szReturnedString);
    _tcscpy(ReturnMachineType, szReturnedString);

    //
    // Cleanup.
    //
    UnmapViewOfFile( view );
    CloseHandle( mapHandle );
    CloseHandle( fileHandle );

    return;
}

TCHAR *MachineToString(DWORD Machine)
{
    switch( Machine )
	{
		case IMAGE_FILE_MACHINE_UNKNOWN :
			return _T("Unknown");
		case IMAGE_FILE_MACHINE_I386 :
			return _T("x86");
		case IMAGE_FILE_MACHINE_AMD64 :
			return _T("AMD64");
		case IMAGE_FILE_MACHINE_IA64 :
			return _T("IA64");
    }
    return _T("INVALID");
}

VOID DumpFileArchInfo(LPCTSTR Filename,PVOID View,DWORD Length,TCHAR *ReturnString)
{
    PIMAGE_DOS_HEADER      dosHeader;
    PIMAGE_NT_HEADERS      ntHeaders;
    PIMAGE_FILE_HEADER     fileHeader;

    //
    // Validate the DOS header.
    //
    dosHeader = IMAGE_BASE_TO_DOS_HEADER( View );
    if( dosHeader->e_magic != IMAGE_DOS_SIGNATURE )
		{
        return;
		}

    //
    // Validate the NT headers.
    //
    ntHeaders = IMAGE_BASE_TO_NT_HEADERS( View );
    if( ntHeaders->Signature != IMAGE_NT_SIGNATURE )
		{
        return;
		}

    fileHeader = IMAGE_BASE_TO_FILE_HEADER( View );
    //
    // Dump the info.
    //
	// dump machine type
    _tcscpy(ReturnString, MachineToString( fileHeader->Machine ));

    return;
}


void LogCheckIfTempDirWriteable(void)
{
    // attempt get the temp directory
    // and write to it.
    // we have had occurences where the tempdir was locked so,
    // some regsvr things failed.
    HANDLE hFile = NULL;
    TCHAR szTempFileName[_MAX_PATH+1];
    TCHAR szTempDir[_MAX_PATH+1];
    if (GetTempPath(_MAX_PATH,szTempDir) == 0)
    {
        // failed.
        iisDebugOut((LOG_TYPE_WARN, _T("LogCheckIfTempDirWriteable:GetTempPath() Failed.  POTENTIAL PROBLEM.  FAILURE.\n")));
    }
    else
    {
        // nope we got the temp dir
        // now let's get a tempfilename, write to it and
        // delete it.

        // trim off the last backslash...
        LPTSTR ptszTemp = _tcsrchr(szTempDir, _T('\\'));
        if (ptszTemp)
        {
            *ptszTemp = _T('\0');
        }

        if (GetTempFileName(szTempDir, _T("IIS"), 0, szTempFileName) != 0)
        {
            // Write to this file, and
            DeleteFile(szTempFileName);

		    // Open existing file or create a new one.
		    hFile = CreateFile(szTempFileName,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
		    if (hFile == INVALID_HANDLE_VALUE)
		    {
			    hFile = NULL;
                iisDebugOutSafeParams((LOG_TYPE_WARN, _T("LogCheckIfTempDirWriteable:LogTempDirLockedCheck() failed to CreateFile %1!s!. POTENTIAL PROBLEM.  FAILURE.\n"), szTempFileName));
		    }
            else
            {
                // write to the file
                if (hFile)
                {
                    DWORD dwBytesWritten = 0;
                    char szTestData[30];
                    strcpy(szTestData, "Test");
                    if (WriteFile(hFile,szTestData,strlen(szTestData),&dwBytesWritten,NULL))
                    {
                        // everything is hunky dory. don't print anything
                    }
                    else
                    {
                        // error writing to the file.
                        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("LogCheckIfTempDirWriteable:WriteFile(%1!s!) Failed.  POTENTIAL PROBLEM.  FAILURE.  Error=0x%2!x!.\n"), szTempFileName, GetLastError()));
                    }
                }
            }
            DeleteFile(szTempFileName);
        }
        else
        {
            iisDebugOutSafeParams((LOG_TYPE_WARN, _T("LogCheckIfTempDirWriteable:GetTempFileName(%1!s!, %2!s!) Failed.  POTENTIAL PROBLEM.  FAILURE.\n"), szTempDir, _T("IIS")));
        }
    }

    if (hFile)
    {
        CloseHandle(hFile);
        DeleteFile(szTempFileName);
    }
    return;
}


#ifndef _CHICAGO_

BOOL EnumProcessModules(HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded)
{
	if (!g_lpfEnumProcessModules)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("EnumProcessModules: unable to work\n")));
        return FALSE;
    }

	return g_lpfEnumProcessModules(hProcess, lphModule, cb, lpcbNeeded);
}


BOOL Init_Lib_PSAPI(void)
{
    BOOL bReturn = FALSE;

    // load the library
    if (!g_hInstLib_PSAPI){g_hInstLib_PSAPI = LoadLibrary( _T("PSAPI.DLL") ) ;}
	if( g_hInstLib_PSAPI == NULL ){goto Init_Library_PSAPI_Exit;}
	
    // get entry point
    if (!g_lpfEnumProcessModules)
        {g_lpfEnumProcessModules = (PfnEnumProcessModules) GetProcAddress( g_hInstLib_PSAPI, "EnumProcessModules");}
    if( g_lpfEnumProcessModules == NULL ){goto Init_Library_PSAPI_Exit;}

    // get entry point
#if defined(UNICODE) || defined(_UNICODE)
    if (!g_lpfGetModuleFileNameEx)
        {g_lpfGetModuleFileNameEx = (PfnGetModuleFileNameEx) GetProcAddress( g_hInstLib_PSAPI, "GetModuleFileNameExW");}
#else
    if (!g_lpfGetModuleFileNameEx)
        {g_lpfGetModuleFileNameEx = (PfnGetModuleFileNameEx) GetProcAddress( g_hInstLib_PSAPI, "GetModuleFileNameExA");}
#endif
    if( g_lpfGetModuleFileNameEx == NULL ){goto Init_Library_PSAPI_Exit;}

    bReturn = TRUE;

Init_Library_PSAPI_Exit:
    if (FALSE == bReturn)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("non fatal error initing lib:PSAPI.DLL\n")));
    }
    return bReturn;
}

#define MAX_MODULES 256
BOOL IsProcessUsingThisModule(LPWSTR lpwsProcessName,DWORD dwProcessId,LPWSTR ModuleName)
{
    BOOL    bReturn = FALSE;
    HANDLE  hRealProcess = NULL;
    DWORD   cbNeeded  = 0;
    int     iNumberOfModules = 0;
    bool    fProcessNameFound = FALSE;
    HMODULE hMod[MAX_MODULES];

    TCHAR   szFileName[_MAX_PATH] ;
    szFileName[0] = 0;


    if (FALSE == Init_Lib_PSAPI())
    {
        goto IsProcessUsingThisModule_Exit;
    }

    // if we don't have a dwProcessId, then get one from the filename!
    if (dwProcessId == 0)
    {
        __try
        {
           dwProcessId = FindProcessByNameW(lpwsProcessName);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("\r\nException Caught in FindProcessByNameW(%1!s!). GetExceptionCode()=0x%2!x!\r\n"), lpwsProcessName, GetExceptionCode()));
        }

        if( dwProcessId == 0 )
        {
            goto IsProcessUsingThisModule_Exit;
        }
    }

    hRealProcess = OpenProcess( MAXIMUM_ALLOWED,FALSE, dwProcessId );
    if( hRealProcess == NULL )
    {
        //iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("IsProcessUsingThisModule: OpenProcess failed!\n")));
        goto IsProcessUsingThisModule_Exit;
    }

    if (!EnumProcessModules(hRealProcess,hMod,MAX_MODULES * sizeof(HMODULE),&cbNeeded))
        {goto IsProcessUsingThisModule_Exit;}

    // loop thru the modules in this .exe file
    // and see if it matches the one we are looking for!
    iNumberOfModules = cbNeeded / sizeof(HMODULE);
	fProcessNameFound = false;
	for(int i=0; i<iNumberOfModules; i++)
	{
        szFileName[0] = 0 ;
		// Get Full pathname!
		if(g_lpfGetModuleFileNameEx(hRealProcess, (HMODULE) hMod[i], szFileName, sizeof( szFileName )))
        {
            // if the szFileName is equal to the file we are looking for then Viola,
            // we've found it in this certain process!

            //[lsass.exe] C:\WINNT4\System32\ntdll.dll
            //iisDebugOut((LOG_TYPE_TRACE, _T("IsProcessUsingThisModule:[%s] %s\n"),lpwsProcessName,szFileName));
            if (_tcsicmp(szFileName,ModuleName) == 0)
            {
                // we've found it so
                // now add it to the list
                bReturn = TRUE;
                goto IsProcessUsingThisModule_Exit;
            }
		}
	}

IsProcessUsingThisModule_Exit:
    if (hRealProcess) {CloseHandle( hRealProcess );}
    return bReturn;
}


BOOL DumpProcessModules(DWORD dwProcessId)
{
    BOOL    bReturn = FALSE;
    HANDLE  hRealProcess = NULL;
    DWORD   cbNeeded  = 0;
    int     iNumberOfModules = 0;
    HMODULE hMod[MAX_MODULES];
    TCHAR   szFileName[_MAX_PATH] ;
    szFileName[0] = 0;

    if (FALSE == Init_Lib_PSAPI())
        {goto DumpProcessModules_Exit;}

    hRealProcess = OpenProcess( MAXIMUM_ALLOWED,FALSE, dwProcessId );
    if( hRealProcess == NULL )
    {
        iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("DumpProcessModules: OpenProcess failed!\n")));
        goto DumpProcessModules_Exit;
    }

    if (!EnumProcessModules(hRealProcess,hMod,MAX_MODULES * sizeof(HMODULE),&cbNeeded))
        {goto DumpProcessModules_Exit;}

    // loop thru the modules in this .exe file
    // and see if it matches the one we are looking for!
    iNumberOfModules = cbNeeded / sizeof(HMODULE);
	for(int i=0; i<iNumberOfModules; i++)
	{
        bReturn = TRUE;

		// Get Full pathname!
		if(g_lpfGetModuleFileNameEx(hRealProcess, (HMODULE) hMod[i], szFileName, sizeof( szFileName )))
        {
            // if the szFileName is equal to the file we are looking for then Viola,
            // we've found it in this certain process!

            //[lsass.exe] C:\WINNT4\System32\ntdll.dll
            iisDebugOut((LOG_TYPE_TRACE, _T("[%d] %s\n"),dwProcessId,szFileName));
		}
	}

DumpProcessModules_Exit:
    if (hRealProcess) {CloseHandle( hRealProcess );}
    return bReturn;
}


DWORD WINAPI FindProcessByNameW(const WCHAR * pszImageName)
{
    DWORD      Result = 0;
    DWORD      numTasks = 0;
    PTASK_LIST The_TList = NULL;

    // Allocate the TASK_LIST in the heap and not on the stack!
    The_TList = (PTASK_LIST) HeapAlloc(GetProcessHeap(), 0, sizeof(TASK_LIST) * MAX_TASKS);
    if (NULL == The_TList){goto FindProcessByNameW_Exit;}

    // Get the task list for the system, store it in The_TList
    numTasks = GetTaskList( The_TList, MAX_TASKS);
    for (DWORD i=0; i<numTasks; i++)
    {
        TCHAR szTempString[_MAX_PATH];

#if defined(UNICODE) || defined(_UNICODE)
        MultiByteToWideChar( CP_ACP, 0, (char*) The_TList[i].ProcessName, -1, szTempString, _MAX_PATH);
#else
        _tcscpy(szTempString, The_TList[i].ProcessName);
#endif
        // compare this process name with what they want
        // if we found the fully pathed process name in our list of processes
        // then return back the ProcessID
        if( _tcsicmp( szTempString, pszImageName ) == 0)
        {
            Result = The_TList[i].dwProcessId;
            goto FindProcessByNameW_Exit;
        }
    }
FindProcessByNameW_Exit:
    if (The_TList){HeapFree(GetProcessHeap(), 0, The_TList);The_TList = NULL;}
    return Result;
}


void LogProcessesUsingThisModuleW(LPCTSTR szModuleNameToLookup, CStringList &strList)
{
    DWORD          numTasks = 0;
    PTASK_LIST     The_TList = NULL;

    // return if nothing to lookup
    if (!(szModuleNameToLookup)) {return;}

    // Allocate the TASK_LIST in the heap and not on the stack!
    The_TList = (PTASK_LIST) HeapAlloc(GetProcessHeap(), 0, sizeof(TASK_LIST) * MAX_TASKS);
    if (NULL == The_TList){goto LogProcessesUsingThisModuleW_Exit;}

    // Get the task list for the system, store it in The_TList
    numTasks = GetTaskList( The_TList, MAX_TASKS);
    for (DWORD i=0; i<numTasks; i++)
    {
        TCHAR szTempString[_MAX_PATH];

#if defined(UNICODE) || defined(_UNICODE)
        MultiByteToWideChar( CP_ACP, 0, (char*) The_TList[i].ProcessName, -1, szTempString, _MAX_PATH);
#else
        _tcscpy(szTempString, The_TList[i].ProcessName);
#endif

        if (TRUE == IsProcessUsingThisModule(szTempString,(DWORD) (DWORD_PTR) The_TList[i].dwProcessId,(TCHAR *) szModuleNameToLookup))
        {
            // Print out the .exe name
            //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("LogProcessesUsingThisModuleW:[%s] using %s\n"),szTempString,szModuleNameToLookup));

            // Add it the list of processes which are using this certain .dll
            //
            // something1.exe
            // something2.exe
            // something3.exe <----
            //
            // Add it to the strList if not already there!
            if (TRUE != IsThisStringInThisCStringList(strList, szTempString))
            {
                strList.AddTail(szTempString);
            }
        }
    }

LogProcessesUsingThisModuleW_Exit:
    if (The_TList){HeapFree(GetProcessHeap(), 0, The_TList);The_TList = NULL;}
    return;
}
#endif

void UnInit_Lib_PSAPI(void)
{
    // Free entry points and library
    if (g_lpfGetModuleFileNameEx){g_lpfGetModuleFileNameEx = NULL;}
    if (g_lpfEnumProcessModules){g_lpfEnumProcessModules = NULL;}
    if (g_hInstLib_PSAPI)
    {
		FreeLibrary(g_hInstLib_PSAPI) ;
		g_hInstLib_PSAPI = NULL;
    }
    return;
}

#ifdef _CHICAGO_
    void LogProcessesUsingThisModuleA(LPCTSTR szModuleNameToLookup, CStringList &strList)
    {
        return;
    }
#endif

void LogProcessesUsingThisModule(LPCTSTR szModuleNameToLookup, CStringList &strList)
{
#ifndef _CHICAGO_
    __try
    {
        LogProcessesUsingThisModuleW(szModuleNameToLookup, strList);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("ExceptionCaught!:LogProcessesUsingThisModule(): File:%1!s!\n"), szModuleNameToLookup));
    }
#else
    LogProcessesUsingThisModuleA(szModuleNameToLookup, strList);
#endif
    return;
}


#ifdef _CHICAGO_
    void LogThisProcessesDLLsA(void)
    {
        return;
    }
#else

void LogThisProcessesDLLsW(void)
{
    DWORD       numTasks  = 0;
    PTASK_LIST  The_TList = NULL;
    DWORD       ThisPid   = GetCurrentProcessId();;

    // Allocate the TASK_LIST in the heap and not on the stack!
    The_TList = (PTASK_LIST) HeapAlloc(GetProcessHeap(), 0, sizeof(TASK_LIST) * MAX_TASKS);
    if (NULL == The_TList){goto LogThisProcessesDLLsW_Exit;}

    // Get the task list for the system, store it in The_TList
    numTasks = GetTaskList( The_TList, MAX_TASKS);
    for (DWORD i=0; i<numTasks; i++)
    {
        if (ThisPid == (DWORD) (DWORD_PTR) The_TList[i].dwProcessId)
        {
            TCHAR szTempString[512];

#if defined(UNICODE) || defined(_UNICODE)
            MultiByteToWideChar( CP_ACP, 0, (char*) The_TList[i].ProcessName, -1, szTempString, _MAX_PATH);
#else
            _tcscpy(szTempString, The_TList[i].ProcessName);
#endif

            // display the used .dll files for this process. (our process)
            DumpProcessModules((DWORD) (DWORD_PTR) The_TList[i].dwProcessId);
            goto LogThisProcessesDLLsW_Exit;
        }
    }

LogThisProcessesDLLsW_Exit:
    if (The_TList){HeapFree(GetProcessHeap(), 0, The_TList);The_TList = NULL;}
    return;
}
#endif

void LogThisProcessesDLLs(void)
{
#ifdef _CHICAGO_
    LogThisProcessesDLLsA();
#else
    __try
    {
        LogThisProcessesDLLsW();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("ExceptionCaught!:LogThisProcessesDLLs().\n")));
    }
#endif
    return;
}


void LogFileVersions_System32(void)
{
    TCHAR buf[_MAX_PATH];
    GetSystemDirectory( buf, _MAX_PATH);
    CString csTempPath = buf;
    LogFilesInThisDir(csTempPath);
    return;
}

void LogFileVersions_Inetsrv(void)
{
    CString csTempPath = g_pTheApp->m_csPathInetsrv;
    LogFilesInThisDir(csTempPath);
    return;
}


DWORD LogFileVersionsForCopyFiles(IN HINF hFile, IN LPCTSTR szSection)
{
    DWORD dwReturn = ERROR_SUCCESS;
    return dwReturn;
}

int LoadExeFromResource(int iWhichExeToGet, LPTSTR szReturnPath)
{
    TCHAR szResourceNumString[10];
    TCHAR szSaveFileNameAs[_MAX_PATH];

    HANDLE  hFile;

    LPTSTR szPointerToAllExeData = NULL;
    DWORD  dwSize = 0;
    int iReturn = E_FAIL;
    _tcscpy(szReturnPath, _T(""));

    // The Binaries stored in the resource is x86 only
    // so... exit if this is not an x86
    SYSTEM_INFO si;
    GetSystemInfo( &si );
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
    {
        iReturn = ERROR_NOT_SUPPORTED;
        goto LoadExeFromResource_Exit;
    }

    // get the resource id from the resource
    _stprintf(szResourceNumString, _T("#%d"), iWhichExeToGet);
    GetWindowsDirectory( szSaveFileNameAs, _MAX_PATH);
    TCHAR szResourceFileName[_MAX_FNAME];
    _stprintf(szResourceFileName, _T("Res%d.bin"), iWhichExeToGet);
    AddPath(szSaveFileNameAs, szResourceFileName);

    iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("LoadExeFromResource: '%1!s!' Start.\n"), szSaveFileNameAs));

    // Check if the filename already exists...if it does, then don't overwrite it!
    if (IsFileExist(szSaveFileNameAs))
    {
        iReturn = ERROR_FILE_EXISTS;
        goto LoadExeFromResource_Exit;
    }
   	
    HRSRC       hrscReg;
	hrscReg = FindResource((HMODULE) g_MyModuleHandle, szResourceNumString, _T("EXE"));
	if (NULL == hrscReg)
	{
		iReturn = GetLastError();
		goto LoadExeFromResource_Exit;
	}

    HGLOBAL     hResourceHandle;
	hResourceHandle = LoadResource((HMODULE)g_MyModuleHandle, hrscReg);
	if (NULL == hResourceHandle)
	{
		iReturn = GetLastError();
		goto LoadExeFromResource_Exit;
	}

	dwSize = SizeofResource((HMODULE)g_MyModuleHandle, hrscReg);

    // szPointerToAllExeData is a pointer to the whole thing
	szPointerToAllExeData = (LPTSTR) hResourceHandle;

    // Write all this data out to the file.
    __try
    {
	    hFile = CreateFile(szSaveFileNameAs,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
	    if (hFile != INVALID_HANDLE_VALUE)
        {
            // save everything into the file
            DWORD dwBytesWritten = 0;
            if (WriteFile(hFile,szPointerToAllExeData,dwSize,&dwBytesWritten,NULL))
            {
                _tcscpy(szReturnPath, szSaveFileNameAs);
                iReturn = ERROR_SUCCESS;
            }
            else
            {
                iReturn = GetLastError();
            }
        }
        else
        {
            iReturn = ERROR_INVALID_HANDLE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TCHAR szErrorString[100];
        _stprintf(szErrorString, _T("\r\n\r\nException Caught in LoadExeFromResource().  GetExceptionCode()=0x%x.\r\n\r\n"), GetExceptionCode());
        OutputDebugString(szErrorString);
        g_MyLogFile.LogFileWrite(szErrorString);
    }

LoadExeFromResource_Exit:
    iisDebugOut_End(_T("LoadExeFromResource"),LOG_TYPE_TRACE);
    //if (szPointerToAllExeData) {LocalFree(szPointerToAllExeData);}
    if (hFile) {CloseHandle(hFile);}
    return iReturn;
}


void LogFileVersionsForGroupOfSections(IN HINF hFile)
{
    CStringList strList;

    CString csTheSection = _T("VerifyFileSections");
    if (GetSectionNameToDo(hFile, csTheSection))
    {
        if (ERROR_SUCCESS == FillStrListWithListOfSections(hFile, strList, csTheSection))
        {
            // loop thru the list returned back
            if (strList.IsEmpty() == FALSE)
            {
                POSITION pos;
                CString csEntry;

                pos = strList.GetHeadPosition();
                while (pos)
                {
                    csEntry = strList.GetAt(pos);
                    LogFileVersionsForThisINFSection(hFile, csEntry);
                    strList.GetNext(pos);
                }
            }
        }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\setpass.cpp ===
#include "stdafx.h"
#include "setpass.h"

#ifndef _CHICAGO_

#include "inetinfo.h"
#include "inetcom.h"

//
//  Quick macro to initialize a unicode string
//

#define InitUnicodeString( pUnicode, pwch )                                \
            {                                                              \
                (pUnicode)->Buffer    = (PWCH)pwch;                      \
                (pUnicode)->Length    = (pwch == NULL )? 0: (wcslen( pwch ) * sizeof(WCHAR));    \
                (pUnicode)->MaximumLength = (pUnicode)->Length + sizeof(WCHAR);\
            }

BOOL GetSecret(
    IN LPCTSTR        pszSecretName,
    OUT BUFFER *      pbufSecret
    )
/*++
    Description:

        Retrieves the specified unicode secret

    Arguments:

        pszSecretName - LSA Secret to retrieve
        pbufSecret - Receives found secret

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    BOOL              fResult;
    NTSTATUS          ntStatus;
    PUNICODE_STRING   punicodePassword = NULL;
    UNICODE_STRING    unicodeSecret;
    LSA_HANDLE        hPolicy;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR wszSecretName[_MAX_PATH];

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wszSecretName, pszSecretName);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)pszSecretName, -1, (LPWSTR)wszSecretName, _MAX_PATH);
#endif

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
    {
        SetLastError( LsaNtStatusToWinError( ntStatus ) );
        return FALSE;
    }

    InitUnicodeString( &unicodeSecret, wszSecretName );

    //
    //  Query the secret value.
    //

    ntStatus = LsaRetrievePrivateData( hPolicy,
                                       &unicodeSecret,
                                       &punicodePassword );

    if( NT_SUCCESS(ntStatus) && (NULL !=punicodePassword))
    {
        DWORD cbNeeded;

        cbNeeded = punicodePassword->Length + sizeof(WCHAR);

        if ( !pbufSecret->Resize( cbNeeded ) )
        {
            ntStatus = STATUS_NO_MEMORY;
            goto Failure;
        }

        memcpy( pbufSecret->QueryPtr(),
                punicodePassword->Buffer,
                punicodePassword->Length );

        *((WCHAR *) pbufSecret->QueryPtr() +
           punicodePassword->Length / sizeof(WCHAR)) = L'\0';

        RtlZeroMemory( punicodePassword->Buffer,
                       punicodePassword->MaximumLength );
    }

Failure:

    fResult = NT_SUCCESS(ntStatus);

    //
    //  Cleanup & exit.
    //

    if( punicodePassword != NULL )
    {
        LsaFreeMemory( (PVOID)punicodePassword );
    }

    LsaClose( hPolicy );

    if ( !fResult )
        SetLastError( LsaNtStatusToWinError( ntStatus ));

    return fResult;

}

BOOL GetAnonymousSecret(
    IN LPCTSTR      pszSecretName,
    OUT LPTSTR      pszPassword
    )
{
    BUFFER * pbufSecret = NULL;
    LPWSTR pwsz = NULL;

    pbufSecret = new BUFFER();
    if (pbufSecret)
    {
        if ( !GetSecret( pszSecretName, pbufSecret ))
            return FALSE;

        pwsz = (WCHAR *) pbufSecret->QueryPtr();

        if (pwsz)
        {
#if defined(UNICODE) || defined(_UNICODE)
            _tcscpy(pszPassword, pwsz);
#else
            WideCharToMultiByte( CP_ACP, 0, pwsz, -1, pszPassword, _MAX_PATH, NULL, NULL );
#endif
        }

        delete(pbufSecret);
        pbufSecret = NULL;
    }

    return TRUE;
}

BOOL GetRootSecret(
    IN LPCTSTR pszRoot,
    IN LPCTSTR pszSecretName,
    OUT LPTSTR pszPassword
    )
/*++
    Description:

        This function retrieves the password for the specified root & address

    Arguments:

        pszRoot - Name of root + address in the form "/root,<address>".
        pszSecretName - Virtual Root password secret name
        pszPassword - Receives password, must be at least PWLEN+1 characters

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    BUFFER * pbufSecret = NULL;
    LPWSTR pwsz;
    LPWSTR pwszTerm;
    LPWSTR pwszNextLine;
    WCHAR wszRoot[_MAX_PATH];

    pbufSecret = new BUFFER();
    if (pbufSecret)
    {

    if ( !GetSecret( pszSecretName, pbufSecret ))
        return FALSE;

    pwsz = (WCHAR *) pbufSecret->QueryPtr();

    //
    //  Scan the list of roots looking for a match.  The list looks like:
    //
    //     <root>,<address>=<password>\0
    //     <root>,<address>=<password>\0
    //     \0
    //

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wszRoot, pszRoot);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)pszRoot, -1, (LPWSTR)wszRoot, _MAX_PATH);
#endif

    while ( *pwsz )
    {
        pwszNextLine = pwsz + wcslen(pwsz) + 1;

        pwszTerm = wcschr( pwsz, L'=' );

        if ( !pwszTerm )
            goto NextLine;

        *pwszTerm = L'\0';

        if ( !_wcsicmp( wszRoot, pwsz ) )
        {
            DWORD cch;

            //
            //  We found a match, copy the password
            //

#if defined(UNICODE) || defined(_UNICODE)
            _tcscpy(pszPassword, pwszTerm+1);
#else
            cch = WideCharToMultiByte( CP_ACP,
                                       WC_COMPOSITECHECK,
                                       pwszTerm + 1,
                                       -1,
                                       pszPassword,
                                       PWLEN + sizeof(CHAR),
                                       NULL,
                                       NULL );
            pszPassword[cch] = '\0';
#endif
            return TRUE;
        }

NextLine:
        pwsz = pwszNextLine;
    }

    //
    //  If the matching root wasn't found, default to the empty password
    //

    *pszPassword = _T('\0');
}

    if (pbufSecret)
    {
        delete(pbufSecret);
        pbufSecret = NULL;
    }
    return TRUE;
}


//
// Saves password in LSA private data (LSA Secret).
//
DWORD SetSecret(IN LPCTSTR pszKeyName,IN LPCTSTR pszPassword)
{
    DWORD dwError =  E_FAIL;
	LSA_HANDLE hPolicy = NULL;

	try
	{
		LSA_OBJECT_ATTRIBUTES lsaoa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

		dwError = LsaNtStatusToWinError(LsaOpenPolicy(NULL, &lsaoa, POLICY_CREATE_SECRET, &hPolicy));
		if (dwError != ERROR_SUCCESS)
		{
            dwError = HRESULT_FROM_WIN32(dwError);
            goto SetSecret_Exit;
		}

		USHORT usPasswordLength = wcslen(pszPassword) * sizeof(WCHAR);
        USHORT usKeyNameLength = wcslen(pszKeyName) * sizeof(WCHAR);

        LSA_UNICODE_STRING lsausKeyName = { usKeyNameLength, usKeyNameLength, const_cast<PWSTR>(pszKeyName) };
        LSA_UNICODE_STRING lsausPrivateData = { usPasswordLength, usPasswordLength, const_cast<PWSTR>(pszPassword) };
        
		dwError = LsaNtStatusToWinError(LsaStorePrivateData(hPolicy, &lsausKeyName, &lsausPrivateData));
		if (dwError != ERROR_SUCCESS)
		{
            dwError = HRESULT_FROM_WIN32(dwError);
            goto SetSecret_Exit;
		}

		LsaClose(hPolicy);
	}
	catch (...)
	{
		if (hPolicy)
		{
			LsaClose(hPolicy);
		}

		//throw;
	}
SetSecret_Exit:
    return dwError;
}

#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\other.h ===
#include "stdafx.h"

void  MyGetVersionFromFile(LPCTSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, LPTSTR pszReturnLocalizedVersion);
BOOL  MyGetDescriptionFromFile(LPCTSTR lpszFilename, LPTSTR pszReturnDescription);
// used for grabbing arch type info out of a file
VOID  DumpFileArchInfo(LPCTSTR Filename,PVOID View,DWORD Length,TCHAR *ReturnString);
TCHAR *MachineToString(DWORD Machine);
TCHAR *StripLastBackSlash(TCHAR * i_szDir);
void  DisplayVerOnCurrentModule();

DWORD LogPendingReBootOperations(void);
int   LogEnumServicesStatus(void);
DWORD LogHeapState(BOOL bLogSuccessStateToo, char *szFileName, int iLineNumber);
int   LogFileVersion(IN LPCTSTR lpszFullFilePath, INT bShowArchType);
BOOL  LogFilesInThisDir(LPCTSTR szDirName);
void  LogFileVersions_System32(void);
void  LogFileVersions_Inetsrv(void);
DWORD LogFileVersionsForThisINFSection( IN HINF hFile, IN LPCTSTR szSection );
void  LogCurrentProcessIDs(void);
VOID  LogFileArchType(LPCTSTR filename, TCHAR * ReturnMachineType);
void  LogCheckIfTempDirWriteable(void);
void  LogAllProcessDlls(void);
void  LogProcessesUsingThisModule(LPCTSTR szModuleNameToLookup, CStringList &strList);
#ifndef _CHICAGO_
    void LogProcessesUsingThisModuleW(LPCTSTR szModuleNameToLookup, CStringList &strList);
#else
    void LogProcessesUsingThisModuleA(LPCTSTR szModuleNameToLookup, CStringList &strList);
#endif

void LogThisProcessesDLLs(void);
#ifndef _CHICAGO_
    void LogThisProcessesDLLsW(void);
#else
    void LogThisProcessesDLLsA(void);
#endif

void LogFileVersionsForGroupOfSections(IN HINF hFile);

DWORD LogFileVersionsForCopyFiles(IN HINF hFile, IN LPCTSTR szSection);
void UnInit_Lib_PSAPI(void);
BOOL  IsProcessUsingThisModule(LPWSTR lpwsProcessName,DWORD dwProcessId,LPWSTR ModuleName);
DWORD WINAPI FindProcessByNameW(const WCHAR * pszImageName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\registry.h ===
#ifndef _REGISTRY_H_
#define _CRegKey_REGISTRY_defined_can_not_include_ATLBASE_H_/* new #def name */
#define _REGISTRY_H_                         /* old #def name */

//----------------------------------------------------------------
// we need the new explicit name since TW_Util.* needs to know if
// its defined in the iis\ui\setup\osrc directory that also defines
// a CRegKey class.  If so it will have trouble including a std
// windows file called <AtlBase.h>
// It keys off of: _CRegKey_REGISTRY_nonATLBASE_H_
//----------------------------------------------------------------


/****************************************************************************
REGISTRY.H
****************************************************************************/

//  Forward declarations
class CRegKey ;
class CRegValueIter ;
class CRegKeyIter ;

//  Maximum size of a Registry class name
#define CREGKEY_MAX_CLASS_NAME MAX_PATH

//  Wrapper for a Registry key handle.

class CRegKey : public CObject
{
protected:
    HKEY m_hKey ;
    DWORD m_dwDisposition ;

    //  Prepare to read a value by finding the value's size.
    LONG PrepareValue ( LPCTSTR pchValueName,
                        DWORD * pdwType,
                        DWORD * pcbSize,
                        BYTE ** ppbData ) ;

    //  Convert a CStringList to the REG_MULTI_SZ format
    static LONG FlattenValue ( CStringList & strList,
                                DWORD * pcbSize,
                        BYTE ** ppbData ) ;

    //  Convert a CByteArray to a REG_BINARY block
    static LONG FlattenValue ( CByteArray & abData,
                        DWORD * pcbSize,
                        BYTE ** ppbData ) ;

public:
    //  Key information return structure
    typedef struct
    {
        TCHAR chBuff [CREGKEY_MAX_CLASS_NAME] ;
        DWORD dwClassNameSize,
              dwNumSubKeys,
              dwMaxSubKey,
              dwMaxClass,
              dwMaxValues,
              dwMaxValueName,
              dwMaxValueData,
              dwSecDesc ;
        FILETIME ftKey ;
    } CREGKEY_KEY_INFO ;

    //  Standard constructor for an existing key
    CRegKey ( HKEY hKeyBase,
              LPCTSTR pchSubKey = NULL,
              REGSAM regSam = KEY_ALL_ACCESS ) ;

    //  Constructor creating a new key.
    CRegKey ( LPCTSTR lpSubKey,
            HKEY hKeyBase,
            LPCTSTR lpValueName = NULL,
            DWORD dwType = 0,
            LPBYTE lpValueData = NULL,
            DWORD cbValueData = 0);

    ~ CRegKey () ;

    //  Allow a CRegKey to be used anywhere an HKEY is required.
    operator HKEY ()
        { return m_hKey ; }

    //  Fill a key information structure
    LONG QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo ) ;

    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
            //  if data exists but not in correct form to deliver into result object.
    LONG QueryValue ( LPCTSTR pchValueName, CString & strResult ) ;
    LONG QueryValue ( LPCTSTR pchValueName, CStringList & strList ) ;
    LONG QueryValue ( LPCTSTR pchValueName, DWORD & dwResult ) ;
    LONG QueryValue ( LPCTSTR pchValueName, CByteArray & abResult ) ;
    LONG QueryValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize );

    //  Overloaded value setting members.
    LONG SetValue ( LPCTSTR pchValueName, LPCTSTR szResult, BOOL fExpand = FALSE ) ;
    LONG SetValue ( LPCTSTR pchValueName, CStringList & strList ) ;
    LONG SetValue ( LPCTSTR pchValueName, DWORD dwResult ) ;
    LONG SetValue ( LPCTSTR pchValueName, CByteArray & abResult ) ;
    LONG SetValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize );

    LONG DeleteValue( LPCTSTR pchKeyName );
    LONG DeleteTree( LPCTSTR pchKeyName );

    int m_iDisplayWarnings;
};


    //  Iterate the values of a key, return the name and type
    //  of each.
class CRegValueIter : public CObject
{
protected:
    CRegKey & m_rk_iter ;
    DWORD m_dw_index ;
    TCHAR * m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    CRegValueIter ( CRegKey & regKey ) ;
    ~ CRegValueIter () ;

    // Get the name (and optional last write time) of the next key.
    LONG Next ( CString * pstrName, DWORD * pdwType ) ;
    LONG Next ( CString * pstrName, CString * pstrValue );

    // decrement the m_dw_index to account for deleted keys
    void Decrement( DWORD delta = 1 ) {m_dw_index -= delta;}

    // Reset the iterator
    void Reset ()
        { m_dw_index = 0 ; }
};

    //  Iterate the sub-key names of a key.
class CRegKeyIter : public CObject
{
protected:
    CRegKey & m_rk_iter ;
        DWORD m_dw_index ;
    TCHAR * m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    CRegKeyIter ( CRegKey & regKey ) ;
    ~ CRegKeyIter () ;

    // Get the name (and optional last write time) of the next key.
    LONG Next ( CString * pstrName, CTime * pTime = NULL ) ;

    // Reset the iterator
    void Reset ()
        { m_dw_index = 0 ; }
};

#endif  // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\registry.cpp ===
#include "stdafx.h"
// defined with iisrtl2.lib
//DEBUG_PRINTS * g_pDebug;

// open an existing key
// if failure, return NULL pointer and put error into SetLastError();
CRegKey :: CRegKey (HKEY hKeyBase, LPCTSTR pchSubKey,REGSAM regSam ) : m_hKey( NULL ), m_dwDisposition( 0 )
{
    LONG err = ERROR_SUCCESS ;
    SetLastError(ERROR_SUCCESS);
    m_iDisplayWarnings = TRUE;

    if ( pchSubKey )
		{err = ::RegOpenKeyEx( hKeyBase, pchSubKey, 0, regSam, & m_hKey ) ;}
    else
		{m_hKey = hKeyBase ;}

    if ( err != ERROR_SUCCESS )
    {
        if (m_hKey) {::RegCloseKey(m_hKey);}
        m_hKey = NULL ;
        // Check if the error is because it simply doesn't exist.
        // if this is the case then don't say failed.  Say WARNING.
        if ( err == ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                {iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRegKey:CRegKey() %s Key doesn't exist.  WARNING. Code=0x%x\n"), pchSubKey, err));}
        }
        else
        {
		    iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey:CRegKey() %s FAILED.  Err=0x%x\n"), pchSubKey, err));
        }
        SetLastError(err);
    }
}

//  Constructor creating a new key/opening a key if already exist, and set value if specified
CRegKey :: CRegKey (LPCTSTR lpSubKey,HKEY hKeyBase,LPCTSTR lpValueName,DWORD dwType,LPBYTE lpValueData,DWORD cbValueData): m_hKey( NULL ),m_dwDisposition( 0 )
{
    LONG err = ERROR_SUCCESS;
    SetLastError(ERROR_SUCCESS);
    m_iDisplayWarnings = TRUE;

    err = ::RegCreateKeyEx( hKeyBase, lpSubKey, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, & m_hKey, & m_dwDisposition ) ;
    if ( err != ERROR_SUCCESS)
	{
        if ( m_hKey ) {::RegCloseKey( m_hKey ) ;}
        m_hKey = NULL ;
        // Check if the error is because it simply doesn't exist.
        // if this is the case then don't say failed.  Say WARNING.
        if ( err == ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                {iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRegKey:CRegKey() %s Key doesn't exist.  WARNING. Code=0x%x\n"), lpSubKey, err));}
        }
        else
        {
		    iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::CRegKey() Open %s FAILED.  err=0x%x\n"), lpSubKey, err));
        }
        SetLastError(err);
    }
	else
	{
        if (lpValueName)
		{
			::RegSetValueEx(m_hKey, lpValueName, 0, dwType, (const LPBYTE)lpValueData, cbValueData);
			if ( err != ERROR_SUCCESS)
			{
				iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::CRegKey() RegSetValueEx %s, %s FAILED.  err=0x%x\n"), lpSubKey,lpValueName, err));
                SetLastError(err);
			}
		}
    }
}

CRegKey :: ~ CRegKey ()
{
    if (m_hKey) {::RegCloseKey( m_hKey );}
}


    //  Prepare to read a value by finding the value's size.
LONG CRegKey :: PrepareValue (LPCTSTR pchValueName, DWORD * pdwType,DWORD * pcbSize,BYTE ** ppbData )
{
    LONG err = 0 ;

    BYTE chDummy[2] ;
    DWORD cbData = 0 ;

    do
    {
        //  Set the resulting buffer size to 0.
        *pcbSize = 0 ;
        *ppbData = NULL ;

        err = ::RegQueryValueEx( *this, (TCHAR *) pchValueName, 0, pdwType, chDummy, & cbData ) ;

        //  The only error we should get here is ERROR_MORE_DATA, but
        //  we may get no error if the value has no data.
        if ( err == 0 )
        {
            cbData = sizeof (LONG) ;  //  Just a fudgy number
        }
        else
            if ( err != ERROR_MORE_DATA )
                break ;

        //  Allocate a buffer large enough for the data.

        *ppbData = new BYTE [ (*pcbSize = cbData) + sizeof (LONG) ] ;

        if ( *ppbData == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        //  Now that have a buffer, re-fetch the value.

        err = ::RegQueryValueEx( *this, (TCHAR *) pchValueName, 0, pdwType, *ppbData, pcbSize ) ;

    } while ( FALSE ) ;

    if ( err )  {delete [] *ppbData ;}

    return err ;
}

//  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
//  if data exists but not in correct form to deliver into result object.
LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, CString & strResult )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
			{break ;}

        if (( dwType != REG_SZ ) && ( dwType != REG_EXPAND_SZ ))
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the data looks like a string
        pabData[cbData] = 0 ;

        //  Catch exceptions trying to assign to the caller's string
        TRY
        {
            strResult = (TCHAR *) pabData ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    while ( FALSE ) ;

    // Memory leak....
    //if ( err )
    //{
        delete [] pabData ;
    //}

	if (err)
    {
        if ( err == ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                {iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::QueryValue(): %s Not found.  WARNING.  code=0x%x\n"), pchValueName, err));}
        }
        else
        {
            if (err != ERROR_INVALID_PARAMETER)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::QueryValue(): %s FAILED.  err=0x%x\n"), pchValueName, err));
            }
        }
    }
    return err ;
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, CStringList & strList )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;
    TCHAR * pbTemp, * pbTempLimit ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
			{break ;}

        if ( dwType != REG_MULTI_SZ )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the trailing data looks like a string
        pabData[cbData] = 0 ;
        pbTemp = (TCHAR *) pabData ;
        pbTempLimit = (TCHAR *) (& pabData[cbData]) ;

        //  Catch exceptions trying to build the list
        TRY
        {
            for ( ; pbTemp < pbTempLimit ; )
            {
                strList.AddTail( pbTemp ) ;
                pbTemp += ::_tcslen( pbTemp ) + 1 ;
            }
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    while ( FALSE ) ;

    delete [] pabData ;

	if (err)
    {
        if ( err == ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                {iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::QueryValue(): %s Not found.  WARNING.  code=0x%x\n"), pchValueName, err));}
        }
        else
        {
            if (err != ERROR_INVALID_PARAMETER)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::QueryValue(): %s FAILED.  err=0x%x.\n"), pchValueName, err));
            }
        }
    }
    return err ;
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, DWORD & dwResult )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if ( dwType != REG_DWORD || cbData != sizeof dwResult )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        dwResult = *((DWORD *) pabData) ;
    }
    while ( FALSE ) ;

    // Memory leak...
    //if ( err )
    //{
        delete [] pabData ;
    //}

	if (err)
    {
        if ( err == ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                {iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::QueryValue(): %s Not found.  WARNING.  code=0x%x\n"), pchValueName, err));}
        }
        else
        {
            if (err != ERROR_INVALID_PARAMETER)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::QueryValue(): %s FAILED.  err=0x%x.\n"), pchValueName, err));
            }
        }
    }
    return err ;
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, CByteArray & abResult )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if ( dwType != REG_BINARY )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Catch exceptions trying to grow the result array
        TRY
        {
            abResult.SetSize( cbData ) ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL

        if ( err )
            break ;

        //  Move the data to the result array.
        for ( DWORD i = 0 ; i < cbData ; i++ )
        {
            abResult[i] = pabData[i] ;
        }
    }
    while ( FALSE ) ;

    // Memory leak....
    //if ( err )
    //{
        delete [] pabData ;
    //}

	if (err)
    {
        if ( err == ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                {iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::QueryValue(): %s Not found.  WARNING.  code=0x%x\n"), pchValueName, err));}
        }
        else
        {
            if (err != ERROR_INVALID_PARAMETER)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::QueryValue(): %s FAILED.  err=0x%x.\n"), pchValueName, err));
            }
        }
    }
    return err ;
}

LONG CRegKey :: QueryValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if ( dwType != REG_BINARY )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        if ( cbSize < cbData )
        {
            err = ERROR_MORE_DATA;
            break;
        }

        ::memcpy(pvResult, pabData, cbData);
    }
    while ( FALSE ) ;

    // Memory leak....
    //if ( err )
    //{
        delete [] pabData ;
    //}

	if (err)
    {
        if ( err == ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                {iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::QueryValue(): %s Not found.  WARNING.  code=0x%x\n"), pchValueName, err));}
        }
        else
        {
            if (err != ERROR_INVALID_PARAMETER)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::QueryValue(): %s FAILED.  err=0x%x.\n"), pchValueName, err));
            }
        }
    }
    return err ;
}


//  Overloaded value setting members.
LONG CRegKey :: SetValue ( LPCTSTR pchValueName, LPCTSTR szResult, BOOL fExpand )
{
    LONG err = 0;
    err = ::RegSetValueEx( *this, pchValueName,0,fExpand ? REG_EXPAND_SZ : REG_SZ,(const BYTE *) szResult,(_tcsclen(szResult) + 1) * sizeof(_TCHAR) ) ;
	if (err != ERROR_SUCCESS) {iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::SetValue(): %s FAILED, err=0x%x\n"), pchValueName,err));}
    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, CStringList & strList )
{
    LONG err = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue( strList, & cbSize, & pbData ) ;
    if ( err == 0 )
    {
        err = ::RegSetValueEx( *this, pchValueName,0,REG_MULTI_SZ,pbData, cbSize ) ;
		if (err != ERROR_SUCCESS) {iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::SetValue(): %s FAILED, err=0x%x\n"), pchValueName,err));}
    }

    delete pbData ;

    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, DWORD dwResult )
{
    LONG err = 0;
    err = ::RegSetValueEx( *this, pchValueName,0,REG_DWORD,(const BYTE *) & dwResult,sizeof dwResult ) ;
	if (err != ERROR_SUCCESS) {iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::SetValue(): %s FAILED, err=0x%x\n"), pchValueName,err));}
    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, CByteArray & abResult )
{
    LONG err = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue( abResult, & cbSize, & pbData ) ;

    if ( err == 0 )
    {
        err = ::RegSetValueEx( *this, pchValueName,0,REG_BINARY,pbData, cbSize ) ;
		if (err != ERROR_SUCCESS) {iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::SetValue(): %s FAILED, err=0x%x\n"), pchValueName,err));}
    }

    delete pbData ;

    return err ;
}

LONG CRegKey :: SetValue ( LPCTSTR pchValueName, void * pvResult, DWORD cbSize )
{
    LONG err = 0;
    err = ::RegSetValueEx( *this, pchValueName,0,REG_BINARY,(const BYTE *)pvResult, cbSize ) ;
	if (err != ERROR_SUCCESS) {iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::SetValue(): %s FAILED, err=0x%x\n"), pchValueName,err));}
    return err ;
}

LONG CRegKey::DeleteValue( LPCTSTR pchKeyName )
{
    LONG err = 0;
    err = ::RegDeleteValue( *this, pchKeyName );
	if (err != ERROR_SUCCESS)
    {
        if ( err != ERROR_FILE_NOT_FOUND )
        {
            if (m_iDisplayWarnings)
                iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::DeleteValue(): %s FAILED, err=0x%x\n"), pchKeyName,err));
        }
    }
    return(err);
}

LONG CRegKey::DeleteTree( LPCTSTR pchKeyName )
{
    LONG err = 0;
    CRegKey regSubKey( *this, pchKeyName );

    if ( NULL != (HKEY) regSubKey )
    {
        CString strName;
        CTime cTime;

        while (TRUE)
        {
            CRegKeyIter regEnum( regSubKey );

            if ( regEnum.Next( &strName, &cTime ) != ERROR_SUCCESS )
            {
                break;
            }

            regSubKey.DeleteTree( strName );
        }
        // delete myself
        err = ::RegDeleteKey( *this, pchKeyName );
    }
    return(err);
}

LONG CRegKey :: FlattenValue ( CStringList & strList, DWORD * pcbSize, BYTE ** ppbData )
{
    LONG err = 0 ;

    POSITION pos ;
    CString * pstr ;
    int cbTotal = 0 ;

    //  Walk the list accumulating sizes
    for ( pos = strList.GetHeadPosition() ; pos != NULL && (pstr = & strList.GetNext( pos )) ; )
    {
        cbTotal += ((pstr->GetLength() + 1)*sizeof(TCHAR));
    }

    //  Allocate and fill a temporary buffer
    if (*pcbSize = cbTotal)
    {
        TRY
        {
            *ppbData = new BYTE[ *pcbSize ] ;

            if (*ppbData)
            {
                BYTE * pbData = *ppbData ;

                //  Populate the buffer with the strings.
                for ( pos = strList.GetHeadPosition() ; pos != NULL && (pstr = & strList.GetNext( pos )) ; )
                {
                    int cb = (pstr->GetLength() + 1)*sizeof(TCHAR) ;
                    ::memcpy( pbData, (LPCTSTR) *pstr, cb ) ;
                    pbData += cb ;
                }
            }
            else
            {
                err = ERROR_NOT_ENOUGH_MEMORY ;
            }
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

	if (err)
    {
            iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::FlattenValue(): %s FAILED.  err=0x%x.\n"), strList, err));
    }
    return err ;
}

LONG CRegKey :: FlattenValue ( CByteArray & abData,DWORD * pcbSize,BYTE ** ppbData )
{
    LONG err = 0 ;

    DWORD i ;

    //  Allocate and fill a temporary buffer
    if (*pcbSize = (DWORD)abData.GetSize())
    {
        TRY
        {
            *ppbData = new BYTE[*pcbSize] ;
            if (*ppbData)
            {
                for ( i = 0 ; i < *pcbSize ; i++ )
                {
                    (*ppbData)[i] = abData[i] ;
                }
            }
            else
            {
                err = ERROR_NOT_ENOUGH_MEMORY ;
            }

        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

	if (err)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("CRegKey::FlattenValue(): FAILED.  err=0x%x.\n"), err));
    }
    return err ;
}


LONG CRegKey :: QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo )
{
    LONG err = 0 ;
    pRegKeyInfo->dwClassNameSize = sizeof pRegKeyInfo->chBuff - 1 ;
    err = ::RegQueryInfoKey( *this,pRegKeyInfo->chBuff,& pRegKeyInfo->dwClassNameSize,NULL,& pRegKeyInfo->dwNumSubKeys,& pRegKeyInfo->dwMaxSubKey,& pRegKeyInfo->dwMaxClass,& pRegKeyInfo->dwMaxValues,& pRegKeyInfo->dwMaxValueName,& pRegKeyInfo->dwMaxValueData,& pRegKeyInfo->dwSecDesc,& pRegKeyInfo->ftKey ) ;
	if (err != ERROR_SUCCESS) {iisDebugOut((LOG_TYPE_ERROR, _T("CRegKey::QueryKeyInfo(): FAILED.  err=0x%x.\n"), err));}
    return err ;
}

CRegKeyIter :: CRegKeyIter ( CRegKey & regKey ) : m_rk_iter( regKey ),m_p_buffer( NULL ),m_cb_buffer( 0 )
{
    LONG err = 0 ;

    CRegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;
    if ( err == 0 )
    {
        TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxSubKey + sizeof (DWORD) ;
            m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

	if (err)
    {
        if (ERROR_NO_MORE_ITEMS != err)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CRegKeyIter::CRegKeyIter(): FAILED.  err=0x%x.\n"), err));
        }
    }
}

CRegKeyIter :: ~ CRegKeyIter ()
{
    delete [] m_p_buffer ;
}


    // Get the name (and optional last write time) of the next key.
LONG CRegKeyIter :: Next ( CString * pstrName, CTime * pTime )
{
    LONG err = 0;

    FILETIME ftDummy ;
    DWORD dwNameSize = m_cb_buffer ;

    err = ::RegEnumKeyEx( m_rk_iter, m_dw_index, m_p_buffer,& dwNameSize, NULL,NULL,NULL,& ftDummy ) ;
    if ( err == 0 )
    {
        m_dw_index++ ;

        if ( pTime )
        {
            *pTime = ftDummy ;
        }

        TRY
        {
            *pstrName = m_p_buffer ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

	if (err)
    {
        if (ERROR_NO_MORE_ITEMS != err)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CRegKeyIter::Next(): FAILED.  err=0x%x.\n"), err));
        }
    }
    return err ;
}


CRegValueIter :: CRegValueIter ( CRegKey & regKey )
    : m_rk_iter( regKey ),
    m_p_buffer( NULL ),
    m_cb_buffer( 0 )
{
    LONG err = 0 ;

    CRegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 )
    {
        TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxValueName + sizeof (DWORD) ;
            m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

	if (err)
    {
        if (ERROR_NO_MORE_ITEMS != err)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CRegValueIter::CRegValueIter(): FAILED.  err=0x%x.\n"), err));
        }
    }
}

CRegValueIter :: ~ CRegValueIter ()
{
    delete [] m_p_buffer ;
}

LONG CRegValueIter :: Next ( CString * pstrName, DWORD * pdwType )
{
    LONG err = 0 ;

    DWORD dwNameLength = m_cb_buffer ;
    err = ::RegEnumValue( m_rk_iter,m_dw_index,m_p_buffer,& dwNameLength,NULL,pdwType,NULL,NULL ) ;
    if ( err == 0 )
    {
        m_dw_index++ ;

        TRY
    {
        *pstrName = m_p_buffer ;
    }
    CATCH_ALL(e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
    }
    END_CATCH_ALL
    }

	if (err)
    {
        if (ERROR_NO_MORE_ITEMS != err)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CRegValueIter::Next(): FAILED.  err=0x%x.\n"), err));
        }
    }
    return err ;
}

LONG CRegValueIter :: Next ( CString * pstrName, CString * pstrValue )
{
    LONG err = 0 ;

    DWORD dwNameLength = m_cb_buffer ;

    TCHAR szValue[_MAX_PATH];
    DWORD dwValue = _MAX_PATH * sizeof(TCHAR);

    err = ::RegEnumValue( m_rk_iter,m_dw_index,m_p_buffer,& dwNameLength,NULL,NULL,(LPBYTE)szValue,&dwValue ) ;
    if ( err == 0 )
    {
        m_dw_index++ ;

        TRY
        {
            *pstrName = m_p_buffer ;
            *pstrValue = szValue;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

	if (err)
    {
        if (ERROR_NO_MORE_ITEMS != err)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CRegValueIter::Next(): FAILED.  err=0x%x.\n"), err));
        }
    }
    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by setup.rc
//
#define IDWRITEUNENCRYPTEDALL           3
#define IDS_CANNOT_GET_MACHINE_NAME     13
#define IDS_OS_NOT_SUPPORT              14
#define IDS_CANNOT_DETECT_OS_TYPE       15
#define IDS_IIS_ALL_INSTALL             16
#define IDS_IIS_ALL_UPGRADE             17
#define IDS_IIS                         18
#define IDS_IIS_ALL_CONFIGURE           18
#define IDS_SETUP                       19
#define IDS_IIS_ALL_REMOVE              19
#define IDS_OS_VERSION_NOT_SUPPORTED    20
#define IDS_GUEST_NAME                  21
#define IDS_IIS_ALL_COMPLETE            22
#define IDS_IIS_ERROR_MSGBOXTITLE       23
#define IDS_USER_COMMENT                24
#define IDS_USER_FULLNAME               25
#define IDS_IIS_ALL_FILEOPS             26
#define IDS_REMOVE_GOPHER               34
#define IDS_EULA_DECLINED               38
#define IDS_SELECT_DIR                  40
#define IDS_NOT_ADMINISTRATOR           41
#define IDS_NT5_NEEDED                  44
#define IDS_NEED_INPUT_FTP              47
#define IDS_NEED_INPUT_WWW              48
#define IDS_ADMIN_SERVER_COMMENT        52
#define IDS_FRESH_MINIMUM_STRING        65
#define IDS_FRESH_TYPICAL_STRING        67
#define IDS_FRESH_CUSTOM_STRING         69
#define IDS_REMOVEALL_WARNING           72
#define IDS_INCORRECT_PLATFORM          73
#define IDS_NEED_PLATFORM_NTW           75
#define IDS_CANNOT_OPEN_SRC_FILE        77
#define IDS_CANNOT_OPEN_DEST_FILE       78
#define IDS_CANNOT_COPY_FILE            79
#define IDS_SERVICE_IN_DELETE_STATE     82
#define IDS_NEED_VALID_PATH_UNATTENDED  83
#define IDS_WAM_ACCOUNT_NAME            88
#define IDS_WAMUSER_COMMENT             92
#define IDS_WAMUSER_FULLNAME            93
#define IDS_UNABLE_TO_STOP_SERVICE      95
#define IDS_INVALID_DIR_INETSRV         96
#define IDS_APP_FRIENDLY_ROOT           97
#define IDS_APP_FRIENDLY_IISADMIN       98
#define IDS_APP_FRIENDLY_WEBPUB         99
#define IDS_APP_FRIENDLY_IISSAMPLES     100
#define IDD_PROPPAGE_WELCOME            101
#define IDS_APP_FRIENDLY_IISHELP        101
#define IDD_PROPPAGE_PUBLISH_DIR        102
#define IDS_UNABLE_TO_CREATE_DRIVER     102
#define IDD_PROPPAGE_END                103
#define IDS_BITMAP_MS                   103
#define IDD_PROPPAGE_EULA               104
#define IDS_BITMAP_TITLE                104
#define IDD_BROWSEDIRECTORY             105
#define IDD_PROPPAGE_MODE_MAINTENANCE   106
#define IDS_WELCOMES_INTRO              106
#define IDD_PROPPAGE_MODE_FRESH         107
#define IDS_WELCOMES_FEATURE            107
#define IDD_PROPPAGE_MODE_UPGRADE       108
#define IDS_WELCOMEW_INTRO              108
#define IDD_PROPPAGE_SRC_PATH           109
#define IDS_WELCOMEW_FEATURE            109
#define IDB_WELCOMES                    110
#define IDS_WELCOMEC_INTRO              110
#define IDB_WELCOMEW                    111
#define IDS_WELCOMEC_FEATURE            111
#define IDB_WELCOMEC                    112
#define IDS_LOCATE_FILE                 112
#define IDB_BANNERS                     113
#define IDS_NEED_TCPIP_WARNING          113
#define IDB_BANNERW                     114
#define IDS_TCPIP_NEEDED_ON_OPTION      114
#define IDB_BANNERC                     115
#define IDS_BAD_SIGNATURE_RELNOTES      115
#define IDB_FTP                         116
#define IDS_DEFAULT_WEB_SITE            116
#define IDB_WWW                         117
#define IDS_DEFAULT_FTP_SITE            117
#define IDB_W3SAMP                      118
#define IDB_INETMGR                     119
#define IDB_HTMLA                       120
#define IDS_BITMAP_MS_TRADEMARK         120
#define IDD_MISSING_FILE_DIALOG         121
#define IDS_BITMAP_TITLE_TRADEMARK      121
#define IDB_PWS                         122
#define IDS_BITMAP_MS_TRADEMARK_OTHER   122
#define IDS_MTS_NOT_INSTALLED           123
#define IDB_TOPLEVEL_IIS                125
#define IDS_UNATTEND_UNSUPPORTED        125
#define IDB_WWW_VDIR                    126
#define IDD_DIALOG_MSG                  126
#define IDS_OS_BUILD_NUM_REQUIREMENT    128
#define IDS_UNABLE_TO_START             129
#define IDS_ERR_CALLING_DLL_PROCEDURE   130
#define IDD_DIALOG1                     130
#define IDD_ENCRYPTED_WRITE_ERROR_DIALOG 130
#define IDS_OLE_INIT_FAILED             131
#define IDD_DIALOG2                     131
#define IDS_FILE_DOES_NOT_EXIST         132
#define IDS_UNABLE_TO_LOCATE_PROCEDURE  133
#define IDS_RETRY                       135
#define IDS_REGSVR_CAUGHT_EXCEPTION     137
#define IDS_SETDATA_ERROR               138
#define IDS_GETDATA_ERROR               139
#define IDS_CREATE_METABASE_ACLS        141
#define IDS_ADD_METABASE_1              143
#define IDS_CONFIG_USER_1               151
#define IDS_COMPONENT_INSTALL_PHASE     154
#define IDS_CLEANUP_PHASE               156
#define IDS_STOPPING_SERVICES           157
#define IDS_REG_ACCT_TO_LOCAL_GROUP     158
#define IDS_REG_ACCT_USER_RIGHTS        159
#define IDS_GET_DC_NAME                 161
#define IDS_CREATE_USER_ACCT            163
#define IDS_MTS_INCORRECTLY_INSTALLED   166
#define IDS_COMPLETED_FILE_CALL         167
#define IDS_TEMPLATE_PUBLIC_WEB_SITE    169
#define IDS_TEMPLATE_PUBLIC_SECURE_SITE 170
#define IDS_TEMPLATE_PUBLIC_FTP_SITE    171
#define IDS_VERIFY_CUSTOMERRORS         172
#define IDS_MIGRATE_IP_SEC              173
#define IDS_SET_ADMIN_RESTRICTION       174
#define IDS_VERIFY_FILTERS              175
#define IDS_CREATING_BASE_ENTRIES       176
#define IDS_SETUP_ERRORS_ENCOUNTERED_MTS 177
#define IDS_MTS_DOING_CREATEINPROC      178
#define IDS_MTS_ERROR_TITLEBAR          179
#define IDS_ADD_SETTINGS_FOR_WEB_1      180
#define IDS_ADD_SETTINGS_FOR_WEB_2      181
#define IDS_ADD_SETTINGS_FOR_WEB_3      182
#define IDS_ADD_SETTINGS_FOR_FTP_1      183
#define IDS_ADD_SETTINGS_FOR_FTP_2      184
#define IDC_LICENSE_TEXT                1000
#define IDC_EULA_ACCEPT                 1001
#define IDC_EULA_DECLINE                1002
#define IDC_WWW_PUB_GROUP               1005
#define IDC_FTP_PUB_GROUP               1006
#define IDC_WWW_PUB_EDIT                1007
#define IDC_FTP_PUB_EDIT                1008
#define IDC_WWW_PUB_BROWSE              1009
#define IDC_FTP_PUB_BROWSE              1010
#define IDC_ADDREMOVE                   1014
#define IDC_REINSTALL                   1015
#define IDC_REMOVEALL                   1016
#define IDC_MINIMUM                     1017
#define IDC_TYPICAL                     1018
#define IDC_CUSTOM                      1019
#define IDC_UPGRADEONLY                 1020
#define IDC_ADDEXTRACOMPS               1021
#define IDC_FRAME_WELCOME               1022
#define IDC_FRAME_BANNER                1023
#define IDC_REINSTALL_REFRESH_FILES     1024
#define IDC_REINSTALL_REFRESH_SETTINGS  1025
#define IDC_FRESH_MINIMUM_STATIC        1034
#define IDC_FRESH_TYPICAL_STATIC        1035
#define IDC_FRESH_CUSTOM_STATIC         1036
#define IDC_FRAME_WELCOME_MS            1038
#define IDC_FRAME_WELCOME_TITLE         1039
#define IDC_FRAME_WELCOME_INTRO         1040
#define IDC_FRAME_WELCOME_FEATURE       1041
#define IDC_FRAME_BANNER_MS             1042
#define IDC_FRAME_BANNER_TITLE          1043
#define IDS_ADD_SETTINGS_FOR            1044
#define IDC_STATIC_BOTTOMLINE           1044
#define IDC_STATIC_TOPLINE              1045
#define IDWRITEUNENCRYPTED              1046
#define IDC_STATIC3                     1047
#define IDS_DEPENDENT_UPON_THIS_SVC_ERR 1048
#define IDC_STATIC1                     1048
#define IDC_STATIC2                     1049
#define IDS_LOADLIBRARY_FAILED          1052
#define IDS_RUN_PROG_FAILED             1054
#define IDS_BEFORE_CALLING_FILE         1055
#define IDS_SETUP_ERRORS_ENCOUNTERED    1056
#define IDS_TCPIP_ERROR                 1057
#define IDS_HTTPCUSTOM_UTF8             1058
#define IDS_REMOVE_CLUS_W3SVC_FIRST     1059
#define IDS_REMOVE_CLUS_MSFTPSVC_FIRST  1060
#define IDS_FAKE_METABASE_BIN_TEXT      1061

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1058
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\setpass.h ===
#include "stdafx.h"

#ifndef _CHICAGO_
	BOOL GetSecret(IN LPCTSTR pszSecretName,OUT BUFFER * pbufSecret);
	BOOL GetAnonymousSecret(IN LPCTSTR pszSecretName,OUT LPTSTR pszPassword);
	BOOL GetRootSecret(IN LPCTSTR pszRoot,IN LPCTSTR pszSecretName,OUT LPTSTR pszPassword);
	DWORD SetSecret(IN LPCTSTR pszKeyName,IN LPCTSTR pszPassword);
#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\setuser.h ===
#include "stdafx.h"

#ifndef _CHICAGO_
    INT  DeleteGuestUser(LPCTSTR szUsername, INT *UserWasDeleted);
    int  GetGuestUserName_SlowWay(LPWSTR lpGuestUsrName);
    int  GetGuestGrpName(LPTSTR lpGuestGrpName);
    void InitLsaString(PLSA_UNICODE_STRING LsaString,LPWSTR String);
    DWORD OpenPolicy(LPTSTR ServerName,DWORD DesiredAccess,PLSA_HANDLE PolicyHandle);
    INT  RegisterAccountToLocalGroup(LPCTSTR szAccountName, LPCTSTR szLocalGroupName, BOOL fAction);
    INT  RegisterAccountUserRights(LPCTSTR szAccountName, BOOL fAction, BOOL fSpecicaliwamaccount);
    BOOL IsUserExist( LPWSTR strUsername );
    INT  CreateUser( LPCTSTR szUsername, LPCTSTR szPassword, LPCTSTR szComment, LPCTSTR szFullName, BOOL fiWamUser,INT *NewlyCreated);
    BOOL GuestAccEnabled();
    NET_API_STATUS NetpNtStatusToApiStatus (IN NTSTATUS NtStatus);
    NET_API_STATUS UaspGetDomainId(IN LPCWSTR ServerName OPTIONAL,OUT PSAM_HANDLE SamServerHandle OPTIONAL,OUT PPOLICY_ACCOUNT_DOMAIN_INFO * AccountDomainInfo);
    NET_API_STATUS SampCreateFullSid(IN PSID DomainSid,IN ULONG Rid,OUT PSID *AccountSid);
    int  GetGuestUserNameForDomain_FastWay(LPTSTR szDomainToLookUp,LPTSTR lpGuestUsrName);
    void GetGuestUserName(LPTSTR lpOutGuestUsrName);
    int  ChangeUserPassword(IN LPTSTR szUserName, IN LPTSTR szNewPassword);
    BOOL DoesUserHaveThisRight(LPCTSTR szAccountName, LPTSTR PrivilegeName);
    HRESULT CreateGroup(LPTSTR szGroupName, LPCTSTR szGroupComment, int iAction);
    int  CreateGroupDC(LPTSTR szGroupName, LPCTSTR szGroupComment);
#endif //_CHICAGO_

NET_API_STATUS NetpNtStatusToApiStatus(IN NTSTATUS NtStatus);
int GetGuestUserNameForDomain_FastWay(LPTSTR szDomainToLookUp,LPTSTR lpGuestUsrName);
void GetGuestUserName(LPTSTR lpOutGuestUsrName);
BOOL DoesUserHaveThisRight(LPCTSTR szAccountName, LPTSTR PrivilegeName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\setuputl.h ===
DWORD   atodw(LPCTSTR lpszData);
int     CreateAnEmptyFile(CString szTheFullPath);
BOOL    CleanPathString(LPTSTR szPath);
BOOL    CreateLayerDirectory(CString &str);
BOOL    ReturnFileNameOnly(LPCTSTR lpFullPath, LPTSTR lpReturnFileName);
BOOL    ReturnFilePathOnly(LPCTSTR lpFullPath, LPTSTR lpReturnPathOnly);
BOOL    IsFileExist(LPCTSTR szFile);
BOOL    IsFileExist_NormalOrCompressed(LPCTSTR szFile);
BOOL    IsValidDriveType(LPTSTR szRoot);
BOOL    IsValidDirectoryName(LPTSTR lpszPath);
int     IsThisDriveNTFS(IN LPTSTR FileName);
void    MakePath(LPTSTR lpPath);
void    AddPath(LPTSTR szPath, LPCTSTR szName );
CString AddPath(CString szPath, LPCTSTR szName );
BOOL    AppendDir(LPCTSTR szParentDir, LPCTSTR szSubDir, LPTSTR szResult);
BOOL    InetDeleteFile(LPCTSTR szFileName);
BOOL    InetCopyFile( LPCTSTR szSrc, LPCTSTR szDest);
void    InetGetFilePath(LPCTSTR szFile, LPTSTR szPath);
BOOL    RecRemoveEmptyDir(LPCTSTR szName);
BOOL    RecRemoveDir(LPCTSTR szName);
BOOL    VerCmp(LPTSTR szSrcVerString, LPTSTR szDestVerString);
int     InstallInfSection_NoFiles(HINF InfHandle,TCHAR szINFFileName[],TCHAR szSectionName[]);
int     InstallInfSection(HINF InfHandle,TCHAR szINFFileName[],TCHAR szSectionName[]);
DWORD   GrantUserAccessToFile(IN LPTSTR FileName,IN LPTSTR TrusteeName);
void    MakeSureDirAclsHaveAtLeastRead(LPTSTR lpszDirectoryPath);
DWORD   SetAccessOnFile(IN LPTSTR FileName, BOOL bDoForAdmin);
int     IsFileLessThanThisVersion(IN LPCTSTR lpszFullFilePath, IN DWORD dwNtopMSVer, IN DWORD dwNtopLSVer);
void    DeleteFilesWildcard(TCHAR *szDir, TCHAR *szFileName);
DWORD   ReturnFileSize(LPCTSTR myFileName);
CString ReturnUniqueFileName(CString csInputFullName);
DWORD RemovePrincipalFromFileAcl(IN TCHAR *pszFile,IN  LPTSTR szPrincipal);

#ifndef _CHICAGO_
    DWORD SetDirectorySecurity(IN LPCTSTR szDirPath,IN LPCTSTR szPrincipal,IN INT iAceType,IN DWORD dwAccessMask,IN DWORD dwInheritMask);
    DWORD SetRegistryKeySecurity(IN HKEY hkeyRootKey,IN LPCTSTR szKeyPath,IN LPCTSTR szPrincipal,IN DWORD dwAccessMask,IN DWORD dwInheritMask,IN BOOL bDoSubKeys, IN LPTSTR szExclusiveList = NULL);
    DWORD SetRegistryKeySecurityAdmin(HKEY hkey, DWORD samDesired,PSECURITY_DESCRIPTOR* ppsdOld);
    DWORD SetAccessOnDirOrFile(IN TCHAR *pszFile,PSID psidGroup,INT iAceType,DWORD dwAccessMask,DWORD dwInheritMask,PSECURITY_DESCRIPTOR* ppsd);
    DWORD SetAccessOnRegKey(HKEY hkey, PSID psidGroup,DWORD dwAccessMask,DWORD dwInheritMask,PSECURITY_DESCRIPTOR* ppsd);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\setuputl.cpp ===
#include "stdafx.h"
#include <setupapi.h>
#include <shlobj.h>
#include <ole2.h>
#include "lzexpand.h"
#include "log.h"
#include "dcomperm.h"
#include "strfn.h"
#include "other.h"
#include <direct.h>
#include <aclapi.h>


typedef struct _QUEUECONTEXT {
    HWND OwnerWindow;
    DWORD MainThreadId;
    HWND ProgressDialog;
    HWND ProgressBar;
    BOOL Cancelled;
    PTSTR CurrentSourceName;
    BOOL ScreenReader;
    BOOL MessageBoxUp;
    WPARAM  PendingUiType;
    PVOID   PendingUiParameters;
    UINT    CancelReturnCode;
    BOOL DialogKilled;
    //
    // If the SetupInitDefaultQueueCallbackEx is used, the caller can
    // specify an alternate handler for progress. This is useful to
    // get the default behavior for disk prompting, error handling, etc,
    // but to provide a gas gauge embedded, say, in a wizard page.
    //
    // The alternate window is sent ProgressMsg once when the copy queue
    // is started (wParam = 0. lParam = number of files to copy).
    // It is then also sent once per file copied (wParam = 1. lParam = 0).
    //
    // NOTE: a silent installation (i.e., no progress UI) can be accomplished
    // by specifying an AlternateProgressWindow handle of INVALID_HANDLE_VALUE.
    //
    HWND AlternateProgressWindow;
    UINT ProgressMsg;
    UINT NoToAllMask;

    HANDLE UiThreadHandle;

#ifdef NOCANCEL_SUPPORT
    BOOL AllowCancel;
#endif

} QUEUECONTEXT, *PQUEUECONTEXT;



//-------------------------------------------------------------------
//  purpose: install an section in an .inf file
//-------------------------------------------------------------------
int InstallInfSection_NoFiles(HINF InfHandle,TCHAR szINFFileName[],TCHAR szSectionName[])
{
    HWND	Window			= NULL;
    BOOL	bReturn			= FALSE;
	BOOL	bReturnTemp			= FALSE; // assume failure.
    TCHAR	ActualSection[1000];
    DWORD	ActualSectionLength;
    BOOL    bPleaseCloseInfHandle = FALSE;

    iisDebugOut_Start1(_T("InstallInfSection_NoFiles"),szSectionName,LOG_TYPE_PROGRAM_FLOW);

__try {

    // Check if a valid infhandle as passed in....
    // if so, use that, otherwise, use the passed in filename...
    if(InfHandle == INVALID_HANDLE_VALUE) 
    {
        // Try to use the filename.
        if (_tcsicmp(szINFFileName, _T("")) == 0)
        {
            goto c1;
        }

        // we have a filename entry. let's try to use it.
	    // Check if the file exists
	    if (!IsFileExist(szINFFileName)) 
		    {
		    //MessageBox(NULL, "unable to find file", "cannot find file", MB_OK);
		    goto c1;
		    }
        
        // Load the inf file and get the handle
        InfHandle = SetupOpenInfFile(szINFFileName, NULL, INF_STYLE_WIN4, NULL);
        bPleaseCloseInfHandle = TRUE;
    }
    if(InfHandle == INVALID_HANDLE_VALUE) {goto c1;}

    //
    // See if there is an nt-specific section
    //
    SetupDiGetActualSectionToInstall(InfHandle,szSectionName,ActualSection,sizeof(ActualSection),&ActualSectionLength,NULL);

    //
    // Perform non-file operations for the section passed on the cmd line.
    //
    bReturn = SetupInstallFromInfSection(Window,InfHandle,ActualSection,SPINST_ALL & ~SPINST_FILES,NULL,NULL,0,NULL,NULL,NULL,NULL);
    if(!bReturn) {goto c1;}

    //
    // Install any services for the section
    //
    bReturn = SetupInstallServicesFromInfSection(InfHandle,ActualSection,0);
    if(!bReturn) 
    {
    iisDebugOut((LOG_TYPE_TRACE, _T("SetupInstallServicesFromInfSection failed.Ret=%d.\n"), GetLastError()));
    }

    //
    // Refresh the desktop.
    //
    SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_FLUSHNOWAIT,0,0);

    //
    // If we get to here, then this routine has been successful.
    //
    bReturnTemp = TRUE;

c1:
    //
    // If the bReturnTemp failed and it was because the user cancelled, then we don't want to consider
    // that as an bReturnTemp (i.e., we don't want to give an bReturnTemp popup later).
    //
    if((bReturnTemp != TRUE) && (GetLastError() == ERROR_CANCELLED)) {bReturnTemp = TRUE;}
    if (bPleaseCloseInfHandle == TRUE)
    {
	    if(InfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(InfHandle);InfHandle = INVALID_HANDLE_VALUE;}
    }

    ;}
__except(EXCEPTION_EXECUTE_HANDLER) 
    {
        if (bPleaseCloseInfHandle == TRUE)
        {
	        if(InfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(InfHandle);InfHandle = INVALID_HANDLE_VALUE;}
        }
    }

    //
    // If the bReturnTemp failed because the user cancelled, then we don't want to consider
    // that as an bReturnTemp (i.e., we don't want to give an bReturnTemp popup later).
    //
    if((bReturnTemp != TRUE) && (GetLastError() == ERROR_CANCELLED)) {bReturnTemp = TRUE;}

	// Display installation failed message
    //if(bReturnTemp) {MyMessageBox(NULL, _T("IDS_INF_FAILED"), MB_OK);}

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("InstallInfSection_NoFiles.[%s].End.Ret=%d.\n"), szSectionName, bReturnTemp));
    return bReturnTemp;
}



//-------------------------------------------------------------------
//  purpose: install an section in an .inf file
//-------------------------------------------------------------------
int InstallInfSection(HINF InfHandle,TCHAR szINFFileName[],TCHAR szSectionName[])
{
    HWND	Window			= NULL;
    PTSTR	SourcePath		= NULL;
    //HINF	InfHandle		= INVALID_HANDLE_VALUE;
    HSPFILEQ FileQueue		= INVALID_HANDLE_VALUE;
    PQUEUECONTEXT	QueueContext	= NULL;
    BOOL	bReturn			= FALSE;
	BOOL	bReturnTemp			= FALSE; // assume failure.
    TCHAR	ActualSection[1000];
    DWORD	ActualSectionLength;
    BOOL    bPleaseCloseInfHandle = FALSE;

    iisDebugOut_Start1(_T("InstallInfSection"),szSectionName,LOG_TYPE_PROGRAM_FLOW);

__try {

    // Check if a valid infhandle as passed in....
    // if so, use that, otherwise, use the passed in filename...
    if(InfHandle == INVALID_HANDLE_VALUE) 
    {
        // Try to use the filename.
        if (_tcsicmp(szINFFileName, _T("")) == 0)
        {
            goto c1;
        }

        // we have a filename entry. let's try to use it.
	    // Check if the file exists
	    if (!IsFileExist(szINFFileName)) 
		    {
		    //MessageBox(NULL, "unable to find file", "cannot find file", MB_OK);
		    goto c1;
		    }
        
        // Load the inf file and get the handle
        InfHandle = SetupOpenInfFile(szINFFileName, NULL, INF_STYLE_WIN4, NULL);
        bPleaseCloseInfHandle = TRUE;
    }
    if(InfHandle == INVALID_HANDLE_VALUE) {goto c1;}

    //
    // See if there is an nt-specific section
    //
    SetupDiGetActualSectionToInstall(InfHandle,szSectionName,ActualSection,sizeof(ActualSection),&ActualSectionLength,NULL);

    //
    // Create a setup file queue and initialize the default queue callback.
	//
    FileQueue = SetupOpenFileQueue();
    if(FileQueue == INVALID_HANDLE_VALUE) {goto c1;}

    //QueueContext = SetupInitDefaultQueueCallback(Window);
    //if(!QueueContext) {goto c1;}

    QueueContext = (PQUEUECONTEXT) SetupInitDefaultQueueCallbackEx(Window,NULL,0,0,0);
    if(!QueueContext) {goto c1;}
    QueueContext->PendingUiType = IDF_CHECKFIRST;

    //
    // Enqueue file operations for the section passed on the cmd line.
    //
	//SourcePath = NULL;
    // SP_COPY_NOPRUNE = setupapi has a new deal which will prune files from the copyqueue if they already exist on the system.
    //                   however, the problem with the new deal is that the pruning code does not check if you have the same file
    //                   queued in the delete or rename queue.  specify SP_COPY_NOPRUNE to make sure that our file never gets
    //                   pruned (removed) from the copy queue. aaronl 12/4/98
    //bReturn = SetupInstallFilesFromInfSection(InfHandle,NULL,FileQueue,ActualSection,SourcePath,SP_COPY_NEWER | SP_COPY_NOPRUNE);
    bReturn = SetupInstallFilesFromInfSection(InfHandle,NULL,FileQueue,ActualSection,SourcePath, SP_COPY_NOPRUNE);
	if(!bReturn) {goto c1;}

    //
    // Commit file queue.
    //
    if(!SetupCommitFileQueue(Window, FileQueue, SetupDefaultQueueCallback, QueueContext)) {goto c1;}

    //
    // Perform non-file operations for the section passed on the cmd line.
    //
    bReturn = SetupInstallFromInfSection(Window,InfHandle,ActualSection,SPINST_ALL & ~SPINST_FILES,NULL,NULL,0,NULL,NULL,NULL,NULL);
    if(!bReturn) {goto c1;}

	//
    // Refresh the desktop.
    //
    SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_FLUSHNOWAIT,0,0);

    //
    // If we get to here, then this routine has been successful.
    //
    bReturnTemp = TRUE;

c1:
    //
    // If the bReturnTemp failed and it was because the user cancelled, then we don't want to consider
    // that as an bReturnTemp (i.e., we don't want to give an bReturnTemp popup later).
    //
    if((bReturnTemp != TRUE) && (GetLastError() == ERROR_CANCELLED)) {bReturnTemp = TRUE;}
	if(QueueContext) {SetupTermDefaultQueueCallback(QueueContext);QueueContext = NULL;}
	if(FileQueue != INVALID_HANDLE_VALUE) {SetupCloseFileQueue(FileQueue);FileQueue = INVALID_HANDLE_VALUE;}
    if (bPleaseCloseInfHandle == TRUE)
    {
	    if(InfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(InfHandle);InfHandle = INVALID_HANDLE_VALUE;}
    }

    ;}
__except(EXCEPTION_EXECUTE_HANDLER) 
    {
        if(QueueContext) {SetupTermDefaultQueueCallback(QueueContext);}
        if(FileQueue != INVALID_HANDLE_VALUE) {SetupCloseFileQueue(FileQueue);}
        if (bPleaseCloseInfHandle == TRUE)
        {
	        if(InfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(InfHandle);InfHandle = INVALID_HANDLE_VALUE;}
        }
    }

    //
    // If the bReturnTemp failed because the user cancelled, then we don't want to consider
    // that as an bReturnTemp (i.e., we don't want to give an bReturnTemp popup later).
    //
    if((bReturnTemp != TRUE) && (GetLastError() == ERROR_CANCELLED)) {bReturnTemp = TRUE;}

	// Display installation failed message
    //if(bReturnTemp) {MyMessageBox(NULL, _T("IDS_INF_FAILED"), MB_OK);}

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("InstallInfSection.[%s].End.Ret=%d.\n"), szSectionName, bReturnTemp));
    return bReturnTemp;
}


BOOL IsValidDriveType(LPTSTR szRoot)
{
    BOOL fReturn = FALSE;
    int i;

    i = GetDriveType(szRoot);

    if (i == DRIVE_FIXED) {fReturn = TRUE;}

    if (i == DRIVE_REMOVABLE)
    {
        BOOL b;
        ULONGLONG TotalSpace;
        DWORD SectorsPerCluster, BytesPerSector, NumberOfFreeClusters, TotalNumberOfClusters;
        DWORD FloppySpace = 10 * 1024 * 1024;// use 10MB to distinguish a floppy from other drives, like JAZ drive 1GB
        b = GetDiskFreeSpace(szRoot,&SectorsPerCluster, &BytesPerSector, &NumberOfFreeClusters, &TotalNumberOfClusters);
        if (b)
        {
             TotalSpace = (ULONGLONG) TotalNumberOfClusters * SectorsPerCluster * BytesPerSector;
             if (TotalSpace > (ULONGLONG) FloppySpace)
                {fReturn = TRUE;}
             else
             {
                 iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("GetDiskFreeSpace():Drive=DRIVE_REMOVABLE:Not Sufficient space on drive '%1!s!'.  FAIL\n"), szRoot));
             }
        }
        else
        {
            iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("GetDiskFreeSpace(Drive=DRIVE_REMOVABLE) on %1!s! returns err: 0x%2!x!.  FAILURE\n"), szRoot, GetLastError()));
        }
    }

    return (fReturn);
}

// If lpszPath is a valid directory, return TRUE, and pass back the valid path in lpszPath to caller
// Otherwise, return FALSE.
BOOL IsValidDirectoryName(LPTSTR lpszPath)
{
    DWORD err = 0;
    BOOL bReturn = FALSE;
    TCHAR szFullPath[_MAX_PATH];
    LPTSTR p;

    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("IsValidDirectoryName %1!s!\n"), lpszPath));
    err = GetFullPathName(lpszPath, _MAX_PATH, szFullPath, &p);
    if (err != 0)
    {
        if (szFullPath[1] == _T(':')) { // good, not a UNC name
            // make sure it is a FIXED drive
            TCHAR szRoot[4];
            _tcsncpy(szRoot, szFullPath, 3);
            szRoot[3] = _T('\0');
            if (IsValidDriveType(szRoot))
            {
                // OK, ready to create each layered directory
                TCHAR szBuffer[_MAX_PATH];
                LPTSTR token, tail;
                CStringArray aDir;
                int i, n;

                tail = szBuffer;
                token = _tcstok(szFullPath, _T("\\"));
                if (token)
                {
                    _tcscpy(tail, token);
                    tail += _tcslen(token);
                    bReturn = TRUE; /* return TRUE if in the form of C:\ */
                    while (token = _tcstok(NULL, _T("\\")))
                    {
                        *tail = _T('\\');
                        tail = _tcsinc(tail);
                        _tcscpy(tail, token);
                        // create it & rememeber it
                        err = GetFileAttributes(szBuffer);
                        if (err == 0xFFFFFFFF)
                        {
                            // szBuffer contains a non-existing path
                            // create it
                            if (CreateDirectory(szBuffer, NULL))
                            {
                                // succeed, remember the directory in an array
                                aDir.Add(szBuffer);
                            }
                            else
                            {
                                iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("IsValidDirectory:CreateDirectory failed on %1!s!, err=%2!x!.\n"), szBuffer, GetLastError()));
                                bReturn = FALSE;
                                break;
                            }
                        } else {
                            // szBuffer contains an existing path,
                            // make sure it is a directory
                            if (!(err & FILE_ATTRIBUTE_DIRECTORY))
                            {
                                iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("IsValidDirectory failure. %1!s! is not a valid directory.\n"), szBuffer));
                                bReturn = FALSE;
                                break;
                            }
                        }
                        tail += _tcslen(token);
                    }
                    if (bReturn)
                    {
                        // pass the valid directory to the caller
                        if (*(tail-1) == _T(':'))
                        {
                            *tail = _T('\\');
                            tail = _tcsinc(tail);
                        }
                        _tcscpy(lpszPath, szBuffer);
                    }
                }
                // remove the created directories we remembered in the array
                n = (int)aDir.GetSize();
                for (i = n-1; i >= 0; i--)
                    RemoveDirectory(aDir[i]);
            } else {
                iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("IsValidDirectory failure. %1!s! is not on a valid drive.\n"), szFullPath));
            }
        } else {
            iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("IsValidDirectory failure. UNC name %1!s! is not allowed.\n"), szFullPath));
        }
    } else {
        iisDebugOutSafeParams((LOG_TYPE_ERROR, _T("IsValidDirectory:GetFullPathName failed on %1!s!, err=%2!x!.\n"), lpszPath, GetLastError()));
    }

    return (bReturn);
}

BOOL IsValidNumber(LPCTSTR szValue)
{
    LPTSTR p = (LPTSTR)szValue;
    while (*p) 
    {
        if ( *p >= _T('0') && *p <= _T('9') ) 
        {
            p = _tcsinc(p);
            continue;
        } else
            return FALSE;
    }
    return TRUE;
}

// Calculate the size of a Multi-String in TCHAR, including the ending 2 '\0's.
int GetMultiStrSize(LPTSTR p)
{
    int c = 0;

    while (1) {
        if (*p) {
            p++;
            c++;
        } else {
            c++;
            if (*(p+1)) {
                p++;
            } else {
                c++;
                break;
            }
        }
    }
    return c;
}

BOOL IsFileExist(LPCTSTR szFile)
{
    // Check if the file has expandable Environment strings
    LPTSTR pch = NULL;
    pch = _tcschr( (LPTSTR) szFile, _T('%'));
    if (pch) 
    {
        TCHAR szValue[_MAX_PATH];
        _tcscpy(szValue,szFile);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szFile, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szFile);}

        return (GetFileAttributes(szValue) != 0xFFFFFFFF);
    }
    else
    {
        return (GetFileAttributes(szFile) != 0xFFFFFFFF);
    }
}

void InetGetFilePath(LPCTSTR szFile, LPTSTR szPath)
{
    // if UNC name \\computer\share\local1\local2
    if (*szFile == _T('\\') && *(_tcsinc(szFile)) == _T('\\')) {
        TCHAR szTemp[_MAX_PATH], szLocal[_MAX_PATH];
        TCHAR *p = NULL;
        int i = 0;

        _tcscpy(szTemp, szFile);
        p = szTemp;
        while (*p) {
            if (*p == _T('\\'))
                i++;
            if (i == 4) {
                *p = _T('\0');
                p = _tcsinc(p); // p is now pointing at local1\local2
                break;
            }
            p = _tcsinc(p);
        }
        _tcscpy(szPath, szTemp); // now szPath contains \\computer\share

        if (i == 4 && *p) { // p is pointing the local path now
            _tcscpy(szLocal, p);
            p = _tcsrchr(szLocal, _T('\\'));
            if (p)
                *p = _T('\0');
            _tcscat(szPath, _T("\\"));
            _tcscat(szPath, szLocal); // szPath contains \\computer\share\local1
        }
    } else { // NOT UNC name
        TCHAR *p;
        if (GetFullPathName(szFile, _MAX_PATH, szPath, &p)) {
            p = _tcsrchr(szPath, _T('\\'));
            if (p) 
            {
                TCHAR *p2 = NULL;
                p2 = _tcsdec(szPath, p);
                if (p2)
                {
                    if (*p2 == _T(':') )
                        {p = _tcsinc(p);}
                }
                *p = _T('\0');
            }
        } else {
            iisDebugOutSafeParams((LOG_TYPE_WARN, _T("GetFullPathName: szFile=%1!s!, err=%2!d!\n"), szFile, GetLastError()));
            MyMessageBox(NULL, _T("GetFullPathName"), GetLastError(), MB_OK | MB_SETFOREGROUND);
        }
    }

    return;
}


BOOL InetDeleteFile(LPCTSTR szFileName)
{
    // if file exists but DeleteFile() fails
    if ( IsFileExist(szFileName) && !(::DeleteFile(szFileName)) ) {
        // if we cannot delete it, then move delay until reboot
        // move it to top level dir on the same drive, and mark it as hidden
        // Note: MoveFileEx() works only on the same drive if dealing with file-in-use
        TCHAR TmpName[_MAX_PATH];
        TCHAR csTmpPath[5] = _T("C:\\.");
        csTmpPath[0] = *szFileName;
        if ( GetTempFileName( (LPCTSTR)csTmpPath, _T("INT"), 0, TmpName ) == 0 ||
            !MoveFileEx( szFileName, TmpName, MOVEFILE_REPLACE_EXISTING|MOVEFILE_COPY_ALLOWED|MOVEFILE_WRITE_THROUGH ) ) {
            return FALSE;
        }
        MoveFileEx( TmpName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT );
        SetFileAttributes(TmpName, FILE_ATTRIBUTE_HIDDEN);
    }

    return TRUE;
}

BOOL InetCopyFile( LPCTSTR szSrc, LPCTSTR szDest)
{
    INT err;
    INT fSrc;
    INT fDest;
    OFSTRUCT ofstruct;

    do {
        // open source file
        iisDebugOut_Start((_T("LZ32.dll:LZOpenFile()")));
        if (( fSrc = LZOpenFile( (LPTSTR)szSrc, &ofstruct, OF_READ | OF_SHARE_DENY_NONE )) < 0 ) 
        {
            iisDebugOut_End((_T("LZ32.dll:LZOpenFile")));
            // cannot open src file
            LZClose(fSrc);

            UINT iMsg = MyMessageBox( NULL, IDS_CANNOT_OPEN_SRC_FILE, szSrc, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
            switch ( iMsg )
            {
            case IDABORT:
                return FALSE;
            case IDRETRY:
                break;
            case IDIGNORE:
            default:
                return TRUE;
            }
        }
        else
        {
            iisDebugOut_End((_T("LZ32.dll:LZOpenFile")));
            break;
        }
    } while (TRUE);

    // move the desintation file
    CFileStatus status;
    if ( CFile::GetStatus( szDest, status ))
    {
        // try to remove it
        if ( !InetDeleteFile( szDest ))
        {
            LZClose( fSrc );
            return TRUE;
        }
    }

    // open desination file
    do {
        iisDebugOut_Start((_T("LZ32.dll:LZOpenFile()")));
        if (( fDest = LZOpenFile( (LPTSTR)szDest, &ofstruct, OF_CREATE |  OF_WRITE | OF_SHARE_DENY_NONE )) < 0 )
        {
            iisDebugOut_End((_T("LZ32.dll:LZOpenFile")));
            LZClose(fDest);

            UINT iMsg = MyMessageBox( NULL, IDS_CANNOT_OPEN_DEST_FILE, szDest, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
            switch ( iMsg )
            {
            case IDABORT:
                LZClose(fSrc);
                return FALSE;
            case IDRETRY:
                break;
            case IDIGNORE:
            default:
                LZClose(fSrc);
                return TRUE;
            }
        }
        else
        {
            iisDebugOut_End((_T("LZ32.dll:LZOpenFile")));
            break;
        }
    } while (TRUE);

    do {
        iisDebugOut_Start((_T("LZ32.dll:LZCopy()")));
        if (( err = LZCopy( fSrc, fDest )) < 0 )
        {
            iisDebugOut_End((_T("LZ32.dll:LZCopy")));
            LZClose( fSrc );
            LZClose( fDest );

            UINT iMsg = MyMessageBox( NULL, IDS_CANNOT_COPY_FILE, szSrc,szDest,ERROR_CANNOT_COPY, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
            switch ( iMsg )
            {
            case IDABORT:
                return FALSE;
            case IDRETRY:
                break;
            case IDIGNORE:
            default:
                return TRUE;
            }
        }
        else
        {
            iisDebugOut_End((_T("LZ32.dll:LZCopy")));
            LZClose( fSrc );
            LZClose( fDest );
            break;
        }
    } while (TRUE);

    return TRUE;
}

// Given a fullpathname of a directory, remove any empty dirs under it including itself

BOOL RecRemoveEmptyDir(LPCTSTR szName)
{
    BOOL fReturn = FALSE;
        DWORD retCode;
        BOOL fRemoveDir = TRUE;
        WIN32_FIND_DATA FindFileData;
        HANDLE hFile = INVALID_HANDLE_VALUE;
        TCHAR szSubDir[_MAX_PATH] = _T("");
        TCHAR szDirName[_MAX_PATH] = _T("");

        retCode = GetFileAttributes(szName);

        if (retCode == 0xFFFFFFFF || !(retCode & FILE_ATTRIBUTE_DIRECTORY))
                return FALSE;

        _stprintf(szDirName, _T("%s\\*"), szName);
        hFile = FindFirstFile(szDirName, &FindFileData);

        if (hFile != INVALID_HANDLE_VALUE) {
                do {
                        if (_tcsicmp(FindFileData.cFileName, _T(".")) != 0 &&
                                _tcsicmp(FindFileData.cFileName, _T("..")) != 0 ) {
                                if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                                        _stprintf(szSubDir, _T("%s\\%s"), szName, FindFileData.cFileName);
                                        fRemoveDir = RecRemoveEmptyDir(szSubDir) && fRemoveDir;
                                } else {
                                    CString csFileName = FindFileData.cFileName;
                                    CString csPrefix = csFileName.Left(3);
                                    CString csSuffix = csFileName.Right(4);
                                    if (_tcsicmp(csPrefix, _T("INT")) == 0 &&
                                        _tcsicmp(csSuffix, _T(".tmp")) == 0 ) { // this is an INT*.tmp created by IIS
                                        _stprintf(szSubDir, _T("%s\\%s"), szName, FindFileData.cFileName);
                                        if (!::DeleteFile(szSubDir))
                                            fRemoveDir = FALSE; // this dir is not empty
                                    } else
                                        fRemoveDir = FALSE; // it is a file, this Dir is not empty
                                }
                        }

                        if (!FindNextFile(hFile, &FindFileData)) {
                                FindClose(hFile);
                                break;
                        }
                } while (TRUE);
        }

        if (fRemoveDir) {
            TCHAR szDirName[_MAX_PATH];
            GetCurrentDirectory( _MAX_PATH, szDirName );
            SetCurrentDirectory(g_pTheApp->m_csSysDir);
            fReturn = ::RemoveDirectory(szName);
            SetCurrentDirectory(szDirName);
        }

        return fReturn;

}

// Given a fullpathname of a directory, remove the directory node

BOOL RecRemoveDir(LPCTSTR szName)
{
    DWORD retCode;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szSubDir[_MAX_PATH] = _T("");
    TCHAR szDirName[_MAX_PATH] = _T("");

    retCode = GetFileAttributes(szName);

    if (retCode == 0xFFFFFFFF)
        return FALSE;

    if (!(retCode & FILE_ATTRIBUTE_DIRECTORY)) {
        InetDeleteFile(szName);
        return TRUE;
    }

    _stprintf(szDirName, _T("%s\\*"), szName);
    hFile = FindFirstFile(szDirName, &FindFileData);

    if (hFile != INVALID_HANDLE_VALUE) {
        do {
            if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 &&
                 _tcsicmp(FindFileData.cFileName, _T("..")) != 0 ) {
                _stprintf(szSubDir, _T("%s\\%s"), szName, FindFileData.cFileName);
                RecRemoveDir(szSubDir);
            }

            if ( !FindNextFile(hFile, &FindFileData) ) {
                FindClose(hFile);
                break;
            }
        } while (TRUE);
    }

    return( ::RemoveDirectory(szName) );
}


//
// Given a directory path, this subroutine will create the direct layer by layer
//

BOOL CreateLayerDirectory( CString &str )
{
    BOOL fReturn = TRUE;

    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("CreateLayerDirectory %1!s!\n"), (LPCTSTR)str));
    do
    {
        INT index=0;
//        INT iLength = str.GetLength();
        INT iLength = _tcslen(str);

        // first find the index for the first directory
        if ( iLength > 2 )
        {
            if ( *_tcsninc(str,1) == _T(':'))
            {
                // assume the first character is driver letter
                if ( *_tcsninc(str,2) == _T('\\'))
                {
                    index = 2;
                } else
                {
                    index = 1;
                }
            } else if ( *_tcsninc(str,0) == _T('\\'))
            {
                if ( *_tcsninc(str,1) == _T('\\'))
                {
                    BOOL fFound = FALSE;
                    INT i;
                    INT nNum = 0;
                    // unc name
                    for (i = 2; i < iLength; i++ )
                    {
                        if ( *_tcsninc(str,i) == _T('\\'))
                        {
                            // find it
                            nNum ++;
                            if ( nNum == 2 )
                            {
                                fFound = TRUE;
                                break;
                            }
                        }
                    }
                    if ( fFound )
                    {
                        index = i;
                    } else
                    {
                        // bad name
                        break;
                    }
                } else
                {
                    index = 1;
                }
            }
        } else if ( *_tcsninc(str,0) == _T('\\'))
        {
            index = 0;
        }

        // okay ... build directory
        do
        {
            // find next one
            do
            {
                if ( index < ( iLength - 1))
                {
                    index ++;
                } else
                {
                    break;
                }
            } while ( *_tcsninc(str,index) != _T('\\'));


            TCHAR szCurrentDir[_MAX_PATH+1];
            TCHAR szLeftDir[_MAX_PATH+1];
            ZeroMemory( szLeftDir, _MAX_PATH+1 );

            GetCurrentDirectory( _MAX_PATH+1, szCurrentDir );

            _tcsncpy( szLeftDir, str,  index + 1 );
            if ( !SetCurrentDirectory(szLeftDir) )
            {
                if (( fReturn = CreateDirectory( szLeftDir, NULL )) != TRUE )
                {
                    break;
                }
            }

            SetCurrentDirectory( szCurrentDir );

            if ( index >= ( iLength - 1 ))
            {
                fReturn = TRUE;
                break;
            }
        } while ( TRUE );
    } while (FALSE);

    return(fReturn);
}


// szResult = szParentDir \ szSubDir
BOOL AppendDir(LPCTSTR szParentDir, LPCTSTR szSubDir, LPTSTR szResult)
{
    LPTSTR p = (LPTSTR)szParentDir;

    ASSERT(szParentDir);
    ASSERT(szSubDir);
    ASSERT(*szSubDir && *szSubDir != _T('\\'));

    if (*szParentDir == _T('\0'))
        _tcscpy(szResult, szSubDir);
    else {
        _tcscpy(szResult, szParentDir);

        p = szResult;
        while (*p)
            p = _tcsinc(p);

        if (*(_tcsdec(szResult, p)) != _T('\\'))
            _tcscat(szResult, _T("\\"));

        _tcscat(szResult, szSubDir);
    }
    return TRUE;
}



//***************************************************************************
//*                                                                         
//* purpose: add's filename onto path
//* 
//***************************************************************************
void AddPath(LPTSTR szPath, LPCTSTR szName )
{
	LPTSTR p = szPath;
    LPTSTR pPrev;
    ASSERT(szPath);
    ASSERT(szName); 

    // Find end of the string
    while (*p){p = _tcsinc(p);}
	
	// If no trailing backslash then add one
    pPrev = _tcsdec(szPath, p);
    if ( (!pPrev) ||
         (*(pPrev) != _T('\\'))
         )
		{_tcscat(szPath, _T("\\"));}
	
	// if there are spaces precluding szName, then skip
    while ( *szName == ' ' ) szName = _tcsinc(szName);;

	// Add new name to existing path string
	_tcscat(szPath, szName);
}


CString AddPath(CString szPath, LPCTSTR szName )
{
    TCHAR szPathCopy[_MAX_PATH] = _T("");
    _tcscpy(szPathCopy,szPath);
	LPTSTR p = szPathCopy;
    ASSERT(szPathCopy);
    ASSERT(szName); 

    // Find end of the string
    while (*p){p = _tcsinc(p);}
	
	// If no trailing backslash then add one
    if (*(_tcsdec(szPathCopy, p)) != _T('\\'))
		{_tcscat(szPathCopy, _T("\\"));}
	
	// if there are spaces precluding szName, then skip
    while ( *szName == _T(' ') ) szName = _tcsinc(szName);;

    // make sure that the szName
    // does not look like this "\filename"
    CString csTempString = szName;
    if (_tcsicmp(csTempString.Left(1), _T("\\")) == 0)
    {
        csTempString = csTempString.Right( csTempString.GetLength() - 1);
    }
    
	// Add new name to existing path string
	_tcscat(szPathCopy, csTempString);

    return szPathCopy;
    //szPath = szPathCopy;
}


BOOL ReturnFileNameOnly(LPCTSTR lpFullPath, LPTSTR lpReturnFileName)
{
    int iReturn = FALSE;

    TCHAR pfilename_only[_MAX_FNAME];
    TCHAR pextention_only[_MAX_EXT];

    _tcscpy(lpReturnFileName, _T(""));

    _tsplitpath( lpFullPath, NULL, NULL, pfilename_only, pextention_only);
    if (pextention_only) {_tcscat(pfilename_only,pextention_only);}
    if (pfilename_only)
    {
        _tcscpy(lpReturnFileName, pfilename_only);
        iReturn = TRUE;
    }
    else
    {
        // well, we don't have anything in pfilename_only
        // that's probably because we got some strange path name like:
        // /??/c:\somethng\filename.txt
        // so... let's just return everything after the last "\" character.
        LPTSTR pszTheLastBackSlash = _tcsrchr((LPTSTR) lpFullPath, _T('\\'));
        _tcscpy(lpReturnFileName, pszTheLastBackSlash);
        iReturn = TRUE;
    }
    return iReturn;
}


BOOL ReturnFilePathOnly(LPCTSTR lpFullPath, LPTSTR lpReturnPathOnly)
{
    int iReturn = FALSE;
    TCHAR szDrive_only[_MAX_DRIVE];
    TCHAR szPath_only[_MAX_PATH];
    TCHAR szFilename_only[_MAX_PATH];
    TCHAR szFilename_ext_only[_MAX_EXT];

    _tcscpy(lpReturnPathOnly, _T(""));
    _tsplitpath( lpFullPath, szDrive_only, szPath_only, szFilename_only, szFilename_ext_only);
    _tcscpy(lpReturnPathOnly, szDrive_only);
    _tcscat(lpReturnPathOnly, szPath_only);
    iReturn = TRUE;

    return iReturn;
}


void DeleteFilesWildcard(TCHAR *szDir, TCHAR *szFileName)
{
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szFileToBeDeleted[_MAX_PATH];

    _stprintf(szFileToBeDeleted, _T("%s\\%s"), szDir, szFileName);

    hFile = FindFirstFile(szFileToBeDeleted, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE) 
    {
        do {
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        // this is a directory, so let's skip it
                    }
                    else
                    {
                        // this is a file, so let's Delete it.
                        TCHAR szTempFileName[_MAX_PATH];
                        _stprintf(szTempFileName, _T("%s\\%s"), szDir, FindFileData.cFileName);
                        // set to normal attributes, so we can delete it
                        SetFileAttributes(szTempFileName, FILE_ATTRIBUTE_NORMAL);
                        // delete it, hopefully
                        InetDeleteFile(szTempFileName);
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) ) 
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }

    return;
}


int IsThisDriveNTFS(IN LPTSTR FileName)
{
    BOOL Ntfs = FALSE;
    TCHAR szDriveRootPath[_MAX_DRIVE + 5];
    DWORD DontCare;
    TCHAR NameBuffer[100];

    // get the Drive only.
    _tsplitpath( FileName, szDriveRootPath, NULL, NULL, NULL);
    _tcscat(szDriveRootPath, _T("\\"));

    //
    //  find out what the file system is
    //
    if (0 != GetVolumeInformation(szDriveRootPath,NULL,0,NULL,&DontCare,&DontCare,NameBuffer,sizeof(NameBuffer)/sizeof(TCHAR)))
    {
        if (0 == _tcsicmp(NameBuffer,_T("NTFS"))) 
            {Ntfs = TRUE;}
    }

    return Ntfs;
}


// take something like
// e:\winnt\system32         and return back %systemroot%\system23
// e:\winnt\system32\inetsrv and return back %systemroot%\system23\inetsrv
int ReverseExpandEnvironmentStrings(LPTSTR szOriginalDir,LPTSTR szNewlyMungedDir)
{
    int     iReturn = FALSE;
    int     iWhere = 0;
    TCHAR   szSystemDir[_MAX_PATH];
    CString csTempString;
    CString csTempString2;

    // default it with the input string
    _tcscpy(szNewlyMungedDir, szOriginalDir);

    // get the c:\winnt\system32 dir
    if (0 == GetSystemDirectory(szSystemDir, _MAX_PATH))
    {
        // we weren't able to get the systemdirectory, so just return whatever was put in
        iReturn = TRUE;
        goto ReverseExpandEnvironmentStrings_Exit;
    }

    csTempString = szOriginalDir;
    csTempString2 = szSystemDir;

    // Find the "e:\winnt\system32"
    iWhere = csTempString.Find(szSystemDir);
    if (-1 != iWhere)
    {
        CString AfterString;

        // there is a "e:\winnt\system32" in the string
        // Get the after e:\winnt\system32 stuff
        AfterString = csTempString.Right(csTempString.GetLength() - (iWhere + csTempString2.GetLength()));

        // Take everything after the string and append it to our new string.
        _tcscpy(szNewlyMungedDir, _T("%SystemRoot%\\System32"));
        _tcscat(szNewlyMungedDir, AfterString);

        // return true!
        iReturn = TRUE;
    }

ReverseExpandEnvironmentStrings_Exit:
    return iReturn;
}


DWORD ReturnFileSize(LPCTSTR myFileName)
{
    DWORD dwReturn = 0xFFFFFFFF;
    HANDLE hFile = CreateFile(myFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        dwReturn = GetFileSize(hFile, NULL);
        CloseHandle(hFile);
    }
    return dwReturn;
}


BOOL IsFileExist_NormalOrCompressed(LPCTSTR szFile)
{
    int iReturn = FALSE;
    TCHAR szDrive_only[_MAX_DRIVE];
    TCHAR szPath_only[_MAX_PATH];
    TCHAR szFilename_only[_MAX_PATH];
    TCHAR szFilename_ext_only[_MAX_EXT];

    TCHAR szCompressedName[_MAX_PATH];

    // Check if the file exsts
    // if it doesn't, check if maybe the compressed file exists.
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("IsFileExist_NormalOrCompressed:%s.\n"), szFile));
    if (IsFileExist(szFile) != TRUE)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("IsFileExist_NormalOrCompressed:%s not exist.\n"), szFile));
        // check if maybe the compressed file exists
        _tsplitpath( szFile, szDrive_only, szPath_only, szFilename_only, szFilename_ext_only);

        // Replace the last character with an '_'
        int nLen = 0;
        nLen = _tcslen(szFilename_ext_only);
        *_tcsninc(szFilename_ext_only, nLen-1) = _T('_');
        _stprintf(szCompressedName,_T("%s%s%s%s"),szDrive_only, szPath_only, szFilename_only, szFilename_ext_only);

        // see if it exists
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("IsFileExist_NormalOrCompressed:%s.\n"), szCompressedName));
        if (IsFileExist(szCompressedName) != TRUE) 
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("IsFileExist_NormalOrCompressed:%s. no exist.\n"), szCompressedName));
            goto IsFileExist_RegOrCompressed_Exit;
        }
        else
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("IsFileExist_NormalOrCompressed:%s. exist.\n"), szCompressedName));
        }
    }

    // we got this far, that must mean things are okay.
    iReturn = TRUE;

IsFileExist_RegOrCompressed_Exit:
    return iReturn;
}


// Clean leading & trailing spaces
// Clean trailing backslashes
BOOL CleanPathString(LPTSTR szPath)
{
    CString csPath = szPath;

    csPath.TrimLeft();
    csPath.TrimRight();

    _tcscpy(szPath, (LPCTSTR)csPath);

    return TRUE;
}


//
//  Return 0 if there was nothing to compare 
//  Return 1 if Source is Equal  to   Destination
//  Return 2 if Source is Larger than Destination
//  Return 3 if Source is Less   than Destination
//
INT VerCmp(LPTSTR szSrcVerString, LPTSTR szDestVerString)
{
    INT iReturn = 0;
    const DWORD MAX_NUM_OF_VER_FIELDS = 32;
    DWORD dwSrcVer[MAX_NUM_OF_VER_FIELDS], dwDestVer[MAX_NUM_OF_VER_FIELDS];
    memset( (PVOID)dwSrcVer, 0, sizeof(dwSrcVer));
    memset( (PVOID)dwDestVer, 0, sizeof(dwDestVer));
    int i=0;
    TCHAR szSeps[] = _T(".");
    TCHAR *token;
    BOOL bNotEqual = FALSE;

    // expand src version string into a dword arrary
    i = 0;
    token = _tcstok(szSrcVerString, szSeps);
    while ( token && (i < MAX_NUM_OF_VER_FIELDS) ) {
        dwSrcVer[i++] = _ttoi(token);
        token = _tcstok(NULL, szSeps);
    }

    // expand dest version string into a dword arrary
    i = 0;
    token = _tcstok(szDestVerString, szSeps);
    while ( token && (i < MAX_NUM_OF_VER_FIELDS) ) {
        dwDestVer[i++] = _ttoi(token);
        token = _tcstok(NULL, szSeps);
    }

    // Check for Equality
    for (i=0; i<MAX_NUM_OF_VER_FIELDS; i++) 
    {
        if (dwSrcVer[i] != dwDestVer[i])
            {
            bNotEqual = TRUE;
            break;
            }
    }

    if (TRUE == bNotEqual)
    {
        // int compare each field
        for (i=0; i<MAX_NUM_OF_VER_FIELDS; i++) 
        {
            if (dwSrcVer[i] > dwDestVer[i])
                {return 2;}
            if (dwSrcVer[i] < dwDestVer[i])
                {return 3;}
        }
        // if we haven't return here, then
        // there probably wasn't anything to loop thru (for 0=0 till 0)
        return 0;
    }
    else
    {
        // it is equal so return so
        return 1;
    }
}


DWORD atodw(LPCTSTR lpszData)
{
    DWORD i = 0, sum = 0;
    TCHAR *s, *t;

    s = (LPTSTR)lpszData;
    t = (LPTSTR)lpszData;

    while (*t)
        t = _tcsinc(t);
    t = _tcsdec(lpszData, t);

    if (*s == _T('0') && (*(_tcsinc(s)) == _T('x') || *(_tcsinc(s)) == _T('X')))
        s = _tcsninc(s, 2);

    while (s <= t) {
        if ( *s >= _T('0') && *s <= _T('9') )
            i = *s - _T('0');
        else if ( *s >= _T('a') && *s <= _T('f') )
            i = *s - _T('a') + 10;
        else if ( *s >= _T('A') && *s <= _T('F') )
            i = *s - _T('A') + 10;
        else
            break;

        sum = sum * 16 + i;
        s = _tcsinc(s);
    }
    return sum;
}


void MakePath(LPTSTR lpPath)
{
   LPTSTR  lpTmp;
   lpTmp = CharPrev( lpPath, lpPath + _tcslen(lpPath));

   // chop filename off
   while ( (lpTmp > lpPath) && *lpTmp && (*lpTmp != '\\') )
      lpTmp = CharPrev( lpPath, lpTmp );

   if ( *CharPrev( lpPath, lpTmp ) != ':' )
       *lpTmp = '\0';
   else
       *CharNext(lpTmp) = '\0';
   return;
}


CString ReturnUniqueFileName(CString csInputFullName)
{
    TCHAR szPathCopy[_MAX_PATH] = _T("");
    _tcscpy(szPathCopy,csInputFullName);
    long iNum = 1;
    do
    {
        _stprintf(szPathCopy,TEXT("%s.%d"),csInputFullName,iNum);
        // Check if the file exists
        if (!IsFileExist(szPathCopy)){goto ReturnUniqueFileName_Exit;}
        iNum++;
    } while (iNum <= 50);

ReturnUniqueFileName_Exit:
    // returns %s50 if there are fifty copies aleady!
    return szPathCopy;
}


/*---------------------------------------------------------------------------*
  Description: Displays the current running version of setup to the debug
  output and setup log.
-----------------------------------------------------------------------------*/
void DisplayVerOnCurrentModule()
{
    TCHAR       tszModuleName[_MAX_PATH+1];
    GetModuleFileName((HINSTANCE)g_MyModuleHandle, tszModuleName, _MAX_PATH+1);
    LogFileVersion(tszModuleName, TRUE);
    return;
}

void MyGetVersionFromFile(LPCTSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, LPTSTR pszReturnLocalizedVersion)
{
    struct TRANSARRAY {
	    WORD wLanguageID;
	    WORD wCharacterSet;
    };
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    VS_FIXEDFILEINFO * lpVSFixedFileInfo;
    LPTSTR      lpBuffer = NULL;
    LPVOID      lpVerBuffer = NULL;

    LPTSTR		pszTheResult = NULL;
    TCHAR       QueryString[48] = _T("");
    TRANSARRAY	*lpTransArray;

    *pdwMSVer = *pdwLSVer = 0L;

    dwVerInfoSize = GetFileVersionInfoSize( (LPTSTR) lpszFilename, &dwHandle);
    if (dwVerInfoSize)
    {
        // Alloc the memory for the version stamping
        lpBuffer = (LPTSTR) LocalAlloc(LPTR, dwVerInfoSize);
        if (lpBuffer)
        {
            int iTemp = 0;
            iTemp = GetFileVersionInfo( (LPTSTR) lpszFilename, dwHandle, dwVerInfoSize, lpBuffer);

            // Read version stamping info
            if (iTemp)
            {
                // Get the value for Translation
                if (VerQueryValue(lpBuffer, _T("\\"), (LPVOID*)&lpVSFixedFileInfo, &uiSize) && (uiSize))
                {
                    *pdwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
                    *pdwLSVer = lpVSFixedFileInfo->dwFileVersionLS;
                }

		        // get a pointer to the translation table information
		        if (VerQueryValue(lpBuffer, _T("\\VarFileInfo\\Translation"), &lpVerBuffer, &uiSize) && (uiSize))
                {
		            lpTransArray = (TRANSARRAY *) lpVerBuffer;
		            // lpTransArray points to the translation array.  dwFixedLength has number of bytes in array
		            _stprintf(QueryString, _T("\\StringFileInfo\\%04x%04x\\FileVersion"), lpTransArray[0].wLanguageID, lpTransArray[0].wCharacterSet);
		            if (VerQueryValue(lpBuffer, QueryString, (LPVOID*) &pszTheResult, &uiSize))
                    {
                        _tcscpy(pszReturnLocalizedVersion, pszTheResult);
                    }
                }
            }
        }
    }

    if(lpBuffer) {LocalFree(lpBuffer);lpBuffer=NULL;}
    return ;
}


BOOL MyGetDescriptionFromFile(LPCTSTR lpszFilename, LPTSTR pszReturnDescription)
{
    BOOL  bRet = FALSE;
    struct TRANSARRAY {
	    WORD wLanguageID;
	    WORD wCharacterSet;
    };
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    VS_FIXEDFILEINFO * lpVSFixedFileInfo;
    LPTSTR      lpBuffer = NULL;
    LPVOID      lpTempBuffer = NULL;

    LPTSTR		pszTheResult = NULL;
    TCHAR       QueryString[52] = _T("");
    TRANSARRAY	*lpTransArray;

    dwVerInfoSize = GetFileVersionInfoSize( (LPTSTR) lpszFilename, &dwHandle);
    if (dwVerInfoSize)
    {
        // Alloc the memory for the version stamping
        lpBuffer = (LPTSTR) LocalAlloc(LPTR, dwVerInfoSize);
        if (lpBuffer)
        {
            int iTemp = 0;
            iTemp = GetFileVersionInfo( (LPTSTR) lpszFilename, dwHandle, dwVerInfoSize, lpBuffer);

            // Read version stamping info
            if (iTemp)
            {
		        // get a pointer to the translation table information
                if (VerQueryValue(lpBuffer, _T("\\VarFileInfo\\Translation"), &lpTempBuffer, &uiSize) && (uiSize))
                {
		            lpTransArray = (TRANSARRAY *) lpTempBuffer;
		            // lpTransArray points to the translation array.  dwFixedLength has number of bytes in array
		            _stprintf(QueryString, _T("\\StringFileInfo\\%04x%04x\\FileDescription"), lpTransArray[0].wLanguageID, lpTransArray[0].wCharacterSet);
		            if (VerQueryValue(lpBuffer, QueryString, (LPVOID*) &pszTheResult, &uiSize))
                    {
                        _tcscpy(pszReturnDescription, pszTheResult);
                        bRet = TRUE;
                    }
                }
            }
        }
    }

    if(lpBuffer) {LocalFree(lpBuffer);lpBuffer=NULL;}
    return bRet;
}


//
// Returns True if the filename has a version stamp which is part of ntop4.0
//
int IsFileLessThanThisVersion(IN LPCTSTR lpszFullFilePath, IN DWORD dwNtopMSVer, IN DWORD dwNtopLSVer)
{
    int iReturn = FALSE;
    DWORD  dwMSVer, dwLSVer;
    TCHAR szLocalizedVersion[100] = _T("");
 
    // if the filename has a version number
    // and it's larger than the release version of ntop 4.2.622.1, 4.02.0622 (localized version)
    // return back true! if not, then return back false.

    // see if the file exists
    if (!IsFileExist(lpszFullFilePath)) 
        {goto iFileWasPartOfIIS4_Exit;}

    // get the fileinformation
    // includes version and localizedversion
    MyGetVersionFromFile(lpszFullFilePath, &dwMSVer, &dwLSVer, szLocalizedVersion);
    if (!dwMSVer)
        {
        iisDebugOut((LOG_TYPE_TRACE, _T("iFileWasPartOfIIS4:%s.No version."), lpszFullFilePath));
        goto iFileWasPartOfIIS4_Exit;
        }

    // okay, there is a version on this.
    iisDebugOut((LOG_TYPE_TRACE, _T("iFileWasPartOfIIS4:%d.%d.%d.%d, %s, %s"), HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer), szLocalizedVersion, lpszFullFilePath));

    // Check if the version is smaller than what was shipped with iis4.0
    // NTOP versions were 4.02.0622
    if (dwMSVer < dwNtopMSVer)
        {goto iFileWasPartOfIIS4_Exit;}

    // check if the file has a smaller minor version number
    if ( (dwMSVer == dwNtopMSVer) && (dwLSVer < dwNtopLSVer) )
        {goto iFileWasPartOfIIS4_Exit;}

    // this is a ntop 4.0 or greater versioned file
    iReturn = TRUE;

iFileWasPartOfIIS4_Exit:
    return iReturn;
}


void MakeSureDirAclsHaveAtLeastRead(LPTSTR lpszDirectoryPath)
{
    iisDebugOut_Start1(_T("MakeSureDirAclsHaveAtLeastRead"),lpszDirectoryPath, LOG_TYPE_TRACE);

    DWORD err;
    TCHAR szThePath[_MAX_PATH];

    if (FALSE == IsThisDriveNTFS(lpszDirectoryPath))
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("MakeSureDirAclsHaveAtLeastRead:filesys is not ntfs.")));
        goto MakeSureDirAclsHaveAtLeastRead_Exit;
    }

    do
    {
        //
        // Loop through all the files in the physical path
        //
        _tcscpy(szThePath, lpszDirectoryPath);
        _tcscat(szThePath, _T("\\*"));

        WIN32_FIND_DATA w32data;
        HANDLE hFind = ::FindFirstFile(szThePath, &w32data);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("MakeSureDirAclsHaveAtLeastRead:WARNING.filenotfound:%s"),lpszDirectoryPath));
            // No files...
            break;
        }
        //
        // First, set the new ACL on the folder itself.
        //
        err = SetAccessOnFile(lpszDirectoryPath, TRUE);
        err = SetAccessOnFile(lpszDirectoryPath, FALSE);
        err = ERROR_SUCCESS;
        //if (err != ERROR_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("MakeSureDirAclsHaveAtLeastRead:%s:FAILED WARNING.ret=0x%x."),lpszDirectoryPath,err));}
        //
        // Now do all the files in it
        //
        do
        {
            //
            // Only set the acl on files, not sub-directories
            //
            if (w32data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                continue;
            }

            //
            // Build the current file's full path name
            //
            _tcscpy(szThePath, lpszDirectoryPath);
            _tcscat(szThePath, _T("\\"));
            _tcscat(szThePath, w32data.cFileName);

            err = SetAccessOnFile(szThePath, TRUE);
            err = SetAccessOnFile(szThePath, FALSE);
            err = ERROR_SUCCESS;
            //if (err != ERROR_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("MakeSureDirAclsHaveAtLeastRead:%s:FAILED WARNING.ret=0x%x."),szThePath,err));}

        } while(SUCCEEDED(err) && FindNextFile(hFind, &w32data));
        FindClose(hFind);
    } while(FALSE);

MakeSureDirAclsHaveAtLeastRead_Exit:
    return;
}


DWORD SetAccessOnFile(IN LPTSTR FileName, BOOL bDoForAdmin)
{
    DWORD dwError = 0;
    TCHAR TrusteeName[50];
    PACL  ExistingDacl = NULL;
    PACL  NewAcl = NULL;
    PSECURITY_DESCRIPTOR psd = NULL;

    // access stuff.
    DWORD AccessMask = GENERIC_ALL;
    EXPLICIT_ACCESS explicitaccess;
    ACCESS_MODE option;
    DWORD InheritFlag = NO_INHERITANCE;

    // other
    PSID principalSID = NULL;
    BOOL bWellKnownSID = FALSE;
    TRUSTEE myTrustee;

    // other other
	LPCTSTR ServerName = NULL; // local machine
	DWORD cbName = 200;
    TCHAR lpGuestGrpName[200];
	TCHAR ReferencedDomainName[200];
	DWORD cbReferencedDomainName = sizeof(ReferencedDomainName);
	SID_NAME_USE sidNameUse = SidTypeUser;

    // get current Dacl on specified file
    dwError = GetNamedSecurityInfo(FileName,SE_FILE_OBJECT,DACL_SECURITY_INFORMATION,NULL,NULL,&ExistingDacl,NULL,&psd);
    if(dwError != ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("SetAccessOnFile: GetNamedSecurityInfo failed on %s. err=0x%x\n"),FileName,dwError));
        goto SetAccessOnFile_Exit;
    }
    // set defaults
    option = GRANT_ACCESS;
    InheritFlag = SUB_CONTAINERS_AND_OBJECTS_INHERIT;

    if (bDoForAdmin)
    {
        // Do for Administrators -- should be more access
        AccessMask = SYNCHRONIZE ;
        AccessMask |= GENERIC_ALL;
        _tcscpy(TrusteeName,_T("BUILTIN\\ADMINISTRATORS"));
        _tcscpy(TrusteeName,_T("administrators"));
    }
    else
    {
        // Do for Administrators -- should be more access
        AccessMask = SYNCHRONIZE ;
        AccessMask |= GENERIC_READ;
        _tcscpy(TrusteeName,_T("EVERYONE"));
    }

    // Get the SID for the certain string (administrator or everyone)
    dwError = GetPrincipalSID(TrusteeName, &principalSID, &bWellKnownSID);
    if (dwError != ERROR_SUCCESS)
        {
        iisDebugOut((LOG_TYPE_WARN, _T("SetAccessOnFile:GetPrincipalSID(%s) FAILED.  Error()= 0x%x\n"), TrusteeName, dwError));
        goto SetAccessOnFile_Exit;
        }

    // using Sid, get the "localized" name
    if (0 == LookupAccountSid(ServerName, principalSID, lpGuestGrpName, &cbName, ReferencedDomainName, &cbReferencedDomainName, &sidNameUse))
        {
        iisDebugOut((LOG_TYPE_WARN, _T("SetAccessOnFile:LookupAccountSid(%s) FAILED.  GetLastError()= 0x%x\n"), TrusteeName, GetLastError()));
        goto SetAccessOnFile_Exit;
        }

    // using the "localized" name, build explicit access structure
    BuildExplicitAccessWithName(&explicitaccess,lpGuestGrpName,AccessMask,option,InheritFlag);
    explicitaccess.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    explicitaccess.Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    explicitaccess.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;

    // set the acl with this certain access stuff
    dwError = SetEntriesInAcl(1,&explicitaccess,ExistingDacl,&NewAcl);
    if(dwError != ERROR_SUCCESS)
    {
        // it may error because the user is already there
        //iisDebugOut((LOG_TYPE_WARN, _T("SetAccessOnFile: SetEntriesInAcl failed on %s. for trustee=%s. err=0x%x\n"),FileName,explicitaccess.Trustee.ptstrName,dwError));
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("SetAccessOnFile: SetEntriesInAcl failed on %s. for trustee=%s. err=0x%x\n"),FileName,explicitaccess.Trustee.ptstrName,dwError));
        goto SetAccessOnFile_Exit;
    }

    // apply new security to file
    dwError = SetNamedSecurityInfo(FileName,SE_FILE_OBJECT,DACL_SECURITY_INFORMATION,NULL,NULL,NewAcl,NULL);
    if(dwError != ERROR_SUCCESS) 
    {
        iisDebugOut((LOG_TYPE_WARN, _T("SetAccessOnFile: SetNamedSecurityInfo failed on %s. err=0x%x\n"),FileName,dwError));
        goto SetAccessOnFile_Exit;
    }

    // everything is kool!
    dwError = ERROR_SUCCESS;

SetAccessOnFile_Exit:
    if(NewAcl != NULL){LocalFree(NewAcl);}
    if(psd != NULL){LocalFree(psd);}
    if (principalSID)
    {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }
    return dwError;
}


int CreateAnEmptyFile(CString strTheFullPath)
{
    int iReturn = FALSE;
    HANDLE hFile = NULL;

    if (IsFileExist(strTheFullPath) == TRUE)
    {
        return TRUE;
    }

	// Open existing file or create a new one.
	hFile = CreateFile(strTheFullPath,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hFile = NULL;
        iisDebugOutSafeParams((LOG_TYPE_WARN, _T("CreateAnEmptyFile:() failed to CreateFile %1!s!. POTENTIAL PROBLEM.  FAILURE.\n"), strTheFullPath));
	}
    else
    {
        // write to the file
        if (hFile)
        {
            iReturn = TRUE;
            /*
            DWORD dwBytesWritten = 0;
            char szTestData[2];
            strcpy(szTestData, " ");
            if (WriteFile(hFile,szTestData,strlen(szTestData),&dwBytesWritten,NULL))
            {
                // everything is hunky dory. don't print anything
                iReturn = TRUE;
            }
            else
            {
                // error writing to the file.
                iisDebugOutSafeParams((LOG_TYPE_WARN, _T("CreateAnEmptyFile:WriteFile(%1!s!) Failed.  POTENTIAL PROBLEM.  FAILURE.  Error=0x%2!x!.\n"), strTheFullPath, GetLastError()));
            }
            */
        }
    }

    if (hFile)
    {
        CloseHandle(hFile);
    }

    return iReturn;
}


DWORD GrantUserAccessToFile(IN LPTSTR FileName,IN LPTSTR TrusteeName)
{
    iisDebugOut_Start1(_T("GrantUserAccessToFile"),FileName,LOG_TYPE_TRACE);

    DWORD dwError = 0;
    PACL  ExistingDacl = NULL;
    PACL  NewAcl = NULL;
    PSECURITY_DESCRIPTOR psd = NULL;

    // access stuff.
    DWORD AccessMask = GENERIC_ALL;
    EXPLICIT_ACCESS explicitaccess;
    ACCESS_MODE option;
    DWORD InheritFlag = NO_INHERITANCE;

    // other
    PSID principalSID = NULL;
    BOOL bWellKnownSID = FALSE;
    TRUSTEE myTrustee;

    // other other
	LPCTSTR ServerName = NULL; // local machine
	DWORD cbName = 200;
    TCHAR lpGuestGrpName[200];
	TCHAR ReferencedDomainName[200];
	DWORD cbReferencedDomainName = sizeof(ReferencedDomainName);
	SID_NAME_USE sidNameUse = SidTypeUser;

    if (IsFileExist(FileName) != TRUE)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GrantUserAccessToFile:file doesn't exist.")));
        goto GrantUserAccessToFile_Exit;
    }

    if (FALSE == IsThisDriveNTFS(FileName))
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GrantUserAccessToFile:filesys is not ntfs.")));
        goto GrantUserAccessToFile_Exit;
    }

    // get current Dacl on specified file
    dwError = GetNamedSecurityInfo(FileName,SE_FILE_OBJECT,DACL_SECURITY_INFORMATION,NULL,NULL,&ExistingDacl,NULL,&psd);
    if(dwError != ERROR_SUCCESS)
    {
        psd = NULL;
        iisDebugOut((LOG_TYPE_WARN, _T("GrantUserAccessToFile: GetNamedSecurityInfo failed on %s.\n"),FileName));
        goto GrantUserAccessToFile_Exit;
    }
    // set defaults
    option = GRANT_ACCESS;
    InheritFlag = SUB_CONTAINERS_AND_OBJECTS_INHERIT;

    // assign access
    AccessMask = SYNCHRONIZE ;
    AccessMask |= GENERIC_ALL;
    //AccessMask = MAXIMUM_ALLOWED;

    // Get the SID for the certain string (administrator or everyone)
    dwError = GetPrincipalSID(TrusteeName, &principalSID, &bWellKnownSID);
    if (dwError != ERROR_SUCCESS)
        {
        principalSID = NULL;
        iisDebugOut((LOG_TYPE_WARN, _T("GrantUserAccessToFile:GetPrincipalSID(%s) FAILED.  Error()= 0x%x\n"), TrusteeName, dwError));
        goto GrantUserAccessToFile_Exit;
        }

    // using Sid, get the "localized" name
    if (0 == LookupAccountSid(ServerName, principalSID, lpGuestGrpName, &cbName, ReferencedDomainName, &cbReferencedDomainName, &sidNameUse))
        {
        iisDebugOut((LOG_TYPE_WARN, _T("GrantUserAccessToFile:LookupAccountSid(%s) FAILED.  GetLastError()= 0x%x\n"), TrusteeName, GetLastError()));
        goto GrantUserAccessToFile_Exit;
        }

    // using the "localized" name, build explicit access structure
    BuildExplicitAccessWithName(&explicitaccess,lpGuestGrpName,AccessMask,option,InheritFlag);
    explicitaccess.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    explicitaccess.Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    explicitaccess.Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;
    if (_tcsicmp(TrusteeName, _T("administrators")) == 0 || _tcsicmp(TrusteeName, _T("everyone")) == 0)
    {
        explicitaccess.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    }

    // set the acl with this certain access stuff
    dwError = SetEntriesInAcl(1,&explicitaccess,ExistingDacl,&NewAcl);
    if(dwError != ERROR_SUCCESS)
    {
        NewAcl = NULL;
        // it may error because the user is already there
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GrantUserAccessToFile: SetEntriesInAcl failed on %s. for trustee=%s. err=0x%x\n"),FileName,explicitaccess.Trustee.ptstrName,dwError));
        goto GrantUserAccessToFile_Exit;
    }

    // apply new security to file
    dwError = SetNamedSecurityInfo(FileName,SE_FILE_OBJECT,DACL_SECURITY_INFORMATION,NULL,NULL,NewAcl,NULL);
    if(dwError != ERROR_SUCCESS) 
    {
        iisDebugOut((LOG_TYPE_WARN, _T("GrantUserAccessToFile: SetNamedSecurityInfo failed on %s. err=0x%x\n"),FileName,dwError));
        goto GrantUserAccessToFile_Exit;
    }

    // everything is kool!
    dwError = ERROR_SUCCESS;

GrantUserAccessToFile_Exit:
    if(NewAcl != NULL){LocalFree(NewAcl);}
    if(psd != NULL){LocalFree(psd);}
    if (principalSID)
    {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }
    iisDebugOut_End1(_T("GrantUserAccessToFile"),FileName);
    return dwError;
}


#ifndef _CHICAGO_

DWORD SetDirectorySecurity(
    IN  LPCTSTR                 szDirPath,
    IN  LPCTSTR                 szPrincipal,
    IN  INT                     iAceType,
    IN  DWORD                   dwAccessMask,
    IN  DWORD                   dwInheritMask
)
{
    DWORD dwStatus = ERROR_FILE_NOT_FOUND;

    if (ACCESS_ALLOWED_ACE_TYPE == iAceType || ACCESS_DENIED_ACE_TYPE == iAceType)
    {
        if (IsFileExist(szDirPath) == TRUE)
        {
            PSID principalSID = NULL;
            BOOL bWellKnownSID = FALSE;
            dwStatus = GetPrincipalSID((LPTSTR) szPrincipal, &principalSID, &bWellKnownSID);
            if (dwStatus == ERROR_SUCCESS)
            {
                PSECURITY_DESCRIPTOR psd = NULL;
                dwStatus = SetAccessOnDirOrFile((TCHAR*) szDirPath,principalSID,iAceType,dwAccessMask,dwInheritMask,&psd);

                //DumpAdminACL(INVALID_HANDLE_VALUE,psd);
                if (psd) {free(psd);psd=NULL;}
            }
        }
    }
    return dwStatus;
}

// -------------------------------------------------------------------------------------
// Function: RemovePrincipalFromFileAcl
//
// Remove a Access Control Entry from an Access Control List for a file/directory for a 
// particular SID
//
// -------------------------------------------------------------------------------------
DWORD RemovePrincipalFromFileAcl(IN TCHAR *pszFile,IN  LPTSTR szPrincipal)
{
    PACL                        pdacl;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    PSECURITY_DESCRIPTOR        psdRelative = NULL;
    PSECURITY_DESCRIPTOR        psdAbsolute = NULL;
    DWORD                       cbSize = 0;
    BOOL                        bRes = 0;
    DWORD                       dwSecurityDescriptorRevision;
    BOOL                        fHasDacl  = FALSE;
    BOOL                        fDaclDefaulted = FALSE; 
    BOOL                        bUserExistsToBeDeleted;
    DWORD                       dwError = ERROR_SUCCESS;

    // get the size of the security descriptor
    if ( !(bRes = GetFileSecurity(pszFile,DACL_SECURITY_INFORMATION,psdRelative,0,&cbSize)) )
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            psdRelative = malloc(cbSize);

            if (!psdRelative)
            {
                return ERROR_INSUFFICIENT_BUFFER;
            }

             bRes = GetFileSecurity(pszFile,DACL_SECURITY_INFORMATION,psdRelative,cbSize,&cbSize);
        }
    }

    if (!bRes)
    {
        if (psdRelative)
        {
            free(psdRelative);
        }
        return (GetLastError());
    }

    // get security descriptor control from the security descriptor 
    if (!GetSecurityDescriptorControl(psdRelative, (PSECURITY_DESCRIPTOR_CONTROL) &sdc,(LPDWORD) &dwSecurityDescriptorRevision))
    {
         dwError = GetLastError();
    }   
    else if (SE_DACL_PRESENT & sdc) 
    { 
        // Acl's are present, so we will attempt to remove the one passes in.
        if (GetSecurityDescriptorDacl(psdRelative, (LPBOOL) &fHasDacl,(PACL *) &pdacl, (LPBOOL) &fDaclDefaulted))
        {
            // Remove ACE from Acl
            dwError = RemovePrincipalFromACL(pdacl,szPrincipal,&bUserExistsToBeDeleted);

            if (dwError == ERROR_SUCCESS)
            {
                psdAbsolute = (PSECURITY_DESCRIPTOR) malloc(GetSecurityDescriptorLength(psdRelative));

                if (psdAbsolute)
                {
                    if ( !(InitializeSecurityDescriptor(psdAbsolute, SECURITY_DESCRIPTOR_REVISION)) ||
                         !(SetSecurityDescriptorDacl(psdAbsolute, TRUE, pdacl, fDaclDefaulted)) ||
                         !(IsValidSecurityDescriptor(psdAbsolute)) ||
                         !(SetFileSecurity(pszFile,(SECURITY_INFORMATION)(DACL_SECURITY_INFORMATION),psdAbsolute))
                       )
                    {
                        dwError = GetLastError();
                    }

                    if (psdAbsolute)
                    {
                        free(psdAbsolute);
                    }
                }
                else
                {
                    dwError = ERROR_INSUFFICIENT_BUFFER;
                }
            }
        } 
        else
        {
            dwError = GetLastError();
        }
    }

    if (psdRelative)
    {
        free(psdRelative);
    }

    return dwError;
}

DWORD SetAccessOnDirOrFile(IN TCHAR *pszFile,PSID psidGroup,INT iAceType,DWORD dwAccessMask,DWORD dwInheritMask,PSECURITY_DESCRIPTOR* ppsd)
{
    PSECURITY_DESCRIPTOR        psdAbsolute = NULL;
    PACL                        pdacl;
    DWORD                       cbSecurityDescriptor = 0;
    DWORD                       dwSecurityDescriptorRevision;
    DWORD                       cbDacl = 0;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    PACL                        pdaclNew = NULL; 
    DWORD                       cbAddDaclLength = 0; 
    BOOL                        fAceFound = FALSE;
    BOOL                        fHasDacl  = FALSE;
    BOOL                        fDaclDefaulted = FALSE; 
    ACCESS_ALLOWED_ACE*         pAce;
    DWORD                       i;
    BOOL                        fAceForGroupPresent = FALSE;
    DWORD                       dwMask;
    PSECURITY_DESCRIPTOR        psdRelative = NULL;
    DWORD                       cbSize = 0;
    BOOL bRes = 0;

    // get the size of the security descriptor
    bRes = GetFileSecurity(pszFile,DACL_SECURITY_INFORMATION,psdRelative,0,&cbSize);
    DWORD dwError = GetLastError();
    if (ERROR_INSUFFICIENT_BUFFER == dwError)
    {
        psdRelative = malloc(cbSize);
        if (!psdRelative)
        {
            return ERROR_INSUFFICIENT_BUFFER;
        }

         bRes = GetFileSecurity(pszFile,DACL_SECURITY_INFORMATION,psdRelative,cbSize,&cbSize);
    }

    if (!bRes)
    {
        if (psdRelative){free(psdRelative);}
        return (GetLastError());
    }

    // get security descriptor control from the security descriptor 
    if (!GetSecurityDescriptorControl(psdRelative, (PSECURITY_DESCRIPTOR_CONTROL) &sdc,(LPDWORD) &dwSecurityDescriptorRevision))
    {
         return (GetLastError());
    }

    // check if DACL is present 
    if (SE_DACL_PRESENT & sdc) 
    {
        ACE_HEADER *pAceHeader;

        // get dacl   
        if (!GetSecurityDescriptorDacl(psdRelative, (LPBOOL) &fHasDacl,(PACL *) &pdacl, (LPBOOL) &fDaclDefaulted))
        {
            return ( GetLastError());
        }

        // check if pdacl is null
        // if it is then security is wide open -- this could be a fat drive.
        if (NULL == pdacl)
        {
            return ERROR_SUCCESS;
        }

        // get dacl length  
        cbDacl = pdacl->AclSize;
        // now check if SID's ACE is there  
        for (i = 0; i < pdacl->AceCount; i++)  
        {
            if (!GetAce(pdacl, i, (LPVOID *) &pAce))
            {
                return ( GetLastError());   
            }

            pAceHeader = (ACE_HEADER *)pAce;

            // check if group sid is already there
            if (EqualSid((PSID) &(pAce->SidStart), psidGroup))    
            {
                if (ACCESS_DENIED_ACE_TYPE == iAceType)
                {
                    if (pAceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
                    {
                        // If the correct access is present, return success
                        if ((pAce->Mask & dwAccessMask) == dwAccessMask)
                        {
                            return ERROR_SUCCESS;
                        }
                        fAceForGroupPresent = TRUE;
                        break;  
                    }
                }
                else
                {
                    if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
                    {
                        // If the correct access is present, return success
                        if ((pAce->Mask & dwAccessMask) == dwAccessMask)
                        {
                            return ERROR_SUCCESS;
                        }
                        fAceForGroupPresent = TRUE;
                        break;  
                    }
                }
            }
        }
        // if the group did not exist, we will need to add room
        // for another ACE
        if (!fAceForGroupPresent)  
        {
            // get length of new DACL  
            cbAddDaclLength = sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(psidGroup); 
        }
    } 
    else
    {
        // get length of new DACL
        cbAddDaclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid (psidGroup);
    }


    // get memory needed for new DACL
    pdaclNew = (PACL) malloc (cbDacl + cbAddDaclLength);
    if (!pdaclNew)
    {
        return (GetLastError()); 
    }

    // get the sd length
    cbSecurityDescriptor = GetSecurityDescriptorLength(psdRelative); 

    // get memory for new SD
    psdAbsolute = (PSECURITY_DESCRIPTOR) malloc(cbSecurityDescriptor + cbAddDaclLength);
    if (!psdAbsolute) 
    {  
        dwError = GetLastError();
        goto ErrorExit; 
    }
    
    // change self-relative SD to absolute by making new SD
    if (!InitializeSecurityDescriptor(psdAbsolute, SECURITY_DESCRIPTOR_REVISION)) 
    {  
        dwError = GetLastError();
        goto ErrorExit; 
    }
    
    // init new DACL
    if (!InitializeAcl(pdaclNew, cbDacl + cbAddDaclLength, ACL_REVISION)) 
    {  
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // Add a new ACE for our SID if one was not already present
    if ( (!fAceForGroupPresent) && (ACCESS_DENIED_ACE_TYPE == iAceType) )
    {
        if (!AddAccessDeniedAce(pdaclNew, ACL_REVISION, dwAccessMask,psidGroup)) 
        {  
            dwError = GetLastError();  
            goto ErrorExit; 
        }
    }

    // now add in all of the ACEs into the new DACL (if org DACL is there)
    if (SE_DACL_PRESENT & sdc) 
    {
        ACE_HEADER *pAceHeader;

        for (i = 0; i < pdacl->AceCount; i++)
        {   
            // get ace from original dacl
            if (!GetAce(pdacl, i, (LPVOID*) &pAce))   
            {
                dwError = GetLastError();    
                goto ErrorExit;   
            }

            pAceHeader = (ACE_HEADER *)pAce;

            if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
            {
                dwMask = pAce->Mask;
                if (ACCESS_ALLOWED_ACE_TYPE == iAceType)
                {
                    // If an ACE for our SID exists, we just need to bump
                    // up the access level instead of creating a new ACE
                    if (EqualSid((PSID) &(pAce->SidStart), psidGroup))
                    {
                        dwMask = dwAccessMask | pAce->Mask;
                    }
                }
                if (!AddAccessAllowedAceEx(pdaclNew, ACL_REVISION, pAce->Header.AceFlags,dwMask,(PSID) &(pAce->SidStart)))   
                {
                    dwError = GetLastError();
                    goto ErrorExit;   
                }
            }
            else if (pAceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
            {
                dwMask = pAce->Mask;
                if (ACCESS_DENIED_ACE_TYPE == iAceType)
                {
                    // If an ACE for our SID exists, we just need to bump
                    // up the access level instead of creating a new ACE
                    if (EqualSid((PSID) &(pAce->SidStart), psidGroup))
                    {
                        dwMask = dwAccessMask | pAce->Mask;
                    }
                }
                if (!AddAccessDeniedAceEx(pdaclNew, ACL_REVISION, pAce->Header.AceFlags,dwMask,(PSID) &(pAce->SidStart)))   
                {
                    dwError = GetLastError();
                    goto ErrorExit;   
                }
            }
            else
            {
                // copy denied or audit ace.
                if (!AddAce(pdaclNew, ACL_REVISION, 0xFFFFFFFF,pAce, pAceHeader->AceSize ))
                {
                    dwError = GetLastError();
                    goto ErrorExit;   
                }
            }

            //iisDebugOut((LOG_TYPE_TRACE, _T("OrgAce[%d]=0x%x\n"),i,pAce->Header.AceFlags));
        }
    } 

    // Add a new ACE for our SID if one was not already present
    if ( (!fAceForGroupPresent) && (ACCESS_ALLOWED_ACE_TYPE == iAceType) )
    {
        if (!AddAccessAllowedAce(pdaclNew, ACL_REVISION, dwAccessMask,psidGroup)) 
        {  
            dwError = GetLastError();  
            goto ErrorExit; 
        }
    }
    
    // change the header on an existing ace to have inherit
    for (i = 0; i < pdaclNew->AceCount; i++)
    {
        if (!GetAce(pdaclNew, i, (LPVOID *) &pAce))
        {
            return ( GetLastError());   
        }

        // CONTAINER_INHERIT_ACE = Other containers that are contained by the primary object inherit the entry.  
        // INHERIT_ONLY_ACE = The ACE does not apply to the primary object to which the ACL is attached, but objects contained by the primary object inherit the entry.  
        // NO_PROPAGATE_INHERIT_ACE = The OBJECT_INHERIT_ACE and CONTAINER_INHERIT_ACE flags are not propagated to an inherited entry. 
        // OBJECT_INHERIT_ACE = Noncontainer objects contained by the primary object inherit the entry.  
        // SUB_CONTAINERS_ONLY_INHERIT = Other containers that are contained by the primary object inherit the entry. This flag corresponds to the CONTAINER_INHERIT_ACE flag. 
        // SUB_OBJECTS_ONLY_INHERIT = Noncontainer objects contained by the primary object inherit the entry. This flag corresponds to the OBJECT_INHERIT_ACE flag. 
        // SUB_CONTAINERS_AND_OBJECTS_INHERIT = Both containers and noncontainer objects that are contained by the primary object inherit the entry. This flag corresponds to the combination of the CONTAINER_INHERIT_ACE and OBJECT_INHERIT_ACE flags. 

        //iisDebugOut((LOG_TYPE_TRACE, _T("NewAce[%d]=0x%x\n"),i,pAce->Header.AceFlags));

        // if it's our SID, then change the header to be inherited
        if (EqualSid((PSID) &(pAce->SidStart), psidGroup))
        {
            pAce->Header.AceFlags |= dwInheritMask;
        }
    }


    // check if everything went ok 
    if (!IsValidAcl(pdaclNew)) 
    {
        dwError = ERROR_INVALID_ACL;
        goto ErrorExit; 
    }

    // now set security descriptor DACL
    if (!SetSecurityDescriptorDacl(psdAbsolute, TRUE, pdaclNew, fDaclDefaulted)) 
    {  
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // check if everything went ok 
    if (!IsValidSecurityDescriptor(psdAbsolute)) 
    {
        dwError = ERROR_INVALID_SECURITY_DESCR;
        goto ErrorExit; 
    }

    // now set the reg key security (this will overwrite any existing security)
    bRes = SetFileSecurity(pszFile,(SECURITY_INFORMATION)(DACL_SECURITY_INFORMATION),psdAbsolute);
    if (bRes)
    {
        dwError = ERROR_SUCCESS;
    }

    if (ppsd)
    {
        *ppsd = psdRelative;
    }

ErrorExit: 
    // free memory
    if (psdAbsolute)  
    {
        free (psdAbsolute); 
        if (pdaclNew)
        {
            free((VOID*) pdaclNew); 
        }
    }

    return dwError;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetAccessOnRegKey
//
//  Purpose:    Adds access for a specified SID to a registry key
//
//  Arguments:
//      hkey         [in]  The registry key that will receive the
//                            modified security descriptor
//      psidGroup    [in]  The SID (in self-relative mode) that will be 
//                            granted access to the key 
//      dwAccessMask [in]  The access level to grant
//      ppsd         [out] The previous security descriptor
//
//  Returns:    DWORD. ERROR_SUCCESS or a failure code from winerror.h
//
//+--------------------------------------------------------------------------
DWORD 
SetAccessOnRegKey(HKEY hkey, PSID psidGroup,
                                DWORD dwAccessMask,
                                DWORD dwInheritMask,
                                PSECURITY_DESCRIPTOR* ppsd)
{ 
    PSECURITY_DESCRIPTOR        psdAbsolute = NULL;
    PACL                        pdacl;
    DWORD                       cbSecurityDescriptor = 0;
    DWORD                       dwSecurityDescriptorRevision;
    DWORD                       cbDacl = 0;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    PACL                        pdaclNew = NULL; 
    DWORD                       cbAddDaclLength = 0; 
    BOOL                        fAceFound = FALSE;
    BOOL                        fHasDacl  = FALSE;
    BOOL                        fDaclDefaulted = FALSE; 
    ACCESS_ALLOWED_ACE*         pAce;
    DWORD                       i;
    BOOL                        fAceForGroupPresent = FALSE;
    DWORD                       dwMask;
    PSECURITY_DESCRIPTOR        psdRelative = NULL;
    DWORD                       cbSize = 0;

    // Get the current security descriptor for hkey
    //
    DWORD dwError = RegGetKeySecurity(hkey, DACL_SECURITY_INFORMATION, psdRelative, &cbSize);

    if (ERROR_INSUFFICIENT_BUFFER == dwError)
    {
        psdRelative = malloc(cbSize);
        if (!psdRelative)
        {
            return ERROR_INSUFFICIENT_BUFFER;
        }
        
        dwError = RegGetKeySecurity(hkey, DACL_SECURITY_INFORMATION, psdRelative, &cbSize);
    }

    // get security descriptor control from the security descriptor 
    if ( (!psdRelative) ||
         (dwError != ERROR_SUCCESS) ||
         (!GetSecurityDescriptorControl(psdRelative, (PSECURITY_DESCRIPTOR_CONTROL) &sdc,(LPDWORD) &dwSecurityDescriptorRevision))
       )
    {
         return (GetLastError());
    }

    // check if DACL is present 
    if (SE_DACL_PRESENT & sdc) 
    {
        ACE_HEADER *pAceHeader;

        // get dacl   
        if (!GetSecurityDescriptorDacl(psdRelative, (LPBOOL) &fHasDacl,(PACL *) &pdacl, (LPBOOL) &fDaclDefaulted))
        {
            return ( GetLastError());
        }

        // check if pdacl is null
        // if it is then security is wide open -- this could be a fat drive.
        if (NULL == pdacl)
        {
            return ERROR_SUCCESS;
        }

        // get dacl length  
        cbDacl = pdacl->AclSize;
        // now check if SID's ACE is there  
        for (i = 0; i < pdacl->AceCount; i++)  
        {
            if (!GetAce(pdacl, i, (LPVOID *) &pAce))
            {
                return ( GetLastError());   
            }

            pAceHeader = (ACE_HEADER *)pAce;
            if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
            {
                // check if group sid is already there
                if (EqualSid((PSID) &(pAce->SidStart), psidGroup))    
                {
                    // If the correct access is present, return success
                    if ((pAce->Mask & dwAccessMask) == dwAccessMask)
                    {
                        return ERROR_SUCCESS;
                    }
                    fAceForGroupPresent = TRUE;
                    break;  
                }
            }
        }
        // if the group did not exist, we will need to add room
        // for another ACE
        if (!fAceForGroupPresent)  
        {
            // get length of new DACL  
            cbAddDaclLength = sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(psidGroup); 
        }
    } 
    else
    {
        // get length of new DACL
        cbAddDaclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid (psidGroup);
    }


    // get memory needed for new DACL
    pdaclNew = (PACL) malloc (cbDacl + cbAddDaclLength);
    if (!pdaclNew)
    {
        return (GetLastError()); 
    }

    // get the sd length
    cbSecurityDescriptor = GetSecurityDescriptorLength(psdRelative); 

    // get memory for new SD
    psdAbsolute = (PSECURITY_DESCRIPTOR) malloc(cbSecurityDescriptor + cbAddDaclLength);
    if (!psdAbsolute) 
    {  
        dwError = GetLastError();
        goto ErrorExit; 
    }
    
    // change self-relative SD to absolute by making new SD
    if (!InitializeSecurityDescriptor(psdAbsolute, SECURITY_DESCRIPTOR_REVISION)) 
    {  
        dwError = GetLastError();
        goto ErrorExit; 
    }
    
    // init new DACL
    if (!InitializeAcl(pdaclNew, cbDacl + cbAddDaclLength, ACL_REVISION)) 
    {  
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // now add in all of the ACEs into the new DACL (if org DACL is there)
    if (SE_DACL_PRESENT & sdc) 
    {
        ACE_HEADER *pAceHeader;

        for (i = 0; i < pdacl->AceCount; i++)
        {
            // get ace from original dacl
            if (!GetAce(pdacl, i, (LPVOID*) &pAce))
            {
                dwError = GetLastError();    
                goto ErrorExit;   
            }

            pAceHeader = (ACE_HEADER *)pAce;
            if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
            {
                // If an ACE for our SID exists, we just need to bump
                // up the access level instead of creating a new ACE
                //
                if (EqualSid((PSID) &(pAce->SidStart), psidGroup))
                {
                    dwMask = dwAccessMask | pAce->Mask;
                }
                else
                {
                    dwMask = pAce->Mask;
                }

                //iisDebugOut((LOG_TYPE_TRACE, _T("OrgAce[%d]=0x%x\n"),i,pAce->Header.AceFlags));

                // now add ace to new dacl   
                if (!AddAccessAllowedAceEx(pdaclNew, ACL_REVISION, pAce->Header.AceFlags,dwMask,(PSID) &(pAce->SidStart)))   
                {
                    dwError = GetLastError();
                    goto ErrorExit;   
                }
            }
            else
            {
                // copy denied or audit ace.
                if (!AddAce(pdaclNew, ACL_REVISION, 0xFFFFFFFF, pAce, pAceHeader->AceSize ))
                {
                    dwError = GetLastError();
                    goto ErrorExit;   
                }
            }
        } 
    } 

    // Add a new ACE for our SID if one was not already present
    if (!fAceForGroupPresent)
    {
        // now add new ACE to new DACL
        if (!AddAccessAllowedAce(pdaclNew, ACL_REVISION, dwAccessMask,psidGroup)) 
        {  
            dwError = GetLastError();  
            goto ErrorExit; 
        }
    }
    
    // change the header on an existing ace to have inherit
    for (i = 0; i < pdaclNew->AceCount; i++)
    {
        if (!GetAce(pdaclNew, i, (LPVOID *) &pAce))
        {
            return ( GetLastError());   
        }
        // CONTAINER_INHERIT_ACE = Other containers that are contained by the primary object inherit the entry.  
        // INHERIT_ONLY_ACE = The ACE does not apply to the primary object to which the ACL is attached, but objects contained by the primary object inherit the entry.  
        // NO_PROPAGATE_INHERIT_ACE = The OBJECT_INHERIT_ACE and CONTAINER_INHERIT_ACE flags are not propagated to an inherited entry. 
        // OBJECT_INHERIT_ACE = Noncontainer objects contained by the primary object inherit the entry.  
        // SUB_CONTAINERS_ONLY_INHERIT = Other containers that are contained by the primary object inherit the entry. This flag corresponds to the CONTAINER_INHERIT_ACE flag. 
        // SUB_OBJECTS_ONLY_INHERIT = Noncontainer objects contained by the primary object inherit the entry. This flag corresponds to the OBJECT_INHERIT_ACE flag. 
        // SUB_CONTAINERS_AND_OBJECTS_INHERIT = Both containers and noncontainer objects that are contained by the primary object inherit the entry. This flag corresponds to the combination of the CONTAINER_INHERIT_ACE and OBJECT_INHERIT_ACE flags. 

        //iisDebugOut((LOG_TYPE_TRACE, _T("NewAce[%d]=0x%x\n"),i,pAce->Header.AceFlags));

        // if it's our SID, then change the header to be inherited
        if (EqualSid((PSID) &(pAce->SidStart), psidGroup))
        {
            //pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE | INHERITED_ACE;
            //pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE | dwInheritMask;
            pAce->Header.AceFlags |= dwInheritMask;
        }
    }


    // check if everything went ok 
    if (!IsValidAcl(pdaclNew)) 
    {
        dwError = ERROR_INVALID_ACL;
        goto ErrorExit; 
    }

    // now set security descriptor DACL
    if (!SetSecurityDescriptorDacl(psdAbsolute, TRUE, pdaclNew, fDaclDefaulted)) 
    {  
        dwError = GetLastError();  
        goto ErrorExit; 
    }

    // check if everything went ok 
    if (!IsValidSecurityDescriptor(psdAbsolute)) 
    {
        dwError = ERROR_INVALID_SECURITY_DESCR;
        goto ErrorExit; 
    }

    // now set the reg key security (this will overwrite any
    // existing security)
    dwError = RegSetKeySecurity(hkey, (SECURITY_INFORMATION)(DACL_SECURITY_INFORMATION), psdAbsolute);

    if (ppsd)
    {
        *ppsd = psdRelative;
    }
ErrorExit: 
    // free memory
    if (psdAbsolute)  
    {
        free (psdAbsolute); 
        if (pdaclNew)
        {
            free((VOID*) pdaclNew); 
        }
    }

    return dwError;
}



BOOL
AddUserAccessToSD(
    IN  PSECURITY_DESCRIPTOR pSd,
    IN  PSID  pSid,
    IN  DWORD NewAccess,
    IN  UCHAR TheAceType,
    OUT PSECURITY_DESCRIPTOR *ppSdNew
    )
{
    ULONG i;
    BOOL bReturn = FALSE;
    BOOL Result;
    BOOL DaclPresent;
    BOOL DaclDefaulted;
    DWORD Length;
    DWORD NewAclLength;
    ACCESS_ALLOWED_ACE* OldAce;
    PACE_HEADER NewAce;
    ACL_SIZE_INFORMATION AclInfo;
    PACL Dacl = NULL;
    PACL NewDacl = NULL;
    PACL NewAceDacl = NULL;
    PSECURITY_DESCRIPTOR NewSD = NULL;
    PSECURITY_DESCRIPTOR OldSD = NULL;
    PSECURITY_DESCRIPTOR outpSD = NULL;
    DWORD cboutpSD = 0;
    BOOL fAceForGroupPresent = FALSE;
    DWORD dwMask;

    OldSD = pSd;

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddUserAccessToSD start\n")));

    // only do if the ace is allowed/denied
    if (ACCESS_ALLOWED_ACE_TYPE != TheAceType && ACCESS_DENIED_ACE_TYPE != TheAceType)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("AddUserAccessToSD useless param\n")));
        goto AddUserAccessToSD_Exit;
    }

    // Convert SecurityDescriptor to absolute format. It generates
    // a new SecurityDescriptor for its output which we must free.
    if ( !MakeAbsoluteCopyFromRelative(OldSD, &NewSD) ) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MakeAbsoluteCopyFromRelative failed\n")));
        goto AddUserAccessToSD_Exit;

    }

    // Must get DACL pointer from new (absolute) SD
    if(!GetSecurityDescriptorDacl(NewSD,&DaclPresent,&Dacl,&DaclDefaulted)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetSecurityDescriptorDacl failed with 0x%x\n"),GetLastError()));
        goto AddUserAccessToSD_Exit;

    }

    // If no DACL, no need to add the user since no DACL
    // means all accesss
    if( !DaclPresent ) 
    {
        bReturn = TRUE;
        goto AddUserAccessToSD_Exit;
    }

    // Code can return DaclPresent, but a NULL which means
    // a NULL Dacl is present. This allows all access to the object.
    if( Dacl == NULL ) 
    {
        bReturn = TRUE;
        goto AddUserAccessToSD_Exit;
    }

    // Get the current ACL's size
    if( !GetAclInformation(Dacl,&AclInfo,sizeof(AclInfo),AclSizeInformation) ) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetAclInformation failed with 0x%x\n"),GetLastError()));
        goto AddUserAccessToSD_Exit;
    }

    // Check if access is already there
    // --------------------------------
    // Check to see if this SID already exists in there
    // if it does (and it has the right access we want) then forget it, we don't have to do anything more.
    for (i = 0; i < AclInfo.AceCount; i++)  
    {
        ACE_HEADER *pAceHeader;
        ACCESS_ALLOWED_ACE* pAce = NULL;

        if (!GetAce(Dacl, i, (LPVOID *) &pAce))
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("GetAce failed with 0x%x\n"),GetLastError()));
            goto AddUserAccessToSD_Exit;
        }

        pAceHeader = (ACE_HEADER *)pAce;

        // check if group sid is already there
        if (EqualSid((PSID) &(pAce->SidStart), pSid))
        {
            if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
            {
                // If the correct access is present, return success
                if ((pAce->Mask & NewAccess) == NewAccess)
                {
                    //iisDebugOut((LOG_TYPE_TRACE, _T("AddUserAccessToSD:correct access already present. Exiting,1=0x%x,2=0x%x,3=0x%x\n"),pAce->Mask,NewAccess,(pAce->Mask & NewAccess)));
                    bReturn = TRUE;
                    goto AddUserAccessToSD_Exit;
                }
                else
                {
                    // the ace that exist doesn't have the permissions that we want.
                    // If an ACE for our SID exists, we just need to bump
                    // up the access level instead of creating a new ACE
                    fAceForGroupPresent = TRUE;
                }
            }
            break;  
        }
    }
    
    // If we have to create a new ACE
    // (because our user isn't listed in the existing ACL)
    // then let's Create a new ACL to put the new access allowed ACE on
    // --------------------------------
    if (!fAceForGroupPresent)
    {
        NewAclLength = sizeof(ACL) +
                       sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) +
                       GetLengthSid( pSid );

        NewAceDacl = (PACL) LocalAlloc( LMEM_FIXED, NewAclLength );
        if ( NewAceDacl == NULL ) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("LocalAlloc failed\n")));
            goto AddUserAccessToSD_Exit;
        }

        if(!InitializeAcl( NewAceDacl, NewAclLength, ACL_REVISION )) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("InitializeAcl failed with 0x%x\n"),GetLastError()));
            goto AddUserAccessToSD_Exit;
        }

        if (ACCESS_DENIED_ACE_TYPE == TheAceType)
        {
            Result = AddAccessDeniedAce(NewAceDacl,ACL_REVISION,NewAccess,pSid);
        }
        else 
        {
            Result = AddAccessAllowedAce(NewAceDacl,ACL_REVISION,NewAccess,pSid);
        }
        if( !Result ) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedAce failed with 0x%x\n"),GetLastError()));
            goto AddUserAccessToSD_Exit;
        }
        // Grab the 1st ace from the Newly created Dacl
        if(!GetAce( NewAceDacl, 0, (void **)&NewAce )) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("GetAce failed with 0x%x\n"),GetLastError()));
            goto AddUserAccessToSD_Exit;
        }

        // add CONTAINER_INHERIT_ACE TO AceFlags
        //NewAce->AceFlags |= CONTAINER_INHERIT_ACE;

        Length = AclInfo.AclBytesInUse + NewAce->AceSize;
    }
    else
    {
        Length = AclInfo.AclBytesInUse;
    }

    // Allocate new DACL
    NewDacl = (PACL) LocalAlloc( LMEM_FIXED, Length );
    if(NewDacl == NULL) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("LocalAlloc failed\n")));
        goto AddUserAccessToSD_Exit;
    }
    if(!InitializeAcl( NewDacl, Length, ACL_REVISION )) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("InitializeAcl failed with 0x%x\n"),GetLastError()));
        goto AddUserAccessToSD_Exit;
    }

    // Insert new ACE at the front of the new DACL
    if (!fAceForGroupPresent)
    {
        if(!AddAce( NewDacl, ACL_REVISION, 0, NewAce, NewAce->AceSize )) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("AddAce failed with 0x%x\n"),GetLastError()));
            goto AddUserAccessToSD_Exit;
        }
    }

    // ----------------------------------------
    // Read thru the old Dacl and get the ACE's
    // add it to the new Dacl
    // ----------------------------------------
    for ( i = 0; i < AclInfo.AceCount; i++ ) 
    {
        ACE_HEADER *pAceHeader;

        Result = GetAce( Dacl, i, (LPVOID*) &OldAce );
        if( !Result ) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("GetAce failed with 0x%x\n"),GetLastError()));
            goto AddUserAccessToSD_Exit;
        }

        pAceHeader = (ACE_HEADER *)OldAce;

        // If an ACE for our SID exists, we just need to bump
        // up the access level instead of creating a new ACE
        //
        if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            dwMask = OldAce->Mask;
            if (fAceForGroupPresent)
            {
                if (EqualSid((PSID) &(OldAce->SidStart), pSid))
                {
                    dwMask = NewAccess | OldAce->Mask;
                }
            }

            // now add ace to new dacl   
            Result = AddAccessAllowedAceEx(NewDacl, ACL_REVISION, OldAce->Header.AceFlags,dwMask,(PSID) &(OldAce->SidStart));
            if( !Result ) 
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("AddAccessAllowedAceEx failed with 0x%x\n"),GetLastError()));
                goto AddUserAccessToSD_Exit;
            }
        }
        else
        {
            // copy denied or audit ace.
            if (!AddAce(NewDacl, ACL_REVISION, 0xFFFFFFFF,OldAce, pAceHeader->AceSize ))
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("AddAce failed with 0x%x\n"),GetLastError()));
                goto AddUserAccessToSD_Exit;
            }
        }
    }


    // Set new DACL for Security Descriptor
    if(!SetSecurityDescriptorDacl(NewSD,TRUE,NewDacl,FALSE)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("SetSecurityDescriptorDacl failed with 0x%x\n"),GetLastError()));
        goto AddUserAccessToSD_Exit;
    }

    // The new SD is in absolute format. change it to Relative before we pass it back
    cboutpSD = 0;
    MakeSelfRelativeSD(NewSD, outpSD, &cboutpSD);
    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);
    if ( !outpSD )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("GlobalAlloc failed\n")));
        goto AddUserAccessToSD_Exit;
    }

    if (!MakeSelfRelativeSD(NewSD, outpSD, &cboutpSD))
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MakeSelfRelativeSD failed with 0x%x\n"),GetLastError()));
        goto AddUserAccessToSD_Exit;
    }

    // The new SD is passed back in relative format,
    *ppSdNew = outpSD;

    bReturn = TRUE;

AddUserAccessToSD_Exit:
    if (NewSD){free( NewSD );NewSD = NULL;}
    if (NewDacl){LocalFree( NewDacl );NewDacl = NULL;}
    if (NewAceDacl){LocalFree( NewAceDacl );NewAceDacl = NULL;}
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddUserAccessToSD end\n")));
    return bReturn;
}

DWORD SetRegistryKeySecurityAdmin(HKEY hkey, DWORD samDesired,PSECURITY_DESCRIPTOR* ppsdOld)
{
    PSID                     psid;
    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    DWORD                    dwError = ERROR_SUCCESS;

    // Get sid for the local Administrators group
    if (!AllocateAndInitializeSid(&sidAuth, 2,SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,0, 0, 0, 0, 0, 0, &psid) ) 
    {
        dwError = GetLastError();
    }

    if (ERROR_SUCCESS == dwError)
    {
        // Add all access privileges for the local administrators group
        dwError = SetAccessOnRegKey(hkey, psid, samDesired, CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE | INHERITED_ACE, ppsdOld);
    }

    return dwError;
}


DWORD SetRegistryKeySecurity(
    IN  HKEY                    hkeyRootKey,
    IN  LPCTSTR                 szKeyPath,
    IN  LPCTSTR                 szPrincipal,
    IN  DWORD                   dwAccessMask,
    IN  DWORD                   dwInheritMask,
    IN  BOOL                    bDoSubKeys,
    IN  LPTSTR                  szExclusiveList
)
{
    DWORD    dwStatus;
    HKEY     hkeyThisKey;
    DWORD    dwKeyIndex;
    DWORD    dwSubKeyLen;
    TCHAR    szSubKeyName[_MAX_PATH];
    FILETIME FileTime;
    TCHAR    *szExclusiveStart;
    BOOL     fSetSecurityRec;

    dwStatus = RegOpenKeyEx(hkeyRootKey,szKeyPath,0L,KEY_ALL_ACCESS,&hkeyThisKey);
    if (ERROR_SUCCESS == dwStatus)
    {
        PSID principalSID = NULL;
        BOOL bWellKnownSID = FALSE;
        if (ERROR_SUCCESS == GetPrincipalSID((LPTSTR) szPrincipal, &principalSID, &bWellKnownSID))
        {
            PSECURITY_DESCRIPTOR psd = NULL;
            SetAccessOnRegKey(hkeyThisKey,principalSID,dwAccessMask,dwInheritMask,&psd);
            if (psd) {free(psd);}
            if (bDoSubKeys)
            {
                dwKeyIndex = 0;
                dwSubKeyLen = sizeof(szSubKeyName) / sizeof(TCHAR);

                while (RegEnumKeyEx (hkeyThisKey,dwKeyIndex,szSubKeyName,&dwSubKeyLen,NULL,NULL,NULL,&FileTime) == ERROR_SUCCESS) 
                {
                    // subkey found so set subkey security
                    // attach on the inherited ace attribute since everything under this will be inherited
                    dwInheritMask |= INHERITED_ACE;

                    fSetSecurityRec = TRUE;

                    szExclusiveStart = szExclusiveList;
                    while ( szExclusiveStart != NULL )
                    {
                        szExclusiveStart = _tcsstr(szExclusiveStart,szSubKeyName);

                        // If we have found the substring, and the character after it is a NULL terminator or a ',', and
                        // it is at the begining of the string, or it had a , before it, then it is a match.
                        if ( ( szExclusiveStart != NULL ) &&
                             ( ( *(szExclusiveStart  + dwSubKeyLen) == '\0' ) || ( *(szExclusiveStart  + dwSubKeyLen) == ',' ) ) &&
                             ( ( szExclusiveStart == szExclusiveList) || (*(szExclusiveStart - 1) == ',') ) 
                             )
                        {
                            fSetSecurityRec = FALSE;
                            break;
                        }

                        // Increment to move past current search result
                        if (szExclusiveStart)
                        {
                            szExclusiveStart = szExclusiveStart + dwSubKeyLen;
                        }
                    }

                    if ( fSetSecurityRec )
                    {
                        dwStatus = SetRegistryKeySecurity(hkeyThisKey,szSubKeyName,szPrincipal,dwAccessMask,dwInheritMask,bDoSubKeys,szExclusiveList);
                    }

                    // set variables for next call
                    dwKeyIndex++;
                    dwSubKeyLen = sizeof(szSubKeyName) / sizeof(TCHAR);
                }
            }
        }
        RegCloseKey(hkeyThisKey);
    }
    return dwStatus;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\sources.inc ===
!include ..\..\..\place.inc
MAJORCOMP=setup
MINORCOMP=iis
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLENTRY=_DllMainCRTStartup
DLLBASE=0x3000000
DLLDEF = ..\iis.def
C_DEFINES=$(C_DEFINES) -DIIS60

PRECOMPILED_INCLUDE=stdafx.h
PRECOMPILED_CXX=1


INCLUDESBASE=$(IISBASEDIR)\inc; \
         $(IISBASEDIR)\inc\$(O); \
         $(NET_INC_PATH); \
         $(WINDOWS_INC_PATH); \
         $(DS_INC_PATH)

INCLUDES=$(INCLUDESBASE);\
        ..; \
        ..\..\..\inc; \
        ..\..\..\admin\ssltools; \
        ..\..\..\svcs\wp\inc

SOURCES= \
	..\dllmain.cpp \
        ..\ocpages.cpp \
        ..\setuputl.cpp \
        ..\shellutl.cpp \
	..\helper.cpp \
	..\other.cpp \
	..\initapp.cpp \
	..\dcomperm.cpp \
	..\svc.cpp \
	..\setuser.cpp \
	..\setpass.cpp \
	..\elem.cpp \
	..\mdkey.cpp \
	..\mdentry.cpp \
	..\mdacl.cpp \
	..\sysprep.cpp \
	..\www.cpp \
	..\ftp.cpp \
	..\registry.cpp \
	..\product.cpp \
        ..\browsedi.cpp \
	..\lsakeys.cpp \
	..\sslkeys.cpp \
	..\htmla.cpp \
	..\wolfpack.cpp \
	..\ipsec.cpp \
	..\kill.cpp \
	..\log.cpp \
	..\strfn.cpp\
	..\massupdt.cpp \
	..\itemlist.cpp \
	..\setup.rc

TARGETLIBS= \
        $(SDK_LIB_PATH)\setupapi.lib \
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib  \
        $(SDK_LIB_PATH)\user32.lib  \
        $(SDK_LIB_PATH)\comdlg32.lib \
        $(SDK_LIB_PATH)\comctl32.lib \
        $(SDK_LIB_PATH)\gdi32.lib \
        $(SDK_LIB_PATH)\ole32.lib \
        $(SDK_LIB_PATH)\oleaut32.lib \
        $(SDK_LIB_PATH)\version.lib \
        $(SDK_LIB_PATH)\lz32.lib \
        $(SDK_LIB_PATH)\netapi32.lib  \
        $(SDK_LIB_PATH)\wsock32.lib   \
        $(SDK_LIB_PATH)\loadperf.lib   \
        $(SDK_LIB_PATH)\shell32.lib   \
        $(SDK_LIB_PATH)\crypt32.lib    \
        $(SDK_LIB_PATH)\wbemuuid.lib \
        $(SDK_LIB_PATH)\clusapi.lib    \
        $(SDK_LIB_PATH)\resutils.lib    \
        $(IISBASEDIR)\lib\$(O)\iisrtl2.lib \
        $(DS_LIB_PATH)\rsa32.lib  \
        $(SDK_LIB_PATH)\samlib.lib          \
        $(SDK_LIB_PATH)\netlib.lib           \
        $(SDK_LIB_PATH)\schannel.lib\
        ..\..\..\svcs\infocomm\rdns\$(O)\isrdns.lib   \
        ..\..\..\admin\ssltools\$(O)\ssltools.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\shellutl.h ===
#include "stdafx.h"
void GetErrorMsg(int errCode, LPCTSTR szExtraMsg);
void MyLoadString(int nID, CString &csResult);
int MyMessageBox(HWND hWnd, LPCTSTR lpszTheMessage, UINT style);
int MyMessageBox(HWND hWnd, LPCTSTR lpszTheMessage, LPCTSTR lpszTheTitle, UINT style);
int MyMessageBox(HWND hWnd, CString csTheMessage, HRESULT iTheErrorCode, UINT style);
int MyMessageBox(HWND hWnd, UINT iTheMessage, UINT style);
int MyMessageBox(HWND hWnd, UINT iTheMessage, int iTheErrorCode, UINT style);
int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever, UINT style);
int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever, int iTheErrorCode, UINT style);
int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever1, LPCTSTR lpszTheFileNameOrWhatever2, int iTheErrorCode, UINT style);
int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever1, LPCTSTR lpszTheFileNameOrWhatever2, LPCTSTR lpszTheFileNameOrWhatever3,int iTheErrorCode, UINT style);
int MyMessageBoxArgs(HWND hWnd, TCHAR *pszfmt, ...);
HRESULT MySetLinkInfoTip(LPCTSTR lpszLink, LPCTSTR lpszDescription);
HRESULT MyQueryLink(LPCTSTR lpszLink, LPTSTR lpszProgram, LPTSTR lpszArgs, LPTSTR lpszDir, LPTSTR lpszIconPath, int *piIconIndex);
HRESULT MyCreateLink(LPCTSTR lpszProgram, LPCTSTR lpszArgs, LPCTSTR lpszLink, LPCTSTR lpszDir, LPCTSTR lpszIconPath, int iIconIndex, LPCTSTR lpszDescription);
BOOL MyDeleteLink(LPTSTR lpszShortcut);
void MyMoveLink(LPCTSTR lpszItemDesc, LPCTSTR lpszOldGroup, LPCTSTR lpszNewGroup);
void MyGetSendToPath(LPTSTR szPath);
void MyGetDeskTopPath(LPTSTR szPath);
void MyGetGroupPath(LPCTSTR szGroupName, LPTSTR szPath);
BOOL MyAddGroup(LPCTSTR szGroupName);
BOOL MyIsGroupEmpty(LPCTSTR szGroupName);
BOOL MyDeleteGroup(LPCTSTR szGroupName);
void MyAddSendToItem(LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir);
void MyDeleteLinkWildcard(TCHAR *szDir, TCHAR *szFileName);
void MyDeleteSendToItem(LPCTSTR szAppName);
void MyAddDeskTopItem(LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir, LPCTSTR szIconPath, int iIconIndex);
void MyDeleteDeskTopItem(LPCTSTR szAppName);
void MyAddItem(LPCTSTR szGroupName, LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir, LPCTSTR lpszIconPath);
void MyAddItemInfoTip(LPCTSTR szGroupName, LPCTSTR szAppName, LPCTSTR szDescription);
void MyDeleteItem(LPCTSTR szGroupName, LPCTSTR szAppName);
BOOL AddURLShortcutItem( LPCTSTR szGroupName, LPCTSTR szItemDesc, LPCTSTR szURL );
void DeleteFromGroup(LPCTSTR szGroupName, LPTSTR szApplicationExec);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\shellutl.cpp ===
#include "stdafx.h"
#include <ole2.h>
#include <shlobj.h>
#include <iis64.h>
#include "log.h"
#include "shellutl.h"

extern OCMANAGER_ROUTINES gHelperRoutines;

HRESULT MySetLinkInfoTip(LPCTSTR lpszLink, LPCTSTR lpszDescription)
{
    HRESULT hres;
    IShellLink* pShellLink;
    WIN32_FIND_DATA wfd;

    CoInitialize(NULL);

    hres = CoCreateInstance(   CLSID_ShellLink,NULL,CLSCTX_INPROC_SERVER,IID_IShellLink,(LPVOID*)&pShellLink);
    if (SUCCEEDED(hres))
    {
       IPersistFile* pPersistFile;
       hres = pShellLink->QueryInterface(IID_IPersistFile, (LPVOID*)&pPersistFile);
       if (SUCCEEDED(hres))
       {
          WCHAR wsz[_MAX_PATH];

          // Ensure that the string is WCHAR.
#if defined(UNICODE) || defined(_UNICODE)
          _tcscpy(wsz, lpszLink);
#else
          MultiByteToWideChar( CP_ACP, 0, lpszLink, -1, wsz, _MAX_PATH);
#endif
          hres = pPersistFile->Load(wsz, STGM_READ);
          if (SUCCEEDED(hres))
          {
              hres = pShellLink->Resolve(NULL, SLR_ANY_MATCH | SLR_NO_UI);
              if (SUCCEEDED(hres))
              {
                if (lpszDescription)
                    {
                    pShellLink->SetDescription(lpszDescription);
                    // Save the link by calling IPersistFile::Save.
                    hres = pPersistFile->Save(wsz, TRUE);
                    }
              }
              else
              {
                  iisDebugOut((LOG_TYPE_WARN, _T("MySetLinkInfoTip(): pShellLink->Resolve FAILED\n")));
              }
          }
          else
          {
              iisDebugOut((LOG_TYPE_WARN, _T("MySetLinkInfoTip(): pPersistFile->Load FAILED\n")));
          }
          pPersistFile->Release();
       }
       else
       {
           iisDebugOut((LOG_TYPE_WARN, _T("MySetLinkInfoTip(): QueryInterface FAILED\n")));
       }
       pShellLink->Release();
    }
    else
    {
        iisDebugOut((LOG_TYPE_WARN, _T("MySetLinkInfoTip(): CoCreateInstance FAILED\n")));
    }
    CoUninitialize();

    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MySetLinkInfoTip(): Link=%1!s!, Desc=%2!s!\n"), lpszLink, lpszDescription));
    return hres;
}


HRESULT MyQueryLink(LPCTSTR lpszLink, LPTSTR lpszProgram, LPTSTR lpszArgs, LPTSTR lpszDir, LPTSTR lpszIconPath, int *piIconIndex)
{
    HRESULT hres;
    IShellLink* pShellLink;
    WIN32_FIND_DATA wfd;

    CoInitialize(NULL);

    hres = CoCreateInstance(   CLSID_ShellLink,NULL,CLSCTX_INPROC_SERVER,IID_IShellLink,(LPVOID*)&pShellLink);
    if (SUCCEEDED(hres))
    {
       IPersistFile* pPersistFile;
       hres = pShellLink->QueryInterface(IID_IPersistFile, (LPVOID*)&pPersistFile);
       if (SUCCEEDED(hres))
       {
          WCHAR wsz[_MAX_PATH];

          // Ensure that the string is WCHAR.
#if defined(UNICODE) || defined(_UNICODE)
          _tcscpy(wsz, lpszLink);
#else
          MultiByteToWideChar( CP_ACP, 0, lpszLink, -1, wsz, _MAX_PATH);
#endif
          hres = pPersistFile->Load(wsz, STGM_READ);
          if (SUCCEEDED(hres))
          {
              hres = pShellLink->Resolve(NULL, SLR_ANY_MATCH | SLR_NO_UI);
              if (SUCCEEDED(hres))
              {
                   pShellLink->GetPath(lpszProgram, _MAX_PATH, (WIN32_FIND_DATA *)&wfd, SLGP_SHORTPATH);
                   pShellLink->GetArguments(lpszArgs, _MAX_PATH);
                   pShellLink->GetWorkingDirectory(lpszDir, _MAX_PATH);
                   pShellLink->GetIconLocation(lpszIconPath, _MAX_PATH, piIconIndex);
              }
              else
              {
                  iisDebugOut((LOG_TYPE_ERROR, _T("MyQueryLink(): pShellLink->Resolve FAILED\n")));
              }
          }
          else
          {
              iisDebugOut((LOG_TYPE_WARN, _T("MyQueryLink(): pPersistFile->Load FAILED\n")));
          }
          pPersistFile->Release();
       }
       else
       {
           iisDebugOut((LOG_TYPE_ERROR, _T("MyQueryLink(): QueryInterface FAILED\n")));
       }
       pShellLink->Release();
    }
    else
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MyQueryLink(): CoCreateInstance FAILED\n")));
    }
    CoUninitialize();
    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("MyQueryLink(): Program=%1!s!, Args=%2!s!, WorkDir=%3!s!, IconPath=%4!s!, IconIndex=%5!d!\n"), lpszProgram, lpszArgs, lpszDir, lpszIconPath, *piIconIndex));
    return hres;
}

HRESULT MyCreateLink(LPCTSTR lpszProgram, LPCTSTR lpszArgs, LPCTSTR lpszLink, LPCTSTR lpszDir, LPCTSTR lpszIconPath, int iIconIndex, LPCTSTR lpszDescription)
{
    HRESULT hres;
    IShellLink* pShellLink;

    CoInitialize(NULL);

    //CoInitialize must be called before this
    // Get a pointer to the IShellLink interface.
    hres = CoCreateInstance(   CLSID_ShellLink,NULL,CLSCTX_INPROC_SERVER,IID_IShellLink,(LPVOID*)&pShellLink);
    if (SUCCEEDED(hres))
    {
       IPersistFile* pPersistFile;

       // Set the path to the shortcut target, and add the description.
       pShellLink->SetPath(lpszProgram);
       pShellLink->SetArguments(lpszArgs);
       pShellLink->SetWorkingDirectory(lpszDir);
       pShellLink->SetIconLocation(lpszIconPath, iIconIndex);
       if (lpszDescription)
        {
           pShellLink->SetDescription(lpszDescription);
        }
       
       // Query IShellLink for the IPersistFile interface for saving the
       // shortcut in persistent storage.
       hres = pShellLink->QueryInterface(IID_IPersistFile, (LPVOID*)&pPersistFile);
       if (SUCCEEDED(hres))
       {
          WCHAR wsz[_MAX_PATH];

#if defined(UNICODE) || defined(_UNICODE)
          _tcscpy(wsz, lpszLink);
#else
          // Ensure that the string is WCHAR.
          MultiByteToWideChar( CP_ACP,0,lpszLink,-1,wsz,_MAX_PATH);
#endif

          // Save the link by calling IPersistFile::Save.
          hres = pPersistFile->Save(wsz, TRUE);
          if (!SUCCEEDED(hres))
          {
              iisDebugOut((LOG_TYPE_ERROR, _T("MyCreateLink(): pPersistFile->Save FAILED\n")));
          }

          pPersistFile->Release();
       }
       else
       {
           iisDebugOut((LOG_TYPE_ERROR, _T("MyCreateLink(): pShellLink->QueryInterface FAILED\n")));
       }
       pShellLink->Release();
    }
    else
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MyCreateLink(): CoCreateInstance FAILED\n")));
    }
    CoUninitialize();
    return hres;
}

BOOL MyDeleteLink(LPTSTR lpszShortcut)
{
    TCHAR  szFile[_MAX_PATH];
    SHFILEOPSTRUCT fos;

    ZeroMemory(szFile, sizeof(szFile));
    _tcscpy(szFile, lpszShortcut);

	iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("MyDeleteLink(): %s.\n"), szFile));

    if (IsFileExist(szFile))
    {
        ZeroMemory(&fos, sizeof(fos));
        fos.hwnd = NULL;
        fos.wFunc = FO_DELETE;
        fos.pFrom = szFile;
        fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;
        int iTemp = SHFileOperation(&fos);
        if (iTemp != 0)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("MyDeleteLink(): SHFileOperation FAILED\n")));
        }
    }

    return TRUE;
}

void MyMoveLink(LPCTSTR lpszItemDesc, LPCTSTR lpszOldGroup, LPCTSTR lpszNewGroup)
{
    TCHAR szOldLink[_MAX_PATH], szNewLink[_MAX_PATH];
    TCHAR szProgram[_MAX_PATH], szArgs[_MAX_PATH], szDir[_MAX_PATH], szIconPath[_MAX_PATH];
    int iIconIndex;

    MyGetGroupPath(lpszOldGroup, szOldLink);
    _tcscat(szOldLink, _T("\\"));
    _tcscat(szOldLink, lpszItemDesc);
    _tcscat(szOldLink, _T(".lnk"));

    MyGetGroupPath(lpszNewGroup, szNewLink);
    if (!IsFileExist(szNewLink))
        MyAddGroup(lpszNewGroup);
    _tcscat(szNewLink, _T("\\"));
    _tcscat(szNewLink, lpszItemDesc);
    _tcscat(szNewLink, _T(".lnk"));

    MyQueryLink(szOldLink, szProgram, szArgs, szDir, szIconPath, &iIconIndex);
    MyDeleteLink(szOldLink);
    MyCreateLink(szProgram, szArgs, szNewLink, szDir, szIconPath, iIconIndex, NULL);

    return;
}

void MyGetSendToPath(LPTSTR szPath)
{
    LPITEMIDLIST   pidlSendTo;
    HRESULT hRes = NOERROR;

    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("SendTo path=%1!s!\n"), szPath));

    hRes = SHGetSpecialFolderLocation(NULL, CSIDL_SENDTO, &pidlSendTo);
    if (hRes != NOERROR)
        {iisDebugOut((LOG_TYPE_ERROR, _T("MyGetSendToPath() SHGetSpecialFolderLocation (CSIDL_SENDTO) FAILED. hresult=0x%x\n"), hRes));}

    int iTemp = SHGetPathFromIDList(pidlSendTo, szPath);
    if (iTemp != TRUE)
        {iisDebugOut((LOG_TYPE_ERROR, _T("MyGetSendToPath() SHGetPathFromIDList FAILED\n")));}

    return;
}

void MyGetDeskTopPath(LPTSTR szPath)
{
    LPITEMIDLIST   pidlDeskTop;
    HRESULT hRes = NOERROR;

#ifndef _CHICAGO_
    hRes = SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, &pidlDeskTop);
#else
    hRes = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY, &pidlDeskTop);
#endif
    if (hRes != NOERROR)
        {iisDebugOut((LOG_TYPE_ERROR, _T("MyGetDeskTopPath() SHGetSpecialFolderLocation (CSIDL_COMMON_DESKTOPDIRECTORY) FAILED. hresult=0x%x\n"), hRes));}

    int iTemp = SHGetPathFromIDList(pidlDeskTop, szPath);
    if (iTemp != TRUE)
        {iisDebugOut((LOG_TYPE_ERROR, _T("MyGetDeskTopPath() SHGetPathFromIDList FAILED\n")));}

    return;
}

void MyGetGroupPath(LPCTSTR szGroupName, LPTSTR szPath)
{
    int            nLen = 0;
    LPITEMIDLIST   pidlPrograms;
    HRESULT hRes = NOERROR;

#ifndef _CHICAGO_
    hRes = SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, &pidlPrograms);
    if (hRes != NOERROR)
        {iisDebugOut((LOG_TYPE_ERROR, _T("MyGetGroupPath() SHGetSpecialFolderLocation (CSIDL_COMMON_PROGRAMS) FAILED. hresult=0x%x\n"), hRes));}
#else
    hRes = SHGetSpecialFolderLocation(NULL, CSIDL_PROGRAMS, &pidlPrograms);
    if (hRes != NOERROR)
        {iisDebugOut((LOG_TYPE_ERROR, _T("MyGetGroupPath() SHGetSpecialFolderLocation (CSIDL_PROGRAMS) FAILED. hresult=0x%x\n"), hRes));}
#endif
    int iTemp = SHGetPathFromIDList(pidlPrograms, szPath);
    if (iTemp != TRUE)
        {iisDebugOut((LOG_TYPE_ERROR, _T("MyGetGroupPath() SHGetPathFromIDList FAILED\n")));}

    nLen = _tcslen(szPath);
    if (szGroupName)
    {
        if (szPath[nLen-1] != _T('\\')){_tcscat(szPath, _T("\\"));}
        _tcscat(szPath, szGroupName);
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("MyGetGroupPath(%s). Returns %s.\n"), szGroupName, szPath));
    return;
}

BOOL MyAddGroup(LPCTSTR szGroupName)
{
    CString csPath;
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    csPath = szPath;
    if (CreateLayerDirectory(csPath) != TRUE)
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("MyAddGroup() CreateLayerDirectory FAILED\n")));
        }
    SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, szPath, 0);
    return TRUE;
}

BOOL MyIsGroupEmpty(LPCTSTR szGroupName)
{
    TCHAR             szPath[_MAX_PATH];
    TCHAR             szFile[_MAX_PATH];
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    BOOL              bFindFile = TRUE;
    BOOL              fReturn = TRUE;

    MyGetGroupPath(szGroupName, szPath);

    _tcscpy(szFile, szPath);
    _tcscat(szFile, _T("\\*.*"));

    hFind = FindFirstFile(szFile, &FindData);
    while((INVALID_HANDLE_VALUE != hFind) && bFindFile)
    {
       if(*(FindData.cFileName) != _T('.'))
       {
           fReturn = FALSE;
           break;
       }

       //find the next file
       bFindFile = FindNextFile(hFind, &FindData);
    }
    FindClose(hFind);

    return fReturn;
}

BOOL MyDeleteGroup(LPCTSTR szGroupName)
{
    BOOL fResult;
    TCHAR             szPath[_MAX_PATH];
    TCHAR             szFile[_MAX_PATH];
    SHFILEOPSTRUCT    fos;
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    BOOL              bFindFile = TRUE;

    MyGetGroupPath(szGroupName, szPath);

    //we can't remove a directory that is not empty, so we need to empty this one

    _tcscpy(szFile, szPath);
    _tcscat(szFile, _T("\\*.*"));

    ZeroMemory(&fos, sizeof(fos));
    fos.hwnd = NULL;
    fos.wFunc = FO_DELETE;
    fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;

    hFind = FindFirstFile(szFile, &FindData);
    while((INVALID_HANDLE_VALUE != hFind) && bFindFile)
    {
       if(*(FindData.cFileName) != _T('.'))
       {
          //copy the path and file name to our temp buffer
          memset( (PVOID)szFile, 0, sizeof(szFile));
          _tcscpy(szFile, szPath);
          _tcscat(szFile, _T("\\"));
          _tcscat(szFile, FindData.cFileName);
          //add a second NULL because SHFileOperation is looking for this
          _tcscat(szFile, _T("\0"));

          //delete the file
          fos.pFrom = szFile;
          int iTemp = SHFileOperation(&fos);
          if (iTemp != 0)
            {iisDebugOut((LOG_TYPE_ERROR, _T("MyDeleteGroup(): SHFileOperation FAILED\n")));}
       }

       //find the next file
       bFindFile = FindNextFile(hFind, &FindData);
    }
    FindClose(hFind);

    fResult = RemoveDirectory(szPath);
    if (fResult) 
    {
        SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, szPath, 0);
    }
    return(fResult);
}

void MyAddSendToItem(LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir)
{
    TCHAR szPath[_MAX_PATH];

    MyGetSendToPath(szPath);

    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szItemDesc);
    _tcscat(szPath, _T(".lnk"));

    MyCreateLink(szProgram, szArgs, szPath, szDir, NULL, 0, NULL);
}

void MyDeleteLinkWildcard(TCHAR *szDir, TCHAR *szFileName)
{
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szFileToBeDeleted[_MAX_PATH];

    _stprintf(szFileToBeDeleted, _T("%s\\%s"), szDir, szFileName);

    hFile = FindFirstFile(szFileToBeDeleted, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE) 
    {
        do {
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        // this is a directory, so let's skip it
                    }
                    else
                    {
                        // this is a file, so let's Delete it.
                        TCHAR szTempFileName[_MAX_PATH];
                        _stprintf(szTempFileName, _T("%s\\%s"), szDir, FindFileData.cFileName);
                        // set to normal attributes, so we can delete it
                        SetFileAttributes(szTempFileName, FILE_ATTRIBUTE_NORMAL);
                        // delete it, hopefully
                        InetDeleteFile(szTempFileName);
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) ) 
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }

    return;
}

void MyDeleteSendToItem(LPCTSTR szAppName)
{
    TCHAR szPath[_MAX_PATH];
    TCHAR szPath2[_MAX_PATH];

    /*
    MyGetSendToPath(szPath);
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szAppName);
    _tcscat(szPath, _T(".lnk"));
    MyDeleteLink(szPath);
    */

    MyGetSendToPath(szPath);
    _tcscpy(szPath2, szAppName);
    _tcscat(szPath2, _T(".lnk"));

    MyDeleteLinkWildcard(szPath, szPath2);
}

void MyAddDeskTopItem(LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir, LPCTSTR szIconPath, int iIconIndex)
{
    TCHAR szPath[_MAX_PATH];

    MyGetDeskTopPath(szPath);

    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szItemDesc);
    _tcscat(szPath, _T(".lnk"));

    MyCreateLink(szProgram, szArgs, szPath, szDir, szIconPath, iIconIndex, NULL);
}

HRESULT GetLNKProgramRunInfo(LPCTSTR lpszLink, LPTSTR lpszProgram)
{
    HRESULT hres;
    int iDoUninit = FALSE;
    IShellLink* pShellLink = NULL;
    WIN32_FIND_DATA wfd;

    if (SUCCEEDED(CoInitialize(NULL)))
        {iDoUninit = TRUE;}

    hres = CoCreateInstance(   CLSID_ShellLink,NULL,CLSCTX_INPROC_SERVER,IID_IShellLink,(LPVOID*)&pShellLink);
    if (SUCCEEDED(hres))
    {
       IPersistFile* pPersistFile = NULL;
       hres = pShellLink->QueryInterface(IID_IPersistFile, (LPVOID*)&pPersistFile);
       if (SUCCEEDED(hres))
       {
          WCHAR wsz[_MAX_PATH];

          // Ensure that the string is WCHAR.
#if defined(UNICODE) || defined(_UNICODE)
          _tcscpy(wsz, lpszLink);
#else
          MultiByteToWideChar( CP_ACP, 0, lpszLink, -1, wsz, _MAX_PATH);
#endif
          hres = pPersistFile->Load(wsz, STGM_READ);
          if (SUCCEEDED(hres))
          {
              hres = pShellLink->Resolve(NULL, SLR_ANY_MATCH | SLR_NO_UI);
              if (SUCCEEDED(hres))
              {
                   pShellLink->GetPath(lpszProgram, _MAX_PATH, (WIN32_FIND_DATA *)&wfd, SLGP_SHORTPATH);
              }
          }
          if (pPersistFile)
            {pPersistFile->Release();pPersistFile = NULL;}
       }
       if (pShellLink)
        {pShellLink->Release();pShellLink = NULL;}
    }

    if (TRUE == iDoUninit)
        {CoUninitialize();}
    return hres;
}

BOOL IsFileNameInDelimitedList(LPTSTR szCommaDelimList,LPTSTR szExeNameWithoutPath)
{
    BOOL bReturn = FALSE;
    TCHAR *token = NULL;
    TCHAR szCopyOfDataBecauseStrTokIsLame[_MAX_PATH];
    _tcscpy(szCopyOfDataBecauseStrTokIsLame,szCommaDelimList);

    // breakup the szCommaDelimList into strings and see if it contains the szExeNameWithoutPath string
    token = _tcstok(szCopyOfDataBecauseStrTokIsLame, _T(",;\t\n\r"));
    while(token != NULL)
	{
        // check if it matches our .exe name.
        if (0 == _tcsicmp(token,szExeNameWithoutPath))
        {
            return TRUE;
        }
	    // Get next token
	    token = _tcstok(NULL, _T(",;\t\n\r"));
    }

    return FALSE;
}


int LNKSearchAndDestroyRecursive(LPTSTR szDirToLookThru, LPTSTR szSemiColonDelmitedListOfExeNames, BOOL bDeleteItsDirToo)
{
    int iReturn = FALSE;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szFilePath[_MAX_PATH];
    TCHAR szFilename_ext_only[_MAX_EXT];

    DWORD retCode = GetFileAttributes(szDirToLookThru);

    if (retCode == 0xFFFFFFFF || !(retCode & FILE_ATTRIBUTE_DIRECTORY))
    {
            return FALSE;
    }
   
    _tcscpy(szFilePath, szDirToLookThru);
    AddPath(szFilePath, _T("*.*"));

    iisDebugOut((LOG_TYPE_TRACE, _T("LNKSearchAndDestroyRecursive:%s,%s,%d\n"),szDirToLookThru, szSemiColonDelmitedListOfExeNames, bDeleteItsDirToo));

    hFile = FindFirstFile(szFilePath, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE) 
    {
        do {
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        TCHAR szFullNewDirToLookInto[_MAX_EXT];
                        _tcscpy(szFullNewDirToLookInto, szDirToLookThru);
                        AddPath(szFullNewDirToLookInto,FindFileData.cFileName);

                        // this is a directory, so let's go into this
                        // directory recursively
                        LNKSearchAndDestroyRecursive(szFullNewDirToLookInto,szSemiColonDelmitedListOfExeNames,bDeleteItsDirToo);
                    }
                    else
                    {
                        // check if this file is a .lnk file
                        // if it is then let's open it and 
                        // see if it points to our .exe we're looking for...
                        
                        // get only the filename's extention
                        _tsplitpath( FindFileData.cFileName, NULL, NULL, NULL, szFilename_ext_only);

                        // check for .lnk
                        if (0 == _tcsicmp(szFilename_ext_only, _T(".lnk")))
                        {
                            TCHAR szFilename_only[_MAX_FNAME];
                            TCHAR szFullPathAndFilename[_MAX_PATH];
                            TCHAR szTemporaryString[_MAX_PATH];

                            // this is a .lnk,
                            // open it and check the .exe..
                            _tcscpy(szFullPathAndFilename,szDirToLookThru);
                            AddPath(szFullPathAndFilename,FindFileData.cFileName);
                            _tcscpy(szTemporaryString,_T(""));

                            if (SUCCEEDED(GetLNKProgramRunInfo(szFullPathAndFilename, szTemporaryString)))
                            {
                                _tsplitpath( szTemporaryString, NULL, NULL, szFilename_only, szFilename_ext_only);
                                _tcscpy(szTemporaryString, szFilename_only);
                                _tcscat(szTemporaryString, szFilename_ext_only);

                                //iisDebugOut((LOG_TYPE_TRACE, _T("open:%s,%s\n"),szFullPathAndFilename,szTemporaryString));

                                // see if it is on our list of comma delimited names...
                                if (TRUE == IsFileNameInDelimitedList(szSemiColonDelmitedListOfExeNames,szTemporaryString))
                                {
                                    SetFileAttributes(szFullPathAndFilename, FILE_ATTRIBUTE_NORMAL);
                                    // delete it, hopefully
                                    InetDeleteFile(szFullPathAndFilename);

                                    // DELETE the file that references this .exe
                                    if (bDeleteItsDirToo)
                                    {
                                        // Get it's dirname and delete that too...
                                        RecRemoveEmptyDir(szDirToLookThru);
                                    }

                                    iReturn = TRUE;
                                }
                             }
                        }
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) ) 
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }

    return iReturn;
}

void MyDeleteDeskTopItem(LPCTSTR szAppName)
{
    TCHAR szPath[_MAX_PATH];
    TCHAR szPath2[_MAX_PATH];

    /*
    MyGetDeskTopPath(szPath);
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szAppName);
    _tcscat(szPath, _T(".lnk"));
    //if this is an upgrade, then the directories could have changed.
    //see if we need to delete the old one...
    MyDeleteLink(szPath);
    */

    MyGetDeskTopPath(szPath);
    _tcscpy(szPath2, szAppName);
    _tcscat(szPath2, _T(".lnk"));

    MyDeleteLinkWildcard(szPath, szPath2);
}

void DeleteFromGroup(LPCTSTR szGroupName, LPTSTR szApplicationExec)
{
    TCHAR szPath[_MAX_PATH];

    // Get path to that group
    MyGetGroupPath(szGroupName, szPath);

    LNKSearchAndDestroyRecursive(szPath, szApplicationExec, FALSE);
}

// boydm -------------------------------------------------------------------------------------------
// Adds a web URL shortcut file . The URL is passed in and is put into the file in the form of a INI file.
BOOL AddURLShortcutItem( LPCTSTR szGroupName, LPCTSTR szItemDesc, LPCTSTR szURL )
{
    iisDebugOutSafeParams((LOG_TYPE_TRACE_WIN32_API, _T("AddURLShortcutItem(): %1!s!,%2!s!,%3!s!\n"), szGroupName, szItemDesc, szURL));
    // this first part of getting the paths is copied from MyAddItem below
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    if (!IsFileExist(szPath))
    {
        MyAddGroup(szGroupName);
    }
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szItemDesc);
    _tcscat(szPath, _T(".url"));

    // now use the private profile routines to easily create and fill in the content for the .url file
    return WritePrivateProfileString(
        _T("InternetShortcut"),        // pointer to section name
        _T("URL"),            // pointer to key name
        szURL,                          // pointer to string to add
        szPath                          // pointer to initialization filename
        );
}

void MyAddItem(LPCTSTR szGroupName, LPCTSTR szItemDesc, LPCTSTR szProgram, LPCTSTR szArgs, LPCTSTR szDir, LPCTSTR lpszIconPath)
{
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    if (!IsFileExist(szPath))
        MyAddGroup(szGroupName);

    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szItemDesc);
    _tcscat(szPath, _T(".lnk"));

    if (lpszIconPath && IsFileExist(lpszIconPath))
    {
        MyCreateLink(szProgram, szArgs, szPath, szDir, lpszIconPath, 0, NULL);
    }
    else
    {
        MyCreateLink(szProgram, szArgs, szPath, szDir, NULL, 0, NULL);
    }
}

void MyAddItemInfoTip(LPCTSTR szGroupName, LPCTSTR szAppName, LPCTSTR szDescription)
{
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szAppName);
    _tcscat(szPath, _T(".lnk"));

    MySetLinkInfoTip(szPath, szDescription);
}


void MyDeleteItem(LPCTSTR szGroupName, LPCTSTR szAppName)
{
    TCHAR szPath[_MAX_PATH];
    TCHAR szPath2[_MAX_PATH];

    /*
    MyGetGroupPath(szGroupName, szPath);
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szAppName);
    _tcscat(szPath, _T(".lnk"));
    MyDeleteLink(szPath);

    // try to remove items added by AddURLShortcutItem()
    MyGetGroupPath(szGroupName, szPath);
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath2, szAppName);
    _tcscat(szPath2, _T(".url"));
    MyDeleteLink(szPath);
    */

    MyGetGroupPath(szGroupName, szPath);
    _tcscpy(szPath2, szAppName);
    _tcscat(szPath2, _T(".lnk"));
    MyDeleteLinkWildcard(szPath, szPath2);

    MyGetGroupPath(szGroupName, szPath);
    _tcscpy(szPath2, szAppName);
    _tcscat(szPath2, _T(".url"));
    MyDeleteLinkWildcard(szPath, szPath2);

    if (MyIsGroupEmpty(szGroupName)) {MyDeleteGroup(szGroupName);}
}

//
// Used when the strings are passed in.
//
int MyMessageBox(HWND hWnd, LPCTSTR lpszTheMessage, UINT style)
{
    int iReturn = TRUE;
    CString csTitle;

    MyLoadString(IDS_IIS_ERROR_MSGBOXTITLE,csTitle);

    // call MyMessageBox which will log to the log file and 
    // check the global variable to see if we can even display the popup
    iReturn = MyMessageBox(hWnd, lpszTheMessage, csTitle, style | MB_SETFOREGROUND);
    return iReturn;
}

//
// Used when the strings are passed in.
//
int MyMessageBox(HWND hWnd, LPCTSTR lpszTheMessage, LPCTSTR lpszTheTitle, UINT style)
{
    int iReturn = IDOK;

    // make sure it goes to iisdebugoutput
    iisDebugOutSafeParams((LOG_TYPE_TRACE, _T("MyMessageBox: Title:%1!s!, Msg:%2!s!\n"), lpszTheTitle, lpszTheMessage));

    if (style & MB_ABORTRETRYIGNORE) 
    {
        iReturn = IDIGNORE;
    }
    
    // Check global variable to see if we can even display the popup!
    if (g_pTheApp->m_bAllowMessageBoxPopups)
    {
        // Suppress the message if unattened or remove all
        // Who cares the user can't do anything about it anyway?
        // no use upsetting them, we do log to the OCM though
        //
        if (! g_pTheApp->m_fUnattended || g_pTheApp->m_dwSetupMode != SETUPMODE_REMOVEALL)
        {
            iReturn = MessageBox(hWnd, lpszTheMessage, lpszTheTitle, style | MB_SETFOREGROUND);
        }
    }
    return iReturn;
}


//
// Used when the string and an error code passed in.
// 
int MyMessageBox(HWND hWnd, CString csTheMessage, HRESULT iTheErrorCode, UINT style)
{
    SetErrorFlag(__FILE__, __LINE__);

    int iReturn = TRUE;
    CString csMsg, csErrMsg;

    csMsg = csTheMessage;

    TCHAR pMsg[_MAX_PATH] = _T("");
    HRESULT nNetErr = (HRESULT) iTheErrorCode;
    DWORD dwFormatReturn = 0;
    dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
    if ( dwFormatReturn == 0) {
        if (nNetErr >= NERR_BASE) 
		{
            HMODULE hDll = (HMODULE)LoadLibrary(_T("netmsg.dll"));
            if (hDll) 
			{
                dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,hDll, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
                FreeLibrary(hDll);
            }
        }
    }

    HandleSpecificErrors(iTheErrorCode, dwFormatReturn, csMsg, pMsg, &csErrMsg);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, csErrMsg, style | MB_SETFOREGROUND);

	// Log the eror message to  OCM
    if (gHelperRoutines.OcManagerContext)
    {
	    if ( gHelperRoutines.ReportExternalError ) {gHelperRoutines.ReportExternalError(gHelperRoutines.OcManagerContext,_T("IIS"),NULL,(DWORD_PTR)(LPCTSTR)csErrMsg,ERRFLG_PREFORMATTED);}
    }

    return iReturn;
}



//
// Used when the String ID's are passed in.
// 
int MyMessageBox(HWND hWnd, UINT iTheMessage, UINT style)
{
    int iReturn = TRUE;
    CString csMsg;

    MyLoadString(iTheMessage,csMsg);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, csMsg, style | MB_SETFOREGROUND);

    return iReturn;
}

//
// Used when the String ID's are passed in.
// And the tthere is an error code which needs to get shown and
// 
int MyMessageBox(HWND hWnd, UINT iTheMessage, int iTheErrorCode, UINT style)
{
    SetErrorFlag(__FILE__, __LINE__);

    int iReturn = TRUE;
    CString csMsg, csErrMsg;

    MyLoadString(iTheMessage,csMsg);

    TCHAR pMsg[_MAX_PATH] = _T("");
    int nNetErr = (int)iTheErrorCode;
    DWORD dwFormatReturn = 0;
    dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
    if ( dwFormatReturn == 0) {
        if (nNetErr >= NERR_BASE) 
		{
            HMODULE hDll = (HMODULE)LoadLibrary(_T("netmsg.dll"));
            if (hDll) 
			{
                dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,hDll, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
                FreeLibrary(hDll);
            }
        }
    }

    HandleSpecificErrors(iTheErrorCode, dwFormatReturn, csMsg, pMsg, &csErrMsg);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, csErrMsg, style | MB_SETFOREGROUND);

	// Log the eror message to  OCM
    if (gHelperRoutines.OcManagerContext)
    {
	    if ( gHelperRoutines.ReportExternalError ) {gHelperRoutines.ReportExternalError(gHelperRoutines.OcManagerContext,_T("IIS"),NULL,(DWORD_PTR)(LPCTSTR)csErrMsg,ERRFLG_PREFORMATTED);}
    }

    return iReturn;
}


int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever, UINT style)
{
    int iReturn = TRUE;
    CString csMsgForSprintf, csMsg;

    // Get the iTheMessage from the resouce file
    // csMsgForSprintf should now look something like: "cannot find file %s".
    MyLoadString(iTheMessage,csMsgForSprintf);

    // now load the passed in filename or whatever.
    // csMsg should now look like: "cannot find file Whatever";
    csMsg.Format( csMsgForSprintf, lpszTheFileNameOrWhatever);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, csMsg, style | MB_SETFOREGROUND);

    return iReturn;
}


int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever, int iTheErrorCode, UINT style)
{
    SetErrorFlag(__FILE__, __LINE__);

    int iReturn = TRUE;
    CString csMsgForSprintf, csMsg, csErrMsg;

    // Get the iTheMessage from the resouce file
    // csMsgForSprintf should now look something like: "cannot find file %s".
    MyLoadString(iTheMessage,csMsgForSprintf);

    // now load the passed in filename or whatever.
    // csMsg should now look like: "cannot find file Whatever";
    csMsg.Format( csMsgForSprintf, lpszTheFileNameOrWhatever);

    TCHAR pMsg[_MAX_PATH] = _T("");
    int nNetErr = (int)iTheErrorCode;
    DWORD dwFormatReturn = 0;
    dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
    if ( dwFormatReturn == 0) {
        if (nNetErr >= NERR_BASE) 
		{
            HMODULE hDll = (HMODULE)LoadLibrary(_T("netmsg.dll"));
            if (hDll) 
			{
                dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,hDll, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
                FreeLibrary(hDll);
            }
        }
    }

    HandleSpecificErrors(iTheErrorCode, dwFormatReturn, csMsg, pMsg, &csErrMsg);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, csErrMsg, style | MB_SETFOREGROUND);

	// Log the eror message to  OCM
    if (gHelperRoutines.OcManagerContext)
    {
	    if ( gHelperRoutines.ReportExternalError ) {gHelperRoutines.ReportExternalError(gHelperRoutines.OcManagerContext,_T("IIS"),NULL,(DWORD_PTR)(LPCTSTR)csErrMsg,ERRFLG_PREFORMATTED);}
    }

    return iReturn;
}


int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever1, LPCTSTR lpszTheFileNameOrWhatever2, int iTheErrorCode, UINT style)
{
    SetErrorFlag(__FILE__, __LINE__);

    int iReturn = TRUE;
    CString csMsgForSprintf, csMsg, csErrMsg;

    // Get the iTheMessage from the resouce file
    // csMsgForSprintf should now look something like: "cannot find file %s %s".
    MyLoadString(iTheMessage,csMsgForSprintf);

    // now load the passed in filename or whatever.
    // csMsg should now look like: "cannot find file Whatever1 Whatever2";
    csMsg.Format( csMsgForSprintf, lpszTheFileNameOrWhatever1, lpszTheFileNameOrWhatever2);

    TCHAR pMsg[_MAX_PATH] = _T("");
    int nNetErr = (int)iTheErrorCode;
    DWORD dwFormatReturn = 0;
    dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
    if ( dwFormatReturn == 0) {
        if (nNetErr >= NERR_BASE) 
		{
            HMODULE hDll = (HMODULE)LoadLibrary(_T("netmsg.dll"));
            if (hDll) 
			{
                dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,hDll, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
                FreeLibrary(hDll);
            }
        }
    }

    HandleSpecificErrors(iTheErrorCode, dwFormatReturn, csMsg, pMsg, &csErrMsg);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, csErrMsg, style | MB_SETFOREGROUND);

	// Log the eror message to  OCM
    if (gHelperRoutines.OcManagerContext)
    {
	    if ( gHelperRoutines.ReportExternalError ) {gHelperRoutines.ReportExternalError(gHelperRoutines.OcManagerContext,_T("IIS"),NULL,(DWORD_PTR)(LPCTSTR)csErrMsg,ERRFLG_PREFORMATTED);}
    }

    return iReturn;
}

int MyMessageBox(HWND hWnd, UINT iTheMessage, LPCTSTR lpszTheFileNameOrWhatever1, LPCTSTR lpszTheFileNameOrWhatever2, LPCTSTR lpszTheFileNameOrWhatever3, int iTheErrorCode, UINT style)
{
    SetErrorFlag(__FILE__, __LINE__);

    int iReturn = TRUE;
    CString csMsgForSprintf, csMsg, csErrMsg;

    // Get the iTheMessage from the resouce file
    // csMsgForSprintf should now look something like: "cannot find file %s %s".
    MyLoadString(iTheMessage,csMsgForSprintf);

    // now load the passed in filename or whatever.
    // csMsg should now look like: "cannot find file Whatever1 Whatever2 Whatever3";
    csMsg.Format( csMsgForSprintf, lpszTheFileNameOrWhatever1, lpszTheFileNameOrWhatever2, lpszTheFileNameOrWhatever3);

    TCHAR pMsg[_MAX_PATH] = _T("");
    int nNetErr = (int)iTheErrorCode;
    DWORD dwFormatReturn = 0;
    dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
    if ( dwFormatReturn == 0) {
        if (nNetErr >= NERR_BASE) 
		{
            HMODULE hDll = (HMODULE)LoadLibrary(_T("netmsg.dll"));
            if (hDll) 
			{
                dwFormatReturn = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,hDll, iTheErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
                FreeLibrary(hDll);
            }
        }
    }

    HandleSpecificErrors(iTheErrorCode, dwFormatReturn, csMsg, pMsg, &csErrMsg);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, csErrMsg, style | MB_SETFOREGROUND);

	// Log the eror message to  OCM
    if (gHelperRoutines.OcManagerContext)
    {
	    if ( gHelperRoutines.ReportExternalError ) {gHelperRoutines.ReportExternalError(gHelperRoutines.OcManagerContext,_T("IIS"),NULL,(DWORD_PTR)(LPCTSTR)csErrMsg,ERRFLG_PREFORMATTED);}
    }

    return iReturn;
}


int MyMessageBoxArgs(HWND hWnd, TCHAR *pszfmt, ...)
{
    int iReturn = TRUE;
    TCHAR tszString[1000];
    va_list va;
    va_start(va, pszfmt);
    _vstprintf(tszString, pszfmt, va);
    va_end(va);

    // Call MyMessageBox which will add title bar and log to log file
    iReturn = MyMessageBox(hWnd, tszString, MB_OK | MB_SETFOREGROUND);

    return iReturn;
}


void GetErrorMsg(int errCode, LPCTSTR szExtraMsg)
{
    SetErrorFlag(__FILE__, __LINE__);

    TCHAR pMsg[_MAX_PATH];

    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,NULL, errCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),pMsg, _MAX_PATH, NULL);
    _tcscat(pMsg, szExtraMsg);
    MyMessageBox(NULL, pMsg, _T(""), MB_OK | MB_SETFOREGROUND);

    return;
}

void MyLoadString(int nID, CString &csResult)
{
    TCHAR buf[MAX_STR_LEN];

    if (LoadString((HINSTANCE) g_MyModuleHandle, nID, buf, MAX_STR_LEN))
        csResult = buf;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\setuser.cpp ===
#include "stdafx.h"
#include "svc.h"
#include "setuser.h"
#include "dcomperm.h"

#ifndef _CHICAGO_

int GetGuestUserName_SlowWay(LPWSTR lpGuestUsrName)
{
    LPWSTR ServerName = NULL; // default to local machine
    DWORD Level = 1; // to retrieve info of all local and global normal user accounts
    DWORD Index = 0;
    DWORD EntriesRequested = 5;
    DWORD PreferredMaxLength = 1024;
    DWORD ReturnedEntryCount = 0;
    PVOID SortedBuffer = NULL;
    NET_DISPLAY_USER *p = NULL;
    DWORD i=0;
    int err = 0;
    BOOL fStatus = TRUE;

    while (fStatus) 
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetQueryDisplayInformation().Start.")));
        err = NetQueryDisplayInformation(ServerName, Level, Index, EntriesRequested, PreferredMaxLength, &ReturnedEntryCount, &SortedBuffer);
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetQueryDisplayInformation().End.")));
        if (err == NERR_Success)
            fStatus = FALSE;
        if (err == NERR_Success || err == ERROR_MORE_DATA) 
        {
            p = (NET_DISPLAY_USER *)SortedBuffer;
            i = 0;
            while (i < ReturnedEntryCount && (p[i].usri1_user_id != DOMAIN_USER_RID_GUEST))
                i++;
            if (i == ReturnedEntryCount) 
            {
                if (err == ERROR_MORE_DATA) 
                { // need to get more entries
                    Index = p[i-1].usri1_next_index;
                }
            }
            else 
            {
                wcscpy(lpGuestUsrName, p[i].usri1_name);
                fStatus = FALSE;
            }
        }
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
        NetApiBufferFree(SortedBuffer);
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));
    }

    return 0;
}

int GetGuestGrpName(LPTSTR lpGuestGrpName)
{
    LPCTSTR ServerName = NULL; // local machine
    DWORD cbName = UNLEN+1;
    TCHAR ReferencedDomainName[200];
    DWORD cbReferencedDomainName = sizeof(ReferencedDomainName);
    SID_NAME_USE sidNameUse = SidTypeUser;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID GuestsSid = NULL;

    AllocateAndInitializeSid(&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_GUESTS,0,0,0,0,0,0, &GuestsSid);

    LookupAccountSid(ServerName, GuestsSid, lpGuestGrpName, &cbName, ReferencedDomainName, &cbReferencedDomainName, &sidNameUse);

    if (GuestsSid)
        FreeSid(GuestsSid);

    return 0;
}

void InitLsaString(PLSA_UNICODE_STRING LsaString,LPWSTR String)
{
    DWORD StringLength;
 
    if (String == NULL) 
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }
 
    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

DWORD OpenPolicy(LPTSTR ServerName,DWORD DesiredAccess,PLSA_HANDLE PolicyHandle)
{
    DWORD Error;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;

    QualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    QualityOfService.ImpersonationLevel = SecurityImpersonation;
    QualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QualityOfService.EffectiveOnly = FALSE;

    //
    // The two fields that must be set are length and the quality of service.
    //
    ObjectAttributes.Length = sizeof(LSA_OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = 0;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = &QualityOfService;

    if (ServerName != NULL)
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString,ServerName);
        Server = &ServerString;
    }
    //
    // Attempt to open the policy for all access
    //
    Error = LsaOpenPolicy(Server,&ObjectAttributes,DesiredAccess,PolicyHandle);
    return(Error);

}

INT RegisterAccountToLocalGroup(LPCTSTR szAccountName, LPCTSTR szLocalGroupName, BOOL fAction)
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("RegisterAccountToLocalGroup:Action=%d,Account=%s\n"), fAction, szAccountName));

    int err;

    // get the sid of szAccountName
    PSID pSID = NULL;
    BOOL bWellKnownSID = FALSE;
    err = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);
    if (err != ERROR_SUCCESS) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("RegisterAccountToLocalGroup:GetPrincipalSID:fAction=%d, Account=%s, Group=%s, err=%d.\n"), fAction, szAccountName, szLocalGroupName, err));
        return (err);
    }

    // Get the localized LocalGroupName
    TCHAR szLocalizedLocalGroupName[GNLEN + 1];
    if (_tcsicmp(szLocalGroupName, _T("Guests")) == 0) 
    {
        GetGuestGrpName(szLocalizedLocalGroupName);
    }
    else 
    {
        _tcscpy(szLocalizedLocalGroupName, szLocalGroupName);
    }
    
    // transfer szLocalGroupName to WCHAR
    WCHAR wszLocalGroupName[_MAX_PATH];
#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wszLocalGroupName, szLocalizedLocalGroupName);
#else
    MultiByteToWideChar( CP_ACP, 0, szLocalizedLocalGroupName, -1, wszLocalGroupName, _MAX_PATH);
#endif

    LOCALGROUP_MEMBERS_INFO_0 buf;

    buf.lgrmi0_sid = pSID;

    if (fAction) 
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetLocalGroupAddMembers().Start.")));
        err = NetLocalGroupAddMembers(NULL, wszLocalGroupName, 0, (LPBYTE)&buf, 1);
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetLocalGroupAddMembers().End.")));
    }
    else 
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetLocalGroupDelMembers().Start.")));
        err = NetLocalGroupDelMembers(NULL, wszLocalGroupName, 0, (LPBYTE)&buf, 1);
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetLocalGroupDelMembers().End.")));
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("RegisterAccountToLocalGroup:fAction=%d, Account=%s, Group=%s, err=%d.\n"), fAction, szAccountName, szLocalGroupName, err));

    if (pSID) 
    {
        if (bWellKnownSID)
            FreeSid (pSID);
        else
            free (pSID);
    }

    return (err);
}

INT RegisterAccountUserRights(LPCTSTR szAccountName, BOOL fAction, BOOL fSpecicaliwamaccount)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("RegisterAccountUserRights:Action=%d,Account=%s,iwam=%d\n"), fAction, szAccountName,fSpecicaliwamaccount));

    int err;

    // get the sid of szAccountName
    PSID pSID = NULL;
    BOOL bWellKnownSID = FALSE;
    err = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);
    if (err != ERROR_SUCCESS) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("RegisterAccountUserRights:GetPrincipalSID:fAction=%d, Account=%s, err=%d.\n"), fAction, szAccountName, err));
        return (err);
    }

    LSA_UNICODE_STRING UserRightString;
    LSA_HANDLE PolicyHandle = NULL;

    err = OpenPolicy(NULL, POLICY_ALL_ACCESS,&PolicyHandle);
    if ( err == NERR_Success )
    {
        if (fAction) 
        {
// defined in ntsecapi.h and ntlsa.h
//#define SE_INTERACTIVE_LOGON_NAME       TEXT("SeInteractiveLogonRight")
//#define SE_NETWORK_LOGON_NAME           TEXT("SeNetworkLogonRight")
//#define SE_BATCH_LOGON_NAME             TEXT("SeBatchLogonRight")
//#define SE_SERVICE_LOGON_NAME           TEXT("SeServiceLogonRight")
// Defined in winnt.h
//#define SE_CREATE_TOKEN_NAME              TEXT("SeCreateTokenPrivilege")
//#define SE_ASSIGNPRIMARYTOKEN_NAME        TEXT("SeAssignPrimaryTokenPrivilege")
//#define SE_LOCK_MEMORY_NAME               TEXT("SeLockMemoryPrivilege")
//#define SE_INCREASE_QUOTA_NAME            TEXT("SeIncreaseQuotaPrivilege")
//#define SE_UNSOLICITED_INPUT_NAME         TEXT("SeUnsolicitedInputPrivilege")
//#define SE_MACHINE_ACCOUNT_NAME           TEXT("SeMachineAccountPrivilege")
//#define SE_TCB_NAME                       TEXT("SeTcbPrivilege")
//#define SE_SECURITY_NAME                  TEXT("SeSecurityPrivilege")
//#define SE_TAKE_OWNERSHIP_NAME            TEXT("SeTakeOwnershipPrivilege")
//#define SE_LOAD_DRIVER_NAME               TEXT("SeLoadDriverPrivilege")
//#define SE_SYSTEM_PROFILE_NAME            TEXT("SeSystemProfilePrivilege")
//#define SE_SYSTEMTIME_NAME                TEXT("SeSystemtimePrivilege")
//#define SE_PROF_SINGLE_PROCESS_NAME       TEXT("SeProfileSingleProcessPrivilege")
//#define SE_INC_BASE_PRIORITY_NAME         TEXT("SeIncreaseBasePriorityPrivilege")
//#define SE_CREATE_PAGEFILE_NAME           TEXT("SeCreatePagefilePrivilege")
//#define SE_CREATE_PERMANENT_NAME          TEXT("SeCreatePermanentPrivilege")
//#define SE_BACKUP_NAME                    TEXT("SeBackupPrivilege")
//#define SE_RESTORE_NAME                   TEXT("SeRestorePrivilege")
//#define SE_SHUTDOWN_NAME                  TEXT("SeShutdownPrivilege")
//#define SE_DEBUG_NAME                     TEXT("SeDebugPrivilege")
//#define SE_AUDIT_NAME                     TEXT("SeAuditPrivilege")
//#define SE_SYSTEM_ENVIRONMENT_NAME        TEXT("SeSystemEnvironmentPrivilege")
//#define SE_CHANGE_NOTIFY_NAME             TEXT("SeChangeNotifyPrivilege")
//#define SE_REMOTE_SHUTDOWN_NAME           TEXT("SeRemoteShutdownPrivilege")
//#define SE_UNDOCK_NAME                    TEXT("SeUndockPrivilege")
//#define SE_SYNC_AGENT_NAME                TEXT("SeSyncAgentPrivilege")
//#define SE_ENABLE_DELEGATION_NAME         TEXT("SeEnableDelegationPrivilege")
            if (fSpecicaliwamaccount)
            {
                InitLsaString(&UserRightString, SE_NETWORK_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}

                // For NT5 -- the Iwam account will not have a ton of priveleges like was first decided.
                // for security reasons it was trimmed.
                InitLsaString(&UserRightString, SE_BATCH_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}

                // For NT51 (Whistler)
                // iwam should have additional rights, per bug277113 "SeAssignPrimaryTokenPrivilege","SeIncreaseQuotaPrivilege"
                InitLsaString(&UserRightString, SE_ASSIGNPRIMARYTOKEN_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}

                InitLsaString(&UserRightString, SE_INCREASE_QUOTA_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}


                /* Old stuff that was taken out post NT5 Beta3
                // Per Bug 291206 - IWAM account should not have the "log on locally" right, as it currently does
                // So make sure it is not there -- since this is a potential security hole!
                InitLsaString(&UserRightString, SE_INTERACTIVE_LOGON_NAME);
                err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                // stuff for nt5 Beta3
                InitLsaString(&UserRightString, SE_TCB_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                InitLsaString(&UserRightString, SE_CREATE_PAGEFILE_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                InitLsaString(&UserRightString, SE_CREATE_TOKEN_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                InitLsaString(&UserRightString, SE_CREATE_PERMANENT_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                InitLsaString(&UserRightString, SE_DEBUG_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                InitLsaString(&UserRightString, SE_AUDIT_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                InitLsaString(&UserRightString, SE_INCREASE_QUOTA_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                InitLsaString(&UserRightString, SE_INC_BASE_PRIORITY_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                InitLsaString(&UserRightString, SE_LOAD_DRIVER_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                InitLsaString(&UserRightString, SE_LOCK_MEMORY_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                InitLsaString(&UserRightString, SE_SYSTEM_ENVIRONMENT_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                InitLsaString(&UserRightString, SE_PROF_SINGLE_PROCESS_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                InitLsaString(&UserRightString, SE_ASSIGNPRIMARYTOKEN_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                */
            }
            else
            {
                InitLsaString(&UserRightString, SE_INTERACTIVE_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                InitLsaString(&UserRightString, SE_NETWORK_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
                InitLsaString(&UserRightString, SE_BATCH_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                if (err != STATUS_SUCCESS){iisDebugOut((LOG_TYPE_WARN, _T("RegisterAccountUserRights:LsaAddAccountRights FAILED. err=0x%x\n"), err));}
            }
        }
        else 
        {
            InitLsaString(&UserRightString, SE_INTERACTIVE_LOGON_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_NETWORK_LOGON_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_BATCH_LOGON_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_ASSIGNPRIMARYTOKEN_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_INCREASE_QUOTA_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);

            /* Old stuff that was taken out post NT5 Beta3
            // if special iwam account or not, let's remove these rights from the iusr or iwam user
            InitLsaString(&UserRightString, SE_TCB_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_CREATE_PAGEFILE_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_CREATE_TOKEN_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_CREATE_PERMANENT_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_DEBUG_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_AUDIT_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_INCREASE_QUOTA_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_INC_BASE_PRIORITY_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_LOAD_DRIVER_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_LOCK_MEMORY_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_SYSTEM_ENVIRONMENT_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_PROF_SINGLE_PROCESS_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_ASSIGNPRIMARYTOKEN_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            */
        }

        LsaClose(PolicyHandle);
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("RegisterAccountUserRights:Action=%d,Account=%s,iwam=%d,err=0x%x\n"), fAction, szAccountName,fSpecicaliwamaccount,err));
    }

    if (pSID) 
    {
        if (bWellKnownSID)
            FreeSid (pSID);
        else
            free (pSID);
    }

    if (err)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("RegisterAccountUserRights:Action=%d,Account=%s,iwam=%d,err=0x%x\n"), fAction, szAccountName,fSpecicaliwamaccount,err));
    }
    return (err);
}

BOOL IsUserExist( LPWSTR strUsername )
{
    BYTE *pBuffer;
    INT err = NERR_Success;
   
    do
    {
        WCHAR *pMachineName = NULL;

        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetServerGetInfo().Start.")));
        err = NetServerGetInfo( NULL, 101, &pBuffer );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetServerGetInfo().End.")));
        
        //  make sure we are not backup docmain first
        if (err != NERR_Success )
        {
            // if this call returns that the service is not running, then let's just assume that the user does exist!!!!
            if (err == NERR_ServerNotStarted)
            {
                // Try to start the server service.
                err = InetStartService(_T("LanmanServer"));
                if (err == 0 || err == ERROR_SERVICE_ALREADY_RUNNING)
                {
                    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetServerGetInfo().Start.")));
                    err = NetServerGetInfo( NULL, 101, &pBuffer );
                    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetServerGetInfo().End.")));
                    if (err != NERR_Success )
                    {
                        if (err == NERR_ServerNotStarted)
                        {
                            iisDebugOut((LOG_TYPE_WARN, _T("NetServerGetInfo:failed.The Server service is not started. assume that %s exists.err=0x%x.\n"),strUsername,err));
                            err = NERR_Success;
                        }
                    }
                }
                else
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("NetServerGetInfo:failed.The Server service is not started. assume that %s exists.err=0x%x.\n"),strUsername,err));
                    err = NERR_Success;
                }
            }
            else
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("NetServerGetInfo:failed.Do not call this on PDC or BDC takes too long.This must be a PDC or BDC.err=0x%x.\n"),err));
            }
            break;
        }

        LPSERVER_INFO_101 pInfo = (LPSERVER_INFO_101)pBuffer;
        if (( pInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL ) != 0 )
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetGetDCName().Start.")));
            NetGetDCName( NULL, NULL, (LPBYTE*)&pMachineName );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetGetDCName().End.")));
        }

        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
        NetApiBufferFree( pBuffer );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));

        if (pMachineName){iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NetUserGetInfo:[%s\\%s].Start.\n"),pMachineName,strUsername));}
        else{iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NetUserGetInfo:[(null)\\%s].Start.\n"),strUsername));}
       
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetUserGetInfo().Start.")));
        err = NetUserGetInfo( pMachineName, strUsername, 3, &pBuffer );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetUserGetInfo().End.")));

        if (pMachineName){iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NetUserGetInfo:[%s\\%s].End.Ret=0x%x.\n"),pMachineName,strUsername,err));}
        else{iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NetUserGetInfo:[(null)\\%s].End.\n"),strUsername));}

        if ( err == NERR_Success )
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
            NetApiBufferFree( pBuffer );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));
        }
        if ( pMachineName != NULL )
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
            NetApiBufferFree( pMachineName );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));
        }

    } while (FALSE);

    return(err == NERR_Success );
}


//
// Create InternetGuest Account
//
INT CreateUser( LPCTSTR szUsername, LPCTSTR szPassword, LPCTSTR szComment, LPCTSTR szFullName, BOOL fiWamUser,INT *NewlyCreated)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("CreateUser: %s\n"), szUsername));
    INT iTheUserAlreadyExists = FALSE;
    INT err = NERR_Success;

    INT iTheUserIsMissingARight = FALSE;

    BYTE *pBuffer;
    WCHAR defGuest[UNLEN+1];
    TCHAR defGuestGroup[GNLEN+1];
    WCHAR wchGuestGroup[GNLEN+1];
    WCHAR wchUsername[UNLEN+1];
    WCHAR wchPassword[LM20_PWLEN+1];
    WCHAR *pMachineName = NULL;

    *NewlyCreated = 0;
    
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestUserName:Start.\n")));
    GetGuestUserName(defGuest);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestUserName:End.\n")));

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestGrpName:Start.\n")));
    GetGuestGrpName(defGuestGroup);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestGrpName:End.\n")));

    iisDebugOut((LOG_TYPE_TRACE, _T("defGuest=%s, defGuestGroup=%s\n"), defGuest, defGuestGroup));

    memset((PVOID)wchUsername, 0, sizeof(wchUsername));
    memset((PVOID)wchPassword, 0, sizeof(wchPassword));
#if defined(UNICODE) || defined(_UNICODE)
    wcsncpy(wchGuestGroup, defGuestGroup, GNLEN);
    wcsncpy(wchUsername, szUsername, UNLEN);
    wcsncpy(wchPassword, szPassword, LM20_PWLEN);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)defGuestGroup, -1, (LPWSTR)wchGuestGroup, GNLEN);
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szUsername, -1, (LPWSTR)wchUsername, UNLEN);
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szPassword, -1, (LPWSTR)wchPassword, LM20_PWLEN);
#endif

    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserGetInfo:(%s) Start.\n"),defGuest));
    err = NetUserGetInfo( NULL, defGuest, 3, &pBuffer );
    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserGetInfo:(%s) End.Ret=0x%x.\n"),defGuest,err));

    if ( err == NERR_Success )
    {
        do
        {
            WCHAR wchComment[MAXCOMMENTSZ+1];
            WCHAR wchFullName[UNLEN+1];

            memset((PVOID)wchComment, 0, sizeof(wchComment));
            memset((PVOID)wchFullName, 0, sizeof(wchFullName));
#if defined(UNICODE) || defined(_UNICODE)
            wcsncpy(wchComment, szComment, MAXCOMMENTSZ);
            wcsncpy(wchFullName, szFullName, UNLEN);
#else
            MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szComment, -1, (LPWSTR)wchComment, MAXCOMMENTSZ);
            MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szFullName, -1, (LPWSTR)wchFullName, UNLEN);
#endif
            USER_INFO_3 *lpui3 = (USER_INFO_3 *)pBuffer;

            lpui3->usri3_name = wchUsername;
            lpui3->usri3_password = wchPassword;
            lpui3->usri3_flags &= ~ UF_ACCOUNTDISABLE;
            lpui3->usri3_flags |= UF_DONT_EXPIRE_PASSWD;
            lpui3->usri3_acct_expires = TIMEQ_FOREVER;

            lpui3->usri3_comment = wchComment;
            lpui3->usri3_usr_comment = wchComment;
            lpui3->usri3_full_name = wchFullName;
            lpui3->usri3_primary_group_id = DOMAIN_GROUP_RID_USERS;

            DWORD parm_err;

            iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserAdd():Start.\n")));
            err = NetUserAdd( NULL, 3, pBuffer, &parm_err );
            iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserAdd():End.Ret=0x%x.\n"),err));

            if ( err == NERR_NotPrimary )
            {
                // it is a backup dc
                iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGetDCName():Start.\n")));
                err = NetGetDCName( NULL, NULL, (LPBYTE *)&pMachineName );
                iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGetDCName():End.Ret=0x%x\n"),err));

                if (err != NERR_Success)
                {
                    MyMessageBox(NULL, _T("CreateUser:NetGetDCName"), err, MB_OK | MB_SETFOREGROUND);
                    break;
                }
                else 
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserAdd().Start.")));
                    err = NetUserAdd( pMachineName, 3, pBuffer, &parm_err );
                    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserAdd().End.")));
                }
            }
            else if ( err == NERR_UserExists )
            {
                iTheUserAlreadyExists = TRUE;
                iisDebugOut((LOG_TYPE_TRACE, _T("CreateUser:User Already exists. reusing.")));
                // see if we can just change the password.
                if (TRUE == ChangeUserPassword((LPTSTR) szUsername, (LPTSTR) szPassword))
                {
                    err = NERR_Success;
                }
            }

            if ( err != NERR_Success )
            {
                MyMessageBox(NULL, _T("CreateUser:NetUserAdd"), err, MB_OK | MB_SETFOREGROUND);
                break;
            }

        } while (FALSE);
        if ( pMachineName != NULL )
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
            NetApiBufferFree( pMachineName );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));
        }
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
        NetApiBufferFree( pBuffer );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));
    }
    if ( err == NERR_Success ) 
    {
        if (iTheUserAlreadyExists)
        {
            // if the user already exists, then
            // don't change any rights or the group that its in leave it alone.
            TCHAR PrivilegeName[256];
            iTheUserIsMissingARight = FALSE;

            //#define SE_INTERACTIVE_LOGON_NAME       TEXT("SeInteractiveLogonRight")
            //#define SE_NETWORK_LOGON_NAME           TEXT("SeNetworkLogonRight")
            //#define SE_BATCH_LOGON_NAME             TEXT("SeBatchLogonRight")
            _tcscpy(PrivilegeName, _T("SeNetworkLogonRight"));
            if (FALSE == DoesUserHaveThisRight(szUsername, PrivilegeName))
            {
                iTheUserIsMissingARight = TRUE;
            }
            else 
            {
                _tcscpy(PrivilegeName, _T("SeBatchLogonRight"));
                if (FALSE == DoesUserHaveThisRight(szUsername, PrivilegeName))
                {
                    iTheUserIsMissingARight = TRUE;
                }
                else
                {
                    if (fiWamUser)
                    {
                        // make sure the iwam user has these additional rights
                        // AssignPrimaryToken and IncreaseQuota privileges 
                        _tcscpy(PrivilegeName, _T("SeAssignPrimaryTokenPrivilege"));
                        if (FALSE == DoesUserHaveThisRight(szUsername, PrivilegeName))
                        {
                            iTheUserIsMissingARight = TRUE;
                        }
                        else
                        {
                            _tcscpy(PrivilegeName, _T("SeIncreaseQuotaPrivilege"));
                            if (FALSE == DoesUserHaveThisRight(szUsername, PrivilegeName))
                            {
                                iTheUserIsMissingARight = TRUE;
                            }
                        }
                    }
                    else
                    {
                        // make sure the iusr user has these additional rights
                        _tcscpy(PrivilegeName, _T("SeInteractiveLogonRight"));
                        if (FALSE == DoesUserHaveThisRight(szUsername, PrivilegeName))
                        {
                            iTheUserIsMissingARight = TRUE;
                        }
                    }
                }
            }

            

            // nope, we have to make sure that our iusr\iwam user has at least these
            // rights, because otherwise it won't work bug#361833
            if (iTheUserIsMissingARight == TRUE)
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("Missing user right[%s]:resetting it."),PrivilegeName));
                RegisterAccountUserRights(szUsername, TRUE, fiWamUser);
            }

            // if its the the iwam user, then make sure they are not part of the Guests Group by removing them
            if (fiWamUser)
            {
                RegisterAccountToLocalGroup(szUsername, _T("Guests"), FALSE);
            }

        }
        else
        {
            // User was successfully newly created
            *NewlyCreated = 1;

            // add it to the guests group
            // (but don't do it for the iwam user)
            if (!fiWamUser)
            {
                RegisterAccountToLocalGroup(szUsername, _T("Guests"), TRUE);
            }

            // add certain user rights to this account
            RegisterAccountUserRights(szUsername, TRUE, fiWamUser);
        }
    }

    if (TRUE == iTheUserAlreadyExists)
        {*NewlyCreated = 2;}

    return err;
}

INT DeleteGuestUser(LPCTSTR szUsername, INT *UserWasDeleted)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("DeleteGuestUser:%s\n"), szUsername));

    INT err = NERR_Success;
    BYTE *pBuffer;
    *UserWasDeleted = 0;

    WCHAR wchUsername[UNLEN+1];
#if defined(UNICODE) || defined(_UNICODE)
    wcsncpy(wchUsername, szUsername, UNLEN);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szUsername, -1, (LPWSTR)wchUsername, UNLEN);
#endif

    if (FALSE == IsUserExist(wchUsername)) 
    {
        *UserWasDeleted = 1;
        iisDebugOut((LOG_TYPE_TRACE, _T("DeleteGuestUser return. %s doesn't exist.\n"), szUsername));
        return err;
    }

    // remove it from the guests group
    RegisterAccountToLocalGroup(szUsername, _T("Guests"), FALSE);

    // remove certain user rights of this account
    RegisterAccountUserRights(szUsername, FALSE, TRUE);

    do
    {
        WCHAR *pMachine = NULL;

        //  make sure we are not backup docmain first
        iisDebugOut((LOG_TYPE_TRACE, _T("NetServerGetInfo:Start.\n")));
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetServerGetInfo().Start.")));
        err = NetServerGetInfo( NULL, 101, &pBuffer );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetServerGetInfo().End.")));
        if (err != NERR_Success )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("NetServerGetInfo:failed.err=0x%x.\n"),err));
            break;
        }
        iisDebugOut((LOG_TYPE_TRACE, _T("NetServerGetInfo:End.\n")));

        LPSERVER_INFO_101 pInfo = (LPSERVER_INFO_101)pBuffer;
        if (( pInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL ) != 0 )
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGetDCName():Start.\n")));
            NetGetDCName( NULL, NULL, (LPBYTE *)&pMachine);
            iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGetDCName():End.\n")));
        }

        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
        NetApiBufferFree( pBuffer );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));

        iisDebugOut((LOG_TYPE_TRACE, _T("NetUserDel:Start.\n")));
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetUserDel().Start.")));
        INT err = ::NetUserDel( pMachine, wchUsername );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetUserDel().End.")));
        iisDebugOut((LOG_TYPE_TRACE, _T("NetUserDel:End.Ret=0x%x.\n"),err));

        if (err == NERR_Success)
        {
            *UserWasDeleted = 1;
        }
        if ( pMachine != NULL )
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().Start.")));
            NetApiBufferFree( pMachine );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("NETAPI32.dll:NetApiBufferFree().End.")));
        }
    } while(FALSE);

    iisDebugOut((LOG_TYPE_TRACE, _T("DeleteGuestUser:%s. End. Return 0x%x\n"), szUsername, err));
    return err;
}

BOOL GuestAccEnabled()
{
    BOOL fEnabled = FALSE;
    INT err = NERR_Success;

    BYTE *pBuffer;
    WCHAR defGuest[UNLEN+1];
    
    GetGuestUserName(defGuest);

    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserGetInfo:Start.\n")));
    err = NetUserGetInfo( NULL, defGuest, 3, &pBuffer );
    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetUserGetInfo:End.Ret=0x%x.\n"),err));

    if ( err == NERR_Success )
    {
        USER_INFO_3 *lpui3 = (USER_INFO_3 *)pBuffer;
        fEnabled = ( lpui3->usri3_flags & UF_ACCOUNTDISABLE ) == 0;
    }
    return fEnabled;
    
}


NET_API_STATUS
NetpNtStatusToApiStatus (
    IN NTSTATUS NtStatus
    )

/*++

Routine Description:

    This function takes an NT status code and maps it to the appropriate
    LAN Man error code.

Arguments:

    NtStatus - Supplies the NT status.

Return Value:

    Returns the appropriate LAN Man error code for the NT status.

--*/
{
    NET_API_STATUS error;

    //
    // A small optimization for the most common case.
    //
    if ( NtStatus == STATUS_SUCCESS ) {
        return NERR_Success;
    }


    switch ( NtStatus ) {

        case STATUS_BUFFER_TOO_SMALL :
            return NERR_BufTooSmall;

        case STATUS_FILES_OPEN :
            return NERR_OpenFiles;

        case STATUS_CONNECTION_IN_USE :
            return NERR_DevInUse;

        case STATUS_INVALID_LOGON_HOURS :
            return NERR_InvalidLogonHours;

        case STATUS_INVALID_WORKSTATION :
            return NERR_InvalidWorkstation;

        case STATUS_PASSWORD_EXPIRED :
            return NERR_PasswordExpired;

        case STATUS_ACCOUNT_EXPIRED :
            return NERR_AccountExpired;

        case STATUS_REDIRECTOR_NOT_STARTED :
            return NERR_NetNotStarted;

        case STATUS_GROUP_EXISTS:
                return NERR_GroupExists;

        case STATUS_INTERNAL_DB_CORRUPTION:
                return NERR_InvalidDatabase;

        case STATUS_INVALID_ACCOUNT_NAME:
                return NERR_BadUsername;

        case STATUS_INVALID_DOMAIN_ROLE:
        case STATUS_INVALID_SERVER_STATE:
        case STATUS_BACKUP_CONTROLLER:
                return NERR_NotPrimary;

        case STATUS_INVALID_DOMAIN_STATE:
                return NERR_ACFNotLoaded;

        case STATUS_MEMBER_IN_GROUP:
                return NERR_UserInGroup;

        case STATUS_MEMBER_NOT_IN_GROUP:
                return NERR_UserNotInGroup;

        case STATUS_NONE_MAPPED:
        case STATUS_NO_SUCH_GROUP:
                return NERR_GroupNotFound;

        case STATUS_SPECIAL_GROUP:
        case STATUS_MEMBERS_PRIMARY_GROUP:
                return NERR_SpeGroupOp;

        case STATUS_USER_EXISTS:
                return NERR_UserExists;

        case STATUS_NO_SUCH_USER:
                return NERR_UserNotFound;

        case STATUS_PRIVILEGE_NOT_HELD:
                return ERROR_ACCESS_DENIED;

        case STATUS_LOGON_SERVER_CONFLICT:
                return NERR_LogonServerConflict;

        case STATUS_TIME_DIFFERENCE_AT_DC:
                return NERR_TimeDiffAtDC;

        case STATUS_SYNCHRONIZATION_REQUIRED:
                return NERR_SyncRequired;

        case STATUS_WRONG_PASSWORD_CORE:
                return NERR_BadPasswordCore;

        case STATUS_DOMAIN_CONTROLLER_NOT_FOUND:
                return NERR_DCNotFound;

        case STATUS_PASSWORD_RESTRICTION:
                return NERR_PasswordTooShort;

        case STATUS_ALREADY_DISCONNECTED:
                return NERR_Success;

        default:

            //
            // Use the system routine to do the mapping to ERROR_ codes.
            //

#ifndef WIN32_CHICAGO
            error = RtlNtStatusToDosError( NtStatus );

            if ( error != (NET_API_STATUS)NtStatus ) {
                return error;
            }
#endif // WIN32_CHICAGO

            //
            // Could not map the NT status to anything appropriate.
            // Write this to the eventlog file
            //

            return NERR_InternalError;
    }
} // NetpNtStatusToApiStatus


NET_API_STATUS
UaspGetDomainId(
    IN LPCWSTR ServerName OPTIONAL,
    OUT PSAM_HANDLE SamServerHandle OPTIONAL,
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO * AccountDomainInfo
    )
/*++
Routine Description:
    Return a domain ID of the account domain of a server.
Arguments:
    ServerName - A pointer to a string containing the name of the
        Domain Controller (DC) to query.  A NULL pointer
        or string specifies the local machine.
    SamServerHandle - Returns the SAM connection handle if the caller wants it.
    DomainId - Receives a pointer to the domain ID.
        Caller must deallocate buffer using NetpMemoryFree.
Return Value:
    Error code for the operation.
--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    SAM_HANDLE LocalSamHandle = NULL;

    ACCESS_MASK LSADesiredAccess;
    LSA_HANDLE  LSAPolicyHandle = NULL;
    OBJECT_ATTRIBUTES LSAObjectAttributes;

    UNICODE_STRING ServerNameString;


    //
    // Connect to the SAM server
    //
    RtlInitUnicodeString( &ServerNameString, ServerName );

    Status = SamConnect(
                &ServerNameString,
                &LocalSamHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                NULL);

    if ( !NT_SUCCESS(Status)) 
    {
        LocalSamHandle = NULL;
        NetStatus = NetpNtStatusToApiStatus( Status );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("UaspGetDomainId: Cannot connect to Sam. err=0x%x\n"),NetStatus));
        goto Cleanup;
    }


    //
    // Open LSA to read account domain info.
    //
    
    if ( AccountDomainInfo != NULL) {
        //
        // set desired access mask.
        //
        LSADesiredAccess = POLICY_VIEW_LOCAL_INFORMATION;

        InitializeObjectAttributes( &LSAObjectAttributes,
                                      NULL,             // Name
                                      0,                // Attributes
                                      NULL,             // Root
                                      NULL );           // Security Descriptor

        Status = LsaOpenPolicy( &ServerNameString,
                                &LSAObjectAttributes,
                                LSADesiredAccess,
                                &LSAPolicyHandle );

        if( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("UaspGetDomainId: Cannot open LSA Policy %lX\n"),NetStatus));
            goto Cleanup;
        }


        //
        // now read account domain info from LSA.
        //

        Status = LsaQueryInformationPolicy(
                        LSAPolicyHandle,
                        PolicyAccountDomainInformation,
                        (PVOID *) AccountDomainInfo );

        if( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("UaspGetDomainId: Cannot read LSA.Err=0x%x.\n"),NetStatus));
            goto Cleanup;
        }
    }

    //
    // Return the SAM connection handle to the caller if he wants it.
    // Otherwise, disconnect from SAM.
    //

    if ( ARGUMENT_PRESENT( SamServerHandle ) ) {
        *SamServerHandle = LocalSamHandle;
        LocalSamHandle = NULL;
    }

    NetStatus = NERR_Success;

    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( LocalSamHandle != NULL ) {
        (VOID) SamCloseHandle( LocalSamHandle );
    }

    if( LSAPolicyHandle != NULL ) {
        LsaClose( LSAPolicyHandle );
    }

    return NetStatus;
} // UaspGetDomainId


NET_API_STATUS
SampCreateFullSid(
    IN PSID DomainSid,
    IN ULONG Rid,
    OUT PSID *AccountSid
    )
/*++
Routine Description:
    This function creates a domain account sid given a domain sid and
    the relative id of the account within the domain.
    The returned Sid may be freed with LocalFree.
--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS    IgnoreStatus;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;
    PULONG      RidLocation;

    //
    // Calculate the size of the new sid
    //
    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(DomainSid) + (UCHAR)1;
    AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);

    //
    // Allocate space for the account sid
    //
    *AccountSid = LocalAlloc(LMEM_ZEROINIT,AccountSidLength);
    if (*AccountSid == NULL) 
    {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
    }
    else 
    {
        //
        // Copy the domain sid into the first part of the account sid
        //
        IgnoreStatus = RtlCopySid(AccountSidLength, *AccountSid, DomainSid);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Increment the account sid sub-authority count
        //
        *RtlSubAuthorityCountSid(*AccountSid) = AccountSubAuthorityCount;

        //
        // Add the rid as the final sub-authority
        //
        RidLocation = RtlSubAuthoritySid(*AccountSid, AccountSubAuthorityCount-1);
        *RidLocation = Rid;

        //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AccountSid=0x%x"),*AccountSid));

        NetStatus = NERR_Success;
    }

    return(NetStatus);
}



int GetGuestUserNameForDomain_FastWay(LPTSTR szDomainToLookUp,LPTSTR lpGuestUsrName)
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestUserNameForDomain_FastWay.start.domain=%s\n"),szDomainToLookUp));
    int iReturn = FALSE;
    NET_API_STATUS NetStatus;

    // for UaspGetDomainId()
    SAM_HANDLE SamServerHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo;

    PSID pAccountSid = NULL;
    PSID pDomainSid = NULL;

    // for LookupAccountSid()
    SID_NAME_USE sidNameUse = SidTypeUser;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    TCHAR szUserName[UNLEN+1];
    DWORD cbName = UNLEN+1;
    // must be big enough to hold something bigger than DNLen since LookupAccountSid may returnn something really big.
    TCHAR szReferencedDomainName[200];
    DWORD cbReferencedDomainName = sizeof(szReferencedDomainName);

    ASSERT(lpGuestUsrName);

    // make sure not to return back gobble-d-gook
    _tcscpy(lpGuestUsrName, _T(""));

    //
    // Get the Sid for the specified Domain
    //
    // szDomainToLookUp=NULL for local machine
    NetStatus = UaspGetDomainId( szDomainToLookUp,&SamServerHandle,&pAccountDomainInfo );
    if ( NetStatus != NERR_Success ) 
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestUserNameForDomain:UaspGetDomainId failed.ret=0x%x."),NetStatus));
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }
    pDomainSid = pAccountDomainInfo->DomainSid;
    //
    // Use the Domain Sid and the well known Guest RID to create the Real Guest Sid
    //
    // Well-known users ...
    // DOMAIN_USER_RID_ADMIN          (0x000001F4L)
    // DOMAIN_USER_RID_GUEST          (0x000001F5L)
    NetStatus = NERR_InternalError;
    NetStatus = SampCreateFullSid(pDomainSid, DOMAIN_USER_RID_GUEST, &pAccountSid);
    if ( NetStatus != NERR_Success ) 
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestUserNameForDomain:SampCreateFullSid failed.ret=0x%x."),NetStatus));
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }

    //
    // Check if the SID is valid
    //
    if (0 == IsValidSid(pAccountSid))
    {
        DWORD dwErr = GetLastError();
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestUserNameForDomain:IsValidSid FAILED.  GetLastError()= 0x%x\n"), dwErr));
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }

    //
    // Retrieve the UserName for the specified SID
    //
    _tcscpy(szUserName, _T(""));
    _tcscpy(szReferencedDomainName, _T(""));
    // szDomainToLookUp=NULL for local machine
    if (!LookupAccountSid(szDomainToLookUp, pAccountSid, szUserName, &cbName, szReferencedDomainName, &cbReferencedDomainName, &sidNameUse))
    {
        DWORD dwErr = GetLastError();
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("GetGuestUserNameForDomain:LookupAccountSid FAILED.  GetLastError()= 0x%x\n"), dwErr));
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }

    //iisDebugOut((LOG_TYPE_TRACE, _T("GetGuestUserNameForDomain:szDomainToLookUp=%s\n"),szDomainToLookUp));
    //iisDebugOut((LOG_TYPE_TRACE, _T("GetGuestUserNameForDomain:pAccountSid=0x%x\n"),pAccountSid));
    //iisDebugOut((LOG_TYPE_TRACE, _T("GetGuestUserNameForDomain:szUserName=%s\n"),szUserName));
    //iisDebugOut((LOG_TYPE_TRACE, _T("GetGuestUserNameForDomain:szReferencedDomainName=%s\n"),szReferencedDomainName));

    // Return the guest user name that we got.
    _tcscpy(lpGuestUsrName, szUserName);

    // Wow, after all that, we must have succeeded
    iReturn = TRUE;

GetGuestUserNameForDomain_FastWay_Exit:
    // Free the Domain info if we got some
    if (pAccountDomainInfo) {NetpMemoryFree(pAccountDomainInfo);}
    // Free the sid if we had allocated one
    if (pAccountSid) {LocalFree(pAccountSid);}
    iisDebugOut((LOG_TYPE_TRACE, _T("GetGuestUserNameForDomain_FastWay.end.domain=%s.ret=%d.\n"),szDomainToLookUp,iReturn));
    return iReturn;
}


void GetGuestUserName(LPTSTR lpOutGuestUsrName)
{
    // try to retrieve the guest username the fast way
    // meaning = lookup the domain sid, and the well known guest rid, to get the guest sid.
    // then look it up.  The reason for this function is that on large domains with mega users
    // the account can be quickly looked up.
    TCHAR szGuestUsrName[UNLEN+1];
    LPTSTR pszComputerName = NULL;
    if (!GetGuestUserNameForDomain_FastWay(pszComputerName,szGuestUsrName))
    {
        iisDebugOut((LOG_TYPE_WARN, _T("GetGuestUserNameForDomain_FastWay:Did not succeed use slow way. WARNING.")));

        // if the fast way failed for some reason, then let's do it
        // the slow way, since this way always used to work, only on large domains (1 mil users) 
        // it could take 24hrs (since this function actually enumerates thru the domain)
        GetGuestUserName_SlowWay(szGuestUsrName);
    }

    // Return back the username
    _tcscpy(lpOutGuestUsrName,szGuestUsrName);

    return;
}


int ChangeUserPassword(IN LPTSTR szUserName, IN LPTSTR szNewPassword)
{
    int iReturn = TRUE;
    USER_INFO_1003  pi1003; 
    NET_API_STATUS  nas; 

    TCHAR szRawComputerName[CNLEN + 10];
    DWORD dwLen = CNLEN + 10;
    TCHAR szComputerName[CNLEN + 10];
    TCHAR szCopyOfUserName[UNLEN+10];
    TCHAR szTempFullUserName[(CNLEN + 10) + (DNLEN+1)];
    LPTSTR pch = NULL;

    _tcscpy(szCopyOfUserName, szUserName);

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeUserPassword().Start.name=%s,pass=%s"),szCopyOfUserName,szNewPassword));
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeUserPassword().Start.name=%s"),szCopyOfUserName));

    if ( !GetComputerName( szRawComputerName, &dwLen ))
        {goto ChangeUserPassword_Exit;}

    // Make a copy to be sure not to move the pointer around.
    _tcscpy(szTempFullUserName, szCopyOfUserName);
    // Check if there is a "\" in there.
    pch = _tcschr(szTempFullUserName, _T('\\'));
    if (pch) 
        {
            // szCopyOfUserName should now go from something like this:
            // mycomputer\myuser
            // to this myuser
            _tcscpy(szCopyOfUserName,pch+1);
            // trim off the '\' character to leave just the domain\computername so we can check against it.
            *pch = _T('\0');
            // compare the szTempFullUserName with the local computername.
            if (0 == _tcsicmp(szRawComputerName, szTempFullUserName))
            {
                // the computername\username has a hardcoded computername in it.
                // lets try to get only the username
                // look szCopyOfusername is already set
            }
            else
            {
                // the local computer machine name
                // and the specified username are different, so get out
                // and don't even try to change this user\password since
                // it's probably a domain\username

                // return true -- saying that we did in fact change the passoword.
                // we really didn't but we can't
                iReturn = TRUE;
                goto ChangeUserPassword_Exit;
            }
        }


    // Make sure the computername has a \\ in front of it
    if ( szRawComputerName[0] != _T('\\') )
        {_tcscpy(szComputerName,_T("\\\\"));}
    _tcscat(szComputerName,szRawComputerName);
    // 
    // administrative over-ride of existing password 
    // 
    // by this time szCopyOfUserName
    // should not look like mycomputername\username but it should look like username.
    pi1003.usri1003_password = szNewPassword;
     nas = NetUserSetInfo(
            szComputerName,   // computer name 
            szCopyOfUserName, // username 
            1003,             // info level 
            (LPBYTE)&pi1003,  // new info 
            NULL 
            ); 

    if(nas != NERR_Success) 
    {
        iReturn = FALSE;
        goto ChangeUserPassword_Exit;
    }

ChangeUserPassword_Exit:
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeUserPassword().End.Ret=%d"),iReturn));
    return iReturn; 
} 


BOOL DoesUserHaveThisRight(LPCTSTR szAccountName, LPTSTR PrivilegeName)
{
    iisDebugOut((LOG_TYPE_TRACE, _T("DoesUserHaveBasicRights:Account=%s\n"), szAccountName));
    int err;
    BOOL fEnabled = FALSE;
    NTSTATUS status;

	LSA_UNICODE_STRING UserRightString;
    // Create a LSA_UNICODE_STRING for the privilege name.
    InitLsaString(&UserRightString, PrivilegeName);

    // get the sid of szAccountName
    PSID pSID = NULL;
    BOOL bWellKnownSID = FALSE;
    err = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);
    if (err != ERROR_SUCCESS) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("DoesUserHaveBasicRights:GetPrincipalSID:Account=%s, err=%d.\n"), szAccountName, err));
        return (err);
    }

    LSA_HANDLE PolicyHandle = NULL;

    err = OpenPolicy(NULL, POLICY_ALL_ACCESS,&PolicyHandle);
    if ( err == NERR_Success )
    {
		UINT i;
        LSA_UNICODE_STRING *rgUserRights = NULL;
		ULONG cRights;
	
		status = LsaEnumerateAccountRights(
				 PolicyHandle,
				 pSID,
				 &rgUserRights,
				 &cRights);

		if (status==STATUS_OBJECT_NAME_NOT_FOUND)
        {
			// no rights/privileges for this account
			fEnabled = FALSE;
		}
		else if (!NT_SUCCESS(status)) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("DoesUserHaveBasicRights:GetPrincipalSID:Failed to enumerate rights: status 0x%08lx\n"), status));
			goto DoesUserHaveBasicRights_Exit;
		}

		for(i=0; i < cRights; i++) 
        {
            if ( RtlEqualUnicodeString(&rgUserRights[i],&UserRightString,FALSE) ) 
            {
                fEnabled = TRUE;
                break;
            }
		}
		
        if (rgUserRights) {LsaFreeMemory(rgUserRights);}
    }

DoesUserHaveBasicRights_Exit:
    if (PolicyHandle){LsaClose(PolicyHandle);}
    if (pSID) 
    {
        if (bWellKnownSID){FreeSid (pSID);}
        else{free (pSID);}
    }
    return (fEnabled);
}



HRESULT CreateGroup(LPTSTR szGroupName, LPCTSTR szGroupComment, int iAction)
{
    HRESULT           hr = S_OK;
    NET_API_STATUS    dwRes;
    LOCALGROUP_INFO_1 MyLocalGroup;

    WCHAR wszLocalGroupName[_MAX_PATH];
    WCHAR wszLocalGroupComment[_MAX_PATH];

    memset(&MyLocalGroup, 0, sizeof(MyLocalGroup));

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wszLocalGroupName, szGroupName);
    _tcscpy(wszLocalGroupComment, szGroupComment);
#else
    MultiByteToWideChar( CP_ACP, 0, szGroupName, -1, wszLocalGroupName, _MAX_PATH);
    MultiByteToWideChar( CP_ACP, 0, szGroupComment, -1, wszLocalGroupComment, _MAX_PATH);
#endif

    MyLocalGroup.lgrpi1_name    = (LPWSTR)szGroupName;
    MyLocalGroup.lgrpi1_comment = (LPWSTR)szGroupComment;

    if (iAction)
    {
      dwRes = ::NetLocalGroupAdd( NULL, 1, (LPBYTE)&MyLocalGroup, NULL );
      if(dwRes != NERR_Success       &&
         dwRes != NERR_GroupExists   &&
         dwRes != ERROR_ALIAS_EXISTS  )
      {
          hr = HRESULT_FROM_WIN32(dwRes);
      }
    }
    else
    {
      dwRes = ::NetLocalGroupDel( NULL, wszLocalGroupName);
      if(dwRes != NERR_Success       &&
         dwRes != NERR_GroupNotFound   &&
         dwRes != ERROR_NO_SUCH_ALIAS   )
      {
          hr = HRESULT_FROM_WIN32(dwRes);
      }

    }

    return hr;
}


int CreateGroupDC(LPTSTR szGroupName, LPCTSTR szGroupComment)
{
    int iReturn = FALSE;
    GROUP_INFO_1 GI1;
    ULONG   BadParm;
    WCHAR * pMachineName = NULL;
    ULONG   ulErr = ERROR_SUCCESS;
    WCHAR wszLocalGroupName[_MAX_PATH];
    WCHAR wszLocalGroupComment[_MAX_PATH];

    memset(&GI1, 0, sizeof(GROUP_INFO_1));

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wszLocalGroupName, szGroupName);
    _tcscpy(wszLocalGroupComment, szGroupComment);
#else
    MultiByteToWideChar( CP_ACP, 0, szGroupName, -1, wszLocalGroupName, _MAX_PATH);
    MultiByteToWideChar( CP_ACP, 0, szGroupComment, -1, wszLocalGroupComment, _MAX_PATH);
#endif


    GI1.grpi1_name      = wszLocalGroupName;
    GI1.grpi1_comment   = wszLocalGroupComment;


    iisDebugOut((LOG_TYPE_TRACE, _T("CreateGroup:NetGroupAdd\n")));
    ulErr = NetGroupAdd(NULL,1,(PBYTE)&GI1,&BadParm);
    iisDebugOut((LOG_TYPE_TRACE, _T("CreateGroup:NetGroupAdd,ret=0x%x\n"),ulErr));
	switch (ulErr) 
	    {
        case NERR_Success:
            iisDebugOut((LOG_TYPE_TRACE, _T("CreateGroup:NetGroupAdd,success\n"),ulErr));
            iReturn = TRUE;
            break;
        case NERR_GroupExists:
            iReturn = TRUE;
    		break;
        case NERR_InvalidComputer:
            iReturn = FALSE;
		    break;
        case NERR_NotPrimary:
            {
                // it is a backup dc
                int err;
                iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGetDCName():Start.\n")));
                err = NetGetDCName( NULL, NULL, (LPBYTE *)&pMachineName );
                iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGetDCName():End.Ret=0x%x\n"),err));
                if (err != NERR_Success)
                {
                    MyMessageBox(NULL, _T("CreateUser:NetGetDCName"), err, MB_OK | MB_SETFOREGROUND);
                }
                else 
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGroupAdd().Start.")));
                    ulErr = NetGroupAdd(pMachineName,1,(PBYTE)&GI1,&BadParm);
                    iisDebugOut((LOG_TYPE_TRACE, _T("NETAPI32.dll:NetGroupAdd().End.")));
                    if (NERR_Success == ulErr || NERR_GroupExists == ulErr)
                    {
                        iReturn = TRUE;
                    }
                }
            }
            break;
        case ERROR_ACCESS_DENIED:
            iReturn = FALSE;
		    break;
        default:
            iReturn = FALSE;
		    break;
	    }

    return iReturn;
}




#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\sslkeys.h ===
#include "stdafx.h"
#include <wincrypt.h>

void Upgradeiis4Toiis5MetabaseSSLKeys();
void UpgradeLSAKeys(PWCHAR pszwTargetMachine);
BOOL PrepIPPortName(CString& csKeyMetaName, CString& csIP, CString& csPort);
void StoreKeyReference_Default(CMDKey& cmdW3SVC, PCCERT_CONTEXT pCert, CString& csPort);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\sslkeys.cpp ===
/* code to upgrade SSL keys to the latest mechanism

    Since there have been several mechanisms to do this in the past we need
    several mechanisms to store and retrieve the private and public portions
    of the keys.

    IIS2/3 used the LSA mechanism to store the keys as secrets in the registry.
    IIS4 stored the keys directly in the metabase as secured data objects.

    IIS5 will be using the native NT5 Protected Storage mechanism to keep the keys.
    This means that we are no longer in the business of storing, protecting and
    retrieving the keys. It will all be done in NT maintained facilities. However,
    we still need to migrate the keys over to the new storage mechanism, which is
    what this code is all about.

    One more thing. Previously the keys were associated with the virtual servers
    in an indirect manner. The keys (IIS4) were stored in a metabase location that
    was parallel to the virtual servers. Then each key had an IP\Port binding
    associated with it that mapped the key back to the original server.
    This has caused no end of confusion for the users as they struggle to associate
    keys with virtual servers.

    Now the references to the keys in the PStore are stored directly on each virtual
    server, creating a implicit releationship between the key and the server.

    The old mapping scheme also supported the concept of wildcarded IP or Port
    address. Whereas this new scheme does not. This means the upgrading will be done
    as a several stop process. First, we look for all the existing keys that are bound
    to a specific IP/Port combination. This takes precedence over wildcards and is
    applied to the keys first. Then IP/wild is applied to any matching virtual server
    that does not already have a key on it. Then wile/Port. Since we have always
    required that there can only be one default key at a time, as soon as we encounter
    it in the process we can just apply it to the master-properties level.

    Fortunately, this whole file is on NT only, so we can assume everything is UNICODE always
*/

#include "stdafx.h"

// this file is also only used on NT, so don't do anything if its win9X
#ifndef _CHICAGO_

#include <ole2.h>
#include "iadm.h"
#include "iiscnfgp.h"
#include "mdkey.h"
#include "lsaKeys.h"

#include "setupapi.h"
#undef MAX_SERVICE_NAME_LEN
#include "elem.h"
#include "mdentry.h"
#include "inetinfo.h"

#include "inetcom.h"
#include "logtype.h"
#include "ilogobj.hxx"
#include "ocmanage.h"
#include "sslkeys.h"
extern OCMANAGER_ROUTINES gHelperRoutines;

#include <wincrypt.h>

#define SECURITY_WIN32
#include <sspi.h>
#include <spseal.h>
#include <issperr.h>
#include <schnlsp.h>

#include "certupgr.h"


const LPCTSTR MDNAME_INCOMPLETE = _T("incomplete");
const LPCTSTR MDNAME_DISABLED = _T("disabled");
const LPCTSTR MDNAME_DEFAULT = _T("default");

const LPCTSTR SZ_SERVER_KEYTYPE = _T("IIsWebServer");

const LPTSTR SZ_SSLKEYS_NODE = _T("SSLKeys");
const LPTSTR SZ_W3SVC_PATH = _T("LM/W3SVC");
const LPTSTR SZ_SSLKEYS_PATH = _T("LM/W3SVC/SSLKeys");

const LPWSTR SZ_CAPI_STORE = L"MY";

#define     ALLOW_DELETE_KEYS       // Normally defined. Don't define for test purposes.

//------------------------------------------------------------------------------
// Given the name of a key in the metabase migrate it to the PStore. At this point we
// are actually only loading and preparing the raw data. The routines to stick it in the
// right place are in an external library so they can be shared with other utilities.
// since the metabase key is already opened by the calling routine, pass it in as a
// parameter.
// returns TRUE for success
PCCERT_CONTEXT MigrateKeyToPStore( CMDKey* pmdKey, CString& csMetaKeyName )
{
    iisDebugOut((LOG_TYPE_TRACE, _T("MigrateKeyToPStore():Start.%s."), (LPCTSTR)csMetaKeyName));
    BOOL        fSuccess = FALSE;
    BOOL        f;
    DWORD       dwAttr, dwUType, dwDType, cbLen, dwLength;

    PVOID       pbPrivateKey = NULL;
    DWORD       cbPrivateKey = 0;

    PVOID       pbPublicKey = NULL;
    DWORD       cbPublicKey = 0;

    PVOID       pbRequest = NULL;
    DWORD       cbRequest = 0;

    PCHAR       pszPassword = NULL;

    PCCERT_CONTEXT pcCertContext = NULL;

    // the actual sub key path this the sslkeys dir plus the key name. The actual metabase
    // object is opened to the w3svc level
    CString     csSubKeyPath = _T("SSLKeys/");
    csSubKeyPath += csMetaKeyName;

    // get the private key - required ---------
    dwAttr = 0;
    dwUType = IIS_MD_UT_SERVER;
    dwDType = BINARY_METADATA;
    // this first call is just to get the size of the pointer we need
    f = pmdKey->GetData(MD_SSL_PRIVATE_KEY,&dwAttr,&dwUType,&dwDType,&cbPrivateKey,NULL,0,(PWCHAR)(LPCTSTR)csSubKeyPath);
    // if the get data fails on the private key, we have nothing to do
    if ( cbPrivateKey == 0 )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED: Unable to read private key for %s"), (LPCTSTR)csMetaKeyName));
        return NULL;
        }

    // allocate the buffer for the private key
    pbPrivateKey = GlobalAlloc( GPTR, cbPrivateKey );
    if ( !pbPrivateKey ) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED to allocate memory for private key.")));
        return NULL;
    }

    // do the real call to get the data from the metabase
    f = pmdKey->GetData(MD_SSL_PRIVATE_KEY,&dwAttr,&dwUType,&dwDType,&cbPrivateKey,(PUCHAR)pbPrivateKey,cbPrivateKey,(PWCHAR)(LPCTSTR)csSubKeyPath);
    // if the get data fails on the private key, we have nothing to do
    if ( !f )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED: Unable to read private key for %s"), (LPCTSTR)csMetaKeyName));
        goto cleanup;
        }


    // get the password -required ------------
    // the password is stored as an ansi binary secure item.
    dwAttr = 0;
    dwUType = IIS_MD_UT_SERVER;
    dwDType = BINARY_METADATA;
    cbLen = 0;
    // this first call is just to get the size of the pointer we need
    f = pmdKey->GetData(MD_SSL_KEY_PASSWORD,&dwAttr,&dwUType,&dwDType,&cbLen,NULL,0,(PWCHAR)(LPCTSTR)csSubKeyPath);
    // if the get data fails on the password, we have nothing to do
    if ( cbLen == 0 )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED retrieve password. Nothing to do.")));
        goto cleanup;
    }

    // allocate the buffer for the password
    pszPassword = (PCHAR)GlobalAlloc( GPTR, cbLen );
    if ( !pszPassword ) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED to allocate memory for password.")));
        goto cleanup;
    }

    // do the real call to get the data from the metabase
    f = pmdKey->GetData(MD_SSL_KEY_PASSWORD,&dwAttr,&dwUType,&dwDType,&cbLen,(PUCHAR)pszPassword,cbLen,(PWCHAR)(LPCTSTR)csSubKeyPath);
    // if the get data fails on the password, we have nothing to do
    if ( !f )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED: Unable to read ssl password for %s"), (LPCTSTR)csMetaKeyName));
        goto cleanup;
        }

    // get the public key -optional -----------
    dwAttr = 0;
    dwUType = IIS_MD_UT_SERVER;
    dwDType = BINARY_METADATA;
    // this first call is just to get the size of the pointer we need
    f = pmdKey->GetData(MD_SSL_PUBLIC_KEY,&dwAttr,&dwUType,&dwDType,&cbPublicKey,NULL,0,(PWCHAR)(LPCTSTR)csSubKeyPath);
    // the public key is optional, so don't fail if we don't get it
    if ( cbPublicKey )
    {
        // allocate the buffer for the private key
        pbPublicKey = GlobalAlloc( GPTR, cbPublicKey );
        if ( !pbPublicKey ) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED to allocate memory for public key.")));
        }
        else
        {
            // do the real call to get the data from the metabase
            f = pmdKey->GetData(MD_SSL_PUBLIC_KEY,&dwAttr,&dwUType,&dwDType,&cbPublicKey,(PUCHAR)pbPublicKey,cbPublicKey,(PWCHAR)(LPCTSTR)csSubKeyPath);
            // if the get data fails on the public key, clean it up and reset it to null
            if ( !f )
            {
                if ( pbPublicKey )
                {
                    GlobalFree( pbPublicKey );
                    pbPublicKey = NULL;
                }
                cbPublicKey = 0;
            }
        }
    }

    // get the request -optional -----------
    dwAttr = 0;
    dwUType = IIS_MD_UT_SERVER;
    dwDType = BINARY_METADATA;
    // this first call is just to get the size of the pointer we need
    f = pmdKey->GetData(MD_SSL_KEY_REQUEST,&dwAttr,&dwUType,&dwDType,
        &cbRequest,NULL,0,(PWCHAR)(LPCTSTR)csSubKeyPath);
    // the request is optional, so don't fail if we don't get it
    if ( cbRequest )
    {
        // allocate the buffer for the private key
        pbRequest = GlobalAlloc( GPTR, cbRequest );
        if ( !pbRequest ) 
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():FAILED to allocate memory for key request.")));
        }
        else
        {
            // do the real call to get the data from the metabase
            f = pmdKey->GetData(MD_SSL_KEY_REQUEST,&dwAttr,&dwUType,&dwDType,
                &cbRequest,(PUCHAR)pbRequest,cbRequest,(PWCHAR)(LPCTSTR)csSubKeyPath);
            // if the get data fails on the key request, clean it up and reset it to null
            if ( !f )
            {
                if ( pbRequest )
                {
                    GlobalFree( pbRequest );
                    pbRequest = NULL;
                }
                cbRequest = 0;
            }
        }
    }

    // ------------------------------------------------------------------
    // Now that we've loaded the data, we can call the conversion utility
    // ------------------------------------------------------------------
    pcCertContext = CopyKRCertToCAPIStore(
        pbPrivateKey, cbPrivateKey,
        pbPublicKey, cbPublicKey,
        pbRequest, cbRequest,
        pszPassword,
        SZ_CAPI_STORE );

    if ( pcCertContext )
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("MigrateKeyToPStore():CopyKRCertToCAPIStore():Upgrade KR key to CAPI for %s. Success."), (LPCTSTR)csMetaKeyName));
    }
    else
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("MigrateKeyToPStore():CopyKRCertToCAPIStore():Upgrade KR key to CAPI for %s.  FAILED."), (LPCTSTR)csMetaKeyName));
    }


cleanup:
    if ( pbPrivateKey ) {GlobalFree( pbPrivateKey );}
    if ( pbPublicKey ) {GlobalFree( pbPublicKey );}
    if ( pszPassword ) {GlobalFree( pszPassword );}

    iisDebugOut((LOG_TYPE_TRACE, _T("MigrateKeyToPStore():End.%s."), (LPCTSTR)csMetaKeyName));

    return pcCertContext;
}


//------------------------------------------------------------------------------
// write a reference to a PStore key on a specific node in the metabase
void WriteKeyReference( CMDKey& cmdW3SVC, PWCHAR pwchSubPath, PCCERT_CONTEXT pCert )
    {
    // get the hash that we need to write out

    //
    // SHA produces 160 bit hash for any message < 2^64 bits in length
    BYTE HashBuffer[40];                // give it some extra size
    DWORD dwHashSize = sizeof(HashBuffer);
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertGetCertificateContextProperty().Start.")));
    if ( !CertGetCertificateContextProperty( pCert,
                                             CERT_SHA1_HASH_PROP_ID,
                                             (VOID *) HashBuffer,
                                             &dwHashSize ) )
        {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertGetCertificateContextProperty().End.")));
        if ( GetLastError() == ERROR_MORE_DATA )
            {
            //Very odd, cert wants more space ..
            iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: StoreCertInfoInMetabase Unable to get hash property")));
            }

        // We definitely need to store the hash of the cert, so error out
        return;
        }
    else
        {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertGetCertificateContextProperty().End.")));
        }

    // write out the hash of the certificate
    cmdW3SVC.SetData( MD_SSL_CERT_HASH, METADATA_INHERIT, IIS_MD_UT_SERVER, BINARY_METADATA,
                        dwHashSize, (PUCHAR)&HashBuffer, pwchSubPath );

    // write out the name of the store
    cmdW3SVC.SetData( MD_SSL_CERT_STORE_NAME, METADATA_INHERIT, IIS_MD_UT_SERVER, STRING_METADATA,
                    (_tcslen(SZ_CAPI_STORE)+1) * sizeof(TCHAR), (PUCHAR)SZ_CAPI_STORE, pwchSubPath );
    }

//------------------------------------------------------------------------------
// store a reference to a PStore key on all the appropriate virtual servers. If csIP
// or csPort is empty, then that item is a wildcard and applies to all virtual servers.
void StoreKeyReference( CMDKey& cmdW3SVC, PCCERT_CONTEXT pCert, CString& csIP, CString& csPort )
{
    TCHAR szForDebug[100];

    if (csIP) 
    {
        if (csPort){_stprintf(szForDebug, _T("ip:%s port:%s"), csIP, csPort);}
        else{_stprintf(szForDebug, _T("ip:%s port:(null)"), csIP);}
    }
    else 
    {
        if (csPort){_stprintf(szForDebug, _T("ip:(null) port:%s"), csPort);}
        else{_stprintf(szForDebug, _T("ip:(null) port:(null)"));}
    }
    iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s."),szForDebug));


    // if it was unable to open the node, then there are no keys to upgrade.
    if ( (METADATA_HANDLE)cmdW3SVC == NULL )
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("FAILED: passed in invalid metabase handle")));
        iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference End")));
        return;
        }

    // generate the iterator for retrieving the virtual servers
    CMDKeyIter  cmdKeyEnum( cmdW3SVC );
    CString     csNodeName;              // Metabase name for the virtual server
    CString     csNodeType;              // node type indicator string
    CString     csBinding;

    PVOID       pData = NULL;

    BOOL        f;

    DWORD       dwAttr, dwUType, dwDType, cbLen, dwLength;

    // iterate through the virtual servers
    iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.iterate through the virtual servers"),szForDebug));
    while (cmdKeyEnum.Next(&csNodeName) == ERROR_SUCCESS)
        {
        // some of the keys under this node are not virutal servers. Thus
        // we first need to check the node type property. If it is not a
        // virtual server then we can just contiue on to the next node.

        // get the string that indicates the node type
        dwAttr = 0;
        dwUType = IIS_MD_UT_SERVER;
        dwDType = STRING_METADATA;
        cbLen = 200;
        f = cmdW3SVC.GetData(MD_KEY_TYPE,
                     &dwAttr,
                     &dwUType,
                     &dwDType,
                     &cbLen,
                     (PUCHAR)csNodeType.GetBuffer(cbLen),
                     cbLen,
                     (PWCHAR)(LPCTSTR)csNodeName);
        csNodeType.ReleaseBuffer();

        // check it - if the node is not a virutal server, then continue on to the next node
        if ( csNodeType != SZ_SERVER_KEYTYPE )
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.%s not a virtualserver, skip."),szForDebug,csNodeName));
            continue;
        }


        // before we do anything else, check if this virtual server already has a key on it.
        // if it does then do not do anything to it. Continue on to the next one
        // we don't actually need to load any data for this to work, so we can call GetData
        // with a size of zero as if we are querying for the size. If that succeedes, then
        // we know that it is there and can continue on
        dwAttr = 0;                     // do not inherit
        dwUType = IIS_MD_UT_SERVER;
        dwDType = BINARY_METADATA;
        dwLength = 0;
        cmdW3SVC.GetData( MD_SSL_CERT_HASH,
                &dwAttr,
                &dwUType,
                &dwDType,
                &dwLength,
                NULL,
                0,
                0,                      // do not inherit
                IIS_MD_UT_SERVER,
                BINARY_METADATA,
                (PWCHAR)(LPCTSTR)csNodeName);

        // if there is a key there already - continue to the next node
        if ( dwLength > 0 )
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.%s already has a key there, skip."),szForDebug,csNodeName));
            continue;
        }

        // this is a valid virtual server with no pre-existing key. Now we need to load
        // the bindings and see if we have a match
        dwAttr = 0;                     // do not inherit
        dwUType = IIS_MD_UT_SERVER;
        dwDType = MULTISZ_METADATA;
        dwLength = 0;
        // The bindings are in a multi-sz. So, first we need to figure out how much space we need
        f = cmdW3SVC.GetData( MD_SECURE_BINDINGS,
                &dwAttr,
                &dwUType,
                &dwDType,
                &dwLength,
                NULL,
                0,
                0,                      // do not inherit
                IIS_MD_UT_SERVER,
                MULTISZ_METADATA,
                (PWCHAR)(LPCTSTR)csNodeName);

        // if the length is zero, then there are no bindings
        if ( dwLength == 0 )
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.%s data len=0 no bindings, skip."),szForDebug,csNodeName));
            continue;
        }

        // Prepare some space to receive the bindings
        TCHAR*      pBindings;

        // if pData is pointing to something, then we need to free it so that we don't leak
        if ( pData )
            {
            GlobalFree( pData );
            pData = NULL;
            }

        // allocate the space, if it fails, we fail
        // note that GPTR causes it to be initialized to zero
        pData = GlobalAlloc( GPTR, dwLength + 2 );
        if ( !pData )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("StoreKeyReference.Start.%s.%s GlobalAlloc failed."),szForDebug,csNodeName));
            continue;
        }
        pBindings = (TCHAR*)pData;

        // now get the real data from the metabase
        f = cmdW3SVC.GetData( MD_SECURE_BINDINGS,
                &dwAttr,
                &dwUType,
                &dwDType,
                &dwLength,
                (PUCHAR)pBindings,
                dwLength,
                0,                      // do not inherit
                IIS_MD_UT_SERVER,
                MULTISZ_METADATA,
                (PWCHAR)(LPCTSTR)csNodeName );

        // if we did not get the bindings, then this node doesn't have any security
        // options set on it. We can continue on to the next virtual server
        if ( FALSE == f )
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.%s No security options set on it, skip."),szForDebug,csNodeName));
            continue;
        }

        // OK. We do have bindings. Now we get to parse them out and check them
        // against the binding strings that were passed in. Note: if a binding
        // matches, but has a host-header at the end, then it does not qualify
        // got the existing bindings, scan them now - pBindings will be pointing at the second end \0
        // when it is time to exit the loop.
        while ( *pBindings )
            {
            csBinding = pBindings;
            csBinding.TrimRight();

            CString     csBindIP;
            CString     csBindPort;         // don't actually care about this one

            // get the binding's IP and port sections so we can look for wildcards in the binding itself
            PrepIPPortName( csBinding, csBindIP, csBindPort );

            // if there is a specified IP, look for it. If we don't find it, go to the next binding.
            if ( !csIP.IsEmpty() && !csBindIP.IsEmpty() )
                {
                // if the IP is not in the binding then bail on this binding
                if ( csBinding.Find( csIP ) < 0 )
                    {
                    iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.%s:org=%s,findIP=%s bail."),szForDebug,csNodeName,csBinding,csIP));
                    goto NextBinding;
                    }
                }

            // if there is a specified Port, look for it. If we don't find it, go to the next binding.\
            // secure bindings themselves always have a port
            if ( !csPort.IsEmpty() )
                {
                // if the Port is not in the binding then bail on this binding
                if ( csBinding.Find( csPort ) < 0 )
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.%s:org=%s,findport=%s bail."),szForDebug,csNodeName,csBinding,csPort));
                    goto NextBinding;
                }
                }

            // test if host headers are there by doing a reverse find for the last colon. Then
            // check if it is the last character. If it isn't, then there is a host-header and
            // we should go to a different binding
            if ( csBinding.ReverseFind(_T(':')) < (csBinding.GetLength()-1) )
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.Start.%s.%s:bail2."),szForDebug,csNodeName));
                goto NextBinding;
            }


            // Well, this is a valid binding on a valid virtual server, we can now write out the key
            iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.%s.%s:Write out the key!"),szForDebug,csNodeName));
            WriteKeyReference( cmdW3SVC, (PWCHAR)(LPCTSTR)csNodeName, pCert );

            // we can break to get out of the specific bindings loop
            break;

NextBinding:
            // increment pBindings to the next string
            pBindings = _tcsninc( pBindings, _tcslen(pBindings))+1;
            }
        }

    // if pData is pointing to something, then we need to free it so that we don't leak
    if ( pData )
        {
        GlobalFree( pData );
        pData = NULL;
        }

    iisDebugOut((LOG_TYPE_TRACE, _T("StoreKeyReference.End.%s."),szForDebug));
}

//------------------------------------------------------------------------------
// given a metabase key name, create strings that can be used to search the virutal servers
// an empty string is a wildcard.
BOOL PrepIPPortName( CString& csKeyMetaName, CString& csIP, CString& csPort )
    {
    int iColon;

    // the first thing we are going to do is seperate the IP and PORT into seperate strings
    // actually, thats not true. Prep the string by putting a colon in it.
    csIP.Empty();
    csPort = _T(':');

    // look for the first ':' and seperate
    iColon = csKeyMetaName.Find( _T(':') );

    // if we got the colon, we can seperate easy
    if ( iColon >= 0 )
        {
        csIP = csKeyMetaName.Left(iColon);
        csPort += csKeyMetaName.Right(csKeyMetaName.GetLength() - iColon - 1);
        }
    // we did not get the colon, so it is one or the other, look for a '.' to get the IP
    else
        {
        if ( csKeyMetaName.Find( _T('.') ) >= 0 )
            csIP = csKeyMetaName;
        else
            csPort += csKeyMetaName;
        }

    // finish decorating the strings with colons if appropriate.
    if ( !csIP.IsEmpty() )
        csIP += _T(':');

    // If the only thing in the port string is a : then it is a wildcard. Clear it out.
    if ( csPort.GetLength() == 1 )
        {
        csPort.Empty();
        }
    else
        {
        // add a final colon to it
        csPort += _T(':');
        }

    return TRUE;
    }


//------------------------------------------------------------------------------
// used when upgrading from IIS2 or IIS3
// this code was in the K2 setup program that shipped. It used to reside in mdentry.cpp and
// has now been encapsulted into its own routine and moved here. The only change to it has been
// to add the Upgradeiis4Toiis5MetabaseSSLKeys call at the end.
void UpgradeLSAKeys( PWCHAR pszwTargetMachine )
{
    iisDebugOut((LOG_TYPE_TRACE, _T("UpgradeLSAKeys Start")));

    DWORD       retCode = KEYLSA_SUCCESS;
    MDEntry     stMDEntry;
    CString     csMDPath;
    TCHAR       tchFriendlyName[_MAX_PATH], tchMetaName[_MAX_PATH];
    BOOL        fUpgradedAKey = FALSE;

    CLSAKeys    lsaKeys;
    WCHAR       wchMachineName[UNLEN + 1];

    memset( (PVOID)wchMachineName, 0, sizeof(wchMachineName));

#if defined(UNICODE) || defined(_UNICODE)
    wcsncpy(wchMachineName, g_pTheApp->m_csMachineName, UNLEN);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)g_pTheApp->m_csMachineName, -1, (LPWSTR)wchMachineName, UNLEN);
#endif

    retCode = lsaKeys.LoadFirstKey(wchMachineName);
    while (retCode == KEYLSA_SUCCESS) {
#if defined(UNICODE) || defined(_UNICODE)
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lsaKeys.m_szMetaName, -1, (LPWSTR)tchMetaName, _MAX_PATH);
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lsaKeys.m_szFriendlyName, -1, (LPWSTR)tchFriendlyName, _MAX_PATH);
#else
        _tcscpy(tchMetaName, lsaKeys.m_szMetaName);
        _tcscpy(tchFriendlyName, lsaKeys.m_szFriendlyName);
#endif
        iisDebugOut((LOG_TYPE_TRACE, _T("lsaKeys: FriendName=%s MetaName=%s\n"), tchFriendlyName, tchMetaName));
        csMDPath = SZ_SSLKEYS_PATH;
        csMDPath += _T("/");
        csMDPath += (CString)tchMetaName;
        stMDEntry.szMDPath = (LPTSTR)(LPCTSTR)csMDPath;
        stMDEntry.dwMDIdentifier = MD_SSL_FRIENDLY_NAME;
        stMDEntry.dwMDAttributes = METADATA_INHERIT;
        stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
        stMDEntry.dwMDDataType = STRING_METADATA;
        stMDEntry.dwMDDataLen = (_tcslen(tchFriendlyName) + 1) * sizeof(TCHAR);
        stMDEntry.pbMDData = (LPBYTE)tchFriendlyName;
        SetMDEntry(&stMDEntry);
        stMDEntry.dwMDIdentifier = MD_SSL_PUBLIC_KEY;
        stMDEntry.dwMDAttributes = METADATA_INHERIT | METADATA_SECURE;
        stMDEntry.dwMDUserType = IIS_MD_UT_SERVER;
        stMDEntry.dwMDDataType = BINARY_METADATA;
        stMDEntry.dwMDDataLen = lsaKeys.m_cbPublic;
        stMDEntry.pbMDData = (LPBYTE)lsaKeys.m_pPublic;
        SetMDEntry(&stMDEntry);
        stMDEntry.dwMDIdentifier = MD_SSL_PRIVATE_KEY;
        stMDEntry.dwMDDataLen = lsaKeys.m_cbPrivate;
        stMDEntry.pbMDData = (LPBYTE)lsaKeys.m_pPrivate;
        SetMDEntry(&stMDEntry);
        stMDEntry.dwMDIdentifier = MD_SSL_KEY_PASSWORD;
        stMDEntry.dwMDDataLen = lsaKeys.m_cbPassword;
        stMDEntry.pbMDData = (LPBYTE)lsaKeys.m_pPassword;
        SetMDEntry(&stMDEntry);
        stMDEntry.dwMDIdentifier = MD_SSL_KEY_REQUEST;
        stMDEntry.dwMDDataLen = lsaKeys.m_cbRequest;
        stMDEntry.pbMDData = (LPBYTE)lsaKeys.m_pRequest;
        SetMDEntry(&stMDEntry);
        fUpgradedAKey = TRUE;

        retCode = lsaKeys.LoadNextKey();
    }

    if (retCode == KEYLSA_NO_MORE_KEYS) {
        iisDebugOut((LOG_TYPE_TRACE, _T("No More Keys\n")));
        lsaKeys.DeleteAllLSAKeys();
    }

    // Now that the keys have been upgraded to the metabase, upgrade again from
    // the metabase to the PStore
    if ( fUpgradedAKey )
        Upgradeiis4Toiis5MetabaseSSLKeys();
    iisDebugOut((LOG_TYPE_TRACE, _T("UpgradeLSAKeys End")));
}


//------------------------------------------------------------------------------
// the plan here is to enumerate all the server keys under the SSLKEYS key in the metabase.
//    Then they need to be migrated to the PStore and have their references resaved into
//    the correct virtual server.
//
// How the heck does all this work?
//
// iis4.0 metabase looks like this:
// w3svc
// w3svc/1
// w3svc/2
// sslkeys
// sslkeys/(entry1) <--could be one of either of the ssl key types list below
// sslkeys/(entry2) <--
// sslkeys/(entry3) <--
// 
// sslkey types:
//  sslkeys/MDNAME_DISABLED
//  sslkeys/MDNAME_INCOMPLETE
//  sslkeys/MDNAME_DEFAULT
//  sslkeys/ip:port
//
//  step 1. Grab all these sslkeys/entries and move them into the new storage (MigrateKeyToPStore)
//          (for each entry we move into the new storage, we add an entry to a Cstring List to say (we did this one already) )
//          a. do it in iteration#1 for In this loop we look for the default key, disabled keys, incomplete keys, and keys specified by specific IP/Port pairs.
//          b. do it in iteration#2 for IP/wild port keys.
//          c. do it in iteration#3 the rest of the keys, which should all be wild ip/Port keys.
//  step 2. for each of these keys which we moved to the new storage: store the reference which we get back from CAPI
//          in our metabase (StoreKeyReference)
//  step 3. Make sure to keep the metabasekeys around, because setup may actually fail: so we don't want to delete the keys
//          until we are sure that setup is completed.
//  step 4. after setup completes without any errors, we delete all the sslkeys
//
void Upgradeiis4Toiis5MetabaseSSLKeys()
{
    iisDebugOut_Start(_T("Upgradeiis4Toiis5MetabaseSSLKeys"), LOG_TYPE_TRACE);
    iisDebugOut((LOG_TYPE_TRACE, _T("--------------------------------------")));
    CString     csMDPath;
   
    // start by testing that the sslkeys node exists.
    CMDKey cmdKey;
    cmdKey.OpenNode( SZ_SSLKEYS_PATH );
    if ( (METADATA_HANDLE)cmdKey == NULL )
    {
        // there is nothing to do
        iisDebugOut((LOG_TYPE_TRACE, _T("Nothing to do.")));
        return;
    }
    cmdKey.Close();

    // create a key object for the SSLKeys level in the metabase. Open it too.
    cmdKey.OpenNode( SZ_W3SVC_PATH );
    if ( (METADATA_HANDLE)cmdKey == NULL )
    {
        // if it was unable to open the node, then there are no keys to upgrade.
        iisDebugOut((LOG_TYPE_WARN, _T("could not open lm/w3svc")));
        iisDebugOut_End(_T("Upgradeiis4Toiis5MetabaseSSLKeys,No keys to upgrade"),LOG_TYPE_TRACE);
        return;
    }

    // create and prepare a metadata iterator object for the sslkeys
    CMDKeyIter  cmdKeyEnum(cmdKey);
    CString     csKeyName;                  // Metabase name for the key

    // used to parse out the name information
    CString     csIP;
    CString     csPort;
    //CString     csSubPath;

    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CONTEXT pDefaultCert = NULL;

    BOOL bUpgradeToPStoreIsGood = TRUE;

    // do the first iteration. In this loop we look for the default key, disabled keys,
    // incomplete keys, and keys specified by specific IP/Port pairs.
    // Note: cmdKeyEnum.m_index is the index member for the iterator
    iisDebugOut((LOG_TYPE_TRACE, _T("1.first interate for default,disabled,incomplete,and keys specified by specific IP/Port pairs.")));
    while (cmdKeyEnum.Next(&csKeyName, SZ_SSLKEYS_NODE ) == ERROR_SUCCESS)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("KeyName=%s."),csKeyName));

        pCert = NULL;

        // look for disabled keys
        if ( csKeyName.Find(MDNAME_DISABLED) >= 0)
        {
            pCert = MigrateKeyToPStore( &cmdKey, csKeyName );
            if (!pCert){bUpgradeToPStoreIsGood = FALSE;}
        }
        // look for incomplete keys
        else if ( csKeyName.Find(MDNAME_INCOMPLETE) >= 0)
        {
            pCert = MigrateKeyToPStore( &cmdKey, csKeyName );
            if (!pCert){bUpgradeToPStoreIsGood = FALSE;}
        }
        // look for the default key
        else if ( csKeyName.Find(MDNAME_DEFAULT) >= 0)
        {
            pDefaultCert = MigrateKeyToPStore( &cmdKey, csKeyName );
            if (!pDefaultCert){bUpgradeToPStoreIsGood = FALSE;}
        }
        // parse the IP/Port name
        else
        {
            // we are only taking keys that have both the IP and the Port specified at this time
            PrepIPPortName( csKeyName, csIP, csPort );
            if ( !csIP.IsEmpty() && !csPort.IsEmpty() )
            {
                // move the key from the metabase to the
                pCert = MigrateKeyToPStore( &cmdKey, csKeyName );
                if ( pCert )
                    {StoreKeyReference( cmdKey, pCert, csIP, csPort );}
                else
                    {bUpgradeToPStoreIsGood = FALSE;}
            }
        }

        // don't leak CAPI certificate contexts now that we are done with it
        if ( pCert )
            {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().Start.")));
            CertFreeCertificateContext( pCert );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().End.")));
            }
    } // end while part 1


    // do the second iteration looking only for IP/wild port keys.
    iisDebugOut((LOG_TYPE_TRACE, _T("2.Second iteration looking only for IP/wild port keys.")));
    cmdKeyEnum.Reset();
    while (cmdKeyEnum.Next(&csKeyName, SZ_SSLKEYS_NODE ) == ERROR_SUCCESS)
    {
        pCert = NULL;

        // parse the IP/Port name
        // we are only taking keys that have the IP specified at this time
        PrepIPPortName( csKeyName, csIP, csPort );
        if ( !csIP.IsEmpty() && csPort.IsEmpty() )
        {
            // move the key from the metabase to the
            pCert = MigrateKeyToPStore( &cmdKey, csKeyName );
            if ( pCert )
                {StoreKeyReference( cmdKey, pCert, csIP, csPort );}
            else
                {bUpgradeToPStoreIsGood = FALSE;}
        }

        // don't leak CAPI certificate contexts now that we are done with it
        if ( pCert )
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().Start.")));
            CertFreeCertificateContext( pCert );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().End.")));
        }
    }

    // upgrade the rest of the keys, which should all be wild ip/Port keys.
    iisDebugOut((LOG_TYPE_TRACE, _T("3.upgrade the rest of the keys, which should all be wild ip/Port keys.")));
    cmdKeyEnum.Reset();
    while (cmdKeyEnum.Next(&csKeyName, SZ_SSLKEYS_NODE) == ERROR_SUCCESS)
    {
        pCert = NULL;

        // parse the IP/Port name
        // we are only taking keys that have the PORT specified at this time
        PrepIPPortName( csKeyName, csIP, csPort );
        if ( !csPort.IsEmpty() && csIP.IsEmpty())
        {
            // move the key from the metabase to the
            pCert = MigrateKeyToPStore( &cmdKey, csKeyName );
            if ( pCert )
                {StoreKeyReference( cmdKey, pCert, csIP, csPort );}
            else
                {bUpgradeToPStoreIsGood = FALSE;}
        }

        // don't leak CAPI certificate contexts now that we are done with it
        if ( pCert )
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().Start.")));
            CertFreeCertificateContext( pCert );
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().End.")));
        }
    }

    // if there is one, write the default key reference out
    if ( pDefaultCert )
        {
        iisDebugOut((LOG_TYPE_TRACE, _T("4.write default key reference out")));

        CString     csPortDefault;

        // old way which used to put it on the lm/w3svc node.
        // but we can't do that anymore since that node can't be accessed by the iis snap-in!
        //WriteKeyReference( cmdKey, L"", pDefaultCert );

        csPortDefault = _T(":443:");
        StoreKeyReference_Default( cmdKey, pDefaultCert, csPortDefault );

        // don't leak CAPI certificate contexts now that we are done with it
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().Start.")));
        CertFreeCertificateContext( pDefaultCert );
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CRYPT32.dll:CertFreeCertificateContext().End.")));
        }

//#ifdef ALLOW_DELETE_KEYS
    if (TRUE == bUpgradeToPStoreIsGood)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("Upgradeiis4Toiis5MetabaseSSLKeys. 5. Removing upgraded sslkeys node.")));
        // delete the sslkeys node in the metabase
        cmdKey.DeleteNode( SZ_SSLKEYS_NODE );
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("Upgradeiis4Toiis5MetabaseSSLKeys. 6. MigrateKeyToPStore failed so keeping ssl key in metabase.")));
    }
//#endif //ALLOW_DELETE_KEYS

    // close the master properties key.
    cmdKey.Close();

    iisDebugOut_End(_T("Upgradeiis4Toiis5MetabaseSSLKeys"), LOG_TYPE_TRACE);
    iisDebugOut((LOG_TYPE_TRACE, _T("--------------------------------------")));

    // force the metabase to write.
    WriteToMD_ForceMetabaseToWriteToDisk();
    return;
}


//------------------------------------------------------------------------------
// store a reference to a PStore key on all the appropriate virtual servers.
void StoreKeyReference_Default( CMDKey& cmdW3SVC, PCCERT_CONTEXT pCert, CString& csPort )
{
    iisDebugOut_Start(_T("StoreKeyReference_Default"), LOG_TYPE_TRACE);

    // generate the iterator for retrieving the virtual servers
    CMDKeyIter  cmdKeyEnum( cmdW3SVC );
    CString     csNodeName;              // Metabase name for the virtual server
    CString     csNodeType;              // node type indicator string
    CString     csBinding;
    PVOID       pData = NULL;
    BOOL        f;
    DWORD       dwAttr, dwUType, dwDType, cbLen, dwLength;

    // We are looking for a particular port which is stored in csPort.
    // if there is no csPort passed in then lets get out of here!
    if ( csPort.IsEmpty() )
    {
        goto StoreKeyReference_Default_Exit;
    }

    // if it was unable to open the node, then there are no keys to upgrade.
    if ( (METADATA_HANDLE)cmdW3SVC == NULL )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("passed in invalid metabase handle")));
        goto StoreKeyReference_Default_Exit;
    }

    // iterate through the virtual servers
    while (cmdKeyEnum.Next(&csNodeName) == ERROR_SUCCESS)
    {
        // some of the keys under this node are not virutal servers. Thus
        // we first need to check the node type property. If it is not a
        // virtual server then we can just contiue on to the next node.

        // get the string that indicates the node type
        dwAttr = 0;
        dwUType = IIS_MD_UT_SERVER;
        dwDType = STRING_METADATA;
        cbLen = 200;
        f = cmdW3SVC.GetData(MD_KEY_TYPE,
                     &dwAttr,
                     &dwUType,
                     &dwDType,
                     &cbLen,
                     (PUCHAR)csNodeType.GetBuffer(cbLen),
                     cbLen,
                     (PWCHAR)(LPCTSTR)csNodeName);
        csNodeType.ReleaseBuffer();
        // check it - if the node is not a virutal server, then continue on to the next node
        if ( csNodeType != SZ_SERVER_KEYTYPE )
        {
            continue;
        }


        // before we do anything else, check if this virtual server already has a key on it.
        // if it does then do not do anything to it. Continue on to the next one
        // we don't actually need to load any data for this to work, so we can call GetData
        // with a size of zero as if we are querying for the size. If that succeedes, then
        // we know that it is there and can continue on
        dwAttr = 0;                     // do not inherit
        dwUType = IIS_MD_UT_SERVER;
        dwDType = BINARY_METADATA;
        dwLength = 0;
        cmdW3SVC.GetData(MD_SSL_CERT_HASH,
                &dwAttr,
                &dwUType,
                &dwDType,
                &dwLength,
                NULL,
                0,
                0,                      // do not inherit
                IIS_MD_UT_SERVER,
                BINARY_METADATA,
                (PWCHAR)(LPCTSTR)csNodeName);
        // if there is a key there already - continue to the next node
        if ( dwLength > 0 )
        {
            continue;
        }

        // this is a valid virtual server with no pre-existing key. Now we need to load
        // the bindings and see if we have a match
        dwAttr = 0;                     // do not inherit
        dwUType = IIS_MD_UT_SERVER;
        dwDType = MULTISZ_METADATA;
        dwLength = 0;
        // The bindings are in a multi-sz. So, first we need to figure out how much space we need
        f = cmdW3SVC.GetData( MD_SECURE_BINDINGS,
                &dwAttr,
                &dwUType,
                &dwDType,
                &dwLength,
                NULL,
                0,
                0,                      // do not inherit
                IIS_MD_UT_SERVER,
                MULTISZ_METADATA,
                (PWCHAR)(LPCTSTR)csNodeName);

        // if the length is zero, then there are no bindings
        if ( dwLength == 0 )
        {
            continue;
        }

        // Prepare some space to receive the bindings
        TCHAR*      pBindings;

        // if pData is pointing to something, then we need to free it so that we don't leak
        if ( pData )
        {
            GlobalFree( pData );
            pData = NULL;
        }

        // allocate the space, if it fails, we fail
        // note that GPTR causes it to be initialized to zero
        pData = GlobalAlloc( GPTR, dwLength + 2 );
        if ( !pData )
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("%s GlobalAlloc failed."),csNodeName));
            continue;
        }
        pBindings = (TCHAR*)pData;

        // now get the real data from the metabase
        f = cmdW3SVC.GetData( MD_SECURE_BINDINGS,
                &dwAttr,
                &dwUType,
                &dwDType,
                &dwLength,
                (PUCHAR)pBindings,
                dwLength,
                0,                      // do not inherit
                IIS_MD_UT_SERVER,
                MULTISZ_METADATA,
                (PWCHAR)(LPCTSTR)csNodeName );
        // if we did not get the bindings, then this node doesn't have any security
        // options set on it. We can continue on to the next virtual server
        if ( FALSE == f )
        {
            continue;
        }

        // OK. We do have bindings. Now we get to parse them out and check them
        // against the binding strings that were passed in. Note: if a binding
        // matches, but has a host-header at the end, then it does not qualify
        // got the existing bindings, scan them now - pBindings will be pointing at the second end \0
        // when it is time to exit the loop.
        while ( *pBindings )
        {
            csBinding = pBindings;
            csBinding.TrimRight();

            // We are looking for a particular port which is stored in csPort.
            // if there is no csPort passed in then lets get out of here!
            if ( csPort.IsEmpty() )
            {
                break;
            }
            else
            {
                // if the Port is not in the binding then bail on this binding
                if ( csBinding.Find( csPort ) < 0 )
                {
                    iisDebugOut((LOG_TYPE_TRACE, _T("%s:org=%s,findport=%s bail."),csNodeName,csBinding,csPort));
                    goto NextBinding;
                }
            }

            // test if host headers are there by doing a reverse find for the last colon. Then
            // check if it is the last character. If it isn't, then there is a host-header and
            // we should go to a different binding
            if ( csBinding.ReverseFind(_T(':')) < (csBinding.GetLength()-1) )
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("%s:bail2."),csNodeName));
                goto NextBinding;
            }

            // Well, this is a valid binding on a valid virtual server, we can now write out the key
            iisDebugOut((LOG_TYPE_TRACE, _T("%s:Write out the key!"),csNodeName));
            WriteKeyReference( cmdW3SVC, (PWCHAR)(LPCTSTR)csNodeName, pCert );

            // we can break to get out of the specific bindings loop
            break;

NextBinding:
            // increment pBindings to the next string
            pBindings = _tcsninc( pBindings, _tcslen(pBindings))+1;
        }
    }

    // if pData is pointing to something, then we need to free it so that we don't leak
    if ( pData )
    {
        GlobalFree( pData );
        pData = NULL;
    }

StoreKeyReference_Default_Exit:
    iisDebugOut_End(_T("StoreKeyReference_Default"), LOG_TYPE_TRACE);
}

#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\strfn.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        strfrn.cpp

   Abstract:

        String Functions

   Author:

        Ronald Meijer (ronaldm)
        Munged to work with setup by BoydM

   Project:

        Internet Services Manager
        And now setup too

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "strfn.h"
#include <pudebug.h>


#ifdef _MT

    //
    // Thread protected stuff
    //
    #define RaiseThreadProtection() EnterCriticalSection(&_csSect)
    #define LowerThreadProtection() LeaveCriticalSection(&_csSect)

    static CRITICAL_SECTION _csSect;

#else

    #pragma message("Module is not thread-safe")

    #define RaiseThreadProtection()
    #define LowerThreadProtection()

#endif // _MT

#define MAKE_NULL(obj) { if (obj) delete obj, obj = NULL; }


//
// Text copy functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL
PCToUnixText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString strSource
    )
/*++

Routine Description:

    Convert CR/LF string to LF string (T String to W String).  Destination
    string will be allocated.

Arguments:

    LPWSTR & lpstrDestination : Destination string
    const CString & strSource : Source string

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    int cch = strSource.GetLength() + 1;
    lpstrDestination = (LPWSTR)AllocMem(cch * sizeof(WCHAR));
    if (lpstrDestination != NULL)
    {
        LPCTSTR lpS = strSource;
        LPWSTR lpD = lpstrDestination;

        do
        {
            if (*lpS != _T('\r'))
            {

#ifdef UNICODE
                *lpD++ = *lpS;
#else
                ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpS, 1, lpD++, 1);
#endif // UNICODE

            }
        }
        while (*lpS++);

        return TRUE;
    }

    return FALSE;
}



BOOL
UnixToPCText(
    OUT CString & strDestination,
    IN  LPCWSTR lpstrSource
    )
/*++

Routine Description:

    Expand LF to CR/LF (no allocation necessary) W String to T String.

Arguments:

    CString & strDestination : Destination string
    LPCWSTR lpstrSource      : Source string

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    BOOL fSuccess = FALSE;

    try
    {
        LPCWSTR lpS = lpstrSource;
        //
        // Since we're doubling every linefeed length, assume
        // the worst possible expansion to start with.
        //
        int cch = (::lstrlenW(lpstrSource) + 1) * 2;
        LPTSTR lpD = strDestination.GetBuffer(cch);

        do
        {
            if (*lpS == L'\n')
            {
                *lpD++ = _T('\r');
            }

#ifdef UNICODE
                *lpD++ = *lpS;
#else
                ::WideCharToMultiByte(CP_ACP, 0, lpS, 1, lpD++, 1, NULL, NULL);
#endif // UNICODE

        }
        while (*lpS++);

        strDestination.ReleaseBuffer();

        ++fSuccess;
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Exception in UnixToPCText");
        e->ReportError();
        e->Delete();
    }

    return fSuccess;
}



BOOL
TextToText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString & strSource
    )
/*++

Routine Description:

    Straight copy with allocation. T String to W String.

Arguments:

    LPWSTR & lpstrDestination : Destination string
    const CString & strSource : Source string

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    int cch = strSource.GetLength() + 1;
    lpstrDestination = (LPWSTR)AllocMem(cch * sizeof(WCHAR));
    if (lpstrDestination != NULL)
    {
        TWSTRCPY(lpstrDestination, strSource, cch);
        return TRUE;
    }

    return FALSE;
}



#ifndef UNICODE



#define WBUFF_SIZE  255



LPWSTR
ReferenceAsWideString(
    IN LPCTSTR str
    )
/*++

Routine Description:

    Reference a T string as a W string (non-unicode only).

Arguments:

    LPCTSTR str : Source string

Return Value:

    Wide char pointer to wide string.

Notes:

    This uses an internal wide char buffer, which will be overwritten
    by subsequent calls to this function.

--*/
{
    static WCHAR wchBuff[WBUFF_SIZE + 1];

    ::MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        str,
        -1,
        wchBuff,
        WBUFF_SIZE + 1
        );

    return wchBuff;
}


#endif !UNICODE


LPWSTR
AllocWideString(
    IN LPCTSTR lpString
    )
/*++

Routine Description:

    Convert the incoming string to an wide string, which is allocated
    by this function

Arguments:

    LPCTSTR lpString        : Input wide string

Return Value:

    Pointer to the allocated string

--*/
{
    //
    // Character counts are DBCS friendly
    //
    int cChars = lstrlen(lpString);
    int nLength = (cChars+1) * sizeof(WCHAR);
    LPWSTR lp = (LPWSTR)AllocMem(nLength);
    if (lp)
    {
#ifdef UNICODE
        lstrcpy(lp, lpString);
#else
        ::MultiByteToWideChar(
            CP_ACP, // code page  
            MB_PRECOMPOSED, // character-type options  
            lpString, // address of string to map  
            cChars, // number of characters in string  
            lp, // address of wide-character buffer  
            cChars+1  // size of buffer  
            ); 
#endif
    }

    return lp;
}

LPSTR
AllocAnsiString(
    IN LPCTSTR lpString
    )
/*++

Routine Description:

    Convert the wide string to an ansi (multi-byte) string, which is allocated
    by this function

Arguments:

    LPCTSTR lpString        : Input wide string

Return Value:

    Pointer to the allocated string

--*/
{
    //
    // Character counts are DBCS friendly
    //
    int cChars = lstrlen(lpString);
    int nLength = (cChars * 2) + 1;
    LPSTR lp = (LPSTR)AllocMem(nLength);
    if (lp)
    {
#ifdef UNICODE
        ::WideCharToMultiByte(
            CP_ACP,
            0,
            lpString,
            cChars + 1,
            lp,
            nLength,
            NULL,
            NULL
            );
#else
    lstrcpy(lp, lpString);
#endif
    }

    return lp;
}


LPTSTR
AllocString(
    IN LPCTSTR lpString
    )
/*++

Routine Description:

    Allocate and copy string

Arguments:

    LPCTSTR lpString        : Input string

Return Value:

    Pointer to the allocated string

--*/
{
    int nLength = lstrlen(lpString) + 1;
    LPTSTR lp = (LPTSTR)AllocMem(nLength * sizeof(TCHAR));
    if (lp)
    {
        lstrcpy(lp, lpString);
    }

    return lp;
}



BOOL
IsUNCName(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string path is a UNC path.

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is a UNC path, FALSE otherwise.

Notes:

    Any string of the form \\foo\bar\whatever is considered a UNC path

--*/
{
    if (strDirPath.GetLength() >= 5)  // It must be at least as long as \\x\y,
    {                                 //
        LPCTSTR lp = strDirPath;      //
        if (*lp == _T('\\')           // It must begin with \\,
         && *(lp + 1) == _T('\\')     //
         && _tcschr(lp + 2, _T('\\')) // And have at least one more \ after that
           )
        {
            //
            // Yes, it's a UNC path
            //
            return TRUE;
        }
    }

    //
    // No, it's not
    //
    return FALSE;
}



BOOL
IsFullyQualifiedPath(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string is a fully qualified path name

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is a fully qualified path name


--*/
{
    return strDirPath.GetLength() >= 3
        && strDirPath[1] == _T(':')
        && strDirPath[2] == _T('\\');
}



LPCTSTR
MakeUNCPath(
    IN OUT CString & strDir,
    IN LPCTSTR lpszOwner,
    IN LPCTSTR lpszDirectory
    )
/*++

Routine Description:

    Convert the given directory to a UNC path.

Arguments:

    CString & strDir      : UNC String.
    LPCTSTR lpszOwner     : Computer name
    LPCTSTR lpszDirectory : Source string

Return Value:

    Pointer to strDir

Notes:

    The owner may or may not start with "\\".  If it doesn't, the
    backslashes are provided.

--*/
{
    //
    // Try to make make a unc path out of the directory
    //
    ASSERT(lpszDirectory[1] == _T(':'));

    strDir.Format(
        _T("\\\\%s\\%c$\\%s"),
        PURE_COMPUTER_NAME(lpszOwner),
        lpszDirectory[0],
        lpszDirectory + 3
        );

    return (LPCTSTR)strDir;
}



BOOL
IsURLName(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string path is an URL path.

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is an URL path, FALSE otherwise.

Notes:

    Any string of the form protocol://whatever is considered an URL path

--*/
{
    if (strDirPath.GetLength() >= 4)  // It must be at least as long as x://
    {                                 //
        if (strDirPath.Find(_T("://")) > 0) // Must contain ://
        {
            //
            // Yes, it's an URL path
            //
            return TRUE;
        }
    }

    //
    // No, it's not
    //
    return FALSE;
}



int
CStringFindNoCase(
    IN const CString & strSrc,
    IN LPCTSTR lpszSub
    )
/*++

Routine Description:

    This should be CString::FindNoCase().  Same as CString::Find(),
    but case-insensitive.

Arguments:

    const CString & strSrc  : Source string
    LPCTSTR lpszSub         : String to look for.

Return Value:

    The position of the substring, or -1 if not found.

--*/
{
    LPCTSTR lp1 = strSrc;
    LPCTSTR lp2, lp3;
    int nPos = -1;

    while (*lp1)
    {
        lp2 = lp1;
        lp3 = lpszSub;

        while(*lp2 && *lp3 && _totupper(*lp2) == _totupper(*lp3))
        {
            ++lp2;
            ++lp3;
        }

        if (!*lp3)
        {
            //
            // Found the substring
            //
            nPos = (int)(lp1 - (LPCTSTR)strSrc);
            break;
        }
    
        ++lp1;                    
    }

    return nPos;
}



DWORD
ReplaceStringInString(
    OUT IN CString & strBuffer,
    IN  CString & strTarget,
    IN  CString & strReplacement,
    IN  BOOL fCaseSensitive
    )
/*++

Routine Description:

    Replace the first occurrence of a string with a second string
    inside a third string.

Arguments:

    CString & strBuffer         : Buffer in which to replace
    CString & strTarget         : String to look for
    CString & strReplacement    : String to replace it with
    BOOL fCaseSensitive         : TRUE for case sensitive replacement.
    
Return Value:

    ERROR_SUCCESS for successful replacement.
    ERROR_INVALID_PARAMETER if any string is empty,
    ERROR_FILE_NOT_FOUND if the target string doesn't exist, or
    another win32 error code indicating failure.

--*/
{
    if (strBuffer.IsEmpty() || strTarget.IsEmpty() || strReplacement.IsEmpty())
    {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD err = ERROR_FILE_NOT_FOUND;
    int nPos = fCaseSensitive 
        ? strBuffer.Find(strTarget)
        : CStringFindNoCase(strBuffer, strTarget);

    if (nPos >= 0)
    {
        try
        {
            CString str(strBuffer.Left(nPos));

            str += strReplacement;
            str += strBuffer.Mid(nPos + strTarget.GetLength());
            strBuffer = str;

            err = ERROR_SUCCESS;
        }
        catch(CMemoryException * e)
        {
            e->Delete();
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }    

    return err;
}


int
CountCharsToDoubleNull(
    IN LPCTSTR lp
    )
/*++

Routine Description:

    Count TCHARS up to and including the double NULL.

Arguments:

    LPCTSTR lp       : TCHAR Stream

Return Value:

    Number of chars up to and including the double NULL

--*/
{
    int cChars = 0;

    for(;;)
    {
        ++cChars;
        if (lp[0] == _T('\0') && lp[1] == _T('\0'))
        {
            return ++cChars;
        }

        ++lp;
    }
}

int
CountWCharsToDoubleNull(
    IN PWCHAR lp
    )
/*++

Routine Description:

    Count TCHARS up to and including the double NULL.

Arguments:

    LPCTSTR lp       : TCHAR Stream

Return Value:

    Number of chars up to and including the double NULL

--*/
{
    int cChars = 0;

    for(;;)
    {
        ++cChars;
        if (lp[0] == L'\0' && lp[1] == L'\0')
        {
            return ++cChars;
        }

        ++lp;
    }
}


DWORD
ConvertDoubleNullListToStringList(
    IN  LPCTSTR lpstrSrc,
    OUT CStringList & strlDest,
    IN  int cChars                  OPTIONAL
    )
/*++

Routine Description:

    Convert a double null terminate list of null terminated strings to a more
    manageable CStringListEx

Arguments:

    LPCTSTR lpstrSrc       : Source list of strings
    CStringList & strlDest : Destination string list.
    int cChars             : Number of characters in double NULL list. if
                             -1, autodetermine length

Return Value:

    ERROR_SUCCESS if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    DWORD err = ERROR_SUCCESS;

    if (lpstrSrc == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (cChars < 0)
    {
        //
        // Calculate our own size.  This might be off if multiple
        // blank linkes (0) appear in the multi_sz, so the character
        // size is definitely preferable
        //
        cChars = CountCharsToDoubleNull(lpstrSrc);
    }

    try
    {
        strlDest.RemoveAll();

        if (cChars == 2 && *lpstrSrc == _T('\0'))
        {
            //
            // Special case: MULTI_SZ containing only
            // a double NULL are in fact blank entirely.
            //
            // N.B. IMHO this is a metabase bug -- RonaldM
            //
            --cChars;
        }

        //
        // Grab strings until only the final NULL remains
        //
        while (cChars > 1)
        {
            CString strTmp = lpstrSrc;
            strlDest.AddTail(strTmp);
            lpstrSrc += (strTmp.GetLength() + 1);
            cChars -= (strTmp.GetLength() + 1);
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!! exception building stringlist");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    return err;
}

DWORD
ConvertWDoubleNullListToStringList(
    IN  PWCHAR lpstrSrc,
    OUT CStringList & strlDest,
    IN  int cChars                  OPTIONAL
    )
/*++

Routine Description:

    Convert a double null terminate list of null terminated strings to a more
    manageable CStringListEx

Arguments:

    LPCTSTR lpstrSrc       : Source list of strings
    CStringList & strlDest : Destination string list.
    int cChars             : Number of characters in double NULL list. if
                             -1, autodetermine length

Return Value:

    ERROR_SUCCESS if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    DWORD err = ERROR_SUCCESS;

    if (lpstrSrc == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (cChars < 0)
    {
        //
        // Calculate our own size.  This might be off if multiple
        // blank linkes (0) appear in the multi_sz, so the character
        // size is definitely preferable
        //
        cChars = CountWCharsToDoubleNull(lpstrSrc);
    }

    try
    {
        strlDest.RemoveAll();

        if (cChars == 2 && *lpstrSrc == _T('\0'))
        {
            //
            // Special case: MULTI_SZ containing only
            // a double NULL are in fact blank entirely.
            //
            // N.B. IMHO this is a metabase bug -- RonaldM
            //
            --cChars;
        }

        //
        // Grab strings until only the final NULL remains
        //
        while (cChars > 1)
        {
            CString strTmp = lpstrSrc;
            strlDest.AddTail(strTmp);
            lpstrSrc += (strTmp.GetLength() + 1);
            cChars -= (strTmp.GetLength() + 1);
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!! exception building stringlist");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    return err;
}




DWORD
ConvertStringListToWDoubleNullList(
    IN  CStringList & strlSrc,
    OUT DWORD & cchDest,
    OUT LPWSTR & lpstrDest
    )
/*++

Routine Description:

    Flatten the string list into a WIDE double null terminated list
    of null terminated strings.

Arguments:

    CStringList & strlSrc : Source string list
    DWORD & cchDest       : Size in characters of the resultant array
                            (including terminating NULLs)
    LPTSTR & lpstrDest    : Allocated flat array.

Return Value:

    ERROR_SUCCESS if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    cchDest = 0;
    lpstrDest = NULL;
    BOOL fNullPad = FALSE;

    //
    // Compute total size in characters
    //
    POSITION pos;
    for(pos = strlSrc.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlSrc.GetNext(pos);

        TRACEEOLID(str);

        cchDest += str.GetLength() + 1;
    }

    if (!cchDest)
    {
        //
        // Special case: A totally empty MULTI_SZ
        // in fact consists of 2 (final) NULLS, instead
        // of 1 (final) NULL.  This is required by the
        // metabase, but should be a bug.  See note
        // at reversal function above.
        //
        ++cchDest;
        fNullPad = TRUE;
    }

    //
    // Remember final NULL
    //
    cchDest += 1;

    lpstrDest = AllocWString(cchDest);
    if (lpstrDest == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPWSTR pch = lpstrDest;
    LPWSTR pwstr;

    for(pos = strlSrc.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlSrc.GetNext(pos);


        // if we are not already UNICODE, we need to convert
#ifndef UNICODE
        pwstr = AllocWideString( (LPCTSTR)str );
#else
        pwstr = (LPWSTR)(LPCTSTR)str;
#endif
        if (pwstr == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(pch, pwstr);
        pch += str.GetLength();
        *pch++ = L'\0';

#ifndef UNICODE
        // clean up the temporary wide string
        FreeMem( pwstr );
#endif
    }

    *pch++ = L'\0';

    if (fNullPad)
    {
        *pch++ = L'\0';
    }

    return ERROR_SUCCESS;
}


DWORD
ConvertStringListToDoubleNullList(
    IN  CStringList & strlSrc,
    OUT DWORD & cchDest,
    OUT LPTSTR & lpstrDest
    )
/*++

Routine Description:

    Flatten the string list into a double null terminated list
    of null terminated strings.

Arguments:

    CStringList & strlSrc : Source string list
    DWORD & cchDest       : Size in characters of the resultant array
                            (including terminating NULLs)
    LPTSTR & lpstrDest    : Allocated flat array.

Return Value:

    ERROR_SUCCESS if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    cchDest = 0;
    lpstrDest = NULL;
    BOOL fNullPad = FALSE;

    //
    // Compute total size in characters
    //
    POSITION pos;
    for(pos = strlSrc.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlSrc.GetNext(pos);

        TRACEEOLID(str);

        cchDest += str.GetLength() + 1;
    }

    if (!cchDest)
    {
        //
        // Special case: A totally empty MULTI_SZ
        // in fact consists of 2 (final) NULLS, instead
        // of 1 (final) NULL.  This is required by the
        // metabase, but should be a bug.  See note
        // at reversal function above.
        //
        ++cchDest;
        fNullPad = TRUE;
    }

    //
    // Remember final NULL
    //
    cchDest += 1;

    lpstrDest = AllocTString(cchDest);
    if (lpstrDest == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPTSTR pch = lpstrDest;

    for(pos = strlSrc.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlSrc.GetNext(pos);

        lstrcpy(pch, (LPCTSTR)str);
        pch += str.GetLength();
        *pch++ = _T('\0');
    }

    *pch++ = _T('\0');

    if (fNullPad)
    {
        *pch++ = _T('\0');
    }

    return ERROR_SUCCESS;
}


int
ConvertSepLineToStringList(
    IN  LPCTSTR lpstrIn,
    OUT CStringList & strlOut,
    IN  LPCTSTR lpstrSep
    )
/*++

Routine Description:

    Convert a line containing multiple strings separated by
    a given character to a CStringListEx

Arguments:

    LPCTSTR lpstrIn         : Input line
    CStringListEx & strlOut : Output stringlist
    LPCTSTR lpstrSep        : List of separators

Return Value:

    The number of items added

--*/
{
    int cItems = 0;
    strlOut.RemoveAll();

    try
    {
        CString strSrc(lpstrIn);
        LPTSTR lp = strSrc.GetBuffer(0);
        lp = StringTok(lp, lpstrSep);

        while (lp)
        {
            CString str(lp);

            strlOut.AddTail(str);
            lp = StringTok(NULL, lpstrSep);
            ++cItems;
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Exception converting CSV list to stringlist");
        e->ReportError();
        e->Delete();
    }

    return cItems;
}




LPCTSTR
ConvertStringListToSepLine(
    IN  CStringList & strlIn,
    OUT CString & strOut,
    IN  LPCTSTR lpstrSep
    )
/*++

Routine Description:

    Convert stringlist into a single CString, each entry seperated by the given
    seperator string.

Arguments:

    CStringListEx & strlIn  : Input stringlist
    CString & strOut        : Output string
    LPCTSTR lpstrSep        : Seperator string

Return Value:

    Pointer to the output string.

--*/
{
    __try 
    {
        strOut.Empty();
        POSITION pos = strlIn.GetHeadPosition();
        BOOL      fAddSep = FALSE;

        while(pos)
        {
            CString & str = strlIn.GetNext(pos);

            if ( fAddSep )
            {
                strOut += lpstrSep;
            }

            if (str)
            {
                strOut += str;
            }
            fAddSep = TRUE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        iisDebugOut((LOG_TYPE_WARN, _T("nException Caught in ConvertStringListToSepLine()=0x%x.."),GetExceptionCode()));
    }

    return strOut;
}



LPTSTR
StringTok(
    IN LPTSTR string,
    IN LPCTSTR control
    )
/*++

Routine Description:

    strtok replacement function.

Arguments:

    LPTSTR string       : string, see strtok
    LPCTSTR control     : seperators, see strtok

Return Value:

    Pointer to string or NULL, see strtok.

Notes:

    This function is NOT thread-safe.

--*/
{
    LPTSTR str;
    LPCTSTR ctrl = control;

    TCHAR map[32];

    static LPTSTR nextoken;

    //
    // Clear control map
    //
    ZeroMemory(map, sizeof(map));

    //
    // Set bits in delimiter table
    //
    do
    {
        map[*ctrl >> 3] |= (1 << (*ctrl & 7));
    }
    while (*ctrl++);

    //
    // Initialize str. If string is NULL, set str to the saved
    // pointer (i.e., continue breaking tokens out of the string
    // from the last StringTok call)
    //
    if (string != NULL)
    {
        str = string;
    }
    else
    {
        str = nextoken;
    }

    //
    // Find beginning of token (skip over leading delimiters). Note that
    // there is no token iff this loop sets str to point to the terminal
    // null (*str == '\0').
    //
#ifdef UNICODE
    //
    // To avoid index overflow, check non-ASCII characters (UNICODE)
    //
    while (!(*str & 0xff00) &&
        (map[*str >> 3] & (1 << (*str & 7))) && *str)
#else
    while ((map[*str >> 3] & (1 << (*str & 7))) && *str)
#endif // UNICODE
    {
        ++str;
    }

    string = str;

    //
    // Find the end of the token. If it is not the end of the string,
    // put a null there.
    //
    for ( /**/ ; *str ; str++ )
    {
#ifdef UNICODE
        //
        // To avoid index overflow, check non-ASCII characters (UNICODE)
        //
        if ( !(*str & 0xff00) &&
            map[*str >> 3] & (1 << (*str & 7)) )
#else
        //
        // Skip DBCS character (ANSI)
        //
        if (IsDBCSLeadByte(*str) && *(str + 1))
        {
            ++str;
        }
        else if ( map[*str >> 3] & (1 << (*str & 7)) )
#endif // UNICODE
        {
            *str++ = '\0';
            break;
        }
    }

    //
    // Update nextoken structure
    //
    nextoken = str;

    //
    // Determine if a token has been found.
    //
    return string != str ? string : NULL;
}



BOOL
CStringListEx::operator ==(
    IN const CStringList & strl
    )
/*++

Routine Description:

    Compare against CStringList.  In order for two CStringLists to match,
    they must match in every element, which must be in the same order.

Arguments:

    CStringList strl       : String list to compare against.

Return Value:

    TRUE if the two string lists are identical

--*/
{
    if (strl.GetCount() != GetCount())
    {
        return FALSE;
    }

    POSITION posa = strl.GetHeadPosition();
    POSITION posb = GetHeadPosition();

    while (posa)
    {
        ASSERT(posa);
        ASSERT(posb);

        CString & strA = strl.GetNext(posa);
        CString & strB = GetNext(posb);

        if (strA != strB)
        {
            return FALSE;
        }
    }

    return TRUE;
}


/*
void
CopyCList(
    OUT CStringList & strlDest,
    IN  CStringList & strlSrc
    )
/*++

Routine Description:

    Assign one stringlist to another.  This is a simple member by member
    copy.

Arguments:

    CStringList & strlDest      : Destination stringlist
    CStringList & strlSrc       : Source stringlist

Return Value:

    None

--/
{
    strlDest.RemoveAll();
    POSITION pos = strlSrc.GetHeadPosition();
    while(pos)
    {
        CString & str = strlSrc.GetNext(pos);
        strlDest.AddTail(str);
    }
}


*/

CStringListEx & 
CStringListEx::operator =(
    IN const CStringList & strl
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    const CStringList & strl        : Source stringlist

Return Value:

    Reference to this

--*/
{
    RemoveAll();
    POSITION pos = strl.GetHeadPosition();
    while(pos)
    {
        CString & str = strl.GetNext(pos);
        AddTail(str);
    }

    return *this;
}



BOOL
SplitUserNameAndDomain(
    IN OUT CString & strUserName,
    IN CString & strDomainName
    )
/*++

Routine Description:

    Split the user name and domain from the given
    username, which is in the format "domain\user".

    Return TRUE if the user name contained a domain
    FALSE if it did not

Arguments:

    CString & strUserName   : User name which may contain a domain name
    CString & strDomainName : Output domain name ("." if local)

Return Value:

    TRUE if a domain is split off

--*/
{
    //
    // Assume local
    //
    strDomainName = _T(".");
    int nSlash = strUserName.Find(_T("\\"));
    if (nSlash >= 0)
    {
        strDomainName = strUserName.Left(nSlash);
        strUserName = strUserName.Mid(nSlash + 1);

        return TRUE;
    }

    return FALSE;
}






const LPCTSTR g_cszMonths[] =
{
    _T("Jan"),
    _T("Feb"),
    _T("Mar"),
    _T("Apr"),
    _T("May"),
    _T("Jun"),
    _T("Jul"),
    _T("Aug"),
    _T("Sep"),
    _T("Oct"),
    _T("Nov"),
    _T("Dec"),
};



const LPCTSTR g_cszWeekDays[] =
{
    _T("Sun"),
    _T("Mon"),
    _T("Tue"),
    _T("Wed"),
    _T("Thu"),
    _T("Fri"),
    _T("Sat"),
};



inline BOOL SkipTillDigit(LPCTSTR & lp)
{
    while (lp && *lp && !_istdigit(*lp)) ++lp;

    return lp != NULL;
}



inline BOOL SkipPastDigits(LPCTSTR & lp)
{
    while (lp && *lp && _istdigit(*lp)) ++lp;

    return lp != NULL;
}



BOOL
FetchIntField(
    LPCTSTR & lp,
    int & n
    )
{
    if (SkipTillDigit(lp))
    {
        n = _ttoi(lp);
        if (n < 0)
        {
            ASSERT(FALSE && "Bogus string->int");
            return FALSE;
        }

        return SkipPastDigits(lp);
    }

    return FALSE;
}



BOOL
MatchString(
    LPCTSTR lpTarget,
    const LPCTSTR * rglp,
    int cElements,
    int & idx
    )
{
    for (idx = 0; idx < cElements; ++idx)
    {
        if (!_tcsnicmp(lpTarget, rglp[idx], _tcslen(rglp[idx])))
        {
            return TRUE;
        }
    }

    return FALSE;
}



static g_dwCurrentTimeZone = TIME_ZONE_ID_INVALID;
static TIME_ZONE_INFORMATION g_tzInfo;


//
// International numeric strings
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Initialize library
//
BOOL
InitIntlSettings()
{
#ifdef _MT
    INITIALIZE_CRITICAL_SECTION(&_csSect);
#endif // _MT

    return CINumber::Allocate();
}



//
// De-initialize library
//
void
TerminateIntlSettings()
{
    CINumber::DeAllocate();

#ifdef _MT
    DeleteCriticalSection(&_csSect);
#endif // _MT
}



//
// Static Member Initialization
//
CString * CINumber::s_pstrThousandSeperator = NULL;
CString * CINumber::s_pstrDecimalPoint = NULL;
CString * CINumber::s_pstrBadNumber = NULL;
CString * CINumber::s_pstrCurrency = NULL;
CString * CINumber::s_pstr = NULL;
BOOL CINumber::s_fAllocated = FALSE;
BOOL CINumber::s_fCurrencyPrefix = TRUE;
BOOL CINumber::s_fInitialized = FALSE;



#ifdef _DOS



BOOL
_dos_getintlsettings(
    OUT INTLFORMAT * pStruct
    )
/*++

Routine Description:

    Get the international settings on a DOS box

Parameters:

    INTLFORMAT * pStruct : Structure to be filled in.

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    TRACEEOLID("[_dos_getintlsetting]");
    union _REGS inregs, outregs;
    struct _SREGS segregs;

    inregs.h.ah = 0x38;   // Intl call
    inregs.h.al = 0x00;   // Current country code
    inregs.x.bx = 0x00;   // Current country code

    segregs.ds  = _FP_SEG(pStruct);
    inregs.x.dx = _FP_OFF(pStruct);

    int nError = _intdosx(&inregs, &outregs, &segregs);

    return outregs.x.cflag == 0;
}

#endif // _DOS



/* protected */
CINumber::CINumber()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    None

--*/
{
    if (!CINumber::s_fInitialized)
    {
        CINumber::Initialize();
    }
}



CINumber::~CINumber()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{
}



/* protected */
/* static */
BOOL
CINumber::Allocate()
/*++

Routine Description:

    Allocate with US settings

Arguments:

    None

Return Value:

    TRUE if allocation was successfull, FALSE otherwise

--*/
{
    RaiseThreadProtection();

    ASSERT(!IsAllocated());
    if (!IsAllocated())
    {
        try
        {
            CINumber::s_pstrThousandSeperator = new CString(_T(","));
            CINumber::s_pstrDecimalPoint = new CString(_T("."));
            CINumber::s_pstrBadNumber = new CString(_T("--"));
            CINumber::s_pstrCurrency = new CString(_T("$ "));
            CINumber::s_pstr = new CString;
            s_fAllocated = TRUE;
        }
        catch(CMemoryException * e)
        {
            TRACEEOLID("Initialization Failed");
            e->ReportError();
            e->Delete();
        }
    }

    LowerThreadProtection();

    return IsAllocated();
}



/* protected */
/* static */
void
CINumber::DeAllocate()
/*++

Routine Description:

    Clean up allocations

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    RaiseThreadProtection();
    
    ASSERT(IsAllocated());
    if (IsAllocated())
    {
        MAKE_NULL(CINumber::s_pstrThousandSeperator);
        MAKE_NULL(CINumber::s_pstrDecimalPoint);
        MAKE_NULL(CINumber::s_pstrBadNumber);
        MAKE_NULL(CINumber::s_pstrCurrency);
        MAKE_NULL(CINumber::s_pstr);
    }

    LowerThreadProtection();

    s_fAllocated = FALSE;
}



/* static */
/* protected */
BOOL
CINumber::Initialize(
    IN BOOL fUserSetting /* TRUE */
    )
/*++

Routine Description:

    Initialize all the international settings, such as thousand
    seperators and decimal points

Parameters:

    BOOL    fUserSetting        If TRUE, use current user settings,
                                if FALSE use system settings.
Return Value:

    TRUE for success, FALSE for failure

Notes:

    Note that this function only needs to be explicitly called
    when the country settings have changed, or when system
    settings are desired (user is default)

--*/
{
#define MAXLEN  6

    int cErrors = 0;

    TRACEEOLID("Getting locale-dependend information");

    ASSERT(IsAllocated());
    if (!IsAllocated())
    {
        Allocate();
    }

    RaiseThreadProtection();

    try
    {

#if defined(_MAC)

        TRACEEOLID("Couldn't get international settings from system");

#elif defined(_WIN32)

        LCID lcid = fUserSetting
            ? ::GetUserDefaultLCID()
            : GetSystemDefaultLCID();

        LCTYPE lctype = fUserSetting ? 0 : LOCALE_NOUSEROVERRIDE;

        //
        // Get Decimal Point
        //
        if (!::GetLocaleInfo(
            lcid,
            LOCALE_SDECIMAL | lctype,
            CINumber::s_pstrDecimalPoint->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get intl decimal point");
            ++cErrors;
        }

        CINumber::s_pstrDecimalPoint->ReleaseBuffer();

        //
        // Get Thousand Seperator
        //
        if (!::GetLocaleInfo(
            lcid, LOCALE_STHOUSAND | lctype,
            CINumber::s_pstrThousandSeperator->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get 1000 seperator");
            ++cErrors;
        }

        CINumber::s_pstrThousandSeperator->ReleaseBuffer();

#ifndef _UNICODE

        //
        // Some countries have a space as a 1000 seperator,
        // but for some reason, this is ansi 160, which
        // shows up as a space fine on windows apps,
        // looks like garbage on console apps.
        //
        if ((*CINumber::s_pstrThousandSeperator)[0] == CHAR(160))
        {
            CINumber::s_pstrThousandSeperator->SetAt(0, ' ');
            TRACEEOLID("Space 1000 seperator substituted");
        }

#endif // _UNICODE

        //
        // Get currency symbol
        //
        if (!::GetLocaleInfo(
            lcid,
            LOCALE_SCURRENCY | lctype,
            CINumber::s_pstrCurrency->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get currency symbol");
            ++cErrors;
        }

        CINumber::s_pstrCurrency->ReleaseBuffer();

#elif defined(_WIN16)

        //
        // Get Decimal Point
        //
        ::GetProfileString(
            "Intl",
            "sDecimal",
            ".",
            CINumber::s_pstrDecimalPoint->GetBuffer(MAXLEN),
            MAXLEN
            );
        CINumber::s_pstrDecimalPoint->ReleaseBuffer();

        //
        // Get 1000 seperator
        //
        ::GetProfileString(
            "Intl",
            "sThousand",
            ",",
            CINumber::s_pstrThousandSeperator->GetBuffer(MAXLEN),
            MAXLEN
            );
        CINumber::s_pstrThousandSeperator->ReleaseBuffer();

        //
        // Get currency symbol
        //
        ::GetProfileString(
            "Intl",
            "sCurrency",
            ",",
            CINumber::s_pstrCurrency->GetBuffer(MAXLEN),
            MAXLEN
            );
        CINumber::s_pstrCurrency->ReleaseBuffer();

#elif defined(_DOS)

        INTLFORMAT fm;

        if (_dos_getintlsettings(&fm))
        {
            //
            // Get Decimal Point
            //
            *CINumber::s_pstrDecimalPoint = fm.szDecimalPoint;

            //
            // Get 1000 seperator
            //
            *CINumber::s_pstrThousandSeperator = fm.szThousandSep;

            //
            // Get Currency Symbol
            //
            *CINumber::s_pstrCurrency = fm.szCurrencySymbol;
        }
        else
        {
            TRACEEOLID("Unable to get intl settings");
            ++cErrors;
        }

#endif // _WIN32 etc

    }

    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception in getting intl settings:");
        e->ReportError();
        e->Delete();
        ++cErrors;
    }

    TRACEEOLID("Thousand Seperator . . . . . : " << *CINumber::s_pstrThousandSeperator);
    TRACEEOLID("Decimal Point  . . . . . . . : " << *CINumber::s_pstrDecimalPoint);
    TRACEEOLID("Currency Symbol. . . . . . . : " << *CINumber::s_pstrCurrency);
    TRACEEOLID("Bad number . . . . . . . . . : " << *CINumber::s_pstrBadNumber);
    TRACEEOLID("Currency Prefix. . . . . . . : " << CINumber::s_fCurrencyPrefix);

    CINumber::s_fInitialized = TRUE;

    LowerThreadProtection();

    return cErrors == 0;
}



/* static */
double
CINumber::BuildFloat(
    IN const LONG lInteger,
    IN const LONG lFraction
    )
/*++

Return Value:

    Combine integer and fraction to form float

Parameters:

    const LONG lInteger       Integer portion
    const LONG lFraction      Fractional portion

Return Value:

    float value

--*/
{
    double flValue = 0.0;

    //
    // Negative fractions?
    //
    ASSERT(lFraction >= 0);

    if (lFraction >= 0)
    {
        flValue = (double)lFraction;
        while (flValue >= 1.0)
        {
            flValue /= 10.0;
        }

        //
        // Re-add (or subtract if the original number
        // was negative) the fractional part
        //
        if (lInteger > 0L)
        {
            flValue += (double)lInteger;
        }
        else
        {
            flValue -= (double)lInteger;
            flValue = -flValue;
        }
    }

    return flValue;
}



/* static */
LPCTSTR
CINumber::ConvertLongToString(
    IN  const LONG lSrc,
    OUT CString & str
    )
/*++

CINumber::ConvertLongToString

Purpose:

    Convert long number to string with 1000 seperators

Parameters:

    const LONG lSrc         Source number
    CString & str           String to write to

Return Value:

    Pointer to converted string

--*/
{
    LPTSTR lpOutString = str.GetBuffer(16);

    //
    // Forget about the negative sign for now.
    //
    LONG lNum = (lSrc >= 0L) ? lSrc : -lSrc;
    int outstrlen = 0;
    do
    {
        lpOutString[outstrlen++] = _T('0') + (TCHAR)(lNum % 10L);
        lNum /= 10L;

        //
        // if more digits left and we're on a 1000 boundary (printed 3 digits,
        // or 3 digits + n*(3 digits + 1 comma), then print a 1000 separator.
        // Note: will only work if the 1000 seperator is 1 character.
        //
        ASSERT(CINumber::s_pstrThousandSeperator->GetLength() == 1);
        if (lNum != 0L && (outstrlen == 3 || outstrlen == 7 || outstrlen == 11))
        {
            lstrcpy(lpOutString + outstrlen, *CINumber::s_pstrThousandSeperator);
            outstrlen += CINumber::s_pstrThousandSeperator->GetLength();
        }

    }
    while (lNum > 0L);

    //
    // Add a negative sign if necessary.
    //
    if (lSrc < 0L)
    {
        lpOutString[outstrlen++] = _T('-');
    }

    str.ReleaseBuffer(outstrlen);
    str.MakeReverse();

    return (LPCTSTR)str;
}



/* static */
LPCTSTR
CINumber::ConvertFloatToString(
    IN const double flSrc,
    IN int nPrecision,
    OUT CString & str
    )
/*++

Routine Description:

    Convert floating point number to string represenation

Parameters:

    const double flSrc          Source floating point number
    int nPrecision              Number of decimal points
    CString & str               String to convert to

Return Value:

    Pointer to converted string.

--*/
{
    //
    // Forget about the negative sign for now,
    // and the fractional portion.
    //
    TCHAR szFraction[256];
    LPCTSTR lpFraction = NULL;

    ::_stprintf(szFraction, _T("%.*f"), nPrecision, flSrc);
    lpFraction = ::_tcschr(szFraction, _T('.') );
    ASSERT(lpFraction != NULL);
    ++lpFraction;

    CINumber::ConvertLongToString((LONG)flSrc, str);

    str += *CINumber::s_pstrDecimalPoint + lpFraction;

    return (LPCTSTR)str;
}



/* static */
BOOL
CINumber::ConvertStringToLong(
    IN  LPCTSTR lpsrc,
    OUT LONG & lValue
    )
/*++

Routine Description:

    Convert string to long integer.  1000 Seperators will be treated
    correctly.

Parameters:

    LPCTSTR lpsrc       Source string
    LONG & lValue       Value to convert to.  Will be 0 in case of error

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    CString strNumber(lpsrc);
    LONG lBase = 1L;
    BOOL fNegative = FALSE;

    lValue = 0L;

    //
    // Empty strings are invalid
    //
    if (strNumber.IsEmpty())
    {
        return FALSE;
    }

    //
    // Check for negative sign (at the end only)
    //
    if (strNumber[0] == _T('-'))
    {
        fNegative = TRUE;
    }

    strNumber.MakeReverse();

    //
    // Strip negative sign
    //
    if (fNegative)
    {
        strNumber.ReleaseBuffer(strNumber.GetLength()-1);
    }

    //
    // Make sure the 1000 seperator is only 1 char.  See note below
    //
    ASSERT(CINumber::s_pstrThousandSeperator->GetLength() == 1);
    for (int i = 0; i < strNumber.GetLength(); ++i)
    {
        if ((strNumber[i] >= _T('0')) && (strNumber[i] <= _T('9')))
        {
            LONG lDigit = (LONG)(strNumber[i] - _T('0'));
            if (lDigit != 0L)
            {
                LONG lOldValue = lValue;
                LONG lDelta = (lDigit * lBase);
                if (lDelta / lDigit != lBase)
                {
                    TRACEEOLID("Overflow!");
                    lValue = 0x7fffffff;

                    return FALSE;
                }

                lValue += lDelta;
                if (lValue - lDelta != lOldValue)
                {
                    TRACEEOLID("Overflow!");
                    lValue = 0x7fffffff;

                    return FALSE;
                }
            }

            lBase *= 10L;
        }
        //
        // It's not a digit, maybe a thousand seperator?
        // CAVEAT: If a thousand seperator of more than
        //         one character is used, this won't work.
        //
        else if ((strNumber[i] != (*CINumber::s_pstrThousandSeperator)[0])
             || (i != 3) && (i != 7) && (i != 11))
        {
            //
            // This is just invalid, since it is not a thousand
            // seperator in the proper location, nor a negative
            // sign.
            //
            TRACEEOLID("Invalid character " << (BYTE)strNumber[i] << " encountered");
            return FALSE;
        }
    }

    if (fNegative)
    {
        lValue = -lValue;
    }

    return TRUE;
}



/* static */
BOOL
CINumber::ConvertStringToFloat(
    IN  LPCTSTR lpsrc,
    OUT double & flValue
    )
/*++

Routine Description:

    Convert fully decorated floating point string to double

Parameters:

    LPCTSTR lpsrc       Source string
    double & flValue    float value generated from string

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    CString strNumber(lpsrc);

    //
    // This only works if the decimal point is a
    // single character
    //
    ASSERT(CINumber::s_pstrDecimalPoint->GetLength() == 1);

    //
    // Strip off the > 0 part
    //
    LONG lFraction = 0;

    int nPoint = strNumber.ReverseFind((*CINumber::s_pstrDecimalPoint)[0]);

    if (nPoint >= 0)
    {
        //
        // Convert fractional part
        //
        LPCTSTR lpszFraction = (LPCTSTR)strNumber + ++nPoint;
        lFraction = ::_ttol(lpszFraction);
        strNumber.ReleaseBuffer(--nPoint);
    }

    //
    // Convert integer part
    //
    LONG lInteger;
    if (ConvertStringToLong(strNumber, lInteger))
    {
        flValue = CINumber::BuildFloat(lInteger, lFraction);
        return TRUE;
    }

    return FALSE;
}



CILong::CILong()
/*++

Routine Description:

    Constructor without arguments

Parameters:

    None.

Return Value:

    N/A

--*/
    : m_lValue(0L)
{
}



CILong::CILong(
    IN LONG lValue
    )
/*++

Routine Description:

    Constructor taking LONG argument

Parameters:

    LONG lValue     Value to be set

Return Value:

    N/A

--*/
    : m_lValue(lValue)
{
}



CILong::CILong(
    IN LPCTSTR lpszValue
    )
/*++

Routine Description:

    Constructor taking string argument

Parameters:

    LPCTSTR lpszValue       String number

Return Value:

    N/A

--*/
{
    ConvertStringToLong(lpszValue, m_lValue);
}



CILong &
CILong::operator =(
    IN LONG lValue
    )
/*++

Routine Description:

    Assignment operator taking long value

Parameters:

    LONG lValue     Value to be set

Return Value:

    this object

--*/
{
    m_lValue = lValue;

    return *this;
}



CILong &
CILong::operator =(
    IN LPCTSTR lpszValue
    )
/*++

Routine Description:

    Assignment operator taking string value

Parameters:

    LPCTSTR lpszValue       String number

Return Value:

    this object

--*/
{
    ConvertStringToLong(lpszValue, m_lValue);

    return *this;
}



//
// Arithmetic Shorthand operators
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CILong &
CILong::operator +=(
    IN const LONG lValue
    )
{
    m_lValue += lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator +=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue += lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator +=(
    IN const CILong& value
    )
{
    m_lValue += value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const LONG lValue
    )
{
    m_lValue -= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue -= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const CILong& value
    )
{
    m_lValue -= value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const LONG lValue
    )
{
    m_lValue *= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue *= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const CILong& value
    )
{
    m_lValue *= value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const LONG lValue
    )
{
    if (lValue != 0)
    {
        m_lValue /= lValue;
    }

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    if (0 == lValue)
    {
        m_lValue = 0;
    }
    else
    {
        m_lValue /= lValue;
    }

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const CILong& value
    )
{
    m_lValue /= value.m_lValue;

    return *this;
}



CIFloat::CIFloat(
    IN int nPrecision
    )
/*++

Routine Description:

    Constructor without arguments

Parameters:

    int nPrecision              Number of decimal digits in string,

Return Value:

    N/A

--*/
    : m_flValue(0.0),
      m_nPrecision(nPrecision)
{
}



CIFloat::CIFloat(
    IN double flValue,
    IN int nPrecision
    )
/*++

Routine Description:

    Constructor taking double argument

Parameters:

    double flValue              Value to be set
    int nPrecision              Number of decimal digits in string,

Return Value:

    N/A

--*/
    : m_flValue(flValue),
      m_nPrecision(nPrecision)
{
}



CIFloat::CIFloat(
    IN LONG lInteger,
    IN LONG lFraction,
    IN int nPrecision
    )
/*++

Routine Description:

    Constructor taking integer and fraction argument

Parameters:

    LONG lInteger               Integer portion
    LONG lFraction              Fractional portion
    int nPrecision              Number of decimal digits in string,

Return Value:

    N/A

--*/
    : m_nPrecision(nPrecision)
{
    m_flValue = CINumber::BuildFloat(lInteger, lFraction);
}



CIFloat::CIFloat(
    IN LPCTSTR lpszValue,
    IN int nPrecision
    )
/*++

Routine Description:

    Constructor taking string argument

Parameters:

    LPCTSTR lpszValue           String number
    int nPrecision              Number of decimal digits in string,

Return Value:

    N/A

--*/
    : m_nPrecision(nPrecision)
{
    ConvertStringToFloat(lpszValue, m_flValue);
}



CIFloat &
CIFloat::operator =(
    IN double flValue
    )
/*++

Routine Description:

    Assignment operator taking double value

Parameters:

    double flValue     Value to be set

Return Value:

    this object

--*/
{
    m_flValue = flValue;

    return *this;
}



CIFloat &
CIFloat::operator =(
    IN LPCTSTR lpszValue
    )
/*++

Routine Description:

    Assignment operator taking string value

Parameters:

    LPCTSTR lpszValue       String number

Return Value:

    this object

--*/
{
    ConvertStringToFloat(lpszValue, m_flValue);

    return *this;
}



//
// Arithmetic Shorthand operators
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIFloat &
CIFloat::operator +=(
    IN const double flValue
    )
{
    m_flValue += flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator +=(
    IN const LPCTSTR lpszValue
    )
{
    double flValue;

    ConvertStringToFloat(lpszValue, flValue);

    m_flValue += flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator +=(
    IN const CIFloat& value
    )
{
    m_flValue += value.m_flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator -=(
    IN const double flValue
    )
{
    m_flValue -= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator -=(
    IN const LPCTSTR lpszValue
    )
{
    double flValue;

    ConvertStringToFloat(lpszValue, flValue);

    m_flValue -= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator -=(
    IN const CIFloat& value
    )
{
    m_flValue -= value.m_flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator *=(
    IN const double flValue
    )
{
    m_flValue *= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator *=(
    IN const LPCTSTR lpszValue
    )
{
    double flValue;

    ConvertStringToFloat(lpszValue, flValue);

    m_flValue *= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator *=(
    IN const CIFloat& value
    )
{
    m_flValue *= value.m_flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator /=(
    IN const double flValue
    )
{
    m_flValue /= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator /=(
    IN const LPCTSTR lpszValue
    )
{
    double flValue;

    ConvertStringToFloat(lpszValue, flValue);
    if (flValue != 0)
    {
        m_flValue /= flValue;
    }

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator /=(
    IN const CIFloat& value
    )
{
    m_flValue /= value.m_flValue;

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\wolfpack.cpp ===
#include "stdafx.h"
#include "wolfpack.h"

#ifndef _CHICAGO_
#include    <windows.h>
#include    <stdio.h>
#include    <clusapi.h>
#include    <resapi.h>
#include    <helper.h>

#define INITIAL_RESOURCE_NAME_SIZE 256 // In characters not in bytes
#define IIS_RESOURCE_TYPE_NAME L"IIS Server Instance"
#define SMTP_RESOURCE_TYPE_NAME L"SMTP Server Instance"
#define NNTP_RESOURCE_TYPE_NAME L"NNTP Server Instance"

#define MAX_OFFLINE_RETRIES 5 // Number of times to try and take a resources offline before giving up 
#define DELAY_BETWEEN_CALLS_TO_OFFLINE 1000*2 // in milliseconds

CONST LPCWSTR scClusterPath = _T("System\\CurrentControlSet\\Services\\ClusSvc");
CONST LPCWSTR scClusterPath2 = _T("System\\CurrentControlSet\\Services\\ClusSvc\\Parameters");

CStringList gcstrListOfClusResources;

int g_ClusterSVCExist = -1; // -1 = not checked, 1 = exist, 0 = not exist

typedef DWORD
(WINAPI *PFN_RESUTILFINDSZPROPERTY)(
IN LPVOID lpTheProperty,
IN OUT LPDWORD nInBufferSize,
IN LPCWSTR lpszResourceTypeName,
OUT LPVOID lpOutBuffer);

typedef DWORD
(WINAPI *PFN_RESUTILFINDDWORDPROPERTY)(
IN LPVOID lpTheProperty,
IN OUT LPDWORD nInBufferSize,
IN LPCWSTR lpszResourceTypeName,
OUT LPDWORD pdwPropertyValue);

typedef DWORD
(WINAPI *PFN_CLUSTERRESOURCECONTROL)(
IN HRESOURCE hResource,
IN HNODE hNode,
IN DWORD dwControlCode,
IN LPVOID lpInBuffer,
IN OUT DWORD nInBufferSize,
OUT LPVOID lpOutBuffer,
IN OUT DWORD nOutBufferSize,
OUT LPDWORD lpBytesReturned
);


typedef HCLUSTER
(WINAPI *PFN_OPENCLUSTER)(
    IN LPCWSTR lpszClusterName
    );

typedef BOOL
(WINAPI *PFN_CLOSECLUSTER)(
    IN HCLUSTER hCluster
    );

typedef DWORD
(WINAPI *PFN_CREATECLUSTERRESOURCETYPE)(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszResourceTypeDll,
    IN DWORD dwLooksAlivePollInterval,
    IN DWORD dwIsAlivePollInterval
    );

typedef DWORD
(WINAPI *PFN_DELETECLUSTERRESOURCETYPE)(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName
    );

typedef HCLUSENUM
(WINAPI
*PFN_ClusterOpenEnum)(
    IN HCLUSTER hCluster,
    IN DWORD dwType
    );

typedef DWORD
(WINAPI
*PFN_ClusterEnum)(
    IN HCLUSENUM hEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcbName
    );

typedef DWORD
(WINAPI
*PFN_ClusterCloseEnum)(
    IN HCLUSENUM hEnum
    );

typedef HRESOURCE
(WINAPI
*PFN_OpenClusterResource)(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceName
    );

typedef BOOL
(WINAPI
*PFN_CloseClusterResource)(
    IN HRESOURCE hResource
    );

typedef DWORD
(WINAPI
*PFN_DeleteClusterResource)(
    IN HRESOURCE hResource
    );

typedef DWORD
(WINAPI
*PFN_OfflineClusterResource)(
    IN HRESOURCE hResource
    );

typedef HKEY
(WINAPI
*PFN_GetClusterResourceKey)(
    IN HRESOURCE hResource,
    IN REGSAM samDesired
    );

typedef LONG
(WINAPI
*PFN_ClusterRegCloseKey)(
    IN HKEY hKey
    );

typedef LONG
(WINAPI
*PFN_ClusterRegQueryValue)(
    IN HKEY hKey,
    IN LPCWSTR lpszValueName,
    OUT LPDWORD lpValueType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

typedef CLUSTER_RESOURCE_STATE
(WINAPI
*PFN_GetClusterResourceState)(
    IN HRESOURCE hResource,
    OUT OPTIONAL LPWSTR lpszNodeName,
    IN OUT LPDWORD lpcbNodeName,
    OUT OPTIONAL LPWSTR lpszGroupName,
    IN OUT LPDWORD lpcbGroupName
    );

typedef DWORD
(WINAPI *PFN_DLLREGISTERCLUADMINEXTENSION)(
    IN HCLUSTER hCluster
    );

typedef DWORD
(WINAPI *PFN_DLLUNREGISTERCLUADMINEXTENSION)(
    IN HCLUSTER hCluster
    );


void ListOfClusResources_Add(TCHAR * szEntry)
{
    //Add entry to the list if not already there
    if (_tcsicmp(szEntry, _T("")) != 0)
    {
        // Add it if it is not already there.
        if (TRUE != IsThisStringInThisCStringList(gcstrListOfClusResources, szEntry))
        {
            gcstrListOfClusResources.AddTail(szEntry);
            //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ListOfClusResources_Add:%s\n"),szEntry));
        }
    }
    return;
}


INT ListOfClusResources_Check(TCHAR * szEntry)
{
    int iReturn = FALSE;

    //Add entry to the list if not already there
    if (_tcsicmp(szEntry, _T("")) != 0)
    {
        // Return true if it's in there!
        iReturn = IsThisStringInThisCStringList(gcstrListOfClusResources, szEntry);
    }
    return iReturn;
}



BOOL
RegisterIisServerInstanceResourceType(
    LPWSTR pszResType,
    LPWSTR pszResTypeDisplayName,
    LPWSTR pszPath,
    LPWSTR pszAdminPath
    )
{
    HCLUSTER                        hC;
    DWORD                           dwErr = ERROR_SUCCESS;
    HINSTANCE                       hClusapi;
    PFN_OPENCLUSTER                 pfnOpenCluster;
    PFN_CLOSECLUSTER                pfnCloseCluster;
    PFN_CREATECLUSTERRESOURCETYPE   pfnCreateClusterResourceType;
    HRESULT                         hres;

    if ( hClusapi = LoadLibrary( L"clusapi.dll" ) )
    {
        pfnOpenCluster = (PFN_OPENCLUSTER)GetProcAddress( hClusapi, "OpenCluster" );
        pfnCloseCluster = (PFN_CLOSECLUSTER)GetProcAddress( hClusapi, "CloseCluster" );
        pfnCreateClusterResourceType = (PFN_CREATECLUSTERRESOURCETYPE)GetProcAddress( hClusapi, "CreateClusterResourceType" );

        if ( pfnOpenCluster &&
             pfnCloseCluster &&
             pfnCreateClusterResourceType )
        {
            if ( hC = pfnOpenCluster( NULL ) )
            {
                hres = pfnCreateClusterResourceType(
                    hC,
                    pszResType,
                    pszResType,
                    pszPath,
                    5000,
                    60000 );


                if ( SUCCEEDED( hres ) )
                {
                    HINSTANCE                           hAdmin;
                    PFN_DLLREGISTERCLUADMINEXTENSION    pfnDllRegisterCluAdminExtension;

                    if ( hAdmin = LoadLibrary( pszAdminPath ) )
                    {
                        pfnDllRegisterCluAdminExtension =
                            (PFN_DLLREGISTERCLUADMINEXTENSION)GetProcAddress( hAdmin, "DllRegisterCluAdminExtension" );
                        if ( pfnDllRegisterCluAdminExtension )
                        {
                            if ( FAILED(hres = pfnDllRegisterCluAdminExtension( hC )) )
                            {
                                dwErr = hres;
                            }
                        }
                        else
                        {
                            dwErr = GetLastError();
                        }
                        FreeLibrary( hAdmin );
                    }
                    else
                    {
                        dwErr = GetLastError();
                    }
                }
                else
                {
                    dwErr = hres;
                }

                pfnCloseCluster( hC );

                if ( dwErr )
                {
                    SetLastError( dwErr );
                }
            }
        }
        else
        {
            dwErr = GetLastError();
        }

        FreeLibrary( hClusapi );
    }
    else
    {
        dwErr = GetLastError();
    }

    return dwErr == ERROR_SUCCESS ? TRUE : FALSE;
}


BOOL
UnregisterIisServerInstanceResourceType(
    LPWSTR pszResType,
    LPWSTR pszAdminPath,
    BOOL   bGrabVRootFromResourceAndAddToIISVRoot,
    BOOL   bDeleteAfterMove
    )
{
    CStringArray cstrArryName, cstrArryPath;
    CStringArray cstrArryNameftp, cstrArryPathftp;

    HCLUSTER                        hC;
    DWORD                           dwErr = ERROR_SUCCESS;
    HINSTANCE                       hClusapi;
    PFN_OPENCLUSTER                 pfnOpenCluster;
    PFN_CLOSECLUSTER                pfnCloseCluster;
    PFN_DELETECLUSTERRESOURCETYPE   pfnDeleteClusterResourceType;
    PFN_ClusterOpenEnum             pfnClusterOpenEnum;
    PFN_ClusterEnum                 pfnClusterEnum;
    PFN_ClusterCloseEnum            pfnClusterCloseEnum;
    PFN_OpenClusterResource         pfnOpenClusterResource;
    PFN_CloseClusterResource        pfnCloseClusterResource;
    PFN_DeleteClusterResource       pfnDeleteClusterResource;
    PFN_OfflineClusterResource      pfnOfflineClusterResource;
    PFN_GetClusterResourceKey       pfnGetClusterResourceKey;
    PFN_ClusterRegCloseKey          pfnClusterRegCloseKey;
    PFN_ClusterRegQueryValue        pfnClusterRegQueryValue;
    PFN_GetClusterResourceState     pfnGetClusterResourceState;
    HRESULT                         hres;
    HCLUSENUM                       hClusEnum;
    WCHAR *                         pawchResName = NULL;
    WCHAR                           awchResName[256];
    WCHAR                           awchResType[256];
    DWORD                           dwEnum;
    DWORD                           dwType;
    DWORD                           dwStrLen;
    HRESOURCE                       hRes;
    HKEY                            hKey;
    BOOL                            fDel;
    DWORD                           dwRetry;

    hClusapi = NULL;
    hClusapi = LoadLibrary(L"clusapi.dll");
    if (!hClusapi)
    {
        hClusapi = NULL;
        iisDebugOut((LOG_TYPE_ERROR, _T("UnregisterIisServerInstanceResourceType:LoadLib clusapi.dll failed.\n")));
        goto UnregisterIisServerInstanceResourceType_Exit;
    }
    pfnOpenCluster = (PFN_OPENCLUSTER)GetProcAddress( hClusapi, "OpenCluster" );
    pfnCloseCluster = (PFN_CLOSECLUSTER)GetProcAddress( hClusapi, "CloseCluster" );
    pfnDeleteClusterResourceType = (PFN_DELETECLUSTERRESOURCETYPE)GetProcAddress( hClusapi, "DeleteClusterResourceType" );
    pfnClusterOpenEnum = (PFN_ClusterOpenEnum)GetProcAddress( hClusapi, "ClusterOpenEnum" );
    pfnClusterEnum = (PFN_ClusterEnum)GetProcAddress( hClusapi, "ClusterEnum" );
    pfnClusterCloseEnum = (PFN_ClusterCloseEnum)GetProcAddress( hClusapi, "ClusterCloseEnum" );
    pfnOpenClusterResource = (PFN_OpenClusterResource)GetProcAddress( hClusapi, "OpenClusterResource" );
    pfnCloseClusterResource = (PFN_CloseClusterResource)GetProcAddress( hClusapi, "CloseClusterResource" );
    pfnDeleteClusterResource = (PFN_DeleteClusterResource)GetProcAddress( hClusapi, "DeleteClusterResource" );
    pfnOfflineClusterResource = (PFN_OfflineClusterResource)GetProcAddress( hClusapi, "OfflineClusterResource" );
    pfnGetClusterResourceKey = (PFN_GetClusterResourceKey)GetProcAddress( hClusapi, "GetClusterResourceKey" );
    pfnClusterRegCloseKey = (PFN_ClusterRegCloseKey)GetProcAddress( hClusapi, "ClusterRegCloseKey" );
    pfnClusterRegQueryValue = (PFN_ClusterRegQueryValue)GetProcAddress( hClusapi, "ClusterRegQueryValue" );
    pfnGetClusterResourceState = (PFN_GetClusterResourceState)GetProcAddress( hClusapi, "GetClusterResourceState" );

    if ( !pfnOpenCluster ||
         !pfnCloseCluster ||
         !pfnDeleteClusterResourceType ||
         !pfnClusterOpenEnum ||
         !pfnClusterEnum ||
         !pfnClusterCloseEnum ||
         !pfnOpenClusterResource ||
         !pfnCloseClusterResource ||
         !pfnDeleteClusterResource ||
         !pfnOfflineClusterResource ||
         !pfnGetClusterResourceKey  ||
         !pfnClusterRegCloseKey ||
         !pfnClusterRegQueryValue ||
         !pfnGetClusterResourceState )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("UnregisterIisServerInstanceResourceType:clusapi.dll missing export function.failure.\n")));
        goto UnregisterIisServerInstanceResourceType_Exit;
    }

    hC = pfnOpenCluster(NULL);
    // if we can't open the cluster, then maybe there are none.
    if (!hC) {goto UnregisterIisServerInstanceResourceType_Exit;}

    // Delete all resources of type pszResType
    hClusEnum = pfnClusterOpenEnum(hC, CLUSTER_ENUM_RESOURCE);
    if (hClusEnum != NULL)
    {
        dwEnum = 0;
        int iClusterEnumReturn = ERROR_SUCCESS;

        // allocate the initial buffer for pawchResName
        dwStrLen = 256 * sizeof(WCHAR);
        pawchResName = NULL;
        pawchResName = (WCHAR *) malloc( dwStrLen );
        if (!pawchResName)
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("UnregisterIisServerInstanceResourceType: malloc FAILED.out of memory.\n")));
            goto UnregisterIisServerInstanceResourceType_Exit;
        }

        do
        {
            iClusterEnumReturn = ERROR_SUCCESS;
            iClusterEnumReturn = pfnClusterEnum( hClusEnum, dwEnum, &dwType, pawchResName, &dwStrLen );
            if (iClusterEnumReturn != ERROR_SUCCESS)
            {
                // Check if failed because it needs more space.
                if (iClusterEnumReturn == ERROR_MORE_DATA)
                {
	                // dwStrLen should be set to the required length returned from pfnClusterEnum
                    dwStrLen = (dwStrLen + 1) * sizeof(WCHAR);
                    pawchResName = (WCHAR *) realloc(pawchResName, dwStrLen);
                    if (!pawchResName)
                    {
                        iisDebugOut((LOG_TYPE_ERROR, _T("UnregisterIisServerInstanceResourceType: realloc FAILED.out of memory.\n")));
                        goto UnregisterIisServerInstanceResourceType_Exit;
                    }
                    // try it again.
                    iClusterEnumReturn = ERROR_SUCCESS;
                    iClusterEnumReturn = pfnClusterEnum( hClusEnum, dwEnum, &dwType, pawchResName, &dwStrLen );
                    if (iClusterEnumReturn != ERROR_SUCCESS)
                    {
                        iisDebugOut((LOG_TYPE_ERROR, _T("UnregisterIisServerInstanceResourceType: FAILED.err=0x%x.\n"), iClusterEnumReturn));
                        break;
                    }
                }
                else
                {
                    if (iClusterEnumReturn != ERROR_NO_MORE_ITEMS)
                    {
                        // failed for some other reason than no more data
                        iisDebugOut((LOG_TYPE_ERROR, _T("UnregisterIisServerInstanceResourceType: FAILED.err=0x%x.\n"), iClusterEnumReturn));
                    }
                    break;
                }
            }


            // proceed
            if ( hRes = pfnOpenClusterResource( hC, pawchResName ) )
            {
                if ( hKey = pfnGetClusterResourceKey( hRes, KEY_READ ) )
                {
                    dwStrLen = sizeof(awchResType)/sizeof(WCHAR);
                    // Check if it's for 'our' type of key (pszResType)
                    fDel = pfnClusterRegQueryValue( hKey, L"Type", &dwType, (LPBYTE)awchResType, &dwStrLen ) == ERROR_SUCCESS && !wcscmp( awchResType, pszResType );
                    pfnClusterRegCloseKey( hKey );

                    if ( fDel )
                    {
                        if (bDeleteAfterMove)
                        {
                            // Take the resource off line so that we can actually delete it, i guess.
                            pfnOfflineClusterResource( hRes );
                            for ( dwRetry = 0 ;dwRetry < 30 && pfnGetClusterResourceState( hRes,NULL,&dwStrLen,NULL,&dwStrLen ) != ClusterResourceOffline; ++dwRetry )
                            {
                                Sleep( 1000 );
                            }
                        }

                        // At this point we have successfully got the cluster to go offline
                        if (bGrabVRootFromResourceAndAddToIISVRoot)
                        {
                            // At this point we have successfully got the cluster to go offline

                            // Get the vroot names and path's here and stick into the arrays....
                            GetClusterIISVRoot(hRes, L"W3SVC", cstrArryName, cstrArryPath);

                            // Do it for FTP now.
                            GetClusterIISVRoot(hRes, L"MSFTPSVC", cstrArryNameftp, cstrArryPathftp);

                            // No need to do it for gopher since there is none.
                            //GetClusterIISVRoot(hRes, L"GOPHERSVC", cstrArryName, cstrArryPath);
                        }

                        // We have saved all the important data into our Array's
                        // now it's okay to delete the Resource
                        if (bDeleteAfterMove)
                        {
                            pfnDeleteClusterResource( hRes );
                        }
                    }
                }

                pfnCloseClusterResource( hRes );
            }

            // Increment to the next one
            ++dwEnum;

        } while(TRUE);

        pfnClusterCloseEnum( hClusEnum );
    }

    if (bDeleteAfterMove)
    {
        dwErr = pfnDeleteClusterResourceType(hC,pszResType );

        HINSTANCE hAdmin;
        if ( hAdmin = LoadLibrary( pszAdminPath ) )
        {
            PFN_DLLUNREGISTERCLUADMINEXTENSION  pfnDllUnregisterCluAdminExtension;
            pfnDllUnregisterCluAdminExtension = (PFN_DLLUNREGISTERCLUADMINEXTENSION)GetProcAddress( hAdmin, "DllUnregisterCluAdminExtension" );
            if ( pfnDllUnregisterCluAdminExtension )
            {
                if ( FAILED(hres = pfnDllUnregisterCluAdminExtension( hC )) )
                {
                    dwErr = hres;
                }
            }
            else
            {
                dwErr = GetLastError();
            }
            FreeLibrary( hAdmin );
        }
        else
        {
            dwErr = GetLastError();
        }
    }

    pfnCloseCluster( hC );

    if (dwErr)
        {SetLastError( dwErr );}

UnregisterIisServerInstanceResourceType_Exit:
    // Copy these to the iis virtual root registry....
    MoveVRootToIIS3Registry(REG_W3SVC,cstrArryName,cstrArryPath);
    // Copy these to the iis virtual root registry....
    MoveVRootToIIS3Registry(REG_MSFTPSVC,cstrArryNameftp,cstrArryPathftp);

    if (hClusapi) {FreeLibrary(hClusapi);}
    if (pawchResName) {free(pawchResName);}
    return dwErr == ERROR_SUCCESS ? TRUE : FALSE;
}


void TestClusterRead(LPWSTR pszClusterName)
{
    iisDebugOut_Start(_T("TestClusterRead"));

    LPWSTR pszResType = L"IIS Virtual Root";

    CStringArray cstrArryName, cstrArryPath;
    CStringArray cstrArryNameftp, cstrArryPathftp;

    HCLUSTER                        hC;
    DWORD                           dwErr = ERROR_SUCCESS;
    HINSTANCE                       hClusapi;
    PFN_OPENCLUSTER                 pfnOpenCluster;
    PFN_CLOSECLUSTER                pfnCloseCluster;
    PFN_DELETECLUSTERRESOURCETYPE   pfnDeleteClusterResourceType;
    PFN_ClusterOpenEnum             pfnClusterOpenEnum;
    PFN_ClusterEnum                 pfnClusterEnum;
    PFN_ClusterCloseEnum            pfnClusterCloseEnum;
    PFN_OpenClusterResource         pfnOpenClusterResource;
    PFN_CloseClusterResource        pfnCloseClusterResource;
    PFN_DeleteClusterResource       pfnDeleteClusterResource;
    PFN_OfflineClusterResource      pfnOfflineClusterResource;
    PFN_GetClusterResourceKey       pfnGetClusterResourceKey;
    PFN_ClusterRegCloseKey          pfnClusterRegCloseKey;
    PFN_ClusterRegQueryValue        pfnClusterRegQueryValue;
    PFN_GetClusterResourceState     pfnGetClusterResourceState;
    HRESULT                         hres;
    HCLUSENUM                       hClusEnum;
    WCHAR *                         pawchResName = NULL;
    WCHAR                           awchResName[256];
    WCHAR                           awchResType[256];
    DWORD                           dwEnum;
    DWORD                           dwType;
    DWORD                           dwStrLen;
    HRESOURCE                       hRes;
    HKEY                            hKey;
    BOOL                            fDel;
    DWORD                           dwRetry;

    hClusapi = NULL;
    hClusapi = LoadLibrary(L"clusapi.dll");
    if (!hClusapi)
    {
        hClusapi = NULL;
        iisDebugOut((LOG_TYPE_TRACE, _T("fail 1\n")));
        goto TestClusterRead_Exit;
    }
    pfnOpenCluster = (PFN_OPENCLUSTER)GetProcAddress( hClusapi, "OpenCluster" );
    pfnCloseCluster = (PFN_CLOSECLUSTER)GetProcAddress( hClusapi, "CloseCluster" );
    pfnDeleteClusterResourceType = (PFN_DELETECLUSTERRESOURCETYPE)GetProcAddress( hClusapi, "DeleteClusterResourceType" );
    pfnClusterOpenEnum = (PFN_ClusterOpenEnum)GetProcAddress( hClusapi, "ClusterOpenEnum" );
    pfnClusterEnum = (PFN_ClusterEnum)GetProcAddress( hClusapi, "ClusterEnum" );
    pfnClusterCloseEnum = (PFN_ClusterCloseEnum)GetProcAddress( hClusapi, "ClusterCloseEnum" );
    pfnOpenClusterResource = (PFN_OpenClusterResource)GetProcAddress( hClusapi, "OpenClusterResource" );
    pfnCloseClusterResource = (PFN_CloseClusterResource)GetProcAddress( hClusapi, "CloseClusterResource" );
    pfnDeleteClusterResource = (PFN_DeleteClusterResource)GetProcAddress( hClusapi, "DeleteClusterResource" );
    pfnOfflineClusterResource = (PFN_OfflineClusterResource)GetProcAddress( hClusapi, "OfflineClusterResource" );
    pfnGetClusterResourceKey = (PFN_GetClusterResourceKey)GetProcAddress( hClusapi, "GetClusterResourceKey" );
    pfnClusterRegCloseKey = (PFN_ClusterRegCloseKey)GetProcAddress( hClusapi, "ClusterRegCloseKey" );
    pfnClusterRegQueryValue = (PFN_ClusterRegQueryValue)GetProcAddress( hClusapi, "ClusterRegQueryValue" );
    pfnGetClusterResourceState = (PFN_GetClusterResourceState)GetProcAddress( hClusapi, "GetClusterResourceState" );

    if ( !pfnOpenCluster ||
         !pfnCloseCluster ||
         !pfnDeleteClusterResourceType ||
         !pfnClusterOpenEnum ||
         !pfnClusterEnum ||
         !pfnClusterCloseEnum ||
         !pfnOpenClusterResource ||
         !pfnCloseClusterResource ||
         !pfnDeleteClusterResource ||
         !pfnOfflineClusterResource ||
         !pfnGetClusterResourceKey  ||
         !pfnClusterRegCloseKey ||
         !pfnClusterRegQueryValue ||
         !pfnGetClusterResourceState )
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("fail 2\n")));
        goto TestClusterRead_Exit;
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("try to open cluster=%s\n"),pszClusterName));
    // try to open the cluster on the computer
    if ( hC = pfnOpenCluster( pszClusterName ) )
    {
        //
        // Delete all resources of type pszResType
        //
        if ( (hClusEnum = pfnClusterOpenEnum( hC, CLUSTER_ENUM_RESOURCE )) != NULL )
        {
            dwEnum = 0;
            int iClusterEnumReturn = ERROR_SUCCESS;

            // allocate the initial buffer for pawchResName
            dwStrLen = 256 * sizeof(WCHAR);
            pawchResName = NULL;
            pawchResName = (LPTSTR) malloc( dwStrLen );
            if (!pawchResName)
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("TestClusterRead: malloc FAILED.out of memory.\n")));
                goto TestClusterRead_Exit;
            }

            do
            {
                iClusterEnumReturn = pfnClusterEnum( hClusEnum, dwEnum, &dwType, pawchResName, &dwStrLen );
                if (iClusterEnumReturn != ERROR_SUCCESS)
                {
                    // Check if failed because it needs more space.
                    if (iClusterEnumReturn == ERROR_MORE_DATA)
                    {
                        // dwStrLen should be set to the required length returned from pfnClusterEnum
                        dwStrLen = (dwStrLen + 1) * sizeof(WCHAR);
                        pawchResName = (LPTSTR) realloc(pawchResName, dwStrLen);
                        if (!pawchResName)
                        {
                            iisDebugOut((LOG_TYPE_ERROR, _T("TestClusterRead: realloc FAILED.out of memory.\n")));
                            goto TestClusterRead_Exit;
                        }
                        // try it again.
                        iClusterEnumReturn = pfnClusterEnum( hClusEnum, dwEnum, &dwType, pawchResName, &dwStrLen );
                        if (iClusterEnumReturn != ERROR_SUCCESS)
                        {
                            iisDebugOut((LOG_TYPE_ERROR, _T("TestClusterRead: FAILED.err=0x%x.\n"), iClusterEnumReturn));
                            break;
                        }
                    }
                    else
                    {
                        if (iClusterEnumReturn != ERROR_NO_MORE_ITEMS)
                        {
                            // failed for some other reason.
                            iisDebugOut((LOG_TYPE_ERROR, _T("TestClusterRead: FAILED.err=0x%x.\n"), iClusterEnumReturn));
                        }
                        break;
                    }
                }

                // proceed
                if ( hRes = pfnOpenClusterResource( hC, pawchResName ) )
                {
                    if ( hKey = pfnGetClusterResourceKey( hRes, KEY_READ ) )
                    {
                        dwStrLen = sizeof(awchResType)/sizeof(WCHAR);

                        fDel = pfnClusterRegQueryValue( hKey, L"Type", &dwType, (LPBYTE)awchResType, &dwStrLen ) == ERROR_SUCCESS && !wcscmp( awchResType, pszResType );

                        iisDebugOut((LOG_TYPE_TRACE, _T("TestClusterRead():ClusterRegQueryValue:%s."),awchResType));
                        pfnClusterRegCloseKey( hKey );

                        if ( fDel )
                        {
                            /*
                            pfnOfflineClusterResource( hRes );
                            for ( dwRetry = 0 ; dwRetry < 30 && pfnGetClusterResourceState( hRes,NULL,&dwStrLen,NULL,&dwStrLen ) != ClusterResourceOffline; ++dwRetry )
                            {
                                Sleep( 1000 );
                            }
                            */

                            // At this point we have successfully got the cluster to go offline

                            // Get the vroot names and path's here and stick into the arrays....
                            GetClusterIISVRoot(hRes, L"W3SVC", cstrArryName, cstrArryPath);

                            // Do it for FTP now.
                            GetClusterIISVRoot(hRes, L"MSFTPSVC", cstrArryNameftp, cstrArryPathftp);

                            // No need to do it for gopher since there is none.
                            //GetClusterIISVRoot(hRes, L"GOPHERSVC", cstrArryName, cstrArryPath);
                        }
                    }

                    pfnCloseClusterResource( hRes );
                }

                // Increment to the next one
                ++dwEnum;

            } while(TRUE);

            pfnClusterCloseEnum( hClusEnum );
        }

        //dwErr = pfnDeleteClusterResourceType(hC,pszResType );

        pfnCloseCluster( hC );

        if (dwErr)
            {SetLastError( dwErr );}
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("fail 3\n")));
    }

TestClusterRead_Exit:
    // Copy these to the iis virtual root registry....
    MoveVRootToIIS3Registry(REG_W3SVC,cstrArryName,cstrArryPath);
    // Copy these to the iis virtual root registry....
    MoveVRootToIIS3Registry(REG_MSFTPSVC,cstrArryNameftp,cstrArryPathftp);

    if (hClusapi) {FreeLibrary(hClusapi);}
    if (pawchResName) {free(pawchResName);}
    iisDebugOut_End(_T("TestClusterRead"));
    return;
}

/****************************************************************************************
 *
 * Function: GetClusterIISVRoot
 *
 * Args: [in] hResource , the resource whos info should be added to the list
 *
 * Retrurn: GetLastError, on error
 *
 ****************************************************************************************/
int GetClusterIISVRoot(HRESOURCE hResource, LPWSTR pszTheServiceType, CStringArray &strArryOfVrootNames, CStringArray &strArryOfVrootData)
{
    //iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: start\n")));
    int iReturn = FALSE;
    HINSTANCE                       hClusapi;
    HINSTANCE                       hResutils;

    PFN_CLUSTERRESOURCECONTROL      pfnClusterResourceControl;
    PFN_RESUTILFINDSZPROPERTY       pfnResUtilFindSzProperty;
    PFN_RESUTILFINDDWORDPROPERTY    pfnResUtilFindDwordProperty;

	//
	// Initial size of the buffer
	//
	DWORD dwBufferSize = 256;
	
	//
	// The requested buffer size, and the number of bytes actually in the returned buffer
	//
	DWORD dwRequestedBufferSize = dwBufferSize;

	//
	// Result from the call to the cluster resource control function
	//
	DWORD dwResult;

	//
	// Buffer that holds the property list for this resource
	//
	LPVOID lpvPropList = NULL;

	//
	// The Proivate property that is being read
	//
	LPWSTR lpwszPrivateProp = NULL;

    hClusapi = LoadLibrary( L"clusapi.dll" );
    if (!hClusapi)
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: failed to loadlib clusapi.dll\n")));
        goto GetIISVRoot_Exit;
        }

    pfnClusterResourceControl = (PFN_CLUSTERRESOURCECONTROL)GetProcAddress( hClusapi, "ClusterResourceControl" );
    if (!pfnClusterResourceControl)
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: failed to GetProcAddress clusapi.dll:ClusterResourceControl\n")));
        goto GetIISVRoot_Exit;
        }

    hResutils = LoadLibrary( L"resutils.dll" );
    if (!hResutils)
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: failed to loadlib resutils.dll\n")));
        goto GetIISVRoot_Exit;
        }
    pfnResUtilFindSzProperty = (PFN_RESUTILFINDSZPROPERTY)GetProcAddress( hResutils, "ResUtilFindSzProperty" );
    if (!pfnResUtilFindSzProperty)
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: failed to GetProcAddress resutils.dll:ResUtilFindSzProperty\n")));
        goto GetIISVRoot_Exit;
        }
    pfnResUtilFindDwordProperty = (PFN_RESUTILFINDDWORDPROPERTY)GetProcAddress( hResutils, "ResUtilFindDwordProperty" );
    if (!pfnResUtilFindDwordProperty)
        {
        iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: failed to GetProcAddress resutils.dll:ResUtilFindDwordProperty\n")));
        goto GetIISVRoot_Exit;
        }

	//
	// Allocate memory for the resource type
	//
	lpvPropList = (LPWSTR) HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, dwBufferSize * sizeof(WCHAR) );
	if( lpvPropList == NULL)
	{
		lpvPropList = NULL;
        iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: E_OUTOFMEMORY\n")));
        goto GetIISVRoot_Exit;
	}

	//
	// Allocate memory for the Property
	//
	lpwszPrivateProp = (LPWSTR) HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, (_MAX_PATH+_MAX_PATH+1) * sizeof(WCHAR) );
	if( lpwszPrivateProp == NULL)
	{
		lpvPropList = NULL;
        iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: E_OUTOFMEMORY\n")));
        goto GetIISVRoot_Exit;
	}
	
	//
	// Get the resource's private properties (Service , InstanceId)
	//
	while( 1 )
	{
		dwResult = pfnClusterResourceControl(hResource,NULL,CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,NULL,0,lpvPropList,dwBufferSize,&dwRequestedBufferSize );
		if( ERROR_SUCCESS == dwResult )
		{
            // ---------------------
            // what the entries are:
            // AccessMask (dword) = 5
            // Alias (string)     = "virtual dir name"
            // Directory (string) = "c:\la\lalalala"
            // ServiceName (string) = W3SVC, MSFTPSVC, GOPHERSVC
            // ---------------------

            //
            // Get the "ServiceName" entry
            //
            dwResult = pfnResUtilFindSzProperty( lpvPropList, &dwRequestedBufferSize, L"ServiceName", &lpwszPrivateProp);
			if( dwResult != ERROR_SUCCESS )
			{
                iisDebugOut((LOG_TYPE_ERROR, _T("Couldn't get 'ServiceName' property.fail\n")));
                goto GetIISVRoot_Exit;
			}

            if (_wcsicmp(lpwszPrivateProp, pszTheServiceType) == 0)
            {
                // okay, we want to do stuff with this one!!!
                DWORD dwAccessMask;
                CString csAlias;
                CString csDirectory;

                TCHAR szMyBigPath[_MAX_PATH + 20];

                DWORD dwPrivateProp = 0;
                dwRequestedBufferSize = sizeof(DWORD);

                // get the Access Mask.
                dwResult = pfnResUtilFindDwordProperty( lpvPropList, &dwRequestedBufferSize, L"AccessMask", &dwPrivateProp);
			    if( dwResult != ERROR_SUCCESS )
			    {
                    iisDebugOut((LOG_TYPE_ERROR, _T("Couldn't get 'AccessMask' property.fail\n")));
                    goto GetIISVRoot_Exit;
			    }
                dwAccessMask = dwPrivateProp;

                // get the Alias
                dwResult = pfnResUtilFindSzProperty( lpvPropList, &dwRequestedBufferSize, L"Alias", &lpwszPrivateProp);
			    if( dwResult != ERROR_SUCCESS )
			    {
                    iisDebugOut((LOG_TYPE_ERROR, _T("Couldn't get 'Alias' property.fail\n")));
                    goto GetIISVRoot_Exit;
			    }
                csAlias = lpwszPrivateProp;

                // Get the Directory
                dwResult = pfnResUtilFindSzProperty( lpvPropList, &dwRequestedBufferSize, L"Directory", &lpwszPrivateProp);
			    if( dwResult != ERROR_SUCCESS )
			    {
                    iisDebugOut((LOG_TYPE_ERROR, _T("Couldn't get 'Directory' property.fail\n")));
                    goto GetIISVRoot_Exit;
			    }
                TCHAR thepath[_MAX_PATH];
                TCHAR * pmypath;
                csDirectory = lpwszPrivateProp;

                // make sure it's a valid directory name!
                if (0 != GetFullPathName(lpwszPrivateProp, _MAX_PATH, thepath, &pmypath))
                    {csDirectory = thepath;}

                // --------------------
                // formulate the string
                // --------------------

			    //
			    // Put the Name into the array.
			    //
                // "/Alias"
                strArryOfVrootNames.Add(csAlias);

                //
                // "C:\inetpub\ASPSamp,,5"
                //
                _stprintf(szMyBigPath,_T("%s,,%d"),csDirectory, dwAccessMask);
                strArryOfVrootData.Add(szMyBigPath);

                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("Entry=[%s] '%s=%s'\n"),pszTheServiceType,csAlias,szMyBigPath));
            }
            goto GetIISVRoot_Exit;
		}

		if( ERROR_MORE_DATA == dwResult )
		{
			//
			// Set the buffer size to the required size reallocate the buffer
			//
			dwBufferSize = ++dwRequestedBufferSize;

			lpvPropList = (LPWSTR) HeapReAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_NO_SERIALIZE, lpvPropList, dwBufferSize * sizeof(WCHAR) );
			if ( lpvPropList == NULL)
			{
                // out of memory!!!!
                goto GetIISVRoot_Exit;
			}
		}
	}

GetIISVRoot_Exit:
    if (lpwszPrivateProp)
        {HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, lpwszPrivateProp);}
    if (lpvPropList)
        {HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, lpvPropList);}
    //iisDebugOut((LOG_TYPE_ERROR, _T("GetClusterIISVRoot: end\n")));
    return iReturn;
}


// REG_W3SVC, REG_MSFTPSVC
void MoveVRootToIIS3Registry(CString strRegPath, CStringArray &strArryOfVrootNames, CStringArray &strArryOfVrootData)
{
    int nArrayItems = 0;
    int i = 0;

    strRegPath +=_T("\\Parameters\\Virtual Roots");
    CRegKey regVR( HKEY_LOCAL_MACHINE, strRegPath);
    if ((HKEY) regVR)
    {
        nArrayItems = (int)strArryOfVrootNames.GetSize();
        // if the CString arrays are empty then we won't ever process anything (nArrayItems is 1 based)
        for (i = 0; i < nArrayItems; i++ )
        {
            regVR.SetValue(strArryOfVrootNames[i], strArryOfVrootData[i]);
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("Array[%d]:%s=%s\n"),i,strArryOfVrootNames[i], strArryOfVrootData[i]));
        }
    }
    return;
}

void Upgrade_WolfPack()
{
    iisDebugOut_Start(_T("Upgrade_WolfPack"),LOG_TYPE_TRACE);

    CRegKey regClusSvc(HKEY_LOCAL_MACHINE, scClusterPath, KEY_READ);
    if ( (HKEY)regClusSvc )
    {
        CString csPath;
        TCHAR szPath[MAX_PATH];
        if (regClusSvc.QueryValue(_T("ImagePath"), csPath) == NERR_Success)
        {
			// string is formatted like this
			// %SystemRoot%\cluster\clusprxy.exe
			// Find the last \ and trim and paste the new file name on
			csPath = csPath.Left(csPath.ReverseFind('\\'));
			
			if ( csPath.IsEmpty() )
            {
				ASSERT(TRUE);
				return;
			}
			
            csPath += _T("\\iisclex3.dll");
	
	        if ( ExpandEnvironmentStrings( (LPCTSTR)csPath,szPath,sizeof(szPath)/sizeof(TCHAR)))
            {
                // in iis3.0 the resources were called 'IIS Virtual Root'
                // in iis4.0 it is something else (iis50 is the same as iis4)
	    	    UnregisterIisServerInstanceResourceType(L"IIS Virtual Root",(LPTSTR)szPath,TRUE,TRUE);
            }
            else
            {
				ASSERT(TRUE);
            }
        }

        ProcessSection(g_pTheApp->m_hInfHandle, _T("Wolfpack_Upgrade"));
    }
    iisDebugOut_End(_T("Upgrade_WolfPack"),LOG_TYPE_TRACE);
}


/****************************************************
*
* Known "problem": If a resource doesn't come offline after the five
* retries than the function continues to try to take the other iis resources
* offline but there is no error reported. You could change this pretty simply I think.
*
*****************************************************/
DWORD BringALLIISClusterResourcesOffline()
{
	//
	// The return code
	//
	DWORD dwError = ERROR_SUCCESS;
	
	//
	// Handle for the cluster
	//
	HCLUSTER hCluster = NULL;

	//
	// Handle for the cluster enumerator
	//
	HCLUSENUM hClusResEnum = NULL;

	//
	// Handle to a resource
	// 
	HRESOURCE hResource = NULL;

	//
	// The index of the resources we're taking offline
	//
	DWORD dwResourceIndex = 0;

	//
	// The type cluster object being enumerated returned by the ClusterEnum function
	//
	DWORD dwObjectType = 0;

	//
	// The name of the cluster resource returned by the ClusterEnum function
	//
	LPWSTR lpwszResourceName = NULL;
	
	//
	// The return code from the call to ClusterEnum
	//
	DWORD dwResultClusterEnum = ERROR_SUCCESS;

	//
	// The size of the buffer (in characters) that is used to hold the resource name's length
	//	
	DWORD dwResourceNameBufferLength = INITIAL_RESOURCE_NAME_SIZE;

	//
	// Size of the resource name passed to and returned by the ClusterEnum function
	//	
	DWORD dwClusterEnumResourceNameLength = dwResourceNameBufferLength;

    BOOL iClusDependsOnIISServices = FALSE;

	//
	// Open the cluster
	//
	if ( !(hCluster = OpenCluster(NULL)) )
	{
        dwError = GetLastError();
        // This will fail with RPC_S_SERVER_UNAVAILABLE "The RPC server is unavailable" if there is no cluster on this system
        if (hCluster == NULL)
        {
            if ( (dwError != RPC_S_SERVER_UNAVAILABLE) &&
                 (dwError != EPT_S_NOT_REGISTERED ) )
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOffline:OpenCluster failed err=0x%x.\n"),dwError));
            }
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOffline:OpenCluster failed err=0x%x.\n"),dwError));
        }
		goto clean_up;
	}

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("BringALLIISClusterResourcesOffline:start.\n")));

	//
	// Get Enumerator for the cluster resouces
	// 
	if ( !(hClusResEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE )) )
	{
		dwError = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOffline:ClusterOpenEnum failed err=0x%x.\n"),dwError));
		goto clean_up;	
	}
	
	//
	// Enumerate the Resources in the cluster
	// 
	
	//
	// Allocate memory to hold the cluster resource name as we enumerate the resources
	//
	if ( !(lpwszResourceName = (LPWSTR) LocalAlloc(LPTR, dwResourceNameBufferLength * sizeof(WCHAR))) )
	{
		dwError = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOffline:LocalAlloc failed err=0x%x.\n"),dwError));
		goto clean_up;
	}

	// 
	// Enumerate all of the resources in the cluster and take the IIS Server Instance's offline
	//
	while( ERROR_NO_MORE_ITEMS  != 
	       (dwResultClusterEnum = ClusterEnum(hClusResEnum,
			              dwResourceIndex, 
				      &dwObjectType, 
				      lpwszResourceName,
				      &dwClusterEnumResourceNameLength )) )
	{
		//
		// If we have a resource's name
		//
		if( ERROR_SUCCESS == dwResultClusterEnum )
		{

			if ( !(hResource = OpenClusterResource( hCluster, lpwszResourceName )) )
			{
				dwError = GetLastError();
				break;
			}

            // If the resource type is "IIS Server Instance", or some other one that is 
            // dependent upon the iis services, then we need to stop it.
            iClusDependsOnIISServices = CheckForIISDependentClusters(hResource);
            if (iClusDependsOnIISServices)
			{
	            CLUSTER_RESOURCE_STATE TheState = GetClusterResourceState(hResource,NULL,0,NULL,0);
                if (TheState == ClusterResourceOnline || TheState == ClusterResourceOnlinePending)
                {
                    HKEY hKey;
                    if ( hKey = GetClusterResourceKey( hResource, KEY_READ ) )
                    {
                        //
                        // Get the resource name.
                        //
                        LPWSTR lpwsResourceName = NULL;
                        lpwsResourceName = GetParameter( hKey, L"Name" );
                        if ( lpwsResourceName != NULL ) 
                        {
                            // this is a resource which we will try to stop
                            // so we should save the name somewhere in like a global list
                            iisDebugOut((LOG_TYPE_TRACE, _T("OfflineClusterResource:'%s'\n"),lpwsResourceName));
                            ListOfClusResources_Add(lpwsResourceName);
                        }
                        if (lpwsResourceName){LocalFree((LPWSTR) lpwsResourceName);}

                        ClusterRegCloseKey(hKey);
                    }

                    //
                    // If the resource doesn't come offline quickly then wait 
                    //
                    if ( ERROR_IO_PENDING == OfflineClusterResource( hResource ) )
                    {
                        for(int iRetry=0; iRetry < MAX_OFFLINE_RETRIES; iRetry++)
                        {
                            Sleep( DELAY_BETWEEN_CALLS_TO_OFFLINE );

                            if ( ERROR_SUCCESS == OfflineClusterResource( hResource ) )
                            {
                                break;
                            }
                        }	
                    }
                }
			CloseClusterResource( hResource );
            }
			
			dwResourceIndex++;
		}
			
		//
		// If the buffer wasn't large enough then retry with a larger buffer
		//
		if( ERROR_MORE_DATA == dwResultClusterEnum )
		{
			//
			// Set the buffer size to the required size reallocate the buffer
			//
			LPWSTR lpwszResourceNameTmp = lpwszResourceName;

			//
			// After returning from ClusterEnum dwClusterEnumResourceNameLength 
			// doesn't include the null terminator character
			//
			dwResourceNameBufferLength = dwClusterEnumResourceNameLength + 1;

			if ( !(lpwszResourceName = 
			      (LPWSTR) LocalReAlloc (lpwszResourceName, dwResourceNameBufferLength * sizeof(WCHAR), 0)) )
			{
				dwError = GetLastError();

				LocalFree( lpwszResourceNameTmp );	
				lpwszResourceNameTmp = NULL;
				break;
			}
		}

		//
		// Reset dwResourceNameLength with the size of the number of characters in the buffer
		// You have to do this because everytime you call ClusterEnum is sets your buffer length 
		// argument to the number of characters in the string it's returning.
		//
		dwClusterEnumResourceNameLength = dwResourceNameBufferLength;
	}	


clean_up:

	if ( lpwszResourceName )
	{
		LocalFree( lpwszResourceName );
		lpwszResourceName = NULL;
	}
	
	if ( hClusResEnum )
	{
		ClusterCloseEnum( hClusResEnum );
		hClusResEnum = NULL;
	}

	if ( hCluster )
	{
		CloseCluster( hCluster );
		hCluster = NULL;
	}

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("BringALLIISClusterResourcesOffline:end.ret=0x%x\n"),dwError));
	return dwError;
}


DWORD BringALLIISClusterResourcesOnline()
{
    //
    // The return code
    //
    DWORD dwError = ERROR_SUCCESS;

    //
    // Handle for the cluster
    //
    HCLUSTER hCluster = NULL;

    //
    // Handle for the cluster enumerator
    //
    HCLUSENUM hClusResEnum = NULL;

    //
    // Handle to a resource
    // 
    HRESOURCE hResource = NULL;

    //
    // The index of the resources we're taking offline
    //
    DWORD dwResourceIndex = 0;

    //
    // The type cluster object being enumerated returned by the ClusterEnum function
    //
    DWORD dwObjectType = 0;

    //
    // The name of the cluster resource returned by the ClusterEnum function
    //
    LPWSTR lpwszResourceName = NULL;

    //
    // The return code from the call to ClusterEnum
    //
    DWORD dwResultClusterEnum = ERROR_SUCCESS;

    //
    // The size of the buffer (in characters) that is used to hold the resource name's length
    //	
    DWORD dwResourceNameBufferLength = INITIAL_RESOURCE_NAME_SIZE;

    //
    // Size of the resource name passed to and returned by the ClusterEnum function
    //	
    DWORD dwClusterEnumResourceNameLength = dwResourceNameBufferLength;

    BOOL iClusDependsOnIISServices = FALSE;


    //
    // Open the cluster
    //
    if ( !(hCluster = OpenCluster(NULL)) )
    {
        dwError = GetLastError();
        // This will fail with RPC_S_SERVER_UNAVAILABLE "The RPC server is unavailable" if there is no cluster on this system
        if (hCluster == NULL)
        {
            if ( (dwError != RPC_S_SERVER_UNAVAILABLE) &&
                 (dwError != EPT_S_NOT_REGISTERED ) )
            {
                iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOnline:OpenCluster failed err=0x%x.\n"),dwError));
            }
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOnline:OpenCluster failed err=0x%x.\n"),dwError));
        }
        goto clean_up;
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("BringALLIISClusterResourcesOnline:end.ret=0x%x\n"),dwError));

    //
    // Get Enumerator for the cluster resouces
    // 
    if ( !(hClusResEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE )) )
    {
        dwError = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOnline:ClusterOpenEnum failed err=0x%x.\n"),dwError));
        goto clean_up;	
    }
	
	//
	// Enumerate the Resources in the cluster
	// 
	
    //
    // Allocate memory to hold the cluster resource name as we enumerate the resources
    //
    if ( !(lpwszResourceName = (LPWSTR) LocalAlloc(LPTR, dwResourceNameBufferLength * sizeof(WCHAR))) )
    {
        dwError = GetLastError();
        iisDebugOut((LOG_TYPE_ERROR, _T("BringALLIISClusterResourcesOnline:LocalAlloc failed err=0x%x.\n"),dwError));
        goto clean_up;
    }

    // 
    // Enumerate all of the resources in the cluster and take the IIS Server Instance's offline
    //
    while( ERROR_NO_MORE_ITEMS  != 
        (dwResultClusterEnum = ClusterEnum(hClusResEnum,
            dwResourceIndex, 
            &dwObjectType, 
            lpwszResourceName,
            &dwClusterEnumResourceNameLength )) )
	{
		//
		// If we have a resource's name
		//
		if( ERROR_SUCCESS == dwResultClusterEnum )
		{

			if ( !(hResource = OpenClusterResource( hCluster, lpwszResourceName )) )
			{
				dwError = GetLastError();
				break;
			}

            // If the resource type is "IIS Server Instance", or some other one that is 
            // dependent upon the iis services, then we probably stopped, it.
            iClusDependsOnIISServices = CheckForIISDependentClusters(hResource);
			if (iClusDependsOnIISServices)
			{
	            CLUSTER_RESOURCE_STATE TheState = GetClusterResourceState(hResource,NULL,0,NULL,0);
	            if (TheState == ClusterResourceOffline || TheState == ClusterResourceOfflinePending)
	            {
                    int iRestart = FALSE;
                    LPWSTR lpwsResourceName = NULL;

                    HKEY hKey;
                    if ( hKey = GetClusterResourceKey( hResource, KEY_READ ) )
                    {
                        //
                        // Get the resource name.
                        //
                        lpwsResourceName = GetParameter( hKey, L"Name" );
                        if ( lpwsResourceName != NULL ) 
                        {
                            iRestart = ListOfClusResources_Check(lpwsResourceName);
                        }
                        ClusterRegCloseKey(hKey);
                    }

                    if (TRUE == iRestart)
                    {
                        iisDebugOut((LOG_TYPE_TRACE, _T("OnlineClusterResource:'%s'.\n"),lpwsResourceName));
                        OnlineClusterResource(hResource);
                        if (lpwsResourceName){LocalFree((LPWSTR) lpwsResourceName);}
                    }
			    }
            }
            CloseClusterResource( hResource );
		
			dwResourceIndex++;
		}
			
        //
        // If the buffer wasn't large enough then retry with a larger buffer
        //
        if( ERROR_MORE_DATA == dwResultClusterEnum )
        {
            //
            // Set the buffer size to the required size reallocate the buffer
            //
            LPWSTR lpwszResourceNameTmp = lpwszResourceName;

            //
            // After returning from ClusterEnum dwClusterEnumResourceNameLength 
            // doesn't include the null terminator character
            //
            dwResourceNameBufferLength = dwClusterEnumResourceNameLength + 1;

            if ( !(lpwszResourceName = 
            (LPWSTR) LocalReAlloc (lpwszResourceName, dwResourceNameBufferLength * sizeof(WCHAR), 0)) )
            {
                dwError = GetLastError();

                LocalFree( lpwszResourceNameTmp );	
                lpwszResourceNameTmp = NULL;
                break;
            }
        }

		//
		// Reset dwResourceNameLength with the size of the number of characters in the buffer
		// You have to do this because everytime you call ClusterEnum is sets your buffer length 
		// argument to the number of characters in the string it's returning.
		//
		dwClusterEnumResourceNameLength = dwResourceNameBufferLength;
	}	


clean_up:
    if ( lpwszResourceName )
    {
        LocalFree( lpwszResourceName );
        lpwszResourceName = NULL;
    }

    if ( hClusResEnum )
    {
        ClusterCloseEnum( hClusResEnum );
        hClusResEnum = NULL;
    }

    if ( hCluster )
    {
        CloseCluster( hCluster );
        hCluster = NULL;
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("BringALLIISClusterResourcesOnline:end.ret=0x%x\n"),dwError));
    return dwError;
}


LPWSTR GetParameter(
    IN HKEY ClusterKey,
    IN LPCWSTR ValueName
    )
/*++
Routine Description:

    Reads a REG_SZ parameter from the cluster regitry, and allocates the
    necessary storage for it.

Arguments:

    ClusterKey - supplies the cluster key where the parameter is stored.

    ValueName - supplies the name of the value.

Return Value:

    A pointer to a buffer containing the parameter value on success.

    NULL on failure.

--*/
{
    LPWSTR  value = NULL;
    DWORD   valueLength;
    DWORD   valueType;
    DWORD   status;

    valueLength = 0;
    status = ClusterRegQueryValue( ClusterKey,ValueName,&valueType,NULL,&valueLength );
    if ( (status != ERROR_SUCCESS) && (status != ERROR_MORE_DATA) ) 
    {
        SetLastError(status);
        return(NULL);
    }
    if ( valueType == REG_SZ ) 
    {
        valueLength += sizeof(UNICODE_NULL);
    }

    value = (LPWSTR) LocalAlloc(LMEM_FIXED, valueLength);
    if ( value == NULL ) 
        {return(NULL);}
    status = ClusterRegQueryValue(ClusterKey,ValueName,&valueType,(LPBYTE)value,&valueLength);
    if ( status != ERROR_SUCCESS) 
    {
        LocalFree(value);
        SetLastError(status);
        value = NULL;
    }
    return(value);
}


INT CheckForIISDependentClusters(HRESOURCE hResource)
{
    INT iReturn = FALSE;

	// If the resource type is "IIS Server Instance", 
	// "SMTP Server Instance" or "NNTP Server Instance" then take it offline
    iReturn = ResUtilResourceTypesEqual(IIS_RESOURCE_TYPE_NAME, hResource);
    if (!iReturn){iReturn = ResUtilResourceTypesEqual(SMTP_RESOURCE_TYPE_NAME, hResource);}
    if (!iReturn){iReturn = ResUtilResourceTypesEqual(NNTP_RESOURCE_TYPE_NAME, hResource);}

    // check for other ones which might be listed in the inf file!
    if (!iReturn && g_pTheApp->m_hInfHandle)
    {
        CStringList strList;
        CString csTheSection = _T("ClusterResType_DependsonIIS");

        if (GetSectionNameToDo(g_pTheApp->m_hInfHandle, csTheSection))
        {
            if (ERROR_SUCCESS == FillStrListWithListOfSections(g_pTheApp->m_hInfHandle, strList, csTheSection))
            {
                // loop thru the list returned back
                if (strList.IsEmpty() == FALSE)
                {
                    POSITION pos;
                    CString csEntry;

                    pos = strList.GetHeadPosition();
                    while (pos) 
                    {
                        csEntry = strList.GetAt(pos);

                        int iTempReturn = FALSE;
                        iTempReturn = ResUtilResourceTypesEqual(csEntry, hResource);
                        if (iTempReturn)
                        {
                            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CheckForIISDependentClusters:yes='%s'\n"),csEntry));
                            iReturn = TRUE;
                            break;
                        }
                        strList.GetNext(pos);
                    }
                }
            }
        }
    }

    return iReturn;
}


DWORD WINAPI DoesThisServiceTypeExistInCluster(PVOID pInfo)
{
    INT iTemp = FALSE;
    CLUSTER_SVC_INFO_FILL_STRUCT * pMyStructOfInfo;
    pMyStructOfInfo = (CLUSTER_SVC_INFO_FILL_STRUCT *) pInfo;

    //pMyStructOfInfo->szTheClusterName
    //pMyStructOfInfo->pszTheServiceType
    //pMyStructOfInfo->csTheReturnServiceResName
    //pMyStructOfInfo->dwReturnStatus

	//
	// The return code
	//
    DWORD dwReturn = ERROR_NOT_FOUND;
    pMyStructOfInfo->dwReturnStatus = dwReturn;

	//
	// Handle for the cluster
	//
	HCLUSTER hCluster = NULL;

	//
	// Handle for the cluster enumerator
	//
	HCLUSENUM hClusResEnum = NULL;

	//
	// Handle to a resource
	// 
	HRESOURCE hResource = NULL;

	//
	// The index of the resources we're taking offline
	//
	DWORD dwResourceIndex = 0;

	//
	// The type cluster object being enumerated returned by the ClusterEnum function
	//
	DWORD dwObjectType = 0;

	//
	// The name of the cluster resource returned by the ClusterEnum function
	//
	LPWSTR lpwszResourceName = NULL;
	
	//
	// The return code from the call to ClusterEnum
	//
	DWORD dwResultClusterEnum = ERROR_SUCCESS;

	//
	// The size of the buffer (in characters) that is used to hold the resource name's length
	//	
	DWORD dwResourceNameBufferLength = INITIAL_RESOURCE_NAME_SIZE;

	//
	// Size of the resource name passed to and returned by the ClusterEnum function
	//	
	DWORD dwClusterEnumResourceNameLength = dwResourceNameBufferLength;

    //
    //  Open the cluster
    //
    hCluster = OpenCluster(pMyStructOfInfo->szTheClusterName);
    if( !hCluster )
    {
        dwReturn = GetLastError();
        goto DoesThisServiceTypeExistInCluster_Exit;	
    }

    //
    // Get Enumerator for the cluster resouces
    // 
    if ( !(hClusResEnum = ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE )) )
    {
        dwReturn = GetLastError();
        goto DoesThisServiceTypeExistInCluster_Exit;	
    }

    //
    // Enumerate the Resources in the cluster
    // 
	
    //
    // Allocate memory to hold the cluster resource name as we enumerate the resources
    //
    if ( !(lpwszResourceName = (LPWSTR) LocalAlloc(LPTR, dwResourceNameBufferLength * sizeof(WCHAR))) )
    {
        dwReturn = GetLastError();
        goto DoesThisServiceTypeExistInCluster_Exit;
    }

    // 
    // Enumerate all of the resources in the cluster
    //
    while( ERROR_NO_MORE_ITEMS  != (dwResultClusterEnum = ClusterEnum(hClusResEnum,dwResourceIndex,&dwObjectType,lpwszResourceName,&dwClusterEnumResourceNameLength)) )
    {
        //
        // If we have a resource's name
        //
		if( ERROR_SUCCESS == dwResultClusterEnum )
		{

			if ( !(hResource = OpenClusterResource( hCluster, lpwszResourceName )) )
			{
				dwReturn = GetLastError();
				break;
			}

            // If the resource type is "IIS Server Instance", or one that depends upon iis like smtp or nntp then
            // check further to see if they have our services (W3SVC or MSFTPSVC)

            iTemp = ResUtilResourceTypesEqual(IIS_RESOURCE_TYPE_NAME, hResource);
            if (!iTemp){iTemp = ResUtilResourceTypesEqual(SMTP_RESOURCE_TYPE_NAME, hResource);}
            if (!iTemp){iTemp = ResUtilResourceTypesEqual(NNTP_RESOURCE_TYPE_NAME, hResource);}

            if (TRUE == iTemp)
            {
                // if the resource hangs it will hang on this call
                pMyStructOfInfo->dwReturnStatus = ERROR_INVALID_BLOCK;
                if (ERROR_SUCCESS == IsResourceThisTypeOfService(hResource, pMyStructOfInfo->pszTheServiceType))
                {
                    CString csResName;
                    //
                    // Yes! we found it
                    //
                    dwReturn = ERROR_SUCCESS;

                    // Display the resource name for fun
                    if (TRUE == GetClusterResName(hResource, &csResName))
                    {
                        // copy it to the return string
                        *pMyStructOfInfo->csTheReturnServiceResName = csResName;
                    }

                    CloseClusterResource( hResource );
                    goto DoesThisServiceTypeExistInCluster_Exit;
                }
                dwReturn = ERROR_NOT_FOUND;
			    CloseClusterResource( hResource );
            }
			
			dwResourceIndex++;
		}

		//
		// If the buffer wasn't large enough then retry with a larger buffer
		//
		if( ERROR_MORE_DATA == dwResultClusterEnum )
		{
			//
			// Set the buffer size to the required size reallocate the buffer
			//
			LPWSTR lpwszResourceNameTmp = lpwszResourceName;

			//
			// After returning from ClusterEnum dwClusterEnumResourceNameLength 
			// doesn't include the null terminator character
			//
			dwResourceNameBufferLength = dwClusterEnumResourceNameLength + 1;

			if ( !(lpwszResourceName = 
			      (LPWSTR) LocalReAlloc (lpwszResourceName, dwResourceNameBufferLength * sizeof(WCHAR), 0)) )
			{
                dwReturn = GetLastError();

				LocalFree( lpwszResourceNameTmp );	
				lpwszResourceNameTmp = NULL;
				break;
			}
		}

		//
		// Reset dwResourceNameLength with the size of the number of characters in the buffer
		// You have to do this because everytime you call ClusterEnum is sets your buffer length 
		// argument to the number of characters in the string it's returning.
		//
		dwClusterEnumResourceNameLength = dwResourceNameBufferLength;
	}	


DoesThisServiceTypeExistInCluster_Exit:
	if ( lpwszResourceName )
	{
		LocalFree( lpwszResourceName );
		lpwszResourceName = NULL;
	}
	
	if ( hClusResEnum )
	{
		ClusterCloseEnum( hClusResEnum );
		hClusResEnum = NULL;
	}

	if ( hCluster )
	{
		CloseCluster( hCluster );
		hCluster = NULL;
	}

    pMyStructOfInfo->dwReturnStatus = dwReturn;
    return dwReturn;
}


DWORD IsResourceThisTypeOfService(HRESOURCE hResource, LPWSTR pszTheServiceType)
{
    DWORD dwReturn = ERROR_NOT_FOUND;
    HINSTANCE hClusapi  = NULL;
    HINSTANCE hResutils = NULL;

    PFN_CLUSTERRESOURCECONTROL      pfnClusterResourceControl;
    PFN_RESUTILFINDSZPROPERTY       pfnResUtilFindSzProperty;

	//
	// Initial size of the buffer
	//
	DWORD dwBufferSize = 256;
	
	//
	// The requested buffer size, and the number of bytes actually in the returned buffer
	//
	DWORD dwRequestedBufferSize = dwBufferSize;

	//
	// Result from the call to the cluster resource control function
	//
	DWORD dwResult;

	//
	// Buffer that holds the property list for this resource
	//
	LPVOID lpvPropList = NULL;

	//
	// The Proivate property that is being read
	//
	LPWSTR lpwszPrivateProp = NULL;

    //
    // Load cluster dll's
    //
    hClusapi = LoadLibrary( L"clusapi.dll" );
    if (!hClusapi)
        {
        dwReturn = TYPE_E_CANTLOADLIBRARY;
        goto IsResourceThisTypeOfService_Exit;
        }

    pfnClusterResourceControl = (PFN_CLUSTERRESOURCECONTROL)GetProcAddress( hClusapi, "ClusterResourceControl" );
    if (!pfnClusterResourceControl)
        {
        dwReturn = ERROR_PROC_NOT_FOUND;
        goto IsResourceThisTypeOfService_Exit;
        }

    hResutils = LoadLibrary( L"resutils.dll" );
    if (!hResutils)
        {
        dwReturn = TYPE_E_CANTLOADLIBRARY;
        goto IsResourceThisTypeOfService_Exit;
        }
    pfnResUtilFindSzProperty = (PFN_RESUTILFINDSZPROPERTY)GetProcAddress( hResutils, "ResUtilFindSzProperty" );
    if (!pfnResUtilFindSzProperty)
        {
        dwReturn = ERROR_PROC_NOT_FOUND;
        goto IsResourceThisTypeOfService_Exit;
        }

	//
	// Allocate memory for the resource type
	//
	lpvPropList = (LPWSTR) HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, dwBufferSize * sizeof(WCHAR) );
	if( lpvPropList == NULL)
	{
		lpvPropList = NULL;
        dwReturn = E_OUTOFMEMORY;
        goto IsResourceThisTypeOfService_Exit;
	}

	//
	// Allocate memory for the Property
	//
	lpwszPrivateProp = (LPWSTR) HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, (_MAX_PATH+_MAX_PATH+1) * sizeof(WCHAR) );
	if( lpwszPrivateProp == NULL)
	{
		lpvPropList = NULL;
        dwReturn = E_OUTOFMEMORY;
        goto IsResourceThisTypeOfService_Exit;
	}
	
	//
	// Get the resource's private properties (Service , InstanceId)
	//
	while( 1 )
	{
		dwResult = pfnClusterResourceControl(hResource,NULL,CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,NULL,0,lpvPropList,dwBufferSize,&dwRequestedBufferSize );
		if( ERROR_SUCCESS == dwResult )
		{

            // ---------------------
            // what the entries are:
            // AccessMask (dword) = 5
            // Alias (string)     = "virtual dir name"
            // Directory (string) = "c:\la\lalalala"
            // ServiceName (string) = W3SVC, MSFTPSVC, GOPHERSVC
            // ---------------------

            //
            // Get the "ServiceName" entry
            //
            dwResult = pfnResUtilFindSzProperty( lpvPropList, &dwRequestedBufferSize, L"ServiceName", &lpwszPrivateProp);
			if( dwResult != ERROR_SUCCESS )
			{
                dwReturn = dwResult;
                goto IsResourceThisTypeOfService_Exit;
			}

            if (_wcsicmp(lpwszPrivateProp, pszTheServiceType) == 0)
            {
                // Okay, we found at least 1 service name that matches
                // the one that was passed -- which we're supposed to look for
                // return success
                dwReturn = ERROR_SUCCESS;
            }
            goto IsResourceThisTypeOfService_Exit;
		}

		if( ERROR_MORE_DATA == dwResult )
		{
			//
			// Set the buffer size to the required size reallocate the buffer
			//
			dwBufferSize = ++dwRequestedBufferSize;

			lpvPropList = (LPWSTR) HeapReAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_NO_SERIALIZE, lpvPropList, dwBufferSize * sizeof(WCHAR) );
			if ( lpvPropList == NULL)
			{
                dwReturn = E_OUTOFMEMORY;
                goto IsResourceThisTypeOfService_Exit;
			}
		}
	}

IsResourceThisTypeOfService_Exit:
    if (lpwszPrivateProp)
        {HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, lpwszPrivateProp);}
    if (lpvPropList)
        {HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, lpvPropList);}
    if (hClusapi)
        {FreeLibrary(hClusapi);}
    if (hResutils)
        {FreeLibrary(hClusapi);}
   
    return dwReturn;
}


INT GetClusterResName(HRESOURCE hResource, CString * csReturnedName)
{
    int iReturn = FALSE;
    HKEY hKey;
    if ( hKey = GetClusterResourceKey( hResource, KEY_READ ) )
    {
        //
        // Get the resource name.
        //
        LPWSTR lpwsResourceName = NULL;
        lpwsResourceName = GetParameter( hKey, L"Name" );
        if ( lpwsResourceName != NULL ) 
        {
            //wcscpy(csReturnedName,lpwsResourceName);
            *csReturnedName = lpwsResourceName;
            iReturn = TRUE;
        }
        if (lpwsResourceName){LocalFree((LPWSTR) lpwsResourceName);}

        ClusterRegCloseKey(hKey);
    }
    return iReturn;
}




INT DoClusterServiceCheck(CLUSTER_SVC_INFO_FILL_STRUCT * pMyStructOfInfo)
{
    int iReturn = FALSE;
    DWORD ThreadID = 0;
    DWORD status = 0;
   
    HANDLE hMyThread = CreateThread(NULL,0,DoesThisServiceTypeExistInCluster,pMyStructOfInfo,0,&ThreadID);
    if (hMyThread)
    {
        // wait for 30 secs only
        DWORD res = WaitForSingleObject(hMyThread,30*1000);
        if (res == WAIT_TIMEOUT)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ERROR DoClusterServiceCheck thread never finished...\n")));
		    GetExitCodeThread(hMyThread, &status);
		    if (status == STILL_ACTIVE) 
            {
			    if (hMyThread != NULL)
                    {TerminateThread(hMyThread, 0);}
		    }
        }
        else
        {
            GetExitCodeThread(hMyThread, &status);
		    if (status == STILL_ACTIVE) 
            {
			    if (hMyThread != NULL)
                    {TerminateThread(hMyThread, 0);}
		    }
            else
            {
                if (ERROR_SUCCESS == status)
                    {iReturn = TRUE;}
            }

            if (hMyThread != NULL)
                {CloseHandle(hMyThread);}
        }
    }

    return iReturn;
}


INT DoesClusterServiceExist(void)
{
    if (-1 == g_ClusterSVCExist)
    {
        CRegKey regClusSvc(HKEY_LOCAL_MACHINE, scClusterPath2, KEY_READ);
        if ( (HKEY) regClusSvc )
        {
            g_ClusterSVCExist = 1;
        }
        else
        {
            g_ClusterSVCExist = 0;
        }
    }
    return g_ClusterSVCExist;
}
#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\svc.h ===
#include "stdafx.h"

// win95 type service only
#ifdef _CHICAGO_
    void W95StartW3SVC();
    BOOL W95ShutdownW3SVC();
    BOOL W95ShutdownIISADMIN(VOID);
#endif //_CHICAGO_

int   InetIsThisExeAService(LPCTSTR lpFileNameToCheck, LPTSTR lpReturnServiceName);
int   InetIsThisExeAService_Worker(LPCTSTR lpServiceName, LPCTSTR lpFileNameToCheck);
INT   InetDisableService( LPCTSTR lpServiceName );
INT   InetStartService( LPCTSTR lpServiceName );
DWORD InetQueryServiceStatus( LPCTSTR lpServiceName );
INT   InetStopService( LPCTSTR lpServiceName );
INT   InetDeleteService( LPCTSTR lpServiceName );
INT   InetCreateService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, DWORD dwStartType, LPCTSTR lpDependencies);
INT   InetCreateDriver(LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, DWORD dwStartType);
INT   InetConfigService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, LPCTSTR lpDependencies);
BOOL  InetRegisterService(LPCTSTR pszMachine, LPCTSTR pszServiceName, GUID *pGuid, DWORD SapId, DWORD TcpPort, BOOL fAdd = TRUE);
DWORD RetrieveServiceConfig(IN SC_HANDLE ServiceHandle,OUT LPQUERY_SERVICE_CONFIG *ServiceConfig);
INT   CheckifServiceExist( LPCTSTR lpServiceName );
INT   CheckifServiceExistAndDependencies( LPCTSTR lpServiceName );
INT   CheckifServiceMarkedForDeletion( LPCTSTR lpServiceName );
int   ValidateDependentService(LPCTSTR lpServiceToValidate, LPCTSTR lpServiceWhichIsDependent);
INT   CreateDependencyForService( LPCTSTR lpServiceName, LPCTSTR lpDependency );
INT   RemoveDependencyForService( LPCTSTR lpServiceName, LPCTSTR lpDependency );
int   StopServiceAndDependencies(LPCTSTR ServiceName, int AddToRestartList);
int   KillService(SC_HANDLE ServiceHandle);
INT   InetConfigServiceInteractive(LPCTSTR lpServiceName, int AddInteractive);
DWORD CreateDriver_Wrap(CString csDriverName, CString csDisplayName, CString csFileName,BOOL bDisplayMsgOnErrFlag);
DWORD CreateService_wrap(CString csServiceName, CString csDisplayName, CString csBinPath, CString csDependencies, CString csDescription, BOOL bDisplayMsgOnErrFlag);
int   ServicesRestartList_Add(LPCTSTR szServiceName);
int   ServicesRestartList_EntryExists(LPCTSTR szServiceName);
int   ServicesRestartList_RestartServices(void);
int   IsThisServiceADriver(LPCTSTR lpServiceName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\sysprep.cpp ===
#include "stdafx.h"
#include <ole2.h>
#include "iadm.h"
#include "iiscnfgp.h"
#include "mdkey.h"
#include "mdacl.h"
#include "inetinfo.h"
#include "log.h"
#include "svc.h"
#include "dcomperm.h"
#include "setpass.h"
#include <comadmin.h>   // CLSID_COMAdminCatalog
#include "comadmii.c"   // CLSID_COMAdminCatalog

typedef TCHAR USERNAME_STRING_TYPE[MAX_PATH];
typedef TCHAR PASSWORD_STRING_TYPE[LM20_PWLEN+1];
typedef enum {
    GUFM_SUCCESS,
    GUFM_NO_PATH,
    GUFM_NO_PASSWORD,
    GUFM_NO_USER_ID
} GUFM_RETURN;
#define OPEN_TIMEOUT_VALUE 30000
#define MD_SET_DATA_RECORD_EXT(PMDR, ID, ATTR, UTYPE, DTYPE, DLEN, PD) \
            { \
            (PMDR)->dwMDIdentifier=ID; \
            (PMDR)->dwMDAttributes=ATTR; \
            (PMDR)->dwMDUserType=UTYPE; \
            (PMDR)->dwMDDataType=DTYPE; \
            (PMDR)->dwMDDataLen=DLEN; \
            (PMDR)->pbMDData=(PBYTE)PD; \
            }

#define SYSPREP_TEMPFILE_NAME _T("IISSysPr.tmp")
#define SYSPREP_KNOWN_SECTION_NAME _T("paths")
#define SYSPREP_KNOWN_REGISTRY_KEY _T("SysPrepIISInfo")
#define SYSPREP_TEMP_PASSWORD_LENGTH 256
#define SYSPREP_USE_SECRETS

#define REG_ENABLEPASSSYNC_KEY          _T("SOFTWARE\\Microsoft\\InetStp")
#define REG_ENABLEPASSSYNC_VALUE        _T("EnableUserAccountRestorePassSync")

DWORD   AddUserToMetabaseACL2(CString csKeyPath, LPTSTR szUserToAdd, ACCESS_ALLOWED_ACE * MyACEInfo);

#ifndef _CHICAGO_
HRESULT 
UpdateComApplications( 
    IMSAdminBase2 * pcCom,
    LPCTSTR     szWamUserName, 
    LPCTSTR     szWamUserPass 
    )
/*++
Routine Description:

    If the IWAM account has been modified, it is necessary to update the
    the out of process com+ applications with the correct account
    information. This routine will collect all the com+ applications and
    reset the activation information.

Arguments:

    pcCom               - metabase object
    szWamUserName       - the new user name
    szWamUserPass       - the new user password

Note:

    This routine is a royal pain in the butt. I take back
    all the good things I may have said about com automation.

Return Value:
    
    HRESULT             - Return value from failed API call
                        - E_OUTOFMEMORY
                        - S_OK - everything worked
                        - S_FALSE - encountered a non-fatal error, unable
                          to reset at least one application.
--*/                       
{
    HRESULT     hr = NOERROR;
    BOOL        fNoErrors = TRUE;

    METADATA_HANDLE     hMetabase = NULL;
    WCHAR *             pwszDataPaths = NULL;
    DWORD               cchDataPaths = 0;
    BOOL                fTryAgain;
    DWORD               cMaxApplications;
    WCHAR *             pwszCurrentPath;

    SAFEARRAY *     psaApplications = NULL;
    SAFEARRAYBOUND  rgsaBound[1];
    DWORD           cApplications;
    VARIANT         varAppKey;
    LONG            rgIndices[1];

    METADATA_RECORD     mdrAppIsolated;
    METADATA_RECORD     mdrAppPackageId;
    DWORD               dwAppIsolated;
    WCHAR               wszAppPackageId[ 40 ];
    DWORD               dwMDGetDataLen = 0;

    ICOMAdminCatalog *      pComCatalog = NULL;
    ICatalogCollection *    pComAppCollection = NULL;
    ICatalogObject *        pComApp = NULL;
    BSTR                    bstrAppCollectionName = NULL;
    LONG                    nAppsInCollection;
    LONG                    iCurrentApp;
    LONG                    nChanges;

    VARIANT     varOldAppIdentity;
    VARIANT     varNewAppIdentity;
    VARIANT     varNewAppPassword;

    // This is built unicode right now. Since all the com apis I need
    // are unicode only I'm using wide characters here. I should get
    // plenty of compiler errors if _UNICODE isn't defined, but just
    // in case....
    DBG_ASSERT( sizeof(TCHAR) == sizeof(WCHAR) );

    iisDebugOut((LOG_TYPE_TRACE, _T("UpdateComApplications():start\n")));

    // Init variants
    VariantInit( &varAppKey );
    VariantInit( &varOldAppIdentity );
    VariantInit( &varNewAppIdentity );
    VariantInit( &varNewAppPassword );

    //
    // Get the applications to be reset by querying the metabase paths
    //
    hr = pcCom->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                     L"LM/W3SVC",
                                     METADATA_PERMISSION_READ,
                                     OPEN_TIMEOUT_VALUE,
                                     &hMetabase
                                     );
    if( FAILED(hr) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("Failed to open metabase (%08x)\n"),hr));
        goto cleanup;
    }

    // Get the data paths string

    fTryAgain = TRUE;
    do
    {
        hr = pcCom->GetDataPaths( hMetabase,
                                           NULL,
                                           MD_APP_PACKAGE_ID,
                                           STRING_METADATA,
                                           cchDataPaths,
                                           pwszDataPaths,
                                           &cchDataPaths 
                                           );

        if( HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr )
        {
            delete[] pwszDataPaths;
            pwszDataPaths = NULL;

            pwszDataPaths = new WCHAR[cchDataPaths];
            if( !pwszDataPaths )
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }
        }
        else
        {
            fTryAgain = FALSE;
        }
    }
    while( fTryAgain );

    if( FAILED(hr) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("Failed to find metadata (%08x) Data(%d)\n"),hr,MD_APP_PACKAGE_ID));
        goto cleanup;
    }
    else if (pwszDataPaths == NULL)
    {
        //
        // If we found no isolated apps, make the path list an empty multisz
        //
        cchDataPaths = 1;
        pwszDataPaths = new WCHAR[cchDataPaths];
        if( !pwszDataPaths )
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
        pwszDataPaths[0] = L'\0';
    }

    // Determine the maximum number of applications

    cMaxApplications = 1; // The pooled application

    for( pwszCurrentPath = pwszDataPaths; 
         *pwszCurrentPath != L'\0';
         pwszCurrentPath += wcslen(pwszCurrentPath) + 1
         )
    {
        cMaxApplications++;
    }

    //
    // Build a key array and load the com applications.
    //

    // Create an array to hold the keys

    rgsaBound[0].cElements = cMaxApplications;
    rgsaBound[0].lLbound = 0;

    psaApplications = SafeArrayCreate( VT_VARIANT, 1, rgsaBound );
    if( psaApplications == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // Set the out of process pool application key
    varAppKey.vt = VT_BSTR;
    varAppKey.bstrVal = SysAllocString( W3_OOP_POOL_PACKAGE_ID );
    if( !varAppKey.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    rgIndices[0] = 0;
    hr = SafeArrayPutElement( psaApplications, rgIndices, &varAppKey );
    if( FAILED(hr) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("Failed setting an element in a safe array (%08x)\n"),hr));
        goto cleanup;
    }

    // For each of the application paths determine if an out of process
    // application is defined there and set the appropriate key into
    // our array    

    MD_SET_DATA_RECORD_EXT( &mdrAppIsolated,
                            MD_APP_ISOLATED,
                            METADATA_NO_ATTRIBUTES,
                            ALL_METADATA,
                            DWORD_METADATA,
                            sizeof(DWORD),
                            (PBYTE)&dwAppIsolated
                            );

    MD_SET_DATA_RECORD_EXT( &mdrAppPackageId,
                            MD_APP_PACKAGE_ID,
                            METADATA_NO_ATTRIBUTES,
                            ALL_METADATA,
                            STRING_METADATA,
                            sizeof(wszAppPackageId),
                            (PBYTE)wszAppPackageId
                            );

    wszAppPackageId[0] = L'\0';

    // Go through each data path and set it into our array if
    // it is an isolated application

    cApplications = 1;  // Actual # of applications - 1 for pool

    for( pwszCurrentPath = pwszDataPaths; 
         *pwszCurrentPath != L'\0';
         pwszCurrentPath += wcslen(pwszCurrentPath) + 1
         )
    {
        hr = pcCom->GetData( hMetabase,
                             pwszCurrentPath,
                             &mdrAppIsolated,
                             &dwMDGetDataLen
                             );
        if( FAILED(hr) )
        {
            iisDebugOut(( LOG_TYPE_ERROR, 
                       _T("Failed to get data from the metabase (%08x) Path(%S) Data(%d)\n"),
                       hr,
                       pwszCurrentPath,
                       mdrAppIsolated.dwMDIdentifier
                       ));

            fNoErrors = FALSE;
            continue;
        }

        // Is the application out of process
        if( dwAppIsolated == 1 )
        {
            // Get the application id

            hr = pcCom->GetData( hMetabase,
                                 pwszCurrentPath,
                                 &mdrAppPackageId,
                                 &dwMDGetDataLen
                                 );
            if( FAILED(hr) )
            {
                iisDebugOut(( LOG_TYPE_ERROR,
                           _T("Failed to get data from the metabase (%08x) Path(%S) Data(%d)\n"),
                           hr,
                           pwszCurrentPath,
                           mdrAppPackageId.dwMDIdentifier
                           ));

                fNoErrors = FALSE;
                continue;
            }

            // Add the application id to the array

            VariantClear( &varAppKey );
            varAppKey.vt = VT_BSTR;
            varAppKey.bstrVal = SysAllocString( wszAppPackageId );
            if( !varAppKey.bstrVal )
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            rgIndices[0]++;
            hr = SafeArrayPutElement( psaApplications, 
                                      rgIndices, 
                                      &varAppKey 
                                      );
            if( FAILED(hr) )
            {
                iisDebugOut(( LOG_TYPE_ERROR,
                           _T("Failed to set safe array element (%08x)\n"),
                           hr
                           ));
                VariantClear( &varAppKey );
                rgIndices[0]--;
                fNoErrors = FALSE;
                continue;
            }
            cApplications++;
        }
    }

    // Done with the metabase
    pcCom->CloseKey(hMetabase);
    hMetabase = NULL;

    // Shrink the size of the safe-array if necessary
    if( cApplications < cMaxApplications )
    {
        rgsaBound[0].cElements = cApplications;

        hr = SafeArrayRedim( psaApplications, rgsaBound );
        if( FAILED(hr) )
        {
            iisDebugOut(( LOG_TYPE_ERROR,
                       _T("Failed to redim safe array (%08x)\n"),
                       hr
                       ));
            goto cleanup;
        }
    }

    //
    // For each application reset the activation identity
    //

    // Use our key array to get the application collection

    hr = CoCreateInstance( CLSID_COMAdminCatalog,
                           NULL,
                           CLSCTX_SERVER,
                           IID_ICOMAdminCatalog,
                           (void**)&pComCatalog
                           );
    if( FAILED(hr) )
    {
        iisDebugOut(( LOG_TYPE_ERROR,
                   _T("Failed to create COM catalog (%08x)\n"),
                   hr
                   ));
        goto cleanup;
    }

    hr = pComCatalog->GetCollection( L"Applications", 
                                     (IDispatch **)&pComAppCollection
                                     );
    if( FAILED(hr) )
    {
        iisDebugOut(( LOG_TYPE_ERROR,
                   _T("Failed to get Applications collection (%08x)\n"),
                   hr
                   ));
        goto cleanup;
    }

    hr = pComAppCollection->PopulateByKey( psaApplications );
    if( FAILED(hr) )
    {
        iisDebugOut(( LOG_TYPE_ERROR,
                   _T("Failed to populate Applications collection (%08x)\n"),
                   hr
                   ));
        goto cleanup;
    }

    // Iterate over the application collection and update all the
    // applications that use IWAM.

    hr = pComAppCollection->get_Count( &nAppsInCollection );
    if( FAILED(hr) )
    {
        iisDebugOut(( LOG_TYPE_ERROR,
                   _T("Failed to get Applications count (%08x)\n"),
                   hr
                   ));
        goto cleanup;
    }

    // Init our new app identity and password.

    varNewAppIdentity.vt = VT_BSTR;
    varNewAppIdentity.bstrVal = SysAllocString( szWamUserName );
    if( !varNewAppIdentity.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    varNewAppPassword.vt = VT_BSTR;
    varNewAppPassword.bstrVal = SysAllocString( szWamUserPass );
    if( !varNewAppPassword.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    for( iCurrentApp = 0; iCurrentApp < nAppsInCollection; ++iCurrentApp )
    {
        if( pComApp )
        {
            pComApp->Release();
            pComApp = NULL;
        }
        if( varOldAppIdentity.vt != VT_EMPTY )
        {
            VariantClear( &varOldAppIdentity );
        }

        hr = pComAppCollection->get_Item( iCurrentApp, 
                                          (IDispatch **)&pComApp );
        if( FAILED(hr) )
        {
            iisDebugOut(( LOG_TYPE_ERROR,
                       _T("Failed to get item from Applications collection (%08x)\n"),
                       hr
                       ));
            fNoErrors = FALSE;
            continue;
        }

        // If the user has set this to something other than the IWAM_
        // user, then we will respect that and not reset the identiy.

        hr = pComApp->get_Value( L"Identity", &varOldAppIdentity );
        if( FAILED(hr) )
        {
            iisDebugOut(( LOG_TYPE_ERROR,
                       _T("Failed to get Identify from Application (%08x)\n"),
                       hr
                       ));
            fNoErrors = FALSE;
            continue;
        }

        DBG_ASSERT( varOldAppIdentity.vt == VT_BSTR );
        if( varOldAppIdentity.vt == VT_BSTR )
        {
            if( memcmp( L"IWAM_", varOldAppIdentity.bstrVal, 10 ) == 0 )
            {
                hr = pComApp->put_Value( L"Identity", varNewAppIdentity );
                if( FAILED(hr) )
                {
                    iisDebugOut(( LOG_TYPE_ERROR,
                               _T("Failed to set new Identify (%08x)\n"),
                               hr
                               ));
                    fNoErrors = FALSE;
                    continue;
                }

                hr = pComApp->put_Value( L"Password", varNewAppPassword );
                if( FAILED(hr) )
                {
                    iisDebugOut(( LOG_TYPE_ERROR,
                               _T("Failed to set new Password (%08x)\n"),
                               hr
                               ));
                    fNoErrors = FALSE;
                    continue;
                }
            }
            else
            {
                DBGINFO(( DBG_CONTEXT,
                          "Unrecognized application identity (%S)\n",
                          varOldAppIdentity.bstrVal
                          ));
            }
        }
    }

    hr = pComAppCollection->SaveChanges( &nChanges );
    if( FAILED(hr) )
    {
        iisDebugOut(( LOG_TYPE_ERROR,
                   _T("Failed to save changes (%08x)\n"),
                   hr
                   ));
        goto cleanup;
    }
    
    goto cleanup;

cleanup:

    if( hMetabase != NULL )
    {
        pcCom->CloseKey(hMetabase);
    }

    if( psaApplications != NULL )
    {
        SafeArrayDestroy( psaApplications );
    }

    if( pComCatalog != NULL )
    {
        pComCatalog->Release();
    }

    if( pComAppCollection != NULL )
    {
        pComAppCollection->Release();
    }

    if( pComApp != NULL )
    {
        pComApp->Release();
    }

    if( varAppKey.vt != VT_EMPTY )
    {
        VariantClear( &varAppKey );
    }

    if( varOldAppIdentity.vt != VT_EMPTY )
    {
        VariantClear( &varOldAppIdentity );
    }

    if( varNewAppIdentity.vt != VT_EMPTY )
    {
        VariantClear( &varNewAppIdentity );
    }

    if( varNewAppPassword.vt != VT_EMPTY )
    {
        VariantClear( &varNewAppPassword );
    }

    delete [] pwszDataPaths;

    iisDebugOut((LOG_TYPE_TRACE, _T("UpdateComApplications():end\n")));

    // return
    if( FAILED(hr) )
    {
        return hr;
    }
    else if( fNoErrors == FALSE )
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}


GUFM_RETURN GetUserFromMetabase(IMSAdminBase2 *pcCom,
                                LPWSTR pszPath,
                                DWORD dwUserMetaId,
                                DWORD dwPasswordMetaId,
                                USERNAME_STRING_TYPE ustUserBuf,
                                PASSWORD_STRING_TYPE pstPasswordBuf)
{

    HRESULT hresTemp;
    GUFM_RETURN  gufmReturn = GUFM_SUCCESS;
    METADATA_RECORD mdrData;
    DWORD dwRequiredDataLen;

    METADATA_HANDLE mhOpenHandle;


    hresTemp = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                              pszPath,
                              METADATA_PERMISSION_READ,
                              OPEN_TIMEOUT_VALUE,
                              &mhOpenHandle);
    if (FAILED(hresTemp)) {
        gufmReturn = GUFM_NO_PATH;
    }
    else {
        MD_SET_DATA_RECORD_EXT(&mdrData,
                               dwUserMetaId,
                               METADATA_NO_ATTRIBUTES,
                               ALL_METADATA,
                               STRING_METADATA,
                               MAX_PATH * sizeof(TCHAR),
                               (PBYTE)ustUserBuf)

        hresTemp = pcCom->GetData(mhOpenHandle,
                                  NULL,
                                  &mdrData,
                                  &dwRequiredDataLen);

        if (FAILED(hresTemp) || (ustUserBuf[0] == (TCHAR)'\0')) {
            gufmReturn = GUFM_NO_USER_ID;
        }
        else {

            MD_SET_DATA_RECORD_EXT(&mdrData,
                                   dwPasswordMetaId,
                                   METADATA_NO_ATTRIBUTES,
                                   ALL_METADATA,
                                   STRING_METADATA,
                                   MAX_PATH * sizeof(TCHAR),
                                   (PBYTE)pstPasswordBuf)

            hresTemp = pcCom->GetData(mhOpenHandle,
                                      NULL,
                                      &mdrData,
                                      &dwRequiredDataLen);
            if (FAILED(hresTemp)) {
                gufmReturn = GUFM_NO_PASSWORD;
            }
        }
        pcCom->CloseKey(mhOpenHandle);
    }

    return gufmReturn;
}
#endif


HRESULT WINAPI SysPrepAclSyncIWam(void)
{
    HRESULT hr = S_OK;
    IMSAdminBase2 * pcCom;
    GUFM_RETURN gufmTemp;

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("start\n")));

    hr = CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase2,(void **) & pcCom);
    if (SUCCEEDED(hr)) 
    {
#ifndef _CHICAGO_
        PASSWORD_STRING_TYPE pstAnonyPass;
        USERNAME_STRING_TYPE ustAnonyName;

        pstAnonyPass[0] = (TCHAR)'\0';
        ustAnonyName[0] = (TCHAR)'\0';
        //
        // Get the WAM username and password
        //
        gufmTemp = GetUserFromMetabase(pcCom,
                                       TEXT("LM/W3SVC"),
                                       MD_WAM_USER_NAME,
                                       MD_WAM_PWD,
                                       ustAnonyName,
                                       pstAnonyPass);

        UpdateComApplications(pcCom,ustAnonyName,pstAnonyPass);
#endif
    pcCom->Release();
    }

    // Loop thru all the acl's
    // and get the values, store it somewhere

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("end,ret=0x%x\n"),hr));
    return hr;
}

// function: ReSetIWamIUsrPasswds
//
// This function Changes the IWAM and IUSR passwords the 
// metabase.  Then sets a reg entry, and stops and starts 
// iisadmin.  This causes iisadmin to reset the password in NT,
// and re sync the com objects.
//
// Return:
//   TRUE - Succeeded
//   FALSE - Failed
//
BOOL ReSetIWamIUsrPasswds(void)
{
    DWORD               dwType;
    DWORD               dwValue;
    DWORD               dwSize;
    DWORD               dwOldRegValue;
    BOOL                fOldRegWasSet = FALSE;
    CMDKey              cmdKey;
    LPTSTR              pszNewPassword = NULL;
    HKEY                hKey;

    iisDebugOut((LOG_TYPE_TRACE, _T("ReSetIWamIUsrPasswds:start\n")));

    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    REG_ENABLEPASSSYNC_KEY,
                    0,
                    KEY_READ | KEY_WRITE,
                    &hKey) != ERROR_SUCCESS)
    {
        // If we can not open the registry to set the flag,
        // there is not hope in resetting the password
        return FALSE;
    }

    cmdKey.OpenNode(TEXT("LM/W3SVC"));

    // Set New IUSR Password
    if (pszNewPassword = CreatePassword(LM20_PWLEN+1))
    {
        cmdKey.SetData(MD_ANONYMOUS_PWD,METADATA_INHERIT | METADATA_SECURE,IIS_MD_UT_FILE,STRING_METADATA,(_tcslen(pszNewPassword)+1)*sizeof(TCHAR),(LPBYTE) pszNewPassword);
        GlobalFree(pszNewPassword);
    }

    // Set New IWAM Password
    if (pszNewPassword = CreatePassword(LM20_PWLEN+1))
    {
        cmdKey.SetData(MD_WAM_PWD,METADATA_INHERIT | METADATA_SECURE,IIS_MD_UT_FILE,STRING_METADATA,(_tcslen(pszNewPassword)+1)*sizeof(TCHAR),(LPBYTE) pszNewPassword);
        GlobalFree(pszNewPassword);
    }

    cmdKey.Close();

    // Retrieve Old Value for REG_ENABLEPASSSYNC
    dwSize = sizeof(DWORD);
    if ( (RegQueryValueEx(hKey,REG_ENABLEPASSSYNC_VALUE,NULL,&dwType,(LPBYTE) &dwValue,&dwSize) == ERROR_SUCCESS) &&
         (dwType == REG_DWORD)
         )
    {
        fOldRegWasSet = TRUE;
        dwOldRegValue = dwValue;
    }

    // Set New Value
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    dwValue = 1;
    if (RegSetValueEx(hKey,REG_ENABLEPASSSYNC_VALUE,0,dwType,(LPBYTE) &dwValue,dwSize) == ERROR_SUCCESS)
    {

        // Stop IISAdmin Service
        StopServiceAndDependencies(TEXT("IISADMIN"), FALSE);

        // Start IISAdmin Service (this will resync the passwords)
        InetStartService(TEXT("IISADMIN"));

        // We are going to reboot after installing, so don't
        // worry about starting the services that we cascadingly
        // stopped

        // Reset the Key to the old value
        if (fOldRegWasSet)
        {
            dwSize = sizeof(DWORD);
            dwType = REG_DWORD;
            RegSetValueEx(hKey,REG_ENABLEPASSSYNC_VALUE,0,dwType,(LPBYTE) &dwOldRegValue,dwSize);
        }
        else
        {
            RegDeleteValue(hKey,REG_ENABLEPASSSYNC_VALUE);
        }
    }
    else
    {
        RegCloseKey(hKey);
        return FALSE;
    }

    RegCloseKey(hKey);

    return TRUE;
}


DWORD SysPrepTempfileWriteAclInfo(HANDLE hFile,CString csKeyPath)
{
    DWORD dwReturn = E_FAIL;

    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    PBYTE pData;
    int BufSize;

    PSECURITY_DESCRIPTOR pOldSd = NULL;

    if (hFile == NULL || hFile == INVALID_HANDLE_VALUE)
    {
        return S_OK;
    }

    cmdKey.OpenNode(csKeyPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound)
        {
            if (cbLen > 0)
            {
                if ( ! (bufData.Resize(cbLen)) )
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("MDDumpAdminACL():  cmdKey.GetData.  failed to resize to %d.!\n"), cbLen));
                }
                else
                {
                    pData = (PBYTE)(bufData.QueryPtr());
                    BufSize = cbLen;
                    cbLen = 0;
                    bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
                }
            }
        }
        cmdKey.Close();

        if (bFound)
        {
            // dump out the info
            // We've got the acl
            pOldSd = (PSECURITY_DESCRIPTOR) pData;
            if (IsValidSecurityDescriptor(pOldSd))
            {
#ifndef _CHICAGO_
                DumpAdminACL(hFile,pOldSd);
                dwReturn = ERROR_SUCCESS;
#endif
            }
        }
        else
        {
            // there was no acl to be found.
        }
    }
    return dwReturn;
}

void SysPrepTempfileWrite(HANDLE hFile,TCHAR * szBuf)
{
    DWORD dwBytesWritten = 0;
    if (hFile != NULL && hFile != INVALID_HANDLE_VALUE)
    {
        if (WriteFile(hFile, szBuf, _tcslen(szBuf) * sizeof(TCHAR), &dwBytesWritten, NULL ) == FALSE )
            {iisDebugOut((LOG_TYPE_WARN, _T("WriteFile Failed=0x%x.\n"), GetLastError()));}
    }
    return;
}

// Loop thru all the acl's
// and get the values, store it somewhere
HRESULT WINAPI SysPrepAclBackup(void)
{
    HRESULT hRes = S_OK;
    CMDKey cmdKey;
    CStringList cslpathList;
    POSITION        pos;
    CString         csPath;
    HANDLE  hFile = INVALID_HANDLE_VALUE;

    DWORD dwBytesWritten = 0;
    TCHAR buf[256];

    TCHAR szTempFileNameFull[_MAX_PATH];

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("start\n")));
   
	hRes = cmdKey.OpenNode(_T("/"));
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("OpenNode failed. err=0x%x.\n"), hRes));
        goto SysPrepAclBackup_Exit;
    }

    // get the sub-paths that have the data on them
    hRes = cmdKey.GetDataPaths( MD_ADMIN_ACL, BINARY_METADATA, cslpathList);
    if ( FAILED(hRes) )
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("Update()-GetDataPaths failed. err=0x%x.\n"), hRes));
        goto SysPrepAclBackup_Exit;
    }

    // we now have the cstringlist of paths that need to be updated. Loop through the
    // list and update them all.
    // get the list's head position
    pos = cslpathList.GetHeadPosition();
    if ( NULL == pos )
    {
        goto SysPrepAclBackup_Exit;
    }

    // Create the tempfile
	if (!GetWindowsDirectory(szTempFileNameFull,_MAX_PATH))
    {
        goto SysPrepAclBackup_Exit;
    }

    AddPath(szTempFileNameFull, SYSPREP_TEMPFILE_NAME);
    if (GetFileAttributes(szTempFileNameFull) != 0xFFFFFFFF)
    {
        // if file already exists, then delete it
        SetFileAttributes(szTempFileNameFull, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(szTempFileNameFull);
    }

    // create the file
	hFile = CreateFile(szTempFileNameFull,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hFile = NULL;
        goto SysPrepAclBackup_Exit;
	}
    SetFilePointer( hFile, NULL, NULL, FILE_END );

    // write a couple of bytes to the beginning of the file say that it's "unicode"
    WriteFile(hFile, (LPCVOID) 0xFF, 1, &dwBytesWritten, NULL);
    WriteFile(hFile, (LPCVOID) 0xFE, 1, &dwBytesWritten, NULL);

    // write a section so that setupapi api's can read it
    //
    //[version]
    //signature="$Windows NT$"
    memset(buf, 0, _tcslen(buf) * sizeof(TCHAR));
    _tcscpy(buf, _T("[version]\r\n"));SysPrepTempfileWrite(hFile, buf);
    _tcscpy(buf, _T("signature=\"$Windows NT$\"\r\n"));SysPrepTempfileWrite(hFile, buf);

    // Write in known section
    _stprintf(buf, _T("[%s]\r\n"),SYSPREP_KNOWN_SECTION_NAME);SysPrepTempfileWrite(hFile, buf);

    // Add entries for the [paths] section
    // [paths]
    // /
    // /w3svc/info
    // etc...
    //
    while ( NULL != pos )
    {
        // get the next path in question
        csPath = cslpathList.GetNext( pos );

        // Write to [paths] section
        _stprintf(buf, _T("%s\r\n"),csPath);
        SysPrepTempfileWrite(hFile, buf);

        // Save this whole list to the tempfile....
        //iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("[%s]\n"),csPath));
    }

    // close the metabase
    if ( (METADATA_HANDLE)cmdKey )
        {cmdKey.Close();}

    // go to the top of the list again
    pos = cslpathList.GetHeadPosition();
    while ( NULL != pos )
    {
        // get the next path in question
        csPath = cslpathList.GetNext( pos );

        // Write to [paths] section
        _stprintf(buf, _T("[%s]\r\n"),csPath);
        SysPrepTempfileWrite(hFile, buf);

        // Get the info that we will add to this section from looking up the metabase...
        // open up the metabase item for each of them.
        // Grab the AdminACL data, convert it to username/permissions
        // save the username/permission data into text format
        SysPrepTempfileWriteAclInfo(hFile,csPath);
    }

SysPrepAclBackup_Exit:
    if ( (METADATA_HANDLE)cmdKey )
        {cmdKey.Close();}
    if (hFile)
        {CloseHandle(hFile);}
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("end,ret=0x%x\n"),hRes));
    return hRes;
}



void SysPrepRestoreAclSection(IN HINF hFile, IN LPCTSTR szSection)
{
    LPTSTR  szLine = NULL;
    DWORD   dwRequiredSize;
    BOOL    bRet = FALSE;
    INFCONTEXT Context;

    // go to the beginning of the section in the INF file
    bRet = SetupFindFirstLine_Wrapped(hFile, szSection, NULL, &Context);
    if (!bRet)
        {
        goto SysPrepRestoreAclSection_Exit;
        }

    // loop through the items in the section.
    while (bRet) 
    {
        // get the size of the memory we need for this
        bRet = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

        // prepare the buffer to receive the line
        szLine = (LPTSTR)GlobalAlloc( GPTR, dwRequiredSize * sizeof(TCHAR) );
        if ( !szLine )
            {
            goto SysPrepRestoreAclSection_Exit;
            }
        
        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
            {
            goto SysPrepRestoreAclSection_Exit;
            }

        // The line we get should look something like this:
        //
        //[/]
        //IIS_WPG,0x0,0x0,0x24,0x400ab
        //Administrators,0x0,0x0,0x18,0x400ab
        //Everyone,0x0,0x0,0x14,0x8

        // Get everything to the left of the "=" sign
        // this should be the username
        TCHAR szUserName[UNLEN + 1];
        ACCESS_ALLOWED_ACE MyNewACE;

        /*
        typedef struct _ACCESS_ALLOWED_ACE {
            ACE_HEADER Header;
            ACCESS_MASK Mask;
            ULONG SidStart;
        } ACCESS_ALLOWED_ACE;

        typedef struct _ACE_HEADER {
            UCHAR AceType;
            UCHAR AceFlags;
            USHORT AceSize;
        } ACE_HEADER;
        typedef ACE_HEADER *PACE_HEADER;

          typedef ULONG ACCESS_MASK;
        */

        TCHAR *token = NULL;
        token = _tcstok(szLine, _T(","));
        if (token == NULL)
        {
            goto SysPrepRestoreAclSection_Exit;
        }
        // Get the username
        _tcscpy(szUserName,token);

        // Get the next 4 values...
        token = _tcstok(NULL, _T(","));
        if (NULL == token){goto SysPrepRestoreAclSection_Exit;}
        MyNewACE.Header.AceType = (UCHAR) atodw(token);

        token = _tcstok(NULL, _T(","));
        if (NULL == token){goto SysPrepRestoreAclSection_Exit;}
        MyNewACE.Header.AceFlags = (UCHAR) atodw(token);

        token = _tcstok(NULL, _T(","));
        if (NULL == token){goto SysPrepRestoreAclSection_Exit;}
        MyNewACE.Header.AceSize = (USHORT) atodw(token);

        token = _tcstok(NULL, _T(","));
        if (NULL == token){goto SysPrepRestoreAclSection_Exit;}
        MyNewACE.Mask = atodw(token);

        //iisDebugOut((LOG_TYPE_TRACE, _T("NewACLinfo:%s,0x%x,0x%x,0x%x,0x%x\n"),szUserName,MyNewACE.Header.AceType,MyNewACE.Header.AceFlags,MyNewACE.Header.AceSize,MyNewACE.Mask));

        // Grab this info and create an ACL for it.
        AddUserToMetabaseACL2(szSection,szUserName,&MyNewACE);
       
        // find the next line in the section. If there is no next line it should return false
        bRet = SetupFindNextLine(&Context, &Context);

        // free the temporary buffer
        GlobalFree( szLine );szLine=NULL;
        szLine = NULL;
    }

SysPrepRestoreAclSection_Exit:
    if (szLine) {GlobalFree(szLine);szLine=NULL;}
    return;
}


DWORD AddUserToMetabaseACL2(CString csKeyPath, LPTSTR szUserToAdd, ACCESS_ALLOWED_ACE * MyACEInfo)
{
    DWORD dwReturn = E_FAIL;

    BOOL bFound = FALSE;
    DWORD attr, uType, dType, cbLen;
    CMDKey cmdKey;
    BUFFER bufData;
    PBYTE pData;
    int BufSize;

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddUserToMetabaseACL2():start.  MyACEInfo->Mask=0x%x.\n"), MyACEInfo->Mask));

    PSECURITY_DESCRIPTOR pOldSd = NULL;
    PSECURITY_DESCRIPTOR pNewSd = NULL;

    cmdKey.OpenNode(csKeyPath);
    if ( (METADATA_HANDLE) cmdKey )
    {
        pData = (PBYTE)(bufData.QueryPtr());
        BufSize = bufData.QuerySize();
        cbLen = 0;
        bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
        if (!bFound)
        {
            if (cbLen > 0)
            {
                if ( ! (bufData.Resize(cbLen)) )
                {
                    iisDebugOut((LOG_TYPE_ERROR, _T("AddUserToMetabaseACL2():  cmdKey.GetData.  failed to resize to %d.!\n"), cbLen));
                }
                else
                {
                    pData = (PBYTE)(bufData.QueryPtr());
                    BufSize = cbLen;
                    cbLen = 0;
                    bFound = cmdKey.GetData(MD_ADMIN_ACL, &attr, &uType, &dType, &cbLen, pData, BufSize);
                }
            }
        }

        cmdKey.Close();

        if (bFound)
        {
            // We've got the acl
            // so now we want to add a user to it.
            pOldSd = (PSECURITY_DESCRIPTOR) pData;
            if (IsValidSecurityDescriptor(pOldSd))
            {
                DWORD AccessMask = (MD_ACR_READ |MD_ACR_WRITE |MD_ACR_RESTRICTED_WRITE |MD_ACR_UNSECURE_PROPS_READ |MD_ACR_ENUM_KEYS |MD_ACR_WRITE_DAC);
                PSID principalSID = NULL;
                BOOL bWellKnownSID = FALSE;

                // Get the SID for the certain string (administrator or everyone or whoever)
                dwReturn = GetPrincipalSID(szUserToAdd, &principalSID, &bWellKnownSID);
                if (dwReturn != ERROR_SUCCESS)
                    {
                    iisDebugOut((LOG_TYPE_WARN, _T("AddUserToMetabaseACL2:GetPrincipalSID(%s) FAILED.  Error()= 0x%x\n"), szUserToAdd, dwReturn));
                    return dwReturn;
                    }

#ifndef _CHICAGO_
//#define ACCESS_ALLOWED_ACE_TYPE                 (0x0)
//#define ACCESS_DENIED_ACE_TYPE                  (0x1)
//#define SYSTEM_AUDIT_ACE_TYPE                   (0x2)
                if (FALSE == AddUserAccessToSD(pOldSd,principalSID,MyACEInfo->Mask,MyACEInfo->Header.AceType,&pNewSd))
                {
                    return dwReturn;
                }
                if (pNewSd)
                {
                    // We have a new self relative SD
                    // lets write it to the metabase.
                    if (IsValidSecurityDescriptor(pNewSd))
                    {
                       dwReturn = WriteSDtoMetaBase(pNewSd, csKeyPath);
                    }
                    else
                    {
                        iisDebugOut((LOG_TYPE_ERROR, _T("AddUserToMetabaseACL2:IsValidSecurityDescriptor failed, bad sd\n")));
                    }
                }
#endif
            }
        }
        else
        {
            // there was no acl to be found.

        }

    }

    if (pNewSd){GlobalFree(pNewSd);}
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("AddUserToMetabaseACL2():End.  Return=0x%x.\n"), dwReturn));
    return dwReturn;
}


HRESULT WINAPI SysPrepAclRestore(void)
{
    HRESULT hr = S_OK;
    HINF InfHandle;
    TCHAR szTempFileNameFull[_MAX_PATH];
    CStringList strList;
    CString csTheSection = SYSPREP_KNOWN_SECTION_NAME;

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("start\n")));
    //MDDumpAdminACL(_T("/"));

    // Loop thru our data file
    // Create the tempfile
	if (!GetWindowsDirectory(szTempFileNameFull,_MAX_PATH))
    {
        goto SysPrepAclRestore_Exit;
    }
    AddPath(szTempFileNameFull, SYSPREP_TEMPFILE_NAME);

    // Get a handle to it.
    InfHandle = SetupOpenInfFile(szTempFileNameFull, NULL, INF_STYLE_WIN4, NULL);
    if(InfHandle == INVALID_HANDLE_VALUE) 
    {
        goto SysPrepAclRestore_Exit;
    }

    if (ERROR_SUCCESS == FillStrListWithListOfSections(InfHandle, strList, csTheSection))
    {
        // loop thru the list returned back
        if (strList.IsEmpty() == FALSE)
        {
            POSITION pos;
            CString csEntry;

            pos = strList.GetHeadPosition();
            while (pos) 
            {
                csEntry = strList.GetAt(pos);

                // go get this section and read thru it's info
                SysPrepRestoreAclSection(InfHandle, csEntry);
                strList.GetNext(pos);
            }
        }
    }

    //MDDumpAdminACL(_T("/"));

    if (GetFileAttributes(szTempFileNameFull) != 0xFFFFFFFF)
    {
        // if file already exists, then delete it
        SetFileAttributes(szTempFileNameFull, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(szTempFileNameFull);
    }


SysPrepAclRestore_Exit:
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("end,ret=0x%x\n"),hr));
    return hr;
}

//
// DO NOT REMOVE THIS ENTRY POINT
//
// Entry point used by SysPrep in Whistler
//
// When sysprep runs, it is going to reset the machine sid
// so when that happens all the crypto stuff is broken.
// we had to implement this stuff so that before sysprep
// changes the sid (and thus breaking crypto) we can save our
// working metabase off somewhere (without crypto key encryption)
//
// At some point after sysprep has changed the machine sid
// it will call us into SysPrepRestore() and we wil restore
// our metabase using the new crypto keys on the machine.
//
HRESULT WINAPI SysPrepBackup(void)
{
    HRESULT hr = S_OK;
    WCHAR lpwszBackupLocation[_MAX_PATH];
    DWORD dwMDVersion;
    DWORD dwMDFlags;
    WCHAR * pwszPassword = NULL;
    BOOL bThingsAreGood = FALSE;
    IMSAdminBase2 * pIMSAdminBase2 = NULL;

    _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("SysPrepBackup:"));
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("start\n")));
#ifndef _CHICAGO_
#ifdef SYSPREP_USE_SECRETS
#else
    CRegKey regBigString(HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_ALL_ACCESS);
#endif
#endif
    // Check if the user who loaded this dll 
    // and is calling this entry point has the right priv to do this!
    if (FALSE == RunningAsAdministrator())
    {
        hr = E_ABORT;
        iisDebugOut((LOG_TYPE_ERROR, _T("No admin priv, aborting\n")));
        goto SysPrepBackup_Exit2;
    }


    // if the service doesn't exist, then we don't have to do anyting
    if (CheckifServiceExist(_T("IISADMIN")) != 0 ) 
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("IIS not installed. do nothing.\n")));
        hr = S_OK;
        goto SysPrepBackup_Exit2;
    }

    // start the iisadmin service before calling backup.
    // this is because if the backup function is called and the metabase is not
    // running, then the metabase must startup while backup is trying to lock the
    // metabase for backup.  a race condition will happen and sometimes backup will
    // fail since the metabase may take a while before starting up.
    // this function will wait till the service is fully started before returning
    InetStartService(_T("IISADMIN"));

#ifndef _CHICAGO_
    pwszPassword = CreatePassword(SYSPREP_TEMP_PASSWORD_LENGTH);
    if (pwszPassword)
    {
#ifdef SYSPREP_USE_SECRETS
        // calling set 
        if (ERROR_SUCCESS == SetSecret(SYSPREP_KNOWN_REGISTRY_KEY,pwszPassword))
        {
            bThingsAreGood = TRUE;
        }
#else
        if ((HKEY) regBigString)
        {
            regBigString.SetValue(SYSPREP_KNOWN_REGISTRY_KEY, pwszPassword);
            bThingsAreGood = TRUE;
        }
#endif
    }

    //iisDebugOut((LOG_TYPE_TRACE, _T("PASSWORD=%s,len=%d\n"),pwszPassword,wcslen(pwszPassword)));
#endif

    // Tell the metabase where it should backup to.
    wcscpy(lpwszBackupLocation,L"");
    
    dwMDFlags = MD_BACKUP_OVERWRITE | MD_BACKUP_SAVE_FIRST | MD_BACKUP_FORCE_BACKUP;
    dwMDVersion = MD_BACKUP_MAX_VERSION;

#ifndef _CHICAGO_
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
#else
    hr = CoInitialize(NULL);
#endif
    // no need to call uninit
    if( FAILED (hr)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CoInitializeEx failed\n")));
        goto SysPrepBackup_Exit2;
    }

    hr = ::CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase2,(void **) & pIMSAdminBase2);
    if(FAILED (hr)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CoCreateInstance on IID_IMSAdminBase2 failed\n")));
        goto SysPrepBackup_Exit;
    }

    // Call the metabase function
	if (SUCCEEDED(hr))
	{
        iisDebugOut((LOG_TYPE_TRACE, _T("BackupWithPasswd calling...\n")));
        if (bThingsAreGood)
        {
            //iisDebugOut((LOG_TYPE_TRACE, _T("using org\n")));
		    hr = pIMSAdminBase2->BackupWithPasswd(lpwszBackupLocation, dwMDVersion, dwMDFlags, pwszPassword);
        }
        else
        {
            //iisDebugOut((LOG_TYPE_TRACE, _T("using backup\n")));
            hr = pIMSAdminBase2->BackupWithPasswd(lpwszBackupLocation, dwMDVersion, dwMDFlags, L"null");
        }
        if (pIMSAdminBase2) 
        {
            pIMSAdminBase2->Release();
            pIMSAdminBase2 = NULL;
        }
        if (SUCCEEDED(hr))
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("BackupWithPasswd SUCCEEDED\n")));
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("BackupWithPasswd failed\n")));
        }

        // Save all the acl info somewhere.
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("SysPrepAclBackup"));
        SysPrepAclBackup();
        _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
	}

SysPrepBackup_Exit:
    CoUninitialize();

SysPrepBackup_Exit2:
    if (pwszPassword) {GlobalFree(pwszPassword);pwszPassword=NULL;}
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("end,ret=0x%x\n"),hr));
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T(""));
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
    return hr;
}

//
// DO NOT REMOVE THIS ENTRY POINT
//
// Entry point used by SysPrep in Whistler
//
// When sysprep runs, it is going to reset the machine sid
// so when that happens all the crypto stuff is broken.
// we had to implement this stuff so that before sysprep
// changes the sid (and thus breaking crypto) we can save our
// working metabase off somewhere (without crypto key encryption)
//
// At some point after sysprep has changed the machine sid
// it will call us into SysPrepRestore() and we wil restore
// our metabase using the new crypto keys on the machine.
//
HRESULT WINAPI SysPrepRestore(void)
{
    HRESULT hr = S_OK;
    WCHAR lpwszBackupLocation[_MAX_PATH];
    TCHAR  szTempDir[_MAX_PATH];
    TCHAR  szSystemDir[_MAX_PATH];
    DWORD dwMDVersion;
    DWORD dwMDFlags;
	WCHAR * pwszPassword = NULL;
    IMSAdminBase2 * pIMSAdminBase2 = NULL;
    BOOL bThingsAreGood = FALSE;

    _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T("SysPrepRestore:"));
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("start\n")));

#ifndef _CHICAGO_
#ifdef SYSPREP_USE_SECRETS
    BUFFER * pbufSecret = NULL;
#else
    CRegKey regBigString(HKEY_LOCAL_MACHINE, REG_INETSTP, KEY_ALL_ACCESS);
#endif
#endif
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SysPrepRestore start\n")));
    // Check if the user who loaded this dll 
    // and is calling this entry point has the right priv to do this!
    if (FALSE == RunningAsAdministrator())
    {
        hr = E_ABORT;
        iisDebugOut((LOG_TYPE_ERROR, _T("No admin priv, aborting\n")));
        goto SysPrepRestore_Exit2;
    }

    // if the service doesn't exist, then we don't have to do anyting
    if (CheckifServiceExist(_T("IISADMIN")) != 0 ) 
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("SysPrepRestore IIS not installed. do nothing.\n")));
        hr = S_OK;
        goto SysPrepRestore_Exit2;
    }

    // make sure the iisadmin service is stopped.
    StopServiceAndDependencies(_T("IISADMIN"), TRUE);

#ifndef _CHICAGO_
#ifdef SYSPREP_USE_SECRETS
    pbufSecret = new BUFFER();
    if (pbufSecret)
    {
        if (GetSecret(SYSPREP_KNOWN_REGISTRY_KEY, pbufSecret))
        {
            LPWSTR pwsz = NULL;
            pwsz = (WCHAR *) pbufSecret->QueryPtr();

            // alloc some space the same size
            pwszPassword = (WCHAR *) GlobalAlloc (GPTR, pbufSecret->QuerySize());

            _tcscpy(pwszPassword, pwsz);

            delete(pbufSecret);
            pbufSecret = NULL;
            bThingsAreGood = TRUE;
        }
    }
#else
    if ((HKEY) regBigString)
    {
        CString csTheData;
        if ( regBigString.QueryValue(SYSPREP_KNOWN_REGISTRY_KEY, csTheData) == ERROR_SUCCESS )
        {
            pwszPassword = (WCHAR *) GlobalAlloc (GPTR, (csTheData.GetLength() + 1) * sizeof(TCHAR) );
            if (pwszPassword)
            {
                wcscpy(pwszPassword,csTheData);
                bThingsAreGood = TRUE;
            }
        }
    }
#endif
#endif

    //iisDebugOut((LOG_TYPE_TRACE, _T("PASSWORD=%s,len=%d\n"),pwszPassword,wcslen(pwszPassword)));


    // Tell the metabase where it should backup to.
    wcscpy(lpwszBackupLocation,L"");
    dwMDFlags = 0;
    dwMDVersion = MD_BACKUP_MAX_VERSION;

    //
    // IISAdmin won't start up if the metabase.xml,mbschema.xml files are corrupted (bad signature)
    // so delete them before restoring....
    if (0 == GetSystemDirectory(szSystemDir, _MAX_PATH))
    {
        goto SysPrepRestore_Exit2;
    }

    // iis6 files -- for whistler server skus
    _stprintf(szTempDir, _T("%s\\inetsrv\\Metabase.xml"),szSystemDir);
    InetDeleteFile(szTempDir);
    _stprintf(szTempDir, _T("%s\\inetsrv\\MBSchema.xml"),szSystemDir);
    InetDeleteFile(szTempDir);
    // iis51 files -- for whistler pro sku
    _stprintf(szTempDir, _T("%s\\inetsrv\\metabase.bin"),szSystemDir);
    InetDeleteFile(szTempDir);
    
#ifndef _CHICAGO_
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
#else
    hr = CoInitialize(NULL);
#endif
    // no need to call uninit
    if( FAILED (hr)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CoInitializeEx failed\n")));
        goto SysPrepRestore_Exit2;
    }
    hr = ::CoCreateInstance(CLSID_MSAdminBase,NULL,CLSCTX_ALL,IID_IMSAdminBase2,(void **) & pIMSAdminBase2);
    if(FAILED (hr)) 
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CoCreateInstance on IID_IMSAdminBase2 failed\n")));
        goto SysPrepRestore_Exit;
    }

    // Call the metabase function
	if (SUCCEEDED(hr))
	{
        iisDebugOut((LOG_TYPE_TRACE, _T("RestoreWithPasswd calling...\n")));
        if (bThingsAreGood)
        {
            //iisDebugOut((LOG_TYPE_TRACE, _T("using org\n")));
		    hr = pIMSAdminBase2->RestoreWithPasswd(lpwszBackupLocation, dwMDVersion, dwMDFlags, pwszPassword);
        }
        else
        {
            //iisDebugOut((LOG_TYPE_TRACE, _T("using backup\n")));
            hr = pIMSAdminBase2->RestoreWithPasswd(lpwszBackupLocation, dwMDVersion, dwMDFlags, L"null");
        }
        if (pIMSAdminBase2) 
        {
            pIMSAdminBase2->Release();
            pIMSAdminBase2 = NULL;
        }
        if (SUCCEEDED(hr))
        {

            // Delete the backup file that we used!
            //MD_DEFAULT_BACKUP_LOCATION + ".md" + MD_BACKUP_MAX_VERSION
            _stprintf(szTempDir, _T("%s\\inetsrv\\MetaBack\\%s.md%d"),szSystemDir,MD_DEFAULT_BACKUP_LOCATION,MD_BACKUP_MAX_VERSION);
            InetDeleteFile(szTempDir);
            _stprintf(szTempDir, _T("%s\\inetsrv\\MetaBack\\%s.sc%d"),szSystemDir,MD_DEFAULT_BACKUP_LOCATION,MD_BACKUP_MAX_VERSION);
            InetDeleteFile(szTempDir);
            iisDebugOut((LOG_TYPE_TRACE, _T("RestoreWithPasswd SUCCEEDED\n")));
#ifndef _CHICAGO_
#ifdef SYSPREP_USE_SECRETS
            // we need to delete the Secret that we used here!            
            SetSecret(SYSPREP_KNOWN_REGISTRY_KEY,L" ");
#else
            if ((HKEY) regBigString)
            {
                regBigString.DeleteValue(SYSPREP_KNOWN_REGISTRY_KEY);
            }
#endif
#endif

            // Do extra stuff
            // like Re-applying the acl for the iis_wpg group to the "/" node
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("SysPrepAclRestore"));
            SysPrepAclRestore();
            _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));

            // syncronize wam with new iwam user
            //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T("SysPrepAclSyncIWam"));
            //SysPrepAclSyncIWam();
            //_tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("RestoreWithPasswd failed\n")));
        }
	}

    // Reset the passwords, and allow iisadmin to fix the com information
    if (!ReSetIWamIUsrPasswds())
    {
        iisDebugOut((LOG_TYPE_WARN, _T("ReSetIWamIUsrPasswds was unable to reset IUSR and IWAM passwords\n")));
    }

SysPrepRestore_Exit:
    CoUninitialize();

SysPrepRestore_Exit2:
    if (pwszPassword) {GlobalFree(pwszPassword);pwszPassword=NULL;}
    iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("end,ret=0x%x\n"),hr));
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo, _T(""));
    _tcscpy(g_MyLogFile.m_szLogPreLineInfo2, _T(""));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\svc.cpp ===
#include "stdafx.h"
#include <winsvc.h>
#include <winsock2.h>
#include <nspapi.h>
#include "w3svc.h"
#include <inetsvcs.h>
#include <pwsdata.hxx>
#include "kill.h"
#include "svc.h"

TCHAR gServicesWhichMustBeRestarted[20][PROCESS_SIZE];
int gServicesWhichMustBeRestarted_nextuse = 0;
int gServicesWhichMustBeRestarted_total = 0;

extern int g_GlobalDebugLevelFlag;

int ServicesRestartList_EntryExists(LPCTSTR szServiceName)
{
    int iFoundMatch = FALSE;

    // loop thru the whole list
    for(int i=0; i < gServicesWhichMustBeRestarted_total;i++)
    {
        if (_tcsicmp(gServicesWhichMustBeRestarted[i], szServiceName) == 0)
        {
            iFoundMatch = TRUE;
            break;
        }
    }

    return iFoundMatch;
}


int ServicesRestartList_Add(LPCTSTR szServiceName)
{
    // check if this value already exists in the globalarary
    if (ServicesRestartList_EntryExists(szServiceName)) {return FALSE;}
    
    // move info into global array
    if (gServicesWhichMustBeRestarted_nextuse <= 20)
    {
        _tcscpy(gServicesWhichMustBeRestarted[gServicesWhichMustBeRestarted_nextuse],szServiceName);
        // increment counter to array
        // increment next use space
        ++gServicesWhichMustBeRestarted_total;
        ++gServicesWhichMustBeRestarted_nextuse;
    }
    return TRUE;
}

int ServicesRestartList_RestartServices(void)
{
    int iReturn = FALSE;
    INT err = 0;

    // loop thru the whole list and restart the services in reverse
    // order from how they were entered?
    if (gServicesWhichMustBeRestarted_total >= 1)
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("RestartServices()Start.\n")));
        for(int i=0; i < gServicesWhichMustBeRestarted_total;i++)
        {
            if (CheckifServiceExist(gServicesWhichMustBeRestarted[i]) == 0 ) 
            {
                err = InetStartService(gServicesWhichMustBeRestarted[i]);
            }
            else
            {
                iisDebugOut((LOG_TYPE_TRACE, _T("RestartServices():%s:Not restarting since it no longer exist.\n"),gServicesWhichMustBeRestarted[i]));
            }
        }
        iisDebugOut_End(_T("RestartServices"));
    }

    return iReturn;
}

DWORD InetStopExtraWait(LPCTSTR lpServiceName)
{
    DWORD dwSvcMaxSleep = 180000;
    int iFileExist = FALSE;

    // Wait.  How long should we really wait for this service to actually stop?
    // the iisadmin Service can take a long time if the metabase.bin file is huge.
    // So... if it's the iisadmin service we're trying to stop, then
    // check to see how big the metabase.bin file is, then for each 1meg give it 3 minutes (180000)
    if (_tcsicmp(lpServiceName,_T("IISADMIN")) == 0)
    {
        // look for the metabase.bin file
        TCHAR szTempDir[_MAX_PATH];
        _tcscpy(szTempDir, g_pTheApp->m_csPathInetsrv);
        AddPath(szTempDir, _T("Metabase.bin"));
        if (IsFileExist(szTempDir))
        {
            iFileExist = TRUE;
        }
        else
        {
            _tcscpy(szTempDir, g_pTheApp->m_csPathInetsrv);
            AddPath(szTempDir, _T("Metabase.xml"));
            if (IsFileExist(szTempDir))
            {
                iFileExist = TRUE;
            }
        }

        if (TRUE == iFileExist)
        {
            // Check to see how big it is.
            DWORD dwFileSize = ReturnFileSize(szTempDir);
            if (dwFileSize != 0xFFFFFFFF)
            {
                int iTime = 1;
                // We were able to get the file size.
                // for each meg for size, give it 3 minutes to save.
                if (dwFileSize > 1000000)
                {
                    iTime = (dwFileSize/1000000);
                    dwSvcMaxSleep = iTime * 180000;

                    iisDebugOut((LOG_TYPE_TRACE, _T("InetStopExtraWait():Metabase.bin is kind of big (>1meg), Lets wait longer for IISADMIN service to stop.maxmilsec=0x%x.\n"),dwSvcMaxSleep));
                }
            }
        }
    }
    return dwSvcMaxSleep;
}

INT InetDisableService( LPCTSTR lpServiceName )
{
    INT err = 0;
    const DWORD dwSvcSleepInterval = 500 ;
    DWORD dwSvcMaxSleep = 180000 ;
    DWORD dwSleepTotal;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    // Calculcate if this is a "special" service which we 
    // need to give more time to in order to stop.
    dwSvcMaxSleep = InetStopExtraWait(lpServiceName);

    do {
        if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL || (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        // if the service is running, stop it
        SERVICE_STATUS svcStatus;
        if ( QueryServiceStatus( hService, &svcStatus ))
        {
            if (( svcStatus.dwCurrentState == SERVICE_RUNNING ))
            {
                if ( !ControlService( hService, SERVICE_CONTROL_STOP, &svcStatus ))
                {
                    err = GetLastError();
                    break;
                }
                for ( dwSleepTotal = 0 ;
                    dwSleepTotal < dwSvcMaxSleep
                    && (QueryServiceStatus( hService, & svcStatus ))
                    && svcStatus.dwCurrentState == SERVICE_STOP_PENDING ;
                    dwSleepTotal += dwSvcSleepInterval )
                {
                    ::Sleep( dwSvcSleepInterval ) ;
                }
            }
        }

        err = ::ChangeServiceConfig( hService, SERVICE_NO_CHANGE, SERVICE_DISABLED,SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, NULL, NULL, NULL );

    } while ( FALSE );

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetDisableService():ServiceName=%s.  Return=0x%x\n"), lpServiceName, err));
    return(err);
}

INT InetStartService( LPCTSTR lpServiceName )
{
    iisDebugOut_Start1(_T("InetStartService"),(LPTSTR) lpServiceName);

    INT err = 0;
    INT err2 = 0;
    const DWORD dwSvcSleepInterval = 500 ;
    DWORD dwSvcMaxSleep = 180000 ;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    // Calculcate if this is a "special" service which we 
    // need to give more time to in order to stop.
    dwSvcMaxSleep = InetStopExtraWait(lpServiceName);

    do 
    {
        // set up the service first
        if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL || (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        SERVICE_STATUS svcStatus;
        if ( !QueryServiceStatus( hService, &svcStatus ))
        {
            err = ::GetLastError();
            break;
        }

        if ( svcStatus.dwCurrentState == SERVICE_RUNNING )
        {
            // We will only get this ERROR_SERVICE_MARKED_FOR_DELETE
            // message if the service is already running.
            if ( !::StartService( hService, 0, NULL ))
            {
                err2 = ::GetLastError();
                if (err2 == ERROR_SERVICE_MARKED_FOR_DELETE) {err = err2;}
            }
            break; // service already started and running
        }

        if ( !::StartService( hService, 0, NULL ))
        {
            err = ::GetLastError();
            break;
        }

        //  Wait for the service to attain "running" status; but
        //  wait no more than 3 minute.
        DWORD dwSleepTotal;
        for ( dwSleepTotal = 0 ; dwSleepTotal < dwSvcMaxSleep
            && (QueryServiceStatus( hService, &svcStatus ))
            && svcStatus.dwCurrentState == SERVICE_START_PENDING ;
            dwSleepTotal += dwSvcSleepInterval )
        {
            ::Sleep( dwSvcSleepInterval ) ;
        }

        if ( svcStatus.dwCurrentState != SERVICE_RUNNING )
        {
            err = dwSleepTotal > dwSvcMaxSleep ? ERROR_SERVICE_REQUEST_TIMEOUT : svcStatus.dwWin32ExitCode;
            break;
        }

    } while ( FALSE );

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}

    if (err){iisDebugOut((LOG_TYPE_WARN, _T("InetStartService():ServiceName=%s unable to start WARNING.  Err=0x%x.\n"), lpServiceName, err));}
    else{iisDebugOut((LOG_TYPE_TRACE, _T("InetStartService():ServiceName=%s success.\n"), lpServiceName));}
    return(err);
}

DWORD InetQueryServiceStatus( LPCTSTR lpServiceName )
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("InetQueryServiceStatus():ServiceName=%s\n"), (LPTSTR) lpServiceName));
    DWORD dwStatus = 0;
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS svcStatus;

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL || 
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL ||
            !::QueryServiceStatus( hService, &svcStatus ) )
        {
            err = GetLastError();
            break;
        }

        dwStatus = svcStatus.dwCurrentState;

    } while (0);

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("InetQueryServiceStatus():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
    return( dwStatus );
}

INT InetStopService( LPCTSTR lpServiceName )
{
    INT err = 0;
    const DWORD dwSvcSleepInterval = 500 ;
    DWORD dwSvcMaxSleep = 180000 ;
    DWORD dwSleepTotal;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    // Calculcate if this is a "special" service which we 
    // need to give more time to in order to stop.
    dwSvcMaxSleep = InetStopExtraWait(lpServiceName);
    
    do {
        if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        SERVICE_STATUS svcStatus;
        if ( !QueryServiceStatus( hService, &svcStatus ))
        {
            err = ::GetLastError();
            break;
        }

        if ( svcStatus.dwCurrentState == SERVICE_STOPPED )
            break; // service already stopped

         if (( svcStatus.dwCurrentState == SERVICE_RUNNING ))
        {
            if ( !ControlService( hService, SERVICE_CONTROL_STOP, &svcStatus ))
            {
                err = GetLastError();
                break;
            }
            for ( dwSleepTotal = 0 ;
                dwSleepTotal < dwSvcMaxSleep
                && (QueryServiceStatus( hService, & svcStatus ))
                && svcStatus.dwCurrentState == SERVICE_STOP_PENDING ;
                dwSleepTotal += dwSvcSleepInterval )
            {
                ::Sleep( dwSvcSleepInterval ) ;
            }
        }

        if ( svcStatus.dwCurrentState != SERVICE_STOPPED )
        {
            err = dwSleepTotal > dwSvcMaxSleep ?
                ERROR_SERVICE_REQUEST_TIMEOUT :
                svcStatus.dwWin32ExitCode;
            break;
        }

    } while ( FALSE );

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetStopService():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
    return(err);
}

INT InetDeleteService( LPCTSTR lpServiceName )
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    /*
    The DeleteService function marks a service for deletion from the service control manager database.
    The database entry is not removed until all open handles to the service have been closed by calls
    to the CloseServiceHandle function, and the service is not running. A running service is stopped
    by a call to the ControlService function with the SERVICE_CONTROL_STOP control code.
    If the service cannot be stopped, the database entry is removed when the system is restarted.
    The service control manager deletes the service by deleting the service key and its subkeys from
    the registry.
    */
    // To delete service immediately, we need to stop service first
    StopServiceAndDependencies(lpServiceName, FALSE);

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL ||
            !::DeleteService( hService ) )
        {
            err = GetLastError();
            break;
        }
    } while (0);

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetDeleteService():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
    return(err);
}

INT InetCreateDriver(LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, DWORD dwStartType)
{
    iisDebugOut_Start1(_T("InetCreateDriver"),(LPTSTR) lpServiceName);

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    do {
        if ( (hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }
		//
		// if Driver already exits then just change the parameters
		//
		if ( CheckifServiceExist(  lpServiceName ) == 0 ) {

			hService = OpenService( hScManager, lpServiceName, GENERIC_ALL );
			
			if ( hService ) {
	   			if ( ChangeServiceConfig( 
						hService,  				// handle to service 
					 	SERVICE_KERNEL_DRIVER,  // type of service 
						dwStartType,  			// when to start service 
					 	SERVICE_ERROR_NORMAL,  	// severity if service fails to start 
					  	lpBinaryPathName,  		// pointer to service binary file name 
						NULL,				  	// pointer to load ordering group name 
					 	NULL, 		 			// pointer to variable to get tag identifier 
					  	NULL, 					// pointer to array of dependency names 
					 	NULL,  					// pointer to account name of service 
					 	NULL, 	 				// pointer to password for service account 
					  	lpDisplayName  			// pointer to display name 
					 	) ){
					 	break;
            	}
			}

		} else {

	        hService = ::CreateService( hScManager, lpServiceName, lpDisplayName,
                GENERIC_ALL, SERVICE_KERNEL_DRIVER, dwStartType,
                SERVICE_ERROR_NORMAL, lpBinaryPathName, NULL, NULL,
                NULL, NULL, NULL );
                
	        if ( hService )  {
            	break;
	        }
		}
    	err = GetLastError();

    } while ( FALSE );

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetCreateDriver():Name=%s. Return=0x%x.\n"), lpServiceName, err));
    return(err);
}

INT InetCreateService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, DWORD dwStartType, LPCTSTR lpDependencies)
{
    iisDebugOut_Start1(_T("InetCreateService"),(LPTSTR) lpServiceName);

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    do {
        if ( (hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

        hService = ::CreateService( hScManager, lpServiceName, lpDisplayName,
                GENERIC_ALL, SERVICE_WIN32_SHARE_PROCESS, dwStartType,
                SERVICE_ERROR_NORMAL, lpBinaryPathName, NULL, NULL,
                lpDependencies, _T("LocalSystem"), NULL );
        if ( !hService )
        {
            err = GetLastError();
            break;
        }

    } while ( FALSE );

    if (hService){CloseServiceHandle(hService);}
    if (hScManager){CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetCreateService():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
    return(err);
}

INT InetConfigService( LPCTSTR lpServiceName, LPCTSTR lpDisplayName, LPCTSTR lpBinaryPathName, LPCTSTR lpDependencies)
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("InetConfigService():ServiceName=%s\n"), (LPTSTR) lpServiceName));

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
			iisDebugOut((LOG_TYPE_ERROR, _T("InetConfigService():OpenSCManager or OpenService: Service=%s BinPathName=%s Dependencies=%s Err=0x%x FAILED\n"), lpServiceName, lpBinaryPathName, lpDependencies, err));
            break;
        }

        if ( !::ChangeServiceConfig(hService, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE, lpBinaryPathName, NULL, NULL, lpDependencies, _T("LocalSystem"), NULL, lpDisplayName) )
        {
            err = GetLastError();
			iisDebugOut((LOG_TYPE_ERROR, _T("InetConfigService():ChangeServiceConfig: Service=%s BinPathName=%s Dependencies=%s Err=0x%x FAILED\n"), lpServiceName, lpBinaryPathName, lpDependencies, err));
            break;
        }

    } while ( FALSE );

    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetConfigService():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
    return(err);
}

INT InetConfigService2( LPCTSTR lpServiceName, LPCTSTR lpDescription)
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("InetConfigService2():ServiceName=%s\n"), (LPTSTR) lpServiceName));

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_DESCRIPTION ServiceDescription;

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
			iisDebugOut((LOG_TYPE_ERROR, _T("InetConfigService2():OpenSCManager or OpenService: Service=%s Err=0x%x FAILED\n"), lpServiceName, err));
            break;
        }

        if (lpDescription)
        {
            if (_tcscmp(lpDescription, _T("")) != 0)
            {
                ServiceDescription.lpDescription = (LPTSTR) lpDescription;
                if (!ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, (LPVOID)&ServiceDescription))
                {
                    err = GetLastError();
			        iisDebugOut((LOG_TYPE_ERROR, _T("InetConfigService2():ChangeServiceConfig2: Service=%s Err=0x%x FAILED\n"), lpServiceName, err));
                    break;
                }
            }
        }

    } while ( FALSE );

    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetConfigService2():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
    return(err);
}


# define SetServiceTypeValues( pSvcTypeValue, dwNS, dwType, dwSize, lpValName, lpVal)   \
       ( pSvcTypeValue)->dwNameSpace = ( dwNS);          \
       ( pSvcTypeValue)->dwValueType = ( dwType);        \
       ( pSvcTypeValue)->dwValueSize = ( dwSize);        \
       ( pSvcTypeValue)->lpValueName = ( lpValName);     \
       ( pSvcTypeValue)->lpValue     = (PVOID ) ( lpVal); \

# define SetServiceTypeValuesDword( pSvcTypeValue, dwNS, lpValName, lpVal) \
   SetServiceTypeValues( (pSvcTypeValue), (dwNS), REG_DWORD, sizeof( DWORD), \
                         ( lpValName), ( lpVal))

BOOL InetRegisterService( LPCTSTR pszMachine, LPCTSTR   pszServiceName, GUID *pGuid, DWORD SapId, DWORD TcpPort, BOOL fAdd )
{
    iisDebugOut_Start1(_T("InetRegisterService"),(LPTSTR) pszServiceName);
    int err;

    WSADATA  WsaData;

    SERVICE_INFO serviceInfo;
    LPSERVICE_TYPE_INFO_ABS lpServiceTypeInfo ;
    LPSERVICE_TYPE_VALUE_ABS lpServiceTypeValues ;
    BYTE serviceTypeInfoBuffer[sizeof(SERVICE_TYPE_INFO) + 1024];
    // Buffer large enough for 3 values ( SERVICE_TYPE_VALUE_ABS)

    DWORD Value1 = 1 ;
    DWORD SapValue = SapId;
    DWORD TcpPortValue = TcpPort;
    DWORD statusFlags;

    //
    // Initialize Windows Sockets DLL
    //

    err = WSAStartup( 0x0101, & WsaData);
    if ( err == SOCKET_ERROR) 
    {
        return ( FALSE);
    }


    //
    // Setup the service information to be passed to SetService() for adding
    //   or deleting this service. Most of the SERVICE_INFO fields are not
    //   required for add or delete operation. The main things of interests are
    //  GUIDs and ServiceSpecificInfo structure.
    //

    memset( (PVOID ) & serviceInfo, 0, sizeof( serviceInfo)); //null all fields

    serviceInfo.lpServiceType     =  pGuid;
    serviceInfo.lpMachineName     =  (LPTSTR)pszMachine;

    //
    // The "Blob" will contain the service specific information.
    // In this case, fill it with a SERVICE_TYPE_INFO_ABS structure
    //  and associated information.
    //
    serviceInfo.ServiceSpecificInfo.pBlobData = serviceTypeInfoBuffer;
    serviceInfo.ServiceSpecificInfo.cbSize    = sizeof( serviceTypeInfoBuffer);

    lpServiceTypeInfo = (LPSERVICE_TYPE_INFO_ABS ) serviceTypeInfoBuffer;

    //
    //  There are totally 3 values associated with this service if we're doing
    //  both SPX and TCP, there's only one value if TCP.
    //

    if ( SapId )
    {
        lpServiceTypeInfo->dwValueCount = 3;
    }
    else
    {
        lpServiceTypeInfo->dwValueCount = 1;
    }
    lpServiceTypeInfo->lpTypeName   = (LPTSTR)pszServiceName;

    lpServiceTypeValues = lpServiceTypeInfo->Values;

    if ( SapId )
    {
        //
        // 1st value: tells the SAP that this is a connection oriented service.
        //
        SetServiceTypeValuesDword( ( lpServiceTypeValues + 0),
                                  NS_SAP,                    // Name Space
                                  SERVICE_TYPE_VALUE_CONN,   // ValueName
                                  &Value1                    // actual value
                                  );

        //
        // 2nd Value: tells SAP about object type to be used for broadcasting
        //   the service name.
        //
        SetServiceTypeValuesDword( ( lpServiceTypeValues + 1),
                                  NS_SAP,
                                  SERVICE_TYPE_VALUE_SAPID,
                                  &SapValue);

        //
        // 3rd value: tells TCPIP name-space provider about TCP/IP port to be used.
        //
        SetServiceTypeValuesDword( ( lpServiceTypeValues + 2),
                                  NS_DNS,
                                  SERVICE_TYPE_VALUE_TCPPORT,
                                  &TcpPortValue);

    }
    else
    {
        SetServiceTypeValuesDword( ( lpServiceTypeValues + 0),
                                    NS_DNS,
                                    SERVICE_TYPE_VALUE_TCPPORT,
                                    &TcpPortValue);
    }
    //
    // Finally, call SetService to actually perform the operation.
    //
    err = SetService(
                     NS_DEFAULT,             // all default name spaces
                     ( fAdd ) ? SERVICE_ADD_TYPE : SERVICE_DELETE_TYPE,       // either ADD or DELETE
                     0,                      // dwFlags not used
                     &serviceInfo,           // the service info structure
                     NULL,                   // lpServiceAsyncInfo
                     &statusFlags            // additional status information
                     );

    // for some unknown reason, the SERVICE_DELETE_TYPE never remove the related registry
    // I have to manually clean it here.
    if (!fAdd) 
    {
        CRegKey regSvcTypes(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Control\\ServiceProvider\\ServiceTypes"));
        if ((HKEY)regSvcTypes) {regSvcTypes.DeleteTree(pszServiceName);}
    }

    iisDebugOut((LOG_TYPE_TRACE, _T("InetRegisterService():ServiceName=%s.End.Return=%d.\n"), pszServiceName, err));
    return ( err != NO_ERROR);
} // InetRegisterService()

#ifdef _CHICAGO_

BOOL
IsInetinfoRunning()
{
    HANDLE hEvent;
    BOOL fFound = FALSE;

    hEvent = CreateEvent(NULL, TRUE, FALSE, _T(PWS_SHUTDOWN_EVENT));

    if ( hEvent != NULL ) {
        fFound = (GetLastError() == ERROR_ALREADY_EXISTS);
        CloseHandle(hEvent);
    }
    return(fFound);
}

VOID
W95StartW3SVC()
{
	STARTUPINFO startupInfo;
	PROCESS_INFORMATION processInfo;
    CString csAppName;

    csAppName = g_pTheApp->m_csPathInetsrv + _T("\\inetinfo.exe");

    if ( !IsInetinfoRunning() ) {
    	ZeroMemory(&startupInfo, sizeof(STARTUPINFO));
	    startupInfo.cb = sizeof(STARTUPINFO);

        //W95ShutdownIISADMIN();

    	if ( !CreateProcess(
    			    csAppName,
    			    _T("inetinfo -e w3svc"),
    			    NULL,
    			    NULL,
    			    FALSE,
    			    0,
    			    NULL,
    			    g_pTheApp->m_csPathInetsrv,
    			    &startupInfo,
    			    &processInfo) )
    	{
            GetErrorMsg(GetLastError(), _T(": W3SVC on Win95"));
    		return;
  	    }
    }
    return;
}


BOOL
W95ShutdownW3SVC(VOID)
{
    HANDLE hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, _T(PWS_SHUTDOWN_EVENT));

    if ( hEvent == NULL ) 
	{
        return(TRUE);
    }

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) 
	{
        SetEvent( hEvent );
    }

    CloseHandle(hEvent);
    return(TRUE);
}

BOOL
W95ShutdownIISADMIN(
    VOID
    )
{
    DWORD i;
    HANDLE hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, _T(IIS_AS_EXE_OBJECT_NAME));

    if ( hEvent == NULL ) {
        return(TRUE);
    }

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {
        SetEvent( hEvent );
    }

    CloseHandle(hEvent);

    for (i=0; i < 20; i++) {

        hEvent = CreateEvent(NULL, TRUE, FALSE, _T(IIS_AS_EXE_OBJECT_NAME));
        if ( hEvent != NULL ) {
            DWORD err = GetLastError();
            CloseHandle(hEvent);

            if ( err == ERROR_ALREADY_EXISTS ) {
                Sleep(500);
                continue;
            }
        }

        break;
    }

    return(TRUE);
}

#endif //_CHICAGO_



INT CheckifServiceExistAndDependencies( LPCTSTR lpServiceName )
{
    INT err = 0;
    INT iReturn = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;

    BYTE ConfigBuffer[4096];
    LPENUM_SERVICE_STATUS ServiceConfigEnum = (LPENUM_SERVICE_STATUS) &ConfigBuffer;

    if ((	hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL || (hService = OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
        // Failed, or more likely the service doesn't exist
        iReturn = GetLastError();
        goto CheckifServiceExistAndDependencies_Exit;
        }

    // There was no error and the service exists.
    // Then let's make sure the actual file exists!!!
    // The above calls will only return true if the service has been registered, but 
    // the call doesn't actually check if the file exists!

	// Retrieve the service's config for the BinaryPathName
    // if it fails then hey, we don't have a correctly installed service
    // so return error!
    if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR)
    {
        iReturn = GetLastError();
	goto CheckifServiceExistAndDependencies_Exit;
    }
    if (!ServiceConfig)
    {
        iReturn = GetLastError();
	goto CheckifServiceExistAndDependencies_Exit;
    }

    if ( (ServiceConfig->dwServiceType & SERVICE_WIN32_OWN_PROCESS) || (ServiceConfig->dwServiceType & SERVICE_WIN32_SHARE_PROCESS))
    {
        if (ServiceConfig->lpBinaryPathName)
        {
            if (IsFileExist(ServiceConfig->lpBinaryPathName)) 
            {
                // the service exists and the file exists too!
                iReturn = 0;
            }
            else
            {
                iReturn = ERROR_FILE_NOT_FOUND;
                goto CheckifServiceExistAndDependencies_Exit;
            }
        }
    }
    else
    {
        iReturn = 0;
    }


    // Get our list of services which we depend upon.
    // let's make sure they are registered and exist.

	// ServiceConfig->lpDependencies should look something like this
	// service\0service\0\0  double null terminated
    {
	TCHAR * pdest = NULL;
	long RightMostNull = 0;

	pdest = ServiceConfig->lpDependencies;
	do 
	{
		if (*pdest != _T('\0'))
		{
			RightMostNull = RightMostNull + _tcslen(pdest) + 1;

            // Check if the service exists
            if (0 != CheckifServiceExistAndDependencies(pdest)){iReturn = err;}

			pdest = _tcschr(pdest, _T('\0'));
			pdest++;
		}
		else
		{
			break;
		}
	} while (TRUE);
    }

CheckifServiceExistAndDependencies_Exit:
    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}
	return (iReturn);
}



INT CheckifServiceExist( LPCTSTR lpServiceName )
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

	if ((	hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL 
		|| (hService = OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {err = GetLastError();}

    if (hService) CloseServiceHandle(hService);
    if (hScManager) CloseServiceHandle(hScManager);
	return (err);
}

/*----------------------------------------------------------------------------------------
Routine Description:
    This routine allocates a buffer for the specified service's configuration parameters,
    and retrieves those parameters into the buffer.  The caller is responsible for freeing
    the buffer.
Remarks:
    The pointer whose address is contained in ServiceConfig is guaranteed to be NULL upon
    return if any error occurred.
-----------------------------------------------------------------------------------------*/
DWORD RetrieveServiceConfig(IN SC_HANDLE ServiceHandle,OUT LPQUERY_SERVICE_CONFIG *ServiceConfig)
{
    DWORD ServiceConfigSize = 0, Err;
    if (NULL == ServiceConfig)
    {
        return ERROR_INVALID_PARAMETER; 
    }
    *ServiceConfig = NULL;
    while(TRUE) {
        if(QueryServiceConfig(ServiceHandle, *ServiceConfig, ServiceConfigSize, &ServiceConfigSize)) 
			{
            //assert(*ServiceConfig);
            return NO_ERROR;
			}
		else 
			{
            Err = GetLastError();
            if(*ServiceConfig) {free(*ServiceConfig);*ServiceConfig=NULL;}
            if(Err == ERROR_INSUFFICIENT_BUFFER) 
				{
                // Allocate a larger buffer, and try again.
                if(!(*ServiceConfig = (LPQUERY_SERVICE_CONFIG) malloc(ServiceConfigSize)))
                    {
                    return ERROR_NOT_ENOUGH_MEMORY;
                    }
				} 
			else 
				{
                *ServiceConfig = NULL;
                return Err;
				}
			}
    }
}


INT CreateDependencyForService( LPCTSTR lpServiceName, LPCTSTR lpDependency )
{
    iisDebugOut_Start1(_T("CreateDependencyForService"),(LPTSTR) lpServiceName);

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

	LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;
	TCHAR szTempDependencies[1024];
	TCHAR * pszTempDependencies = NULL;
	pszTempDependencies = szTempDependencies;

    do {
        // set up the service first
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

		// Get the existing Service information
		if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR) 
			{
			err = GetLastError();
			break;
			}
		if(!ServiceConfig)
			{
			err = GetLastError();
			break;
			}
		// Check if our service is already in there.
		// ServiceConfig->lpDependencies should look something like this
		// service\0service\0\0  double null terminated
		TCHAR * pdest = NULL;
		int bFoundFlag = FALSE;
		long RightMostNull = 0;

		pdest = ServiceConfig->lpDependencies;
		do 
		{
			if (*pdest != _T('\0'))
			{
				RightMostNull = RightMostNull + _tcslen(pdest) + 1;
				if (_tcsicmp(pdest, lpDependency) == 0) 
					{
					bFoundFlag = TRUE;
					break;
					}

				// copy the entry onto our string which we'll use later.
				_tcscpy(pszTempDependencies,pdest);
				// position pointer to the end
				pszTempDependencies=pszTempDependencies + RightMostNull;

				pdest = _tcschr(pdest, _T('\0'));
				pdest++;
			}
			else
			{
				break;
			}
		} while (TRUE);

		// if the service is already on the dependency list then exit
		if (bFoundFlag == TRUE) 
		{
			break;
		}
				
		// The Service is not there So Let's add it to the end of the list then change the data
		// The pointer should be at the beginning or at the next entry point
		_tcscpy(pszTempDependencies, lpDependency);
		// position pointer to the end
		pszTempDependencies=pszTempDependencies + (_tcslen(pszTempDependencies) + 1);
		// add another null to the end
		*pszTempDependencies = _T('\0');

	
        if(!::ChangeServiceConfig(hService,SERVICE_NO_CHANGE,SERVICE_NO_CHANGE,SERVICE_NO_CHANGE,NULL,NULL,NULL,szTempDependencies,NULL,NULL,NULL)) 
			{
			err = GetLastError();
			break;
			}

	} while ( FALSE );

    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("CreateDependencyForService():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
	return err;
}


INT RemoveDependencyForService( LPCTSTR lpServiceName, LPCTSTR lpDependency )
{
    iisDebugOut_Start1(_T("RemoveDependencyForService"),(LPTSTR) lpServiceName);

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

	LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;
	TCHAR szTempDependencies[1024];
	TCHAR * pszTempDependencies = NULL;
	pszTempDependencies = szTempDependencies;

    do {
            // set up the service first
            if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
                (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
            {
                err = GetLastError();
                break;
            }

            // Get the existing Service information
            if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR) 
                {
                err = GetLastError();
                break;
                }
            if(!ServiceConfig) 
                {
                err = GetLastError();
                break;
                }

		// Check if our service is already in there.
		// ServiceConfig->lpDependencies should look something like this
		// service\0service\0\0  double null terminated

		TCHAR * pdest = NULL;
		int bFoundFlag = FALSE;
		long RightMostNull = 0;
		_tcsset(szTempDependencies, _T('\0'));
		pdest = ServiceConfig->lpDependencies;
		do 
		{
			if (*pdest != _T('\0'))
			{
				RightMostNull = RightMostNull + _tcslen(pdest) + 1;
				if (_tcsicmp(pdest, lpDependency) == 0) 
					{
					bFoundFlag = TRUE;
					}
				else
				{
				// copy the entry onto our string which we'll use later.
				_tcscpy(pszTempDependencies,pdest);
				// position pointer to the end
				pszTempDependencies=pszTempDependencies + RightMostNull;
				*pszTempDependencies = _T('\0');

				/*
					if (_tcslen(szTempDependencies) == 0)
						memcpy(szTempDependencies, pdest, _tcslen(pdest) + 1);
					else
						memcpy(szTempDependencies + _tcslen(szTempDependencies) + 1, pdest, _tcslen(pdest) + 1);
					*/
				}
				pdest = _tcschr(pdest, _T('\0'));
				pdest++;
			}
			else
			{
				break;
			}
		} while (TRUE);
		// if the service was in the list.
		// Then let's remove it.
		if (bFoundFlag == FALSE) 
		{
			break;
		}

		if(!::ChangeServiceConfig(hService,SERVICE_NO_CHANGE,SERVICE_NO_CHANGE,SERVICE_NO_CHANGE,NULL,NULL,NULL,szTempDependencies,NULL,NULL,NULL)) 
			{
			err = GetLastError();
			break;
			}

	} while ( FALSE );

    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}
    iisDebugOut((LOG_TYPE_TRACE, _T("RemoveDependencyForService():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
	return err;
}


INT DisplayDependencyForService( LPCTSTR lpServiceName)
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

	LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;

    do {
        // set up the service first
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            break;
        }

		// Get the existing Service information
		if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR) 
			{
			err = GetLastError();
			break;
			}
		if(!ServiceConfig) 
			{
			err = GetLastError();
			break;
			}
		// Check if our service is already in there.
		// ServiceConfig->lpDependencies should look something like this
		// service\0service\0\0  double null terminated
		TCHAR * pdest = NULL;
		int bFoundFlag = FALSE;
		long RightMostNull = 0;
		pdest = ServiceConfig->lpDependencies;
		do 
		{
			if (*pdest != _T('\0'))
			{
				pdest = _tcschr(pdest, _T('\0'));
				pdest++;
			}
			else
			{
				break;
			}
		} while (TRUE);
		

	} while ( FALSE );

    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}
	return err;
}


//
//Routine Description:
//    Stop the named service and all those services which depend upon it.
//    And if the service is hung and can't be stopped, then kill the darn thing.
//
//Arguments:
//    ServiceName (Name of service to stop)
//
//Return Status:
//    TRUE - Indicates service successfully stopped
//    FALSE - Timeout occurred.
//
int StopServiceAndDependencies(LPCTSTR ServiceName, int AddToRestartList)
{
    iisDebugOut_Start1(_T("StopServiceAndDependencies"),(LPTSTR) ServiceName);

    int Err = 0;
    int iBeforeServiceStatus = 0;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    DWORD Timeout;
	int iReturn = FALSE;
    DWORD TimeoutMaxSecs = 60;
    DWORD dwSvcMaxSleep = 0;

    //
    // Open a handle to the Service.
    //
    ScManagerHandle = OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT );
    if (ScManagerHandle == NULL) 
	{
        Err = GetLastError();
		iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies():OpenSCManager: Err on Service %s Err=0x%x FAILED\n"), ServiceName, Err));
        goto Cleanup;
    }

    ServiceHandle = OpenService(ScManagerHandle,ServiceName,SERVICE_QUERY_STATUS | SERVICE_INTERROGATE | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_STOP | SERVICE_QUERY_CONFIG );
    if ( ServiceHandle == NULL ) 
	{
        Err = GetLastError();
        if (Err == ERROR_SERVICE_DOES_NOT_EXIST)
        {
             iReturn = TRUE;
             iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("StopServiceAndDependencies():%s Service does not exist.\n"), ServiceName));
        }
        else
        {
	     iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies():OpenService: Err on Service %s Err=0x%x FAILED\n"), ServiceName, Err));
        }
        goto Cleanup;
    }

    // Get the before service status.
    if (QueryServiceStatus(ServiceHandle, &ServiceStatus)) 
    {
        iBeforeServiceStatus = ServiceStatus.dwCurrentState;
    }

    //
    // Ask the service to stop.
    //
    if ( !ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus) ) 
	{
        Err = GetLastError();
        // If there are dependent services running,
        //  determine their names and stop them.
        if ( Err == ERROR_DEPENDENT_SERVICES_RUNNING ) 
		{
            BYTE ConfigBuffer[4096];
            LPENUM_SERVICE_STATUS ServiceConfig = (LPENUM_SERVICE_STATUS) &ConfigBuffer;
            DWORD BytesNeeded;
            DWORD ServiceCount;
            DWORD ServiceIndex;

            //
            // Get the names of the dependent services.
            //
            if ( !EnumDependentServices( ServiceHandle,SERVICE_ACTIVE,ServiceConfig,sizeof(ConfigBuffer),&BytesNeeded,&ServiceCount ) ) 
			{
                Err = GetLastError();
				iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies():EnumDependentServices: Err on Service %s Err=0x%x FAILED\n"), ServiceName, Err));
                goto Cleanup;
            }

            //
            // Stop those services.
            //
            for ( ServiceIndex=0; ServiceIndex<ServiceCount; ServiceIndex++ ) 
			{
                StopServiceAndDependencies( ServiceConfig[ServiceIndex].lpServiceName, AddToRestartList);
            }

            //
            // Ask the original service to stop.
            //
            if ( !ControlService( ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus) ) 
			{
                Err = GetLastError();

				// check if the service is already stopped..
				if ( Err == ERROR_SERVICE_CANNOT_ACCEPT_CTRL || Err == ERROR_SERVICE_NOT_ACTIVE) 
				{
					// check if the service is alread stopped.
					if (QueryServiceStatus( ServiceHandle, &ServiceStatus )) 
					{
						if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED || ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) 
							{
                            iReturn = TRUE;
                            goto Cleanup;
                            }
					}
				}
				else
				{
                    // The service must be in a hung mode.  Let's kill it.
                    iisDebugOut((LOG_TYPE_WARN, _T("StopServiceAndDependencies():'%s' Service must be in a hung mode.  Let's kill it.\n"), ServiceName));
                    KillService(ServiceHandle);
                    goto WaitLoop;
				}
			
                goto Cleanup;
            }
        }
		else 
		{
			// check if the service is already stopped..
			if ( Err == ERROR_SERVICE_CANNOT_ACCEPT_CTRL || Err == ERROR_SERVICE_NOT_ACTIVE) 
			{
				// check if the service is alread stopped.
				if (QueryServiceStatus( ServiceHandle, &ServiceStatus )) 
				{
					if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED || ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) 
						{
                        Err = ServiceStatus.dwCurrentState;
                        iReturn = TRUE;
                        goto Cleanup;
                        }
				}
			}
			else
			{
					// The service must be in a hung mode.  Let's kill it.
					iisDebugOut((LOG_TYPE_WARN, _T("StopServiceAndDependencies():'%s' Service must be in a hung mode.  Let's kill it.\n"), ServiceName));
					KillService(ServiceHandle);
					goto WaitLoop;
			}
		
            goto Cleanup;
        }
    }
    else
    {
        // We successfully asked the service to stop...
    }


WaitLoop:
    // Calculcate if this is a "special" service which we 
    // need to give more time to in order to stop.
    dwSvcMaxSleep = InetStopExtraWait(ServiceName);
    // dwSvcMaxSleep returns 3 minute intervals.  so default dwSvcMaxSleep will be 180000 (3 minutes)
    // we need to convert this into how many seconds
    TimeoutMaxSecs = (dwSvcMaxSleep/1000);

    // Loop waiting for the service to stop.
    for ( Timeout=0; Timeout < TimeoutMaxSecs; Timeout++ ) 
    {
        // Return or continue waiting depending on the state of the service.
        if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED ) 
		{
			// The service successfully stopped.
            iisDebugOut((LOG_TYPE_TRACE, _T("StopServiceAndDependencies(): %s Service stopped.\n"), ServiceName));
			iReturn = TRUE;
            goto Cleanup;
        }

        // Wait a second for the service to finish stopping.
        Sleep( 1000 );

        // Query the status of the service again.
        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus ))
		{
            Err = GetLastError();
			iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies():QueryServiceStatus: Err on Service %s Err=0x%x FAILED\n"), ServiceName, Err));
            goto Cleanup;
        }

        // if the service we are trying to stop is a driver,
        // then heck we should just get out of here..
        if (TRUE == IsThisServiceADriver(ServiceName))
        {
            iisDebugOut((LOG_TYPE_WARN, _T("StopServiceAndDependencies(): %s service is a driver, and can only be removed upon reboot.\n"), ServiceName));
            goto Cleanup;
        }
    }

    // if we get here then the service failed to stop.
    iisDebugOut((LOG_TYPE_ERROR, _T("StopServiceAndDependencies(): failed to stop %s service.\n"), ServiceName));

Cleanup:
    if ( ScManagerHandle != NULL )  {(VOID) CloseServiceHandle(ScManagerHandle);}
	if ( ServiceHandle != NULL ) {(VOID) CloseServiceHandle(ServiceHandle);}

    // if we successfully stopped this service, then
    // add it to the restart service list
    if (iReturn == TRUE)
    {
        iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("StopServiceAndDependencies(): %s service. success.\n"), ServiceName));
        if (iBeforeServiceStatus == SERVICE_RUNNING)
        {
            if (AddToRestartList) {ServicesRestartList_Add(ServiceName);}
        }
    }
    return iReturn;
}


// ----------------------------------------------
// The service must be in a hung mode.  Let's kill it.
// Get the binary path name and use that to kill it.
// Return true on successfull kill.  false otherwise.
// ----------------------------------------------
int KillService(SC_HANDLE ServiceHandle)
{
	int iReturn = FALSE;
	LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;
    int iFlagPutItBack = FALSE;

	// Retrieve the service's config for the BinaryPathName
	// if failed then just return
	if(RetrieveServiceConfig(ServiceHandle, &ServiceConfig) != NO_ERROR)  
		{
		goto KillService_Exit;
		}
	if(!ServiceConfig)
		{
		goto KillService_Exit;
		}

	// The Service can be one of these types:
	//		SERVICE_WIN32_OWN_PROCESS: A service type flag that indicates a Win32 service that runs in its own process.
	//		SERVICE_WIN32_SHARE_PROCESS: A service type flag that indicates a Win32 service that shares a process with other services.
	//		SERVICE_KERNEL_DRIVER: A service type flag that indicates a Windows NT device driver.
	//		SERVICE_FILE_SYSTEM_DRIVER: A service type flag that indicates a Windows NT file system driver.
	//		SERVICE_INTERACTIVE_PROCESS: A flag that indicates a Win32 service process that can interact with the desktop.

	// Attempt to kill only if it's a process.
	if ( (ServiceConfig->dwServiceType & SERVICE_WIN32_OWN_PROCESS) || (ServiceConfig->dwServiceType & SERVICE_WIN32_SHARE_PROCESS))
	{
		// parse out the different parts and take only the filename.ext
		TCHAR pfilename_only[_MAX_FNAME];
		TCHAR pextention_only[_MAX_EXT];
		_tsplitpath( ServiceConfig->lpBinaryPathName, NULL, NULL, pfilename_only, pextention_only);
		if (pextention_only) {_tcscat(pfilename_only,pextention_only);}

		// Convert it to ansi for our "kill" function
		char szFile[_MAX_FNAME];
		#if defined(UNICODE) || defined(_UNICODE)
			WideCharToMultiByte( CP_ACP, 0, (WCHAR*)pfilename_only, -1, szFile, _MAX_FNAME, NULL, NULL );
		#else
			_tcscpy(szFile, pfilename_only);
		#endif

        // Some of these services have some action to do if the service is killed.
        // like IISADMIN has some restart function which will automagically restart the
        // Service if the process is not properly shutdown.
        // We need to disable this deal because We can't have this service just startup by itself again.
        iFlagPutItBack = FALSE;
        if (_tcsicmp(ServiceConfig->lpServiceStartName,_T("IISADMIN")) == 0)
        {
            // Go lookup the registry for "FailureCommands" and save that information.
            // retrieve from registry
            CString csFailureCommand;
            CRegKey regIISADMINParam(HKEY_LOCAL_MACHINE, REG_IISADMIN);
            if ( (HKEY)regIISADMINParam ) 
            {
                regIISADMINParam.m_iDisplayWarnings = FALSE;
                if (ERROR_SUCCESS == regIISADMINParam.QueryValue(_T("FailureCommands"), csFailureCommand))
                {
                    // Kool, we got it.
                    // Set it to do nothing.
                    regIISADMINParam.SetValue(_T("FailureCommands"), _T(""));
                    iFlagPutItBack = TRUE;
                }
            }

            // kill the service's process
            if (KillProcessNameReturn0(szFile) == 0) {iReturn = TRUE;}

            if (TRUE == iFlagPutItBack)
            {
                CRegKey regIISADMINParam(HKEY_LOCAL_MACHINE, REG_IISADMIN);
                if ( (HKEY)regIISADMINParam ) 
                {
                    regIISADMINParam.SetValue(_T("FailureCommands"), csFailureCommand);
                }
            }

        }
        else
        {
		    if (KillProcessNameReturn0(szFile) == 0) {iReturn = TRUE;}
        }
	}

KillService_Exit:
    if (ServiceConfig) {free(ServiceConfig);}
	return iReturn;
}



INT CheckifServiceMarkedForDeletion( LPCTSTR lpServiceName )
{
    INT iReturn = FALSE;
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    // set up the service first
    if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
        (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
    {
        err = GetLastError();
        goto CheckifServiceMarkedForDeletion_Exit;
    }

    SERVICE_STATUS svcStatus;
    if ( !QueryServiceStatus( hService, &svcStatus ))
    {
        err = ::GetLastError();
        goto CheckifServiceMarkedForDeletion_Exit;
    }

    if ( svcStatus.dwCurrentState == SERVICE_RUNNING )
    {
        // We will only get this ERROR_SERVICE_MARKED_FOR_DELETE
        // message if the service is already running.
        if ( !::StartService( hService, 0, NULL ))
        {
            err = ::GetLastError();
            if (err == ERROR_SERVICE_MARKED_FOR_DELETE) {iReturn = TRUE;}
            goto CheckifServiceMarkedForDeletion_Exit;
        }
    }

CheckifServiceMarkedForDeletion_Exit:
    if (hService) CloseServiceHandle(hService);
    if (hScManager) CloseServiceHandle(hScManager);
    return iReturn;
}


//
// warning: This will leave the lpServiceToValidate in the started mode upon exit!
//
int ValidateDependentService(LPCTSTR lpServiceToValidate, LPCTSTR lpServiceWhichIsDependent)
{
    iisDebugOut_Start1(_T("ValidateDependentService"),(LPTSTR) lpServiceToValidate);

    int iReturn = FALSE;
    INT err = 0;
    int iFailFlag = FALSE;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;

    LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;

    // Let's validate that the lpServiceToValidate is installed fine.

    // Check if the lpServiceToValidate service EVEN exists
    err = CheckifServiceExistAndDependencies(lpServiceToValidate);
    if ( err != 0 ) 
    {
        MyMessageBox(NULL, IDS_DEPENDENT_UPON_THIS_SVC_ERR, lpServiceWhichIsDependent,lpServiceWhichIsDependent,err, MB_OK | MB_SETFOREGROUND);
    }
    else
    {
        // Try to start the service
        err = InetStartService(lpServiceToValidate);
        if (err == 0 || err == ERROR_SERVICE_ALREADY_RUNNING)
        {
            err = NERR_Success;
            iReturn = TRUE;
            goto ValidateDependentService_Exit;
        }

        // Service returned an error when we tried to start it.
        // Check if the error = ERROR_SERVICE_DEPENDENCY_FAIL
        if (err == ERROR_SERVICE_DEPENDENCY_FAIL)
        {
            // Loop thru this services dependencies and try to 
            // start them, to find out which one failed to start.
            iFailFlag = FALSE;
            if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL || (hService = ::OpenService( hScManager, lpServiceToValidate, GENERIC_ALL )) == NULL )  {iFailFlag = TRUE;}
            // Get the existing Service information
            if (iFailFlag != TRUE) {if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR) {iFailFlag = TRUE;}}
            if (iFailFlag != TRUE) {if(!ServiceConfig){iFailFlag = TRUE;}}
            // Get the dependencies
            if (iFailFlag != TRUE)
            {
	            TCHAR * pdest = NULL;
	            long RightMostNull = 0;
	            pdest = ServiceConfig->lpDependencies;
	            do 
	            {
		            if (*pdest != _T('\0'))
		            {
                        RightMostNull = RightMostNull + _tcslen(pdest) + 1;

                        // Try to start the service...
                        err = InetStartService(pdest);
                        if (err)
                        {
                        if (err != ERROR_SERVICE_ALREADY_RUNNING)
                        {
                            // The pdest
                            // Service was unable to start because...
                            // MyMessageBox(NULL, IDS_UNABLE_TO_START, pdest, err, MB_OK | MB_SETFOREGROUND);
                            iisDebugOut((LOG_TYPE_ERROR, _T("ValidateDependentService():Unable to start ServiceName=%s.\n"), pdest));
                        }
                        }
			            pdest = _tcschr(pdest, _T('\0'));
			            pdest++;
		            }
		            else
		            {
			            break;
		            }
                } while (TRUE);
            }
        }
        else
        {
            MyMessageBox(NULL, IDS_UNABLE_TO_START, lpServiceToValidate, err, MB_OK | MB_SETFOREGROUND);
        }
           
    }

ValidateDependentService_Exit:
    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}
    iisDebugOut_End1(_T("ValidateDependentService"), lpServiceToValidate, LOG_TYPE_TRACE);
    return iReturn;
}



int LogEnumServicesStatus(void)
{
    int iReturn = FALSE;
#ifndef _CHICAGO_
    BOOL success = 0;
	SC_HANDLE scm = NULL;
	LPENUM_SERVICE_STATUS status = NULL;
	DWORD numServices=0, sizeNeeded=0, resume=0;

	// Open a connection to the SCM
    //scm = OpenSCManager(0, 0, GENERIC_ALL);
	scm = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
	if (!scm)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CallEnumServicesStatus():OpenSCManager.  FAILED.  err=0x%x\n"), GetLastError()));
        goto CallEnumServicesStatus_Exit;
    }

	// get the number of bytes to allocate
	// MAKE SURE resume starts at 0
	resume = 0;
	success = EnumServicesStatus(scm, SERVICE_WIN32 | SERVICE_DRIVER, SERVICE_ACTIVE | SERVICE_INACTIVE, 0, 0, &sizeNeeded, &numServices, &resume);
	if (GetLastError() != ERROR_MORE_DATA)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CallEnumServicesStatus():EnumServicesStatus0.  FAILED.  err=0x%x\n"), GetLastError()));
        goto CallEnumServicesStatus_Exit;
    }

	// Allocate space
	status = (LPENUM_SERVICE_STATUS) LocalAlloc(LPTR, sizeNeeded);
    if( status == NULL )
    {
        goto CallEnumServicesStatus_Exit;
    }
    
	// Get the status records. Making an assumption
	// here that no new services get added during
	// the allocation (could lock the database to
	// guarantee that...)
	resume = 0;
	success = EnumServicesStatus(scm, SERVICE_WIN32,SERVICE_ACTIVE | SERVICE_INACTIVE,status, sizeNeeded, &sizeNeeded,&numServices, &resume);
	if (!success)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("CallEnumServicesStatus():EnumServicesStatus.  FAILED.  err=0x%x\n"), GetLastError()));
        goto CallEnumServicesStatus_Exit;
    }

	DWORD i;
	for (i=0; i < numServices; i++)
    {
        switch(status[i].ServiceStatus.dwCurrentState)
        {
            case SERVICE_STOPPED:
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_STOPPED [%s].\n"), status[i].lpServiceName));
                break;
            case SERVICE_START_PENDING:
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_START_PENDING [%s].\n"), status[i].lpServiceName));
                break;
            case SERVICE_STOP_PENDING:
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_STOP_PENDING [%s].\n"), status[i].lpServiceName));
                break;
            case SERVICE_RUNNING:
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_RUNNING [%s].\n"), status[i].lpServiceName));
                break;
            case SERVICE_CONTINUE_PENDING:
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_CONTINUE_PENDING [%s].\n"), status[i].lpServiceName));
                break;
            case SERVICE_PAUSE_PENDING:
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_PAUSE_PENDING [%s].\n"), status[i].lpServiceName));
                break;
            case SERVICE_PAUSED:
                iisDebugOut((LOG_TYPE_PROGRAM_FLOW, _T("SERVICE_PAUSED [%s].\n"), status[i].lpServiceName));
                break;
        }
    }
    iReturn = TRUE;

CallEnumServicesStatus_Exit:
    if (status){LocalFree(status);}
    if (scm) {CloseServiceHandle(scm);}
#endif
    return iReturn;
}


int InetIsThisExeAService(LPCTSTR lpFileNameToCheck, LPTSTR lpReturnServiceName)
{
    int iReturn = FALSE;
#ifndef _CHICAGO_
    BOOL success = 0;
	SC_HANDLE scm = NULL;
	LPENUM_SERVICE_STATUS status = NULL;
	DWORD numServices=0, sizeNeeded=0, resume=0;

    _tcscpy(lpReturnServiceName, _T(""));

	// Open a connection to the SCM
    //scm = OpenSCManager(0, 0, GENERIC_ALL);
	scm = OpenSCManager(0, 0, SC_MANAGER_ALL_ACCESS);
	if (!scm)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("InetIsThisExeAService():OpenSCManager.  FAILED.  err=0x%x\n"), GetLastError()));
        goto InetIsThisExeAService_Exit;
    }

	// get the number of bytes to allocate
	// MAKE SURE resume starts at 0
	resume = 0;
	success = EnumServicesStatus(scm, SERVICE_WIN32 | SERVICE_DRIVER, SERVICE_ACTIVE | SERVICE_INACTIVE, 0, 0, &sizeNeeded, &numServices, &resume);
	if (GetLastError() != ERROR_MORE_DATA)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("InetIsThisExeAService():EnumServicesStatus0.  FAILED.  err=0x%x\n"), GetLastError()));
        goto InetIsThisExeAService_Exit;
    }

	// Allocate space
	status = (LPENUM_SERVICE_STATUS) LocalAlloc(LPTR, sizeNeeded);
    if( status == NULL )
    {
        goto InetIsThisExeAService_Exit;
    }
    
	// Get the status records. Making an assumption
	// here that no new services get added during
	// the allocation (could lock the database to
	// guarantee that...)
	resume = 0;
	success = EnumServicesStatus(scm, SERVICE_WIN32,SERVICE_ACTIVE | SERVICE_INACTIVE,status, sizeNeeded, &sizeNeeded,&numServices, &resume);
	if (!success)
    {
        iisDebugOut((LOG_TYPE_ERROR, _T("InetIsThisExeAService():EnumServicesStatus.  FAILED.  err=0x%x\n"), GetLastError()));
        goto InetIsThisExeAService_Exit;
    }

	DWORD i;
	for (i=0; i < numServices; i++)
    {
        // Use the status[i].lpServiceName
        // to query the service and find out it's binary filename
        if (TRUE == InetIsThisExeAService_Worker(status[i].lpServiceName, lpFileNameToCheck))
        {
            iReturn = TRUE;
            // copy in the service name into the return string.
            _tcscpy(lpReturnServiceName, status[i].lpServiceName);
            goto InetIsThisExeAService_Exit;
        }
    }

InetIsThisExeAService_Exit:
    if (status){LocalFree(status);}
    if (scm) {CloseServiceHandle(scm);}
#endif
    return iReturn;
}


int InetIsThisExeAService_Worker(LPCTSTR lpServiceName, LPCTSTR lpFileNameToCheck)
{
    int iReturn = FALSE;

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;

    BYTE ConfigBuffer[4096];
    LPENUM_SERVICE_STATUS ServiceConfigEnum = (LPENUM_SERVICE_STATUS) &ConfigBuffer;

    if ((	hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL || (hService = OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
        // Failed, or more likely the service doesn't exist
        //iReturn = GetLastError();
        goto InetIsThisExeAService_Worker_Exit;
        }

	if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR)
		{
                //iReturn = GetLastError();
		goto InetIsThisExeAService_Worker_Exit;
		}

	if(!ServiceConfig)
		{
		goto InetIsThisExeAService_Worker_Exit;
		}

    if ( (ServiceConfig->dwServiceType & SERVICE_WIN32_OWN_PROCESS) || (ServiceConfig->dwServiceType & SERVICE_WIN32_SHARE_PROCESS))
    {
        if (ServiceConfig->lpBinaryPathName)
        {
            if (_tcsicmp(lpFileNameToCheck, ServiceConfig->lpBinaryPathName) == 0)
            {
                //We found a match!!!!!
                iReturn = TRUE;
            }
            else
            {
                // we did not find a match, based on c:\path\filename and c:\path\filename
                // maybe we try "filename.exe" and "filename.exe"????
                TCHAR szBinaryNameOnly[_MAX_FNAME];
                TCHAR szFileNameToCheckNameOnly[_MAX_FNAME];
                if (TRUE == ReturnFileNameOnly((LPCTSTR) ServiceConfig->lpBinaryPathName, szBinaryNameOnly))
                {
                    if (TRUE == ReturnFileNameOnly((LPCTSTR) lpFileNameToCheck, szFileNameToCheckNameOnly))
                    {
                        if (_tcsicmp(szFileNameToCheckNameOnly, szBinaryNameOnly) == 0)
                        {
                            //We found a match!!!!!
                            iReturn = TRUE;
                        }
                    }
                }
                
            }
        }
    }

InetIsThisExeAService_Worker_Exit:
    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}
    return iReturn;
}


int IsThisServiceADriver(LPCTSTR lpServiceName)
{
    int iReturn = FALSE;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    LPQUERY_SERVICE_CONFIG ServiceConfig=NULL;

    BYTE ConfigBuffer[4096];
    LPENUM_SERVICE_STATUS ServiceConfigEnum = (LPENUM_SERVICE_STATUS) &ConfigBuffer;
    if ((hScManager = OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL || (hService = OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
    {
        // Failed, or more likely the service doesn't exist
        //iReturn = GetLastError();
        goto IsThisServiceADriver_Exit;
    }

    if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR)
    {
        //iReturn = GetLastError();
        goto IsThisServiceADriver_Exit;
    }

    if(!ServiceConfig)
    {
        //iReturn = GetLastError();
        goto IsThisServiceADriver_Exit;
    }

    if ( (ServiceConfig->dwServiceType & SERVICE_KERNEL_DRIVER) || (ServiceConfig->dwServiceType & SERVICE_FILE_SYSTEM_DRIVER))
    {
        iReturn = TRUE;
    }

IsThisServiceADriver_Exit:
    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}
    return iReturn;
}


int CreateDriver(CString csDriverName, CString csDisplayName, CString csFileName)
{
    DWORD dwReturn = ERROR_SUCCESS;
    CString csBinPath;
    CString csFile;
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("CreateDriver:%s:%s start.\n"), csDriverName, csFileName));

    csBinPath = _T("\\SystemRoot\\System32\\drivers\\");
    csBinPath += csFileName;
    
    // Check if the file even exists first.
    csFile = g_pTheApp->m_csSysDir;
    csFile += _T("\\Drivers\\");
    csFile += csFileName;
    if (!IsFileExist(csFile)) 
    {
        dwReturn = ERROR_FILE_NOT_FOUND;
        goto CreateDriver_Exit;
    }

    //
    // Attempt to create the service, could fail if this is an
    // Refresh Install will leave the driver from the prior
    // Install, becuse if we delete in the remove phase it will
    // get marked for deletion and not get readded now.
    // this could happen in a upgrade as well....
    //
    dwReturn = InetCreateDriver(csDriverName, (LPCTSTR)csDisplayName, (LPCTSTR)csBinPath, SERVICE_DEMAND_START);
    if ( dwReturn != ERROR_SUCCESS )
    {
        if (dwReturn == ERROR_SERVICE_EXISTS)
        {
            iisDebugOut((LOG_TYPE_TRACE, _T("CreateDriver:%s:Service exists.\n"), csDriverName));
            dwReturn = ERROR_SUCCESS;
        }
        else
        {
            iisDebugOut((LOG_TYPE_ERROR, _T("CreateDriver:%s:failed to create service Err=0x%x.\n"), csDriverName, dwReturn));
            MyMessageBox(NULL, IDS_UNABLE_TO_CREATE_DRIVER, csDriverName, dwReturn, MB_OK | MB_SETFOREGROUND);
        }
    }
    else
    {
        iisDebugOut((LOG_TYPE_TRACE, _T("CreateDriver:%s:Successfully created.\n"), csDriverName));
    }

CreateDriver_Exit:
    return dwReturn;
}


DWORD CreateDriver_Wrap(CString csDriverName, CString csDisplayName, CString csFileName,BOOL bDisplayMsgOnErrFlag)
{
	int bFinishedFlag = FALSE;
	UINT iMsg = NULL;
	DWORD dwReturn = ERROR_SUCCESS;

    // Create or Config driver spud.sys, NT Server product onloy!!!
    if (g_pTheApp->m_eOS != OS_W95) 
    {
	    do
	    {
		    dwReturn = CreateDriver(csDriverName, csDisplayName, csFileName);
		    if (dwReturn == ERROR_SUCCESS)
		    {
			    break;
		    }
		    else
		    {
			    if (bDisplayMsgOnErrFlag == TRUE)
			    {
                    iMsg = MyMessageBox( NULL, IDS_RETRY, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
				    switch ( iMsg )
				    {
				    case IDIGNORE:
					    dwReturn = ERROR_SUCCESS;
					    goto CreateDriver_Wrap_Exit;
				    case IDABORT:
					    dwReturn = ERROR_OPERATION_ABORTED;
					    goto CreateDriver_Wrap_Exit;
				    case IDRETRY:
					    break;
				    default:
					    break;
				    }
			    }
			    else
			    {
				    // return whatever err happened
				    goto CreateDriver_Wrap_Exit;
			    }

		    }
	    } while (dwReturn != ERROR_SUCCESS);
    }

CreateDriver_Wrap_Exit:
	return dwReturn;
}


INT InetConfigServiceInteractive(LPCTSTR lpServiceName, int AddInteractive)
{
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("InetConfigServiceInteractive(%i):ServiceName=%s\n"),AddInteractive,(LPTSTR) lpServiceName));

    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    LPQUERY_SERVICE_CONFIG ServiceConfig = NULL;
    DWORD dwNewServiceType = 0;
    BOOL bDoStuff =  FALSE;

    do {
        if ((hScManager = ::OpenSCManager( NULL, NULL, GENERIC_ALL )) == NULL ||
            (hService = ::OpenService( hScManager, lpServiceName, GENERIC_ALL )) == NULL )
        {
            err = GetLastError();
            // if error = ERROR_SERVICE_DOES_NOT_EXIST
            if (ERROR_SERVICE_DOES_NOT_EXIST != err)
            {
                 iisDebugOut((LOG_TYPE_ERROR, _T("InetConfigServiceInteractive():OpenSCManager or OpenService: Service=%s Err=0x%x FAILED\n"), lpServiceName,err));
            }
            break;
        }

            if(RetrieveServiceConfig(hService, &ServiceConfig) != NO_ERROR)
	        {
                err = GetLastError();
                break;
		}

            if(!ServiceConfig)
	        {
                err = GetLastError();
                break;
		}

	    // Interactive flag can only work on own_process or share_process types
	    if ( (ServiceConfig->dwServiceType & SERVICE_WIN32_OWN_PROCESS) || (ServiceConfig->dwServiceType & SERVICE_WIN32_SHARE_PROCESS))
	    {
            // default it incase someone changes code below and logic gets messed up
            dwNewServiceType = ServiceConfig->dwServiceType;

            // if the interactive flag is already there
            // then don't do jack, otherwise, add it on
            if (ServiceConfig->dwServiceType & SERVICE_INTERACTIVE_PROCESS)
            {
                // only do stuff if we're asked to remove it!
                if (FALSE == AddInteractive)
                {
                    // Remove it from the mask!
                    dwNewServiceType = ServiceConfig->dwServiceType & (~SERVICE_INTERACTIVE_PROCESS);
                    bDoStuff = TRUE;
                }
            }
            else
            {
                if (TRUE == AddInteractive)
                {
                    dwNewServiceType = ServiceConfig->dwServiceType | SERVICE_INTERACTIVE_PROCESS;
                    bDoStuff = TRUE;
                }
            }

            if (TRUE == bDoStuff)
            {
                if ( !::ChangeServiceConfig(hService, dwNewServiceType, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, NULL, NULL, NULL) )
                {
                    err = GetLastError();
			        iisDebugOut((LOG_TYPE_ERROR, _T("InetConfigServiceInteractive():ChangeServiceConfig: Service=%s Err=0x%x FAILED\n"), lpServiceName, err));
                    break;
                }
            }
            else
            {
                break;
            }

        }
        else
        {
            break;
        }

    } while ( FALSE );

    if (ServiceConfig) {free(ServiceConfig);}
    if (hService) {CloseServiceHandle(hService);}
    if (hScManager) {CloseServiceHandle(hScManager);}

    iisDebugOut((LOG_TYPE_TRACE, _T("InetConfigServiceInteractive():ServiceName=%s. Return=0x%x.\n"), lpServiceName, err));
    return(err);
}


// This function trys to create the www service 
int MyCreateService(CString csServiceName, CString csDisplayName, CString csBinPath, CString csDependencies, CString csDescription)
{
    int iReturn = !ERROR_SUCCESS;
    int err = NERR_Success;

    iisDebugOut((LOG_TYPE_TRACE, _T("MyCreateService:%s,%s,%s,%s.\n"),csServiceName, csDisplayName, csBinPath, csDependencies));

    TCHAR szDependencies2[100];

    // csDependencies should look like this: "IISADMIN:something:"
    _tcscpy(szDependencies2, csDependencies);
    _tcscat(szDependencies2, _T(":"));
        
    // make sure it ends with a ":"
    // and then replace all the ":", with a "\0" null....
    TCHAR *p = (LPTSTR) szDependencies2;
    while (*p) 
    {
        // change ":" to a null "\0"
        if (*p == _T(':')){*p = _T('\0');}
        p = _tcsinc(p);
    }

    err = InetCreateService(csServiceName, (LPCTSTR)csDisplayName, (LPCTSTR)csBinPath, SERVICE_AUTO_START, szDependencies2);
    if ( err != NERR_Success )
    {
        // check if the error is because the service already exists...
        if (err == ERROR_SERVICE_EXISTS)
        {
            // Since the service should exist by the time we get here,
            // let's make sure it has the dependency we want it to have.
            err = InetConfigService(csServiceName, (LPCTSTR)csDisplayName, (LPCTSTR)csBinPath, szDependencies2);
            if (err != NERR_Success)
            {
                SetLastError(err);
                goto MyCreateService_Exit;
            }
        }
        else
        {
            SetLastError(err);
            goto MyCreateService_Exit;
        }

    }

    // Use newer api to add the description field.
    err = InetConfigService2(csServiceName, (LPCTSTR)csDescription);
    if (err != NERR_Success)
    {
        SetLastError(err);
        goto MyCreateService_Exit;
    }

    // there was no error in the InetCreateService call.
    // so everything is hunky dory
    iReturn = ERROR_SUCCESS;

MyCreateService_Exit:
    return iReturn;
}


DWORD CreateService_wrap(CString csServiceName, CString csDisplayName, CString csBinPath, CString csDependencies, CString csDescription, BOOL bDisplayMsgOnErrFlag)
{
	int bFinishedFlag = FALSE;
	UINT iMsg = NULL;
	DWORD dwReturn = ERROR_SUCCESS;

	do
	{
		dwReturn = MyCreateService(csServiceName, csDisplayName, csBinPath, csDependencies, csDescription);
		if (dwReturn == ERROR_SUCCESS)
		{
			break;
		}
		else
		{
			if (bDisplayMsgOnErrFlag == TRUE)
			{
                iMsg = MyMessageBox( NULL, IDS_RETRY, MB_ABORTRETRYIGNORE | MB_SETFOREGROUND );
				switch ( iMsg )
				{
				case IDIGNORE:
					dwReturn = ERROR_SUCCESS;
					goto CreateService_wrap_Exit;
				case IDABORT:
					dwReturn = ERROR_OPERATION_ABORTED;
					goto CreateService_wrap_Exit;
				case IDRETRY:
					break;
				default:
					break;
				}
			}
			else
			{
				// return whatever err happened
				goto CreateService_wrap_Exit;
			}

		}
	} while (dwReturn != ERROR_SUCCESS);

CreateService_wrap_Exit:
	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\strfn.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        strfrn.h

   Abstract:

        String Functions

   Author:

        Ronald Meijer (ronaldm)
        Munged for setup by BoydM

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _STRFN_H
#define _STRFN_H


//
// Memory Allocation Macros
//
#define AllocMem(cbSize)\
    ::LocalAlloc(LPTR, cbSize)

#define FreeMem(lp)\
    ::LocalFree(lp)

#define AllocMemByType(citems, type)\
    (type *)AllocMem(citems * sizeof(type))


//
// Debug Formatting Macros
//
   #define TRACEOUT(x)        { ; }
   #define TRACEEOL(x)        { ; }
   #define TRACEEOLID(x)      { ; }
   #define TRACEEOLERR(err,x) { ; }


//
// Helper Macros
//

//
// Get number of array elements
//
#define ARRAY_SIZE(a)    (sizeof(a)/sizeof(a[0]))

//
// Compute size of string array in characters.  That is, don't count
// the terminal null.
//
#define STRSIZE(str)     (ARRAY_SIZE(str)-1)

//
// Get byte count of array
//
#define ARRAY_BYTES(a)   (sizeof(a) * sizeof(a[0]))

//
// Get byte count of character elements of a string -- again
// by not including the terminating NULL.
//
#define STRBYTES(str)    (ARRAY_BYTES(str) - sizeof(str[0]))

#define AllocTString(cch)\
    (LPTSTR)AllocMem((cch) * sizeof(TCHAR))
#define AllocWString(cch)\
    (LPWSTR)AllocMem((cch) * sizeof(WCHAR))

#define IS_NETBIOS_NAME(lpstr) (*lpstr == _T('\\'))

//
// Return the portion of a computer name without the backslashes
//
#define PURE_COMPUTER_NAME(lpstr) (IS_NETBIOS_NAME(lpstr) ? lpstr + 2 : lpstr)

//
// Convert CR/LF to LF
//
BOOL 
PCToUnixText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString strSource
    );

//
// Expand LF to CR/LF (no allocation necessary)
//
BOOL 
UnixToPCText(
    OUT CString & strDestination,
    IN  LPCWSTR lpstrSource
    );

//
// Straight copy
//
BOOL
TextToText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString & strSource
    );

LPWSTR
AllocWideString(
    IN LPCTSTR lpString
    );

LPSTR AllocAnsiString(
    IN LPCTSTR lpString
    );


LPTSTR AllocString(
    IN LPCTSTR lpString
    );

#ifdef UNICODE

    //
    // Copy W string to T string
    // 
    #define WTSTRCPY(dst, src, cch) \
        lstrcpy(dst, src)

    //
    // Copy T string to W string
    //
    #define TWSTRCPY(dst, src, cch) \
        lstrcpy(dst, src)

    //
    // Reference a T String as a W String (a nop in Unicode)
    //
    #define TWSTRREF(str)   ((LPWSTR)str)

#else

    //
    // Convert a T String to a temporary W Buffer, and
    // return a pointer to this internal buffer
    //
    LPWSTR ReferenceAsWideString(LPCTSTR str);

    //
    // Copy W string to T string
    // 
    #define WTSTRCPY(dst, src, cch) \
        WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cch, NULL, NULL)

    //
    // Copy T string to W string
    //
    #define TWSTRCPY(dst, src, cch) \
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, src, -1, dst, cch)

    //
    // Reference a T String as a W String 
    //
    #define TWSTRREF(str)   ReferenceAsWideString(str)

#endif // UNICODE

//
// Determine if the given string is a UNC name
//
BOOL IsUNCName(
    IN const CString & strDirPath
    );

//
// Determine if the path is a fully qualified path in the context
// of the local machine
//
BOOL IsFullyQualifiedPath(
    IN const CString & strDirPath
    );

//
// Determine if the given string is an URL path
//
BOOL IsURLName(
    IN const CString & strDirPath
    );

//
// Determine if the given string describes a relative URL path
//
inline BOOL IsRelURLPath(
    IN LPCTSTR lpPath
    )
{
    ASSERT(lpPath != NULL);
    return *lpPath == _T('/');
}

//
// Determine if the given path describes a wild-carded redirection
// path (starts with *;)
//
inline BOOL IsWildcardedRedirectPath(
    IN LPCTSTR lpPath
    )
{
    ASSERT(lpPath != NULL);
    return lpPath[0] == '*' && lpPath[1] == ';';
}

//
// Determine if the account is local (doesn't have a computer name)
//
inline BOOL MyIsLocalAccount(
    IN CString & strAccount
    )
{
    return strAccount.Find(_T('\\')) == -1;
}

//
// Convert local path to UNC path
//
LPCTSTR MakeUNCPath(
    IN OUT CString & strDir,
    IN LPCTSTR lpszOwner,
    IN LPCTSTR lpszDirectory
    );

//
// Given domain\username, split into user name and domain
//
BOOL SplitUserNameAndDomain(
    IN OUT CString & strUserName,
    IN CString & strDomainName
    );

//
// Convert double-null terminated string to a CStringList
//
DWORD
ConvertDoubleNullListToStringList(
    IN  LPCTSTR lpstrSrc,
    OUT CStringList & strlDest,
    IN  int cChars = -1
    );

DWORD
ConvertWDoubleNullListToStringList(
    IN  PWCHAR lpstrSrc,
    OUT CStringList & strlDest,
    IN  int cChars = -1
    );

//
// Go from a CStringList to a WIDE double null terminated list
//
DWORD
ConvertStringListToWDoubleNullList(
    IN  CStringList & strlSrc,
    OUT DWORD & cchDest,
    OUT PWCHAR & lpstrDest
    );

//
// Go from a CStringList to a double null terminated list
//
DWORD
ConvertStringListToDoubleNullList(
    IN  CStringList & strlSrc,
    OUT DWORD & cchDest,
    OUT LPTSTR & lpstrDest
    );


//
// Convert separated list of strings to CStringList
//
int
ConvertSepLineToStringList(
    IN  LPCTSTR lpstrIn,
    OUT CStringList & strlOut,
    IN  LPCTSTR lpstrSep
    );

//
// Reverse function of the above
//
LPCTSTR
ConvertStringListToSepLine(
    IN  CStringList & strlIn,
    OUT CString & strOut,
    IN  LPCTSTR lpstrSep
    );

//
// Private strtok
//
LPTSTR 
StringTok(
    IN LPTSTR string,
    IN LPCTSTR control
    );

//
// CString.Find() that's not case-sensitive
//
int 
CStringFindNoCase(
    IN const CString & strSrc,
    IN LPCTSTR lpszSub
    );

//
// Replace the first occurrance of one string
// inside another one.  Return error code
//
DWORD
ReplaceStringInString(
    OUT IN CString & strBuffer,
    IN  CString & strTarget,
    IN  CString & strReplacement,
    IN  BOOL fCaseSensitive
    );


class CStringListEx : public CStringList
/*++

Class Description:

    Superclass of CStringList with comparison and assignment
    operators.

Public Interface:

    operator ==       Comparison operator
    operator !=       Comparison operator
    operator =        Assignment operator  

--*/
{
//
// ctor
//
public:
    CStringListEx(int nBlockSize = 10) : CStringList(nBlockSize) {};

//
// Operators
//
public:
    BOOL operator == (const CStringList & strl);           
    BOOL operator != (const CStringList & strl) { return !operator ==(strl); }
    CStringListEx & operator =(const CStringList & strl);
};


#ifdef _DOS

typedef struct tagINTLFORMAT
{
    WORD wDateFormat;
    CHAR szCurrencySymbol[5];
    CHAR szThousandSep[2];
    CHAR szDecimalPoint[2];
    CHAR szDateSep[2];
    CHAR szTimeSep[2];
    BYTE bCurrencyFormat;
    BYTE bCurrencyDecimals;
    BYTE bTimeFormat;
    DWORD dwMapCall;
    CHAR szDataSep[2];
    BYTE bReserved[5];
} INTLFORMAT;

BOOL _dos_getintlsettings(INTLFORMAT * pStruct);

#endif // _DOS



class CINumber
/*++

Class Description:

    Base class for international-friendly number formatting

Public Interface:

NOTES: Consider making this class a template

--*/
{
public:
    static BOOL Initialize(BOOL fUserSetting = TRUE);
    static CString * s_pstrBadNumber;
    static BOOL UseSystemDefault();
    static BOOL UseUserDefault();
    static BOOL IsInitialized();
    static LPCTSTR QueryThousandSeperator();
    static LPCTSTR QueryDecimalPoint();
    static LPCTSTR QueryCurrency();
    static double BuildFloat(const LONG lInteger, const LONG lFraction);
    static LPCTSTR ConvertLongToString(const LONG lSrc, CString & str);
    static LPCTSTR ConvertFloatToString(
        IN const double flSrc, 
        IN int nPrecision, 
        OUT CString & str
        );

    static BOOL ConvertStringToLong(LPCTSTR lpsrc, LONG & lValue);
    static BOOL ConvertStringToFloat(LPCTSTR lpsrc, double & flValue);

protected:
    CINumber();
    ~CINumber();

protected:
    friend BOOL InitIntlSettings();
    friend void TerminateIntlSettings();
    static BOOL Allocate();
    static void DeAllocate();
    static BOOL IsAllocated();

protected:
    static CString * s_pstr;

private:
    static CString * s_pstrThousandSeperator;
    static CString * s_pstrDecimalPoint;
    static CString * s_pstrCurrency;
    static BOOL s_fCurrencyPrefix;
    static BOOL s_fInitialized;
    static BOOL s_fAllocated;
};



class CILong : public CINumber
/*++

Class Description:

    International-friendly LONG number

Public Interface:


--*/
{
public:
    //
    // Constructors
    //
    CILong();
    CILong(LONG lValue);
    CILong(LPCTSTR lpszValue);

public:
    //
    // Assignment Operators
    //
    CILong & operator =(LONG lValue);
    CILong & operator =(LPCTSTR lpszValue);

    //
    // Shorthand Operators
    //
    CILong & operator +=(const LONG lValue);
    CILong & operator +=(const LPCTSTR lpszValue);
    CILong & operator +=(const CILong& value);
    CILong & operator -=(const LONG lValue);
    CILong & operator -=(const LPCTSTR lpszValue);
    CILong & operator -=(const CILong& value);
    CILong & operator *=(const LONG lValue);
    CILong & operator *=(const LPCTSTR lpszValue);
    CILong & operator *=(const CILong& value);
    CILong & operator /=(const LONG lValue);
    CILong & operator /=(const LPCTSTR lpszValue);
    CILong & operator /=(const CILong& value);

    //
    // Comparison operators
    //
    BOOL operator ==(LONG value);
    BOOL operator !=(CILong& value);

    //
    // Conversion operators
    //
    operator const LONG() const;
    operator LPCTSTR() const;

    inline friend CArchive & AFXAPI operator<<(CArchive & ar, CILong & value)
    {
        return (ar << value.m_lValue);
    }

    inline friend CArchive & AFXAPI operator>>(CArchive & ar, CILong & value)
    {
        return (ar >> value.m_lValue);
    }

#ifdef _DEBUG
    //
    // CDumpContext stream operator
    //
    inline friend CDumpContext & AFXAPI operator<<(
        CDumpContext& dc, 
        const CILong& value
        )
    {
        return (dc << value.m_lValue);
    }

#endif // _DEBUG

protected:
    LONG m_lValue;
};



class CIFloat : public CINumber
/*++

Class Description:

    International-friendly floating point number    

Public Interface:

--*/
{
public:
    //
    // Constructors
    //
    CIFloat(int nPrecision = 2);
    CIFloat(double flValue, int nPrecision = 2);
    CIFloat(LONG lInteger, LONG lFraction, int nPrecision = 2);
    CIFloat(LPCTSTR lpszValue, int nPrecision = 2);

public:
    //
    // Precision functions
    //
    int QueryPrecision() const;
    void SetPrecision(int nPrecision);

    //
    // Assignment Operators
    //
    CIFloat & operator =(double flValue);
    CIFloat & operator =(LPCTSTR lpszValue);

    //
    // Shorthand Operators
    //
    CIFloat & operator +=(const double flValue);
    CIFloat & operator +=(const LPCTSTR lpszValue);
    CIFloat & operator +=(const CIFloat& value);
    CIFloat & operator -=(const double flValue);
    CIFloat & operator -=(const LPCTSTR lpszValue);
    CIFloat & operator -=(const CIFloat& value);
    CIFloat & operator *=(const double flValue);
    CIFloat & operator *=(const LPCTSTR lpszValue);
    CIFloat & operator *=(const CIFloat& value);
    CIFloat & operator /=(const double flValue);
    CIFloat & operator /=(const LPCTSTR lpszValue);
    CIFloat & operator /=(const CIFloat& value);

    //
    // Conversion operators
    //
    operator const double() const;
    operator LPCTSTR() const;

    //
    // Persistence Operators
    //
    inline friend CArchive& AFXAPI operator<<(CArchive& ar, CIFloat& value)
    {
        return (ar << value.m_flValue);
    }

    inline friend CArchive& AFXAPI operator>>(CArchive& ar, CIFloat& value)
    {
        return (ar >> value.m_flValue);
    }

#ifdef _DEBUG

    //
    // CDumpContext stream operator
    //
    inline friend CDumpContext& AFXAPI operator<<(
        CDumpContext& dc, 
        const CIFloat& value
        )
    {
        return (dc << value.m_flValue);
    }

#endif // _DEBUG

protected:
    double m_flValue;
    int m_nPrecision;
};


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline /* static */ BOOL CINumber::UseSystemDefault()
{
    return Initialize(FALSE);
}

inline /* static */ BOOL CINumber::UseUserDefault()
{
    return Initialize(TRUE);
}

inline /* static */ BOOL CINumber::IsInitialized()
{
    return s_fInitialized;
}

inline /* static */ LPCTSTR CINumber::QueryThousandSeperator()
{
    return (LPCTSTR)*s_pstrThousandSeperator;
}

inline /* static */ LPCTSTR CINumber::QueryDecimalPoint()
{
    return (LPCTSTR)*s_pstrDecimalPoint;
}

inline /* static */ LPCTSTR CINumber::QueryCurrency()
{
    return (LPCTSTR)*s_pstrCurrency;
}

inline /* static */ BOOL CINumber::IsAllocated()
{
    return s_fAllocated;
}

inline BOOL CILong::operator ==(LONG value)
{
    return m_lValue == value;
}

inline BOOL CILong::operator !=(CILong& value)
{
    return m_lValue != value.m_lValue;
}

inline CILong::operator const LONG() const
{
    return m_lValue;
}

inline CILong::operator LPCTSTR() const
{
    return CINumber::ConvertLongToString(m_lValue, *CINumber::s_pstr);
}

inline int CIFloat::QueryPrecision() const
{
    return m_nPrecision;
}

inline void CIFloat::SetPrecision(int nPrecision)
{
    m_nPrecision = nPrecision;
}

inline CIFloat::operator const double() const
{
    return m_flValue;
}

inline CIFloat::operator LPCTSTR() const
{
    return CINumber::ConvertFloatToString(
        m_flValue, 
        m_nPrecision, 
        *CINumber::s_pstr
        );
}

#endif // _STRFN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\unicode\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT

#include <afxwin.h>
#include <afxext.h>
#include <afxcoll.h>
#include <afxcmn.h>
#include <malloc.h>

#include <ntsam.h>
#include <lm.h>
#include <lmerr.h>
#include <WinError.h>
#include <dbgutil.h>
#include <buffer.hxx>

#include "resource.h"
#include "registry.h"
#include "const.h"
#include "initapp.h"
#include "helper.h"
#include "dllmain.h"
#include "setuputl.h"
#include "shellutl.h"
#include <assert.h>

#undef UNUSED
#include <netlib.h>
#include <lsarpc.h>


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\wolfpack.h ===
#include "stdafx.h"
#include <resapi.h>

INT DoesClusterServiceExist(void);
#ifndef _CHICAGO_
    void  Upgrade_WolfPack();
    DWORD BringALLIISClusterResourcesOffline();
    DWORD BringALLIISClusterResourcesOnline();
    INT   DoClusterServiceCheck(CLUSTER_SVC_INFO_FILL_STRUCT * MyStructOfInfo);
    BOOL  RegisterIisServerInstanceResourceType(LPWSTR pszResType,LPWSTR pszResTypeDisplayName,LPWSTR pszPath,LPWSTR pszAdminPath);
    BOOL  UnregisterIisServerInstanceResourceType(LPWSTR pszResType,LPWSTR pszAdminPath,BOOL bGrabVRootFromResourceAndAddToIISVRoot,BOOL bDeleteAfterMove);
#endif //_CHICAGO_
void   MoveVRootToIIS3Registry( CString strRegPath, CStringArray &strArryOfVrootNames, CStringArray &strArryOfVrootData);
DWORD  IsResourceThisTypeOfService(HRESOURCE hResource, LPWSTR pszTheServiceType);
INT    GetClusterResName(HRESOURCE hResource, CString * csReturnedName);
DWORD WINAPI DoesThisServiceTypeExistInCluster(PVOID pInfo);
int    GetClusterIISVRoot(HRESOURCE hResource, LPWSTR pszTheServiceType, CStringArray &strArryOfVrootNames, CStringArray &strArryOfVrootData);
LPWSTR GetParameter(IN HKEY ClusterKey,IN LPCWSTR ValueName);
int    CheckForIISDependentClusters(HRESOURCE hResource);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\www.h ===
#include "stdafx.h"

int CheckIfThisServerHasAUserThenUseIt(int iForWhichUser);
int CheckIfServerAHasAUserThenUseForServerB(TCHAR *szServerAMetabasePath,int iServerBisWhichUser);
int MakeThisUserNameAndPasswordWork(int iForWhichUser, TCHAR *szAnonyName,TCHAR *szAnonyPassword, int iMetabaseUserExistsButCouldntGetPassword, int IfUserNotExistThenReturnFalse);
int LoopThruW3SVCInstancesAndSetStuff();
#ifndef _CHICAGO_
    int Register_iis_www_handle_iusr_acct(void);
    int Register_iis_www_handle_iwam_acct(void);
    int CheckForOtherIUsersAndUseItForWWW(void);
#endif
INT Register_iis_www();
INT Unregister_iis_www();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\ansi\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#ifndef _MBCS
#define _MBCS	// using MBCS enabling function
#endif
#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#include <afxwin.h>
#include <afxext.h>
#include <afxcoll.h>
#include <afxcmn.h>
#include <malloc.h>
#include <WinError.h>

#include <ntsam.h>
#include <ntlsa.h>
#include <lm.h>
#include <lmerr.h>

#include <dbgutil.h>
#include <buffer.hxx>

#include "resource.h"
#include "registry.h"
#include "const.h"
#include "initapp.h"
#include "helper.h"
#include "dllmain.h"
#include "setuputl.h"
#include "shellutl.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\sld\makefile.inc ===
iCPU=$(PROCESSOR_ARCHITECTURE)

!IF "$(iCPU)"=="x86"
iCPU=I386
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\osrc\www.cpp ===
#include "stdafx.h"
#include <ole2.h>
#include "iadmw.h"
#include "iiscnfg.h"
#include "mdkey.h"
#include "mdentry.h"
#include "mdacl.h"
#include "other.h"
#include "ocmanage.h"
#include "setpass.h"
#include "setuser.h"
#include "www.h"
#include "dllmain.h"

extern OCMANAGER_ROUTINES gHelperRoutines;


#define Register_iis_www_log _T("Register_iis_www")

INT Register_iis_www()
{
    iisDebugOut_Start(Register_iis_www_log, LOG_TYPE_TRACE);
    int iReturn = TRUE;
    int iTempFlag = TRUE;

    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];

    ACTION_TYPE atWWW = GetSubcompAction(_T("iis_www"), TRUE);
    CMDKey cmdKey;

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_www_before"));

    // ---------------------------------------------------
    //
    // Here is the first place where we try to access the metabase!
    //
    // ---------------------------------------------------
    // create node /LM/W3SVC before wamreg.dll create IIS package
    // the registration of w3svc.dll will also require these initial entries to be here
    cmdKey.CreateNode(METADATA_MASTER_ROOT_HANDLE, _T("LM/W3SVC"));
    if ( !(METADATA_HANDLE)cmdKey )
    {
        // We failed to create node on the metabase
        // this is pretty serious.
        // we failed to create the ftp service.
        iisDebugOut((LOG_TYPE_ERROR, _T("%s(): failed to create initial node is metabase 'LM/W3SVC'. GetLastError()=0x%x\n"), Register_iis_www_log, GetLastError()));
        iReturn = FALSE;
        goto Register_iis_www_exit;
    }
    cmdKey.Close();

    // ---------------------------------------------------
    //
    // Get the anonymous username/passowrd and iwam username/password accounts.
    // And verify that the accounts exist and have the right privledges.
    //
    // ---------------------------------------------------
#ifndef _CHICAGO_
    // IUSR_(computername)
    Register_iis_www_handle_iusr_acct();
    SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle, 33002, g_pTheApp->m_csWWWAnonyName);
    AdvanceProgressBarTickGauge();

    // IWAM_(computername)
    Register_iis_www_handle_iwam_acct();
    SetupSetStringId_Wrapper(g_pTheApp->m_hInfHandle, 33001, g_pTheApp->m_csWAMAccountName);
    AdvanceProgressBarTickGauge();
#endif // _CHICAGO_

    // ---------------------------------------------------
    //
    // Install any services or whatever
    //
    // when we get out of this:
    // MAKE SURE THE IISADMIN SERVICE IS RUNNING.
    // This is because we don't want the startup code called twice.
    // example: start the metabase, but it takes a minute,
    // meanwhile, thru com, the metabase tries to get started again,
    // it will then error out with a "instance of the service is already running" error or something like it.
    // ---------------------------------------------------

    WriteToMD_Capabilities(_T("W3SVC"));

    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_www_1"));
    AdvanceProgressBarTickGauge();

    ProgressBarTextStack_Set(IDS_IIS_ALL_CONFIGURE);

    InstallMimeMap();
    HandleSecurityTemplates(_T("W3SVC"));

    // ================
    //
    // LM/W3SVC/n/
    // LM/W3SVC/n/ServerBindings
    // LM/W3SVC/n/SecureBindings
    // LM/W3SVC/n/ServerComment
    // LM/W3SVC/n/ServerSize
    // LM/W3SVC/n/MD_NOT_DELETABLE
    //
    // fresh = ok.
    // reinstall = ok -- Do not re-create these things if it is a reinstall...
    // upgrade 1,2,3 = ok, handles upgrades.
    // upgrade 4     = ok.  if exists, should leave what the user had.
    //                 otherwise write in the default stuff
    //
    //                 if the user does not have these virtual roots which we installed during iis4 days
    //                 then we don't need to verify that they are they.  the user removed them for some
    //                 reason, and we should honor that.
    //                 a. make sure the iishelp points to the right place though.
    // ================
    // About Virtual Roots
    AddVRootsToMD(_T("W3SVC"));
    AdvanceProgressBarTickGauge();

    LoopThruW3SVCInstancesAndSetStuff();
    LogHeapState(FALSE, __FILE__, __LINE__);
    AdvanceProgressBarTickGauge();

    iCount = 1;
    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;

        _stprintf(szTempSection, _T("register_iis_www_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);

        AdvanceProgressBarTickGauge();
    }

    //
    // Finaly Save the path to the WWW Root
    //
    ProcessSection(g_pTheApp->m_hInfHandle, _T("register_iis_www_after"));

    ProgressBarTextStack_Pop();

Register_iis_www_exit:
    iisDebugOut_End(Register_iis_www_log, LOG_TYPE_TRACE);
    return iReturn;
}



INT Unregister_iis_www()
{

    int iCount = 0;
    int iTemp = TRUE;
    TCHAR szTempSection[255];
    ACTION_TYPE atWWW = GetSubcompAction(_T("iis_www"),TRUE);

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_www_before"));
    AdvanceProgressBarTickGauge();

    iCount = 0;
    while(TRUE == iTemp && iCount < 10)
    {   
        iCount++;

        _stprintf(szTempSection, _T("unregister_iis_www_%d"),iCount);

        // this will return false if the section does not exist
        iTemp = ProcessSection(g_pTheApp->m_hInfHandle, szTempSection);

        AdvanceProgressBarTickGauge();
    }

    ProcessSection(g_pTheApp->m_hInfHandle, _T("unregister_iis_www_after"));
    AdvanceProgressBarTickGauge();
    return 0;
}


int LoopThruW3SVCInstancesAndSetStuff()
{
    int iReturn = TRUE;
    CMDKey cmdKey;
    CStringArray arrayInstance;
    int nArray = 0, i = 0;

    // get all instances into an array
    cmdKey.OpenNode(_T("LM/W3SVC"));

    if ( (METADATA_HANDLE)cmdKey )
    {
        CMDKeyIter cmdKeyEnum(cmdKey);
        CString csKeyName;
        while (cmdKeyEnum.Next(&csKeyName) == ERROR_SUCCESS)
        {
            if (IsValidNumber((LPCTSTR)csKeyName))
            {
                arrayInstance.Add(csKeyName);
            }
        }
        cmdKey.Close();
    }

    nArray = (int)arrayInstance.GetSize();
    /*
#ifndef _CHICAGO_
     for (i=0; i<nArray; i++)
     {
        CString csPath;
        csPath = _T("LM/W3SVC/");
        csPath += arrayInstance[i];
        csPath += _T("/ROOT/IISHELP");

        // bug#142508 - Remove restriction on iishelp dir
        // Set LocalhostAccess Only Only
        //SetLocalHostRestriction(csPath);

        // Bug114531: no need to add scriptmap under iisHelp
        // add script map for IISHelp
        // WriteScriptMapListToMetabase(&ScriptMapList, (LPTSTR)(LPCTSTR)csPath, MD_SCRIPTMAPFLAG_SCRIPT | MD_SCRIPTMAPFLAG_CHECK_PATH_INFO);
    }
#endif
    //FreeScriptMapList(&ScriptMapList);
    */

    // set AppFriendlyName, IP restriction and customerror in each non-HTMLA instance
    for (i=0; i<nArray; i++)
        {
        CString csPath;
        csPath = _T("LM/W3SVC/");
        csPath += arrayInstance[i];
        SetAppFriendlyName(csPath);

#ifndef _CHICAGO_
        csPath += _T("/Root/iisadmin");
        if (!g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
        {
            // do not reset the admin restriction on iisadmin if doing an upgrade
            // over an existing metabase
            SetIISADMINRestriction(csPath);
        }
#endif
        }
    goto CreateW3SVCInstances_exit;

CreateW3SVCInstances_exit:
    return iReturn;
}


#ifndef _CHICAGO_

#define Register_iis_www_handle_iwam_acct_log _T("Register_iis_www_handle_iwam_acct")

int Register_iis_www_handle_iwam_acct(void)
{
    int err = FALSE;
    int iReturn = TRUE;
    INT iUserWasNewlyCreated = 0;
    iisDebugOut_Start(Register_iis_www_handle_iwam_acct_log, LOG_TYPE_TRACE);

    if (0 != g_pTheApp->dwUnattendConfig)
    {
        // if some sort of unattended user was specified
        // then use it.  if they specified only a password,
        // then use that password for the default user.
        if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WAM_USER_NAME)
        {
            if (_tcsicmp(g_pTheApp->m_csWAMAccountName_Unattend,_T("")) != 0)
                {g_pTheApp->m_csWAMAccountName = g_pTheApp->m_csWAMAccountName_Unattend;}
        }

        if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WAM_USER_PASS)
        {
            g_pTheApp->m_csWAMAccountPassword = g_pTheApp->m_csWAMAccountPassword_Unattend;
        }

        // let's use the iusr_computername deal
    
        err = CreateIWAMAccount(g_pTheApp->m_csWAMAccountName,g_pTheApp->m_csWAMAccountPassword, &iUserWasNewlyCreated);
        if ( err != NERR_Success )
        {
            // something went wrong, set the user back to iwam!!!
            g_pTheApp->ReGetMachineAndAccountNames();
            g_pTheApp->ResetWAMPassword();

            // flow down and process CheckIfThisServerHasAUserThenUseIt()
            // since things are now hosed!
        }
        else
        {
            // Check if the user was NewlyCreated.
            // if it was then add it to list that eventually gets written to
            // the registry -- so that when uninstall happens, setup knows
            // which users it added -- so that it can remove them!
            if (1 == iUserWasNewlyCreated)
            {
                // Add to the list
                g_pTheApp->UnInstallList_Add(_T("IUSR_WAM"),g_pTheApp->m_csWAMAccountName);
            }
            WriteToMD_IWamUserName_WWW();
            goto Register_iis_www_handle_iwam_acct_Exit;
        }
    }

    if (TRUE == CheckIfThisServerHasAUserThenUseIt(DO_IT_FOR_W3SVC_WAMUSER))
        {goto Register_iis_www_handle_iwam_acct_Exit;}

    // if there are no registry/existing user combinations
    // then we'll have to create a new iusr for WWW

    // let's use the iusr_computername deal
    err = CreateIWAMAccount(g_pTheApp->m_csWAMAccountName,g_pTheApp->m_csWAMAccountPassword, &iUserWasNewlyCreated);
    if ( err != NERR_Success )
    {
        // regenerate the password and try again...
        g_pTheApp->ResetWAMPassword();
        err = CreateIWAMAccount(g_pTheApp->m_csWAMAccountName,g_pTheApp->m_csWAMAccountPassword, &iUserWasNewlyCreated);
    }

    // Check if the user was NewlyCreated.
    // if it was then add it to list that eventually gets written to
    // the registry -- so that when uninstall happens, setup knows
    // which users it added -- so that it can remove them!
    if (1 == iUserWasNewlyCreated)
    {
        // Add to the list
        //g_pTheApp->UnInstallList_Add(_T("IUSR_WAM"),g_pTheApp->m_csWAMAccountName);
    }

    // Stick iwam username in the metabase
    // (this may fail because the password is using encryption -- rsabase.dll)
    // ================
    // LM/W3SVC/WamUserName
    // LM/W3SVC/WamPwd
    // ================
    WriteToMD_IWamUserName_WWW();

    goto Register_iis_www_handle_iwam_acct_Exit;
    
Register_iis_www_handle_iwam_acct_Exit:
    iisDebugOut_End(Register_iis_www_handle_iwam_acct_log, LOG_TYPE_TRACE);
    return iReturn;
}


#define Register_iis_www_handle_iusr_acct_log _T("Register_iis_www_handle_iusr_acct")
int Register_iis_www_handle_iusr_acct(void)
{
    int err = FALSE;
    int iReturn = TRUE;
    INT iUserWasNewlyCreated = 0;
    ACTION_TYPE atWWW = GetSubcompAction(_T("iis_www"),FALSE);
    iisDebugOut_Start(Register_iis_www_handle_iusr_acct_log, LOG_TYPE_TRACE);

    g_pTheApp->m_csWWWAnonyName = g_pTheApp->m_csGuestName;
    g_pTheApp->m_csWWWAnonyPassword = g_pTheApp->m_csGuestPassword;

    if (0 != g_pTheApp->dwUnattendConfig)
    {
        // if some sort of unattended www user was specified
        // then use it.  if they specified only a password,
        // then use that password for the default user.
        if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_NAME)
        {
            if (_tcsicmp(g_pTheApp->m_csWWWAnonyName_Unattend,_T("")) != 0)
                {g_pTheApp->m_csWWWAnonyName = g_pTheApp->m_csWWWAnonyName_Unattend;}
        }

        if (g_pTheApp->dwUnattendConfig & USER_SPECIFIED_INFO_WWW_USER_PASS)
        {
            g_pTheApp->m_csWWWAnonyPassword = g_pTheApp->m_csWWWAnonyPassword_Unattend;
        }

        err = CreateIUSRAccount(g_pTheApp->m_csWWWAnonyName, g_pTheApp->m_csWWWAnonyPassword, &iUserWasNewlyCreated);
        if ( err != NERR_Success )
        {
            // something went wrong, set the user back to guest!!!
            g_pTheApp->m_csWWWAnonyName = g_pTheApp->m_csGuestName;
            g_pTheApp->m_csWWWAnonyPassword = g_pTheApp->m_csGuestPassword;

            // flow down and process CheckIfThisServerHasAUserThenUseIt()
            // since things are now hosed!
        }
        else
        {
            // Check if the user was NewlyCreated.
            // if it was then add it to list that eventually gets written to
            // the registry -- so that when uninstall happens, setup knows
            // which users it added -- so that it can remove them!
            if (1 == iUserWasNewlyCreated)
            {
                // Add to the list
                g_pTheApp->UnInstallList_Add(_T("IUSR_WWW"),g_pTheApp->m_csWWWAnonyName);
            }

            WriteToMD_AnonymousUserName_WWW(FALSE);
            goto Register_iis_www_handle_iusr_acct_Exit;
        }
    }

    if (TRUE == CheckIfThisServerHasAUserThenUseIt(DO_IT_FOR_W3SVC_ANONYMOUSUSER))
        {goto Register_iis_www_handle_iusr_acct_Exit;}

    // Well, i guess the there is no metabase entry for the iusr under ftp.

    // see if we can get it from somewhere else...
    if (atWWW == AT_INSTALL_FRESH)
    {
        // if this is a fresh install of ftp, then
        // let's try to use the www user
        if (TRUE == CheckIfServerAHasAUserThenUseForServerB(_T("LM/MSFTPSVC"), DO_IT_FOR_W3SVC_ANONYMOUSUSER))
            {goto Register_iis_www_handle_iusr_acct_Exit;}
    }

    // if this is an upgrade or fresh or whatevers
    // see if we can get it from an older iis place
    if (TRUE == CheckForOtherIUsersAndUseItForWWW())
        {goto Register_iis_www_handle_iusr_acct_Exit;}

    // if there are no registry/existing user combinations
    // then we'll have to create a new iusr for WWW

    // this was inited in initapp.cpp: CInitApp::SetSetupParams
    // and it could have been overridden by the time we get here

    // let's use the iusr_computername deal
    g_pTheApp->m_csWWWAnonyName = g_pTheApp->m_csGuestName;
    g_pTheApp->m_csWWWAnonyPassword = g_pTheApp->m_csGuestPassword;
    CreateIUSRAccount(g_pTheApp->m_csWWWAnonyName, g_pTheApp->m_csWWWAnonyPassword, &iUserWasNewlyCreated);
    if (1 == iUserWasNewlyCreated)
    {
        // Add to the list
        //g_pTheApp->UnInstallList_Add(_T("IUSR_WWW"),g_pTheApp->m_csWWWAnonyName);
    }

    // ================
    // LM/W3SVC/AnonymousUserName
    // LM/W3SVC/AnonymousPwd
    // ================
    WriteToMD_AnonymousUserName_WWW(FALSE);
    goto Register_iis_www_handle_iusr_acct_Exit;
    
Register_iis_www_handle_iusr_acct_Exit:
    iisDebugOut_End(Register_iis_www_handle_iusr_acct_log, LOG_TYPE_TRACE);
    return iReturn;
}


// Look in the old iis1.0,2.0,3.0 spot for the ftp user and name.
// retrieve it from the registry..
#define CheckForOtherIUsersAndUseItForWWW_log _T("CheckForOtherIUsersAndUseItForWWW")
int CheckForOtherIUsersAndUseItForWWW(void)
{
    int iReturn = FALSE;
    int IfTheUserNotExistThenDoNotDoThis = TRUE;

    CString csAnonyName;
    TCHAR szAnonyName[UNLEN+1];
    TCHAR szAnonyPassword[PWLEN+1];
    iisDebugOut_Start(CheckForOtherIUsersAndUseItForWWW_log);

    CRegKey regFTPParam(HKEY_LOCAL_MACHINE, REG_FTPPARAMETERS, KEY_READ);
    CRegKey regWWWParam(HKEY_LOCAL_MACHINE, REG_WWWPARAMETERS, KEY_READ);

    ACTION_TYPE atWWW = GetSubcompAction(_T("iis_www"),FALSE);
    if (atWWW != AT_INSTALL_UPGRADE)
        {goto CheckForOtherIUsersAndUseItForWWW_Exit;}

    if (g_pTheApp->m_eUpgradeType != UT_351 && g_pTheApp->m_eUpgradeType != UT_10 && g_pTheApp->m_eUpgradeType != UT_20 && g_pTheApp->m_eUpgradeType != UT_30)
        {goto CheckForOtherIUsersAndUseItForWWW_Exit;}

    // retrieve from registry
    if ( (HKEY) regWWWParam ) 
    {
        regWWWParam.m_iDisplayWarnings = FALSE;
        if (ERROR_SUCCESS == regWWWParam.QueryValue(_T("AnonymousUserName"), csAnonyName))
        {
            _tcscpy(szAnonyName, csAnonyName);
            GetAnonymousSecret( _T("W3_ANONYMOUS_DATA"), szAnonyPassword );
            int iThisIsFalseBecauseNoMetabase = FALSE;
            if (TRUE == MakeThisUserNameAndPasswordWork(DO_IT_FOR_W3SVC_ANONYMOUSUSER, szAnonyName, szAnonyPassword, iThisIsFalseBecauseNoMetabase, IfTheUserNotExistThenDoNotDoThis))
            {
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s:using old www reg usr:%s.\n"),CheckForOtherIUsersAndUseItForWWW_log,szAnonyName));
                iReturn = TRUE;
                goto CheckForOtherIUsersAndUseItForWWW_Exit;
            }
            else
            {
                // the user was not found, so don't use this registry data
                // just flow down to the next check
            }
            goto CheckForOtherIUsersAndUseItForWWW_Exit;
        }
    }


    if ( (HKEY) regFTPParam ) 
    {
        regFTPParam.m_iDisplayWarnings = FALSE;
        if (ERROR_SUCCESS == regFTPParam.QueryValue(_T("AnonymousUserName"), csAnonyName))
        {
            _tcscpy(szAnonyName, csAnonyName);
            GetAnonymousSecret( _T("FTPD_ANONYMOUS_DATA"), (LPTSTR)szAnonyPassword );
            int iThisIsFalseBecauseNoMetabase = FALSE;
            if (TRUE == MakeThisUserNameAndPasswordWork(DO_IT_FOR_W3SVC_ANONYMOUSUSER, szAnonyName, szAnonyPassword, iThisIsFalseBecauseNoMetabase, IfTheUserNotExistThenDoNotDoThis))
            {
                iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s:using old ftp reg usr:%s.\n"),CheckForOtherIUsersAndUseItForWWW_log,szAnonyName));
                iReturn = TRUE;
                goto CheckForOtherIUsersAndUseItForWWW_Exit;
            }
            else
            {
                // if this didn't work, then we'll have to return false
                // in other words -- we couldn't find a valid registry and existing user entry...
                iReturn = FALSE;
            }
        }
    }

CheckForOtherIUsersAndUseItForWWW_Exit:
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s():End.ret=%d\n"),CheckForOtherIUsersAndUseItForWWW_log,iReturn));
    return iReturn;
}


#define MakeThisUserNameAndPasswordWork_log _T("MakeThisUserNameAndPasswordWork")
int MakeThisUserNameAndPasswordWork(int iForWhichUser, TCHAR *szAnonyName,TCHAR *szAnonyPassword, int iMetabaseUserExistsButCouldntGetPassword, int IfUserNotExistThenReturnFalse)
{
    int  iReturn = TRUE;
    int  iMetabaseUpgradeScenarioSoOverWriteOnlyIfAlreadyThere = FALSE;
    INT  iUserWasNewlyCreated = 0;

    // We want to see if these users exists
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s:usrtype=%d:flag1=%d:flag2=%d\n"),MakeThisUserNameAndPasswordWork_log,iForWhichUser,szAnonyName,iMetabaseUserExistsButCouldntGetPassword,IfUserNotExistThenReturnFalse));

    // check if anonyname is blank
    if (!szAnonyName) {goto MakeThisUserNameAndPasswordWork_Exit;}
    // Check if just contains nothing
    if (_tcsicmp(szAnonyName, _T("")) == 0) {goto MakeThisUserNameAndPasswordWork_Exit;}

    // Only check if the user exists if this is a user on this machine.
    // if it is not a user on this machine, then don't validate the user/password,
    // since during Guimode setup, they may not be connected to the network.
    if ( IsDomainSpecifiedOtherThanLocalMachine(szAnonyName))
    {
        // use whatever they had.
        // can't verify that the user exists.
        // can't verify that the password actually works.

        // so we can't verify that the user exists, so let's figure it doesn't
        if (IfUserNotExistThenReturnFalse)
        {
            iReturn = FALSE;
        }
    }
    else
    {
        // Check if this user actually exists...
        if (IsUserExist(szAnonyName))
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s:The %s user exists\n"),MakeThisUserNameAndPasswordWork_log,szAnonyName));

            // The only way we can be down here is if the username is a local account.
            // Reset the password to make sure it works!
            ChangeUserPassword(szAnonyName, szAnonyPassword);

            if (iForWhichUser == DO_IT_FOR_W3SVC_ANONYMOUSUSER)
            {
                // IUSR_ account already exist, reuse it
                g_pTheApp->m_csWWWAnonyName = szAnonyName;
                // But assume that the password is correct!
                g_pTheApp->m_csWWWAnonyPassword = szAnonyPassword;
                // make sure this user has the appropriate rights..
                RegisterAccountUserRights(g_pTheApp->m_csWWWAnonyName, TRUE, FALSE);
            }
            if (iForWhichUser == DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER)
            {
                // IUSR_ account already exist, reuse it
                g_pTheApp->m_csFTPAnonyName = szAnonyName;
                // But assume that the password is correct!
                g_pTheApp->m_csFTPAnonyPassword = szAnonyPassword;
                // make sure this user has the appropriate rights..
                RegisterAccountUserRights(g_pTheApp->m_csFTPAnonyName, TRUE, FALSE);
            }
            if (iForWhichUser == DO_IT_FOR_W3SVC_WAMUSER)
            {
                // IWAM_ account already exist, resue it
                g_pTheApp->m_csWAMAccountName = szAnonyName;
                // But assume that the password is correct!
                g_pTheApp->m_csWAMAccountPassword = szAnonyPassword;
                // make sure the user has the appropriate rights
                RegisterAccountUserRights(g_pTheApp->m_csWAMAccountName, TRUE, TRUE);
            }
           
        }
        else
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s:The %s user does not exist\n"),MakeThisUserNameAndPasswordWork_log,szAnonyName));
            if (IfUserNotExistThenReturnFalse)
            {
                iReturn = FALSE;
            }
            else
            {
                if (iForWhichUser == DO_IT_FOR_W3SVC_ANONYMOUSUSER)
                {
                    iisDebugOut((LOG_TYPE_WARN, _T("%s():FAIL WARNING: previous W3SVC iusr_ does not exist. creating a new one.\n"),MakeThisUserNameAndPasswordWork_log));
                    g_pTheApp->m_csWWWAnonyName = szAnonyName;
                    if (!szAnonyPassword || _tcsicmp(szAnonyPassword, _T("")) == 0)
                        {_tcscpy(szAnonyPassword,g_pTheApp->m_csGuestPassword);}
                    g_pTheApp->m_csWWWAnonyPassword = szAnonyPassword;
                    CreateIUSRAccount(g_pTheApp->m_csWWWAnonyName, g_pTheApp->m_csWWWAnonyPassword,&iUserWasNewlyCreated);
                }

                if (iForWhichUser == DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER)
                {
                    iisDebugOut((LOG_TYPE_WARN, _T("%s():FAIL WARNING: previous MSFTPSVC iusr_ does not exist. creating a new one.\n"),MakeThisUserNameAndPasswordWork_log));
                    g_pTheApp->m_csFTPAnonyName = szAnonyName;
                    if (!szAnonyPassword || _tcsicmp(szAnonyPassword, _T("")) == 0)
                        {_tcscpy(szAnonyPassword,g_pTheApp->m_csGuestPassword);}
                    g_pTheApp->m_csFTPAnonyPassword = szAnonyPassword;
                    CreateIUSRAccount(g_pTheApp->m_csFTPAnonyName, g_pTheApp->m_csFTPAnonyPassword,&iUserWasNewlyCreated);
                }

                if (iForWhichUser == DO_IT_FOR_W3SVC_WAMUSER)
                {
                    iisDebugOut((LOG_TYPE_WARN, _T("%s():FAIL WARNING: previous W3SVC iwam_ does not exist. creating a new one.\n"),MakeThisUserNameAndPasswordWork_log));
                    g_pTheApp->m_csWAMAccountName = szAnonyName;
                    if (!szAnonyPassword || _tcsicmp(szAnonyPassword, _T("")) == 0)
                        {_tcscpy(szAnonyPassword,g_pTheApp->m_csGuestPassword);}
                    g_pTheApp->m_csWAMAccountPassword = szAnonyPassword;
                    CreateIWAMAccount(g_pTheApp->m_csWAMAccountName,g_pTheApp->m_csWAMAccountPassword,&iUserWasNewlyCreated);
                }
            }
        }
    }

MakeThisUserNameAndPasswordWork_Exit:
    if (iMetabaseUserExistsButCouldntGetPassword)
    {
        iMetabaseUpgradeScenarioSoOverWriteOnlyIfAlreadyThere = TRUE;
    }
    if (g_pTheApp->m_bUpgradeTypeHasMetabaseFlag)
    {
        iMetabaseUpgradeScenarioSoOverWriteOnlyIfAlreadyThere = TRUE;
    }

    if (iForWhichUser == DO_IT_FOR_W3SVC_ANONYMOUSUSER)
    {
        // ================
        // LM/W3SVC/AnonymousUserName
        // LM/W3SVC/AnonymousPwd
        // ================
        WriteToMD_AnonymousUserName_WWW(iMetabaseUpgradeScenarioSoOverWriteOnlyIfAlreadyThere);
    }
    if (iForWhichUser == DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER)
    {
        // ================
        // LM/MSFTPSVC/AnonymousUserName
        // LM/MSFTPSVC/AnonymousPwd
        // ================
        WriteToMD_AnonymousUserName_FTP(iMetabaseUpgradeScenarioSoOverWriteOnlyIfAlreadyThere);
    }
    if (iForWhichUser == DO_IT_FOR_W3SVC_WAMUSER)
    {
        // ================
        // LM/W3SVC/WamUserName
        // LM/W3SVC/WamPwd
        // ================
        WriteToMD_IWamUserName_WWW();
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s():End.ret=%d.\n"),MakeThisUserNameAndPasswordWork_log,iReturn));
    return iReturn;
}


//
// Returns true if it can get the ftp/WWW username and password from the metabase,
// if it can then it will make sure that it can use that user <-- by creating it if it doesn't exist
//
#define CheckIfThisServerHasAUserThenUseIt_log _T("CheckIfThisServerHasAUserThenUseIt")
int CheckIfThisServerHasAUserThenUseIt(int iForWhichUser)
{
    int  iReturn = FALSE;
    TCHAR szAnonyName[UNLEN+1];
    TCHAR szAnonyPassword[PWLEN+1];
    TCHAR szMetabasePath[_MAX_PATH];
    int iMetabaseUserExistsButCouldntGetPassword = TRUE;

    // set defaults for the w3svc user
    int iMetabaseID_ForUserName = MD_ANONYMOUS_USER_NAME;
    int iMetabaseID_ForUserPassword = MD_ANONYMOUS_PWD;
    _tcscpy(szMetabasePath,_T("LM/W3SVC"));

    if (iForWhichUser == DO_IT_FOR_MSFTPSVC_ANONYMOUSUSER)
    {
        _tcscpy(szMetabasePath,_T("LM/MSFTPSVC"));
        iMetabaseID_ForUserName = MD_ANONYMOUS_USER_NAME;
        iMetabaseID_ForUserPassword = MD_ANONYMOUS_PWD;
    }
    if (iForWhichUser == DO_IT_FOR_W3SVC_WAMUSER)
    {
        _tcscpy(szMetabasePath,_T("LM/W3SVC"));
        iMetabaseID_ForUserName = MD_WAM_USER_NAME;
        iMetabaseID_ForUserPassword = MD_WAM_PWD;
    }

    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s():Start:%s:whichuser=%d\n"),CheckIfThisServerHasAUserThenUseIt_log,szMetabasePath,iForWhichUser));

    // See if it's already in the metabase if it is then use that.
    if (TRUE == GetDataFromMetabase(szMetabasePath, iMetabaseID_ForUserName, (PBYTE)szAnonyName, UNLEN+1))
    {
        // Check if the username is null
        if (!szAnonyName)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("...GetDataFromMetabase:username is null.fail.\n")));
            iReturn = FALSE;
            goto CheckIfThisServerHasAUserThenUseIt_Exit;
        }

        // Check if just contains nothing
        if (_tcsicmp(szAnonyName, _T("")) == 0)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("...GetDataFromMetabase:username is blank.fail.\n")));
            iReturn = FALSE;
            goto CheckIfThisServerHasAUserThenUseIt_Exit;
        }

        // see if we can get the password too!
        iMetabaseUserExistsButCouldntGetPassword = TRUE;
        if (TRUE == GetDataFromMetabase(szMetabasePath, iMetabaseID_ForUserPassword, (PBYTE)szAnonyPassword, PWLEN+1))
        {
            iMetabaseUserExistsButCouldntGetPassword = FALSE;
        }
        // Yes, we got the username and password.
        // let's see if they are valid...
        MakeThisUserNameAndPasswordWork(iForWhichUser, szAnonyName, szAnonyPassword, iMetabaseUserExistsButCouldntGetPassword, FALSE);
        iReturn = TRUE;
    }

CheckIfThisServerHasAUserThenUseIt_Exit:
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s():End.ret=%d.\n"),CheckIfThisServerHasAUserThenUseIt_log,iReturn));
    return iReturn;
}


#define CheckIfServerAHasAUserThenUseForServerB_log _T("CheckIfServerAHasAUserThenUseForServerB")
int CheckIfServerAHasAUserThenUseForServerB(TCHAR *szServerAMetabasePath,int iServerBisWhichUser)
{
    int  iReturn = FALSE;
    TCHAR szAnonyName[UNLEN+1];
    TCHAR szAnonyPassword[PWLEN+1];
    int iMetabaseUserExistsButCouldntGetPassword = TRUE;
    iisDebugOut_Start(CheckIfServerAHasAUserThenUseForServerB_log);

    // see if www server has a user there, if it does then use that.

    // See if it's already in the metabase if it is then use that.
    if (TRUE == GetDataFromMetabase(szServerAMetabasePath, MD_ANONYMOUS_USER_NAME, (PBYTE)szAnonyName, UNLEN+1))
    {
        // Check if the username is null
        if (!szAnonyName)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("...GetDataFromMetabase:username is null.fail.\n")));
            iReturn = FALSE;
            goto CheckIfServerAHasAUserThenUseForServerB_Exit;
        }

        // Check if just contains nothing
        if (_tcsicmp(szAnonyName, _T("")) == 0)
        {
            iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("...GetDataFromMetabase:username is blank.fail.\n")));
            iReturn = FALSE;
            goto CheckIfServerAHasAUserThenUseForServerB_Exit;
        }

        // see if we can get the password too!
        iMetabaseUserExistsButCouldntGetPassword = TRUE;
        if (TRUE == GetDataFromMetabase(szServerAMetabasePath, MD_ANONYMOUS_PWD, (PBYTE)szAnonyPassword, PWLEN+1))
        {
            iMetabaseUserExistsButCouldntGetPassword = FALSE;
        }

        // Yes, we got the username and password.
        // let's see if they are valid...
        MakeThisUserNameAndPasswordWork(iServerBisWhichUser, szAnonyName, szAnonyPassword, iMetabaseUserExistsButCouldntGetPassword, FALSE);
        iReturn = TRUE;
    }

CheckIfServerAHasAUserThenUseForServerB_Exit:
    iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("%s():End.ret=%d.\n"),CheckIfServerAHasAUserThenUseForServerB_log,iReturn));
    return iReturn;
}

#endif // _CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\certlook\main.cpp ===
#include <stdio.h>
#include <tchar.h>
#include <malloc.h>

// iis metabase includes
#define INITGUID // must be before iadmw.h
#include <iadmw.h>      // Interface header
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines

// other includes
#include <wincrypt.h>
#include <xenroll.h>
#include <cryptui.h>
#include "utils.h"

const CLSID CLSID_CEnroll = 
	{0x43F8F289, 0x7A20, 0x11D0, {0x8F, 0x06, 0x00, 0xC0, 0x4F, 0xC2, 0x95, 0xE1}};

const IID IID_IEnroll = 
	{0xacaa7838, 0x4585, 0x11d1, {0xab, 0x57, 0x00, 0xc0, 0x4f, 0xc2, 0x95, 0xe1}};

#define  ARRAYSIZE(x)\
	(sizeof(x)/sizeof(x[0]))

int g_iDo_A = FALSE;
int g_iDo_B = FALSE;
int g_iDo_C = FALSE;


// prototypes
void  ShowHelp(void);
int   DoStuff(void);
int   PrintCertDescList(void);
DWORD CheckCertConstraints(PCCERT_CONTEXT pCC);

// begin 
void ShowHelp(void)
{
    _tprintf(_T("Certificate Looker test program\n\n"));
    _tprintf(_T("Usage:Certlook.exe [-b] [-c]\n\n"));
    _tprintf(_T("no parameters opens the 'MY' store\n"));
    _tprintf(_T("           -b opens the 'CA' store\n"));
    _tprintf(_T("           -c opens the 'ROOT' store\n"));
    return;
}


int __cdecl  main(int argc,char *argv[])
{
    int iRet = 0;
    int argno;
	char * pArg = NULL;
	char * pCmdStart = NULL;
    TCHAR szFilePath1[_MAX_PATH];
    TCHAR szFilePath2[_MAX_PATH];
    TCHAR szParamString_Z[_MAX_PATH];

    int iDoVersion = FALSE;
    int iGotParamZ = FALSE;

    *szFilePath1 = '\0';
    *szFilePath2 = '\0';
    *szParamString_Z = '\0';
    _tcscpy(szFilePath1,_T(""));
    _tcscpy(szFilePath2,_T(""));
    _tcscpy(szParamString_Z,_T(""));
    
    for(argno=1; argno<argc; argno++) 
    {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' ) 
        {
            switch (argv[argno][1]) 
            {
                case 'a':
                case 'A':
                    g_iDo_A = TRUE;
                    break;
                case 'b':
                case 'B':
                    g_iDo_B = TRUE;
                    break;
                case 'c':
                case 'C':
                    g_iDo_C = TRUE;
                    break;
                case 'v':
                case 'V':
                    iDoVersion = TRUE;
                    break;
                case 'z':
                case 'Z':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') 
                    {
                        char szTempString[_MAX_PATH];

						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') 
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else 
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
#if defined(UNICODE) || defined(_UNICODE)
						MultiByteToWideChar(CP_ACP, 0, szTempString, -1, (LPWSTR) szParamString_Z, _MAX_PATH);
#else
                        _tcscpy(szParamString_Z,szTempString);
#endif

                        iGotParamZ = TRUE;
					}
                    break;
                case '?':
                    goto main_exit_with_help;
                    break;
            }
        }
        else 
        {
            if (_tcsicmp(szFilePath1, _T("")) == 0)
            {
                // if no arguments, then get the filename portion
#if defined(UNICODE) || defined(_UNICODE)
                MultiByteToWideChar(CP_ACP, 0, argv[argno], -1, (LPTSTR) szFilePath1, _MAX_PATH);
#else
                _tcscpy(szFilePath1,argv[argno]);
#endif
            }
            else
            {
                if (_tcsicmp(szFilePath2, _T("")) == 0)
                {
                    // if no arguments, then get the filename portion
#if defined(UNICODE) || defined(_UNICODE)
                    MultiByteToWideChar(CP_ACP, 0, argv[argno], -1, (LPTSTR) szFilePath2, _MAX_PATH);
#else
                    _tcscpy(szFilePath2,argv[argno]);
#endif
                }
            }
        }
    }


    iRet = DoStuff();

    if (TRUE == iDoVersion)
    {
        // output the version
        _tprintf(_T("1\n\n"));

        iRet = 10;
        goto main_exit_gracefully;
    }

    /*
    if (_tcsicmp(szFilePath1, _T("")) == 0)
    {
        goto main_exit_with_help;
    }
    */

    goto main_exit_gracefully;
  
main_exit_gracefully:
    exit(iRet);

main_exit_with_help:
    ShowHelp();
    exit(iRet);
}

int DoStuff(void)
{
    int iReturn = FALSE;

    PrintCertDescList();

    goto DoStuff_Exit;

DoStuff_Exit:
    return iReturn;
}


BOOL ViewCertificateDialog(CRYPT_HASH_BLOB* pcrypt_hash, HWND hWnd)
{
    BOOL bReturn = FALSE;
    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pCert = NULL;

	hStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM,
            PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
           	NULL,
            CERT_SYSTEM_STORE_LOCAL_MACHINE,
            _T("MY")
            );
    if (hStore != NULL)
    {
		// Now we need to find cert by hash
		//CRYPT_HASH_BLOB crypt_hash;
		//crypt_hash.cbData = hash.GetSize();
		//crypt_hash.pbData = hash.GetData();
		pCert = CertFindCertificateInStore(hStore, 
			X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
			0, CERT_FIND_HASH, (LPVOID)pcrypt_hash, NULL);
    }

	if (pCert)
	{
		BOOL fPropertiesChanged;
		CRYPTUI_VIEWCERTIFICATE_STRUCT vcs;
		HCERTSTORE hCertStore = ::CertDuplicateStore(hStore);
		::ZeroMemory (&vcs, sizeof (vcs));
		vcs.dwSize = sizeof (vcs);
        vcs.hwndParent = hWnd;
		vcs.dwFlags = 0;
		vcs.cStores = 1;
		vcs.rghStores = &hCertStore;
		vcs.pCertContext = pCert;
		::CryptUIDlgViewCertificate(&vcs, &fPropertiesChanged);
		::CertCloseStore (hCertStore, 0);
        bReturn = TRUE;
	}
    else
    {
        // it failed
    }
    if (pCert != NULL)
        ::CertFreeCertificateContext(pCert);
    if (hStore != NULL)
        ::CertCloseStore(hStore, 0);

    return bReturn;
}

BOOL
GetKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						  CERT_ENHKEY_USAGE ** pKeyUsage, 
						  BOOL fPropertiesOnly, 
						  HRESULT * phRes)
{
	DWORD cb = 0;
	BOOL bRes = FALSE;
   if (!CertGetEnhancedKeyUsage(pCertContext,
                                fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                NULL,
                                &cb))
   {
		*phRes = HRESULT_FROM_WIN32(GetLastError());
		goto ErrExit;
   }
   if (NULL == (*pKeyUsage = (CERT_ENHKEY_USAGE *)malloc(cb)))
   {
		*phRes = E_OUTOFMEMORY;
		goto ErrExit;
   }
   if (!CertGetEnhancedKeyUsage (pCertContext,
                                 fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                 *pKeyUsage,
                                 &cb))
   {
		free(*pKeyUsage);
		*phRes = HRESULT_FROM_WIN32(GetLastError());
		goto ErrExit;
   }
	*phRes = S_OK;
	bRes = TRUE;
ErrExit:
	return bRes;
}


BOOL
ContainsKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						 HRESULT * phRes
						 )
{
	BOOL bRes = FALSE;
	CERT_ENHKEY_USAGE * pKeyUsage = NULL;
	if (GetKeyUsageProperty(pCertContext, &pKeyUsage, FALSE, phRes))
	{
		if (pKeyUsage->cUsageIdentifier == 0)
		{
            _tprintf(_T("cUsageIdentifier=0   <---\n"));
			bRes = TRUE;
		}
		else
		{
			for (DWORD i = 0; i < pKeyUsage->cUsageIdentifier; i++)
			{
				// Our friends from CAPI made this property ASCII even for 
				// UNICODE program
				if (strstr(pKeyUsage->rgpszUsageIdentifier[i], szOID_PKIX_KP_SERVER_AUTH) != NULL)
				{
                    _tprintf(_T("cUsageIdentifier=szOID_PKIX_KP_SERVER_AUTH\n"));
					bRes = TRUE;
					break;
				}
				if (strstr(pKeyUsage->rgpszUsageIdentifier[i], szOID_SERVER_GATED_CRYPTO) != NULL)
				{
                    _tprintf(_T("cUsageIdentifier=szOID_SERVER_GATED_CRYPTO\n"));
					bRes = TRUE;
					break;
				}
				if (strstr(pKeyUsage->rgpszUsageIdentifier[i], szOID_SGC_NETSCAPE) != NULL)
				{
                    _tprintf(_T("cUsageIdentifier=szOID_SGC_NETSCAPE\n"));
					bRes = TRUE;
					break;
				}
			}
		}
        if (pKeyUsage){free(pKeyUsage);}
	}
	return bRes;
}



BOOL
GetNameString(PCCERT_CONTEXT pCertContext,
				  DWORD type,
				  DWORD flag,
				  WCHAR * TheName,
				  HRESULT * phRes)
{
	BOOL bRes = FALSE;
	LPTSTR pName = NULL;
	DWORD cchName = CertGetNameString(pCertContext, type, flag, NULL, NULL, 0);
	if (cchName > 1)
	{
        pName = (LPTSTR) malloc(cchName);
        if (pName)
        {
            bRes = (1 != CertGetNameString(pCertContext, type, flag, NULL, pName, cchName));
            ZeroMemory(TheName,sizeof(TheName));
            memcpy(TheName,pName,cchName);
        }
	}
	else
	{
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	return bRes;
}


BOOL
GetFriendlyName(PCCERT_CONTEXT pCertContext,
                    WCHAR * TheName,
					 HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	TCHAR * pName = NULL;
    if (CertGetCertificateContextProperty(pCertContext, CERT_FRIENDLY_NAME_PROP_ID, NULL, &cb))
    {
        pName = (LPTSTR) malloc(cb);
        if (pName)
        {
            if (CertGetCertificateContextProperty(pCertContext, CERT_FRIENDLY_NAME_PROP_ID, pName, &cb))
            {
		        pName[cb] = 0;
    	        bRes = TRUE;

                ZeroMemory(TheName,sizeof(TheName));
                memcpy(TheName,pName,cb);
            }
	        else
	        {
		        *phRes = HRESULT_FROM_WIN32(GetLastError());
	        }
        }
	    else
	    {
		    *phRes = HRESULT_FROM_WIN32(GetLastError());
	    }

    }
	else
	{
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}

	return bRes;
}


BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId)
{   
    PCCRYPT_OID_INFO pOIDInfo;
            
    if (NULL != (pOIDInfo = CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, pszObjId, 0)))
    {
        if ((DWORD)wcslen(pOIDInfo->pwszName)+1 <= stringSize)
        {
            wcscpy(string, pOIDInfo->pwszName);
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return (MultiByteToWideChar(CP_ACP, 0, pszObjId, -1, string, stringSize) != 0);
    }
    return TRUE;
}


BOOL 
FormatEnhancedKeyUsageString(PCCERT_CONTEXT pCertContext, 
							 BOOL fPropertiesOnly, 
							 BOOL fMultiline,
							 HRESULT * phRes)
{
	CERT_ENHKEY_USAGE * pKeyUsage = NULL;
	WCHAR szText[255];
	BOOL bRes = FALSE;

	if (GetKeyUsageProperty(pCertContext, &pKeyUsage, fPropertiesOnly, phRes))
	{
        _tprintf(_T("EnhancedKeyUsage="));

		// loop for each usage and add it to the display string
		for (DWORD i = 0; i < pKeyUsage->cUsageIdentifier; i++)
		{
			if (!(bRes = MyGetOIDInfo(szText, ARRAYSIZE(szText), pKeyUsage->rgpszUsageIdentifier[i])))
				break;
			// add delimeter if not first iteration
            wprintf(szText);
            wprintf(L",");
		}
        wprintf(L"\n");
		free (pKeyUsage);
	}
	return bRes;
}




BOOL PrintCertDescription(PCCERT_CONTEXT pCert)
{
	BOOL bRes = FALSE;
    HRESULT hRes = 0;
	DWORD cb;
	UINT i, j;
	CERT_NAME_INFO * pNameInfo;
    WCHAR wCA_Name[255];

	if (pCert == NULL)
		goto ErrExit;

	if (!CryptDecodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
					pCert->pCertInfo->Subject.pbData,
					pCert->pCertInfo->Subject.cbData,
					0, NULL, &cb)
		||	NULL == (pNameInfo = (CERT_NAME_INFO *)_alloca(cb))
		|| !CryptDecodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
					pCert->pCertInfo->Subject.pbData,
					pCert->pCertInfo->Subject.cbData,
					0, 
					pNameInfo, &cb)
					)
	{
		goto ErrExit;
	}

	for (i = 0; i < pNameInfo->cRDN; i++)
	{
        CERT_RDN_VALUE_BLOB Blobber;
		CERT_RDN rdn = pNameInfo->rgRDN[i];
		for (j = 0; j < rdn.cRDNAttr; j++)
		{
			CERT_RDN_ATTR attr = rdn.rgRDNAttr[j];
            Blobber = (CERT_RDN_VALUE_BLOB) attr.Value;
            WCHAR TempString[255];
            ZeroMemory(TempString,sizeof(TempString));
            memcpy(TempString, Blobber.pbData,Blobber.cbData);

			if (strcmp(attr.pszObjId, szOID_COMMON_NAME) == 0)
			{
                _tprintf(_T("szOID_COMMON_NAME="));wprintf(TempString);_tprintf(_T("\n"));
			}
			else if (strcmp(attr.pszObjId, szOID_COUNTRY_NAME) == 0)
			{
                _tprintf(_T("szOID_COUNTRY_NAME="));wprintf(TempString);_tprintf(_T("\n"));
			}
			else if (strcmp(attr.pszObjId, szOID_LOCALITY_NAME) == 0)
			{
                _tprintf(_T("szOID_LOCALITY_NAME="));wprintf(TempString);_tprintf(_T("\n"));
			}
			else if (strcmp(attr.pszObjId, szOID_STATE_OR_PROVINCE_NAME) == 0)
			{
                _tprintf(_T("szOID_STATE_OR_PROVINCE_NAME="));wprintf(TempString);_tprintf(_T("\n"));
			}
			else if (strcmp(attr.pszObjId, szOID_ORGANIZATION_NAME) == 0)
			{
                _tprintf(_T("szOID_ORGANIZATION_NAME="));wprintf(TempString);_tprintf(_T("\n"));
			}
			else if (strcmp(attr.pszObjId, szOID_ORGANIZATIONAL_UNIT_NAME) == 0)
			{
                _tprintf(_T("szOID_ORGANIZATIONAL_UNIT_NAME="));wprintf(TempString);_tprintf(_T("\n"));
			}
		}
	}
    
	// issued to
	if (!GetNameString(pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, wCA_Name, &hRes))
    {
		goto ErrExit;
    }
    _tprintf(_T("Name="));wprintf(wCA_Name);_tprintf(_T("\n"));
    if (wCA_Name){free(wCA_Name);}

    /*
	// expiration date
	if (!FormatDateString(desc.m_ExpirationDate, pCert->pCertInfo->NotAfter, FALSE, FALSE))
	{
		goto ErrExit;
	}
    */

	// purpose
	if (!FormatEnhancedKeyUsageString(pCert, FALSE, FALSE, &hRes))
	{
		// According to local experts, we should also use certs without this property set
        _tprintf(_T("There is no EnhancedKeyUsage on this one.\n"));
		//goto ErrExit;
	}

	// friendly name
	if (GetFriendlyName(pCert, wCA_Name, &hRes))
	{
        _tprintf(_T("FriendlyName="));wprintf(wCA_Name);_tprintf(_T("\n"));
        if (wCA_Name){free(wCA_Name);}
	}

	bRes = TRUE;

ErrExit:
	return bRes;
}


HCERTSTORE OpenMyStore(IEnroll * pEnroll, HRESULT * phResult)
{
	HCERTSTORE hStore = NULL;
	BSTR bstrStoreName = NULL;
    BSTR bstrStoreType = NULL;
	long dwStoreFlags;

	if(SUCCEEDED(pEnroll->get_MyStoreNameWStr(&bstrStoreName)))
    {
	    if(SUCCEEDED(pEnroll->get_MyStoreTypeWStr(&bstrStoreType)))
        {
	        if(SUCCEEDED(pEnroll->get_MyStoreFlags(&dwStoreFlags)))
            {
	            size_t store_type_len = wcslen(bstrStoreType);
	            char * szStoreProvider = (char *)_alloca(store_type_len + 1);
	            //ASSERT(szStoreProvider != NULL);
	            size_t n = wcstombs(szStoreProvider, bstrStoreType, store_type_len);
	            //ASSERT(n != -1);
	            // this converter doesn't set zero byte!!!
	            szStoreProvider[n] = '\0';

                if (g_iDo_B)
                {
                    _tprintf(_T("CertOpenStore:CA\n"));
                hStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM,
                    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                    NULL,
                    CERT_SYSTEM_STORE_LOCAL_MACHINE,
                    L"CA");
                }
                else if (g_iDo_C)
                {
                    _tprintf(_T("CertOpenStore:ROOT\n"));
                    hStore = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM,
                        PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                        NULL,
                        CERT_SYSTEM_STORE_LOCAL_MACHINE,
                        L"ROOT");
                }
                else
                {
                    wprintf(L"CertOpenStore:%s\n",bstrStoreName);
	                hStore = CertOpenStore(
		               szStoreProvider,
                       PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
		               NULL,
		               dwStoreFlags,
		               bstrStoreName
		               );
                }

            }
        }
    }

    if (bstrStoreName) {CoTaskMemFree(bstrStoreName);}
    if (bstrStoreType) {CoTaskMemFree(bstrStoreType);}
    if (hStore == NULL){*phResult = HRESULT_FROM_WIN32(GetLastError());}
	return hStore;
}

IEnroll * GetEnrollObject(void)
{
    HRESULT hRes = 0;
    IEnroll * pEnroll;
    BOOL bPleaseDoCoUninit = FALSE;

    hRes = CoInitialize(NULL);
    if(FAILED(hRes))
    {
        return NULL;
    }
    bPleaseDoCoUninit = TRUE;

	hRes = CoCreateInstance(CLSID_CEnroll,NULL,CLSCTX_INPROC_SERVER,IID_IEnroll,(void **)&pEnroll);

	// now we need to change defaults for this
	// object to LOCAL_MACHINE
	if (pEnroll != NULL)
	{
		long dwFlags;
		pEnroll->get_MyStoreFlags(&dwFlags);
		dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
		dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;
		// following call will change Request store flags also
		pEnroll->put_MyStoreFlags(dwFlags);
		pEnroll->get_GenKeyFlags(&dwFlags);
		dwFlags |= CRYPT_EXPORTABLE;
		pEnroll->put_GenKeyFlags(dwFlags);
		pEnroll->put_KeySpec(AT_KEYEXCHANGE);
		pEnroll->put_ProviderType(PROV_RSA_SCHANNEL);
		pEnroll->put_DeleteRequestCert(TRUE);
	}
    else
    {
        _tprintf(_T("GetEnrollObject failed!\n"));
    }

    if (bPleaseDoCoUninit)
    {
        CoUninitialize();
    }

	return pEnroll;
}


int PrintCertDescList(void)
{
	BOOL bRes = FALSE;
    HRESULT hRes = 0;
    HCERTSTORE hStore = NULL;
    int iCount = 0;

	// we are looking to MY store only
    IEnroll * pXEnroll = GetEnrollObject();
    if (!pXEnroll){goto PrintCertDescList_Exit;}

    hStore = OpenMyStore(GetEnrollObject(), &hRes);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = NULL;

		// do not include certs with improper usage
		while (NULL != (pCert = CertEnumCertificatesInStore(hStore, pCert)))
		{
            _tprintf(_T("========================================\n"));
            if (TRUE == g_iDo_A)
            {
                AttachFriendlyName(pCert);
            }
            CheckCertConstraints(pCert);

			if (!ContainsKeyUsageProperty(pCert, &hRes))
			{
                _tprintf(_T("There is a key missing KeyUsage Property. skipping.\n"));
				if (SUCCEEDED(hRes) || hRes == CRYPT_E_NOT_FOUND)
					continue;
				else
					goto PrintCertDescList_ExitErr;
			}
			if (!PrintCertDescription(pCert))
			{
				if (hRes == CRYPT_E_NOT_FOUND)
					continue;
				goto PrintCertDescList_ExitErr;
			}
		}
        _tprintf(_T("========================================\n"));
		bRes = TRUE;
PrintCertDescList_ExitErr:
		if (pCert != NULL){CertFreeCertificateContext(pCert);}
		CertCloseStore(hStore, 0);
	}
    else
    {
        _tprintf(_T("CertOpenStore failed\n"));
    }

PrintCertDescList_Exit:
	return bRes;
}


DWORD CheckCertConstraints(PCCERT_CONTEXT pCC)
{
    PCERT_EXTENSION pCExt;  // returned ext
    LPCSTR           pszObjId;         // Object identifier
    DWORD i;

    CERT_BASIC_CONSTRAINTS_INFO *pConstraints=NULL;
    CERT_BASIC_CONSTRAINTS2_INFO *p2Constraints=NULL;
    DWORD ConstraintSize=0;
    DWORD RV=ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR;
    BOOL Using2=FALSE;

    void* ConstraintBlob=NULL;

    pszObjId = szOID_BASIC_CONSTRAINTS;

    pCExt = CertFindExtension(
        pszObjId,       // in, Pointer to object identifier
        pCC->pCertInfo->cExtension,    // in, # of extensions in the array
        pCC->pCertInfo->rgExtension);   // in, The array of attributes
    
    if (pCExt == NULL) {
        pszObjId = szOID_BASIC_CONSTRAINTS2;

        pCExt = CertFindExtension(
            pszObjId,       // in, Pointer to object identifier
            pCC->pCertInfo->cExtension,    // in, # of extensions in the array
            pCC->pCertInfo->rgExtension);   // in, The array of attributes
        Using2=TRUE;
    }
    
    if (pCExt == NULL) {
        _tprintf(_T("No BasicConstraints in cert\n"));
        goto ret;
    }

    // Decode extension
    if (!CryptDecodeObject(
        X509_ASN_ENCODING,  
        pCExt->pszObjId, 
        pCExt->Value.pbData,  
        pCExt->Value.cbData,  
        0,
        NULL,
        &ConstraintSize)) {

        _tprintf(_T("Error %d when Decoding extension\n"),GetLastError());
        goto ret;
        
    }

    ConstraintBlob=malloc(ConstraintSize);
    if (ConstraintBlob == NULL) 
    {
        _tprintf(_T("out of memory!!!!...\n"));
        goto ret;
    }

    if (!CryptDecodeObject(
        X509_ASN_ENCODING,  
        pCExt->pszObjId, 
        pCExt->Value.pbData,  
        pCExt->Value.cbData,  
        0,         
        (void*)ConstraintBlob,
        &ConstraintSize)) 
    {
        _tprintf(_T("Error %d when Decoding extension\n"),GetLastError());
       goto ret;
        
    }

    if (Using2) 
    {
        _tprintf(_T("Using2....\n"));

        p2Constraints=(CERT_BASIC_CONSTRAINTS2_INFO*)ConstraintBlob;
        if (!p2Constraints->fCA) 
        {
            _tprintf(_T("Yes, there is constraints in here! it's not a CA!\n"));
            RV=ERROR_SUCCESS;
        }
        else
        {
            _tprintf(_T("Yes, there is constraints in here! it's a CA!\n"));
        }
    }
    else 
    {
        _tprintf(_T("!Using2....\n"));
        pConstraints=(CERT_BASIC_CONSTRAINTS_INFO*)ConstraintBlob;
        if (((pConstraints->SubjectType.cbData * 8) - pConstraints->SubjectType.cUnusedBits) >= 2) 
        {
            if ((*pConstraints->SubjectType.pbData) & CERT_END_ENTITY_SUBJECT_FLAG) 
            {
                _tprintf(_T("Yes, there is constraints in here! CERT_END_ENTITY_SUBJECT_FLAG = true!\n"));

                RV=ERROR_SUCCESS;
            }
            else
            {
                _tprintf(_T("Yes, there is constraints in here but CERT_END_ENTITY_SUBJECT_FLAG = false!\n"));
            }

        }
    }
        
ret:

    free(ConstraintBlob);
    return (RV);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\certlook\utils.cpp ===
#include "utils.h"
#include <wincrypt.h>

//***************************************************************************
//*                                                                         
//* purpose: 
//*
//***************************************************************************
LPSTR StripWhitespace( LPSTR pszString )
{
    LPSTR pszTemp = NULL;

    if ( pszString == NULL ) 
    {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) 
    {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) 
    {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenA(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) 
    {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}


//***************************************************************************
//*                                                                         
//* purpose: return back a Alocated wide string from a ansi string
//*          caller must free the returned back pointer with GlobalFree()
//*
//***************************************************************************
LPWSTR MakeWideStrFromAnsi(UINT uiCodePage, LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    // make sure they gave us something
    if (!psz)
    {
        return NULL;
    }

    // compute the length
    i =  MultiByteToWideChar(uiCodePage, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate memory in that length
    pwsz = (LPWSTR) GlobalAlloc(GPTR,i * sizeof(WCHAR));
    if (!pwsz) return NULL;

    // clear out memory
    memset(pwsz, 0, wcslen(pwsz) * sizeof(WCHAR));

    // convert the ansi string into unicode
    i =  MultiByteToWideChar(uiCodePage, 0, (LPSTR) psz, -1, pwsz, i);
    if (i <= 0) 
        {
        GlobalFree(pwsz);
        pwsz = NULL;
        return NULL;
        }

    // make sure ends with null
    pwsz[i - 1] = 0;

    // return the pointer
    return pwsz;
}


BOOL IsFileExist(LPCTSTR szFile)
{
    // Check if the file has expandable Environment strings
    LPTSTR pch = NULL;
    pch = _tcschr( (LPTSTR) szFile, _T('%'));
    if (pch) 
    {
        TCHAR szValue[_MAX_PATH];
        _tcscpy(szValue,szFile);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szFile, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szFile);}

        return (GetFileAttributes(szValue) != 0xFFFFFFFF);
    }
    else
    {
        return (GetFileAttributes(szFile) != 0xFFFFFFFF);
    }
}


void AddPath(LPTSTR szPath, LPCTSTR szName )
{
	LPTSTR p = szPath;

    // Find end of the string
    while (*p){p = _tcsinc(p);}
	
	// If no trailing backslash then add one
    if (*(_tcsdec(szPath, p)) != _T('\\'))
		{_tcscat(szPath, _T("\\"));}
	
	// if there are spaces precluding szName, then skip
    while ( *szName == ' ' ) szName = _tcsinc(szName);;

	// Add new name to existing path string
	_tcscat(szPath, szName);
}

void DoExpandEnvironmentStrings(LPTSTR szFile)
{
    TCHAR szValue[_MAX_PATH];
    _tcscpy(szValue,szFile);
    // Check if the file has expandable Environment strings
    LPTSTR pch = NULL;
    pch = _tcschr( (LPTSTR) szFile, _T('%'));
    if (pch) 
    {
        if (!ExpandEnvironmentStrings( (LPCTSTR)szFile, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {
            _tcscpy(szValue,szFile);
            }
    }
    _tcscpy(szFile,szValue);
    return;
}



// return -1 for error
// return 0 for not exportable
// reutrn 1 for exportable
#define PRIVATE_KEY_ERROR          -1
#define PRIVATE_KEY_NOT_EXPORTABLE 0
#define PRIVATE_KEY_EXPORTABLE     1
DWORD CheckPrivateKeyStatus(PCCERT_CONTEXT pCertContextRequest)
{
    HCRYPTPROV  hCryptProv = NULL;
    DWORD       dwKeySpec = 0;
    BOOL        fCallerFreeProv = FALSE;
    BOOL        dwRet = PRIVATE_KEY_ERROR;
    HCRYPTKEY   hKey = NULL;
    DWORD       dwPermissions = 0;
    DWORD       dwSize = 0;

    //
    // first get the private key context
    //
    if (!CryptAcquireCertificatePrivateKey(
            pCertContextRequest,
            CRYPT_ACQUIRE_USE_PROV_INFO_FLAG | CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
            NULL,
            &hCryptProv,
            &dwKeySpec,
            &fCallerFreeProv))
    {
        DWORD dw = GetLastError();
        dwRet = PRIVATE_KEY_ERROR;
        goto ErrorReturn;
    }

    //
    // get the handle to the key
    //
    if (!CryptGetUserKey(hCryptProv, dwKeySpec, &hKey))
    {
        dwRet = PRIVATE_KEY_ERROR;
        goto ErrorReturn;
    }

    //
    // finally, get the permissions on the key and check if it is exportable
    //
    dwSize = sizeof(dwPermissions);
    if (!CryptGetKeyParam(hKey, KP_PERMISSIONS, (PBYTE)&dwPermissions, &dwSize, 0))
    {
        goto ErrorReturn;
    }

    dwRet = (dwPermissions & CRYPT_EXPORT) ? PRIVATE_KEY_EXPORTABLE : PRIVATE_KEY_NOT_EXPORTABLE;

CleanUp:

    if (hKey != NULL)
    {
        CryptDestroyKey(hKey);
    }

    if (fCallerFreeProv)
    {
        CryptReleaseContext(hCryptProv, 0);
    }

    return dwRet;

ErrorReturn:
    goto CleanUp;
}


HRESULT AttachFriendlyName(PCCERT_CONTEXT pContext)
{
	CRYPT_DATA_BLOB blob_name;
    WCHAR szName[200];
    wcscpy(szName,L"TestingName\0\0");

	blob_name.pbData = (LPBYTE)(LPCWSTR) szName;
	blob_name.cbData = (wcslen(szName)+1) * sizeof(WCHAR);

	if (!CertSetCertificateContextProperty(pContext,CERT_FRIENDLY_NAME_PROP_ID, 0, &blob_name))
	{
        _tprintf(_T("AttachFriendlyName: FAILED\n"));
		return HRESULT_FROM_WIN32(GetLastError());
	}
    else
    {
        _tprintf(_T("AttachFriendlyName: SUCCEEDED!!!\n"));
    }

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\chkpass\other.h ===
BOOL IsUserExist(LPWSTR strUsername);
BOOL ValidatePassword(IN LPCWSTR UserName,IN LPCWSTR Domain,IN LPCWSTR Password);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\chkpass\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_INTERNET_EXPLORER_GROUP     1
#define IDS_INTERNET_EXPLORER_GROUP_PWS_LINK 2

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\certlook\utils.h ===
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <setupapi.h>
#include <wincrypt.h>


LPSTR   StripWhitespace(LPSTR pszString);
LPWSTR  MakeWideStrFromAnsi(UINT uiCodePage, LPSTR psz);
BOOL    IsFileExist(LPCTSTR szFile);
void    AddPath(LPTSTR szPath, LPCTSTR szName);
int     DoesThisSectionExist(IN HINF hFile, IN LPCTSTR szTheSection);
void    DoExpandEnvironmentStrings(LPTSTR szFile);
HRESULT AttachFriendlyName(PCCERT_CONTEXT pContext);

#define DEBUG_FLAG

#ifdef DEBUG_FLAG
    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
	    int nBuf;
	    TCHAR szBuffer[512];
	    va_list args;
	    va_start(args, lpszFormat);

	    nBuf = _vsntprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	    //ASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	    OutputDebugString(szBuffer);
	    va_end(args);
    }
#else
    inline void _cdecl DebugTrace(LPTSTR , ...){}
#endif

#define IISDebugOutput DebugTrace
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\dirminus\dirminus.cpp ===
/****************************************************************************
* Author:   Aaron Lee
* Purpose:  do a directory minus a bunch of other directories
******************************************************************************/
#include <direct.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <string.h>
#include <windows.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <iostream.h>
#include <fstream.h>
#include <winbase.h>
#include "filefind.h"

#define MAX_ARRAY_SIZE  5000
#define ALL_FILES       0xff


struct arrayrow
{
    long total;
    long nextuse;
} GlobalMinusArrayIndex, GlobalFileInputMinusListIndex;
char GlobalMinusArray[MAX_ARRAY_SIZE][_MAX_FNAME];
char GlobalFileInputMinusList[MAX_ARRAY_SIZE][_MAX_FNAME];

// Globals
char  g_szinput_filename_full[_MAX_PATH];
char  g_szinput_filename[_MAX_FNAME];

// prototypes
int  __cdecl main(int ,char *argv[]);
void Do_Process(void);
void aFileToMinus(char * TheFileToMinus);
int  GlobalMinusArray_Add(char * FileNameToAdd);
void GlobalMinusArray_Fill(void);
void GlobalMinusArray_Print(void);
int  GlobalMinusArray_Check(char * FileNameToCheck);
void ShowHelp(void);

//-------------------------------------------------------------------
//  purpose: main
//-------------------------------------------------------------------
int __cdecl main(int argc,char *argv[])
{
    int argno = 0;
    int nflags = 0;
    char filename_dir[_MAX_PATH];
    char filename_only[_MAX_FNAME];
    char filename_ext[_MAX_EXT];

    filename_only[0]='\0';

    // process command line arguments
    for(argno=1; argno<argc; argno++)
        {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' )
            {
            nflags++;
            switch (argv[argno][1])
                {
                case 'm':
					aFileToMinus(&argv[argno][2]);
                    break;
                case '?':
                    goto exit_with_help;
                    break;
                }
            } // if switch character found
        else
            {
            if ( *filename_only == '\0' )
                {
                // if no arguments, then
                // get the filename_dir and put it into
                strcpy(g_szinput_filename_full, argv[argno]);
                filename_dir[0] = '\0';
                // split up this path
                _splitpath( g_szinput_filename_full, NULL, filename_dir, filename_only, filename_ext);

                strcat(filename_only, filename_ext);
				strcpy(g_szinput_filename,filename_only);
                // if we're missing dir, then get it.
                if (*filename_dir == '\0')
                    {
                    // Get current directory
                    TCHAR szCurrentDir[_MAX_PATH];
                    GetCurrentDirectory( _MAX_PATH, szCurrentDir);
                    // stick it into our variable
                    strcpy(filename_dir, szCurrentDir);
                    strcpy(g_szinput_filename_full, szCurrentDir);
                    strcat(g_szinput_filename_full, "\\");
                    strcat(g_szinput_filename_full, filename_only);
                    }
                }
            else
                {
                // Additional filenames (or arguments without a "-" or "/" preceding)
                //goto exit_with_help;
                // should be the section to execute.
                }
            } // non-switch char found
        } // for all arguments

    if ( *filename_only == '\0')
        {
        printf("Too few arguments, argc=%d\n\n",argc);
        goto exit_with_help;
        }

    // run the function to do everything
    Do_Process();

    return TRUE;

exit_with_help:
    ShowHelp();
    return FALSE;

}

void aFileToMinus(char * TheFileToMinus)
{
	// blankout the array values if any.
	GlobalFileInputMinusList[GlobalFileInputMinusListIndex.nextuse][0]= '\0';
    // move info into global array
    strcpy(GlobalFileInputMinusList[GlobalFileInputMinusListIndex.nextuse],TheFileToMinus);
    // increment counter to array
    // increment next use space
    ++GlobalFileInputMinusListIndex.total;
    ++GlobalFileInputMinusListIndex.nextuse;
	return;
}

void ShowHelp()
{
    printf("\n");
    printf("DirMinus - does a dir minus other files\n");
    printf("----------------------------------------\n");
    printf("   Usage: Dir *.* -m*.cab -mFilename.exe\n");
	printf("----------------------------------------\n");
    return;
}

void Do_Process(void)
{
	// Get stuff that we want to minus out into a huge array
	GlobalMinusArray_Fill();
	//GlobalMinusArray_Print();

	// Ok now, loop thru the directory and lookup each entry
	// in our globalminusarray, if it's there, then don't print it out!
    int  attr;
    char filename_dir[_MAX_PATH];
    char filename_only[_MAX_FNAME];
    long hFile;
    finddata datareturn;

	if (!(g_szinput_filename)) {return;}

	// Get the filename portion
	_splitpath( g_szinput_filename, NULL, filename_dir, filename_only, NULL);
	attr= 0;
	if (strcmp(filename_only, "*.*") == 0)
		{attr=ALL_FILES;}

	InitStringTable(STRING_TABLE_SIZE);
	if ( FindFirst(g_szinput_filename, attr, &hFile, &datareturn) )
	{
		// check if it's a sub dir
		if (!( datareturn.attrib & _A_SUBDIR))
		{
			// is This Entry in our minus list?
			if (GlobalMinusArray_Check(datareturn.name) == FALSE)
			{
				// print it out
				printf(datareturn.name);
				printf ("\n");
			}
		}

		while(FindNext(attr, hFile, &datareturn))
		{
		// check if it's a sub dir
		if (!(datareturn.attrib & _A_SUBDIR))
			// is This Entry in our minus list?
			if (GlobalMinusArray_Check(datareturn.name) == FALSE)
			{
				// print it out
				printf(datareturn.name);
				printf ("\n");
			}
		}

	} // we didn't find the specified file.

	EndStringTable();
	return;
}

void GlobalMinusArray_Fill(void)
{
	int  outerindex;
    int  attr;
    char filename_dir[_MAX_PATH];
    char filename_only[_MAX_FNAME];
    long hFile;
    finddata datareturn;


    if (!(GlobalFileInputMinusList[0][0])) {return;}
   
    for( outerindex = 0; outerindex < GlobalFileInputMinusListIndex.total;outerindex++)
    {
		
		// Get the filename portion
		_splitpath( GlobalFileInputMinusList[outerindex], NULL, filename_dir, filename_only, NULL);
		attr= 0;
		if (strcmp(filename_only, "*.*") == 0)
			{attr=ALL_FILES;}

		InitStringTable(STRING_TABLE_SIZE);
		if ( FindFirst(GlobalFileInputMinusList[outerindex], attr, &hFile, &datareturn) )
			{
			// check if it's a sub dir
			if (!( datareturn.attrib & _A_SUBDIR))
				{
					// ok we found one.
					// now take this entry and try to add it to the global array!!!
					GlobalMinusArray_Add(datareturn.name);
				}

			while(FindNext(attr, hFile, &datareturn))
				{
				// check if it's a sub dir
				if (!(datareturn.attrib & _A_SUBDIR))
					{
					// ok we found one.
					// now take this entry and try to add it to the global array!!!
					GlobalMinusArray_Add(datareturn.name);
					}
				}

			} // we didn't find the specified file.
	}

    EndStringTable();
}

int GlobalMinusArray_Add(char * FileNameToAdd)
{
    // blankout the array values if any.
    GlobalMinusArray[GlobalMinusArrayIndex.nextuse][0] = '\0';
    // move info into global array
    strcpy(GlobalMinusArray[GlobalMinusArrayIndex.nextuse],FileNameToAdd);
    // increment counter to array
    // increment next use space
    ++GlobalMinusArrayIndex.total;
    ++GlobalMinusArrayIndex.nextuse;
    return TRUE;
}

void GlobalMinusArray_Print(void)
{
    int  i0;
    for( i0 = 0; i0 < GlobalMinusArrayIndex.total;i0++)
        {
		printf("-");
		printf(GlobalMinusArray[i0]);
        printf("\n");
        }
    return;
}

int GlobalMinusArray_Check(char * FileNameToCheck)
{
	int  i0;
    for( i0 = 0; i0 < GlobalMinusArrayIndex.total;i0++)
        {
		if (_stricmp(GlobalMinusArray[i0], FileNameToCheck) == 0)
			{return TRUE;}
        }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\chkpass\main.cpp ===
#include <stdio.h>
#include <fstream.h>
#include <windows.h>
#include <winver.h>
#include <tchar.h>
#include <ole2.h>
#include <shlobj.h>
#include "other.h"

#define UNICODE
#define _UNICODE

#define DEBUGTEMP

//
// prototypes...
//
int  __cdecl main(int ,char *argv[]);
void ShowHelp(void);
LPSTR StripWhitespace(LPSTR pszString);

BOOL DoStuff1(WCHAR *szUserName,WCHAR *szUserDomain,WCHAR *szUserPass);


//
// Globals
//
int g_Flag_u = FALSE;
int g_Flag_d = FALSE;
int g_Flag_p = FALSE;

WCHAR g_wszUserName[50];
WCHAR g_wszUserDomain[50];
WCHAR g_wszUserPass[50];


//-------------------------------------------------------------------
//  purpose: main
//-------------------------------------------------------------------
int __cdecl main(int argc,char *argv[])
{
	LPSTR pArg = NULL;
	LPSTR pCmdStart = NULL;

    int argno;
    int nflags=0;
	char szTempFileName[MAX_PATH];
	char szTempString[MAX_PATH];
	szTempFileName[0] = '\0';

    // process command line arguments
    for(argno=1; argno<argc; argno++)
        {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' )
            {
            nflags++;
            switch (argv[argno][1])
                {
                case 'u':
				case 'U':
					g_Flag_u = TRUE;

					// Get the string for this flag
					pArg = CharNext(argv[argno]);
					pArg = CharNext(pArg);
					if (*pArg == ':')
					{
						pArg = CharNext(pArg);

						// Check if it's quoted
						if (*pArg == '\"')
						{
							pArg = CharNext(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNext(pArg);}
						}
						else
						{
							pCmdStart = pArg;
							// while ((*pArg) && (*pArg != '/') && (*pArg != '-')){pArg = CharNext(pArg);}
							while (*pArg){pArg = CharNext(pArg);}
						}
						*pArg = '\0';
						lstrcpy(szTempString, StripWhitespace(pCmdStart));
						#ifdef DEBUGTEMP
						printf(szTempString); printf("\n");
						#endif

						// Convert to unicode
						// And assign it to the global.
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) g_wszUserName, 50);
					}
					break;
                case 'd':
				case 'D':
					g_Flag_d = TRUE;
					// Get the string for this flag
					pArg = CharNext(argv[argno]);
					pArg = CharNext(pArg);
					if (*pArg == ':')
					{
						pArg = CharNext(pArg);
						// Check if it's quoted
						if (*pArg == '\"')
						{
							pArg = CharNext(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNext(pArg);}
						}
						else
						{
							pCmdStart = pArg;
							// while ((*pArg) && (*pArg != '/') && (*pArg != '-')){pArg = CharNext(pArg);}
							while (*pArg){pArg = CharNext(pArg);}
						}
						*pArg = '\0';
						lstrcpy(szTempString, StripWhitespace(pCmdStart));
						#ifdef DEBUGTEMP
						printf(szTempString); printf("\n");
						#endif

						// Convert to unicode
						// And assign it to the global.
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) g_wszUserDomain, 50);
					}
                    break;
                case 'p':
				case 'P':
					g_Flag_p = TRUE;
					// Get the string for this flag
					pArg = CharNext(argv[argno]);
					pArg = CharNext(pArg);
					if (*pArg == ':')
					{
						pArg = CharNext(pArg);
						// Check if it's quoted
						if (*pArg == '\"')
						{
							pArg = CharNext(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNext(pArg);}
						}
						else
						{
							pCmdStart = pArg;
							// while ((*pArg) && (*pArg != '/') && (*pArg != '-')){pArg = CharNext(pArg);}
							while (*pArg){pArg = CharNext(pArg);}
						}
						*pArg = '\0';
						lstrcpy(szTempString, StripWhitespace(pCmdStart));
						#ifdef DEBUGTEMP
						printf(szTempString); printf("\n");
						#endif

						// Convert to unicode
						// And assign it to the global.
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) g_wszUserPass, 50);
					}
                    break;
                case '?':
                    goto main_exit_with_help;
                    break;
                }
            } // if switch character found
        else
            {
            if ( *szTempFileName == '\0' )
                {
                // if no arguments, then
                // get the ini_filename_dir and put it into
                strcpy(szTempFileName, argv[argno]);
                }
            } // non-switch char found
        } // for all arguments


	if (FALSE == DoStuff1(g_wszUserName,g_wszUserDomain,g_wszUserPass))
		{goto main_exit_with_help;}

	goto main_exit_gracefully;
	
main_exit_gracefully:
    printf("Done.\n");
    return TRUE;

main_exit_with_help:
    ShowHelp();
    return FALSE;
}


void ShowHelp()
{
	char szModuleName[_MAX_PATH];
	char szFilename_only[_MAX_FNAME];
	char szMyString[_MAX_PATH + _MAX_PATH];
	GetModuleFileName(NULL, szModuleName, _MAX_PATH);

	// Trim off the filename only.
	_tsplitpath(szModuleName, NULL, NULL, szFilename_only, NULL);

	sprintf(szMyString, "\n%s - Checks if password is valid for given Username\\Domain\\Password\n", szFilename_only);
	printf(szMyString);
	sprintf(szMyString, "------------------------------------------------------------------------\n", szFilename_only);
	printf(szMyString);
	sprintf(szMyString, "Usage: %s -u:(username) -d:(domain) -p:(password) \n", szFilename_only);
	printf(szMyString);
	sprintf(szMyString, "Example: %s -u:aaronl -d:redmond -p:mypassword \n", szFilename_only);
	printf(szMyString);
	sprintf(szMyString, "Hint: Special characters like a quotation mark in the password, \n");
	printf(szMyString);
	sprintf(szMyString, "should be designated like: %s -u:(username) -d:(domain) -p:Mr\\\"Weekend\\\" \n", szFilename_only);
	printf(szMyString);

    return;
}


//***************************************************************************
//*                                                                         *
//* NAME:       StripWhitespace                                             *
//*                                                                         *
//* SYNOPSIS:   Strips spaces and tabs from both sides of given string.     *
//*                                                                         *
//***************************************************************************
LPSTR StripWhitespace( LPSTR pszString )
{
    LPSTR pszTemp = NULL;

    if ( pszString == NULL ) {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlen(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}


//-------------------------------------------------------------------
//  purpose: misc
//-------------------------------------------------------------------
BOOL DoStuff1(WCHAR *szUserName,WCHAR *szUserDomain,WCHAR *szUserPass)
{
	BOOL bReturn = FALSE;
	char szMyString[_MAX_PATH + _MAX_PATH];
	char szTempString1[100];
	char szTempString2[100];
	char szTempString3[100];
	LPCWSTR lpszUserName = szUserName;
	LPCWSTR lpszUserDomain = szUserDomain;
	LPCWSTR lpszUserPass = szUserPass;

	// check if any of the fields are blank...
	if (!szUserName) {goto DoStuff1_Exit_BlankUser;}
	if (_wcsicmp(szUserName,L"") == 0) {goto DoStuff1_Exit_BlankUser;}

	WideCharToMultiByte( CP_ACP, 0, (WCHAR *)szUserName, -1, szTempString1, 100, NULL, NULL );
	WideCharToMultiByte( CP_ACP, 0, (WCHAR *)szUserDomain, -1, szTempString2, 100, NULL, NULL );
	WideCharToMultiByte( CP_ACP, 0, (WCHAR *)szUserPass, -1, szTempString3, 100, NULL, NULL );
	sprintf(szMyString, "Validating:User=%s,Domain=%s,Password=%s\n",szTempString1,szTempString2,szTempString3);
	printf(szMyString);

	if (TRUE == ValidatePassword(lpszUserName, lpszUserDomain, lpszUserPass)) 
		{
		printf("Yes!  Password is valid.\n");
		bReturn = TRUE;
		}
	else
		{printf("No!  Password is not valid.\n");}

DoStuff1_Exit:
	return bReturn;

DoStuff1_Exit_BlankUser:
	sprintf(szMyString, "Error: Missing required parameter. User Name is empty.\n");
	printf(szMyString);
	goto DoStuff1_Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\copyfile\makefile.inc ===
iCPU=$(PROCESSOR_ARCHITECTURE)
!IF "$(iCPU)"=="x86"
iCPU=I386
!ENDIF

!IF "$(PROCESSOR_ARCHITECTURE)"!="MIPS"
!IF "$(PROCESSOR_ARCHITECTURE)"!="PPC"

CDROOT=$(_NTTREE)\inetsrv\Dump

copyfile:
	if not exist "$(CDROOT)" mkdir $(CDROOT)
# 	xcopy /d $(iCPU)\*.*           $(CDROOT)
	xcopy /d *.exe            $(CDROOT)
!ENDIF
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\chkpass\other.cpp ===
#include <stdio.h>
#include <windows.h>
#include <winver.h>
#include <tchar.h>
#include <ole2.h>
#include <shlobj.h>

#include <winnt.h>
#include <subauth.h>

#include <lmaccess.h>
#include <lmserver.h>
#include <lmapibuf.h>
#include <lmerr.h>

#include <basetsd.h>

#define SECURITY_WIN32
#define ISSP_LEVEL  32
#define ISSP_MODE   1
#include <sspi.h>

#include "other.h"

//#ifdef UNICODE
BOOL ValidatePassword(IN LPCWSTR UserName,IN LPCWSTR Domain,IN LPCWSTR Password)
/*++

Routine Description:

    Uses SSPI to validate the specified password

Arguments:

    UserName - Supplies the user name

    Domain - Supplies the user's domain

    Password - Supplies the password

Return Value:

    TRUE if the password is valid.

    FALSE otherwise.

--*/
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle ClientCredHandle;
    CredHandle ServerCredHandle;
    BOOL ClientCredAllocated = FALSE;
    BOOL ServerCredAllocated = FALSE;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    PSecPkgInfo PackageInfo = NULL;
    ULONG ClientFlags;
    ULONG ServerFlags;
    TCHAR TargetName[100];
    SEC_WINNT_AUTH_IDENTITY_W AuthIdentity;
    BOOL Validated = FALSE;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    AuthIdentity.User = (LPWSTR)UserName;
    AuthIdentity.UserLength = lstrlenW(UserName);
    AuthIdentity.Domain = (LPWSTR)Domain;
    AuthIdentity.DomainLength = lstrlenW(Domain);
    AuthIdentity.Password = (LPWSTR)Password;
    AuthIdentity.PasswordLength = lstrlenW(Password);
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( _T("NTLM"), &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }

    //
    // Acquire a credential handle for the server side
    //
    SecStatus = AcquireCredentialsHandle(
                    NULL,
                    _T("NTLM"),
                    SECPKG_CRED_INBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ServerCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ServerCredAllocated = TRUE;

    //
    // Acquire a credential handle for the client side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    _T("NTLM"),
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ClientCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ClientCredAllocated = TRUE;

    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        goto error_exit;
    }

    ClientFlags = ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT;

    InitStatus = InitializeSecurityContext(
                    &ClientCredHandle,
                    NULL,               // No Client context yet
                    NULL,
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( !NT_SUCCESS(InitStatus) ) {
        goto error_exit;
    }

    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        goto error_exit;
    }
    ServerFlags = ASC_REQ_EXTENDED_ERROR;

    AcceptStatus = AcceptSecurityContext(
                    &ServerCredHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( !NT_SUCCESS(AcceptStatus) ) {
        goto error_exit;
    }

    if (InitStatus != STATUS_SUCCESS)
    {

        //
        // Get the AuthenticateMessage (ClientSide)
        //

        ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
        AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
        if ( AuthenticateBuffer.pvBuffer == NULL ) {
            goto error_exit;
        }

        SecStatus = InitializeSecurityContext(
                        NULL,
                        &ClientContextHandle,
                        TargetName,
                        0,
                        0,                      // Reserved 1
                        SECURITY_NATIVE_DREP,
                        &ChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &AuthenticateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ( !NT_SUCCESS(SecStatus) ) {
            goto error_exit;
        }

        if (AcceptStatus != STATUS_SUCCESS) {

            //
            // Finally authenticate the user (ServerSide)
            //

            AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

            SecStatus = AcceptSecurityContext(
                            NULL,
                            &ServerContextHandle,
                            &AuthenticateDesc,
                            ServerFlags,
                            SECURITY_NATIVE_DREP,
                            &ServerContextHandle,
                            NULL,
                            &ContextAttributes,
                            &Lifetime );

            if ( !NT_SUCCESS(SecStatus) ) {
                goto error_exit;
            }
            Validated = TRUE;

        }

    }

error_exit:
    if (ServerCredAllocated) {
        FreeCredentialsHandle( &ServerCredHandle );
    }
    if (ClientCredAllocated) {
        FreeCredentialsHandle( &ClientCredHandle );
    }

    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
    return(Validated);
}
//#endif

BOOL IsUserExist(LPWSTR strUsername)
{
    BYTE *pBuffer;
    INT err = NERR_Success;
  
    do
    {
        const unsigned short *pMachineName = NULL;
        
        //  make sure we are not backup docmain first
        if (( err = NetServerGetInfo( NULL, 101, &pBuffer )) != NERR_Success )
        {
            printf("NetServerGetInfo:failed.Do not call this on PDC or BDC takes too long.This must be a PDC or BDC.");
            break;
        }

		//
		// Check if domain controller or backup domain controller
		//
		LPSERVER_INFO_101 pInfo = (LPSERVER_INFO_101)pBuffer;
		if (( pInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL ) != 0 )
		{
			printf("Backupdomaincontroller.NetGetDCName.start.");
			NetGetDCName( NULL, NULL, (LPBYTE*)&pMachineName );
			printf((char*) pMachineName);
			printf("NetGetDCName.end.");
		}
		else
		{
			if (( pInfo->sv101_type & SV_TYPE_DOMAIN_CTRL ) != 0 )
			{
				printf("Domaincontroller.NetGetDCName.start.");
				NetGetDCName( NULL, NULL, (LPBYTE*)&pMachineName );
				printf((char*) pMachineName);
				printf("NetGetDCName.end.");
			}
		}

        NetApiBufferFree( pBuffer );

		// old for testing
		/*
		char buf[ CNLEN + 10 ];
		DWORD dwLen = CNLEN + 10;
		if ( GetComputerName( buf, &dwLen ))
			{
			printf((char*) buf);
			pMachineName = (const unsigned short *) buf;
			printf((char*) buf);
			}
		*/

        if (pMachineName)
		{
			printf("MachineName="); printf((char*) pMachineName);
			printf("Username="); //printf((char*) strUsername);
		}
        else
		{
			printf("MachineName=(null)");
			printf("Username="); //printf((char*) strUsername);
		}
       
		printf("\n");
        err = NetUserGetInfo( pMachineName, strUsername, 3, &pBuffer );
		char szTheError[255];
		sprintf(szTheError, "TheErrCode=0x%x\n",err);
		printf(szTheError);
		if (err == ERROR_ACCESS_DENIED)
		{
			printf("ERROR_ACCESS_DENIED.The user does not have access to the requested information. \n");
			printf("\n");
		}
		if (err == NERR_InvalidComputer)
		{
			printf("ERROR_ACCESS_DENIED.The computer name is invalid.\n");
			printf("\n");
		}
		if (err == NERR_UserNotFound)
		{
			printf("NERR_UserNotFound.The user name could not be found.\n");
			printf("\n");
		}

        //if (pMachineName){iisDebugOut((_T("NetUserGetInfo:[%s\\%s].End.Ret=0x%x.\n"),pMachineName,strUsername,err));}
        //else{iisDebugOut((_T("NetUserGetInfo:[(null)\\%s].End.\n"),strUsername));}

        if ( err == NERR_Success ){NetApiBufferFree( pBuffer );}
        if ( pMachineName != NULL ){NetApiBufferFree( (void*) pMachineName );}

    } while (FALSE);

	if (err == NERR_Success )
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}

}



void DoStuff99(LPCTSTR lpUserName)
{
	//printf("DoStuff99.Start.\n");
	WCHAR wchUsername[UNLEN+1];

    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lpUserName, -1, (LPWSTR)wchUsername, UNLEN);

	//if (TRUE == IsUserExist((const unsigned short *) lpUserName))
	if (TRUE == IsUserExist(wchUsername))
	{
		printf("IsUserExist.TRUE.\n");
	}
	else
	{
		printf("IsUserExist.FAILED.\n");
	}

	//printf("DoStuff99.End.\n");
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\dirminus\filefind.cpp ===
/********************************************************************************
* Description:
*	 Functions that do what _dos_findfirst and _dos_findnext SHOULD do
*******************************************************************************/
#include <io.h>
#include <string.h>
#include <malloc.h>
#include "filefind.h"

static char * StringTable;
static long offset = 0 ;
static long MaxOffset;


int InitStringTable(long size)
{
	StringTable=(char *) malloc(size);
    ResetStringTable();
	return StringTable != 0;
}

void EndStringTable()
{
	if (StringTable)
		free (StringTable);

}

void AddString (char * StringToAdd, finddata * s)
{
	int len;

	len=strlen(StringToAdd);
	
   	strcpy(StringTable+offset, StringToAdd);
	s->name=StringTable+offset;
	offset+=len+1;
	if (len>12) {
		strcpy(StringTable+offset, StringToAdd);
		StringTable[offset+11]='~';
		StringTable[offset+12]='\0';
		s->ShortName=StringTable+offset;
		offset+=13;
	}
	else
		s->ShortName=s->name;
	
	MaxOffset= (offset > MaxOffset) ? offset : MaxOffset;
	
}

long GetStringTableSize()
{
	return MaxOffset;
}

void ResetStringTable()
{
	offset=0;
}

int
FindFirst(char * ss, unsigned attr, long * hFile, finddata * s)
{
	int         found;
	SysFindData s2;
	    
	*hFile=_findfirst(ss, &s2);
	found = (*hFile != -1L);
	if (found) {
		if ( attr == ALL_FILES ) {
			while(found && s2.name[0] == '.')
				found=(_findnext(*hFile, &s2) == 0);
		}
		else if ( attr & _A_SUBDIR )  {
			while(found && (((s2.attrib & _A_SUBDIR) == 0) || s2.name[0] == '.'))
				found=(_findnext(*hFile, &s2) == 0);
		}
		else  {
			while(found && (s2.attrib & _A_SUBDIR))
				found=(_findnext(*hFile, &s2) == 0);
		}
		if (!found)
			_findclose(*hFile);
		else {
			memcpy(s, &s2, sizeof(finddata));
			AddString(s2.name, s);
		}
    }
	return(found);
} /* FindFirst() */






int
FindNext(int attr, long hFile, finddata * s)
{
	int      found;
	SysFindData s2;

	 
	found=(_findnext(hFile, &s2) == 0);
	if (found  &&  attr != ALL_FILES) {
		if ( attr & _A_SUBDIR )	{
			while(found && (((s2.attrib & _A_SUBDIR) == 0) || s2.name[0] == '.'))
				found=(_findnext(hFile, &s2) == 0);
		}
		else {
			while(found && (s2.attrib & _A_SUBDIR))
				found=(_findnext(hFile, &s2) == 0);
		}
    }
	if (!found)
		_findclose(hFile);
	else {
		memcpy(s, &s2, sizeof(finddata));
		AddString(s2.name, s);
	}
	return(found);
} /* FindNext() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\dllhell\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1
#define IDS_STRING2                     2
#define IDS_STRING3                     3
#define IDS_STRING4                     4
#define IDS_STRING5                     5
#define IDS_STRING6                     6
#define IDS_STRING7                     7
#define IDS_STRING8                     8
#define IDS_STRING9                     9
#define IDS_STRING10                    10

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\dllhell\depends.cpp ===
#include <objbase.h>
#include <delayimp.h>
#include "depends.h"
#include "resource.h"

// stuff for finding out architecture type of a file
#define IMAGE_BASE_TO_DOS_HEADER(b) ((PIMAGE_DOS_HEADER)(b))
#define IMAGE_BASE_TO_NT_HEADERS(b) ((PIMAGE_NT_HEADERS)( (DWORD_PTR)(b) + ((PIMAGE_DOS_HEADER)(b))->e_lfanew ))
#define IMAGE_BASE_TO_FILE_HEADER(b) ((PIMAGE_FILE_HEADER)( &IMAGE_BASE_TO_NT_HEADERS(b)->FileHeader ))

//******************************************************************************
// CDepends :: Constructor/Destructor
//******************************************************************************
CDepends::CDepends() :
   m_hFile(NULL),
   m_lpvFile(NULL),
   m_pIFH(NULL),
   m_pIOH(NULL),
   m_pISH(NULL),
   m_fOutOfMemory(FALSE),
   m_fCircularError(FALSE),
   m_fMixedMachineError(FALSE),
   m_dwMachineType((DWORD)-1),
   m_pModuleRoot(NULL),
   m_cxOrdinal(0),
   m_cxHint(0),
   m_cImports(0),
   m_cExports(0)
{

}
//******************************************************************************
CDepends::~CDepends() {
}



//******************************************************************************
BOOL CDepends::SetInitialFilename(LPCSTR szPath) {

   // Set our current directory to the directory that the file is in. We need to
   // do this so our file search can find dependents that happen to be in the
   // same directory that our target file is in.
   //CString strDir(szPath);
   //strDir = strDir.Left(strDir.ReverseFind('\\') + 1);
   //SetCurrentDirectory(strDir);

   SetCurrentDirectory(szPath);
   
   // Create our root module node.
   if (m_pModuleRoot = CreateModule(szPath, 0)) 
   {
      // Start the recursion on the head module to process all modules.
      ProcessModule(m_pModuleRoot);
   }
   else 
   {
      m_fOutOfMemory = TRUE;
   }

   // If we ran out of memory while processing the module, then free our
   // document data, display an error, and fail the document from loading.
   // Out of memory is a fairly major error.  If this should occur, MFC will
   // most likely notice and report the problem before we do.
   if (m_fOutOfMemory) 
   {
      DeleteContents();
      //CString strError("Not enough memory to process \"");
      //strError += m_pModuleRoot->m_pData->m_szPath;
      //strError += "\"!";
      //MessageBox(strError, "Dependency Walker Error", MB_ICONERROR | MB_OK);
      return FALSE;
   }

   // Display a message if the module contains a circular dependency error.
   if (m_fCircularError) 
   {
      //CString strError("\"");
      //strError += m_pModuleRoot->m_pData->m_szPath;
      //strError += "\" will fail to load due to circular dependencies.";
      //g_pMainFrame->MessageBox(strError, "Dependency Walker Module Error",MB_ICONERROR | MB_OK);
   }

   // Display a message if the module contains a mixed machine error.
   if (m_fMixedMachineError) {
      //CString strError("\"");
      //strError += m_pModuleRoot->m_pData->m_szPath;
      //strError += "\" will fail to load due to a mismatched machine type with "
      //            "one or more of the dependent modules.";
      //g_pMainFrame->MessageBox(strError, "Dependency Walker Module Error", MB_ICONERROR | MB_OK);
   }

   return TRUE;
}

CModule* CDepends::LoopThruAndPrintLosers(CModule *pModuleCur) 
{
    //
    // loop thru the linked list and look for
    // items marked with m_fExportError
    //
   if (!pModuleCur) {
      return NULL;
   }

   // check to see if our current module is marked with m_fExportError
   // Check to see if our current module matches our search module.
   if (pModuleCur->m_fExportError == TRUE)
   {
        char szMyBigString[_MAX_PATH + 50];
        char szMyPrintString[_MAX_PATH + 50];
        MyLoadString(IDS_STRING7, szMyBigString);
        sprintf(szMyPrintString, szMyBigString,(LPSTR) pModuleCur->m_pData->m_szPath);
	    printf(szMyPrintString);

        // Convert the filename to unicode.
        //LPWSTR  pwszModuleName = NULL;
        //pwszModuleName = MakeWideStrFromAnsi( (LPSTR)(pModuleCur->m_pData->m_szPath) );
        //g_MyLogFile.PrintToLog(_T("  %s"), pwszModuleName);
        //if (pwszModuleName){CoTaskMemFree(pwszModuleName);}
   }

   if (pModuleCur->m_pData->m_fFileNotFound == TRUE)
   {
        char szMyBigString[_MAX_PATH + 50];
        char szMyPrintString[_MAX_PATH + 50];
        MyLoadString(IDS_STRING8, szMyBigString);
        sprintf(szMyPrintString, szMyBigString,(LPSTR) pModuleCur->m_pData->m_szPath);
	    printf(szMyPrintString);

        // Convert the filename to unicode.
        //LPWSTR  pwszModuleName = NULL;
        //pwszModuleName = MakeWideStrFromAnsi( (LPSTR)(pModuleCur->m_pData->m_szPath) );
        //g_MyLogFile.PrintToLog(_T("  %s"), pwszModuleName);
        //if (pwszModuleName){CoTaskMemFree(pwszModuleName);}
   }

   // Recurse into LoopThruAndPrintLosers() for each dependent module.
   pModuleCur = pModuleCur->m_pDependents;
   while (pModuleCur) 
   {
      CModule *pModuleFound = LoopThruAndPrintLosers(pModuleCur);
      if (pModuleFound) {
         return pModuleFound;
      }
      pModuleCur = pModuleCur->m_pNext;
   }

   return NULL;
}


void CDepends::DeleteContents() {

   // Delete all modules by recursing into DeleteModule() with our root module.
   if (m_pModuleRoot) {
      DeleteModule(m_pModuleRoot);
      m_pModuleRoot = NULL;
   }

   // Clear our memory error flag.
   m_fOutOfMemory = FALSE;

   // Clear our circular dependency error flag.
   m_fCircularError = FALSE;

   // Clear our mixed machine error flag.
   m_fMixedMachineError = FALSE;
   m_dwMachineType = (DWORD)-1;
}


//******************************************************************************
// CDepends :: Internal functions
//******************************************************************************

CModule* CDepends::CreateModule(LPCSTR szFile, int depth) {

   CHAR szPath[16384] = "", *pszFile = NULL;

   // Attempt to find the file in our search path.  This will mimic what the OS
   // loader does when looking for a module.  Our OnOpenDocument() function sets
   // the current directory to the module directory, so SearchPath() will first
   // look in the module directory.
   //SearchPath(NULL, szFile, NULL, sizeof(szPath), szPath, &pszFile);
   SearchPathA(NULL, szFile, NULL, sizeof(szPath), szPath, &pszFile);

   // If we don't have a path, then just copy the file name into our path string
   // and set the file pointer to the character following the last wack "\".
   if (!*szPath) {
      strcpy(szPath, szFile);
      LPSTR pszWack = strrchr(szPath, '\\');
      pszFile = (pszWack && *(pszWack + 1)) ? (pszWack + 1) : szPath;
   }

   // If our file name pointer is invalid, then just point it to our path.
   if (pszFile < szPath) {
      pszFile = szPath;
   }

   // Create a new CModule object
   CModule *pModule = new CModule();
   if (!pModule) {
      return NULL;
   }
   ZeroMemory(pModule, sizeof(CModule));

   // Store our module's depth for later recursion overflow checks.
   pModule->m_depth = depth;

   // Recurse our module tree to see if this module is a duplicate of another.
   pModule->m_pModuleOriginal = FindModule(m_pModuleRoot, szPath);

   // Check to see if a duplicate was found.
   if (pModule->m_pModuleOriginal) {

      // If the module is a duplicate, then just point our data field to the
      // original module's data field.
      pModule->m_pData = pModule->m_pModuleOriginal->m_pData;

   } else {

      // If this module is not a duplicate, then create a new CModuleData object.
      pModule->m_pData = (CModuleData*)new BYTE[sizeof(CModuleData) + strlen(szPath)];
      if (!pModule->m_pData) {
         delete pModule;
         return NULL;
      }

      // Clear the object, copy the path string to it, and set the file pointer.
      ZeroMemory(pModule->m_pData, sizeof(CModuleData));
      strcpy(pModule->m_pData->m_szPath, szPath);
      pModule->m_pData->m_szFile = pModule->m_pData->m_szPath + (pszFile - szPath);

      // For readability, make path lowercase and file uppercase.
      _strlwr(pModule->m_pData->m_szPath);
      _strupr(pModule->m_pData->m_szFile);
   }

   // Return our new module object.
   return pModule;
}

//******************************************************************************
CFunction* CDepends::CreateFunction(int ordinal, int hint, LPCSTR szName,
                                       DWORD_PTR dwAddress, LPCSTR szForward)
{
   // Create a CFunction object.
   CFunction *pFunction = (CFunction*)new BYTE[sizeof(CFunction) + strlen(szName)];
   if (!pFunction) {
      return NULL;
   }

   // Clear the function object and fill in its members.
   ZeroMemory(pFunction, sizeof(CFunction));
   strcpy(pFunction->m_szName, szName);
   pFunction->m_ordinal = ordinal;
   pFunction->m_hint = hint;
   pFunction->m_dwAddress = dwAddress;

   // If a forward string exists, then allocate a buffer and store a pointer to
   // it in our CFunction's m_dwExtra member.  See the CFunction class for more
   // info on m_dwExtra.
   if (szForward) {
      if (pFunction->m_dwExtra = (DWORD_PTR)new CHAR[strlen(szForward) + 1]) {
         strcpy((LPSTR)pFunction->m_dwExtra, szForward);
      } else {
         delete[] (BYTE*)pFunction;
         return NULL;
      }
   }

   // Return our new function object.
   return pFunction;
}

//******************************************************************************
void CDepends::DeleteModule(CModule *pModule) {

   // Recurse into DeleteModule() to delete all our dependent modules first.
   CModule *pModuleCur = pModule->m_pDependents;
   while (pModuleCur) {
      CModule *pModuleNext = pModuleCur->m_pNext;
      DeleteModule(pModuleCur);
      pModuleCur = pModuleNext;
   }

   // Delete all of our current module's parent import functions.
   CFunction *pFunctionCur = pModule->m_pParentImports;
   while (pFunctionCur) {
      CFunction *pFunctionNext = pFunctionCur->m_pNext;
      delete[] (BYTE*)pFunctionCur;
      pFunctionCur = pFunctionNext;
   }

   // If we are not marked as a duplicate, then free our CModuleData.
   if (!pModule->m_pModuleOriginal) {

      // Delete all of our current module's export functions.
      CFunction *pFunctionCur = pModule->m_pData->m_pExports;
      while (pFunctionCur) {

         // Delete our forward string if we allocated one.
         if (pFunctionCur->GetForwardString()) {
            delete[] (CHAR*)pFunctionCur->GetForwardString();
         }

         // Delete the export node itself.
         CFunction *pFunctionNext = pFunctionCur->m_pNext;
         delete[] (BYTE*)pFunctionCur;
         pFunctionCur = pFunctionNext;
      }

      // Delete any error string that may have been allocated.
      if (pModule->m_pData->m_pszError) {
         delete[] (CHAR*)pModule->m_pData->m_pszError;
      }

      // Delete our current module's CModuleData object.
      delete[] (BYTE*)pModule->m_pData;
   }

   // Delete our current module object itself.
   delete pModule;
}

//******************************************************************************
CModule* CDepends::FindModule(CModule *pModuleCur, LPCSTR szPath) {

   if (!pModuleCur) {
      return NULL;
   }

   // Check to see if our current module matches our search module.
   if (!_stricmp(pModuleCur->m_pData->m_szPath, szPath)) {
      return (pModuleCur->m_pModuleOriginal ? pModuleCur->m_pModuleOriginal : pModuleCur);
   }

   // Recurse into FindModule() for each dependent module.
   pModuleCur = pModuleCur->m_pDependents;
   while (pModuleCur) {
      CModule *pModuleFound = FindModule(pModuleCur, szPath);
      if (pModuleFound) {
         return pModuleFound;
      }
      pModuleCur = pModuleCur->m_pNext;
   }

   return NULL;
}

//******************************************************************************
BOOL CDepends::VerifyModule(CModule *pModule) {

   // Map an IMAGE_DOS_HEADER structure onto our module file mapping.
   PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER)m_lpvFile;

   // Check for the DOS signature ("MZ").
   if (pIDH->e_magic != IMAGE_DOS_SIGNATURE) {
      //SetModuleError(pModule, "No DOS signature found. This file is not a valid Win32 module.");
      return FALSE;
   }

   // Map an IMAGE_NT_HEADERS structure onto our module file mapping.
   PIMAGE_NT_HEADERS pINTH = (PIMAGE_NT_HEADERS)((DWORD_PTR)m_lpvFile + pIDH->e_lfanew);

   // Check for NT/PE signature ("PE\0\0").
   if (pINTH->Signature != IMAGE_NT_SIGNATURE) {
      //SetModuleError(pModule, "No PE signature found. This file is not a valid Win32 module.");
      return FALSE;
   }

   // Map our IMAGE_FILE_HEADER structure onto our module file mapping.
   m_pIFH = &pINTH->FileHeader;

   // Map our IMAGE_OPTIONAL_HEADER structure onto our module file mapping.
   m_pIOH = &pINTH->OptionalHeader;

   // Map our IMAGE_SECTION_HEADER structure array onto our module file mapping
   m_pISH = IMAGE_FIRST_SECTION(pINTH);

   return TRUE;
}



char *MachineToString(DWORD Machine)
{
    switch( Machine ) 
	{
		case IMAGE_FILE_MACHINE_UNKNOWN :
			return "Unknown";
		case IMAGE_FILE_MACHINE_I386 :
			return "x86";
		case IMAGE_FILE_MACHINE_R3000 :
			return "MIPS";
		case IMAGE_FILE_MACHINE_R4000 :
			return "MIPS";
		case IMAGE_FILE_MACHINE_R10000 :
			return "MIPS";
		case IMAGE_FILE_MACHINE_ALPHA :
			return "Alpha";
		case IMAGE_FILE_MACHINE_POWERPC :
			return "PPC";  //IBM PowerPC
    }
    return "INVALID";
}


//******************************************************************************
BOOL CDepends::GetModuleInfo(CModule *pModule) {

   // Store the machine type.
   pModule->m_pData->m_dwMachine = m_pIFH->Machine;

   // Check for a mismatched machine error.
   if (m_dwMachineType == (DWORD)-1) {
      m_dwMachineType = pModule->m_pData->m_dwMachine;
   } else if (m_dwMachineType != pModule->m_pData->m_dwMachine) {
      m_fMixedMachineError = TRUE;

        char szMyBigString[_MAX_PATH + 50];
        char szMyPrintString[_MAX_PATH + 50];
        MyLoadString(IDS_STRING9, szMyBigString);
        sprintf(szMyPrintString, szMyBigString, MachineToString(pModule->m_pData->m_dwMachine), (LPSTR) pModule->m_pData->m_szPath);
	    printf(szMyPrintString);
   }

   // Store the subsystem type
   pModule->m_pData->m_dwSubsystem = m_pIOH->Subsystem;

   // Store the preferred base address
   pModule->m_pData->m_dwBaseAddress = m_pIOH->ImageBase;

   // Store the image version
   pModule->m_pData->m_dwImageVersion =
      MAKELONG(m_pIOH->MinorImageVersion, m_pIOH->MajorImageVersion);

   // Store the linker version
   pModule->m_pData->m_dwLinkerVersion =
      MAKELONG(m_pIOH->MinorLinkerVersion, m_pIOH->MajorLinkerVersion);

   // Store the OS version
   pModule->m_pData->m_dwOSVersion =
      MAKELONG(m_pIOH->MinorOperatingSystemVersion, m_pIOH->MajorOperatingSystemVersion);

   // Store the subsystem version
   pModule->m_pData->m_dwSubsystemVersion = MAKELONG(m_pIOH->MinorSubsystemVersion, m_pIOH->MajorSubsystemVersion);

   return TRUE;
}


BOOL
CDepends::WalkIAT(
    PIMAGE_THUNK_DATA pITDF,
    PIMAGE_THUNK_DATA pITDA,
    CModule *pModule,
    DWORD_PTR dwBase
    )
{
    CFunction *pFunctionLast = NULL, *pFunctionNew;

    // Loop through all the Image Thunk Data structures in the function array.
    while (pITDF->u1.Ordinal) {

         LPCSTR szFunction = "";
         int    ordinal = -1, hint = -1;

         // Check to see if this function is by ordinal or by name. If the
         // function is by ordinal, the ordinal's high bit will be set. If the
         // the high bit is not set, then the ordinal value is really a virtual
         // address of an IMAGE_IMPORT_BY_NAME structure.

         if (IMAGE_SNAP_BY_ORDINAL(pITDF->u1.Ordinal)) {
             ordinal = (int)IMAGE_ORDINAL(pITDF->u1.Ordinal);
         } else {
            PIMAGE_IMPORT_BY_NAME pIIBN =
               (PIMAGE_IMPORT_BY_NAME)(dwBase + (DWORD_PTR)pITDF->u1.AddressOfData);
            szFunction = (LPCSTR)pIIBN->Name;
            hint = (int)pIIBN->Hint;
         }

         // If this import module has been pre-bound, then get this function's
         // entrypoint memory address.
         DWORD_PTR dwAddress = (DWORD_PTR)(pITDA ? pITDA->u1.Function : (DWORD_PTR)INVALID_HANDLE_VALUE);

         // Create a new CFunction object for this function.
         if (!(pFunctionNew = CreateFunction(ordinal, hint, szFunction, dwAddress))) {
             m_fOutOfMemory = TRUE;
             return FALSE;
         }

         // Add the function to the end of our module's function linked list
         if (pFunctionLast) {
             pFunctionLast->m_pNext = pFunctionNew;
         } else {
             pModule->m_pParentImports = pFunctionNew;
         }
         pFunctionLast = pFunctionNew;

         // Increment to the next function and address.
         pITDF++;
         if (pITDA) {
             pITDA++;
         }
    }
    return TRUE;
}


//******************************************************************************
BOOL CDepends::BuildImports(CModule *pModule) {

   // If this module has no imports (like NTDLL.DLL), then just return success.
   if (m_pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size == 0) {
      return TRUE;
   }

   // Locate our Import Image Directory's relative virtual address
   DWORD VAImageDir = m_pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

   PIMAGE_SECTION_HEADER pISH = NULL;

   // Locate the section that contains this Image Directory. We do this by
   // walking through all of our sections until we find the one that specifies
   // an address range that our Image Directory fits in.
   for (int i = 0; i < m_pIFH->NumberOfSections; i++) {
      if ((VAImageDir >= m_pISH[i].VirtualAddress) &&
          (VAImageDir < (m_pISH[i].VirtualAddress + m_pISH[i].SizeOfRawData)))
      {
         pISH = &m_pISH[i];
         break;
      }
   }

   // Bail out if we could not find a section that owns our Image Directory.
   if (!pISH) {
      //SetModuleError(pModule, "Could not find the section that owns the Import Directory.");
      return FALSE;
   }

   // Compute our base that everything else is an offset from. We do this by
   // taking our base file pointer and adding our section's PointerToRawData,
   // which is an absolute offset value into our file.  We then subtract off our
   // Virtual Address since the offsets we are going to be adding later will be
   // relative to the this Virtual Address
   DWORD_PTR dwBase = (DWORD_PTR)m_lpvFile + pISH->PointerToRawData - pISH->VirtualAddress;

   // To locate the beginning of our Image Import Descriptor array, we add our
   // Image Directory offset to our base.
   PIMAGE_IMPORT_DESCRIPTOR pIID = (PIMAGE_IMPORT_DESCRIPTOR)(dwBase + VAImageDir);

   CModule   *pModuleLast   = NULL, *pModuleNew;
   CFunction *pFunctionLast = NULL, *pFunctionNew;

   // Loop through all the Image Import Descriptors in the array.
   while (pIID->OriginalFirstThunk || pIID->FirstThunk) {

      // Locate our module name string and create the module object.
      if (!(pModuleNew = CreateModule((LPCSTR)(dwBase + pIID->Name),
                                      pModule->m_depth + 1)))
      {
         m_fOutOfMemory = TRUE;
         return FALSE;
      }

      // Add the module to the end of our module linked list.
      if (pModuleLast) {
         pModuleLast->m_pNext = pModuleNew;
      } else {
         pModule->m_pDependents = pModuleNew;
      }
      pModuleLast = pModuleNew;

      // Locate the beginning of our function array and address array. The
      // function array (pITDF) is an array of IMAGE_THUNK_DATA structures that
      // contains all the exported functions, both by name and by ordinal. The
      // address array (pITDA) is an parallel array of IMAGE_THUNK_DATA
      // structures that is used to store the all the function's entrypoint
      // addresses. Usually the address array contains the exact same values
      // the function array contains until the OS loader actually loads all the
      // modules. At that time, the loader will set (bind) these addresses to
      // the actual addresses that the given functions reside at in memory. Some
      // modules have their exports pre-bound which can provide a speed increase
      // when loading the module. If a module is pre-bound (often seen with
      // system modules), the TimeDateStamp field of our IMAGE_IMPORT_DESCRIPTOR
      // structure will be set and the address array will contain the actual
      // memory addresses that the functions will reside at, assuming that the
      // imported module loads at its preferred base address.

      PIMAGE_THUNK_DATA pITDF = NULL, pITDA = NULL;

      // Check to see if module is Microsoft format or Borland format.
      if (pIID->OriginalFirstThunk) {

         // Microsoft uses the OriginalFirstThunk field for the function array.
         pITDF = (PIMAGE_THUNK_DATA)(dwBase + (DWORD)pIID->OriginalFirstThunk);

         // Microsoft optionally uses the FirstThunk as a bound address array.
         // If the TimeDateStamp field is set, then the module has been bound.
         if (pIID->TimeDateStamp) {
            pITDA = (PIMAGE_THUNK_DATA)(dwBase + (DWORD)pIID->FirstThunk);
         }

      } else {

         // Borland uses the FirstThunk field for the function array.
         pITDF = (PIMAGE_THUNK_DATA)(dwBase + (DWORD)pIID->FirstThunk);;
      }

      // Find imports
      if (!WalkIAT(pITDF, pITDA, pModuleLast, dwBase)) {
          return FALSE;
      }

      // Increment to the next import module
      pIID++;
   }

   return TRUE;
}

BOOL CDepends::BuildDelayImports(CModule *pModule) {

   // If this module has no delay imports just return success.
   if (m_pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].Size == 0) {
      return TRUE;
   }

   // Locate our Import Image Directory's relative virtual address
   DWORD VAImageDir = m_pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress;

   PIMAGE_SECTION_HEADER pISH = NULL;

   // Locate the section that contains this Image Directory. We do this by
   // walking through all of our sections until we find the one that specifies
   // an address range that our Image Directory fits in.
   for (int i = 0; i < m_pIFH->NumberOfSections; i++) {
      if ((VAImageDir >= m_pISH[i].VirtualAddress) &&
          (VAImageDir < (m_pISH[i].VirtualAddress + m_pISH[i].SizeOfRawData)))
      {
         pISH = &m_pISH[i];
         break;
      }
   }

   // Bail out if we could not find a section that owns our Image Directory.
   if (!pISH) {
      //SetModuleError(pModule, "Could not find the section that owns the Import Directory.");
      return FALSE;
   }

   // Compute our base that everything else is an offset from. We do this by
   // taking our base file pointer and adding our section's PointerToRawData,
   // which is an absolute offset value into our file.  We then subtract off our
   // Virtual Address since the offsets we are going to be adding later will be
   // relative to the this Virtual Address
   DWORD_PTR dwBase = (DWORD_PTR)m_lpvFile + pISH->PointerToRawData - pISH->VirtualAddress;

   // To locate the beginning of our Image Import Descriptor array, we add our
   // Image Directory offset to our base.
   PImgDelayDescr pIDD = (PImgDelayDescr)(dwBase + VAImageDir);

   CModule   *pModuleLast   = NULL, *pModuleNew;
   CFunction *pFunctionLast = NULL, *pFunctionNew;

   if (pIDD->grAttrs & dlattrRva) {
       PImgDelayDescrV2 pIDDv2 = (PImgDelayDescrV2)pIDD;
       // Loop through all the Image Import Descriptors in the array.
       while (pIDDv2->rvaINT && pIDDv2->rvaIAT && pIDDv2->rvaHmod) {

          DWORD_PTR dwNameBase = 0, dwINTBase = 0;

          // Locate the section that contains this Image Directory. We do this by
          // walking through all of our sections until we find the one that specifies
          // an address range that our Image Directory fits in.
          for (int i = 0; i < m_pIFH->NumberOfSections; i++) {
             if (((DWORD_PTR)pIDDv2->rvaDLLName >= m_pISH[i].VirtualAddress) &&
                 ((DWORD_PTR)pIDDv2->rvaDLLName < (m_pISH[i].VirtualAddress + m_pISH[i].SizeOfRawData)))
             {
                dwNameBase = ((DWORD_PTR)m_lpvFile + m_pISH[i].PointerToRawData - m_pISH[i].VirtualAddress);
             }

             if (((DWORD_PTR)pIDDv2->rvaINT >= (m_pISH[i].VirtualAddress)) &&
                 ((DWORD_PTR)pIDDv2->rvaINT < (m_pISH[i].VirtualAddress + m_pISH[i].SizeOfRawData)))
             {
                dwINTBase = ((DWORD_PTR)m_lpvFile + m_pISH[i].PointerToRawData - m_pISH[i].VirtualAddress);
             }
          }

          if (!dwINTBase) {
             //SetModuleError(pModule, "Could not find the section that owns the Delay Import INT.");
             return FALSE;
          }

          if (!dwNameBase) {
             //SetModuleError(pModule, "Could not find the section that owns the Delay Import DllName.");
             return FALSE;
          }

          // Locate our module name string and create the module object.
          if (!(pModuleNew = CreateModule((LPCSTR)(dwNameBase + pIDDv2->rvaDLLName),
                                          pModule->m_depth + 1)))
          {
             m_fOutOfMemory = TRUE;
             return FALSE;
          }

          // Add the module to the end of our module linked list.
          if (pModuleLast) {
             pModuleLast->m_pNext = pModuleNew;
          } else {
             if (pModule->m_pDependents) {
                 pModuleLast = pModule->m_pDependents;
                 while (pModuleLast->m_pNext) {
                     pModuleLast = pModuleLast->m_pNext;
                 }
                 pModuleLast->m_pNext = pModuleNew;
             } else {
                 pModule->m_pDependents = pModuleNew;
             }
          }
          pModuleLast = pModuleNew;

          pModuleLast->m_fDelayLoad = TRUE;

          // For now, don't worry about bound imports.

          PIMAGE_THUNK_DATA pITDF = NULL;

          pITDF = (PIMAGE_THUNK_DATA)(dwINTBase + (DWORD_PTR)pIDDv2->rvaINT);

          // Find imports
          if (!WalkIAT(pITDF, NULL, pModuleLast, dwNameBase)) {
              return FALSE;
          }

          // Increment to the next import module
          pIDDv2++;
       }
   } else {
       PImgDelayDescrV1 pIDDv1 = (PImgDelayDescrV1)pIDD;

       // Loop through all the Image Import Descriptors in the array.
       while (pIDDv1->pINT && pIDDv1->pIAT && pIDDv1->phmod) {

          DWORD_PTR dwNameBase = 0, dwINTBase = 0;

          // Locate the section that contains this Image Directory. We do this by
          // walking through all of our sections until we find the one that specifies
          // an address range that our Image Directory fits in.
          for (int i = 0; i < m_pIFH->NumberOfSections; i++) {
             if (((DWORD_PTR)pIDDv1->szName >= (m_pIOH->ImageBase + m_pISH[i].VirtualAddress)) &&
                 ((DWORD_PTR)pIDDv1->szName < (m_pIOH->ImageBase + m_pISH[i].VirtualAddress + m_pISH[i].SizeOfRawData)))
             {
                dwNameBase = ((DWORD_PTR)m_lpvFile + m_pISH[i].PointerToRawData - m_pISH[i].VirtualAddress - m_pIOH->ImageBase);
             }

             if (((DWORD_PTR)pIDDv1->pINT >= (m_pIOH->ImageBase + m_pISH[i].VirtualAddress)) &&
                 ((DWORD_PTR)pIDDv1->pINT < (m_pIOH->ImageBase + m_pISH[i].VirtualAddress + m_pISH[i].SizeOfRawData)))
             {
                dwINTBase = ((DWORD_PTR)m_lpvFile + m_pISH[i].PointerToRawData - m_pISH[i].VirtualAddress - m_pIOH->ImageBase);
             }
          }

          if (!dwINTBase) {
             //SetModuleError(pModule, "Could not find the section that owns the Delay Import INT.");
             return FALSE;
          }

          if (!dwNameBase) {
             //SetModuleError(pModule, "Could not find the section that owns the Delay Import DllName.");
             return FALSE;
          }

          // Locate our module name string and create the module object.
          if (!(pModuleNew = CreateModule((LPCSTR)(dwNameBase + pIDDv1->szName),
                                          pModule->m_depth + 1)))
          {
             m_fOutOfMemory = TRUE;
             return FALSE;
          }

          // Add the module to the end of our module linked list.
          if (pModuleLast) {
             pModuleLast->m_pNext = pModuleNew;
          } else {
             if (pModule->m_pDependents) {
                 pModuleLast = pModule->m_pDependents;
                 while (pModuleLast->m_pNext) {
                     pModuleLast = pModuleLast->m_pNext;
                 }
                 pModuleLast->m_pNext = pModuleNew;
             } else {
                 pModule->m_pDependents = pModuleNew;
             }
          }
          pModuleLast = pModuleNew;

          pModuleLast->m_fDelayLoad = TRUE;

          // For now, don't worry about bound imports.

          PIMAGE_THUNK_DATA pITDF = NULL;

          pITDF = (PIMAGE_THUNK_DATA)(dwINTBase + (DWORD_PTR)pIDDv1->pINT);

          // Find imports
          if (!WalkIAT(pITDF, NULL, pModuleLast, dwNameBase)) {
              return FALSE;
          }

          // Increment to the next import module
          pIDDv1++;
       }
   }

   return TRUE;
}



//******************************************************************************
BOOL CDepends::BuildExports(CModule *pModule) {

   // If this module has no exports, then just return success.
   if (m_pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size == 0) {
      return TRUE;
   }

   // Locate our Export Image Directory's relative virtual address
   DWORD VAImageDir = m_pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

   PIMAGE_SECTION_HEADER pISH = NULL;

   // Locate the section that contains this Image Directory. We do this by
   // walking through all of our sections until we find the one that specifies
   // an address range that our Image Directory fits in.
   for (int i = 0; i < m_pIFH->NumberOfSections; i++) {
      if ((VAImageDir >= m_pISH[i].VirtualAddress) &&
          (VAImageDir < (m_pISH[i].VirtualAddress + m_pISH[i].SizeOfRawData)))
      {
         pISH = &m_pISH[i];
         break;
      }
   }

   // Bail out if we could not find a section that owns our Image Directory.
   if (!pISH) {
      //SetModuleError(pModule, "Could not find the section that owns the Export Directory.");
      return FALSE;
   }

   // Compute our base that everything else is an offset from. We do this by
   // taking our base file pointer and adding our section's PointerToRawData,
   // which is an absolute offset value into our file.  We then subtract off our
   // Virtual Address since the offsets we are going to be adding later will be
   // relative to the this Virtual Address
   DWORD_PTR dwBase = (DWORD_PTR)m_lpvFile + pISH->PointerToRawData - pISH->VirtualAddress;

   // To locate the beginning of our Image Export Directory, we add our
   // Image Directory offset to our base.
   PIMAGE_EXPORT_DIRECTORY pIED = (PIMAGE_EXPORT_DIRECTORY)(dwBase + VAImageDir);

   // pdwNames is a DWORD array of size pIED->NumberOfNames, which contains VA
   // pointers to all the function name strings. pwOrdinals is a WORD array of
   // size pIED->NumberOfNames, which contains all the ordinal values for each
   // function exported by name. pdwNames and pwOrdinals are parallel arrays,
   // meaning that the ordinal in pwOrdinals[x] goes with the function name
   // pointed to by pdwNames[x]. The value used to index these arrays is
   // referred to as the "hint".

   // pdwAddresses is a DWORD array of size pIED->NumberOfFunctions, which
   // contains the entrypoint addresses for all functions exported by the
   // module. Contrary to several PE format documents, this array is *not*
   // parallel with pdwNames and pwOrdinals. The index used for this array is
   // the ordinal value of the function you are interested in, minus the base
   // ordinal specified in pIED->Base. Another common mistake is to assume that
   // pIED->NumberOfFunctions is always equal to pIED->AddressOfNames. If the
   // module exports function by ordinal only, then pIED->NumberOfFunctions
   // will be greater than pIED->NumberOfNames.

   DWORD *pdwNames     = (DWORD*)(dwBase + (DWORD)pIED->AddressOfNames);
   WORD  *pwOrdinals   = (WORD* )(dwBase + (DWORD)pIED->AddressOfNameOrdinals);
   DWORD *pdwAddresses = (DWORD*)(dwBase + (DWORD)pIED->AddressOfFunctions);

   CFunction *pFunctionLast = NULL, *pFunctionNew;

   // Loop through all the "exported by name" functions.
   for (int hint = 0; hint < (int)pIED->NumberOfNames; hint++) {

      // Get our ordinal value, function name, and entrypoint address
      int    ordinal    = pIED->Base + (DWORD)pwOrdinals[hint];
      LPCSTR szFunction = (LPCSTR)(dwBase + pdwNames[hint]);
      DWORD  dwAddress  = pdwAddresses[ordinal - pIED->Base];
      LPCSTR szForward  = NULL;

      // Certain modules, such as NTDLL.DLL and MSVCRT40.DLL, have what are
      // known as forwarded functions.  Forwarded functions are functions that
      // are exported from one module, but the code actually lives in another
      // module.  We can check to see if a function is forwarded by looking at
      // its address pointer.  If the address pointer points to the character
      // immediately following the NULL character in its function name string,
      // then this address pointer is really a pointer to a forward string in
      // the string table.  Some documents state that if the address points to
      // a RVA in our current section, then the address must point to a forward
      // string.  This is not true since the function code can (and sometimes
      // does) live in the same section that we are currently in.

      if (((DWORD_PTR)szFunction + strlen(szFunction) + 1) == (dwBase + dwAddress)) {
         szForward = (LPCSTR)(dwBase + dwAddress);
      }

      // Create a new CFunction object for this function.
      if (!(pFunctionNew = CreateFunction(ordinal, hint, szFunction, dwAddress, szForward))) {
         m_fOutOfMemory = TRUE;
         return FALSE;
      }

      // Add the function to the end of our module's export function linked list
      if (pFunctionLast) {
         pFunctionLast->m_pNext = pFunctionNew;
      } else {
         pModule->m_pData->m_pExports = pFunctionNew;
      }
      pFunctionLast = pFunctionNew;
   }

   // Loop through all the "exported by ordinal" functions. This module has
   // pIED->NumberOfFunctions functions with consecutive ordinals starting
   // with the ordinal specified by pIED->Base. We need to loop through all
   // these ordinal values and add any to our list that have not already been
   // added by name.

   for (int ordinal = pIED->Base;
        ordinal < (int)(pIED->NumberOfFunctions + pIED->Base); ordinal++) {

      // Loop through our current list to make sure we haven't already added
      // this function during our "exported by name" search above.
      CFunction *pFunctionCur = pModule->m_pData->m_pExports;
      while (pFunctionCur) {
         if (pFunctionCur->m_ordinal == ordinal) {
            break;
         }
         pFunctionCur = pFunctionCur->m_pNext;
      }

      // If this ordinal is not currently in our list, then add it to our list.
      if (!pFunctionCur) {

         // Get this function's entrypoint address.
         DWORD dwAddress = pdwAddresses[ordinal - pIED->Base];

         // Create a new CFunction object for this function.
         if (!(pFunctionNew = CreateFunction(ordinal, -1, "", dwAddress))) {
            m_fOutOfMemory = TRUE;
            return FALSE;
         }

         // Add the function to the end of our module's export function linked list
         if (pFunctionLast) {
            pFunctionLast->m_pNext = pFunctionNew;
         } else {
            pModule->m_pData->m_pExports = pFunctionNew;
         }
         pFunctionLast = pFunctionNew;
      }
   }

   return TRUE;
}

//******************************************************************************
BOOL CDepends::VerifyParentImports(CModule *pModule) {

   CModule *pModuleHead = NULL, *pModuleLast, *pModuleCur;

   // Loop through each of our parent import functions.
   CFunction *pImport = pModule->m_pParentImports;
   while (pImport) {

      // Mark this parent import function as not resolved before starting search.
      pImport->m_dwExtra = 0;

      // Loop through all our exports, looking for a match with our current import.
      CFunction *pExport = pModule->m_pData->m_pExports;
      while (pExport) {

         // If we have a name, then check for the match by name.
         if (*pImport->m_szName) {
            if (!strcmp(pImport->m_szName, pExport->m_szName)) {

               // We found a match. Link this parent import to its associated
               // export, break out of loop, and move on to handling our next
               // parent import.
               pImport->m_dwExtra = (DWORD_PTR)pExport;
               break;
            }

         // If we don't have a name, then check for the match by name.
         } else if (pImport->m_ordinal == pExport->m_ordinal) {

            // We found a match. Link this parent import to its associated
            // export, break out of loop, and move on to handling our next
            // parent import.
            pImport->m_dwExtra = (DWORD_PTR)pExport;
            break;
         }

         // Move to the next export
         pExport = pExport->m_pNext;
      }

      // Check to see if an export match was found.
      if (pImport->GetAssociatedExport()) {

         CHAR   szFile[1024];
         LPCSTR szFunction;

         // If an export was found, check to see if it is a forwarded function.
         // If it is forwarded, then we need to make sure we consider the
         // forwarded module as a new dependent of the current module.
         LPCSTR szForward = pImport->GetAssociatedExport()->GetForwardString();
         if (szForward) {

            // Extract and build the DLL name from the forward string.
            LPCSTR pszDot = strchr(szForward, '.');
            if (pszDot) {
               strncpy(szFile, szForward, (size_t)(pszDot - szForward));
               strcpy(szFile + (pszDot - szForward), ".DLL");
               szFunction = pszDot + 1;
            } else {
               strcpy(szFile, "Invalid");
               szFunction = szForward;
            }

            // Search our local forward module list to see if we have already
            // created a forward CModoule for this DLL file.
            for (pModuleLast = NULL, pModuleCur = pModuleHead; pModuleCur;
                 pModuleLast = pModuleCur, pModuleCur = pModuleCur->m_pNext)
            {
               if (!_stricmp(pModuleCur->m_pData->m_szFile, szFile)) {
                  break;
               }
            }

            // If we have not created a forward module for this file yet, then
            // create it now and add it to the end of our list.
            if (!pModuleCur) {

               if (!(pModuleCur = CreateModule(szFile, pModule->m_depth + 1))) {
                  m_fOutOfMemory = TRUE;
                  return FALSE;
               }
               pModuleCur->m_fForward = TRUE;

               // Add the new module to our local forward module list.
               if (pModuleLast) {
                  pModuleLast->m_pNext = pModuleCur;
               } else {
                  pModuleHead = pModuleCur;
               }
            }

            // Create a new CFunction object for this function.
            CFunction *pFunction = CreateFunction(-1, -1, szFunction, (DWORD)-1);
            if (!pFunction) {
               m_fOutOfMemory = TRUE;
               return FALSE;
            }

            // Insert this function object into our forward module's import list.
            pFunction->m_pNext = pModuleCur->m_pParentImports;
            pModuleCur->m_pParentImports = pFunction;
         }

      } else {

         // If we could not find an import/export match, then flag the module
         // as having an export error.
         pModule->m_fExportError = TRUE;
      }

      // Move to the next parent import function.
      pImport = pImport->m_pNext;
   }

   // If we created any forward modules during our entire import verify, then
   // add them to the end of our module's dependent module list.
   if (pModuleHead) {

      // Walk to end of our module's dependent module list.
      for (pModuleLast = pModule->m_pDependents;
           pModuleLast && pModuleLast->m_pNext;
           pModuleLast = pModuleLast->m_pNext)
      {}

      // Add our local list to the end of our module's dependent module list.
      if (pModuleLast) {
         pModuleLast->m_pNext = pModuleHead;
      } else {
         pModule->m_pDependents = pModuleHead;
      }
   }
   return TRUE;
}


//******************************************************************************
BOOL CDepends::ProcessModule(CModule *pModule) {

   BOOL fResult = FALSE;

   // First check to see if this module is a duplicate. If it is, make sure the
   // original instance of this module has been processed and then just perform
   // the Parent Import Verify. If the module being passed in is an original,
   // then just ensure that we haven't already processed this module.

   if (pModule->m_pModuleOriginal) {

      // Process the original module and its subtree.
      fResult = ProcessModule(pModule->m_pModuleOriginal);
      if (!fResult && m_fOutOfMemory) {
         return FALSE;
      }

   // Exit now if we have already processed this original module in the past.
   } else if (pModule->m_pData->m_fProcessed) {
      return TRUE;

   } else {

      // Mark this module as processed.
      pModule->m_pData->m_fProcessed = TRUE;

      // Open the file for read.
      //m_hFile = CreateFile(pModule->m_pData->m_szPath, GENERIC_READ,
      m_hFile = CreateFileA(pModule->m_pData->m_szPath, GENERIC_READ,
                           FILE_SHARE_READ, NULL, OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL, NULL);

      // Exit now if the file failed to open.
      if (m_hFile == INVALID_HANDLE_VALUE) {
         DWORD dwGLE = GetLastError();
         if (dwGLE == ERROR_FILE_NOT_FOUND) {
            //SetModuleError(pModule, "File not found in local directory or search path.");
            pModule->m_pData->m_fFileNotFound = TRUE;
         } else if (dwGLE == ERROR_PATH_NOT_FOUND) {
            //SetModuleError(pModule, "Invalid path or file name.");
            pModule->m_pData->m_fFileNotFound = TRUE;
         } else {
            //SetModuleError(pModule, "CreateFile() failed (%u).", dwGLE);
         }
         return FALSE;
      }

      // Create a file mapping object for the open module.
      HANDLE hMap = CreateFileMapping(m_hFile, NULL, PAGE_READONLY, 0, 0, NULL);

      // Exit now if the file failed to map.
      if (hMap == NULL) {
         //SetModuleError(pModule, "CreateFileMapping() failed (%u).", GetLastError());
         CloseHandle(m_hFile);
         m_hFile = NULL;
         return FALSE;
      }

      // Create a file mapping view for the open module.
      m_lpvFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);

      // Exit now if the mapped view failed to create.
      if (m_lpvFile == NULL) {
         //SetModuleError(pModule, "MapViewOfFile() failed (%u).", GetLastError());
         CloseHandle(hMap);
         CloseHandle(m_hFile);
         m_hFile = NULL;
         return FALSE;
      }

      __try {

         // Everything from here on is pretty much relying on the file being a
         // valid binary with valid pointers and offsets. It is fairly safe to
         // just wrap everything in exception handling and then blindly access
         // the file. Anything that causes us to move outside our file mapping
         // will generate an exception and bring us back here to fail the file.

         fResult = (VerifyModule(pModule)   &&
                    GetModuleInfo(pModule)  &&
                    BuildImports(pModule)   &&
                    BuildDelayImports(pModule) &&
                    BuildExports(pModule));

      } __except(EXCEPTION_EXECUTE_HANDLER) {
         //SetModuleError(pModule, "Module does not appear to be a valid Win32 module.");
      }

      // Close our map view pointer, our map handle, and our file handle.
      UnmapViewOfFile(m_lpvFile);
      CloseHandle(hMap);
      CloseHandle(m_hFile);

      // Clear our file handles and pointers.
      m_hFile   = NULL;
      m_lpvFile = NULL;
      m_pIFH    = NULL;
      m_pIOH    = NULL;
      m_pISH    = NULL;
   }

   // Compare our parent imports with our exports to make sure they all match up.
   if (!VerifyParentImports(pModule)) {
      return FALSE;
   }

   // Safeguard to ensure that we don't get stuck in some recursize loop.  This
   // can occur if there is a circular dependency with forwarded functions. This
   // is extremely rare and would require someone to design it, but we need
   // to handle this case to prevent us from crashing on it.  When NT encounters
   // a module like this, it fails the load with exception 0xC00000FD which is
   // defined as STATUS_STACK_OVERFLOW in WINNT.H.  We use 255 as our max depth
   // because the several versions of the tree control crash if more than 256
   // depths are displayed.

   if (pModule->m_depth >= 255) {

      // If this module has dependents, then delete them.
      if (pModule->m_pDependents) {
         DeleteModule(pModule->m_pDependents);
         pModule->m_pDependents = NULL;
      }

      // Flag this document as having a circular dependency error.
      m_fCircularError = TRUE;
      return FALSE;
   }

   // Recurse into ProcessModule() to handle all our dependent modules.
   pModule = pModule->m_pDependents;
   while (pModule) {
      if (!ProcessModule(pModule) && m_fOutOfMemory) {
         return FALSE;
      }
      pModule = pModule->m_pNext;
   }

   return fResult;
}





















LPWSTR MakeWideStrFromAnsi(LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\dirminus\filefind.h ===
typedef struct  _finddata_t SysFindData;
struct MyFindDataStruct 
{
	unsigned	attrib;   // File attribute
	time_t		time_create; //   Time of file creation ( 1L for FAT file systems)
	time_t		time_access; //   Time of last file access (1L for FAT file systems)
	time_t		time_write; //   Time of last write to file
	unsigned long size; //   Length of file in bytes
	char *		name; //   Null-terminated name of matched file/directory, without the path
	char *		ShortName;
};
typedef struct MyFindDataStruct finddata;


#define ALL_FILES		0xff
#define STRING_TABLE_SIZE   100000

int  InitStringTable(long size);
void EndStringTable();
void AddString(char * s, finddata * f);
long GetStringTableSize();
void ResetStringTable();
int  FindFirst(char * ss, unsigned attr, long * hFile, finddata * s);
int  FindNext(int attr, long hFile, finddata * s);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\dllhell\main.cpp ===
#include "main.h"
#include "depends.h"
#include "resource.h"

//
// Code by AaronL
// copied most of it from the depends source code.
//

//
// prototypes...
//
int __cdecl main(int ,char *argv[]);
void  ShowHelp(void);

void  ProcessManyFiles(char * szTheDir, char * szTheFileNameOrWildCard);
void  ProcessOneFile(LPSTR szTempFileName);
void  OutputToScreen(char * szTheString1, char * szTheString2);

//
// Globals
//
int g_Flag_R = FALSE;

HINSTANCE g_hModuleHandle = NULL;

#define ALL_FILES       0xff

//-------------------------------------------------------------------
//  purpose: main
//-------------------------------------------------------------------
int __cdecl main(int argc,char *argv[])
{
	LPSTR pArg = NULL;
	LPSTR pCmdStart = NULL;

    int argno;
    int nflags=0;
	char szTempFileName[MAX_PATH];
	char szTempString[MAX_PATH];
	szTempFileName[0] = '\0';

    g_hModuleHandle = GetModuleHandle(NULL);

    // process command line arguments
    for(argno=1; argno<argc; argno++)
        {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' )
            {
            nflags++;
            switch (argv[argno][1])
                {
                case 'r':
				case 'R':
					g_Flag_R = TRUE;
                    break;
                case '?':
                    goto main_exit_with_help;
                    break;
                }
            } // if switch character found
        else
            {
            if ( *szTempFileName == '\0' )
                {
                // if no arguments, then
                strcpy(szTempFileName, argv[argno]);
                }
            } // non-switch char found
        } // for all arguments

    char szTheDriveOnly[_MAX_DRIVE];
    char szTheDirOnly[_MAX_DIR];
    char szTheFileNameOnly[_MAX_FNAME];
    char szTheEXTOnly[_MAX_EXT];

    char szTheFileNameAndExt[_MAX_FNAME + _MAX_EXT];
    char szTheDriveAndDir[_MAX_PATH];

    if (strcmp(szTempFileName, "") == 0)
    {
        goto main_exit_with_help;
    }
    _splitpath(szTempFileName, szTheDriveOnly, szTheDirOnly, szTheFileNameOnly, szTheEXTOnly);
    sprintf(szTheFileNameAndExt, "%s%s", szTheFileNameOnly, szTheEXTOnly);
    sprintf(szTheDriveAndDir, "%s%s", szTheDriveOnly, szTheDirOnly);

    ProcessManyFiles(szTheDriveAndDir, szTheFileNameAndExt);
    
	goto main_exit_gracefully;
	
main_exit_gracefully:
    return TRUE;

main_exit_with_help:
    ShowHelp();
    return FALSE;
}


void ShowHelp()
{
	char szModuleName[_MAX_PATH];
	char szFilename_only[_MAX_FNAME];
	char szMyBigString[255];
    char szMyPrintString[255 + _MAX_PATH];
	GetModuleFileName(NULL, szModuleName, _MAX_PATH);

	// Trim off the filename only.
	_tsplitpath(szModuleName, NULL, NULL, szFilename_only, NULL);
    
    MyLoadString(IDS_STRING1, szMyBigString);
	sprintf(szMyPrintString, szMyBigString, szFilename_only);
	printf(szMyPrintString);

    MyLoadString(IDS_STRING2, szMyBigString);
	printf(szMyBigString);

    MyLoadString(IDS_STRING3, szMyBigString);
	sprintf(szMyPrintString, szMyBigString, szFilename_only);
	printf(szMyPrintString);

    MyLoadString(IDS_STRING4, szMyBigString);
	sprintf(szMyPrintString, szMyBigString, szFilename_only);
	printf(szMyPrintString);
    return;
}


void ProcessOneFile(char * szTempFileName)
{
    CDepends DependsStuff;
    char szMyPrintString[_MAX_PATH + 50];
    sprintf(szMyPrintString, "%s\r\n", (LPSTR) szTempFileName);
    printf(szMyPrintString);

    DependsStuff.SetInitialFilename(szTempFileName);

    if (DependsStuff.m_fOutOfMemory) 
    {
        char szMyBigString[_MAX_PATH + 50];
        MyLoadString(IDS_STRING5, szMyBigString);
        sprintf(szMyPrintString, szMyBigString, (LPSTR) szTempFileName);
	    printf(szMyPrintString);
    }

    // Display a message if the module contains a circular dependency error.
    if (DependsStuff.m_fCircularError) 
    {
        char szMyBigString[_MAX_PATH + 50];
        MyLoadString(IDS_STRING6, szMyBigString);
        sprintf(szMyPrintString, szMyBigString, (LPSTR) szTempFileName);
	    printf(szMyPrintString);
    }

    // Display a message if the module contains a mixed machine error.
    if (DependsStuff.m_fMixedMachineError) 
    {
        //sprintf(szMyPrintString, "  MixedMachineError:%s\r\n", (LPSTR) szTempFileName);
        //printf(szMyPrintString);
    }

    DependsStuff.LoopThruAndPrintLosers(DependsStuff.m_pModuleRoot);
    DependsStuff.DeleteContents();
}


void ProcessManyFiles(char * szTheDir, char * szTheFileNameOrWildCard)
{
    WIN32_FIND_DATA FindFileData;
    char szTheFullMonty[_MAX_PATH];
    char szTheRealWildcards[_MAX_PATH];
    int iFoundWildCard = FALSE;

    if (0 == strcmp(szTheDir, ""))
    {
        // if there is no specified directory
        strcpy(szTheFullMonty, szTheFileNameOrWildCard);
    }
    else
    {
        // if there is a dir, check if ends with a '\'
        // if it does, then kool, if it doesn't then add it.
        // then tack them together
        char *pTemp = NULL;
        pTemp = strrchr(szTheDir, (int) '\\');
        if (pTemp != NULL)
        {
            sprintf(szTheFullMonty, "%s%s", szTheDir, szTheFileNameOrWildCard);
        }
        else
        {
            sprintf(szTheFullMonty, "%s\\%s", szTheDir, szTheFileNameOrWildCard);
        }
    }
    //printf(szTheFullMonty);printf("<--\n");

    // if the fullmonty is a directory
    // then we have a directory.
    // get out.
    int retCode = GetFileAttributes(szTheFullMonty);
    if (retCode == 0xFFFFFFFF || (retCode & FILE_ATTRIBUTE_DIRECTORY)) 
    {
        // if there are wildcards in there, then
        // let it come thru, if not get out.
        char szFileNamePart[_MAX_FNAME];
        char *pdest = NULL;
        strcpy(szFileNamePart, szTheFileNameOrWildCard);
        pdest = strrchr(szFileNamePart, (int) '?');
        if (pdest != NULL)
        {
            iFoundWildCard = TRUE;
        }

        if (FALSE == iFoundWildCard)
        {
            pdest = NULL;
            pdest = strrchr(szFileNamePart,(int) '*');
            if (pdest != NULL)
            {
                iFoundWildCard = TRUE;
            }
        }

        if (FALSE == iFoundWildCard)
        {
            return;
        }
    }

    // if we have something which includes wildcards,
    // then change it to *.*
    if (TRUE == iFoundWildCard)
    {
        char szTheDriveOnly[_MAX_DRIVE];
        char szTheDirOnly[_MAX_DIR];
        char szTheFileNameOnly[_MAX_FNAME];
        char szTheEXTOnly[_MAX_EXT];
        char szTheFileNameAndExt[_MAX_FNAME + _MAX_EXT];
        char szTheDriveAndDir[_MAX_PATH];

        _splitpath(szTheFullMonty, szTheDriveOnly, szTheDirOnly, szTheFileNameOnly, szTheEXTOnly);
        sprintf(szTheFileNameAndExt, "%s%s", szTheFileNameOnly, szTheEXTOnly);
        sprintf(szTheDriveAndDir, "%s%s", szTheDriveOnly, szTheDirOnly);

        printf(szTheFullMonty);
        printf("\n");
        printf(szTheFileNameAndExt);
        printf("\n");
        printf(szTheFileNameAndExt);
        printf("\n");
    }

    HANDLE hFile = FindFirstFile(szTheFullMonty, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE) 
    {
        do {
            //printf("=%s\n",FindFileData.cFileName);
            if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        // this is a directory, so let's skip it
                        // if it's supposed to recurse thru dirs, then let's go into it.
                        if (TRUE == g_Flag_R)
                        {
                            char szSubDir[_MAX_PATH];
                            _stprintf(szSubDir, _T("%s"), FindFileData.cFileName);
                          
	                        //printf("found dir=%s,filename=%s\n",szSubDir,szTheFileNameOrWildCard);
                            ProcessManyFiles(szSubDir, szTheFileNameOrWildCard);
                        }
                    }
                else
                    {
                    // this is a file, so let's do something
                    char szTempFileName[_MAX_PATH];

                    if (0 == strcmp(szTheDir, ""))
                    {
                        // if there is no specified directory
                        strcpy(szTempFileName,FindFileData.cFileName);
                    }
                    else
                    {
                        char *pTemp = NULL;
                        pTemp = strrchr(szTheDir, (int) '\\');
                        if (pTemp != NULL)
                        {
                            sprintf(szTempFileName, "%s%s", szTheDir, FindFileData.cFileName);
                        }
                        else
                        {
                            sprintf(szTempFileName, "%s\\%s", szTheDir, FindFileData.cFileName);
                        }
                    }
                    
                    // This is a file so lets act upon it.
                    ProcessOneFile(szTempFileName);
                    }
                }

            // get the next file
            if ( !FindNextFile(hFile, &FindFileData) ) 
                {
                FindClose(hFile);
                break;
                }

            } while (TRUE);
    }
}


void OutputToScreen(char * szTheString1, char * szTheString2)
{
	char szMyPrintString[_MAX_PATH + _MAX_PATH];
	sprintf(szMyPrintString, szTheString1, szTheString2);
	printf(szMyPrintString);
    return;
}


void MyLoadString(int nID, char *szResult)
{
    char buf[1024];

    if (g_hModuleHandle == NULL) {return;}
  
    if (LoadString(g_hModuleHandle, nID, buf, sizeof(buf)))
        {strcpy(szResult, buf);}

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\dllhell\main.h ===
#include <stdio.h>
#include <fstream.h>
#include <windows.h>
#include <winver.h>
#include <tchar.h>
#include <ole2.h>
#include <shlobj.h>

#define UNICODE
#define _UNICODE

void  MyLoadString(int nID, char *szResult);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\flist\main.cpp ===
#include <stdio.h>
#include <fstream.h>
#include <windows.h>
#include <tchar.h>
#include "resource.h"
#include "other.h"

//
//  FList - a file list munger
//  Written by: AaronL
//

//
// prototypes...
//
int  __cdecl main(int ,char *argv[]);
void ShowHelp(void);
BOOL DoStuff(void);
int  ProcessFor_A(void);
int  ProcessFor_B(void);
int  ProcessFor_C(void);
int  ProcessFor_D(void);
int  ProcessFor_E(void);
int  ProcessFor_F(void);
int  MyLoadString(int nID, TCHAR *szResult);

//
// Globals
//
HINSTANCE g_hModuleHandle = NULL;

int   g_Flag_a = FALSE;
int   g_Flag_b = FALSE;
int   g_Flag_c = FALSE;
int   g_Flag_d = FALSE;
int   g_Flag_e = FALSE;
int   g_Flag_f = FALSE;
TCHAR g_Flag_f_Data[_MAX_PATH];

int   g_Flag_g = FALSE;
int   g_Flag_z = FALSE;
TCHAR g_Flag_z_Data[_MAX_PATH];

TCHAR g_szFileList1[_MAX_PATH];
TCHAR g_szFileList2[_MAX_PATH];


//-------------------------------------------------------------------
//  purpose: main
//-------------------------------------------------------------------
int __cdecl main(int argc,char *argv[])
{
	LPSTR pArg = NULL;
    int   argno = 0;
    int   nflags = 0;

    g_hModuleHandle = GetModuleHandle(NULL);
	
    _tcscpy(g_Flag_z_Data, _T(""));
    _tcscpy(g_szFileList1, _T(""));
    _tcscpy(g_szFileList2, _T(""));

    // process command line arguments
    for(argno=1; argno<argc; argno++)
        {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' )
            {
                nflags++;
                switch (argv[argno][1])
                {
                    case 'a': 
                    case 'A':
					    g_Flag_a = TRUE;
					    break;
                    case 'b': 
                    case 'B':
					    g_Flag_b = TRUE;
					    break;
                    case 'c': 
                    case 'C':
					    g_Flag_c = TRUE;
					    break;
                    case 'd': 
                    case 'D':
					    g_Flag_d = TRUE;
					    break;
                    case 'e': 
                    case 'E':
					    g_Flag_e = TRUE;
					    break;
                    case 'f':
		    case 'F':
					    g_Flag_f = TRUE;
					    // Get the string for this flag
					    pArg = CharNextA(argv[argno]);
					    pArg = CharNextA(pArg);
					    if (*pArg == ':')
					    {
                            char szTempString[MAX_PATH];
                            LPSTR pCmdStart = NULL;

						    pArg = CharNextA(pArg);
						    // Check if it's quoted
						    if (*pArg == '\"')
						    {
							    pArg = CharNextA(pArg);
							    pCmdStart = pArg;
							    while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
						    }
						    else
						    {
							    pCmdStart = pArg;
							    // while ((*pArg) && (*pArg != '/') && (*pArg != '-')){pArg = CharNextA(pArg);}
							    while (*pArg){pArg = CharNextA(pArg);}
						    }
						    *pArg = '\0';
                            lstrcpyA(szTempString, StripWhitespaceA(pCmdStart));

						    // Convert to unicode
						    // And assign it to the global.
						    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPTSTR) g_Flag_f_Data, _MAX_PATH);
					    }
                        break;
                    case 'g': 
                    case 'G':
					    g_Flag_g = TRUE;
					    break;
                    case 'z':
		    case 'Z':
					    g_Flag_z = TRUE;
					    // Get the string for this flag
					    pArg = CharNextA(argv[argno]);
					    pArg = CharNextA(pArg);
					    if (*pArg == ':')
					    {
                            char szTempString[MAX_PATH];
                            LPSTR pCmdStart = NULL;

						    pArg = CharNextA(pArg);
						    // Check if it's quoted
						    if (*pArg == '\"')
						    {
							    pArg = CharNextA(pArg);
							    pCmdStart = pArg;
							    while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
						    }
						    else
						    {
							    pCmdStart = pArg;
							    // while ((*pArg) && (*pArg != '/') && (*pArg != '-')){pArg = CharNextA(pArg);}
							    while (*pArg){pArg = CharNextA(pArg);}
						    }
						    *pArg = '\0';
                            lstrcpyA(szTempString, StripWhitespaceA(pCmdStart));

						    // Convert to unicode
						    // And assign it to the global.
						    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPTSTR) g_Flag_z_Data, _MAX_PATH);
					    }
                        break;
                    case '?':
                        goto main_exit_with_help;
                        break;
                } // end of switch
            } // if switch character found
        else
            {
	            char szTempFileName[_MAX_PATH];
	            szTempFileName[0] = '\0';

                if (_tcscmp(g_szFileList1, _T("")) == 0)
                {
                int iLen = min((_MAX_PATH-1), strlen(argv[argno]));
                strncpy(szTempFileName, argv[argno], iLen);

		    // Convert to unicode And assign it to the global.
		    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempFileName, -1, (LPTSTR) g_szFileList1, _MAX_PATH);
                }
                else
                {
                    if (_tcscmp(g_szFileList2, _T("")) == 0)
                    {
                        lstrcpyA(szTempFileName, argv[argno]);
				        // Convert to unicode And assign it to the global.
				        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempFileName, -1, (LPTSTR) g_szFileList2, _MAX_PATH);
                    }
                }

            } // non-switch char found
        } // for all arguments


    if (_tcscmp(g_Flag_z_Data, _T("")) == 0)
        {g_Flag_z = FALSE;}
    
	if (FALSE == DoStuff())
		{goto main_exit_with_help;}

	goto main_exit_gracefully;
	
main_exit_gracefully:
    exit(0);
    return TRUE;

main_exit_with_help:
    ShowHelp();
    exit(1);
    return FALSE;
}


void ShowHelp()
{
    TCHAR szModuleName_Full[_MAX_PATH];
    TCHAR szModuleName_Fname[_MAX_FNAME];
    GetModuleFileName(NULL, szModuleName_Full, _MAX_PATH);

    // Trim off the filename only.
    _tsplitpath(szModuleName_Full, NULL, NULL, szModuleName_Fname, NULL);

    TCHAR szMyBigString[255];

    if (MyLoadString(IDS_STRING1, szMyBigString))
       {OutputToConsole(szMyBigString,szModuleName_Fname);}

    if (MyLoadString(IDS_STRING2, szMyBigString))
       {OutputToConsole(szMyBigString,szModuleName_Fname);}

    if (MyLoadString(IDS_STRING3, szMyBigString))
       {OutputToConsole(szMyBigString);}

    if (MyLoadString(IDS_STRING4, szMyBigString))
       {OutputToConsole(szMyBigString,szModuleName_Fname);}

    if (MyLoadString(IDS_STRING5, szMyBigString))
       {OutputToConsole(szMyBigString);}

    if (MyLoadString(IDS_STRING6, szMyBigString))
       {OutputToConsole(szMyBigString,szModuleName_Fname);}

    if (MyLoadString(IDS_STRING7, szMyBigString))
       {OutputToConsole(szMyBigString);}

    if (MyLoadString(IDS_STRING8, szMyBigString))
       {OutputToConsole(szMyBigString,szModuleName_Fname);}

    if (MyLoadString(IDS_STRING9, szMyBigString))
       {OutputToConsole(szMyBigString);}

    if (MyLoadString(IDS_STRING10, szMyBigString))
       {OutputToConsole(szMyBigString,szModuleName_Fname);}

    if (MyLoadString(IDS_STRING11, szMyBigString))
       {OutputToConsole(szMyBigString);}

    if (MyLoadString(IDS_STRING15, szMyBigString))
       {OutputToConsole(szMyBigString,szModuleName_Fname);}

    if (MyLoadString(IDS_STRING16, szMyBigString))
       {OutputToConsole(szMyBigString);}


    /*
    OutputToConsole(_T("Flist -f FileList.txt -z:beforestring\r\n"));
    OutputToConsole(_T("    [For every line in FileList.txt when the 'beforestring' is found, the entries before it will be deleted]\r\n"));
    OutputToConsole(_T("Flist -g FileList.txt -z:afterstring\r\n"));
    OutputToConsole(_T("    [For every line in FileList.txt when the 'afterstring' is found, the entries after it will be deleted]\r\n"));
    */
    return;
}


//-------------------------------------------------------------------
BOOL DoStuff(void)
{
	BOOL bReturn = FALSE;
    if (TRUE == ProcessFor_A()){bReturn = TRUE; goto DoStuff_Exit;}
    if (TRUE == ProcessFor_B()){bReturn = TRUE; goto DoStuff_Exit;}
    if (TRUE == ProcessFor_C()){bReturn = TRUE; goto DoStuff_Exit;}
    if (TRUE == ProcessFor_D()){bReturn = TRUE; goto DoStuff_Exit;}
    if (TRUE == ProcessFor_E()){bReturn = TRUE; goto DoStuff_Exit;}
    if (TRUE == ProcessFor_F()){bReturn = TRUE; goto DoStuff_Exit;}
    goto DoStuff_Exit;

DoStuff_Exit:
	return bReturn;
}


void MissingFileListEntry1(TCHAR * szMySwitch)
{
    TCHAR szMyBigString[255];
    if (MyLoadString(IDS_STRING12, szMyBigString))
       {OutputToConsole(szMyBigString,szMySwitch);}
    return;
}
void MissingFileListEntry2(TCHAR * szMySwitch)
{
    TCHAR szMyBigString[255];
    if (MyLoadString(IDS_STRING13, szMyBigString))
       {OutputToConsole(szMyBigString,szMySwitch);}
    return;
}
void MissingFile(TCHAR * szMissingFileName)
{
    TCHAR szMyBigString[255];
    if (MyLoadString(IDS_STRING14, szMyBigString))
       {OutputToConsole(szMyBigString,szMissingFileName);}
    return;
}

//
// Flist -a FileList1.txt FileList2.Txt
//   [Prints out common entries between FileList1.txt and FileList2.txt]
//
int ProcessFor_A(void)
{
    int iReturn = FALSE;
    TCHAR szMySwitch[] = _T("-a");

    MyFileList FileList1 = {0};
    MyFileList FileList2 = {0};

    if (TRUE != g_Flag_a) {goto ProcessFor_A_Exit;}
    if (_tcscmp(g_szFileList1, _T("")) == 0)
    {
        MissingFileListEntry1(szMySwitch);
        goto ProcessFor_A_Exit;
    }
    if (_tcscmp(g_szFileList2, _T("")) == 0)
    {
        MissingFileListEntry2(szMySwitch);
        goto ProcessFor_A_Exit;
    }

	// Check if the file exists
    if (TRUE != IsFileExist(g_szFileList1))
    {
        MissingFile(g_szFileList1);
        goto ProcessFor_A_Exit;
    }
	// Check if the file exists
    if (TRUE != IsFileExist(g_szFileList2))
    {
        MissingFile(g_szFileList2);
        goto ProcessFor_A_Exit;
    }

    //
    // we've got everything we need.
    //
    FileList1.next = &FileList1; // make it a sentinel
    FileList1.prev = &FileList1; // make it a sentinel
    ReadFileIntoList(g_szFileList1, &FileList1);

    FileList2.next = &FileList2; // make it a sentinel
    FileList2.prev = &FileList2; // make it a sentinel
    ReadFileIntoList(g_szFileList2, &FileList2);

    //DumpOutLinkedFileList(&FileList1);
    //DumpOutLinkedFileList(&FileList2);

    //
    // Do the actual work
    //
    DumpOutCommonEntries(&FileList1, &FileList2);
    
    FreeLinkedFileList(&FileList1);
    FreeLinkedFileList(&FileList2);

    iReturn = TRUE;

ProcessFor_A_Exit:
    return iReturn;
}


int ProcessFor_B(void)
{
    int iReturn = FALSE;
    TCHAR szMySwitch[] = _T("-b");

    MyFileList FileList1 = {0};
    MyFileList FileList2 = {0};

    if (TRUE != g_Flag_b) {goto ProcessFor_B_Exit;}
    if (_tcscmp(g_szFileList1, _T("")) == 0)
    {
        MissingFileListEntry1(szMySwitch);
        goto ProcessFor_B_Exit;
    }
    if (_tcscmp(g_szFileList2, _T("")) == 0)
    {
        MissingFileListEntry2(szMySwitch);
        goto ProcessFor_B_Exit;
    }

	// Check if the file exists
    if (TRUE != IsFileExist(g_szFileList1))
    {
        MissingFile(g_szFileList1);
        goto ProcessFor_B_Exit;
    }
	// Check if the file exists
    if (TRUE != IsFileExist(g_szFileList2))
    {
        MissingFile(g_szFileList2);
        goto ProcessFor_B_Exit;
    }

    //
    // we've got everything we need.
    //
    FileList1.next = &FileList1; // make it a sentinel
    FileList1.prev = &FileList1; // make it a sentinel
    ReadFileIntoList(g_szFileList1, &FileList1);

    FileList2.next = &FileList2; // make it a sentinel
    FileList2.prev = &FileList2; // make it a sentinel
    ReadFileIntoList(g_szFileList2, &FileList2);

    //
    // Do the actual work
    //
    DumpOutDifferences(&FileList1, &FileList2);
    
    FreeLinkedFileList(&FileList1);
    FreeLinkedFileList(&FileList2);

    iReturn = TRUE;

ProcessFor_B_Exit:
    return iReturn;
}


int ProcessFor_C(void)
{
    int iReturn = FALSE;
    TCHAR szMySwitch[] = _T("-c");

    MyFileList FileList1 = {0};

    if (TRUE != g_Flag_c) {goto ProcessFor_C_Exit;}
    if (_tcscmp(g_szFileList1, _T("")) == 0)
    {
        MissingFileListEntry1(szMySwitch);
        goto ProcessFor_C_Exit;
    }

	// Check if the file exists
    if (TRUE != IsFileExist(g_szFileList1))
    {
        MissingFile(g_szFileList1);
        goto ProcessFor_C_Exit;
    }

    //
    // we've got everything we need.
    //
    FileList1.next = &FileList1; // make it a sentinel
    FileList1.prev = &FileList1; // make it a sentinel
    ReadFileIntoList(g_szFileList1, &FileList1);

    DumpOutLinkedFileList(&FileList1);
   
    FreeLinkedFileList(&FileList1);

    iReturn = TRUE;

ProcessFor_C_Exit:
    return iReturn;
}


int ProcessFor_D(void)
{
    int iReturn = FALSE;
    TCHAR szMySwitch[] = _T("-d");

    MyFileList FileList1 = {0};

    if (TRUE != g_Flag_d) {goto ProcessFor_D_Exit;}
    if (_tcscmp(g_szFileList1, _T("")) == 0)
    {
        MissingFileListEntry1(szMySwitch);
        goto ProcessFor_D_Exit;
    }

	// Check if the file exists
    if (TRUE != IsFileExist(g_szFileList1))
    {
        MissingFile(g_szFileList1);
        goto ProcessFor_D_Exit;
    }

    //
    // we've got everything we need.
    //
    FileList1.next = &FileList1; // make it a sentinel
    FileList1.prev = &FileList1; // make it a sentinel
    ReadFileIntoList(g_szFileList1, &FileList1);

    DumpOutLinkedFileList(&FileList1);
   
    FreeLinkedFileList(&FileList1);

    iReturn = TRUE;

ProcessFor_D_Exit:
    return iReturn;
}

int ProcessFor_E(void)
{
    int iReturn = FALSE;
    TCHAR szMySwitch[] = _T("-e");

    MyFileList FileList1 = {0};

    if (TRUE != g_Flag_e) {goto ProcessFor_E_Exit;}
    if (_tcscmp(g_szFileList1, _T("")) == 0)
    {
        MissingFileListEntry1(szMySwitch);
        goto ProcessFor_E_Exit;
    }

	// Check if the file exists
    if (TRUE != IsFileExist(g_szFileList1))
    {
        MissingFile(g_szFileList1);
        goto ProcessFor_E_Exit;
    }

    //
    // we've got everything we need.
    //
    FileList1.next = &FileList1; // make it a sentinel
    FileList1.prev = &FileList1; // make it a sentinel
    ReadFileIntoList(g_szFileList1, &FileList1);

    DumpOutLinkedFileList(&FileList1);
   
    FreeLinkedFileList(&FileList1);

    iReturn = TRUE;

ProcessFor_E_Exit:
    return iReturn;
}

int ProcessFor_F(void)
{
    int iReturn = FALSE;
    TCHAR szMySwitch[] = _T("-f");

    MyFileList FileList1 = {0};

    if (TRUE != g_Flag_f) {goto ProcessFor_F_Exit;}
    if (_tcscmp(g_szFileList1, _T("")) == 0)
    {
        MissingFileListEntry1(szMySwitch);
        goto ProcessFor_F_Exit;
    }

    // Check if the file exists
    if (TRUE != IsFileExist(g_szFileList1))
    {
        MissingFile(g_szFileList1);
        goto ProcessFor_F_Exit;
    }

    //
    // we've got everything we need.
    //
    FileList1.next = &FileList1; // make it a sentinel
    FileList1.prev = &FileList1; // make it a sentinel
    ReadFileIntoList(g_szFileList1, &FileList1);

    DumpOutLinkedFileList(&FileList1);
   
    FreeLinkedFileList(&FileList1);

    iReturn = TRUE;

ProcessFor_F_Exit:
    return iReturn;
}

#define BUFFER_MAX 1024
int MyLoadString(int nID, TCHAR *szResult)
{
    TCHAR buf[BUFFER_MAX];
    int iReturn = FALSE;

    if (g_hModuleHandle == NULL) {return iReturn;}
  
    if (LoadString(g_hModuleHandle, nID, buf, BUFFER_MAX))
        {
        iReturn = TRUE;
        _tcscpy(szResult, buf);
        }

    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\iismui\main.cpp ===
#include <stdio.h>
#include <windows.h>
#include "resource.h"

//
// Standard Win32 DLL Entry point
//
BOOL WINAPI DllMain(IN HANDLE DllHandle,IN DWORD  Reason,IN LPVOID Reserved)
{
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\dllhell\depends.h ===
#include "main.h"

#define MI_MODULE                  0
#define MI_DUPLICATE               1
#define MI_EXPORT_ERROR            2
#define MI_DUPLICATE_EXPORT_ERROR  3
#define MI_NOT_FOUND               4
#define MI_ERROR                   5

#define FI_IMPORT                  0
#define FI_IMPORT_ERROR            1
#define FI_EXPORT                  2
#define FI_EXPORT_FORWARD          3

VOID DoKoolShit(LPCTSTR Filename);
LPWSTR MakeWideStrFromAnsi(LPSTR psz);


//******************************************************************************
//***** CFunction
//******************************************************************************
class CFunction {
public:
   CFunction *m_pNext;
   int        m_ordinal;
   int        m_hint;
   DWORD_PTR  m_dwAddress;
   DWORD_PTR  m_dwExtra;
   CHAR       m_szName[1];

   // The m_dwExtra field's purpose is dependent on whether the CFunction
   // object is an export or an import.  For imports, it is a pointer to the
   // associated export in the child module.  If the import was not resolved,
   // then this value will be NULL.  For exports, the m_dwExtra field is a
   // pointer to a forward string.  If the export has no forward string, then
   // this member will be NULL.

   inline CFunction* GetAssociatedExport() { return (CFunction*)m_dwExtra; }
   inline LPCSTR     GetForwardString()    { return (LPCSTR)m_dwExtra; }
};


//******************************************************************************
//***** CModuleData
//******************************************************************************

// Every CModule object points to a CModuleData object. There is a single
// CModuleData for every unique module we process. If a module is duplicated in
// in our tree, there will be a CModule object for each instance, but they will
// all point to the same CModuleData object. For each unique module, a CModule
// object and a CModuleData object are created and the module is opened and
// processed. For every duplicate module, just a CModule object is created and
// pointed to the existing CModuleData. Duplicate modules are never opened since
// all the data that would be achieved by processing the file are already stored
// in the CModuleData.

class CModuleData {
public:
   // Flag to determine if this module has been processed yet.
   BOOL m_fProcessed;

   // Filled in by GetFileInfo()
   DWORD m_dwTimeStamp;
   DWORD m_dwSize;
   DWORD m_dwAttributes;

   // Filled in by GetModuleInfo()
   DWORD m_dwMachine;
   DWORD m_dwSubsystem;
   DWORD_PTR m_dwBaseAddress;
   DWORD m_dwImageVersion;
   DWORD m_dwLinkerVersion;
   DWORD m_dwOSVersion;
   DWORD m_dwSubsystemVersion;

   // Filled in by GetVersionInfo()
   DWORD m_dwFileVersionMS;
   DWORD m_dwFileVersionLS;
   DWORD m_dwProductVersionMS;
   DWORD m_dwProductVersionLS;

   // Build by BuildExports()
   CFunction *m_pExports;

   // Filled in by CheckForDebugInfo()
   BOOL m_fDebug;

   // Allocated and filled in by SetModuleError() if an error occurs.
   LPSTR m_pszError;
   BOOL  m_fFileNotFound;

   // Allocated and filled in by CreateModule()
   LPSTR m_szFile;
   CHAR  m_szPath[1];
};


//******************************************************************************
//***** CModule
//******************************************************************************
class CModule {
public:
   // Our next sibling module.
   CModule *m_pNext;

   // Head pointer to a list of dependent modules.
   CModule *m_pDependents;

   // Head pointer to a list of functions that our parent module imports from us.
   CFunction *m_pParentImports;

   // If we are a duplicate, then this will point to the original CModule.
   CModule *m_pModuleOriginal;

   // Depth of this module in our tree. Used to catch circular dependencies.
   int m_depth;

   // Set if any of our parent's imports can't be matched to one of our exports.
   BOOL m_fExportError;

   // Set if this module was included in the tree because of a forward call.
   BOOL m_fForward;

   // Set if this module was included via Delay Load import.
   BOOL m_fDelayLoad;

   // Pointer to the bulk of our module's processed information.
   CModuleData *m_pData;

   inline int GetImage() {
      return ((m_pData->m_fFileNotFound)            ? MI_NOT_FOUND :
              (m_pData->m_pszError)                 ? MI_ERROR :
              (m_pModuleOriginal && m_fExportError) ? MI_DUPLICATE_EXPORT_ERROR :
              (m_fExportError)                      ? MI_EXPORT_ERROR :
              (m_pModuleOriginal)                   ? MI_DUPLICATE : MI_MODULE);
   }
};

class CDepends {

// Internal variables
protected:
   // The following 5 members contain information about the currently opened
   // module file. We can store them here in our document since there is never
   // a time when two files are open at once.
   HANDLE                 m_hFile;
   LPVOID                 m_lpvFile;
   PIMAGE_FILE_HEADER     m_pIFH;
   PIMAGE_OPTIONAL_HEADER m_pIOH;
   PIMAGE_SECTION_HEADER  m_pISH;

   DWORD m_dwMachineType;

// Public variables
public:
   CModule           *m_pModuleRoot;

   BOOL  m_fOutOfMemory;
   BOOL  m_fCircularError;
   BOOL  m_fMixedMachineError;

   int      m_cxOrdinal;
   int      m_cxHint;
   int      m_cImports;
   int      m_cExports;

// Public Functions
public:
   CDepends();
   virtual  ~CDepends();
   BOOL     SetInitialFilename(LPCSTR lpszPathName);
   CModule* LoopThruAndPrintLosers(CModule *pModuleCur);
   void     DeleteContents();

// Internal functions
protected:
   CFunction* CreateFunction(int ordinal, int hint, LPCSTR szName, DWORD_PTR dwAddress, LPCSTR szForward = NULL);

   CModule*   CreateModule(LPCSTR szPath, int depth);
   void       DeleteModule(CModule *pModule);
   CModule*   FindModule(CModule *pModuleCur, LPCSTR szPath);

   void       SetModuleError(CModule *pModule, LPCTSTR szFormat, ...);
   BOOL       VerifyModule(CModule *pModule);
   BOOL       GetModuleInfo(CModule *pModule);

   BOOL       BuildImports(CModule *pModule);
   BOOL       BuildDelayImports(CModule *pModule);
   BOOL       WalkIAT(PIMAGE_THUNK_DATA pITDF, PIMAGE_THUNK_DATA pITDA, CModule *pModule, DWORD_PTR dwBase);
   BOOL       BuildExports(CModule *pModule);
   BOOL       VerifyParentImports(CModule *pModule);
   BOOL       ProcessModule(CModule *pModule);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\flist\other.h ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <tchar.h>

LPSTR  StripWhitespaceA(LPSTR pszString);
LPTSTR StripWhitespace(LPTSTR pszString);
LPTSTR StripLineFeedReturns(LPTSTR pszString );
BOOL   IsFileExist(LPCTSTR szFile);

void OutputToConsole(TCHAR *szInsertionStringFormat, TCHAR *szInsertionString);
void OutputToConsole(TCHAR *szInsertionStringFormat, int iTheInteger);
void OutputToConsole(TCHAR *szString);

typedef struct _MyFileList
{
    TCHAR szFileNameEntry[_MAX_PATH];
    struct _MyFileList *prev, *next;
} MyFileList;

void ReadFileIntoList(LPTSTR szTheFileNameToOpen,MyFileList *pListToFill);
void AddToLinkedListFileList(MyFileList *pMasterList,MyFileList *pEntryToadd);
void DumpOutLinkedFileList(MyFileList *pTheMasterFileList);
void FreeLinkedFileList(MyFileList *pList);
void DumpOutCommonEntries(MyFileList *pTheMasterFileList1, MyFileList *pTheMasterFileList2);
void DumpOutDifferences(MyFileList *pTheMasterFileList1, MyFileList *pTheMasterFileList2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\flist\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1
#define IDS_STRING2                     2
#define IDS_STRING3                     3
#define IDS_STRING4                     4
#define IDS_STRING5                     5
#define IDS_STRING6                     6
#define IDS_STRING7                     7
#define IDS_STRING8                     8
#define IDS_STRING9                     9
#define IDS_STRING10                    10
#define IDS_STRING11                    11
#define IDS_STRING12                    12
#define IDS_STRING13                    13
#define IDS_STRING14                    14
#define IDS_STRING15                    15
#define IDS_STRING16                    16

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\infutil2\filefind.h ===
typedef struct  _finddata_t SysFindData;
struct MyFindDataStruct 
{
    unsigned        attrib;   // File attribute
    time_t          time_create; //   Time of file creation ( 1L for FAT file systems)
    time_t          time_access; //   Time of last file access (1L for FAT file systems)
    time_t          time_write; //   Time of last write to file
    unsigned long size; //   Length of file in bytes
    char *          name; //   Null-terminated name of matched file/directory, without the path
    char *          ShortName;
};
typedef struct MyFindDataStruct finddata;


#define ALL_FILES		0xff
#define STRING_TABLE_SIZE   100000

int  InitStringTable(long size);
void EndStringTable();
void AddString(char * s, finddata * f);
long GetStringTableSize();
void ResetStringTable();
int  FindFirst(char * ss, unsigned attr, intptr_t * hFile, finddata * s);
int  FindNext(int attr, intptr_t hFile, finddata * s);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\iisvdir\main.cpp ===
#include <stdio.h>

#define INITGUID // must be before iadmw.h

#include <iadmw.h>      // Interface header
#include <iiscnfg.h>    // MD_ & IIS_MD_ defines

#define REASONABLE_TIMEOUT 1000

void  ShowHelp(void);
LPSTR StripWhitespace(LPSTR pszString);
BOOL  OpenMetabaseAndDoStuff(WCHAR * wszVDir, WCHAR * wszDir, int iTrans);
BOOL  GetVdirPhysicalPath(IMSAdminBase *pIMSAdminBase,WCHAR * wszVDir,WCHAR *wszStringPathToFill);
BOOL  AddVirtualDir(IMSAdminBase *pIMSAdminBase, WCHAR * wszVDir, WCHAR * wszDir);
BOOL  RemoveVirtualDir(IMSAdminBase *pIMSAdminBase, WCHAR * wszVDir);
HRESULT LoadAllData(IMSAdminBase * pmb, METADATA_HANDLE hMetabase,WCHAR *subdir, BYTE **buf, DWORD *size,DWORD *count);
HRESULT AddVirtualServer(UINT iServerNum, UINT iServerPort, WCHAR * wszDefaultVDirDir);
HRESULT DelVirtualServer(UINT iServerNum);

#define TRANS_ADD        0
#define TRANS_DEL        1
#define TRANS_PRINT_PATH 2
#define TRANS_ADD_VIRTUAL_SERVER 4
#define TRANS_DEL_VIRTUAL_SERVER 8

int __cdecl 
main(
     int argc,
     char *argv[]
)
{
    BOOL fRet = FALSE;
    int argno;
	char * pArg = NULL;
	char * pCmdStart = NULL;
    WCHAR wszPrintString[MAX_PATH];
    char szTempString[MAX_PATH];

    int iGotParamS = FALSE;
    int iGotParamP = FALSE;
    int iGotParamV = FALSE;
    int iDoDelete  = FALSE;
    int iDoWebPath = FALSE;
    int iTrans = 0;

    WCHAR wszDirPath[MAX_PATH];
    WCHAR wszVDirName[MAX_PATH];
    WCHAR wszTempString_S[MAX_PATH];
    WCHAR wszTempString_P[MAX_PATH];
    
    wszDirPath[0] = '\0';
    wszVDirName[0] = '\0';
    wszTempString_S[0] = '\0';
    wszTempString_P[0] = '\0';

    for(argno=1; argno<argc; argno++) {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' ) {
            switch (argv[argno][1]) {
                case 'd':
                case 'D':
                    iDoDelete = TRUE;
                    break;
                case 'o':
                case 'O':
                    iDoWebPath = TRUE;
                    break;
                case 's':
                case 'S':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        } else {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszTempString_S, 50);

                        iGotParamS = TRUE;
					}
                    break;
                case 'p':
                case 'P':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        } else {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszTempString_P, 50);

                        iGotParamP = TRUE;
					}
                    break;
                case 'v':
				case 'V':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') {
						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        } else {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
						MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szTempString, -1, (LPWSTR) wszVDirName, 50);

                        iGotParamV = TRUE;
					}
					break;
                case '?':
                    goto main_exit_with_help;
                    break;
                }
        } else {
            if ( *wszDirPath == '\0' ) {
                // if no arguments, then get the filename portion
                MultiByteToWideChar(CP_ACP, 0, argv[argno], -1, (LPWSTR) wszDirPath, 50);
            }
        }
    }


    iTrans = TRANS_ADD_VIRTUAL_SERVER;
    if (TRUE == iGotParamS)
    {
        HRESULT hr;
        UINT iServerNum = 100;

        if (iDoDelete) 
        {
            iTrans = TRANS_DEL_VIRTUAL_SERVER;

            if (*wszTempString_S == '\0')
            {
                // sorry, we need something in here
                goto main_exit_with_help;
            }

            iServerNum = _wtoi(wszTempString_S);

            hr = DelVirtualServer(iServerNum);
            if (FAILED(hr))
            {
                wsprintf(wszPrintString,L"FAILED to remove virtual server: W3SVC/%d\n", iServerNum);
                wprintf(wszPrintString);
                fRet = TRUE;
            }
            else
            {
                wsprintf(wszPrintString,L"SUCCESS:removed virtual server: W3SVC/%d\n", iServerNum);
                wprintf(wszPrintString);
                fRet = FALSE;
            }
            goto main_exit_gracefully;
        }
        else
        {
            if (TRUE == iGotParamP)
            {
                UINT iServerPort = 81;

                // we need the filename too
                if (*wszDirPath == '\0')
                {
                    // sorry, we need all 3 parameters
                    goto main_exit_with_help;
                }
                if (*wszTempString_S == '\0')
                {
                    // sorry, we need all 3 parameters
                    goto main_exit_with_help;
                }
                if (*wszTempString_P == '\0')
                {
                    // sorry, we need all 3 parameters
                    goto main_exit_with_help;
                }

                iServerNum = _wtoi(wszTempString_S);
                iServerPort = _wtoi(wszTempString_P);

                hr = AddVirtualServer(iServerNum, iServerPort, wszDirPath);
                if (FAILED(hr))
                {
                    wsprintf(wszPrintString,L"FAILED to create virtual server: W3SVC/%d=%s, port=%d. err=0x%x\n", iServerNum, wszDirPath, iServerPort,hr);
                    wprintf(wszPrintString);
                    fRet = TRUE;
                }
                else
                {
                    wsprintf(wszPrintString,L"SUCCESS:created virtual server: W3SVC/%d=%s, port=%d\n", iServerNum, wszDirPath, iServerPort);
                    wprintf(wszPrintString);
                    fRet = FALSE;
                }
                goto main_exit_gracefully;
            }
        }
    }

    iTrans = TRANS_ADD;
    if (iDoWebPath){
        iTrans = TRANS_PRINT_PATH;
    }
    else {
        if (iDoDelete) {
            iTrans = TRANS_DEL;
            if (FALSE == iGotParamV) {
                // sorry, we need at parameter -v
                goto main_exit_with_help;
            }
        } else if (FALSE == iGotParamV || *wszDirPath == '\0') {
                // sorry, we need both parameters
                goto main_exit_with_help;
            }
    }

    fRet = OpenMetabaseAndDoStuff(wszVDirName, wszDirPath, iTrans);


main_exit_gracefully:
    exit(fRet);

main_exit_with_help:
    ShowHelp();
    exit(fRet);
}


LPSTR StripWhitespace( LPSTR pszString )
{
    LPSTR pszTemp = NULL;

    if ( pszString == NULL ) {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenA(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}


void
ShowHelp()
{
    wprintf(L"Creates/Removes an IIS5 virtual directory to default web site\n\n");
    wprintf(L"IISVDIR [FullPath] [-v:VDirName] [-d] [-o]\n\n");
    wprintf(L"Instructions for add\\delete virtual directory:\n");
    wprintf(L"   FullPath     DOS path where vdir will point to (required for add)\n");
    wprintf(L"   -v:vdirname  The virtual dir name (required for both add\\delete)\n");
    wprintf(L"   -d           If set will delete vdir. if not set will add\n");
    wprintf(L"   -o           If set will printout web root path\n\n");
    wprintf(L"Instructions for add\\delete virtual server:\n");
    wprintf(L"   FullPath     DOS path where default vdir will point to in the virtual server (required for add)\n");
    wprintf(L"   -s:sitenum   For adding virtual server: The virtual server site number (required for both add\\delete)\n");
    wprintf(L"   -p:portnum   For adding virtual server: The virtual server port number (required for add)\n");
    wprintf(L"   -d           If set will delete virtual server. if not set will add\n");
    wprintf(L"\n");
    wprintf(L"Add Example: IISVDIR c:\\MyGroup\\MyStuff -v:Stuff\n");
    wprintf(L"Del Example: IISVDIR -v:Stuff -d\n");
    wprintf(L"Get Example: IISVDIR -o\n");
    wprintf(L"Add Virtual Server Example: IISVDIR c:\\MyGroup\\MyStuff -s:200 -p:81\n");
    wprintf(L"Del Virtual Server Example: IISVDIR -s:200 -d\n");
    return;
}


BOOL
OpenMetabaseAndDoStuff(
    WCHAR * wszVDir,
    WCHAR * wszDir,
    int iTrans
)
{
    BOOL fRet = FALSE;
    HRESULT hr;
    IMSAdminBase *pIMSAdminBase = NULL;  // Metabase interface pointer
    WCHAR wszPrintString[MAX_PATH + MAX_PATH];

    if( FAILED (CoInitializeEx( NULL, COINIT_MULTITHREADED )) ||
        FAILED (::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMSAdminBase)))  {
        return FALSE;
    }

    switch (iTrans) {
        case TRANS_DEL:
            if( RemoveVirtualDir( pIMSAdminBase, wszVDir)) {

                        hr = pIMSAdminBase->SaveData();

                        if( SUCCEEDED( hr )) {
                             fRet = TRUE;
                        }
                }

            if (TRUE == fRet) {
                wsprintf(wszPrintString,L"SUCCESS:removed vdir=%s\n", wszVDir);
                wprintf(wszPrintString);
            } else {
                wsprintf(wszPrintString,L"FAILED to remove vdir=%s, err=0x%x\n", wszVDir, hr);
                wprintf(wszPrintString);
            }
            break;
        case TRANS_ADD:
            if( AddVirtualDir( pIMSAdminBase, wszVDir, wszDir)) {

                        hr = pIMSAdminBase->SaveData();

                        if( SUCCEEDED( hr )) {
                             fRet = TRUE;
                        }
                }

            if (TRUE == fRet) {
                wsprintf(wszPrintString,L"SUCCESS: %s=%s", wszVDir, wszDir);
                wprintf(wszPrintString);
            } else {
                wsprintf(wszPrintString,L"FAILED to set: %s=%s, err=0x%x", wszVDir, wszDir, hr);
                wprintf(wszPrintString);
            }
            break;
        default:
            WCHAR wszRootPath[MAX_PATH];
            if (TRUE == GetVdirPhysicalPath(pIMSAdminBase,wszVDir,(WCHAR *) wszRootPath))
            {
                fRet = TRUE;
                if (_wcsicmp(wszVDir, L"") == 0) {
                    wsprintf(wszPrintString,L"/=%s", wszRootPath);
                } else {
                    wsprintf(wszPrintString,L"%s=%s", wszVDir, wszRootPath);
                }

                wprintf(wszPrintString);
            }
            else
            {
                wprintf(L"FAILED to get root path");
            }
            break;
    }
    
    if (pIMSAdminBase) {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }

    CoUninitialize();
    return fRet;
}


BOOL
GetVdirPhysicalPath(
    IMSAdminBase *pIMSAdminBase,
    WCHAR * wszVDir,
    WCHAR *wszStringPathToFill
    )
{
    HRESULT hr;
    BOOL fRet = FALSE;
    METADATA_HANDLE hMetabase = NULL;   // handle to metabase
    METADATA_RECORD mr;
    WCHAR  szTmpData[MAX_PATH];
    DWORD  dwMDRequiredDataLen;

    // open key to ROOT on website #1 (default)
    hr = pIMSAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                         L"/LM/W3SVC/1",
                         METADATA_PERMISSION_READ,
                         REASONABLE_TIMEOUT,
                         &hMetabase);
    if( FAILED( hr )) {
        return FALSE;
    }

    // Get the physical path for the WWWROOT
    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = 0;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = sizeof( szTmpData );
    mr.pbMDData       = reinterpret_cast<unsigned char *>(szTmpData);

    // if nothing specified get the root.
    if (_wcsicmp(wszVDir, L"") == 0) {
        WCHAR wszTempDir[MAX_PATH];
        wsprintf(wszTempDir,L"/ROOT/%s", wszVDir);
        hr = pIMSAdminBase->GetData( hMetabase, wszTempDir, &mr, &dwMDRequiredDataLen );
    } else {
        hr = pIMSAdminBase->GetData( hMetabase, L"/ROOT", &mr, &dwMDRequiredDataLen );
    }
    pIMSAdminBase->CloseKey( hMetabase );

    if( SUCCEEDED( hr )) {
        wcscpy(wszStringPathToFill,szTmpData);
        fRet = TRUE;
    }

    pIMSAdminBase->CloseKey( hMetabase );
    return fRet;
}


BOOL
AddVirtualDir(
    IMSAdminBase *pIMSAdminBase,
    WCHAR * wszVDir,
    WCHAR * wszDir
)
{
    HRESULT hr;
    BOOL    fRet = FALSE;
    METADATA_HANDLE hMetabase = NULL;       // handle to metabase
    WCHAR   wszTempPath[MAX_PATH];
    DWORD   dwMDRequiredDataLen = 0;
    DWORD   dwAccessPerm = 0;
    METADATA_RECORD mr;
    
    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         L"/LM/W3SVC/1/ROOT",
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         REASONABLE_TIMEOUT,
                         &hMetabase );

    // Create the key if it does not exist.
    if( FAILED( hr )) {
        return FALSE;
    }

    fRet = TRUE;

    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = 0;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = sizeof( wszTempPath );
    mr.pbMDData       = reinterpret_cast<unsigned char *>(wszTempPath);

    // see if MD_VR_PATH exists.
    hr = pIMSAdminBase->GetData( hMetabase, wszVDir, &mr, &dwMDRequiredDataLen );

    if( FAILED( hr )) {

        fRet = FALSE;
        if( hr == MD_ERROR_DATA_NOT_FOUND ||
            HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND ) {

            // Write both the key and the values if GetData() failed with any of the two errors.

            pIMSAdminBase->AddKey( hMetabase, wszVDir );

            mr.dwMDIdentifier = MD_VR_PATH;
            mr.dwMDAttributes = METADATA_INHERIT;
            mr.dwMDUserType   = IIS_MD_UT_FILE;
            mr.dwMDDataType   = STRING_METADATA;
            mr.dwMDDataLen    = (wcslen(wszDir) + 1) * sizeof(WCHAR);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(wszDir);

            // Write MD_VR_PATH value
            hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
            fRet = SUCCEEDED( hr );

            // Set the default authentication method
            if( fRet ) {

                DWORD dwAuthorization = MD_AUTH_NT;     // NTLM only.

                mr.dwMDIdentifier = MD_AUTHORIZATION;
                mr.dwMDAttributes = METADATA_INHERIT;   // need to inherit so that all subdirs are also protected.
                mr.dwMDUserType   = IIS_MD_UT_FILE;
                mr.dwMDDataType   = DWORD_METADATA;
                mr.dwMDDataLen    = sizeof(DWORD);
                mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAuthorization);

                // Write MD_AUTHORIZATION value
                hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
                fRet = SUCCEEDED( hr );
            }
        }
    }

    // In the following, do the stuff that we always want to do to the virtual dir, regardless of Admin's setting.

    if( fRet ) {

        dwAccessPerm = MD_ACCESS_READ | MD_ACCESS_SCRIPT;

        mr.dwMDIdentifier = MD_ACCESS_PERM;
        mr.dwMDAttributes = METADATA_INHERIT;    // Make it inheritable so all subdirectories will have the same rights.
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = DWORD_METADATA;
        mr.dwMDDataLen    = sizeof(DWORD);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAccessPerm);

        // Write MD_ACCESS_PERM value
        hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
        fRet = SUCCEEDED( hr );
    }

    if( fRet ) {

        PWCHAR  szDefLoadFile = L"Default.htm,Default.asp";

        mr.dwMDIdentifier = MD_DEFAULT_LOAD_FILE;
        mr.dwMDAttributes = 0;   // no need for inheritence
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = (wcslen(szDefLoadFile) + 1) * sizeof(WCHAR);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szDefLoadFile);

        // Write MD_DEFAULT_LOAD_FILE value
        hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
        fRet = SUCCEEDED( hr );
    }

    if( fRet ) {

        PWCHAR  wszKeyType = IIS_CLASS_WEB_VDIR_W;

        mr.dwMDIdentifier = MD_KEY_TYPE;
        mr.dwMDAttributes = 0;   // no need for inheritence
        mr.dwMDUserType   = IIS_MD_UT_SERVER;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = (wcslen(wszKeyType) + 1) * sizeof(WCHAR);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(wszKeyType);

        // Write MD_DEFAULT_LOAD_FILE value
        hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
        fRet = SUCCEEDED( hr );
    }

    pIMSAdminBase->CloseKey( hMetabase );

    return fRet;
}


BOOL
RemoveVirtualDir(
    IMSAdminBase *pIMSAdminBase,
    WCHAR * wszVDir
)
{
    METADATA_HANDLE hMetabase = NULL;       // handle to metabase
    HRESULT hr;

    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         L"/LM/W3SVC/1/ROOT",
                         METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                         REASONABLE_TIMEOUT,
                         &hMetabase );

    if( FAILED( hr )) {
        return FALSE; 
    }

    // We don't check the return value since the key may already 
    // not exist and we could get an error for that reason.
    pIMSAdminBase->DeleteKey( hMetabase, wszVDir );

    pIMSAdminBase->CloseKey( hMetabase );    

    return TRUE;
}


HRESULT LoadAllData(IMSAdminBase * pmb, 
                       METADATA_HANDLE hMetabase,
					   WCHAR *subdir, 
					   BYTE **buf, 
					   DWORD *size,
					   DWORD *count) {
	DWORD dataSet;
	DWORD neededSize;
	HRESULT hr;
	//
	// Try to get the property names.
	//
	hr = pmb->GetAllData(hMetabase,
					subdir,
					METADATA_NO_ATTRIBUTES,
					ALL_METADATA,
					ALL_METADATA,
					count,
					&dataSet,
					*size,
					*buf,
					&neededSize);
	if (!SUCCEEDED(hr)) {
        DWORD code = ERROR_INSUFFICIENT_BUFFER;

        if (hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
            delete *buf;
            *buf = 0;
            *size = neededSize;
            *buf = new BYTE[neededSize];

            hr = pmb->GetAllData(hMetabase,
							subdir,
							METADATA_NO_ATTRIBUTES,
							ALL_METADATA,
							ALL_METADATA,
							count,
							&dataSet,
	 						*size,
							*buf,
							&neededSize);

		}
	}
	return hr;
}

const DWORD getAllBufSize = 4096*2;
HRESULT 
OpenMetabaseAndGetAllData(void)
{
    HRESULT hr = E_FAIL;
    IMSAdminBase *pIMSAdminBase = NULL;  // Metabase interface pointer
    WCHAR wszPrintString[MAX_PATH + MAX_PATH];
    METADATA_HANDLE hMetabase = NULL;       // handle to metabase
    DWORD bufSize = getAllBufSize;
    BYTE *buf = new BYTE[bufSize];
    DWORD count=0;
    DWORD linesize =0;

    BYTE *pBuf1=NULL;
    BYTE *pBuf2=NULL;

    if( FAILED (CoInitializeEx( NULL, COINIT_MULTITHREADED )) ||
        FAILED (::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMSAdminBase)))  {
        wprintf(L"CoCreateInstance. FAILED. code=0x%x\n",hr);
        return hr;
    }

    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                         L"/Schema/Properties",
                         METADATA_PERMISSION_READ,
                         REASONABLE_TIMEOUT,
                         &hMetabase );

    if( FAILED( hr )) {
        wprintf(L"pIMSAdminBase->OpenKey. FAILED. code=0x%x\n",hr);
       goto OpenMetabaseAndGetAllData_Exit;
    }
	hr = LoadAllData(pIMSAdminBase, hMetabase, L"Names", &buf, &bufSize, &count);
    if( FAILED( hr )) {
        wprintf(L"LoadAllData: FAILED. code=0x%x\n",hr);
       goto OpenMetabaseAndGetAllData_Exit;
    }

    wprintf(L"LoadAllData: Succeeded. bufSize=0x%x, count=0x%x, buf=%p, end of buf=%p\n",bufSize,count,buf,buf+bufSize);
    wprintf(L"Here is the last 1000 bytes, that the client received.\n");

    linesize = 0;
    pBuf1 = buf+bufSize - 1000;
    for (int i=0;pBuf1<buf+bufSize;pBuf1++,i++) {
        if (NULL == *pBuf1) {
            wprintf(L".");
        }
        else {
            wprintf(L"%c",*pBuf1);
        }
        linesize++;

        if (linesize >= 16) {
            linesize=0;
            wprintf(L"\n");
        }
    }

    wprintf(L"\n");

    hr = ERROR_SUCCESS;

OpenMetabaseAndGetAllData_Exit:
    if (pIMSAdminBase) {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }

    CoUninitialize();
    return hr;
}


// Calculate the size of a Multi-String in WCHAR, including the ending 2 '\0's.
int GetMultiStrSize(LPWSTR p)
{
    int c = 0;

    while (1) {
        if (*p) {
            p++;
            c++;
        } else {
            c++;
            if (*(p+1)) {
                p++;
            } else {
                c++;
                break;
            }
        }
    }
    return c;
}


HRESULT DelVirtualServer(UINT iServerNum)
{
    HRESULT hr = E_FAIL;
    return hr;
}


// iServerNum       the virtual server number
// iServerPort      the virtual server port (port 80 is the default site's port,so you can't use this and you can't use one that is already in use)
// wszDir           the physical directory where the default site is located
HRESULT AddVirtualServer(UINT iServerNum, UINT iServerPort, WCHAR * wszDefaultVDirDir)
{
    HRESULT hr = E_FAIL;
    IMSAdminBase *pIMSAdminBase = NULL;  // Metabase interface pointer
    METADATA_HANDLE hMetabase = NULL;       // handle to metabase
    METADATA_RECORD mr;

    WCHAR wszMetabasePath[_MAX_PATH];
    WCHAR wszMetabasePathRoot[10];
    WCHAR wszData[_MAX_PATH];
    DWORD dwData = 0;

    METADATA_HANDLE hKeyBase = METADATA_MASTER_ROOT_HANDLE;

    if( FAILED (CoInitializeEx( NULL, COINIT_MULTITHREADED )) ||
        FAILED (::CoCreateInstance(CLSID_MSAdminBase,
                          NULL,
                          CLSCTX_ALL,
                          IID_IMSAdminBase,
                          (void **)&pIMSAdminBase))) {
        wprintf(L"CoCreateInstance. FAILED. code=0x%x\n",hr);
        return hr;
    }

    // Create the new node
    wsprintf(wszMetabasePath,L"LM/W3SVC/%i",iServerNum);

    // try to open the specified metabase node, it might already exist
    hr = pIMSAdminBase->OpenKey(hKeyBase,
                         wszMetabasePath,
                         METADATA_PERMISSION_READ,
                         REASONABLE_TIMEOUT,
                         &hMetabase);
    if (hr == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
        hr = pIMSAdminBase->CloseKey(hMetabase);

        // open the metabase root handle
        hr = pIMSAdminBase->OpenKey(hKeyBase,
                            L"",
                            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                            REASONABLE_TIMEOUT,&hMetabase);
        if( FAILED( hr )) {
            // if we can't even open the root handle, then we're pretty hosed
            wprintf(L"1OpenKey. FAILED. code=0x%x\n",hr);
            goto AddVirtualServer_Exit;
        }

        // and add our node
        hr = pIMSAdminBase->AddKey(hMetabase, wszMetabasePath);
        if (FAILED(hr)) {
            wprintf(L"AddKey. FAILED. code=0x%x\n",hr);
            pIMSAdminBase->CloseKey(hMetabase);
            goto AddVirtualServer_Exit;
        } else {
            hr = pIMSAdminBase->CloseKey(hMetabase);
            if (FAILED(hr)) {
                goto AddVirtualServer_Exit;
            } else {
                // open it again
                hr = pIMSAdminBase->OpenKey(hKeyBase,
                    wszMetabasePath,
                    METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                    REASONABLE_TIMEOUT,
                    &hMetabase);
                if (FAILED(hr)) {
                    wprintf(L"2OpenKey. FAILED. code=0x%x\n",hr);
                    pIMSAdminBase->CloseKey(hMetabase);
                    goto AddVirtualServer_Exit;
                }
            }
        }
    } else {
        if (FAILED(hr))
        {
            wprintf(L"3OpenKey. FAILED. code=0x%x\n",hr);
            goto AddVirtualServer_Exit;
        }
        else
        {
            // we were able to open the path, so it must already exist!
            hr = ERROR_ALREADY_EXISTS;
            pIMSAdminBase->CloseKey(hMetabase);
            goto AddVirtualServer_Exit;
        }
    }


    // We should have a brand new Key now...

    //
    // Create stuff in the node of this path!
    //

    //
    // /LM/W3SVC/1/KeyType
    //
    memset( (PVOID)wszData, 0, sizeof(wszData));
    wcscpy(wszData,IIS_CLASS_WEB_SERVER_W);

    mr.dwMDIdentifier = MD_KEY_TYPE;
    mr.dwMDAttributes = 0;   // no need for inheritence
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = (wcslen(wszData) + 1) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(wszData);
    hr = pIMSAdminBase->SetData( hMetabase, L"", &mr );
    if (FAILED(hr)) {
        wprintf(L"SetData[MD_KEY_TYPE]. FAILED. code=0x%x\n",hr);
    }

    //
    // /W3SVC/1/ServerBindings
    //
    memset( (PVOID)wszData, 0, sizeof(wszData));
    wsprintf(wszData, L":%d:", iServerPort);
       
    mr.dwMDIdentifier = MD_SERVER_BINDINGS;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = MULTISZ_METADATA;
    mr.dwMDDataLen    = GetMultiStrSize(wszData) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(wszData);

    hr = pIMSAdminBase->SetData( hMetabase, L"", &mr );
    if (FAILED(hr)) {
        wprintf(L"SetData[MD_SERVER_BINDINGS]. FAILED. code=0x%x\n",hr);
    }

    //
    // /W3SVC/1/SecureBindings
    //
    memset( (PVOID)wszData, 0, sizeof(wszData));
    wcscpy(wszData, L" ");
  
    mr.dwMDIdentifier = MD_SECURE_BINDINGS;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = MULTISZ_METADATA;
    mr.dwMDDataLen    = GetMultiStrSize(wszData) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(wszData);

    hr = pIMSAdminBase->SetData( hMetabase, L"", &mr );
    if (FAILED(hr)) {
        wprintf(L"SetData[MD_SECURE_BINDINGS]. FAILED. code=0x%x\n",hr);
    }

    //
    // Create stuff in the /Root node of this path!
    //
    wcscpy(wszMetabasePathRoot, L"/Root");
    wcscpy(wszData,IIS_CLASS_WEB_VDIR_W);

    // W3SVC/3/Root/KeyType
    mr.dwMDIdentifier = MD_KEY_TYPE;
    mr.dwMDAttributes = 0;   // no need for inheritence
    mr.dwMDUserType   = IIS_MD_UT_SERVER;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = (wcslen(wszData) + 1) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(wszData);
    hr = pIMSAdminBase->SetData( hMetabase, wszMetabasePathRoot, &mr );
    if (FAILED(hr)) {
        wprintf(L"SetData[MD_KEY_TYPE]. FAILED. code=0x%x\n",hr);
    }

    // W3SVC/3/Root/VrPath
    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = (wcslen(wszDefaultVDirDir) + 1) * sizeof(WCHAR);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(wszDefaultVDirDir);
    hr = pIMSAdminBase->SetData( hMetabase, wszMetabasePathRoot, &mr );
    if (FAILED(hr)) {
        wprintf(L"SetData[MD_VR_PATH]. FAILED. code=0x%x\n",hr);
    }

    // W3SVC/3/Root/Authorizaton
    dwData = MD_AUTH_ANONYMOUS | MD_AUTH_NT;
    mr.dwMDIdentifier = MD_AUTHORIZATION;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = DWORD_METADATA;
    mr.dwMDDataLen    = sizeof(DWORD);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwData);
    hr = pIMSAdminBase->SetData( hMetabase, wszMetabasePathRoot, &mr );
    if (FAILED(hr)) {
        wprintf(L"SetData[MD_AUTHORIZATION]. FAILED. code=0x%x\n",hr);
    }

    // W3SVC/3/Root/AccessPerm
    dwData = MD_ACCESS_SCRIPT | MD_ACCESS_READ;
    mr.dwMDIdentifier = MD_ACCESS_PERM;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = DWORD_METADATA;
    mr.dwMDDataLen    = sizeof(DWORD);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwData);
    hr = pIMSAdminBase->SetData( hMetabase, wszMetabasePathRoot, &mr );
    if (FAILED(hr)) {
        wprintf(L"SetData[MD_ACCESS_PERM]. FAILED. code=0x%x\n",hr);
    }

    // W3SVC/3/Root/DirectoryBrowsing
    dwData = MD_DIRBROW_SHOW_DATE
        | MD_DIRBROW_SHOW_TIME
        | MD_DIRBROW_SHOW_SIZE
        | MD_DIRBROW_SHOW_EXTENSION
        | MD_DIRBROW_LONG_DATE
        | MD_DIRBROW_LOADDEFAULT;
        // | MD_DIRBROW_ENABLED;

    mr.dwMDIdentifier = MD_DIRECTORY_BROWSING;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = DWORD_METADATA;
    mr.dwMDDataLen    = sizeof(DWORD);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwData);
    hr = pIMSAdminBase->SetData( hMetabase, wszMetabasePathRoot, &mr );
    if (FAILED(hr)) {
        wprintf(L"SetData[MD_DIRECTORY_BROWSING]. FAILED. code=0x%x\n",hr);
    }

    /*
    dwData = 0;
    mr.dwMDIdentifier = MD_SERVER_AUTOSTART;
    mr.dwMDAttributes = METADATA_INHERIT;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = DWORD_METADATA;
    mr.dwMDDataLen    = sizeof(DWORD);
    mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwData);
    hr = pIMSAdminBase->SetData( hMetabase, wszMetabasePathRoot, &mr );
    if (FAILED(hr)) {
        wprintf(L"SetData[MD_SERVER_AUTOSTART]. FAILED. code=0x%x\n",hr);
    }
    */

    pIMSAdminBase->CloseKey(hMetabase);

AddVirtualServer_Exit:
    if (pIMSAdminBase) {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }

    CoUninitialize();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\iismui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1
#define IDS_STRING2                     2
#define IDS_STRING3                     3

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\flist\other.cpp ===
#include <stdio.h>
#include <fstream.h>
#include <windows.h>
#include <tchar.h>
#include "other.h"

extern int g_Flag_a;
extern int g_Flag_b;
extern int g_Flag_c;
extern int g_Flag_d;
extern int g_Flag_e;
extern int g_Flag_f;
extern TCHAR * g_Flag_f_Data;
extern int g_Flag_g;
extern int g_Flag_z;
extern TCHAR * g_Flag_z_Data;


void OutputToConsole(TCHAR *szInsertionStringFormat, TCHAR *szInsertionString)
{
    TCHAR BigString[1000];
    _stprintf(BigString,szInsertionStringFormat,szInsertionString);
    _tprintf(BigString);
    return;
}


void OutputToConsole(TCHAR *szInsertionStringFormat, int iTheInteger)
{
    TCHAR BigString[1000];
    _stprintf(BigString,szInsertionStringFormat,iTheInteger);
    _tprintf(BigString);
    return;
}


void OutputToConsole(TCHAR *szString)
{
    _tprintf(szString);
    return;
}


void DumpOutCommonEntries(MyFileList *pTheMasterFileList1, MyFileList *pTheMasterFileList2)
{
    MyFileList *t = NULL;
    MyFileList *t2 = NULL;
    t = pTheMasterFileList1->next;
    while (t != pTheMasterFileList1)
    {
        //
        // Loop thru all of list 2 looking for this entry
        //
        t2 = pTheMasterFileList2->next;
        while (t2 != pTheMasterFileList2)
        {
            if (0 == _tcsicmp(t->szFileNameEntry, t2->szFileNameEntry))
            {
                //OutputToConsole(_T("%s\r\n"),t->szFileNameEntry);
                OutputToConsole(_T("%s\n"),t->szFileNameEntry);
            }
            t2 = t2->next;
        }

        // Get the next entry from list 2
        t = t->next;
    }
    return;
}


void DumpOutLinkedFileList(MyFileList *pTheMasterFileList)
{
    MyFileList *t = NULL;
    t = pTheMasterFileList->next;
    while (t != pTheMasterFileList)
    {
        //OutputToConsole(_T("%s\r\n"),t->szFileNameEntry);
        OutputToConsole(_T("%s\n"),t->szFileNameEntry);
        t = t->next;
    }
    return;
}


void DumpOutDifferences(MyFileList *pTheMasterFileList1, MyFileList *pTheMasterFileList2)
{
    int iFound = FALSE;

    MyFileList *t = NULL;
    MyFileList *t2 = NULL;

    // Loop thru list #1
    t = pTheMasterFileList1->next;
    while (t != pTheMasterFileList1)
    {
        //
        // Loop thru all of list 2 looking for this entry
        //
        iFound = FALSE;
        t2 = pTheMasterFileList2->next;
        while (t2 != pTheMasterFileList2 && iFound != TRUE)
        {
            if (0 == _tcsicmp(t->szFileNameEntry, t2->szFileNameEntry))
                {iFound = TRUE;}
            t2 = t2->next;
        }
        if (FALSE == iFound)
        {
            //OutputToConsole(_T("%s\r\n"),t->szFileNameEntry);
            OutputToConsole(_T("%s\n"),t->szFileNameEntry);
        }

        // Get the next entry from list 2
        t = t->next;
    }

    // Loop thru list #2
    t2 = pTheMasterFileList2->next;
    while (t2 != pTheMasterFileList2)
    {
        //
        // Loop thru all of list 2 looking for this entry
        //
        iFound = FALSE;
        t = pTheMasterFileList1->next;
        while (t != pTheMasterFileList1 && iFound != TRUE)
        {
            if (0 == _tcsicmp(t2->szFileNameEntry, t->szFileNameEntry))
                {iFound = TRUE;}
            t = t->next;
        }
        if (FALSE == iFound)
        {
            //OutputToConsole(_T("%s\r\n"),t2->szFileNameEntry);
            OutputToConsole(_T("%s\n"),t2->szFileNameEntry);
        }

        // Get the next entry from list 2
        t2 = t2->next;
    }

    return;
}


void ReadFileIntoList(LPTSTR szTheFileNameToOpen,MyFileList *pListToFill)
{
    ifstream inputfile;
    char fileinputbuffer[_MAX_PATH];
    TCHAR UnicodeFileBuf[_MAX_PATH];
    TCHAR UnicodeFileBuf_Real[_MAX_PATH];

    TCHAR szDrive_only[_MAX_DRIVE];
    TCHAR szPath_only[_MAX_PATH];
    TCHAR szFilename_only[_MAX_FNAME];
    TCHAR szFilename_ext_only[_MAX_EXT];

    char szAnsiFileName[_MAX_PATH];
    WideCharToMultiByte( CP_ACP, 0, (TCHAR*)szTheFileNameToOpen, -1, szAnsiFileName, _MAX_PATH, NULL, NULL );

    // Read flat file and put into huge array
    inputfile.open(szAnsiFileName, ios::in);
    inputfile.getline(fileinputbuffer, sizeof(fileinputbuffer));
    do
    {
        if (*fileinputbuffer)
        {
            // convert to unicode.
            MultiByteToWideChar(CP_ACP, 0, (LPCSTR)fileinputbuffer, -1, (LPTSTR) UnicodeFileBuf, _MAX_PATH);

            _tcscpy(UnicodeFileBuf_Real, UnicodeFileBuf);
            if (TRUE == g_Flag_c)
            {
                //  take out the path and only store the filename.
                _tsplitpath(UnicodeFileBuf, NULL, NULL, szFilename_only, szFilename_ext_only);

                _tcscpy(UnicodeFileBuf_Real, szFilename_only);
                _tcscat(UnicodeFileBuf_Real, szFilename_ext_only);
                _tcscat(UnicodeFileBuf_Real, _T("\0\0"));
            }
            else if (TRUE == g_Flag_d)
                {
                    //  take out the path and only store the filename.
                    _tsplitpath(UnicodeFileBuf, szDrive_only, szPath_only, NULL, NULL);

                    _tcscpy(UnicodeFileBuf_Real, szDrive_only);
                    _tcscat(UnicodeFileBuf_Real, szPath_only);
                    _tcscat(UnicodeFileBuf_Real, _T("\0\0"));
                }

            //
            // trim spaces or tabs from either side
            //
            if (TRUE == g_Flag_e)
            {
                TCHAR *p;
                p = UnicodeFileBuf_Real;
                _tcscpy(UnicodeFileBuf_Real,StripWhitespace(p));
            }

            //
            // remove everything after the "=" character
            //
#ifndef _WIN64
            if (TRUE == g_Flag_f)
            {
                TCHAR *p = NULL;
                TCHAR *pDest = NULL;
                TCHAR MyDelim = _T('=');
                p = UnicodeFileBuf_Real;

                // check if there is a defined delimiter.
                if( _tcsicmp((const wchar_t *) &g_Flag_f_Data, _T("") ) != 0)
                {
                    MyDelim = (TCHAR) &g_Flag_f_Data[0];
                }

                pDest = _tcsrchr(p, MyDelim);
                if (pDest){*pDest = _T('\0');}
            }
#endif

            //
            // Trim any /r/n characters from the end.
            //
            TCHAR *p;
            p = UnicodeFileBuf_Real;
            _tcscpy(UnicodeFileBuf_Real,StripLineFeedReturns(p));

            MyFileList *pNew = NULL;
            pNew = (MyFileList *)calloc(1, sizeof(MyFileList));
            if (pNew)
            {
                //OutputToConsole(_T("Entry=%s"),UnicodeFileBuf_Real);
                _tcscpy(pNew->szFileNameEntry, UnicodeFileBuf_Real);
                pNew->prev = NULL;
                pNew->next = NULL;
            }

            // Add it in there.
            AddToLinkedListFileList(pListToFill, pNew);
        }
    } while (inputfile.getline(fileinputbuffer, sizeof(fileinputbuffer)));
	inputfile.close();

    return;
}


void AddToLinkedListFileList(MyFileList *pMasterList,MyFileList *pEntryToadd)
{
    MyFileList *pTempMasterList;
    int i;
    int bFound = FALSE;
    BOOL fReplace = TRUE;
    if (!pEntryToadd) {return;}

    pTempMasterList = pMasterList->next;
    while (pTempMasterList != pMasterList) 
    {
        i = _tcsicmp(pTempMasterList->szFileNameEntry, pEntryToadd->szFileNameEntry);

        // if the next entry in the list is less than what we have.
        // then
        if (i < 0) 
        {
            pTempMasterList = pTempMasterList->next;
            // continue
        }

        if (i == 0) 
        {
            if (fReplace)
            {
                // replace pTempMasterList
                pEntryToadd->next = pTempMasterList->next;
                pEntryToadd->prev = pTempMasterList->prev;
                (pTempMasterList->prev)->next = pEntryToadd;
                (pTempMasterList->next)->prev = pEntryToadd;
                free(pTempMasterList);
            }
            else 
            {
                // don't replace pTempMasterList
                free(pEntryToadd);
            }
            return;
        }

        if (i > 0) 
        {
            // location found: insert before pTempMasterList
            break;
        }
    }

    // insert before pTempMasterList
    pEntryToadd->next = pTempMasterList;
    pEntryToadd->prev = pTempMasterList->prev;
    (pTempMasterList->prev)->next = pEntryToadd;
    pTempMasterList->prev = pEntryToadd;
    return;
}


void FreeLinkedFileList(MyFileList *pList)
{
    if (!pList) {return;}

    MyFileList *t = NULL, *p = NULL;

    t = pList->next;
    while (t != pList) 
    {
        p = t->next;
        free(t);
        t = p;
    }

    t->prev = t;
    t->next = t;
    return;
}


BOOL IsFileExist(LPCTSTR szFile)
{
    // Check if the file has expandable Environment strings
    LPTSTR pch = NULL;
    pch = _tcschr( (LPTSTR) szFile, _T('%'));
    if (pch) 
    {
        TCHAR szValue[_MAX_PATH];
        _tcscpy(szValue,szFile);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szFile, szValue, _MAX_PATH))
            {_tcscpy(szValue,szFile);}

        return (GetFileAttributes(szValue) != 0xFFFFFFFF);
    }
    else
    {
        return (GetFileAttributes(szFile) != 0xFFFFFFFF);
    }
}


//***************************************************************************
//* NAME:       StripWhitespace                                             *
//* SYNOPSIS:   Strips spaces and tabs from both sides of given string.     *
//***************************************************************************
LPSTR StripWhitespaceA( LPSTR pszString )
{
    LPSTR pszTemp = NULL;

    if ( pszString == NULL ) {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenA(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}

//***************************************************************************
//* NAME:       StripWhitespace                                             *
//* SYNOPSIS:   Strips spaces and tabs from both sides of given string.     *
//***************************************************************************
LPTSTR StripWhitespace(LPTSTR pszString )
{
    LPTSTR pszTemp = NULL;

    if ( pszString == NULL ) {
        return NULL;
    }

    while ( *pszString == _T(' ') || *pszString == _T('\t') ) {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == _T('\0') ) {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenW(pszString) - 1;

    while ( *pszString == _T(' ') || *pszString == _T('\t') ) {
        *pszString = _T('\0');
        pszString -= 1;
    }

    return pszTemp;
}


//***************************************************************************
//* NAME:       StripLineFeedReturns                                        *
//* SYNOPSIS:   Strips linefeeds and returns from both sides of given string*
//***************************************************************************
LPTSTR StripLineFeedReturns(LPTSTR pszString )
{
    LPTSTR pszTemp = NULL;

    if ( pszString == NULL ) {
        return NULL;
    }

    while ( *pszString == _T('\n') || *pszString == _T('\r') ) {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == _T('\0') ) {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenW(pszString) - 1;

    while ( *pszString == _T('\n') || *pszString == _T('\r') ) {
        *pszString = _T('\0');
        pszString -= 1;
    }

    return pszTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\infutil2\filefind.cpp ===
/********************************************************************************
* Description:
*	 Functions that do what _dos_findfirst and _dos_findnext SHOULD do
*******************************************************************************/
#include <io.h>
#include <string.h>
#include <malloc.h>
#include "filefind.h"

static char * StringTable;
static long offset = 0 ;
static long MaxOffset;


int InitStringTable(long size)
{
	StringTable=(char *) malloc(size);
    ResetStringTable();
	return StringTable != 0;
}

void EndStringTable()
{
	if (StringTable)
		free (StringTable);

}

void AddString (char * StringToAdd, finddata * s)
{
	int len;

	len=strlen(StringToAdd);
	
   	strcpy(StringTable+offset, StringToAdd);
	s->name=StringTable+offset;
	offset+=len+1;
	if (len>12) {
		strcpy(StringTable+offset, StringToAdd);
		StringTable[offset+11]='~';
		StringTable[offset+12]='\0';
		s->ShortName=StringTable+offset;
		offset+=13;
	}
	else
		s->ShortName=s->name;
	
	MaxOffset= (offset > MaxOffset) ? offset : MaxOffset;
	
}

long GetStringTableSize()
{
	return MaxOffset;
}

void ResetStringTable()
{
	offset=0;
}

int
FindFirst(char * ss, unsigned attr, intptr_t * hFile, finddata * s)
{
	int         found;
	SysFindData s2;
	
	*hFile=_findfirst(ss, &s2);
        found = (*hFile != -1);
	if (found) {
		if ( attr == ALL_FILES ) {
			while(found && s2.name[0] == '.')
				found=(_findnext(*hFile, &s2) == 0);
		}
		else if ( attr & _A_SUBDIR )  {
			while(found && (((s2.attrib & _A_SUBDIR) == 0) || s2.name[0] == '.'))
				found=(_findnext(*hFile, &s2) == 0);
		}
		else  {
			while(found && (s2.attrib & _A_SUBDIR))
				found=(_findnext(*hFile, &s2) == 0);
		}
		if (!found)
			_findclose(*hFile);
		else {
			memcpy(s, &s2, sizeof(finddata));
			AddString(s2.name, s);
		}
    }
	return(found);
} /* FindFirst() */






int
FindNext(int attr, intptr_t hFile, finddata * s)
{
	int      found;
	SysFindData s2;

	
	found=(_findnext(hFile, &s2) == 0);
	if (found  &&  attr != ALL_FILES) {
		if ( attr & _A_SUBDIR )	{
			while(found && (((s2.attrib & _A_SUBDIR) == 0) || s2.name[0] == '.'))
				found=(_findnext(hFile, &s2) == 0);
		}
		else {
			while(found && (s2.attrib & _A_SUBDIR))
				found=(_findnext(hFile, &s2) == 0);
		}
    }
	if (!found)
		_findclose(hFile);
	else {
		memcpy(s, &s2, sizeof(finddata));
		AddString(s2.name, s);
	}
	return(found);
} /* FindNext() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\install\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by start.rc
//
#define IDS_NOTSUPPORT                  1
#define IDS_CANTRUN                     2
#define IDS_LOAD1                       3
#define IDS_RUN_NTS                     4
#define IDS_RUN_NTW                     5
#define IDS_RUN_W95                     6
#define IDS_UNABLE_TO_RUN               7
#define IDS_UNABLE_TO_FIND              8
#define IDS_SETUP                       9
#define IDS_TITLE                       9
#define IDS_SETUP_LOAD                  10
#define IDS_ERROR                       10
#define IDS_UNKNOWN_SERVER_TYPE         11
#define IDS_INF_FAILED                  11
#define IDS_UNABLE_TO_SETUP             12
#define IDS_SECTION_NAME                12
#define IDS_CANNOT_RUN_UNC              13
#define IDS_INF_FILENAME                13
#define IDS_INETSRV_INSTALLED_DIR       14
#define IDI_ICON1                       101
#define IDI_ICON2                       102
#define IDI_ICON3                       106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\infutil2\main.cpp ===
//****************************************************************************
//* Author:   Aaron Lee
//* Purpose:  Create .DDF and .INF files for specified files
//******************************************************************************/
/*
; ------------------------------------------------------------------------------------
; Format for this file
;
; position 1 = nts_x86 flag
; position 2 = ntw_x86 flag
; position 3 = win95 flag
; position 4 = win98 flag
; position 5 = nts_alpha flag
; position 6 = ntw_alpha flag
; position 7 = other_os flag
;
; position 8 = cabfilename
; position 9 = inf section
; position 10 = filename (wildcards okay)
;
; position 11= .INF rename to
; position 12= .DDF exclude from cab flag
; position 13=  Do Not Produce Error if Empty
; position 14=  Do Not include this file if the cab is empty!
; position 15=  Slipstream file -- don't reference the 0 cab, reference the # specified in global Variable - g_iSlipStreamDiskID
; ------------------------------------------------------------------------------------
1,1,1,1,0,0,0,basic.cab,iis_product_files_sys,setupapi.dll,,1
1,1,1,1,0,0,0,basic.cab,iis_product_files_sys,cfgmgr32.dll
1,1,1,1,0,0,0,basic.cab,iis_product_files_sys,ocmanage.dll
1,1,1,1,0,0,0,basic.cab,iis_product_files_sys,sysocmgr.exe
1,1,1,1,0,0,0,basic.cab,iis_core_files_sys,inetsrv\mdutil.exe
1,1,1,1,0,0,0,basic.cab,iis_core_files_sys,inetsrv\iismap.dll
1,1,1,1,0,0,0,basic.cab,iis_core_files_inetsrv,inetsrv\iscomlog.dll

;nts_x86,
ntw_x86,
win95,
win98,
nts_alpha,
ntw_alpha,
other_os,

cab filename,
inf section,
filename (wildcards okay),
.INF rename to,
.DDF exclude from cab,
1=don't show error if file not exist,
1=Do Not include this file if the cab is empty!,
Owner
*/
#include <direct.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <string.h>
#include <windows.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <iostream.h>
#include <fstream.h>
#include <winbase.h>
#include "filefind.h"
#include <iis64.h>

// Defines
#define delimiters      ",\t\n"
#define MAX_STRING      512
#define MAX_ARRAY_SIZE  10000
#define MAX_ARRAY_SMALL 1000
#define ALL_FILES       0xff

#define NTS_X86         "nts_x86"
#define NTW_X86         "ntw_x86"
#define WIN95           "win95"
#define WIN98           "win98"
#define NTS_ALPHA       "nts_alpha"
#define NTW_ALPHA       "ntw_alpha"
#define OTHER_OS        "other_os"

// Globals
int   g_iSlipStreamDiskID = 99;  // default if none specified as input parameter
int   g_iGlobalReturnCode = TRUE;

int   g_bOutputFileDate = FALSE;
int   g_bOutputFileTime = FALSE;
int   g_bOutputFileDateTime = FALSE;
int   g_bDoFileCompare = FALSE;
char  g_szDoFileCompareData[_MAX_PATH];
int   g_bVersionCheck = FALSE;
int   g_bShowFileFormat = FALSE;
int   g_bOutputDetails = TRUE;
int   g_bChangeListOnly = FALSE;
int   g_bChangeListOnly2 = FALSE;
int   g_bCabbing_Flag = TRUE;
int   g_bDisplayToScreen = FALSE;
char  g_szModuleFilename[_MAX_FNAME];
char  g_szDDFOutput[_MAX_PATH];
char  g_szINFOutput[_MAX_PATH];
char  g_szLSTOutput[_MAX_PATH];
char  g_szCATOutput[_MAX_PATH];
char  g_szCNGOutput[_MAX_PATH];
char  g_szLOCOutput[_MAX_PATH];
char  g_szNOTExistOutput[_MAX_PATH];

char  g_szinput_filename_full[_MAX_PATH];
char  g_szinput_platform[10];
char  g_szCurrentDir[_MAX_PATH];

char  g_szFilenameTag[_MAX_FNAME] = "CAB";

#define USENEW


struct FileReadLine
{
    int  NTS_x86_flag;
    int  NTW_x86_flag;
    int  Win95_flag;
	int  Win98_flag;
    int  NTS_alpha_flag;
    int  NTW_alpha_flag;
	int  Other_os_flag;
    char CabFileName[50];
    char INF_Sections[100];
    char Filename_Full[_MAX_PATH];
    char Filename_Name[_MAX_FNAME];
    char Filename_Path[_MAX_PATH];
    char DDF_Renamed[_MAX_PATH];
    char INF_Rename_To[_MAX_FNAME];
    int  DDF_Exclude_From_Cab_Flag;
    int  Do_Not_Show_Error_Flag;
    int  Do_Not_Include_file_if_cabEmpty_Flag;
	// invisible stuff
	long FileName_Size;
	int  FileWasNotActuallyFoundToExist;
	int  GetFromSlipStreamDisk;
} Flat_GlobalArray_Main[MAX_ARRAY_SIZE];


struct CabSizeInfoStruct
{
	char CabFileName[50];
	int  TotalFiles;
	long TotalFileSize;
} Flat_GlobalArray_CabSizes[30];

char Flat_GlobalArray_Err[MAX_ARRAY_SIZE][255];

struct arrayrow
{
    long total;
    long nextuse;
} Flat_GlobalArrayIndex_Main, Flat_GlobalArrayIndex_Err, Flat_GlobalArrayIndex_CabSizes;


char Flat_GlobalUniqueDirList[300][_MAX_PATH];
int Flat_GlobalUniqueDirList_nextuse;
int Flat_GlobalUniqueDirList_total;

// used for files which should not be included in the cab.
FileReadLine g_non_cablist_temp[MAX_ARRAY_SMALL];
int g_non_cablist_temp_nextuse;
int g_non_cablist_temp_total;


// prototypes
int   __cdecl main(int ,char *argv[]);
void  ShowHelp(void);
void  ShowFormat(void);
void  MakeDirIfNeedTo(char []);
int   strltrim(LPSTR & thestring);
int   RemoveAllSpaces(LPSTR & thetempstring);
int   IsThisStringInHere(LPTSTR, char[]);
void  GetPath(char *input_filespec, char *path, char *fs);
int   DoesFileExist(char *input_filespec);
void  GetThisModuleName(void);
char* __cdecl strtok2(char *,const char *);

void  Flat_ProcessFile(void);
void  Flat_GlobalArray_Fill(char[]);
void  Flat_GlobalArray_ChkDups(void);
void  Flat_GlobalArray_Prepend_UniqueString(void);

void  Flat_GlobalArray_Sort_Cols1(void);
void  Flat_GlobalArray_Sort_Cols1a(BOOL bDescendFlag);
void  Flat_GlobalArray_Sort_Cols2(BOOL bDescendFlag);

int   Flat_GlobalArray_Add(FileReadLine);
void  Flat_GlobalArray_Add_Err(char[]);
int   Flat_GlobalArray_EntryExists(FileReadLine);
void  Flat_GlobalArray_Print(void);
void  Flat_GlobalArray_Print_Err(void);
int   Flat_IsFileNameDup(int);
void  Flat_Create_Output_DDF(void);
void  Flat_Create_Output_INF(void);
int   Flat_Create_Output_ERR(void);
int   Flat_DoWeIncludeThisFileCheck(int processeduptill);


void Global_TotalCabFileSize_Compute(void);
void Global_TotalCabFileSize_Print(void);

int ReturnDirLevelCount(char *DirectoryTree);
void FillGlobalUniqueDirList();
int GlobalUniqueDirChkIfAlreadyThere(char *TheStringToCheck);
int GlobalUniqueDirReturnMyIndexMatch(char *TheStringToCheck);

void PrintFileDateTime(char *Full_Filename);
LPSTR  StripWhitespaceA(LPSTR pszString);
int iCompareTime(SYSTEMTIME *SystemTime1,SYSTEMTIME *SystemTime2);
int CompareFiles(LPSTR lpFileName1,LPSTR lpFileName2);
BOOL GetFileDate(LPTSTR lpFileName1,SYSTEMTIME *SystemTime1);



//-------------------------------------------------------------------
//  purpose: main
//-------------------------------------------------------------------
int __cdecl main(int argc,char *argv[])
{
	LPSTR pArg = NULL;
    int  argno = 0;
    int  nflags=0;
    char ini_filename_dir[_MAX_PATH];
    char ini_filename_only[_MAX_FNAME];
    char ini_filename_ext[_MAX_EXT];

    ini_filename_only[0]='\0';
    g_szinput_platform[0]='\0';

    GetThisModuleName();

    // Get current directory
    GetCurrentDirectory( _MAX_PATH, g_szCurrentDir);

    // process command line arguments
    for(argno=1; argno<argc; argno++)
        {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' )
            {
            nflags++;
            switch (argv[argno][1])
                {
                case '1':
					g_bOutputFileDate = TRUE;
                    break;
				case '2':
					g_bOutputFileTime = TRUE;
                    break;
                case '3':
					g_bOutputFileDateTime = TRUE;
                    break;
                case '4':
					g_bDoFileCompare = TRUE;
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':')
					{
                        char szTempString[MAX_PATH];
                        LPSTR pCmdStart = NULL;

						pArg = CharNextA(pArg);
						// Check if it's quoted
						if (*pArg == '\"')
						{
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
						}
						else
						{
							pCmdStart = pArg;
							// while ((*pArg) && (*pArg != '/') && (*pArg != '-')){pArg = CharNextA(pArg);}
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
                        lstrcpyA(g_szDoFileCompareData, StripWhitespaceA(pCmdStart));
					}

                    break;
                case 'a':
				case 'A':
					g_bChangeListOnly = TRUE;
                    break;
                case 'b':
				case 'B':
					g_bChangeListOnly2 = TRUE;
                    break;
                case 'd':
				case 'D':
					g_bOutputDetails = FALSE;
                    break;
                case 'f':
				case 'F':
					g_bShowFileFormat = TRUE;
                    break;
				case 'n':
                case 'N':
					g_bCabbing_Flag = FALSE;
                    break;
				case 'x':
                case 'X':
					g_bDisplayToScreen = TRUE;
                    break;
                case 's':
					g_iSlipStreamDiskID = atoi(&argv[argno][2]);
                    break;
                case 't':
                case 'T':
                    strncpy (g_szFilenameTag, &argv[argno][2], sizeof(g_szFilenameTag));
                    break;
                case 'v':
                case 'V':
                    g_bVersionCheck = TRUE;
                    break;
                case '?':
                    goto exit_with_help;
                    break;
                }
            } // if switch character found
        else
            {
            if ( *ini_filename_only == '\0' )
                {
                // if no arguments, then
                // get the ini_filename_dir and put it into
                strcpy(g_szinput_filename_full, argv[argno]);
                ini_filename_dir[0] = '\0';
                // split up this path
                _splitpath( g_szinput_filename_full, NULL, ini_filename_dir, ini_filename_only, ini_filename_ext);

                strcat(ini_filename_only, ini_filename_ext);
                // if we're missing dir, then get it.
                if (*ini_filename_dir == '\0')
                    {
                    // stick current dir into our variable
                    strcpy(ini_filename_dir, g_szCurrentDir);
                    strcpy(g_szinput_filename_full, g_szCurrentDir);
                    strcat(g_szinput_filename_full, "\\");
                    strcat(g_szinput_filename_full, ini_filename_only);
                    }
                }
            else
                {
                // Additional filenames (or arguments without a "-" or "/" preceding)
                //goto exit_with_help;
                // should be the section to execute.
                strcpy(g_szinput_platform, argv[argno]);
                }
            } // non-switch char found
        } // for all arguments

    if (g_bShowFileFormat)
    {
        ShowFormat();
        goto exit_no_printf;
    }

    if (g_bVersionCheck)
    {
        printf("3\n\n");
        exit(3);
        return TRUE;
    }
    
    // check if filename was specified
    // check if section name was specified
    if ( *ini_filename_only == '\0')
        {
        printf("Too few arguments, argc=%d\n\n",argc);
        goto exit_with_help;
        }

    // Check if the file exists!
    if (FALSE == DoesFileExist(g_szinput_filename_full))
        {
        printf("INI file %s, does not exist!.\n", g_szinput_filename_full);
        goto exit_gracefully;
        }

    // check if all they want is to compare a file with another list of files
    // and check if the 2nd list of files has a date/time stamp which is more recent than file#1
    if (g_bDoFileCompare)
    {
        // check if filename was specified
        if (strcmp(g_szDoFileCompareData,"") == 0)
            {
            printf("-4 option  missing file parameter!\n\n");
            goto exit_with_help;
            }

        // compare file#s date with the list of files in #2
        if (TRUE == CompareFiles(g_szinput_filename_full,g_szDoFileCompareData))
        {
            printf("1\n\n");
            goto exit_no_printf_1;
        }
        else
        {
            printf("0\n\n");
            goto exit_no_printf;
        }
    }

    // check if all they want is the date,time or date and time!!!
    if (g_bOutputFileDate || g_bOutputFileTime || g_bOutputFileDateTime)
    {
        // get the file's julian date and echo it out!
        PrintFileDateTime(g_szinput_filename_full);
        goto exit_no_printf;
    }

    // check if filename was specified
    // check if section name was specified
    if ( *ini_filename_only == '\0' || *g_szinput_platform == '\0')
        {
        printf("Too few arguments, argc=%d\n\n",argc);
        goto exit_with_help;
        }

    // Check if g_szinput_platform is one of the available options
    strcpy(g_szinput_platform, g_szinput_platform);

    if ( (_stricmp(g_szinput_platform, NTS_X86) != 0) &&
         (_stricmp(g_szinput_platform, NTW_X86) != 0) &&
         (_stricmp(g_szinput_platform, WIN95) != 0) &&
         (_stricmp(g_szinput_platform, WIN98) != 0) &&
         (_stricmp(g_szinput_platform, NTS_ALPHA) != 0) &&
         (_stricmp(g_szinput_platform, NTW_ALPHA) != 0) &&
         (_stricmp(g_szinput_platform, OTHER_OS) != 0))
        {
        printf("2nd parameter must be one of %s,%s,%s,%s,%s,%s or %s.\n", NTS_X86, NTW_X86, WIN95, WIN98, NTS_ALPHA, NTW_ALPHA, OTHER_OS);
        goto exit_gracefully;
        }

    // Fine, process the ini file.
    char    stempstring[100];
    sprintf(stempstring, "Start %s.\n", g_szModuleFilename);
    printf(stempstring);
    printf("---------------------------------------------------\n");

    // We have at least g_szinput_platform and g_szinput_filename_full defined

    // run the function to do everything
    Flat_ProcessFile();

exit_gracefully:
    printf("---------------------------------------------------\n");
    printf("Done.\n");
    if (g_iGlobalReturnCode == TRUE)
        {exit(0);}
    else
        {exit(1);}
    return g_iGlobalReturnCode;

exit_with_help:
    ShowHelp();
    return FALSE;

exit_no_printf:
    exit(0);
    return FALSE;

exit_no_printf_1:
    exit(1);
    return TRUE;

}


int CompareFiles(LPSTR lpFileName1,LPSTR lpFileName2)
{
    int iReturn = FALSE;
    int   attr = 0;
    intptr_t  hFile = 0;
    finddata datareturn;
    SYSTEMTIME SystemTime1;
    SYSTEMTIME SystemTime2;
    char filename_dir[_MAX_PATH];
    char filename_only[_MAX_FNAME];
    char TempString[_MAX_PATH];
    char *pDest = NULL;

    // file#1 should be a regular file
    // file#2 could be 1 file or a list of files.

    // regardless, take file#1's date and compare it with the dates of the files in list#2
    // if anyone of the files in list#2 is newer than file#1, return true!

    InitStringTable(STRING_TABLE_SIZE);

    // Get the date\time for file #1
    if (FALSE == GetFileDate(lpFileName1, &SystemTime1))
    {
        printf("CompareFiles: Failure to GetFileDate on %s\n",lpFileName1);
        goto CompareFiles_Exit;
    }

    pDest = lpFileName2;

    // Find end of the string
    while (*pDest){pDest = _tcsinc(pDest);}

	// If no trailing backslash then kool, copy on the *.*
    if (*(_tcsdec(lpFileName2, pDest)) == _T('\\'))
    {
        strcat(lpFileName2, "*.*");
        attr=ALL_FILES;
    }

    // get the path
    _splitpath(lpFileName2, NULL, filename_dir, filename_only, NULL);
    attr= 0;
    if (_stricmp(filename_only, "*") == 0)
        {attr=ALL_FILES;}
    if (_stricmp(filename_only, "*.*") == 0)
        {attr=ALL_FILES;}
    if (FindFirst(lpFileName2, attr, &hFile, &datareturn))
    {
        // check if it's a sub dir
        if (!(datareturn.attrib & _A_SUBDIR))
        {
            // Get the filename portion
            strcpy(TempString, filename_dir);
            strcat(TempString, datareturn.name);
            // compare the date with file#1's date
            if (FALSE == GetFileDate(TempString, &SystemTime2))
            {
                printf("CompareFiles: Failure to GetFileDate on %s\n",TempString);
            }
            else
            {

                // check if the filedate is bigger than file#1's date
                if (TRUE == iCompareTime(&SystemTime1,&SystemTime2))
                {
                    iReturn = TRUE;
                    goto CompareFiles_Exit;
                }
             }
        }

        while(FindNext(attr, hFile, &datareturn))
        {
            //printf("FindNext:%s\n",datareturn.name);
            // check if it's a sub dir
            if (!(datareturn.attrib & _A_SUBDIR))
            {
                // Get the filename portion
                strcpy(TempString, filename_dir);
                strcat(TempString, datareturn.name);
                // compare the date with file#1's date
                if (FALSE == GetFileDate(TempString, &SystemTime2))
                {
                    printf("CompareFiles: Failure to GetFileDate on %s\n",TempString);
                }
                else
                {
                    // check if the filedate is bigger than file#1's date
                    if (TRUE == iCompareTime(&SystemTime1,&SystemTime2))
                    {
                        iReturn = TRUE;
                        goto CompareFiles_Exit;
                    }
                 }

            }
        }
    }

CompareFiles_Exit:
    EndStringTable();
    return iReturn;
}

// if systemtime2 is larger than systemtime1 then return true!
int iCompareTime(SYSTEMTIME *SystemTime1,SYSTEMTIME *SystemTime2)
{
    int iReturn = FALSE;

    if (SystemTime2->wYear > SystemTime1->wYear){goto iCompareTime_Larger;}
    if (SystemTime2->wYear < SystemTime1->wYear){goto iCompareTime_Smaller;}
    if (SystemTime2->wMonth > SystemTime1->wMonth){goto iCompareTime_Larger;}
    if (SystemTime2->wMonth < SystemTime1->wMonth){goto iCompareTime_Smaller;}

    if (SystemTime2->wDay > SystemTime1->wDay){goto iCompareTime_Larger;}
    if (SystemTime2->wDay < SystemTime1->wDay){goto iCompareTime_Smaller;}

    if (SystemTime2->wHour > SystemTime1->wHour){goto iCompareTime_Larger;}
    if (SystemTime2->wHour < SystemTime1->wHour){goto iCompareTime_Smaller;}

    if (SystemTime2->wMinute > SystemTime1->wMinute){goto iCompareTime_Larger;}
    if (SystemTime2->wMinute < SystemTime1->wMinute){goto iCompareTime_Smaller;}

    if (SystemTime2->wSecond > SystemTime1->wSecond){goto iCompareTime_Larger;}
    if (SystemTime2->wSecond < SystemTime1->wSecond){goto iCompareTime_Smaller;}

    if (SystemTime2->wMilliseconds > SystemTime1->wMilliseconds){goto iCompareTime_Larger;}
    if (SystemTime2->wMilliseconds < SystemTime1->wMilliseconds){goto iCompareTime_Smaller;}

    // they are exactly the same

    iReturn = FALSE;
    return iReturn;

iCompareTime_Larger:
    iReturn = TRUE;
    return iReturn;

iCompareTime_Smaller:
    iReturn = FALSE;
    return iReturn;

}
                 


BOOL GetFileDate(LPTSTR lpFileName1,SYSTEMTIME *SystemTime1)
{
    HANDLE hFile1 = NULL;
    FILETIME fCreate,fAccess,fWrite;

    FILETIME LocalFileTime;
    

    if (!(hFile1=CreateFile(lpFileName1,GENERIC_READ,FILE_SHARE_READ, NULL,OPEN_EXISTING,0,0)))
    {
			return FALSE;
    }
	if (!GetFileTime(hFile1,&fCreate,&fAccess,&fWrite))
    {
			CloseHandle(hFile1);
			return FALSE;
    }
	if (!FileTimeToLocalFileTime(&fWrite,&LocalFileTime))
	{
		CloseHandle(hFile1);
		return FALSE;
	}
    if (!FileTimeToSystemTime(&LocalFileTime,SystemTime1))
	{
		CloseHandle(hFile1);
		return FALSE;
	}
	CloseHandle(hFile1);
    return TRUE;
}


void PrintFileDateTime(char *Full_Filename)
{
    SYSTEMTIME SystemTime;
    char szDateandtime[50];
    // get the file's time stamp 17:31.
    // make it look like: 1731
    //
    // get the file's date 12/30/1999
    // make it look like 19991230

    // make it all look like 199912301731
    if (TRUE == GetFileDate(Full_Filename, &SystemTime))
    {
        //sprintf(szDateandtime,"[%02d/%02d/%02d %02d:%02d:%02d]\n",SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
        //printf(szDateandtime);

        if (g_bOutputFileDate)
        {
            sprintf(szDateandtime,"%02d%02d%02d\n",SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay);
            printf(szDateandtime);
        }
        
        if (g_bOutputFileTime)
        {
            sprintf(szDateandtime,"%02d%02d%02d\n",SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
            printf(szDateandtime);
        }

        if (g_bOutputFileDateTime)
        {
            sprintf(szDateandtime,"%02d%02d%02d%02d%02d%02d\n",
                SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay, 
                SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
            printf(szDateandtime);
        }
    }
   
    return;
}

//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_ProcessFile()
{
    ifstream inputfile;
    char fileinputbuffer[1000];

    char    stempstring[100];
    char *  ptemp = NULL;

    Flat_GlobalArrayIndex_Main.total=0;  Flat_GlobalArrayIndex_Main.nextuse=0;
    Flat_GlobalArrayIndex_Err.total=0;   Flat_GlobalArrayIndex_Err.nextuse=0;

    // Get output file names
    strcpy(g_szDDFOutput, g_szModuleFilename);
    strcat(g_szDDFOutput, ".DDF");
    strcpy(g_szINFOutput, g_szModuleFilename);
    strcat(g_szINFOutput, ".INF");

    strcpy(g_szLSTOutput, g_szModuleFilename);
    strcat(g_szLSTOutput, ".LST");

    strcpy(g_szCATOutput, g_szModuleFilename);
    strcat(g_szCATOutput, ".CAT");

    strcpy(g_szCNGOutput, g_szModuleFilename);
    strcat(g_szCNGOutput, ".CNG");

    strcpy(g_szNOTExistOutput, g_szModuleFilename);
    strcat(g_szNOTExistOutput, ".NOT");

    strcpy(g_szLOCOutput, g_szModuleFilename);
    strcat(g_szLOCOutput, ".LOC");
   

    // don't delete these files if we're only doing the changelist file
    if (!g_bChangeListOnly)
    {
	    DeleteFile(g_szCATOutput);
        DeleteFile(g_szNOTExistOutput);
    }
    // always delete this file
    DeleteFile(g_szCNGOutput);
    DeleteFile(g_szLOCOutput);

    // Read flat file and put into huge array
    inputfile.open(g_szinput_filename_full, ios::in);
    inputfile.getline(fileinputbuffer, sizeof(fileinputbuffer));
    do
    {
        // check for any comments, don't add these to the array.
        if (strchr(fileinputbuffer, ';') != NULL) 
        {
        ptemp = strrchr(fileinputbuffer, ';');
        if (ptemp){*ptemp = '\0';}
        }
        if (*fileinputbuffer)
        {
            // Remove spaces
            char *p;
            p = fileinputbuffer;
            RemoveAllSpaces(p);

            // Take line, parse it and put it into our global file structure.
            // Do only for our platform!!!!
            Flat_GlobalArray_Fill(fileinputbuffer);
        }
    } while (inputfile.getline(fileinputbuffer, sizeof(fileinputbuffer)));

	inputfile.close();

    // OK, all entries should be in the global_main array
    // and all the "extra" entries should be in there too..

	// add a "IIS" to the font of any filename
	Flat_GlobalArray_Prepend_UniqueString();

    // 1. loop thru the global array and mark any filenames for duplicates..
    Flat_GlobalArray_Sort_Cols2(TRUE);
    Flat_GlobalArray_ChkDups();

    // 2. sort on #1 cab file, then on #2 section
    Flat_GlobalArray_Sort_Cols2(FALSE);
	if (g_bOutputDetails == TRUE) {Flat_GlobalArray_Print();}

    if (!g_bChangeListOnly)
    {
        //printf("\n\n sorted by cab and section...\n");

        // 3. loop thru the list and create .DDF file
        sprintf(stempstring, "Creating DDF file...%s\n",g_szDDFOutput);
        printf(stempstring);
	    if (g_bCabbing_Flag) {Flat_Create_Output_DDF();}
    }
	
    // Sort on sections
    Flat_GlobalArray_Sort_Cols1a(FALSE);
    //printf("\n\n sorted by section...\n");
	if (g_bDisplayToScreen) Flat_GlobalArray_Print();

    // 4. loop thru the list and create .INF file
    if (g_bChangeListOnly)
    {
        sprintf(stempstring, "Creating CNG file only...%s\n",g_szINFOutput);
        printf(stempstring);
    }
    else
    {
        sprintf(stempstring, "Creating INF file...%s\n",g_szINFOutput);
        printf(stempstring);
    }

	Flat_Create_Output_INF();

	printf("\nTotals:\n");
	Global_TotalCabFileSize_Compute();
	Global_TotalCabFileSize_Print();

    printf("\nErrors/Warnings:\n");
    Flat_GlobalArray_Print_Err();

    Flat_Create_Output_ERR();

    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_GlobalArray_Fill(char fileinputbuffer[])
{
    char *token;
    int  token_count;
    char thetempstring[MAX_STRING];
    char tempstring[255];
    char temperrorwords[255] = "";
    FileReadLine tempentry = {0,0,0,0,0,0,0,"","","","","","","",0,0,0,0,0,0};
    FileReadLine theentry = {0,0,0,0,0,0,0,"","","","","","","",0,0,0,0,0,0};

    strcpy(thetempstring, fileinputbuffer);

    // get the first token
    token = strtok2( thetempstring, delimiters );
    token_count = 0;

    // Add entry to Global Array, convert to all lowercase

    // parse out platforms
    if (token == NULL) {goto Exit_Flat_FillGlobalArray_Main;}
    strcpy(temperrorwords, "x86_NTS_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.NTS_x86_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}
    strcpy(temperrorwords, "x86_NTW_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.NTW_x86_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}

    strcpy(temperrorwords, "Win95_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Win95_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError2;}

    strcpy(temperrorwords, "Win98_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Win98_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError2;}

    strcpy(temperrorwords, "NTS_alpha_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.NTS_alpha_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}
    strcpy(temperrorwords, "NTW_alpha_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.NTW_alpha_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}

    strcpy(temperrorwords, "Other_os_flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Other_os_flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError1;}


    // do only for our specified platform!
    if ( (tempentry.NTS_x86_flag==0) && (_stricmp(g_szinput_platform,NTS_X86) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}
    if ( (tempentry.NTW_x86_flag==0) && (_stricmp(g_szinput_platform,NTW_X86) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}

    if ( (tempentry.Win95_flag==0) && (_stricmp(g_szinput_platform,WIN95) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}
    if ( (tempentry.Win98_flag==0) && (_stricmp(g_szinput_platform,WIN98) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}


    if ( (tempentry.NTS_alpha_flag==0) && (_stricmp(g_szinput_platform,NTS_ALPHA) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}
    if ( (tempentry.NTW_alpha_flag==0) && (_stricmp(g_szinput_platform,NTW_ALPHA) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}

    if ( (tempentry.Other_os_flag==0) && (_stricmp(g_szinput_platform,OTHER_OS) == 0))
        {goto Exit_Flat_FillGlobalArray_Main;}
	
    strcpy(temperrorwords, "Cabfilename");
    strcpy(tempentry.CabFileName, token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError2;}
    strcpy(temperrorwords, "INF_Sections");
    strcpy(tempentry.INF_Sections, token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto InputParseError2;}
    strcpy(temperrorwords, "Filename_Full");
    strcpy(tempentry.Filename_Full, token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}
    strcpy(temperrorwords, "INF_Rename_To");
    strcpy(tempentry.INF_Rename_To, token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}
    strcpy(temperrorwords, "DDF_Exclude_From_Cab_Flag");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.DDF_Exclude_From_Cab_Flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}

    strcpy(temperrorwords, "Do_Not_Show_Error_Flag");
	if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Do_Not_Show_Error_Flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}

    strcpy(temperrorwords, "Do_Not_Include_file_if_cabEmpty_Flag");
	if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.Do_Not_Include_file_if_cabEmpty_Flag = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}

    strcpy(temperrorwords, "GetFromSlipStreamDisk");
    if ( (_stricmp("1",(char *) token) != 0) && (_stricmp("0",(char *) token) != 0) && (_stricmp("", (char*) token)!=0) ) goto InputParseError;
    tempentry.GetFromSlipStreamDisk = atoi(token); token = strtok2( NULL, delimiters ); token_count++;if (token == NULL) {goto MoveToGlobals;}
	

    
MoveToGlobals:
    if (!(tempentry.Filename_Full)) {goto Exit_Flat_FillGlobalArray_Main;}
    // Check for wildcards in position array in filename position #2
    int   attr;
    char filename_dir[_MAX_PATH];
    char filename_only[_MAX_FNAME];

    // Get the filename portion
    _splitpath( tempentry.Filename_Full, NULL, filename_dir, filename_only, NULL);
    attr= 0;
    if (_stricmp(filename_only, "*.*") == 0)
        {attr=ALL_FILES;}

    // list thru the files
    intptr_t  hFile;
    finddata datareturn;

    InitStringTable(STRING_TABLE_SIZE);
    if ( FindFirst(tempentry.Filename_Full, attr, &hFile, &datareturn) )
        {
        // check if it's a sub dir
        if (!( datareturn.attrib & _A_SUBDIR))
            {
                // ok we found one.
                // let's add it to our list of stuff to add
                theentry = tempentry;

                char tempstring1[255];
                strcpy(tempstring1, filename_dir);
                strcat(tempstring1, datareturn.name);
                strcpy(theentry.Filename_Full, tempstring1);

                strcpy(tempstring1, datareturn.name);
                strcpy(theentry.Filename_Name, tempstring1);

                strcpy(tempstring1, filename_dir);
                strcpy(theentry.Filename_Path, tempstring1);

                strcpy(tempstring1, datareturn.name);
                strcpy(theentry.DDF_Renamed, tempstring1);

				theentry.FileName_Size = datareturn.size;

                // now take this entry and try to add it to the global array!!!
                Flat_GlobalArray_Add(theentry);
            }

        while(FindNext(attr, hFile, &datareturn))
            {
            // check if it's a sub dir
            if (!(datareturn.attrib & _A_SUBDIR))
                {
                // ok we found one.
                // let's add it to our list of stuff to add
                theentry = tempentry;

                char tempstring1[255];
                strcpy(tempstring1, filename_dir);
                strcat(tempstring1, datareturn.name);
                strcpy(theentry.Filename_Full, tempstring1);

                strcpy(tempstring1, datareturn.name);
                strcpy(theentry.Filename_Name, tempstring1);

                strcpy(tempstring1, filename_dir);
                strcpy(theentry.Filename_Path, tempstring1);

                strcpy(tempstring1, datareturn.name);
                strcpy(theentry.DDF_Renamed, tempstring1);

				theentry.FileName_Size = datareturn.size;

                // now take this entry and try to add it to the global array!!!
                Flat_GlobalArray_Add(theentry);
                }
            }

        }
    else
        // we didn't find the specified file.
        {
			// If this is a file which doesn't get into a cab, then
		    // let's add it to the .inf file section [SourceDisksFiles] later.
		    if (tempentry.DDF_Exclude_From_Cab_Flag)
			{
				    fstream f4;
					f4.open(g_szNOTExistOutput, ios::out | ios::app);

					char fullpath[_MAX_PATH];
					char * pmyfilename;
					char myPath[_MAX_PATH];
					pmyfilename = fullpath;

					// Resolve relative path to real path
					if (0 != GetFullPathName(tempentry.Filename_Full, _MAX_PATH, myPath, &pmyfilename))
					{
						// Take only the filename...

						// achg.htr=1,,1902
						strcpy(tempstring,pmyfilename);
						f4.write(tempstring, strlen(tempstring));
                                                if (tempentry.GetFromSlipStreamDisk == 0)
                                                {
						  strcpy(tempstring,"=0,,50000");
                                                }
                                                else
                                                {
                                                  sprintf(tempstring,"=%d,,50000",g_iSlipStreamDiskID);
                                                }

						f4.write(tempstring, strlen(tempstring));
						f4.write("\n", 1);

						// let's add it to our list of stuff to add
						theentry = tempentry;

						strcpy(theentry.Filename_Full, tempentry.Filename_Full);
						strcpy(theentry.Filename_Name, pmyfilename);

						_splitpath( tempentry.Filename_Full, NULL, theentry.Filename_Path, NULL, NULL);
						//strcpy(theentry.Filename_Path, myPath);
						strcpy(theentry.DDF_Renamed, pmyfilename);
						theentry.FileName_Size = 50000;

						printf(tempentry.Filename_Full);
						printf(".  FileWasNotActuallyFoundToExist1.\n");
						theentry.FileWasNotActuallyFoundToExist = TRUE;

						// now take this entry and try to add it to the global array!!!
						Flat_GlobalArray_Add(theentry);

					}
					f4.close();
			}
			else
			{
				// check if we're not supposed to show errors!
				if (tempentry.Do_Not_Show_Error_Flag == 0)
				{
					// add it to the error list.
					sprintf(tempstring, "ERROR: file not found--> %s --> %s", tempentry.Filename_Full, fileinputbuffer);
					Flat_GlobalArray_Add_Err(tempstring);
				}
			}
        }


    EndStringTable();


Exit_Flat_FillGlobalArray_Main:
        return;

InputParseError:
    sprintf(tempstring, "INFUTIL ERROR: %s should be numeric and is not--> %s", temperrorwords, fileinputbuffer);
    Flat_GlobalArray_Add_Err(tempstring);
    return;
InputParseError1:
    sprintf(tempstring, "INFUTIL ERROR: missing platform info--> %s", fileinputbuffer);
    Flat_GlobalArray_Add_Err(tempstring);
    return;
InputParseError2:
    sprintf(tempstring, "INFUTIL ERROR: missing %s--> %s", temperrorwords, fileinputbuffer);
    Flat_GlobalArray_Add_Err(tempstring);
    return;

}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int Flat_GlobalArray_Add(FileReadLine entrytoadd)
{
    FileReadLine Temp = {0,0,0,0,0,0,0,"","","","","","","",0,0,0,0,0,0};

    // check if this value already exists in the globalarary
    if (Flat_GlobalArray_EntryExists(entrytoadd)) return FALSE;
    
    // blankout the array values if any.
    Flat_GlobalArray_Main[Flat_GlobalArrayIndex_Main.nextuse] = Temp;

    // move info into global array
    Flat_GlobalArray_Main[Flat_GlobalArrayIndex_Main.nextuse] = entrytoadd;

    // increment counter to array
    // increment next use space
    ++Flat_GlobalArrayIndex_Main.total;
    ++Flat_GlobalArrayIndex_Main.nextuse;
    return TRUE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int Flat_GlobalArray_EntryExists(FileReadLine theentry)
{
    int matchcount;

    // loop thru the whole list
    for( int i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
    {
        // check if entries are the same.
        matchcount=0;
        if (_strnicmp(Flat_GlobalArray_Main[i0].CabFileName, theentry.CabFileName, lstrlen(theentry.CabFileName) + 1) == 0 )
            {++matchcount;}
        if (_strnicmp(Flat_GlobalArray_Main[i0].INF_Sections, theentry.INF_Sections, lstrlen(theentry.INF_Sections) + 1) == 0 )
            {++matchcount;}
        if (_strnicmp(Flat_GlobalArray_Main[i0].Filename_Full, theentry.Filename_Full, lstrlen(theentry.Filename_Full) + 1) == 0 )
            {++matchcount;}
        if (_strnicmp(Flat_GlobalArray_Main[i0].Filename_Name, theentry.Filename_Name, lstrlen(theentry.Filename_Name) + 1) == 0 )
            {++matchcount;}
        if (matchcount == 4)
        {
            // we found a match!!! "WARNING: file already included"
            return TRUE;
        }
    }
    //. no matches... return FALSE.
    return FALSE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int IsThisStringInHere(LPTSTR  lpTemp, char szStringToCheck[])
{
    int     bFlag               = FALSE;

    // Lookup sections to see if they exists in ini file.
    if (*lpTemp != '\0')
        {
        // loop thru and process results
        bFlag = FALSE;
        while (*lpTemp)
            {
            // check if our section name is in there.
            if (_strnicmp(szStringToCheck, lpTemp, lstrlen(lpTemp) + 1) == 0 )
                {bFlag = TRUE;}
            lpTemp += (lstrlen(lpTemp) + 1);
            }

        // Check if our section was in there
        if (bFlag != TRUE)
            {return FALSE;}

        }

    return TRUE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int Flat_DDFDoesThisFileCabAlreadyExists(int processeduptill)
{
    int i0;

    char CompareTo_cab[100];
    char CompareTo_fullfilename[100];

    strcpy(CompareTo_cab, Flat_GlobalArray_Main[processeduptill].CabFileName);
    strcpy(CompareTo_fullfilename, Flat_GlobalArray_Main[processeduptill].Filename_Full);

    for(i0=0;i0<processeduptill;i0++)
        {
        // check if global value has already been processed.
        // check if the cab is the same
        // check if the dir is the same
        // check if the filename is the same
        if (_stricmp(Flat_GlobalArray_Main[i0].CabFileName, CompareTo_cab) == 0)
            {
            if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Full,CompareTo_fullfilename) == 0)
                {
                // if they both match, then shoot that means that we already printed this out.
                return TRUE;
                }
            }
        }

    return FALSE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void ShowHelp()
{
    printf("InfUtil2 - prints out file date/time,\n");
    printf("           or print out watch list from <input file> list,\n");
    printf("           or creates .ddf and .inf files from <input file> list\n");
    printf("----------------------------------------------------------------\n");
    printf("  Usage:\n");
    printf("       infutil2 /? /F [/1 /2 /3] [/4:<filename>] [/A /B] /D /N /S? /T??? /X <input file> <section name>\n\n");
	printf("  Params:\n");
    printf("       /? show this stuff\n");
    printf("       /F show <input file> format help\n");
    printf("      Flags for Date/Time use:\n");
    printf("       /1 print out <input file>'s date as number\n");
    printf("       /2 print out <input file>'s time as number\n");
    printf("       /3 print out <input file>'s date and time as big number\n");
    printf("      Flags for compare file list timestamp use:\n");
    printf("       /4: compare dir in <filename> with <input file>'s timestamp.  if dir has newer files, then set ERRORLEVEL=1\n");
    printf("      Flags for change list use:\n");
    printf("       /A produce a list of files to watch for changes (if files in list change then re-build cabs) from <input file> list\n");
    printf("       /B produce a list of files to watch for changes (includes files which aren't in cabs) from <input file> list\n");
    printf("      Flags for .ddf .inf use:\n");
    printf("       /D don't show details\n");
    printf("       /SslipstreamSourceDisksNames file id -- used for SP1 slipstream to point loose files to file specified in /S\n");
    printf("         used in sync with <input file> change.  look in .ddf file.\n");
    printf("       /Ttag Appends tag_ to the beginning of all filenames\n");
    printf("       /N Produce INF File which will not require .ddf file (meaning no cabs).(untested) \n");
    printf("       /X Display output for debug\n");
    printf("       <input file> is a file name.\n");
    printf("       <section name> is either %s,%s,%s,%s,%s,%s,%s.\n", NTS_X86, NTW_X86, WIN95, WIN98, NTS_ALPHA, NTW_ALPHA, OTHER_OS);
    printf("\n");
    printf("Example:\n");
    printf("       infutil2.exe /3 myfile.txt\n");
    printf("           Will print out myfile.txt's date/time as yymmddhhmmss.\n");
    printf("       infutil2.exe /Tcore inifile.ini %s\n", NTS_X86);
    printf("           Will produce a infutil2.ddf,inf,cng files. the .ddf and .inf files will create cabs with files beginning with 'core_'\n");
    printf("       infutil2.exe /C inifile.ini %s\n", NTS_X86);
    printf("           Will only produce a infutil2.cng file with a list of files to watch for changes in.\n");
    return;
}

void ShowFormat(void)
{
    printf("Format for <input file>:\n");
    printf("       position 1 = nts_x86 flag\n");
    printf("                2 = ntw_x86 flag\n");
    printf("                3 = win95 flag\n");
    printf("                4 = win98 flag\n");
    printf("                5 = nts_alpha flag\n");
    printf("                6 = ntw_alpha flag\n");
    printf("                7 = other_os flag\n");
    printf("                8 = cabfilename\n");
    printf("                9 = inf section\n");
    printf("               10 = filename (wildcards okay)\n");
    printf("               11 = .INF rename to\n");
    printf("               12 = .DDF exclude from cab flag\n");
    printf("               13 = Do Not Produce Error if Empty\n");
    printf("               14 = Do Not include this file if the cab is empty!\n");
    printf("\n");
    printf("Example of format for <input file>:\n");
    printf("       1,1,1,1,0,0,0,core.cab,core_files_sys,x86\\SysFile1.dll,,1,,\n");
    printf("       1,1,1,1,0,0,0,core.cab,core_files_sys,x86\\SysFile2.dll,,1,,\n");
    printf("       0,0,0,0,1,1,0,core.cab,core_files_sys,Alpha\\SysFile1.dll,,1,,\n");
    printf("       0,0,0,0,1,1,0,core.cab,core_files_sys,Alpha\\SysFile2.dll,,1,,\n");
    printf("       1,0,0,0,0,0,0,core.cab,product_files,x86\\ProdSrv.dll,,1,,\n");
    printf("       0,1,0,0,0,0,0,core.cab,product_files,x86\\ProdWks.dll,,1,,\n");
    printf("       0,0,1,1,0,0,0,core.cab,product_files,x86\\Prod95.dll,,1,,\n");
    printf("       0,0,0,0,1,0,0,core.cab,product_files,Alpha\\ProdSrvA.dll,,1,,\n");
    printf("       0,0,0,0,0,1,0,core.cab,product_files,Alpha\\ProdWksA.dll,,1,,\n");
    printf("       1,1,1,1,0,0,0,core.cab,product_files,x86\\Prodx86.dll,,1,,\n");
    printf("       0,0,0,0,1,1,0,core.cab,product_files,Alpha\\ProdAlph.dll,,1,,\n");
    printf("       1,1,1,1,0,0,0,core.cab,product_files2,x86\\Ext\\*.*,,,,\n");
    printf("       0,0,0,0,1,1,0,core.cab,product_files2,Alpha\\Ext\\*.*,,,,\n");
    printf("       1,1,1,1,1,1,0,core.cab,product_files2,16bit\\*.*,,,,\n");
    printf("       1,1,1,1,1,1,0,content.cab,content_files_dir1,content\\index.htm,,,,\n");
    printf("       1,1,1,1,1,1,0,content.cab,content_files_dir1,content\\readme.txt,,,,\n");
    printf("       1,1,1,1,1,1,0,content.cab,content_files_dir1,content\\default.htm,,,,\n");
    printf("       1,1,1,1,1,1,0,content.cab,content_files_dir2,content\\content1.htm,,,,\n");
    printf("       1,1,1,1,1,1,0,content.cab,content_files_dir2,content\\content2.htm,,,,\n");
    printf("       1,1,1,1,1,1,0,content.cab,content_files_dir2,content\\content3.htm,,,,\n");
    printf("       1,1,1,1,1,1,0,content.cab,content_files_dir2,content\\content4.htm,,,,\n");
    printf("       1,1,1,1,1,1,0,docs.cab,help_files_dir1,help\\*.*,,,,\n");
    printf("       1,1,1,1,1,1,0,docs.cab,help_files_dir2,help\\other\\*.*,,,,\n");
    printf("       1,1,1,1,1,1,0,docs.cab,help_files_dir3,help\\support\\*.txt,,,,\n");
    printf("       1,1,1,1,1,1,0,docs.cab,help_files_dir4,help\\other\\*.xls,,,,\n");
    printf("\n");
    printf("Example of use:\n");
    printf("       infutil2.exe -Tcore -D abovefile.csv %s\n", NTS_X86);
    printf("       Will produce .ddf,inf,err,cat,not and infutil2.cng files. Figure it out.\n");
    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int DoesFileExist(char *input_filespec)
{
    if (GetFileAttributes(input_filespec) == -1)
    {
        return(FALSE);
    }
    return (TRUE);
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void GetPath(char * input_filespec, char * path, char * fs)
{
    char filespec[100];
    char * p;
    struct _stat s;

    strcpy(filespec, input_filespec);

        /* if filespec is a directory, interpret it to mean dir\*.* */
    if (_stat(filespec, &s) == 0 && s.st_mode & S_IFDIR)
        {
            /* root is special case */
        if ( (*filespec == '\\' && *(filespec+1) == '\0') ||
                 (*(filespec+1) == ':' && *(filespec+2) == '\\' && *(filespec+3)=='\0'))
            strcat(filespec, "*.*");
        else
            strcat(filespec, "\\*.*");
        }

        /* search string from end to beginning for back slash */
    p=filespec+strlen(filespec)-1;
    for(; p>filespec && *p != '\\' && *p != ':'; p--);
        /* is it a drive or path */
    if ( *p=='\\' || *p==':')
        {
        strncpy(path, filespec, DIFF(p-filespec)+1);
        path[p-filespec+1]='\0';
        strcpy(fs, p+1);
        }
    else /* no drive, path */
        {
            /* yep, no path */
        path[0]='\0';
        strcpy(fs, filespec);
        }

} /* GetPath */


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int strltrim(LPSTR & thestring)
{
    char * p = NULL;

    p = thestring;

    // check for spaces to the right
    if (*p ==' ')
        {
        while (*p == ' ')
            {p += (lstrlen((char*) *p) + 1);}

        thestring = p;
        printf("%s testing..", p);
        return TRUE;
        }
    return FALSE;
}



//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void MakeDirIfNeedTo(char thestring[])
{
    char *p = NULL;
    char tempstring[255];
    // Check the string to see if there are any "\"'s in the string
    // if there are then let's remove the filename and make the directory
    if (strchr(thestring, '\\') != NULL)
        {
        strcpy(tempstring, thestring);
        // remove the filename
        p = strrchr(tempstring, '\\');
        if(p){*p = '\0';}

        // ok now we have the path
        // let's create the directory
        _mkdir(tempstring);

        }
    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void GetThisModuleName(void)
{
    char    szfilename_only[_MAX_FNAME];
    char    szPath[_MAX_PATH];
    // Get the path
    if (GetModuleFileName(NULL, szPath, _MAX_PATH))
    {
      // split up this path and take filename only
      _splitpath( szPath, NULL, NULL, szfilename_only, NULL);

      // set global variable with it
      strcpy(g_szModuleFilename, szfilename_only);
    }
    return;
}

void Flat_GlobalArray_Prepend_UniqueString(void)
{
    //char Filename_Full[_MAX_PATH];
    //char Filename_Name[_MAX_FNAME];
    //char Filename_Path[_MAX_PATH];
    //char DDF_Renamed[_MAX_PATH];
    //char INF_Rename_To[_MAX_FNAME];

    char filename_only[_MAX_FNAME];
    char filename_ext[_MAX_EXT];
	char NewFilename[_MAX_FNAME];

	int i0 =0;
	for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
	{
		if (Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag == 0)
		{
			// Tack on the IIS Tag.
			_splitpath( Flat_GlobalArray_Main[i0].Filename_Full, NULL, NULL, filename_only, filename_ext);
			if (filename_ext)
                {sprintf(NewFilename, "%s_%s%s", g_szFilenameTag, filename_only, filename_ext);}
			else
				{sprintf(NewFilename, "%s_%s", g_szFilenameTag, filename_only);}

			// re-create the full name
			//sprintf(Flat_GlobalArray_Main[i0].Filename_Full, "%s%s", Flat_GlobalArray_Main[i0].Filename_Path, NewFilename);
			// re-create the filename only
			//strcpy(Flat_GlobalArray_Main[i0].Filename_Name, NewFilename);

			_splitpath( Flat_GlobalArray_Main[i0].DDF_Renamed, NULL, NULL, filename_only, filename_ext);
			if (filename_ext)
				{sprintf(NewFilename, "%s_%s%s", g_szFilenameTag, filename_only, filename_ext);}
			else
				{sprintf(NewFilename, "%s_%s", g_szFilenameTag, filename_only);}

			// re-create the filename
			strcpy(Flat_GlobalArray_Main[i0].DDF_Renamed, NewFilename);

			/*
			_splitpath( Flat_GlobalArray_Main[i0].INF_Rename_To, NULL, NULL, filename_only, filename_ext);
			if (filename_only)
			{
			if (filename_ext)
				{sprintf(NewFilename, "%s_%s%s", g_szFilenameTag, filename_only, filename_ext);}
			else
				{sprintf(NewFilename, "%s_%s", g_szFilenameTag, filename_only);}
			// re-create the filename
			strcpy(Flat_GlobalArray_Main[i0].INF_Rename_To, NewFilename);
			}
			*/
		}
	}
}


//-------------------------------------------------------------------
//  purpose: check for duplicate filenames
//-------------------------------------------------------------------
void Flat_GlobalArray_ChkDups(void)
{
    int i0 =0;
    int i1 =0;
    int i3 = 0;
    char filetemp[255];
    char filetempwhole[255];
    int theflag = FALSE;
    char checkagainst[255];
    int foundtheflag2 = FALSE;
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
        if (Flat_IsFileNameDup(i0))
            {
            printf (".");
            i1 = 0;
            // if the file exists outside a cab, then do not rename.
            // only rename files which exist in the cab.
            if (Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag == 0)
            {
                do
                {
                    theflag = FALSE;
                    // Give it a new name.
                    // then check if the name already exists.
                    i1++;
if (g_bCabbing_Flag != TRUE)
{
#ifdef USENEW
					if (i1 == 1)
					{
						// Count how many directory levels in There.
						int iDirLevelCount = 0;
						int z1 = 0;
						iDirLevelCount = ReturnDirLevelCount(Flat_GlobalArray_Main[i0].Filename_Full);

						strcpy(filetemp, Flat_GlobalArray_Main[i0].Filename_Path);
						if (iDirLevelCount >=1)
						{
							for( z1 = 0; z1 < iDirLevelCount;z1++)
								{strcat(filetemp, "..\\");}
						}
						
						/*

						strcpy(filetemp, "");
						if (iDirLevelCount >=1)
						{
							for( z1 = 0; z1 < iDirLevelCount;z1++)
								{strcat(filetemp, "..\\");}
						}
						strcat(filetemp, Flat_GlobalArray_Main[i0].Filename_Path);						
						*/

						// add the filename
						strcat(filetemp, Flat_GlobalArray_Main[i0].Filename_Name);
						
						strcpy(filetempwhole,filetemp);
					}
					else
					{
						sprintf(filetemp, "%s_%s%d", g_szFilenameTag, Flat_GlobalArray_Main[i0].Filename_Full, i1);
						strcpy(filetempwhole, Flat_GlobalArray_Main[i0].Filename_Path);
						strcat(filetempwhole, filetemp);
					}
#else
                    sprintf(filetemp, "%s_%s%d", g_szFilenameTag, Flat_GlobalArray_Main[i0].Filename_Name, i1);
                    strcpy(filetempwhole, Flat_GlobalArray_Main[i0].Filename_Path);
                    strcat(filetempwhole, filetemp);
#endif
}
else
{
                    sprintf(filetemp, "%s_%s%d", g_szFilenameTag, Flat_GlobalArray_Main[i0].Filename_Name, i1);
                    strcpy(filetempwhole, Flat_GlobalArray_Main[i0].Filename_Path);
                    strcat(filetempwhole, filetemp);
}
                
                    // check if the file exists..

                    // check if it already exists in our list...
                    strcpy(checkagainst, filetempwhole);
                    foundtheflag2= FALSE;

                    for (i3=0;i3<Flat_GlobalArrayIndex_Main.total;i3++)
                        {
                        if (i3 != i0)
                            {
                            if (_stricmp(Flat_GlobalArray_Main[i3].Filename_Name, filetemp) == 0)
                                {foundtheflag2= TRUE;}
                            else
                                {
                                if (_stricmp(Flat_GlobalArray_Main[i3].DDF_Renamed, filetemp) == 0)
                                    {foundtheflag2= TRUE;}
                                }
                            }
                        }

                    if (foundtheflag2 == FALSE)
                    {

                    // check if it already exists in the filesystem...
                    int   attr = 0;
                    intptr_t  hFile = 0;
                    finddata datareturn;
                    InitStringTable(STRING_TABLE_SIZE);
                    if ( FindFirst(filetempwhole, attr, &hFile, &datareturn) )
                        {
                        // shoot that blows, it already exists
                        // do it again.
                        theflag = FALSE;
                        }
                    else
                        {
                            theflag = TRUE;
                        }

                    }

                } while (theflag == FALSE);
            // Add to the ddf renamedfile place
            strcpy(Flat_GlobalArray_Main[i0].DDF_Renamed, filetemp);
            }
            
            }
        }
    printf ("\n");
    return;
}


//-------------------------------------------------------------------
//  purpose: check for duplicate filenames in filename column
//-------------------------------------------------------------------
int Flat_IsFileNameDup(int indextocheck)
{
	int iReturn = FALSE;
    int i0;
    char checkagainst[255];
    char checkagainst2[255];

    // check for exact duplicate.
    // if it is then we can't have any of these
    // Return false, because we will remove this entry later
    // it should return false, because the files are identical and do not need to be renamed.
    strcpy(checkagainst, Flat_GlobalArray_Main[indextocheck].Filename_Full);
    strcpy(checkagainst2, Flat_GlobalArray_Main[indextocheck].Filename_Name);
    for (i0=0;i0<Flat_GlobalArrayIndex_Main.total;i0++)
    //for (i0=0;i0<indextocheck;i0++)
        {
		iReturn = FALSE;
        if (i0 != indextocheck)
            {
			/*
			if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, checkagainst2) == 0)
			{
				if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, "global.asa") == 0)
				{
				printf(":");
				printf(Flat_GlobalArray_Main[i0].Filename_Full);
				printf("(");printf(Flat_GlobalArray_Main[i0].Filename_Name);printf(")");
				printf("[");printf(Flat_GlobalArray_Main[i0].DDF_Renamed);printf("]");

				printf(":");
				printf(Flat_GlobalArray_Main[indextocheck].Filename_Full);
				printf("(");printf(Flat_GlobalArray_Main[indextocheck].Filename_Name);printf(")");
				printf("[");printf(Flat_GlobalArray_Main[indextocheck].DDF_Renamed);printf("]");
				printf("\n");
				}
			}
			*/

            if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Full, checkagainst) == 0)
                {
				// We have a duplicate which we will ignore!
				//printf(Flat_GlobalArray_Main[i0].Filename_Full);
				//printf(".  Duplicate.1.!!!!\n");
				_stricmp(Flat_GlobalArray_Main[indextocheck].DDF_Renamed, Flat_GlobalArray_Main[i0].DDF_Renamed);
				iReturn = FALSE;
				goto Flat_IsFileNameDup_Exit;
				}
            else
                {
                if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, checkagainst2) == 0)
                    {
						// We have  a duplicate, check if this one has already been renamed though.
						if (_stricmp(Flat_GlobalArray_Main[i0].DDF_Renamed, checkagainst2) == 0)
						{
							//printf(".  Duplicate.2.!!!!\n");
							iReturn = TRUE;
							goto Flat_IsFileNameDup_Exit;
						}
						else
						{
							// check if what we are renaming indextocheck to, is the same as DDF_Renamed...
							if (_stricmp(Flat_GlobalArray_Main[i0].DDF_Renamed, Flat_GlobalArray_Main[indextocheck].DDF_Renamed) == 0)
							{
								//(".  Duplicate.3.!!!!\n");
								iReturn = TRUE;
								goto Flat_IsFileNameDup_Exit;
							}
						}

                    }

                }
            }

		// go on to the next one....
        }

    /*
    // Check for filename duplicate only
    strcpy(checkagainst, Flat_GlobalArray_Main[indextocheck].Filename_Name);
    for (i0=0;i0<Flat_GlobalArrayIndex_Main.total;i0++)
        {
        if (i0 != indextocheck)
            {
            if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, checkagainst) == 0)
                {return TRUE;}
            }
        }
        */
Flat_IsFileNameDup_Exit:
    return iReturn;
}


//-------------------------------------------------------------------
//  purpose: sort on CabFileName, then on Filename_Path
//-------------------------------------------------------------------
void Flat_GlobalArray_Sort_Cols2(BOOL bDescendFlag)
{
    int offset, inorder;
    int i;
    int j;
    int n;
    int result;
    int swapflag;

    FileReadLine tempentry;

    n = Flat_GlobalArrayIndex_Main.total;

    offset=n;
    do{
        offset = (8 * offset) /11;
        offset = (offset == 0) ? 1 : offset;
        inorder = TRUE;
        for (i=0,j=offset;i < (n - offset);i++,j++)
        {
            swapflag = FALSE;
            result = _stricmp(Flat_GlobalArray_Main[i].CabFileName, Flat_GlobalArray_Main[j].CabFileName);

            if (bDescendFlag)
            {
                if (result < 0)
                    {swapflag = TRUE;}
                else
                    {
                    if (result == 0)
                        {
                            result = _stricmp(Flat_GlobalArray_Main[i].Filename_Path, Flat_GlobalArray_Main[j].Filename_Path);
                            if (result < 0)
								{swapflag = TRUE;}
							else
							{
								if (result ==0)
								result = _stricmp(Flat_GlobalArray_Main[i].Filename_Name, Flat_GlobalArray_Main[j].Filename_Name);
								if (result < 0)
									{swapflag = TRUE;}
							}
                        }
                    }
            }
            else
            {
                // check if larger
                if (result > 0)
                    {swapflag = TRUE;}
                else
                    {
                    if (result == 0)
                        {
                            result = _stricmp(Flat_GlobalArray_Main[i].Filename_Path, Flat_GlobalArray_Main[j].Filename_Path);
                            // check if larger
                            if (result > 0)
								{swapflag = TRUE;}
							else
							{
								if (result ==0)
								result = _stricmp(Flat_GlobalArray_Main[i].Filename_Name, Flat_GlobalArray_Main[j].Filename_Name);
								if (result > 0)
									{swapflag = TRUE;}
							}
                        }
                    }
            }


            if (swapflag == TRUE)
                {
                inorder = FALSE;

                // do the swap
                // move into temp
                tempentry = Flat_GlobalArray_Main[i];

                // move into original
                Flat_GlobalArray_Main[i] = Flat_GlobalArray_Main[j];

                // move temp into other
                Flat_GlobalArray_Main[j] = tempentry;
                }
        }
    } while (!(offset == 1 && inorder == TRUE));

    return;
}

//-------------------------------------------------------------------
//  purpose: sort on INF_Sections only
//-------------------------------------------------------------------
void Flat_GlobalArray_Sort_Cols1()
{
    int offset, inorder;
    int i;
    int j;
    int n;
    int result;
    FileReadLine tempentry;

    n = Flat_GlobalArrayIndex_Main.total;

    offset=n;
    do{
        offset = (8 * offset) /11;
        offset = (offset == 0) ? 1 : offset;
        inorder = TRUE;
        for (i=0,j=offset;i < (n - offset);i++,j++)
        {

            result = _stricmp(Flat_GlobalArray_Main[i].INF_Sections, Flat_GlobalArray_Main[j].INF_Sections);
            if (result > 0)
            {
                inorder = FALSE;

                // do the swap
                 // move into temp
                tempentry = Flat_GlobalArray_Main[i];

                // move into original
                Flat_GlobalArray_Main[i] = Flat_GlobalArray_Main[j];

                // move temp into other
                Flat_GlobalArray_Main[j] = tempentry;

            }
        }
    } while (!(offset == 1 && inorder == TRUE));

    return;
}


//-------------------------------------------------------------------
//  purpose: sort on INF_Sections then on filename
//-------------------------------------------------------------------
void Flat_GlobalArray_Sort_Cols1a(BOOL bDescendFlag)
{
    int offset, inorder;
    int i;
    int j;
    int n;
    int result;
    int swapflag;

    FileReadLine tempentry;

    n = Flat_GlobalArrayIndex_Main.total;

    offset=n;
    do{
        offset = (8 * offset) /11;
        offset = (offset == 0) ? 1 : offset;
        inorder = TRUE;
        for (i=0,j=offset;i < (n - offset);i++,j++)
        {
            swapflag = FALSE;
            result = _stricmp(Flat_GlobalArray_Main[i].INF_Sections, Flat_GlobalArray_Main[j].INF_Sections);

            if (bDescendFlag)
            {
                if (result < 0)
                    {swapflag = TRUE;}
                else
                    {
                    if (result == 0)
                        {
                            result = _stricmp(Flat_GlobalArray_Main[i].Filename_Name, Flat_GlobalArray_Main[j].Filename_Name);
                            if (result < 0){swapflag = TRUE;}
                        }
                    }
            }
            else
            {
                // check if larger
                if (result > 0)
                    {swapflag = TRUE;}
                else
                    {
                    if (result == 0)
                        {
                            result = _stricmp(Flat_GlobalArray_Main[i].Filename_Name, Flat_GlobalArray_Main[j].Filename_Name);
                            // check if larger
                            if (result > 0){swapflag = TRUE;}
                        }
                    }
            }


            if (swapflag == TRUE)
                {
                inorder = FALSE;

                // do the swap
                // move into temp
                tempentry = Flat_GlobalArray_Main[i];

                // move into original
                Flat_GlobalArray_Main[i] = Flat_GlobalArray_Main[j];

                // move temp into other
                Flat_GlobalArray_Main[j] = tempentry;
                }
        }
    } while (!(offset == 1 && inorder == TRUE));

    return;
}



//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_GlobalArray_Print(void)
{
    int  i0;
    int  total;
    char bigtemp[20];

    total = Flat_GlobalArrayIndex_Main.total;

    for( i0 = 0; i0 < total;i0++)
        {
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].NTS_x86_flag);
        printf (bigtemp); printf(",");
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].NTW_x86_flag);
        printf (bigtemp); printf(",");

        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Win95_flag);
        printf (bigtemp); printf(",");
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Win98_flag);
        printf (bigtemp); printf(",");

        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].NTS_alpha_flag);
        printf (bigtemp); printf(",");
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].NTW_alpha_flag);
        printf (bigtemp); printf(",");

        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Other_os_flag);
        printf (bigtemp); printf(",");

        printf(Flat_GlobalArray_Main[i0].CabFileName);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].INF_Sections);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].Filename_Full);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].Filename_Name);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].Filename_Path);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].DDF_Renamed);
        printf(",");
        printf(Flat_GlobalArray_Main[i0].INF_Rename_To);
        printf(",");
        sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag);
        printf (bigtemp); printf(",");
		sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Do_Not_Show_Error_Flag);
		printf (bigtemp); printf(",");
		sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].Do_Not_Include_file_if_cabEmpty_Flag);
		printf (bigtemp); printf(",");
		sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].GetFromSlipStreamDisk);
		printf (bigtemp); printf(",");
		sprintf(bigtemp, "%d", Flat_GlobalArray_Main[i0].FileName_Size);
		printf (bigtemp);
		printf ("\n");
        }

    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_Create_Output_INF(void)
{
    int i0;
    fstream f;
	fstream f2;
    fstream f3;
    fstream f4;
    fstream f5;
    char last_section[255];
    char this_section[255];
    char tempstring[255];
    char fullpath[_MAX_PATH];
    int Changed_f4 = FALSE;
    int Changed_f5 = FALSE;

    if (!g_bChangeListOnly)
    {
	    f.open(g_szINFOutput, ios::out);
        f3.open(g_szCATOutput, ios::out);
    }

    f4.open(g_szCNGOutput, ios::out);
    f5.open(g_szLOCOutput, ios::out);


if (g_bCabbing_Flag == TRUE)
{
	// Produce .inf file for use with .ddf file
	// for generating cabs!!!
	// ----------------------------------------
	
	// Produce the top half -- the sections
	// bottom half -- producted by diamond using.ddf file
	// ------------------------------------
    strcpy(last_section, " ");
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
        Changed_f4 = FALSE;
        Changed_f5 = FALSE;
        strcpy(this_section, Flat_GlobalArray_Main[i0].INF_Sections);

        // For each new section change.
        if (_stricmp(this_section, last_section) != 0)
        {
            if (!g_bChangeListOnly)
            {
                // print out new section stuff
                f.write("\n", 1);
                sprintf(tempstring, "[%s]\n", this_section);
                f.write (tempstring, strlen(tempstring));
            }

            strcpy(last_section, this_section);
        }

		if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
		{
            // write it out to the .cat file
//            strcpy(tempstring,Flat_GlobalArray_Main[i0].Filename_Name);
//            // take out trailing spaces.
//            f3.write(tempstring, strlen(tempstring));

            TCHAR * pmyfilename;
            pmyfilename = fullpath;
            TCHAR myPath[_MAX_PATH];
            // Resolve relative path to real path
            if (0 != GetFullPathName(Flat_GlobalArray_Main[i0].Filename_Full, _MAX_PATH, myPath, &pmyfilename))
            {
                if (!g_bChangeListOnly)
                {
                    // should look like this
                    // <HASH>d:\mydir\myfile=d:\mydir\myfile
                    strcpy(tempstring,"<HASH>");
                    f3.write(tempstring, strlen(tempstring));

                    strcpy(tempstring,myPath);
                    f3.write(tempstring, strlen(tempstring));

                    strcpy(tempstring,"=");
                    f3.write(tempstring, strlen(tempstring));

                    strcpy(tempstring,myPath);
                    f3.write(tempstring, strlen(tempstring));
                }

                if (g_bChangeListOnly2)
                {
                    // write out entry for change list.
                    strcpy(tempstring,myPath);
                    f4.write(tempstring, strlen(tempstring));
                    Changed_f4 = TRUE;
                }
                else if (Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag == 0)
                {
                    // write out entry for change list
                    strcpy(tempstring,myPath);
                    f4.write(tempstring, strlen(tempstring));
                    Changed_f4 = TRUE;
                }

                if (Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag == 1)
                {
                    // write out entry for localization (list of files in binaries dir outside of cab)
                    strcpy(tempstring,pmyfilename);
                    f5.write(tempstring, strlen(tempstring));
                    Changed_f5 = TRUE;
                }

            }

			// Check if this file has the rename stuff set and additional info there,
			// don't write the \n until past this part..
			if (_stricmp(Flat_GlobalArray_Main[i0].INF_Rename_To,"") == 0)
				{
				// write out the filename!
				// print out the filename
				if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, Flat_GlobalArray_Main[i0].DDF_Renamed) == 0)
					{
					    strcpy(tempstring,Flat_GlobalArray_Main[i0].Filename_Name);
                        if (!g_bChangeListOnly)
                        {
					        f.write (tempstring, strlen(tempstring));
                        }
                        // append on overwrite all the time
                        // notice the two commas!
                        //f.write (",,4",3);
					}
				else
					{
					    // rename to:
					    strcpy(tempstring, Flat_GlobalArray_Main[i0].Filename_Name);
                        if (!g_bChangeListOnly)
                        {
					        f.write (tempstring, strlen(tempstring));
                        }
					    // rename from:
					    strcpy(tempstring, Flat_GlobalArray_Main[i0].DDF_Renamed);
                        if (!g_bChangeListOnly)
                        {
					        f.write (",",1);
					        f.write (tempstring, strlen(tempstring));
                            // append on overwrite all the time
                            //f.write (",4",2);
                        }
					}
				}
			else
				{
				    // the rename flag was set and the filename is in there.
				    // format:  rename to, rename from
                    if (!g_bChangeListOnly)
                    {

				        // rename to:
				        strcpy(tempstring, Flat_GlobalArray_Main[i0].INF_Rename_To);
				        f.write (tempstring, strlen(tempstring));

				        // rename from:
				        strcpy(tempstring, Flat_GlobalArray_Main[i0].DDF_Renamed);
				        f.write (",",1);
				        f.write (tempstring, strlen(tempstring));

                        // append on overwrite all the time
                        //f.write (",4",2);
                    }
				}
		}

        // ok, now it's kool to write this part.
        f.write("\n", 1);
        f3.write("\n", 1);
            if (Changed_f4)
            {
                f4.write("\n", 1);
            }
            if (Changed_f5)
            {
                f5.write("\n", 1);
            }
        }

        if (!g_bChangeListOnly)
        {
	        f.close();
            f3.close();
        }
        f4.close();
        f5.close();
}
else
{
	// Produce .inf file for use without anything else!!!
	// no need corresponding .ddf file for these!!!
	// ----------------------------------------

	// Produce the top half -- the sections
	// ------------------------------------
    strcpy(last_section, " ");
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
        strcpy(this_section, Flat_GlobalArray_Main[i0].INF_Sections);

        // For each new section change.
        if (_stricmp(this_section, last_section) != 0)
            {
            if (!g_bChangeListOnly)
            {
                // print out new section stuff
                f.write("\n", 1);
                sprintf(tempstring, "[%s]\n", this_section);
                f.write (tempstring, strlen(tempstring));
            }

            strcpy(last_section, this_section);
            }

#ifdef USENEW
		if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
		{
			// Check if this file has the rename stuff set and additional info there,
			// don't write the \n until past this part..
			if (_stricmp(Flat_GlobalArray_Main[i0].INF_Rename_To,"") == 0)
				{
				// write out the filename!
				// print out the filename
				if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, Flat_GlobalArray_Main[i0].DDF_Renamed) == 0)
					{
                        if (!g_bChangeListOnly)
                        {
					        strcpy(tempstring,Flat_GlobalArray_Main[i0].Filename_Name);
					        f.write (tempstring, strlen(tempstring));
                        // append on overwrite all the time
                        // notice the two commas!
                        //f.write (",,4",3);
                        }

					}
				else
					{
                        if (!g_bChangeListOnly)
                        {
					        // rename to:
					        strcpy(tempstring, Flat_GlobalArray_Main[i0].Filename_Name);
					        f.write (tempstring, strlen(tempstring));

					        // rename from:
					        strcpy(tempstring, Flat_GlobalArray_Main[i0].DDF_Renamed);
					        f.write (",",1);
					        f.write (tempstring, strlen(tempstring));
                            // append on overwrite all the time
                            //f.write (",4",2);
                        }
					}
				}
			else
				{
                    if (!g_bChangeListOnly)
                    {
                        // the rename flag was set and the filename is in there.
				        // format:  rename to, rename from

				        // rename to:
				        strcpy(tempstring, Flat_GlobalArray_Main[i0].INF_Rename_To);
				        f.write (tempstring, strlen(tempstring));

				        // rename from:
				        strcpy(tempstring, Flat_GlobalArray_Main[i0].DDF_Renamed);
				        f.write (",",1);
				        f.write (tempstring, strlen(tempstring));
                        // append on overwrite all the time
                        //f.write (",4",2);
                    }
				}
		}
#else
            if (!g_bChangeListOnly)
            {
			    // write out the filename!
			    // like this: filename.txt, inetsrv\test\test\filename.txt
			    strcpy(tempstring,Flat_GlobalArray_Main[i0].Filename_Name);
			    f.write (tempstring, strlen(tempstring));
			    strcpy(tempstring, ",");
			    f.write(tempstring, strlen(tempstring));
                strcpy(tempstring,Flat_GlobalArray_Main[i0].Filename_Full);
                f.write (tempstring, strlen(tempstring));
            }
#endif

            if (!g_bChangeListOnly)
            {
		    f.write("\n", 1);
            }
        }

	// Produce the bottom half -- the sections
	// ------------------------------------
	// use f2 for some other batch processing.
    if (!g_bChangeListOnly)
    {
 	    f2.open(g_szLSTOutput, ios::out);

	    //[SourceDisksNames]
	    //; file names and associated disks
	    //; diskid = description,tagfile,unused,subdir
	    //0="Setup Files","",0
	    f.write("\n\n", 2);
	    strcpy(tempstring, "[SourceDisksNames]\n");
        f.write(tempstring, strlen(tempstring));
	    strcpy(tempstring, ";Filenames and asociated disks\n");
	    f.write(tempstring, strlen(tempstring));
	    strcpy(tempstring, ";diskid = description,tagfile,unused,subdir\n");
        f.write(tempstring, strlen(tempstring));
#ifdef USENEW
	    FillGlobalUniqueDirList();
	    //0="Setup Files","",inetsrv
	    //1="Setup Files","",inetsrv\help
	    //2="Setup Files","",inetsrv\help\testing
int i9;
	    for( i9 = 0; i9 < Flat_GlobalUniqueDirList_total;i9++)
	    {
		    // REmove trailing slash character Flat_GlobalUniqueDirList[i9])
		    char tempdir[_MAX_PATH];
		    char *temppointer = NULL;
		    strcpy(tempdir, Flat_GlobalUniqueDirList[i9]);
		    temppointer = strrchr(tempdir, '\\');
		    if (temppointer) { (*temppointer) = '\0';}

		    sprintf(tempstring, "%d=\"Setup Files\",,,%s\n", i9, tempdir);
		    f.write(tempstring, strlen(tempstring));
	    }
#else
	    strcpy(tempstring, "0 = \"Setup Files\", \"\",0, \"\"\n");
        f.write(tempstring, strlen(tempstring));
	    strcpy(tempstring, "\n\n");
        f.write(tempstring, strlen(tempstring));
#endif

	    //[SourceDisksNames.x86]
	    //; file names and associated disks
	    //; diskid = description,tagfile,unused,subdir
	    //0="Setup Files","",0
	    f.write("\n\n", 2);
	    strcpy(tempstring, "[SourceDisksNames.x86]\n");
        f.write(tempstring, strlen(tempstring));
	    strcpy(tempstring, ";Filenames and asociated disks\n");
	    f.write(tempstring, strlen(tempstring));
	    strcpy(tempstring, ";diskid = description,tagfile,unused,subdir\n");
        f.write(tempstring, strlen(tempstring));
#ifdef USENEW
	    FillGlobalUniqueDirList();
	    //0="Setup Files","",inetsrv
	    //1="Setup Files","",inetsrv\help
	    //2="Setup Files","",inetsrv\help\testing
	    for(i9 = 0; i9 < Flat_GlobalUniqueDirList_total;i9++)
	    {
		    // REmove trailing slash character Flat_GlobalUniqueDirList[i9])
		    char tempdir[_MAX_PATH];
		    char *temppointer = NULL;
		    strcpy(tempdir, Flat_GlobalUniqueDirList[i9]);
		    temppointer = strrchr(tempdir, '\\');
		    if (temppointer) { (*temppointer) = '\0';}

		    sprintf(tempstring, "%d=\"Setup Files\",,,%s\n", i9, tempdir);
		    f.write(tempstring, strlen(tempstring));
	    }
#else
	    strcpy(tempstring, "0 = \"Setup Files\", \"\",0, \"\",\i386\n");
        f.write(tempstring, strlen(tempstring));
	    strcpy(tempstring, "\n\n");
        f.write(tempstring, strlen(tempstring));
#endif

	    //[SourceDisksNames.Alpha]
	    //; file names and associated disks
	    //; diskid = description,tagfile,unused,subdir
	    //0="Setup Files","",0
	    f.write("\n\n", 2);
	    strcpy(tempstring, "[SourceDisksNames.Alpha]\n");
        f.write(tempstring, strlen(tempstring));
	    strcpy(tempstring, ";Filenames and asociated disks\n");
	    f.write(tempstring, strlen(tempstring));
	    strcpy(tempstring, ";diskid = description,tagfile,unused,subdir\n");
        f.write(tempstring, strlen(tempstring));
#ifdef USENEW
	    FillGlobalUniqueDirList();
	    //0="Setup Files","",inetsrv
	    //1="Setup Files","",inetsrv\help
	    //2="Setup Files","",inetsrv\help\testing
	    for(i9 = 0; i9 < Flat_GlobalUniqueDirList_total;i9++)
	    {
		    // REmove trailing slash character Flat_GlobalUniqueDirList[i9])
		    char tempdir[_MAX_PATH];
		    char *temppointer = NULL;
		    strcpy(tempdir, Flat_GlobalUniqueDirList[i9]);
		    temppointer = strrchr(tempdir, '\\');
		    if (temppointer) { (*temppointer) = '\0';}

		    sprintf(tempstring, "%d=\"Setup Files\",,,%s\n", i9, tempdir);
		    f.write(tempstring, strlen(tempstring));
	    }
#else
	    strcpy(tempstring, "0 = \"Setup Files\", \"\",0, \"\",\Alpha\n");
        f.write(tempstring, strlen(tempstring));
	    strcpy(tempstring, "\n\n");
        f.write(tempstring, strlen(tempstring));
#endif

	    //; filename_on_source = diskid,subdir,size,checksum,spare,spare
	    //[SourceDisksFiles]
	    //_default.pif = 1,,1024,,,,,1,3
	    strcpy(tempstring, "; filename_on_source = diskid,subdir,size,checksum,spare,spare\n");
        f.write(tempstring, strlen(tempstring));
	    strcpy(tempstring, "[SourceDisksFiles]\n");
        f.write(tempstring, strlen(tempstring));

        for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
            {
		    // filename and directory
		    // filename.txt = 0,subdirectory
		    //sprintf(tempstring, "%s = 0\n", Flat_GlobalArray_Main[i0].Filename_Full);
#ifdef USENEW
		    if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
		    {
			    // Check if this file has the rename stuff set and additional info there,
			    // don't write the \n until past this part..
			    if (_stricmp(Flat_GlobalArray_Main[i0].INF_Rename_To,"") == 0)
				    {
				    // write out the filename!
				    // print out the filename

//[SourceDisksFiles]
//..\test1\cfw.pdb=2,,2
				    if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, Flat_GlobalArray_Main[i0].DDF_Renamed) == 0)
					    {
					    int indexmatch = GlobalUniqueDirReturnMyIndexMatch(Flat_GlobalArray_Main[i0].Filename_Path);
					    sprintf(tempstring, "%s=%d", Flat_GlobalArray_Main[i0].Filename_Name, indexmatch);
					    f.write (tempstring, strlen(tempstring));
					    }
				    else
					    {
					    // rename from:
					    int indexmatch = GlobalUniqueDirReturnMyIndexMatch(Flat_GlobalArray_Main[i0].Filename_Path);
					    sprintf(tempstring, "%s=%d", Flat_GlobalArray_Main[i0].DDF_Renamed,indexmatch);
					    f.write (tempstring, strlen(tempstring));
					    }
				    }
			    else
				    {
				    // the rename flag was set and the filename is in there.
				    // rename from:
				    int indexmatch = GlobalUniqueDirReturnMyIndexMatch(Flat_GlobalArray_Main[i0].Filename_Path);
				    sprintf(tempstring, "%s=%d", Flat_GlobalArray_Main[i0].DDF_Renamed,indexmatch);
				    f.write (tempstring, strlen(tempstring));
				    }
		    }
		    f.write("\n", 1);
#else
		    sprintf(tempstring, "%s\n", Flat_GlobalArray_Main[i0].Filename_Full);
		    f.write(tempstring, strlen(tempstring));
#endif
    //if (strcmp(Flat_GlobalArray_Main[i0].Filename_Path, "") == 0)
    //  {sprintf(tempstring, "%s;.\n", Flat_GlobalArray_Main[i0].Filename_Full);}
    //else
    //  {sprintf(tempstring, "%s;%s\n", Flat_GlobalArray_Main[i0].Filename_Full, Flat_GlobalArray_Main[i0].Filename_Path);}

		    //sprintf(tempstring, "%s\\%s;%s\n", g_szCurrentDir,Flat_GlobalArray_Main[i0].Filename_Full,Flat_GlobalArray_Main[i0].Filename_Full);
		    sprintf(tempstring, "%s\\%s\n", g_szCurrentDir,Flat_GlobalArray_Main[i0].Filename_Full);
		    f2.write(tempstring, strlen(tempstring));
            }
	    f2.close();
    }
    f.close();
    }
    return;
}


//-------------------------------------------------------------------
//  purpose: ok, loop thru the array and create the ddf details...
//-------------------------------------------------------------------
void Flat_Create_Output_DDF(void)
{
    fstream f;
    char thefilename[255];
    int i0;
    int i1;
    int i2;
    int i3;

    char last_cab[50];
    char last_sourcedir[255];
    char this_cab[50];
    char this_sourcedir[255];

    char tempstring[255];

    // used for list of all cab's
    char tempcablist[20][255];
    int tempcablist_nextuse;
    int tempcablist_total;
    int found;
    char temp_cab[50];

    // loop thru all globalarray stuff and get all the cab filenames and stick into the tempcablist.
    tempcablist_nextuse = 0;
    tempcablist_total = 0;
    for(i1=0;i1<Flat_GlobalArrayIndex_Main.total;i1++)
    {
        found=FALSE;
		if (Flat_DoWeIncludeThisFileCheck(i1) == TRUE)
		{
			strcpy(temp_cab, Flat_GlobalArray_Main[i1].CabFileName);
			// loop thru array to see if it's already there.
			for(i2=0;i2<tempcablist_total;i2++)
				{
				if (_stricmp(tempcablist[i2], temp_cab) == 0)
					{found=TRUE;}
				}
			if (found==FALSE)
				{
				// add it
				strcpy(tempcablist[tempcablist_nextuse],temp_cab);
				tempcablist_nextuse++;
				tempcablist_total++;
				}
		}
    }


    // ok, create our little output file...
    f.open(g_szDDFOutput, ios::out);
    strcpy(last_cab, "0");
    strcpy(last_sourcedir, "-");
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
        strcpy(this_cab, Flat_GlobalArray_Main[i0].CabFileName);
        strcpy(this_sourcedir, Flat_GlobalArray_Main[i0].INF_Sections);
        _splitpath( Flat_GlobalArray_Main[i0].Filename_Full, NULL, this_sourcedir, NULL, NULL);
        
		if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
		{

        // For each Cab Type...
        if (_stricmp(this_cab, last_cab) != 0)
            {

            // Check if it is the first time!
            if (_stricmp(last_cab, "0") == 0)
                {
                strcpy(tempstring, "\n;***** LAYOUT SECTION (Generated) ***** \n");
                f.write (tempstring, strlen(tempstring));
                // print out all the cabinet names
                // loop thru the list of cabinet names and print them out.
                for(i2=0;i2<tempcablist_total;i2++)
                    {
                    sprintf(tempstring, "  .Set CabinetName%d=%s\n", i2+1, tempcablist[i2]);
                    f.write (tempstring, strlen(tempstring));
                    }
                f.write("\n", 1);

                // Set Generate INF=on!!!!
                strcpy(tempstring, ".Set GenerateInf=On\n");
                f.write (tempstring, strlen(tempstring));
                f.write("\n", 1);

                // Do files which don't get included into the cab files..
                strcpy(tempstring, ";*** Files not to include in Cab.\n");
                f.write (tempstring, strlen(tempstring));
                // Set source
                // list files.

                char last_filepath[255];
                char this_filepath[255];

				strcpy(g_non_cablist_temp[0].Filename_Name, "");
                g_non_cablist_temp_nextuse = 0;
                g_non_cablist_temp_total = 0;
                int itexists;

                for(i3=0;i3<Flat_GlobalArrayIndex_Main.total;i3++)
                    {
                    // check if this entry has the ddf_excludefromcab flag set.
                    if (Flat_GlobalArray_Main[i3].DDF_Exclude_From_Cab_Flag)
                        {
                        // add only if not already there...
                        itexists = FALSE;
                        for (int i6=0;i6<g_non_cablist_temp_total;i6++)
                            {
                            if (_stricmp(g_non_cablist_temp[i6].Filename_Name,Flat_GlobalArray_Main[i3].Filename_Name)==0)
                                {itexists = TRUE;}
                            }

                        if (itexists == FALSE)
                        {
                        // Add to our temporary array...
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].NTS_x86_flag = Flat_GlobalArray_Main[i3].NTS_x86_flag;
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].NTW_x86_flag = Flat_GlobalArray_Main[i3].NTW_x86_flag;
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].Win95_flag = Flat_GlobalArray_Main[i3].Win95_flag;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].Win98_flag = Flat_GlobalArray_Main[i3].Win98_flag;
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].NTS_alpha_flag = Flat_GlobalArray_Main[i3].NTS_alpha_flag;
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].NTW_alpha_flag = Flat_GlobalArray_Main[i3].NTW_alpha_flag;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].Other_os_flag = Flat_GlobalArray_Main[i3].Other_os_flag;
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].CabFileName,Flat_GlobalArray_Main[i3].CabFileName);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].INF_Sections,Flat_GlobalArray_Main[i3].INF_Sections);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].Filename_Full,Flat_GlobalArray_Main[i3].Filename_Full);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].Filename_Name,Flat_GlobalArray_Main[i3].Filename_Name);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].Filename_Path,Flat_GlobalArray_Main[i3].Filename_Path);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].DDF_Renamed,Flat_GlobalArray_Main[i3].DDF_Renamed);
                        strcpy(g_non_cablist_temp[g_non_cablist_temp_nextuse].INF_Rename_To,Flat_GlobalArray_Main[i3].INF_Rename_To);
                        g_non_cablist_temp[g_non_cablist_temp_nextuse].DDF_Exclude_From_Cab_Flag = Flat_GlobalArray_Main[i3].DDF_Exclude_From_Cab_Flag;

                        g_non_cablist_temp[g_non_cablist_temp_nextuse].Do_Not_Show_Error_Flag = Flat_GlobalArray_Main[i3].Do_Not_Show_Error_Flag;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].Do_Not_Include_file_if_cabEmpty_Flag = Flat_GlobalArray_Main[i3].Do_Not_Include_file_if_cabEmpty_Flag;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].FileName_Size = Flat_GlobalArray_Main[i3].FileName_Size;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].FileWasNotActuallyFoundToExist = Flat_GlobalArray_Main[i3].FileWasNotActuallyFoundToExist;
						g_non_cablist_temp[g_non_cablist_temp_nextuse].GetFromSlipStreamDisk = Flat_GlobalArray_Main[i3].GetFromSlipStreamDisk;

						/*
						if (Flat_GlobalArray_Main[i3].FileWasNotActuallyFoundToExist)
						{
						printf(Flat_GlobalArray_Main[i3].Filename_Full);
						printf(".  HEY..\n");
						}
						*/


                            g_non_cablist_temp_nextuse++;
                            g_non_cablist_temp_total++;
                            }
                        }
                    }


                // sort the array
                int offset, inorder, isort, jsort, niterate, resultsort; //, i0sort;
                //FileReadLine tempentrysort[MAX_ARRAY_SMALL];
				FileReadLine tempentrysort;
                niterate = g_non_cablist_temp_total;
                offset=niterate;
                do{
                    offset = (8 * offset) /11;
                    offset = (offset == 0) ? 1 : offset;
                    inorder = TRUE;
                    for (isort=0,jsort=offset;isort < (niterate - offset);isort++,jsort++)
                    {
                        resultsort = _stricmp(g_non_cablist_temp[isort].Filename_Path, g_non_cablist_temp[jsort].Filename_Path);
                        if (resultsort > 0)
                        {
                            inorder = FALSE;

                // do the swap
                // move into temp
                tempentrysort = g_non_cablist_temp[isort];

                // move into original
                g_non_cablist_temp[isort] = g_non_cablist_temp[jsort];

                // move temp into other
                g_non_cablist_temp[jsort] = tempentrysort;

				/* weird to stuff..
                            // do the swap
                             // move into temp
                            for (i0sort=0;i0sort<MAX_ARRAY_SMALL;i0sort++)
                                {
                                tempentrysort[i0sort] = g_non_cablist_temp[isort];
                                //strcpy(tempentrysort[i0sort].thestring,(g_non_cablist_temp[isort].thecol[i0sort].thestring));
                                }
                            // move into original
                            for (i0sort=0;i0sort<MAX_ARRAY_SMALL;i0sort++)
                                {
								// move into original
                                Flat_GlobalArray_Main[isort] = g_non_cablist_temp[jsort];
                                //strcpy( Flat_GlobalArray_Main[isort].thecol[i0sort].thestring, g_non_cablist_temp[jsort].thecol[i0sort].thestring);
                                }
                            // move temp into other
                            for (i0sort=0;i0sort<MAX_ARRAY_SMALL;i0sort++)
                                {
                                g_non_cablist_temp[jsort] = tempentrysort[i0sort];
                                //strcpy(g_non_cablist_temp[jsort].thecol[i0sort].thestring, tempentrysort[i0sort].thestring);
                                }
								*/
                        }
                    }
                } while (!(offset == 1 && inorder == TRUE));


                strcpy(tempstring, ".Set Compress=OFF\n");
                f.write (tempstring, strlen(tempstring));
                strcpy(tempstring, ".Set Cabinet=OFF\n");
                f.write (tempstring, strlen(tempstring));


                // loop thru our new array, and output stuff
                strcpy(last_filepath,"0");
                for (int i5=0;i5<g_non_cablist_temp_total;i5++)
                    {
                    strcpy(this_filepath, g_non_cablist_temp[i5].Filename_Path);

                    if (_stricmp(last_filepath, this_filepath) != 0)
                        {
                        // take the dir and write it out
                        f.write("\n", 1);
                        sprintf(tempstring, ".Set SourceDir=%s\n", this_filepath);
                        f.write (tempstring, strlen(tempstring));
                        strcpy(last_filepath, this_filepath);
                        }

					if (g_non_cablist_temp[i5].FileWasNotActuallyFoundToExist)
					{
						printf(g_non_cablist_temp[i5].Filename_Full);
						printf(".  FileWasNotActuallyFoundToExist.skip write to ddf..\n");
                        g_iGlobalReturnCode = FALSE;
					}
					else
					{
						// print out the filename
						if (_stricmp(g_non_cablist_temp[i5].Filename_Name, g_non_cablist_temp[i5].DDF_Renamed) == 0)
							{strcpy(tempstring,g_non_cablist_temp[i5].Filename_Name);}
						else
							{
							strcpy(tempstring,g_non_cablist_temp[i5].Filename_Name);
							strcat(tempstring," ");
							strcat(tempstring,g_non_cablist_temp[i5].DDF_Renamed);
							}
						f.write (tempstring, strlen(tempstring));

						// files which are outside of the cab should have the unique flag set.
						// of cource, because they are all in the same place!!

                                                // check if this is one of those "special" files which
                                                // come from a service pack.
                                                if (g_non_cablist_temp[i5].GetFromSlipStreamDisk == 0)
                                                {
                                                 strcpy(tempstring, "\t/unique=yes");
                                                }
                                                else
                                                {
                                                 sprintf(tempstring,"\t/unique=yes /cab#=%d", g_iSlipStreamDiskID);
                                                }
						f.write (tempstring, strlen(tempstring));
						f.write("\n", 1);
					}
                    }



                f.write("\n", 1);

                // Files which do get included in the Cab
                strcpy(tempstring, ";*** Files to include in Cabs.\n");
                f.write (tempstring, strlen(tempstring));

                f.write(";\n", 2);
                sprintf(tempstring, ";  Cab File = %s\n", this_cab);
                f.write (tempstring, strlen(tempstring));
                f.write(";\n", 2);

                // Set cabinet on and compress on.
                strcpy(tempstring, ".Set Cabinet=on\n");
                f.write (tempstring, strlen(tempstring));
                strcpy(tempstring, ".Set Compress=on\n");
                f.write (tempstring, strlen(tempstring));

                }
            else
                {
                f.write("\n;\n", 3);
                sprintf(tempstring, ";  Cab File = %s\n", this_cab);
                f.write (tempstring, strlen(tempstring));
                f.write(";\n", 2);
                // Write new stuff for every new cabinet
                strcpy(tempstring, ".Set Cabinet=off\n");
                f.write (tempstring, strlen(tempstring));
                strcpy(tempstring, ".Set Cabinet=on\n");
                f.write (tempstring, strlen(tempstring));
                strcpy(tempstring, ".New Cabinet\n");
                f.write (tempstring, strlen(tempstring));
                }

            strcpy(last_cab, this_cab);
            }

        // Copy over the filename
        // don't copy over if the file should not be
        // included in the the cab file.
        //if (_stricmp(Flat_GlobalArray_Main[i0].thecol[COL_DDF_EXCLUDEFROMCAB].thestring,"true") != 0)
        if (!(Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag))
            {
            // don't copy over if the same file, in the same directory for the same cab file
            // exists already.  this could happen if they want the same file in different
            // sections....
            if (Flat_DDFDoesThisFileCabAlreadyExists(i0) == FALSE)
                {
				//if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE) {

					// For each new directory change
					if (_stricmp(this_sourcedir, last_sourcedir) != 0)
						{
						// print out new section stuff
						f.write("\n", 1);
						sprintf(tempstring, ".Set SourceDir=%s\n", this_sourcedir);
						f.write (tempstring, strlen(tempstring));

						strcpy(last_sourcedir, this_sourcedir);
						}

					// write out the filename!
					strcpy(thefilename, Flat_GlobalArray_Main[i0].Filename_Name);

					if (_stricmp(Flat_GlobalArray_Main[i0].Filename_Name, Flat_GlobalArray_Main[i0].DDF_Renamed) == 0)
						{
						// Check for spaces
						if (strchr(Flat_GlobalArray_Main[i0].Filename_Name, ' ') != NULL)
							{
							strcpy(thefilename, "\"");
							strcat(thefilename,Flat_GlobalArray_Main[i0].Filename_Name);
							strcat(thefilename, "\"");
							}
						else
							{strcpy(thefilename,Flat_GlobalArray_Main[i0].Filename_Name);}
						}
					else
						{
						// Check for spaces
						if (strchr(Flat_GlobalArray_Main[i0].Filename_Name, ' ') != NULL)
							{
							strcpy(thefilename, "\"");
							strcat(thefilename,Flat_GlobalArray_Main[i0].Filename_Name);
							strcat(thefilename, "\"");
							}
						else
							{
							strcpy(thefilename,Flat_GlobalArray_Main[i0].Filename_Name);
							}
						strcat(thefilename," ");

						// check for spaces
						if (strchr(Flat_GlobalArray_Main[i0].DDF_Renamed, ' ') != NULL)
							{
							strcpy(thefilename, "\"");
							strcat(thefilename,Flat_GlobalArray_Main[i0].DDF_Renamed);
							strcat(thefilename, "\"");
							}
						else
							{
							strcat(thefilename,Flat_GlobalArray_Main[i0].DDF_Renamed);
							}
                    
						}

					f.write (thefilename, strlen(thefilename));

					// Check if this file has the unique flag set.
					// don't write the \n until past this part..
					/*if (_stricmp(Flat_GlobalArray_Main[i0].thecol[COL_DDF_UNIQUE].thestring,"true")) == 0)
						{
							strcpy(tempstring, "\t/unique=yes");
							f.write (tempstring, strlen(tempstring));
						}
						*/
					// ok, now it's kool to write this part.
					f.write ("\n", 1);
					//}
				}
            }
		}
	}
    f.close();
    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int Flat_Create_Output_ERR(void)
{
    int i0;
    fstream f;
    char filename_only[255];
    char szPath[_MAX_PATH];
    char tempstring[MAX_STRING];

    // Get the path
    GetModuleFileName(NULL, szPath, _MAX_PATH);
    // split up this path
    _splitpath( szPath, NULL, NULL, filename_only, NULL);

    strcat(filename_only, ".ERR");

    // if there are any errors to report...
    if (Flat_GlobalArrayIndex_Err.total <= 0)
        {return FALSE;}

    // open the file
    f.open(filename_only, ios::out);

    // loop thru the errors and print out the errors
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Err.total;i0++)
        {
        strcpy(tempstring, (char*)Flat_GlobalArray_Err[i0]);
        f.write (tempstring, strlen(tempstring));
        f.write("\n", 1);
        }
        
    f.close();
    return TRUE;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_GlobalArray_Add_Err(char theentry[])
{
    g_iGlobalReturnCode = FALSE;

    // lets add it
    strcpy(Flat_GlobalArray_Err[Flat_GlobalArrayIndex_Err.nextuse], theentry);

    // increment counter to array
    // increment next use space
    ++Flat_GlobalArrayIndex_Err.total;
    ++Flat_GlobalArrayIndex_Err.nextuse;
    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void Flat_GlobalArray_Print_Err(void)
{
    int  i0;
    for( i0 = 0; i0 < Flat_GlobalArrayIndex_Err.total;i0++)
        {
        printf (Flat_GlobalArray_Err[i0]);
        printf ("\n");
        }
    return;
}


//-------------------------------------------------------------------
// purpose:
//  the problem with regular strtok2 is that it will
//  skip stuff like ",,," and ignore all the blanks in
//  between to get to the next token.  this strtok2 function
//  was written to over come that.  so that strtok2 works like
//  you think it would.
//-------------------------------------------------------------------
char * __cdecl strtok2 (char * string,const char * control)
{
        //unsigned char *str;
        //const unsigned char *ctrl = control;
        //unsigned char map[32];
        char *str;
        const char *ctrl = control;
        char map[32];
        int count;

        static char *nextoken;

        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
            {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
            } while (*ctrl++);

        /* Initialize str. If string is NULL, set str to the saved
         * pointer (i.e., continue breaking tokens out of the string
         * from the last strtok2 call) */
        if (string)
                str = string;
        else
                str = nextoken;

        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token iff this loop sets str to point to the terminal
         * null (*str == '\0') */
        /*
        while (
                (map[*str >> 3] & (1 << (*str & 7) ) )    && *str
                )
                str++;
                */

        string = str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
                if ( map[*str >> 3] & (1 << (*str & 7)) ) {
                        *str++ = '\0';
                        break;
                }

        /* Update nextoken (or the corresponding field in the per-thread data
         * structure */
        nextoken = str;

        /* Determine if a token has been found. */
        if ( string == str )
                return NULL;
        else
                return string;
}





int RemoveAllSpaces(LPSTR & thetempstring)
{
	int iReturn = FALSE;
	int j = 0;
    char thevalue[1024];
    char tempstring2[1024];

    strcpy(tempstring2, thetempstring);
//	strset(thevalue, '\0');
    strcpy(thevalue, "");

	for (int i=0;i < (int) strlen(tempstring2);i++)
	{
		
		if (tempstring2[i] == ' ')
		{
			iReturn = TRUE;
		}
		else
		{
			thevalue[j] = tempstring2[i];
			thevalue[j+1] = '\0';
			j++;
		}
	}
	if (iReturn == TRUE)  {strcpy(thetempstring, thevalue);}

    return iReturn;
}


int Flat_DoWeIncludeThisFileCheck(int processeduptill)
{
	//return TRUE;
	int iReturn = FALSE;
    int i0 = 0;
	int TheCount = 0;

    char CompareTo_cab[100];

	if (Flat_GlobalArray_Main[processeduptill].Do_Not_Include_file_if_cabEmpty_Flag != 1) {return TRUE;}

	// Grab the cabfilename
	strcpy(CompareTo_cab, Flat_GlobalArray_Main[processeduptill].CabFileName);
	for( i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
        {
		if (i0 != processeduptill)
			{
			if (Flat_GlobalArray_Main[i0].Do_Not_Include_file_if_cabEmpty_Flag != 1)
				{
				if (_stricmp(Flat_GlobalArray_Main[i0].CabFileName, CompareTo_cab) == 0)
					{
					++TheCount;
					break;
					}
				}
			}
        }

	if (TheCount > 0){iReturn = TRUE;}

    return iReturn;
}


void Global_TotalCabFileSize_Compute(void)
{
	char szTheCabFileName[50] = "";
	int MyFileSize = 0;
	int TheNextUse = 0;
	int iTheFlag = FALSE;
	int iIndexToUse = 0;

	// Go thru the whole list and add everything up
	for( int i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
		{
			if (Flat_DoWeIncludeThisFileCheck(i0) == TRUE)
			{
				if (!(Flat_GlobalArray_Main[i0].DDF_Exclude_From_Cab_Flag))
				{

					iIndexToUse = Flat_GlobalArrayIndex_CabSizes.nextuse;

					TheNextUse = 0;
					// lets add it if not already there.
					while (TheNextUse < Flat_GlobalArrayIndex_CabSizes.total)
					{
						if (_stricmp(Flat_GlobalArray_CabSizes[TheNextUse].CabFileName, Flat_GlobalArray_Main[i0].CabFileName) == 0)
						{
							iIndexToUse = TheNextUse;
							iTheFlag = TRUE;
							break;
						}
						TheNextUse++;
					}

					if (iTheFlag == TRUE)
					{
						// copy over the filename
						strcpy(Flat_GlobalArray_CabSizes[iIndexToUse].CabFileName, Flat_GlobalArray_Main[i0].CabFileName);

						// Get the size
						Flat_GlobalArray_CabSizes[iIndexToUse].TotalFileSize = Flat_GlobalArray_CabSizes[iIndexToUse].TotalFileSize + Flat_GlobalArray_Main[i0].FileName_Size;
						Flat_GlobalArray_CabSizes[iIndexToUse].TotalFiles++;
					}
					else
					{
						iIndexToUse = Flat_GlobalArrayIndex_CabSizes.nextuse;

						// copy over the filename
						strcpy(Flat_GlobalArray_CabSizes[iIndexToUse].CabFileName, Flat_GlobalArray_Main[i0].CabFileName);

						// Get the size
						Flat_GlobalArray_CabSizes[iIndexToUse].TotalFileSize = Flat_GlobalArray_CabSizes[iIndexToUse].TotalFileSize + Flat_GlobalArray_Main[i0].FileName_Size;
						Flat_GlobalArray_CabSizes[iIndexToUse].TotalFiles++;

						++Flat_GlobalArrayIndex_CabSizes.total;
						++Flat_GlobalArrayIndex_CabSizes.nextuse;
					}
				}
			}
		}
}


void Global_TotalCabFileSize_Print(void)
{
    int  i0;
	char stempstring[100];

    for( i0 = 0; i0 < Flat_GlobalArrayIndex_CabSizes.total;i0++)
        {
		sprintf(stempstring, "%s: Filecount=%d, Size=%d\n",Flat_GlobalArray_CabSizes[i0].CabFileName, Flat_GlobalArray_CabSizes[i0].TotalFiles, Flat_GlobalArray_CabSizes[i0].TotalFileSize);
        printf(stempstring);
        }
	printf("\n");
    return;
}


// Returns the count of the "\" characters in the string
//
int ReturnDirLevelCount(char *DirectoryTree)
{
	int TheCount = 0;
	char szTemp[_MAX_PATH];
	_tcscpy(szTemp, DirectoryTree);
	char *p = szTemp;
	while (*p) 
	{
		if (*p == '\\') 
			{TheCount++;}
		
		p = _tcsinc(p);
	}

	return TheCount;
}




void FillGlobalUniqueDirList()
{
    // used to keep a list of unique directory names.
	// loop thru the whole structure and pull out all the unique directory names.
    for( int i0 = 0; i0 < Flat_GlobalArrayIndex_Main.total;i0++)
    {
        // check if entries are the same.
		if (FALSE == GlobalUniqueDirChkIfAlreadyThere(Flat_GlobalArray_Main[i0].Filename_Path))
		{
			// Not there yet.  so let's add it
			strcpy(Flat_GlobalUniqueDirList[Flat_GlobalUniqueDirList_nextuse], Flat_GlobalArray_Main[i0].Filename_Path);

			// increment counter to array
			// increment next use space
			++Flat_GlobalUniqueDirList_total;
			++Flat_GlobalUniqueDirList_nextuse;
		}
    }
	return;
}


int GlobalUniqueDirChkIfAlreadyThere(char *TheStringToCheck)
{
	int iReturn = FALSE;

	for( int i0 = 0; i0 < Flat_GlobalUniqueDirList_total;i0++)
	{
		if (_stricmp(Flat_GlobalUniqueDirList[i0], TheStringToCheck) == 0)
		{
			iReturn = TRUE;
			goto isItAlreadyThere_Exit;
		}
	}

isItAlreadyThere_Exit:
	return iReturn;
}


int GlobalUniqueDirReturnMyIndexMatch(char *TheStringToCheck)
{
	int iReturn = 0;

	for( int i0 = 0; i0 < Flat_GlobalUniqueDirList_total;i0++)
	{
		if (_stricmp(Flat_GlobalUniqueDirList[i0], TheStringToCheck) == 0)
		{
			iReturn = i0;
			goto GlobalUniqueDirReturnMyIndexMatch_Exit;
		}
	}

GlobalUniqueDirReturnMyIndexMatch_Exit:
	return iReturn;
}

//***************************************************************************
//* NAME:       StripWhitespace                                             *
//* SYNOPSIS:   Strips spaces and tabs from both sides of given string.     *
//***************************************************************************
LPSTR StripWhitespaceA( LPSTR pszString )
{
    LPSTR pszTemp = NULL;

    if ( pszString == NULL ) {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenA(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\guid.h ===
#ifndef _MYGUID_H_
#define _MYGUID_H_
    int AppDeleteRecoverable_Wrap(LPCTSTR lpszPath);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\guid.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"

#include <objbase.h>
#include <initguid.h>

#define INITGUID
#include "iwamreg.h"
#include "guid.h"

int AppDeleteRecoverable_Wrap(LPCTSTR lpszPath)
{
    int iReturn = FALSE;
    int iCoInitCalled = FALSE;

    TCHAR lpszKeyPath[_MAX_PATH];
    WCHAR wchKeyPath[_MAX_PATH];
    HRESULT         hr = NOERROR;
    IWamAdmin*        pIWamAdmin = NULL;

    if (lpszPath[0] == _T('/'))
    {
        _tcscpy(lpszKeyPath, lpszPath);
    }
    else
    {
        lpszKeyPath[0] = _T('/');
        _tcscpy(_tcsinc(lpszKeyPath), lpszPath);
    }

#if defined(UNICODE) || defined(_UNICODE)
    _tcscpy(wchKeyPath, lpszKeyPath);
#else
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lpszKeyPath, -1, (LPWSTR)wchKeyPath, _MAX_PATH);
#endif

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
    {
        iisDebugOut((_T("AppDeleteRecoverable_Wrap: CoInitializeEx() failed, hr=%x\n"), hr));
        goto AppDeleteRecoverable_Wrap_Exit;
    }
    // Set the flag to say that we need to call co-uninit
    iCoInitCalled = TRUE;

    hr = CoCreateInstance(CLSID_WamAdmin,NULL,CLSCTX_SERVER,IID_IWamAdmin,(void **)&pIWamAdmin);
    if (FAILED(hr))
    {
        iisDebugOut((_T("AppDeleteRecoverable_Wrap:CoCreateInstance() failed. err=%x.\n"), hr));
        goto AppDeleteRecoverable_Wrap_Exit;
    }

    hr = pIWamAdmin->AppDeleteRecoverable(wchKeyPath, TRUE);
    pIWamAdmin->Release();
    if (FAILED(hr))
    {
        iisDebugOut((_T("AppDeleteRecoverable_Wrap() on path %s failed, err=%x.\n"), lpszKeyPath, hr));
        goto AppDeleteRecoverable_Wrap_Exit;
    }

    // We got this far, everything must be okay.
    iReturn = TRUE;

AppDeleteRecoverable_Wrap_Exit:
    if (iCoInitCalled == TRUE) {CoUninitialize();}
    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\loadlib\main.cpp ===
#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <oleauto.h>

int  __cdecl main(int ,char *argv[]);
void ShowHelp(void);
int  DoesFileExist(char *input_filespec);
int  ProcessFile(char szTheFileName[]);
DWORD CallProcedureInDll(LPCTSTR lpszDLLFile, LPCTSTR lpszProcedureToCall, BOOL bInitOleFlag);

int g_Param_A =  FALSE;
int g_Param_B =  FALSE;

//-------------------------------------------------------------------
//  purpose: main
//-------------------------------------------------------------------
int __cdecl main(int argc,char *argv[])
{
    int argno;
    int nflags=0;
    char szTempFileName1[_MAX_PATH];
    char szTempFileName2[_MAX_PATH];
    int iLen = 0;

    szTempFileName1[0] = '\0';
    szTempFileName2[0] = '\0';

    // process command line arguments
    for(argno=1; argno<argc; argno++)
        {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' )
            {
            nflags++;
            switch (argv[argno][1])
                {
                case 'a':
                    g_Param_A = TRUE;
                    break;
                case 'b':
                    g_Param_B = TRUE;
                    break;
                case '?':
                    goto exit_with_help;
                    break;
                }
            } // if switch character found
        else
            {
                if ( *szTempFileName1 == '\0' )
                    {
                    strcpy(szTempFileName1, argv[argno]);
                    }
                else
                {
                    if ( *szTempFileName2 == '\0' )
                        {
                        strcpy(szTempFileName2, argv[argno]);
                        }

                }
            } // non-switch char found
        } // for all arguments

    
    // check if filename was specified
    if ( *szTempFileName1 == '\0')
        {
        _tprintf("Too few arguments, argc=%d\n\n",argc);
        goto exit_with_help;
        }

    // Check if the file exists!
    if (FALSE == DoesFileExist(szTempFileName1))
        {
        _tprintf("File '%s', does not exist!\r\n", szTempFileName1);
        goto exit_gracefully;
        }

    if (g_Param_A)
    {
        if ( *szTempFileName2 == '\0')
        {
            _tprintf("Calling DllRegisterServer() in %s\r\n",szTempFileName1);
            CallProcedureInDll(szTempFileName1,_T("DllRegisterServer"),TRUE);
        }
        else
        {
            _tprintf("Calling %s() in %s\r\n", szTempFileName2,szTempFileName1);
            CallProcedureInDll(szTempFileName1,szTempFileName2,TRUE);
        }
    }
    else
    {
        // run the function to do everything
        ProcessFile(szTempFileName1);
    }

    
exit_gracefully:
    _tprintf("Done.\n");
    return TRUE;

exit_with_help:
    ShowHelp();
    return FALSE;
}

//-------------------------------------------------------------------
//  purpose: 
//-------------------------------------------------------------------
int ProcessFile(char szTheFileName[])
{
	HINSTANCE    hLibHandle;
    if ( ( hLibHandle = LoadLibrary( szTheFileName ) ) != NULL )  
    {
		_tprintf("LoadLibarary Successfull.\n");
        {
            FreeLibrary(hLibHandle);
            return TRUE;
        }
    } 
    else  
    {
		_tprintf("LoadLibarary Failed.\n");
        return FALSE;
    }

}

//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
void ShowHelp()
{
    _tprintf("\n");
    _tprintf("LoadLib - does a loadlibrary call on the specified file.\n");
    _tprintf("Usage: LoadLib <input file> \n");
    return;
}


//-------------------------------------------------------------------
//  purpose:
//-------------------------------------------------------------------
int DoesFileExist(char *input_filespec)
{
    if (GetFileAttributes(input_filespec) == -1) {return(FALSE);}
    return (TRUE);
}


BOOL IsFileExist(LPCTSTR szFile)
{
    // Check if the file has expandable Environment strings
    LPTSTR pch = NULL;
    pch = _tcschr( (LPTSTR) szFile, _T('%'));
    if (pch) 
    {
        TCHAR szValue[_MAX_PATH];
        _tcscpy(szValue,szFile);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szFile, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szFile);}

        return (GetFileAttributes(szValue) != 0xFFFFFFFF);
    }
    else
    {
        return (GetFileAttributes(szFile) != 0xFFFFFFFF);
    }
}



int iOleInitialize(void)
{
    int iBalanceOLE = FALSE;
    HRESULT hInitRes = NULL;
    hInitRes = OleInitialize(NULL);
    if ( SUCCEEDED(hInitRes) || hInitRes == RPC_E_CHANGED_MODE ) 
        {
            if ( SUCCEEDED(hInitRes))
            {
                iBalanceOLE = TRUE;
            }
            else
            {
                _tprintf("iOleInitialize failed 1\n");
            }
        }
    else
    {
        _tprintf("iOleInitialize failed 2\n");
    }

    return iBalanceOLE;
}


void iOleUnInitialize(int iBalanceOLE)
{
    if (iBalanceOLE)
    {
        OleUninitialize();
    }
    return;
}

void InetGetFilePath(LPCTSTR szFile, LPTSTR szPath)
{
    // if UNC name \\computer\share\local1\local2
    if (*szFile == _T('\\') && *(_tcsinc(szFile)) == _T('\\')) {
        TCHAR szTemp[_MAX_PATH], szLocal[_MAX_PATH];
        TCHAR *p = NULL;
        int i = 0;

        _tcscpy(szTemp, szFile);
        p = szTemp;
        while (*p) {
            if (*p == _T('\\'))
                i++;
            if (i == 4) {
                *p = _T('\0');
                p = _tcsinc(p); // p is now pointing at local1\local2
                break;
            }
            p = _tcsinc(p);
        }
        _tcscpy(szPath, szTemp); // now szPath contains \\computer\share

        if (i == 4 && *p) { // p is pointing the local path now
            _tcscpy(szLocal, p);
            p = _tcsrchr(szLocal, _T('\\'));
            if (p)
                *p = _T('\0');
            _tcscat(szPath, _T("\\"));
            _tcscat(szPath, szLocal); // szPath contains \\computer\share\local1
        }
    } else { // NOT UNC name
        TCHAR *p;
        if (GetFullPathName(szFile, _MAX_PATH, szPath, &p)) {
            p = _tcsrchr(szPath, _T('\\'));
            if (p) 
            {
                TCHAR *p2 = NULL;
                p2 = _tcsdec(szPath, p);
                if (p2)
                {
                    if (*p2 == _T(':') )
                        {p = _tcsinc(p);}
                }
                *p = _T('\0');
            }
        } else {
            _tprintf("InetGetFilePath failed\n");
        }
    }

    return;
}


typedef HRESULT (CALLBACK *HCRET)(void);

DWORD CallProcedureInDll(LPCTSTR lpszDLLFile, LPCTSTR lpszProcedureToCall, BOOL bInitOleFlag)
{
    TCHAR szErrorString[100];

    DWORD dwReturn = ERROR_SUCCESS;
    HINSTANCE hDll = NULL;

    // Diferent function prototypes...
    HCRET hProc = NULL;
    int iTempProcGood = FALSE;
    HRESULT hRes = 0;

    BOOL bBalanceOLE = FALSE;
    HRESULT hInitRes = NULL;

    int err = NOERROR;

    // Variables to changing and saving dirs
    TCHAR szDirName[_MAX_PATH], szFilePath[_MAX_PATH];
    // Variable to set error string
    TCHAR szErrString[256];

    _tcscpy(szDirName, _T(""));
    _tcscpy(szErrString, _T(""));

    _tprintf("CallProcedureInDll start\n");

    // If we need to initialize the ole library then init it.
    if (bInitOleFlag)
    {
        bBalanceOLE = iOleInitialize();
        if (FALSE == bBalanceOLE)
        {
            hInitRes = OleInitialize(NULL);
			// Ole Failed.
			dwReturn = hInitRes;
            SetLastError(dwReturn);
            _tprintf("CallProcedureInDll failed 1\n");
    		goto CallProcedureInDll_Exit;
		}
	}

	// Check if the file exists
    if (!IsFileExist(lpszDLLFile)) 
	{
		dwReturn = ERROR_FILE_NOT_FOUND;
        _tprintf("CallProcedureInDll failed 2\n");
        SetLastError(dwReturn);
    	goto CallProcedureInDll_Exit;
	}

    // Change Directory
    GetCurrentDirectory( _MAX_PATH, szDirName );
    InetGetFilePath(lpszDLLFile, szFilePath);

    // Change to The Drive.
    if (SetCurrentDirectory(szFilePath) == 0) {}

    // Try to load the module,dll,ocx.
    hDll = LoadLibraryEx(lpszDLLFile, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
	if (!hDll)
	{
		// Failed to load library, Probably because some .dll file is missing.
		// Show the error message.
		dwReturn = TYPE_E_CANTLOADLIBRARY;
        _tprintf("CallProcedureInDll failed 3\n");
        SetLastError(dwReturn);

    	goto CallProcedureInDll_Exit;
	}
	
	// Ok module was successfully loaded.  now let's try to get the Address of the Procedure
	// Convert the function name to ascii before passing it to GetProcAddress()
	char AsciiProcedureName[255];
#if defined(UNICODE) || defined(_UNICODE)
    // convert to ascii
    WideCharToMultiByte( CP_ACP, 0, (TCHAR *)lpszProcedureToCall, -1, AsciiProcedureName, 255, NULL, NULL );
#else
    // the is already ascii so just copy
    strcpy(AsciiProcedureName, lpszProcedureToCall);
#endif

    iTempProcGood = TRUE;
    hProc = (HCRET)GetProcAddress(hDll, AsciiProcedureName);
    if (!hProc){iTempProcGood = FALSE;}
	if (!iTempProcGood)
	{
		// failed to load,find or whatever this function.
	    dwReturn = ERROR_PROC_NOT_FOUND;
        _tprintf("CallProcedureInDll failed 4\n");
        SetLastError(dwReturn);
    	goto CallProcedureInDll_Exit;
	}

	// Call the function that we got the handle to
    __try
    {
        hRes = (*hProc)();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        _tprintf(szErrorString, _T("\r\n\r\nException Caught in CallProcedureInDll().  GetExceptionCode()=0x%x.\r\n\r\n"), GetExceptionCode());
        _tprintf(szErrorString);
    }
	
	if (FAILED(hRes))
	{
        dwReturn = E_FAIL;
        _tprintf("CallProcedureInDll failed 5\n");
        // this function returns E_FAIL but
        // the actual error is in GetLastError()
        // set the last error to whatever was returned from the function call
        SetLastError(hRes);
	}
    else
    {
    }

CallProcedureInDll_Exit:
    if (hDll)
    {
        FreeLibrary(hDll);
    }
    else
    {
    }
    if (_tcscmp(szDirName, _T("")) != 0){SetCurrentDirectory(szDirName);}
    // To close the library gracefully, each successful call to OleInitialize,
    // including those that return S_FALSE, must be balanced by a corresponding
    // call to the OleUninitialize function.
    iOleUnInitialize(bBalanceOLE);
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\helper.cpp ===
#include "stdafx.h"
#include "guid.h"
#include "iadm.h"
#include "mdkey.h"

extern HANDLE g_MyModuleHandle;
extern int g_iPWS40OrBetterInstalled;
extern int g_iPWS10Installed;
extern int g_iVermeerPWS10Installed;

extern CHAR g_FullFileNamePathToSettingsFile[_MAX_PATH];
extern CHAR g_PWS10_Migration_Section_Name_AddReg[];
extern CHAR g_PWS40_Migration_Section_Name_AddReg[];
extern CHAR g_Migration_Section_Name_AddReg[];

extern CHAR g_PWS10_Migration_Section_Name_CopyFiles[];
extern CHAR g_PWS40_Migration_Section_Name_CopyFiles[];
extern char g_Migration_Section_Name_CopyFiles[];

extern MyLogFile g_MyLogFile;

int  g_SectionCount = 0;

#define METABASE_BIN_FILENAME "Metabase.bin"
#define METABASE_BIN_BEFORE_CHANGE "kjhgfdsa.001"
#define METABASE_BIN_AFTER_CHANGE "kjhgfdsa.002"

#define REG_NETWORK_MSWEBSVR "Enum\\Network\\MSWEBSVR"
#define REG_HKLM_NETWORK_MSWEBSVR "HKLM\\Enum\\Network\\MSWEBSVR"

#define REG_PWS_40_UNINSTALL_KEY "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\MSIIS"
#define REG_HKLM_PWS_40_UNINSTALL_KEY "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\MSIIS"

// used to check if pws 4.0 is installed
#define REG_INETSTP    "Software\\Microsoft\\INetStp"
#define REG_INETSTP_MAJORVERSION_STRINGVALUE  "MajorVersion"
#define REG_INETSTP_INSTALLPATH_STRINGVALUE   "InstallPath"
// used to check if pws 1.0 is installed
#define REG_WWWPARAMETERS       "System\\CurrentControlSet\\Services\\W3Svc\\Parameters"
#define REG_WWWPARAMETERS_MAJORVERSION_STRINGVALUE "MajorVersion"

// used to check if vermeer pws 1.0 is installed
#define FILENAME_FRONTPG_INI          "frontpg.ini"
#define FILENAME_FRONTPG_INI_SECTION  "FrontPage 1.1"
#define FILENAME_FRONTPG_INI_KEY      "PWSRoot"

// used for parsing the values in the .rc file
#define g_LoadString_token_delimiters   ",;\t\n\r"

// regkey value for the metabase flag for doing unsecuredread
#define METABASEUNSECUREDREAD_VALUENAME "MetabaseUnSecuredRead"

// unattend answer file stuff for UNATTEND_TXT_PWS_SECTION section
#define UNATTEND_TXT_PWS_SECTION          "InternetServer"
#define UNATTEND_TXT_PWS_METABASE_NEW     "Win95MigrateDllMetabaseNew"
#define UNATTEND_TXT_PWS_METABASE_ORGINAL "Win95MigrateDllMetabaseOrg"

#define UNATTEND_TXT_FILES_TO_DELETE_SECTION "Win95MigrateDll_DeleteFilesOrDirs_IIS"

// Special key to say "hey, we need to do some special metabase stuff
// like: doing an AppDeleteRecoverable() on the metabase.
// we don't have to do AppDeleteRecoverable if MTS is migrated automagically.
//#define SPECIAL_METABASE_STUFF

int MyMessageBox(char [], char []);
int MySettingsFile_Write_PWS10(HANDLE);
int MySettingsFile_Write_PWS40(HANDLE);
int InstallInfSection(char szINFFilename[],char szSectionName[]);

void RecursivelyMoveRegFormatToInfFormat_Wrap1(HKEY hRootKeyType, CHAR szRootKey[], HANDLE fAppendToFile);
int RecursivelyMoveRegFormatToInfFormat(HKEY hRootKeyType, CHAR szRootKey[], HANDLE fAppendToFile);
int SetMetabaseToDoUnEncryptedRead(int iOnFlag);


typedef struct _QUEUECONTEXT {
    HWND OwnerWindow;
    DWORD MainThreadId;
    HWND ProgressDialog;
    HWND ProgressBar;
    BOOL Cancelled;
    PTSTR CurrentSourceName;
    BOOL ScreenReader;
    BOOL MessageBoxUp;
    WPARAM  PendingUiType;
    PVOID   PendingUiParameters;
    UINT    CancelReturnCode;
    BOOL DialogKilled;
    //
    // If the SetupInitDefaultQueueCallbackEx is used, the caller can
    // specify an alternate handler for progress. This is useful to
    // get the default behavior for disk prompting, error handling, etc,
    // but to provide a gas gauge embedded, say, in a wizard page.
    //
    // The alternate window is sent ProgressMsg once when the copy queue
    // is started (wParam = 0. lParam = number of files to copy).
    // It is then also sent once per file copied (wParam = 1. lParam = 0).
    //
    // NOTE: a silent installation (i.e., no progress UI) can be accomplished
    // by specifying an AlternateProgressWindow handle of INVALID_HANDLE_VALUE.
    //
    HWND AlternateProgressWindow;
    UINT ProgressMsg;
    UINT NoToAllMask;

    HANDLE UiThreadHandle;

#ifdef NOCANCEL_SUPPORT
    BOOL AllowCancel;
#endif

} QUEUECONTEXT, *PQUEUECONTEXT;



int ReturnTrueIfPWS40_Installed(void)
{
	iisDebugOut(_T("ReturnTrueIfPWS40_Installed.  Start."));
	int iReturn = FALSE;

	// Check if pws 4.0 or better is installed.
	DWORD rc = 0;
	HKEY hKey = NULL;

	DWORD dwType, cbData;
	BYTE   bData[1000];
	cbData = 1000;

	rc = RegOpenKey(HKEY_LOCAL_MACHINE, REG_INETSTP, &hKey);
    if (rc == ERROR_SUCCESS) 
	{
        // try open a particular value...

	    // Check if we can read the Major Version Value.
	    // try to query the value
	    rc = RegQueryValueEx(hKey,REG_INETSTP_MAJORVERSION_STRINGVALUE,NULL,&dwType,bData,&cbData);
	    if ( ERROR_SUCCESS == rc) 
	        {iReturn = TRUE;} 
    }
	else
	{
        SetLastError(rc);
    }

	if (hKey){RegCloseKey(hKey);}
	iisDebugOut(_T("ReturnTrueIfPWS40_Installed.  Return=%d.  End."), iReturn);
	return iReturn;
}

int ReturnTrueIfVermeerPWS10_Installed(void)
{
	iisDebugOut(_T("ReturnTrueIfVermeerPWS10_Installed.  Start."));
	int iReturn = FALSE;

	char szFrontpgIniFile[_MAX_PATH];
	strcpy(szFrontpgIniFile, "");
	if (0 == GetSystemDirectory(szFrontpgIniFile, sizeof(szFrontpgIniFile)))
	{
		// Error so write it out
		SetupLogError_Wrap(LogSevError, "Call to GetSystemDirectory() Failed. GetLastError=%x.", GetLastError());
		goto ReturnTrueIfVermeerPWS10_Installed_Exit;
	}
	else
	{
		AddPath(szFrontpgIniFile, FILENAME_FRONTPG_INI);
	}

	if (CheckIfFileExists(szFrontpgIniFile) == TRUE) 
	{
		iisDebugOut(_T("ReturnTrueIfVermeerPWS10_Installed.  Found %s file. Check FrontPage 1.1/PWSRoot Section."), szFrontpgIniFile);
		char buf[_MAX_PATH];
		GetPrivateProfileString(FILENAME_FRONTPG_INI_SECTION, FILENAME_FRONTPG_INI_KEY, _T(""), buf, _MAX_PATH, szFrontpgIniFile);
		if (*buf && CheckIfFileExists(buf)) 
			{
			// yes, vermeer frontpage's personal web server is installed
			iReturn = TRUE;
			}
		else
		{
			iisDebugOut(_T("ReturnTrueIfVermeerPWS10_Installed.  Check FrontPage 1.1/PWSRoot Section references file %s.  but it's not found so, Vermeer pws1.0 not installed."), buf);
		}
	}

ReturnTrueIfVermeerPWS10_Installed_Exit:
	iisDebugOut(_T("ReturnTrueIfVermeerPWS10_Installed.  Return=%d.  End."), iReturn);
	return iReturn;
}



int ReturnTrueIfPWS10_Installed(void)
{
	iisDebugOut(_T("ReturnTrueIfPWS10_Installed.  Start."));
	int iReturn = FALSE;

	// For old win95 pws 1.0 check
	// Check if we can get the w3svc\parameters key.
	HKEY hKey = NULL;
	DWORD rc = 0;

	DWORD dwType, cbData;
	BYTE   bData[1000];
	cbData = 1000;

	rc = RegOpenKey(HKEY_LOCAL_MACHINE, REG_WWWPARAMETERS, &hKey);
	if ( ERROR_SUCCESS != rc) 
	{
		SetLastError (rc);
		// if the key Does not exists pws 1.0a is not installed
		goto ReturnTrueIfPWS10_Installed_Exit;
	} 

	// Check if we can read the Major Version Value.  Should be set to '\0' if pws 1.0
	// try to query the value
	rc = RegQueryValueEx(hKey,REG_WWWPARAMETERS_MAJORVERSION_STRINGVALUE,NULL,&dwType,bData,&cbData);
	if ( ERROR_SUCCESS != rc) 
	{
		// SetLastError (rc);
		// if the key Does not exists pws 1.0a is not installed
		//SetupLogError_Wrap(LogSevError, "Failed to Read Registry Value '%s' in Key '%s'.  GetLastError()=%x",REG_WWWPARAMETERS_MAJORVERSION_STRINGVALUE, REG_WWWPARAMETERS, GetLastError());
        //iisDebugOut(_T("Failed to Read Registry Value '%s' in Key '%s'. pws1.0a is not installed."),REG_WWWPARAMETERS_MAJORVERSION_STRINGVALUE,REG_WWWPARAMETERS);
		goto ReturnTrueIfPWS10_Installed_Exit;
	} 

	// Check if we can read the MajorVersion value should be set to '\0' if pws 1.0
	if (bData[0] == '\0') {iReturn = TRUE;}
	
ReturnTrueIfPWS10_Installed_Exit:
	if (hKey){RegCloseKey(hKey);}
	iisDebugOut(_T("ReturnTrueIfPWS10_Installed.  Return=%d.  End."), iReturn);
	return iReturn;
}

int CheckIfPWS95Exists(void)
{
	iisDebugOut(_T("CheckIfPWS95Exists.  Start."));
	int iReturn = FALSE;

	// Check if this is pws 4.0 or better
	if (ReturnTrueIfPWS40_Installed() == TRUE)
	{
		g_iPWS40OrBetterInstalled = TRUE;
		iReturn = TRUE;
		goto CheckIfPWS95Exists_Exit;
	}

	// Check if this is pws 1.0a
	if (ReturnTrueIfPWS10_Installed() == TRUE)
	{
		iReturn = TRUE;
		g_iPWS10Installed = TRUE;
		goto CheckIfPWS95Exists_Exit;
	}

	// Check if this is Vermeer pws 1.0
	if (ReturnTrueIfVermeerPWS10_Installed() == TRUE)
	{
		iReturn = TRUE;
		g_iVermeerPWS10Installed = TRUE;
		goto CheckIfPWS95Exists_Exit;
	}

CheckIfPWS95Exists_Exit:
	iisDebugOut(_T("CheckIfPWS95Exists.  Return=%d.  End."), iReturn);
	return iReturn;
}


void iisDebugOut( TCHAR *pszfmt, ...)
{
	TCHAR acsString[1000];
	TCHAR acsString2[1000];

	va_list va;
	va_start(va, pszfmt);
	_vstprintf(acsString, pszfmt, va);
	va_end(va);

#if DBG == 1 || DEBUG == 1 || _DEBUG == 1
	_stprintf(acsString2, _T("%s"), acsString);
	OutputDebugString(acsString2);
	g_MyLogFile.LogFileWrite(acsString2);
#else  // DBG == 0
	_stprintf(acsString2, _T("%s"), acsString);
	// no outputdebug string for fre builds
	g_MyLogFile.LogFileWrite(acsString2);
#endif // DBG

    return;
}


//***************************************************************************
//*                                                                         
//* purpose: TRUE if the file is opened, FALSE if the file does not exists.
//* 
//***************************************************************************
int CheckIfFileExists(LPCTSTR szFile)
{ 
	return (GetFileAttributes(szFile) != 0xFFFFFFFF);
}

BOOL isDirEmpty(LPCTSTR szDirName)
{
    TCHAR szSearchString[MAX_PATH+1];
    HANDLE hFileSearch;
    WIN32_FIND_DATA wfdFindData;
    BOOL bMoreFiles = TRUE;
    
    //
    //  Now search for files
    //
    sprintf(szSearchString, _T("%s\\*.*"), szDirName);
    
    hFileSearch = FindFirstFile(szSearchString, &wfdFindData);
    while ((INVALID_HANDLE_VALUE != hFileSearch) && bMoreFiles)
    {
        if ((0 != lstrcmpi(wfdFindData.cFileName, _T("."))) &&
            (0 != lstrcmpi(wfdFindData.cFileName, _T(".."))))
        {
            FindClose(hFileSearch);
            return FALSE;
        }
        
        bMoreFiles = FindNextFile(hFileSearch, &wfdFindData);
    }

    if (INVALID_HANDLE_VALUE != hFileSearch)
    {
        FindClose(hFileSearch);
    }
    
    return TRUE;
}

BOOL RemoveAllDirsIfEmpty(LPCTSTR szTheDir)
{
    TCHAR szDirCopy[_MAX_PATH];
    DWORD retCode = GetFileAttributes(szTheDir);
    _tcscpy(szDirCopy,szTheDir);
    if (retCode == 0xFFFFFFFF)
    {
        return FALSE;
    }

    if ((retCode & FILE_ATTRIBUTE_DIRECTORY)) 
    {
        if (TRUE == isDirEmpty(szDirCopy))
        {
            iisDebugOut(_T("RemoveDirectory:%s"),szDirCopy);
            RemoveDirectory(szDirCopy);
            // Get the next dir in...
            // and see if it's empty

            // strip off the filename
            TCHAR * pTemp = strrchr(szDirCopy, '\\');
            if (pTemp){*pTemp = '\0';}
            RemoveAllDirsIfEmpty(szDirCopy);
            
            // strip off the filename
            pTemp = strrchr(szDirCopy, '\\');
            if (pTemp){*pTemp = '\0';}
            RemoveAllDirsIfEmpty(szDirCopy);
        }
    }
    return TRUE;
}

BOOL InetDeleteFile(LPCTSTR szFileName)
{
    // if file exists but DeleteFile() fails
    if ( CheckIfFileExists(szFileName) && !(DeleteFile(szFileName)) ) 
    {
        // failed to delete it
        return FALSE;
    }
    else
    {
        iisDebugOut(_T("InetDeleteFile:%s"),szFileName);

	    TCHAR szDrive_only[_MAX_DRIVE];
	    TCHAR szPath_only[_MAX_PATH];
        TCHAR szTheDir[_MAX_PATH];
        _tsplitpath(szFileName,szDrive_only,szPath_only,NULL,NULL);

		_tcscpy(szTheDir, szDrive_only);
		_tcscat(szTheDir, szPath_only);

        // see if the directory is empty...
        // if it is.. then remove it...
        RemoveAllDirsIfEmpty(szTheDir);
    }
    return TRUE;
}


BOOL RecRemoveDir(LPCTSTR szName)
{
    BOOL iRet = FALSE;
    DWORD retCode;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szSubDir[_MAX_PATH] = _T("");
    TCHAR szDirName[_MAX_PATH] = _T("");

    retCode = GetFileAttributes(szName);

    if (retCode == 0xFFFFFFFF)
        return FALSE;

    if (!(retCode & FILE_ATTRIBUTE_DIRECTORY)) {
        InetDeleteFile(szName);
        return TRUE;
    }

    _stprintf(szDirName, _T("%s\\*"), szName);
    hFile = FindFirstFile(szDirName, &FindFileData);

    if (hFile != INVALID_HANDLE_VALUE) {
        do {
            if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 &&
                 _tcsicmp(FindFileData.cFileName, _T("..")) != 0 ) {
                _stprintf(szSubDir, _T("%s\\%s"), szName, FindFileData.cFileName);
                RecRemoveDir(szSubDir);
            }

            if ( !FindNextFile(hFile, &FindFileData) ) {
                FindClose(hFile);
                break;
            }
        } while (TRUE);
    }

    iRet = RemoveAllDirsIfEmpty(szName);
    return iRet;
}

void MyDeleteLinkWildcard(TCHAR *szDir, TCHAR *szFileName)
{
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szFileToBeDeleted[_MAX_PATH];

    _stprintf(szFileToBeDeleted, _T("%s\\%s"), szDir, szFileName);

    hFile = FindFirstFile(szFileToBeDeleted, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE) 
    {
        do {
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        // this is a directory, so let's skip it
                    }
                    else
                    {
                        // this is a file, so let's Delete it.
                        TCHAR szTempFileName[_MAX_PATH];
                        _stprintf(szTempFileName, _T("%s\\%s"), szDir, FindFileData.cFileName);
                        // set to normal attributes, so we can delete it
                        SetFileAttributes(szTempFileName, FILE_ATTRIBUTE_NORMAL);
                        // delete it, hopefully
                        InetDeleteFile(szTempFileName);
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) ) 
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }

    return;
}

//***************************************************************************
//*                                                                         
//* purpose: Write out our "settings" file which is just a setupapi .inf file
//*          which will get installed on the WinNT side
//* 
//***************************************************************************
int MySettingsFile_Write(void)
{
	int iReturn = FALSE;
	HANDLE hFile;
	iisDebugOut(_T("MySettingsFile_Write.  Start."));

	// Get From the registry
	// if pws 4.0 installed then get all that information
	// and save it in the Settings file.
	if (g_iPWS40OrBetterInstalled == TRUE)
		{
		strcpy(g_Migration_Section_Name_AddReg, g_PWS40_Migration_Section_Name_AddReg);
		strcpy(g_Migration_Section_Name_CopyFiles, g_PWS40_Migration_Section_Name_CopyFiles);
		}
	else if (g_iPWS10Installed == TRUE)
		{
		strcpy(g_Migration_Section_Name_AddReg, g_PWS10_Migration_Section_Name_AddReg);
		strcpy(g_Migration_Section_Name_CopyFiles, g_PWS10_Migration_Section_Name_CopyFiles);
		}

	if (g_iPWS40OrBetterInstalled || g_iPWS10Installed)
	{
		// Open existing file or create a new one.
		if (g_FullFileNamePathToSettingsFile)
		{
			iisDebugOut(_T("MySettingsFile_Write.  CreatingFile '%s'."), g_FullFileNamePathToSettingsFile);
			hFile = CreateFile(g_FullFileNamePathToSettingsFile,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				if (g_iPWS40OrBetterInstalled == TRUE)
				{
					// Get all the pws4.0 registry stuff and save it in the settings file.
					iReturn = MySettingsFile_Write_PWS40(hFile);
					if (iReturn != TRUE) {SetupLogError_Wrap(LogSevError, "Failed to Write PWS40 Registry values to file '%s'.",g_FullFileNamePathToSettingsFile);}

					// On PWS 4.0, We need to make sure to 
					// 1. Not copy over files/dirs in the inetsrv directory from pws 4.0
					// 2. copy over all other files in the inetsrv directory for the user 
					// might have some controls and such that they created and want to keep.

					// add deleted files
				}
				else if (g_iPWS10Installed == TRUE)
				{
					// if pws 1.0 installed then get all that information and save it in the Settings file.
					iReturn = MySettingsFile_Write_PWS10(hFile);
					if (iReturn != TRUE) {SetupLogError_Wrap(LogSevError, "Failed to Write PWS10 Registry values to file '%s'.",g_FullFileNamePathToSettingsFile);}
				}
			}
			else
			{
				SetupLogError_Wrap(LogSevError, "Failed to Create to file '%s'.",g_FullFileNamePathToSettingsFile);
			}
		}
		else
		{
			SetupLogError_Wrap(LogSevError, "File handle Does not exist '%s'.",g_FullFileNamePathToSettingsFile);
		}
	}
	else
	{
		iisDebugOut(_T("MySettingsFile_Write.  Neither PWS 1.0 or 4.0 is currently installed, no upgraded required."));
	}

    if (hFile && hFile != INVALID_HANDLE_VALUE) {CloseHandle(hFile);hFile=NULL;}
	iisDebugOut(_T("MySettingsFile_Write.  End.  Return = %d"), iReturn);
	return iReturn;
}

int AnswerFile_AppendDeletion(TCHAR * szFileNameOrPathToDelete,LPCSTR AnswerFile)
{
	int iReturn = FALSE;
    CHAR szTempString[30];
    CHAR szQuotedPath[_MAX_PATH];

    if (!szFileNameOrPathToDelete)
    {
        goto AnswerFile_AppendDeletion_Exit;
    }
	// Open existing file or create a new one.
	if (!AnswerFile)
	{
        SetupLogError_Wrap(LogSevError, "File handle Does not exist '%s'.",AnswerFile);
        goto AnswerFile_AppendDeletion_Exit;
	}

    if (CheckIfFileExists(AnswerFile) != TRUE)
    {
        iisDebugOut(_T("AnswerFile_AppendDeletion:file not exist...\n"));
        goto AnswerFile_AppendDeletion_Exit;
    }

    sprintf(szTempString,"%d",g_SectionCount);
    iisDebugOut(_T("AnswerFile_AppendDeletion:%s=%s\n"), szTempString,szFileNameOrPathToDelete);
    sprintf(szQuotedPath, "\"%s\"",szFileNameOrPathToDelete);
    if (0 == WritePrivateProfileString(UNATTEND_TXT_FILES_TO_DELETE_SECTION, szTempString, szQuotedPath, AnswerFile))
    {
	    SetupLogError_Wrap(LogSevError, "Failed to WritePrivateProfileString Section=%s, in File %s.  GetLastError=%x.", UNATTEND_TXT_FILES_TO_DELETE_SECTION, AnswerFile, GetLastError());
        iisDebugOut(_T("Failed to WritePrivateProfileString Section=%s, in File %s.  GetLastError=%x."), UNATTEND_TXT_FILES_TO_DELETE_SECTION, AnswerFile, GetLastError());
        goto AnswerFile_AppendDeletion_Exit;
    }
    g_SectionCount++;

    iReturn = TRUE;

AnswerFile_AppendDeletion_Exit:
    iisDebugOut(_T("AnswerFile_AppendDeletion:end.ret=%d,%s\n"),iReturn,szFileNameOrPathToDelete);
	return iReturn;
}

int AnswerFile_ReadSectionAndDoDelete(IN HINF AnswerFileHandle)
{
	int iReturn = FALSE;
    BOOL bFlag = FALSE;
    INFCONTEXT Context;
    DWORD dwRequiredSize = 0;
    LPTSTR szLine = NULL;
    DWORD retCode = 0;

    iisDebugOut(_T("MySettingsFile_ReadSectionAndDoDelete:start\n"));
    
    // go to the beginning of the section in the INF file
    bFlag = SetupFindFirstLine(AnswerFileHandle,UNATTEND_TXT_FILES_TO_DELETE_SECTION, NULL, &Context);
    if (!bFlag)
    {
        goto MySettingsFile_ReadSectionAndDoDelete_Exit;
    }

    // loop through the items in the section.
    while (bFlag) 
    {
        // get the size of the memory we need for this
        bFlag = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

        // prepare the buffer to receive the line
        szLine = (LPTSTR)GlobalAlloc( GPTR, dwRequiredSize * sizeof(TCHAR) );
        if ( !szLine )
            {
            iisDebugOut(_T("err:Out of Memory"));
            goto MySettingsFile_ReadSectionAndDoDelete_Exit;
            }
        
        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
            {
            iisDebugOut(_T("SetupGetLineText failed"));
            goto MySettingsFile_ReadSectionAndDoDelete_Exit;
            }

        // For each of these entries do something
        // Delete the file...

        retCode = GetFileAttributes(szLine);
        if (retCode != 0xFFFFFFFF)
        {
            iReturn = TRUE;
            if (retCode & FILE_ATTRIBUTE_DIRECTORY)
            {
                // it's a directory...recusively delete it
                iisDebugOut(_T("RecRemoveDir:%s\n"),szLine);
                RecRemoveDir(szLine);
            }
            else
            {
                iisDebugOut(_T("InetDeleteFile:%s\n"),szLine);
                InetDeleteFile(szLine);
            }
        }
        else
        {
            iisDebugOut(_T("not found:%s, skipping delete\n"),szLine);
        }

        // find the next line in the section. If there is no next line it should return false
        bFlag = SetupFindNextLine(&Context, &Context);

        // free the temporary buffer
        if (szLine) {GlobalFree(szLine);szLine=NULL;}
        iReturn = TRUE;
    }

MySettingsFile_ReadSectionAndDoDelete_Exit:
    if (szLine) {GlobalFree(szLine);szLine=NULL;}
    iisDebugOut(_T("MySettingsFile_ReadSectionAndDoDelete:end\n"));
	return iReturn;
}

int MySettingsFile_Install(void)
{
	int iReturn = 0;
	iReturn = InstallInfSection(g_FullFileNamePathToSettingsFile, "DefaultInstall");
	return iReturn;
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
LPWSTR MakeWideStrFromAnsi(LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    if (!psz)
        return NULL;

    // compute the length
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}


//***************************************************************************
//*                                                                         
//* purpose:
//* 
//***************************************************************************
void MakePath(LPTSTR lpPath)
{
   LPTSTR  lpTmp;
   lpTmp = CharPrev( lpPath, lpPath + _tcslen(lpPath));

   // chop filename off
   while ( (lpTmp > lpPath) && *lpTmp && (*lpTmp != '\\') )
      lpTmp = CharPrev( lpPath, lpTmp );

   if ( *CharPrev( lpPath, lpTmp ) != ':' )
       *lpTmp = '\0';
   else
       *CharNext(lpTmp) = '\0';
   return;
}


//***************************************************************************
//*                                                                         
//* purpose: add's filename onto path
//* 
//***************************************************************************
void AddPath(LPTSTR szPath, LPCTSTR szName )
{
	LPTSTR p = szPath;

    // Find end of the string
    while (*p){p = _tcsinc(p);}
	
	// If no trailing backslash then add one
    if (*(_tcsdec(szPath, p)) != _T('\\'))
		{_tcscat(szPath, _T("\\"));}
	
	// if there are spaces precluding szName, then skip
    while ( *szName == ' ' ) szName = _tcsinc(szName);;

	// Add new name to existing path string
	_tcscat(szPath, szName);
}



//  Prepare to read a value by finding the value's size.
LONG RegPrepareValue(HKEY hKey, LPCTSTR pchValueName, DWORD * pdwType,DWORD * pcbSize,BYTE ** ppbData )
{
    LONG err = 0 ;
    BYTE chDummy[2] ;
    DWORD cbData = 0 ;

    do
    {
        //  Set the resulting buffer size to 0.
        *pcbSize = 0 ;
        *ppbData = NULL ;

        err = ::RegQueryValueEx( hKey, (TCHAR *) pchValueName, 0, pdwType, chDummy, & cbData ) ;

        //  The only error we should get here is ERROR_MORE_DATA, but
        //  we may get no error if the value has no data.
        if ( err == 0 ) 
        {
            cbData = sizeof (LONG) ;  //  Just a fudgy number
        }
        else
            if ( err != ERROR_MORE_DATA ) 
                break ;

        //  Allocate a buffer large enough for the data.

        *ppbData = new BYTE [ (*pcbSize = cbData) + sizeof (LONG) ] ;

        if ( *ppbData == NULL ) 
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        //  Now that have a buffer, re-fetch the value.

        err = ::RegQueryValueEx( hKey, (TCHAR *) pchValueName, 0, pdwType, *ppbData, pcbSize ) ;

    } while ( FALSE ) ;

    if ( err )  {delete [] *ppbData ;}

    return err ;
}



int AddRegToInfIfExist_Dword(HKEY hRootKeyType,CHAR szRootKey[],CHAR szRootName[],HANDLE fAppendToFile)
{
    int iReturn = FALSE;
    HKEY  hOpen = NULL;
    DWORD dwType;
    DWORD cbData = 500;
    BYTE  bData[500];

	CHAR szTheStringToWrite[2000];
	DWORD dwBytesWritten = 0;

	// Create the HKLM string for the output string
    CHAR szThisKeyType[5];
	strcpy(szThisKeyType, "HKLM");
	if (hRootKeyType == HKEY_LOCAL_MACHINE) {strcpy(szThisKeyType, "HKLM");}
	if (hRootKeyType == HKEY_CLASSES_ROOT) {strcpy(szThisKeyType, "HKCR");}
	if (hRootKeyType == HKEY_CURRENT_USER) {strcpy(szThisKeyType, "HKCU");}
	if (hRootKeyType == HKEY_USERS) {strcpy(szThisKeyType, "HKU");}

    // try to open the key
    if (ERROR_SUCCESS == RegOpenKey(hRootKeyType, szRootKey, &hOpen))
        {
        // try to query the value
        DWORD dwData = 0;
        DWORD dwDataSize = 0;
        dwDataSize = sizeof (DWORD);
        if (ERROR_SUCCESS == RegQueryValueEx(hOpen,szRootName,NULL,&dwType,(LPBYTE) &dwData,&dwDataSize))
            {
            DWORD dwTheValue = 0;
            dwTheValue = dwData;

            // We got the value.  so now let's write the darn thing out to the file.
            //HKLM,"System\CurrentControlSet\Services\W3Svc\Parameters","MajorVersion",0x00010001,4
            sprintf(szTheStringToWrite, "%s,\"%s\",\"%s\",0x00010001,%ld\r\n",szThisKeyType,szRootKey,szRootName,dwTheValue);

            iisDebugOut(_T("AddRegToInfIfExist_Dword:%s."),szTheStringToWrite);

            // write it to the file
            if (fAppendToFile) {WriteFile(fAppendToFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);}
			else {printf(szTheStringToWrite);}

            iReturn = TRUE;
            }
        }

    if (hOpen) {RegCloseKey(hOpen);}
    return iReturn;
}



/*
This function can be used to recursively grab a whole key out
of the registry and write it to a setupapi style .inf file.

[version]
signature="$CHICAGO$"
advancedinf=2.0

[PWS10_Migrate_install]
AddReg=PWS10_Migrate_Reg

[PWS10_Migrate_Reg]   (Creates this section)
HKLM,"System\CurrentControlSet\Services\InetInfo",,,""
HKLM,"System\CurrentControlSet\Services\InetInfo\Parameters",,,""
HKLM,"System\CurrentControlSet\Services\InetInfo\Parameters","MaxPoolThreads",0x00000001,05
HKLM,"System\CurrentControlSet\Services\InetInfo\Parameters","MaxConcurrency",0x00000001,01
HKLM,"System\CurrentControlSet\Services\InetInfo\Parameters","ThreadTimeout",0x00000001,00,2
...
...

Here are the flags as defined in the setupapi.h file:
#define FLG_ADDREG_BINVALUETYPE     ( 0x00000001 ) 
#define FLG_ADDREG_NOCLOBBER        ( 0x00000002 ) 
#define FLG_ADDREG_DELVAL           ( 0x00000004 ) 
#define FLG_ADDREG_APPEND           ( 0x00000008 ) // Currently supported only for REG_MULTI_SZ values. 
#define FLG_ADDREG_KEYONLY          ( 0x00000010 ) // Just create the key, ignore value 
#define FLG_ADDREG_OVERWRITEONLY    ( 0x00000020 ) // Set only if value already exists 
#define FLG_ADDREG_TYPE_SZ          ( 0x00000000 ) 
#define FLG_ADDREG_TYPE_MULTI_SZ    ( 0x00010000 ) 
#define FLG_ADDREG_TYPE_EXPAND_SZ   ( 0x00020000 ) 
#define FLG_ADDREG_TYPE_BINARY      ( 0x00000000 | FLG_ADDREG_BINVALUETYPE ) 
#define FLG_ADDREG_TYPE_DWORD       ( 0x00010000 | FLG_ADDREG_BINVALUETYPE ) 
#define FLG_ADDREG_TYPE_NONE        ( 0x00020000 | FLG_ADDREG_BINVALUETYPE ) 
#define FLG_ADDREG_TYPE_MASK        ( 0xFFFF0000 | FLG_ADDREG_BINVALUETYPE )
*/
int RecursivelyMoveRegFormatToInfFormat(HKEY hRootKeyType, CHAR szRootKey[], HANDLE fAppendToFile)
{
	int iReturn = FALSE;
	int iGotDefaultValue = FALSE;

	// Stuff for getting values in our node
	HKEY  hKey = NULL;
	DWORD rc = 0;
	DWORD dwIndex =0, dwType, cbValueName, cbValue, nStrSize;
	CHAR  lpTemp[20], lpValueName[32], msg[512];
	CHAR  *strResult = NULL;
	unsigned int i = 0;
	union vEntry
	{
		DWORD dw;		// REG_DWORD, REG_DWORD_LITTLE_ENDIAN
		CHAR sz[256];	// REG_SZ
		CHAR esz[256];	// REG_EXPAND_SZ
		CHAR bin[1024]; // REG_BINARY
		CHAR dwbig[4];  // REG_DWORD_BIG_ENDIAN
		CHAR msz[2048]; // REG_MULTI_SZ
	} vEntry1;
	
	// Stuff for looping thru keys that we can see
	HANDLE hHeap = NULL;
	DWORD dwBufSize, nSubkeys, nSubkeyNameLen;
	LPTSTR lpBuffer = NULL;

	CHAR szThisKeyType[5];
	CHAR szCompoundFromRootKey[1000];
	CHAR szTheStringToWrite[2000];
	DWORD dwBytesWritten = 0;
	
	// Create the HKLM string for the output string
	strcpy(szThisKeyType, "HKLM");
	if (hRootKeyType == HKEY_LOCAL_MACHINE) {strcpy(szThisKeyType, "HKLM");}
	if (hRootKeyType == HKEY_CLASSES_ROOT) {strcpy(szThisKeyType, "HKCR");}
	if (hRootKeyType == HKEY_CURRENT_USER) {strcpy(szThisKeyType, "HKCU");}
	if (hRootKeyType == HKEY_USERS) {strcpy(szThisKeyType, "HKU");}

	// Get the szRootKey and work from there
	rc = RegOpenKey(hRootKeyType, szRootKey, &hKey);
	if (rc != ERROR_SUCCESS) 
    {
        goto RecursivelyMoveRegFormatToInfFormat_Exit;
    }

	// Grab the "Default" Entry if there is one.
	cbValue = sizeof(vEntry1);
	rc = RegQueryValueEx(hKey, NULL, 0, &dwType, (LPBYTE) &vEntry1, &cbValue) ;
	if ( ERROR_SUCCESS == rc) 
	{
		if (vEntry1.sz)
		{
			iGotDefaultValue = TRUE;
			strResult = (TCHAR *) vEntry1.sz;
			// This can only be a string!
			// from: System\\CurrentControlSet\\Services\\InetInfo
			//       Value = Something
			//   to: HKLM,"Software\Microsoft\InetSrv",,,"Something"
			// ---------------------------------------------------
			sprintf(szTheStringToWrite, "%s,\"%s\",,,\"%s\"\r\n",szThisKeyType, szRootKey, strResult);
			if (fAppendToFile) 
				{WriteFile(fAppendToFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);}
			else 
				{printf(szTheStringToWrite);}
		}
	}
	// if there was no default entry, then just write the key without a default entry.
	if (!iGotDefaultValue)
	{
		//   to: HKLM,"Software\Microsoft\InetSrv",,0x00000010,"Something"
		sprintf(szTheStringToWrite, "%s,\"%s\",,0x00000010,\"%s\"\r\n",szThisKeyType, szRootKey, strResult);
		if (fAppendToFile) {WriteFile(fAppendToFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);}
		else {printf(szTheStringToWrite);}
	}

	// Now Enum all ValueNames under this
	dwIndex = 0;
	while (rc == ERROR_SUCCESS)
	{
		memset(msg, 0, sizeof(msg));
		cbValueName = 32;
		cbValue = sizeof(vEntry1);
		rc = RegEnumValue( hKey, dwIndex++, lpValueName, &cbValueName, NULL, &dwType, (LPBYTE) &vEntry1, &cbValue );
		if ( ERROR_SUCCESS == rc) 
		{
			strcpy(szTheStringToWrite, "");
			switch (dwType)
			{
				case REG_SZ:
					// to: HKLM,"Software\Microsoft\InetSrv","SomethingName",0x00000000,"SomethingData"
					sprintf(szTheStringToWrite, "%s,\"%s\",\"%s\",0x00000000,\"%s\"\r\n",szThisKeyType,szRootKey, lpValueName, vEntry1.sz);
					break;
				case REG_EXPAND_SZ:
					// to: HKLM,"Software\Microsoft\InetSrv","SomethingName",0x00020000,"%windir%\SomethingData"
					nStrSize = ExpandEnvironmentStrings(vEntry1.esz, msg, 512);
					sprintf(szTheStringToWrite, "%s,\"%s\",\"%s\",0x00020000,\"%s\"\r\n",szThisKeyType,szRootKey, lpValueName, vEntry1.sz);
					break;
				case REG_MULTI_SZ:
					// to: HKLM,"System\CurrentControlSet\Services\InetInfo\Parameters","ThreadTimeout",0x00000001,00,20
					strcpy(msg, "");
					for (i=0;i < cbValue; i++)
					{
						if (i==0){sprintf(lpTemp, "%02X", (BYTE) vEntry1.bin[i]);}
						else{sprintf(lpTemp, ",%02X", (BYTE) vEntry1.bin[i]);}
						strcat(msg, lpTemp);
					}
					sprintf(szTheStringToWrite, "%s,\"%s\",\"%s\",0x00000001,%s\r\n",szThisKeyType,szRootKey, lpValueName, msg);
					break;
				case REG_DWORD:
					// to: HKLM,"System\CurrentControlSet\Services\InetInfo\Parameters","StartupServices",0x00010001,1
					sprintf(szTheStringToWrite, "%s,\"%s\",\"%s\",0x00010001,%ld\r\n",szThisKeyType,szRootKey, lpValueName, vEntry1.dw);
					break;
				case REG_DWORD_BIG_ENDIAN:
				case REG_BINARY:
					// to: HKLM,"System\CurrentControlSet\Services\InetInfo\Parameters","MaxPoolThreads",0x00000001,05
					strcpy(msg, "");
					for (i=0;i < cbValue; i++)
					{
						if (i==0){sprintf(lpTemp, "%02X", (BYTE) vEntry1.bin[i]);}
						else{sprintf(lpTemp, ",%02X", (BYTE) vEntry1.bin[i]);}
						strcat(msg, lpTemp);
					}
					sprintf(szTheStringToWrite, "%s,\"%s\",\"%s\",0x00000001,%s\r\n",szThisKeyType,szRootKey, lpValueName, msg);
					break;
				default:
					sprintf(szTheStringToWrite, "; Unknown data value for Key '%s', Value '%s'", szRootKey, lpValueName);
					SetupLogError_Wrap(LogSevError, "Error Reading Registry Key '%s', Unknown data value for key '%s'.",szRootKey, lpValueName);
			}
			if (fAppendToFile) {WriteFile(fAppendToFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);}
			else {printf(szTheStringToWrite);}
		}
	}
	
	//
	// Now Recursively go thru the Sub keys
	//
	RegQueryInfoKey(hKey, NULL, NULL, NULL, &nSubkeys, &nSubkeyNameLen, NULL, NULL, NULL, NULL, NULL, NULL);
	// Allocate memory
	hHeap = GetProcessHeap();
	lpBuffer = (CHAR *) HeapAlloc(hHeap, 0, ++nSubkeyNameLen);
    if (lpBuffer)
    {
	    // Enum thru the keys
	    for (dwIndex = 0; dwIndex < nSubkeys; dwIndex++)
	    {
		    dwBufSize = nSubkeyNameLen;
		    rc = RegEnumKeyEx(hKey, dwIndex, lpBuffer, &dwBufSize, NULL, NULL, NULL, NULL);
		    if ( ERROR_SUCCESS == rc) 
		    {
			    strcpy(szCompoundFromRootKey, szRootKey);
			    strcat(szCompoundFromRootKey, "\\");
			    strcat(szCompoundFromRootKey, lpBuffer);
			    // Call this function again, but with the newly created key.
			    // and they'll tell they're friends, who will tell they're friends... it's amway!
			    RecursivelyMoveRegFormatToInfFormat(hRootKeyType, szCompoundFromRootKey, fAppendToFile);
		    }
	    }
    }
	
	// Set the flag to say, yes we did some work
	iReturn = TRUE;

RecursivelyMoveRegFormatToInfFormat_Exit:
	if (hKey){RegCloseKey(hKey);}
	if (hHeap && lpBuffer){HeapFree(hHeap, 0, lpBuffer);}
	return iReturn;
}



//-------------------------------------------------------------------
//  purpose: install an section in an .inf file
//-------------------------------------------------------------------
int InstallInfSection(char szINFFilename_Full[],char szSectionName[])
{

    HWND	Window			= NULL;
    PTSTR	SourcePath		= NULL;
    HINF	InfHandle		= INVALID_HANDLE_VALUE;
    HSPFILEQ FileQueue		= INVALID_HANDLE_VALUE;
    PQUEUECONTEXT	QueueContext	= NULL;
    BOOL	bReturn			= FALSE;
    BOOL	bError			= TRUE; // assume failure.
    TCHAR	ActualSection[1000];
    DWORD	ActualSectionLength;
    TCHAR * pTemp = NULL;
    iisDebugOut(_T("InstallInfSection(%s, [%s]).  Start."),szINFFilename_Full,szSectionName);

//__try {

	// Get the path to setup.exe and strip off filename so we only have the path
	char szPath[_MAX_PATH]; 

	// get the path only
	strcpy(szPath,g_FullFileNamePathToSettingsFile);

	// strip off the filename
        pTemp = strrchr(szPath, '\\');
        if (pTemp){*pTemp = '\0';}

	// set it to the pointer
	SourcePath = szPath;
        pTemp = NULL;
        pTemp = strrchr(SourcePath, '\\');
        if (pTemp) {*pTemp = '\0';}

	// Check if the file exists
	if (CheckIfFileExists(szINFFilename_Full) == FALSE) 
		{
		SetupLogError_Wrap(LogSevError, "InstallInfSection() Error: Cannot Find the file '%s'.  FAILURE.", szINFFilename_Full);
		goto c0;
		}

	//
    // Load the inf file and get the handle
	//
    InfHandle = SetupOpenInfFile(szINFFilename_Full, NULL, INF_STYLE_WIN4, NULL);
    if(InfHandle == INVALID_HANDLE_VALUE) 
	{
		if (GetLastError() != ERROR_CANCELLED) {SetupLogError_Wrap(LogSevError, "SetupOpenInfFile(), Filename='%s',Section='%s' FAILED.", szINFFilename_Full, szSectionName);}
		goto c1;
	}

    //
    // See if there is an nt-specific section
    //
    SetupDiGetActualSectionToInstall(InfHandle,szSectionName,ActualSection,sizeof(ActualSection),&ActualSectionLength,NULL);

    //
    // Create a setup file queue and initialize the default queue callback.
	//
    FileQueue = SetupOpenFileQueue();
    if(FileQueue == INVALID_HANDLE_VALUE) 
	{
		if (GetLastError() != ERROR_CANCELLED) {SetupLogError_Wrap(LogSevError, "SetupOpenFileQueue(), Filename='%s',Section='%s' FAILED.", szINFFilename_Full, szSectionName);}
		goto c1;
	}

    //QueueContext = SetupInitDefaultQueueCallback(Window);
    //if(!QueueContext) {goto c1;}
    QueueContext = (PQUEUECONTEXT) SetupInitDefaultQueueCallbackEx(Window,NULL,0,0,0);
    if(!QueueContext) 
	{
		if (GetLastError() != ERROR_CANCELLED) {SetupLogError_Wrap(LogSevError, "SetupInitDefaultQueueCallbackEx(), Filename='%s',Section='%s' FAILED.", szINFFilename_Full, szSectionName);}
		goto c1;
	}
    QueueContext->PendingUiType = IDF_CHECKFIRST;

    //
    // Enqueue file operations for the section passed on the cmd line.
    //
	//SourcePath = NULL;
    bReturn = SetupInstallFilesFromInfSection(InfHandle,NULL,FileQueue,ActualSection,SourcePath,SP_COPY_NEWER);
	if(!bReturn) 
	{
		if (GetLastError() != ERROR_CANCELLED) {SetupLogError_Wrap(LogSevError, "SetupInstallFilesFromInfSection(), Filename='%s',Section='%s' FAILED.", szINFFilename_Full, szSectionName);}
		goto c1;
	}

    //
    // Commit file queue.
    //
    if(!SetupCommitFileQueue(Window, FileQueue, SetupDefaultQueueCallback, QueueContext)) 
	{
		if (GetLastError() != ERROR_CANCELLED) {SetupLogError_Wrap(LogSevError, "SetupCommitFileQueue(), Filename='%s',Section='%s' FAILED.", szINFFilename_Full, szSectionName);}
		goto c1;
	}

    //
    // Perform non-file operations for the section passed on the cmd line.
    //
    bReturn = SetupInstallFromInfSection(Window,InfHandle,ActualSection,SPINST_ALL ^ SPINST_FILES,NULL,NULL,0,NULL,NULL,NULL,NULL);
    if(!bReturn) 
	{
		if (GetLastError() != ERROR_CANCELLED) {SetupLogError_Wrap(LogSevError, "SetupInstallFromInfSection(), Filename='%s',Section='%s' FAILED.", szINFFilename_Full, szSectionName);}
		goto c1;
	}

	//
    // Refresh the desktop.
    //
    SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_FLUSHNOWAIT,0,0);

    //
    // If we get to here, then this routine has been successful.
    //
    bError = FALSE;

c1:
    //
    // If the bError was because the user cancelled, then we don't want to consider
    // that as an bError (i.e., we don't want to give an bError popup later).
    //
    if(bError && (GetLastError() == ERROR_CANCELLED)) {bError = FALSE;}
	if(QueueContext) {SetupTermDefaultQueueCallback(QueueContext);QueueContext = NULL;}
	if(FileQueue != INVALID_HANDLE_VALUE) {SetupCloseFileQueue(FileQueue);FileQueue = INVALID_HANDLE_VALUE;}
	if(InfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(InfHandle);InfHandle = INVALID_HANDLE_VALUE;}

c0: ;

//    } __except(EXCEPTION_EXECUTE_HANDLER) 
//		{
//        if(QueueContext) {SetupTermDefaultQueueCallback(QueueContext);}
//        if(FileQueue != INVALID_HANDLE_VALUE) {SetupCloseFileQueue(FileQueue);}
//        if(InfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(InfHandle);}
//		}

    //
    // If the bError was because the user cancelled, then we don't want to consider
    // that as an bError (i.e., we don't want to give an bError popup later).
    //
    if(bError && (GetLastError() == ERROR_CANCELLED)) {bError = FALSE;}

	// Display installation failed message
    if(bError) 
	{
		SetupLogError_Wrap(LogSevError, "InstallInfSection(), Filename='%s',Section='%s' FAILED.", szINFFilename_Full, szSectionName);
	}
	else
	{
		iisDebugOut(_T("InstallInfSection(%s, [%s]).  End."),szINFFilename_Full,szSectionName);
	}
	
    return bError;
}

int MySettingsFile_Write_PWS40(HANDLE hFile)
{
	int iReturn = FALSE;
	int iEverythingIsKool = TRUE;
	CHAR szTheStringToWrite[2000];
	DWORD dwBytesWritten = 0;
	TCHAR szMetabaseFullPath[_MAX_PATH];

	// Registry variables
	HKEY hKey = NULL;
	DWORD dwType, cbData=1000,rc=0;
	BYTE   bData[1000];

	char *token = NULL;
	
	iisDebugOut(_T("MySettingsFile_Write_PWS40.  Start."));

	if (hFile)
	{
		// ----------------------------
		// Write the header information
		// ----------------------------
		strcpy(szTheStringToWrite, "[version]\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}
		
		strcpy(szTheStringToWrite, "signature=\"$CHICAGO$\"\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		strcpy(szTheStringToWrite, "advancedinf=2.0\r\n\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		// Create a [DefaultInstall] section which will get run
		// ----------------------------
		strcpy(szTheStringToWrite, "[DefaultInstall]\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		sprintf(szTheStringToWrite, "AddReg=%s\r\n", g_Migration_Section_Name_AddReg);
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

//		sprintf(szTheStringToWrite, "CopyFiles=%s\r\n\r\n", g_Migration_Section_Name_CopyFiles);
//		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
//		if (!iReturn) {iEverythingIsKool = FALSE;}
		
		// inetstp setup information
		// AddReg information
		// ----------------------------
		iisDebugOut(_T("MySettingsFile_Write_PWS40.  Adding AddReg Section."));
		sprintf(szTheStringToWrite, "[%s]\r\n", g_Migration_Section_Name_AddReg);
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		// Now, Get the ";" delimited list of HKLM registry values to read and write to our file.
		char szSemiColonDelimitedList[1024];
		strcpy(szSemiColonDelimitedList,"");
		if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_PWS40_HKLM_REG_TO_MIGRATE, szSemiColonDelimitedList, sizeof(szSemiColonDelimitedList))) 
			{
			iisDebugOut(_T("MySettingsFile_Write_PWS40.  Err or LoadString retieval of IDS_PWS40_HKLM_REG_TO_MIGRATE, Defaulting with english registry values to copy over."));
			strcpy(szSemiColonDelimitedList,"Software\\Microsoft\\InetStp;System\\CurrentControlSet\\Services\\InetInfo;System\\CurrentControlSet\\Services\\W3Svc;System\\CurrentControlSet\\Services\\ASP");
			}

		//LOOP THRU THE LIST
		token = NULL;
		token = strtok( szSemiColonDelimitedList, g_LoadString_token_delimiters);
		while( token != NULL )
			{
			// we really should remove pre/post trailing spaces

			// Grab this certain value("Software\\Microsoft\\INetStp")
			// and recursively write it to our "settings" file
			RecursivelyMoveRegFormatToInfFormat_Wrap1(HKEY_LOCAL_MACHINE,token,hFile);

			// Get next token
			token = strtok( NULL, g_LoadString_token_delimiters);
			}

        // Lookup these key,string value pairs and
        // if they exist, add them to the inf file.
        AddRegToInfIfExist_Dword(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents","iis_common",hFile);
        AddRegToInfIfExist_Dword(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents","iis_www",hFile);
        AddRegToInfIfExist_Dword(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents","iis_pwmgr",hFile);
        AddRegToInfIfExist_Dword(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents","iis_doc_common",hFile);
        AddRegToInfIfExist_Dword(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents","iis_doc_pwmcore",hFile);
        AddRegToInfIfExist_Dword(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents","iis_doc_asp",hFile);

/*
		// CopyFiles information
		// ----------------------------
		// Lookup the inetstp key to get the location of inetsrv directory.
		iisDebugOut(_T("MySettingsFile_Write_PWS40.  CopyFiles Section. lookup registry inetstp."));
		rc = RegOpenKey(HKEY_LOCAL_MACHINE, REG_INETSTP, &hKey);
		if ( ERROR_SUCCESS != rc) 
		{
			SetLastError (rc);
			SetupLogError_Wrap(LogSevError, "Failed to open registry key %s GetLastError()=%x", REG_INETSTP, GetLastError());
			// if the key does not exist, then hey, we won't be able to find
			// the metabase, much less upgrade it!
			// so let's bag out of here!
			iEverythingIsKool = FALSE;
			goto MySettingsFile_Write_PWS40_Exit;
		} 

		// try to query the value
		rc = RegQueryValueEx(hKey,REG_INETSTP_INSTALLPATH_STRINGVALUE,NULL,&dwType,bData,&cbData);
		if ( ERROR_SUCCESS != rc) 
		{
			SetLastError (rc);
			SetupLogError_Wrap(LogSevError, "Failed to Read Registry key %s Value in Key '%s'.  GetLastError()=%x", REG_INETSTP_INSTALLPATH_STRINGVALUE, REG_INETSTP, GetLastError());
			iEverythingIsKool = FALSE;
			goto MySettingsFile_Write_PWS40_Exit;
		}
		// We have the value, copy it to our string
		// Should look something like this "c:\\windows\system\inetsrv"
		_tcscpy(szMetabaseFullPath, (const char *) bData);
		// Now add on the metadata.dll part
		AddPath(szMetabaseFullPath, METADATA_DLL_FILENAME);

		// Check if it exists.
		if (CheckIfFileExists(szMetabaseFullPath) != TRUE) 
		{
			SetupLogError_Wrap(LogSevError, "File not found FAILURE. '%s'.", szMetabaseFullPath);
			iEverythingIsKool = FALSE;
			goto MySettingsFile_Write_PWS40_Exit;
		}
		iisDebugOut(_T("MySettingsFile_Write_PWS40.  CopyFiles Section. Check if file exist %s = TRUE", szMetabaseFullPath));

		// Now we need to copy this file from
		// the system dir to the system32 directory.
		// So... let's create an entry in our "settings" file
		// to do it upon installation.
		//[Section1]
		//Metabase.Dll
		iisDebugOut(_T("MySettingsFile_Write_PWS40.  Adding CopyFiles supporting Sections."));
		sprintf(szTheStringToWrite, "\r\n[%s]\r\n", g_Migration_Section_Name_CopyFiles);
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		sprintf(szTheStringToWrite, "%s\r\n\r\n", METADATA_DLL_FILENAME);
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		//[DestinationDirs]
		//Section1=11
		sprintf(szTheStringToWrite, "[DestinationDirs]\r\n");
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		sprintf(szTheStringToWrite, "%s=11  ;System on win95, System32 on WinNT\r\n\r\n", g_Migration_Section_Name_CopyFiles);
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		//[SourceDisksNames]
		//1="Setup Files",,,system
		sprintf(szTheStringToWrite, "[SourceDisksNames]\r\n");
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		sprintf(szTheStringToWrite, "1= \"Files copied from win95\\system dir\",,,System\r\n\r\n");
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		//[SourceDisksFiles]
		//Metabase.Dll=1
		sprintf(szTheStringToWrite, "[SourceDisksFiles]\r\n");
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		sprintf(szTheStringToWrite, "%s=1\r\n\r\n", METADATA_DLL_FILENAME);
		iReturn = WriteFile( hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}
*/

		iReturn = iEverythingIsKool;
	}


//MySettingsFile_Write_PWS40_Exit:
	iisDebugOut(_T("MySettingsFile_Write_PWS40.  End.  Return=%d"), iReturn);
	if (hKey){RegCloseKey(hKey);}
	return iReturn;
}


int MySettingsFile_Write_PWS10(HANDLE hFile)
{
	int iReturn = FALSE;
	int iEverythingIsKool = TRUE;
	CHAR szTheStringToWrite[2000];
	DWORD dwBytesWritten;
	char *token = NULL;

	iisDebugOut(_T("MySettingsFile_Write_PWS10.  Start."));
	if (hFile)
	{
		strcpy(szTheStringToWrite, "[version]\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}
		
		strcpy(szTheStringToWrite, "signature=\"$CHICAGO$\"\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		strcpy(szTheStringToWrite, "advancedinf=2.0\r\n\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		// Create a [DefaultInstall] section which will get run
		strcpy(szTheStringToWrite, "[DefaultInstall]\r\n");
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		sprintf(szTheStringToWrite, "AddReg=%s\r\n\r\n", g_Migration_Section_Name_AddReg);
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		sprintf(szTheStringToWrite, "[%s]\r\n", g_Migration_Section_Name_AddReg);
		iReturn = WriteFile(hFile,szTheStringToWrite,strlen(szTheStringToWrite),&dwBytesWritten,NULL);
		if (!iReturn) {iEverythingIsKool = FALSE;}

		// Now, Get the ";" delimited list of HKLM registry values to read and write to our file.
		char szSemiColonDelimitedList[1024];
		strcpy(szSemiColonDelimitedList,"");
		if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_PWS10_HKLM_REG_TO_MIGRATE, szSemiColonDelimitedList, sizeof(szSemiColonDelimitedList))) 
			{
			iisDebugOut(_T("MySettingsFile_Write_PWS10.  Err or LoadString retieval of IDS_PWS10_HKLM_REG_TO_MIGRATE, Defaulting with english registry values to copy over."));
			strcpy(szSemiColonDelimitedList, "Software\\Microsoft\\INetStp;System\\CurrentControlSet\\Services\\InetInfo;System\\CurrentControlSet\\Services\\MsFtpSvc;System\\CurrentControlSet\\Services\\W3Svc");
			}

		//LOOP THRU THE LIST
		token = NULL;
		token = strtok( szSemiColonDelimitedList, g_LoadString_token_delimiters);
		while( token != NULL )
			{
			// we really should remove pre/post trailing spaces

			// Grab this certain value("Software\\Microsoft\\INetStp")
			// and recursively write it to our "settings" file
			RecursivelyMoveRegFormatToInfFormat_Wrap1(HKEY_LOCAL_MACHINE,token,hFile);

			// Get next token
			token = strtok( NULL, g_LoadString_token_delimiters);
			}

		// set the return value to 
		iReturn = iEverythingIsKool;
	}
	iisDebugOut(_T("MySettingsFile_Write_PWS10.  End.  Return=%d"), iReturn);
	return iReturn;
}


int MyMessageBox(char szMsg[], char szFileName[])
{
	char szTempErrString[200];
	sprintf(szTempErrString, szMsg, szFileName);
	return MessageBox(NULL, szTempErrString, "PWS Migration Dll Failure", MB_OK);
}

// handle the [HKEY_LOCAL_MACHINE\Enum\Network\MSWEBSVR] reg key
void HandleSpecialRegKey(void)
{
	int iReturn = FALSE;
	
	HKEY hKey = NULL;
	if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REG_NETWORK_MSWEBSVR, &hKey))
        {iReturn = TRUE;}
    if (hKey){RegCloseKey(hKey);}

	if (iReturn == TRUE)
	{
		// Write to the Migrate.inf file that we are "Handling" this registry settings.
		iisDebugOut(_T("HandleSpecialRegKey. Write Entry to Migrate.inf file."));
		iReturn = MigInf_AddHandledRegistry(REG_HKLM_NETWORK_MSWEBSVR, NULL);
		if (iReturn != TRUE) {SetupLogError_Wrap(LogSevWarning, "Warning: MigInf_AddHandledRegistry() FAILED.");}

		//
		// Important: Write memory version of migrate.inf to disk
		//
		if (!MigInf_WriteInfToDisk()) 
		{
            iReturn = GetLastError();
			SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.err=0x%x",iReturn);
		}
	}

	if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REG_PWS_40_UNINSTALL_KEY, &hKey))
        {iReturn = TRUE;}
    if (hKey){RegCloseKey(hKey);}

	if (iReturn == TRUE)
	{
		// Write to the Migrate.inf file that we are "Handling" this registry settings.
		iisDebugOut(_T("HandleSpecialRegKey. Write Entry2 to Migrate.inf file."));
		iReturn = MigInf_AddHandledRegistry(REG_HKLM_PWS_40_UNINSTALL_KEY, NULL);
		if (iReturn != TRUE) {SetupLogError_Wrap(LogSevWarning, "Warning: MigInf_AddHandledRegistry2() FAILED.");}

		//
		// Important: Write memory version of migrate.inf to disk
		//
		if (!MigInf_WriteInfToDisk()) 
		{
            iReturn = GetLastError();
			SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk2() FAILED.err=0x%x",iReturn);
		}
	}
}

void RecursivelyMoveRegFormatToInfFormat_Wrap1(HKEY hRootKeyType, CHAR szRootKey[], HANDLE fAppendToFile)
{
	int iReturn = FALSE;
	char szTheFullKey[512];
	char szTheMask[50];

	// use this stuff for the migrate.inf file
	strcpy(szTheMask, "HKLM\\%s");
	if (hRootKeyType == HKEY_LOCAL_MACHINE) {strcpy(szTheMask, "HKLM\\%s");}
	if (hRootKeyType == HKEY_CLASSES_ROOT) {strcpy(szTheMask, "HKCR\\%s");}
	if (hRootKeyType == HKEY_CURRENT_USER) {strcpy(szTheMask, "HKCU\\%s");}
	if (hRootKeyType == HKEY_USERS) {strcpy(szTheMask, "HKU\\%s");}
	sprintf(szTheFullKey, szTheMask, szRootKey);
	iisDebugOut(_T("RecursivelyMoveRegFormatToInfFormat_Wrap1. %s"), szTheFullKey);

	// Call the real recursive function
	iReturn = RecursivelyMoveRegFormatToInfFormat(hRootKeyType, szRootKey, fAppendToFile);

    //
    // Write handled for every setting we are processing.  Because this
    // DLL supports only some of the values in the Desktop key, we must
    // be very specific as to which values are actually handled.  If
    // your DLL handles all registry values AND subkeys of a registry
    // key, you can specify NULL in the second parameter of 
    // MigInf_AddHandledRegistry.
    //
	if (iReturn == TRUE)
	{
		// Write to the Migrate.inf file that we are "Handling" this registry settings.
		iisDebugOut(_T("RecursivelyMoveRegFormatToInfFormat_Wrap1. Write Entry to Migrate.inf file."));
		iReturn = MigInf_AddHandledRegistry(szTheFullKey, NULL);
		if (iReturn != TRUE) {SetupLogError_Wrap(LogSevWarning, "Warning: MigInf_AddHandledRegistry() FAILED.");}

		//
		// Important: Write memory version of migrate.inf to disk
		//
		if (!MigInf_WriteInfToDisk()) 
		{
            iReturn = GetLastError();
			SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.err=0x%x",iReturn);
		}
	}

	return;
}



int ReturnImportantDirs(void)
{
	int iReturn = FALSE;
	if (g_iPWS40OrBetterInstalled == TRUE)
		{
		// do something
		}
	else if (g_iPWS10Installed == TRUE)
		{
		// do something else
		}
	return iReturn;
}


void SetupLogError_Wrap(IN LogSeverity TheSeverityErr, TCHAR *MessageString, ...)
{
	TCHAR acsString[1000];
	TCHAR acsString2[1000];

	va_list va;
	va_start(va, MessageString);
    _vstprintf(acsString, MessageString, va);
	va_end(va);

	// Append on Our modules information.
	_stprintf(acsString2, _T("SetupLogError: %s"), acsString);
	iisDebugOut(acsString2);

	_stprintf(acsString2, _T("[PWS Migration DLL]:%s%s"), g_MyLogFile.m_szLogPreLineInfo, acsString);
	SetupLogError(acsString2, TheSeverityErr);

	return;
}


int SetMetabaseToDoUnEncryptedRead(int iOnFlag)
{
	int iReturn = FALSE;

	DWORD rc = 0;
	HKEY hKey = NULL;
	DWORD dwResult = 0;
	DWORD DontCare;
    rc = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REG_INETSTP, 0, _T(""), 0, KEY_ALL_ACCESS, NULL, &hKey, &DontCare);
    if (rc != ERROR_SUCCESS) 
	{
		SetLastError(rc);
		goto SetMetabaseToDoUnEncryptedRead_Exit;
	}
		
	dwResult = 1;
	rc = RegSetValueEx(hKey, METABASEUNSECUREDREAD_VALUENAME, 0, REG_DWORD, (const BYTE *) &dwResult, sizeof dwResult);
    if (rc != ERROR_SUCCESS) 
	{
		SetLastError(rc);
		goto SetMetabaseToDoUnEncryptedRead_Exit;
	}

	iReturn = TRUE;

SetMetabaseToDoUnEncryptedRead_Exit:
	if (hKey){RegCloseKey(hKey);}
	return iReturn;
}


void DeleteMetabaseSchemaNode(void)
{
    CMDKey cmdKey;
    cmdKey.OpenNode(_T("/"));
    if ( (METADATA_HANDLE) cmdKey ) 
    {
        iisDebugOut(_T("MyUpgradeTasks.DeleteNode /Schema.Start."));
        cmdKey.DeleteNode(_T("Schema"));
        cmdKey.Close();
        iisDebugOut(_T("MyUpgradeTasks.DeleteNode /Schema.End."));
    }
    return;
}

BOOL MyDeleteLink(LPTSTR lpszShortcut)
{
    TCHAR  szFile[_MAX_PATH];
    SHFILEOPSTRUCT fos;

    ZeroMemory(szFile, sizeof(szFile));
    _tcscpy(szFile, lpszShortcut);

	iisDebugOut(_T("MyDeleteLink(): %s.\n"), szFile);

    if (CheckIfFileExists(szFile))
    {
        ZeroMemory(&fos, sizeof(fos));
        fos.hwnd = NULL;
        fos.wFunc = FO_DELETE;
        fos.pFrom = szFile;
        fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;
        if (SHFileOperation(&fos) != 0)
        {
            iisDebugOut(_T("MyDeleteLink(): SHFileOperation FAILED\n"));
        }
    }
    else
    {
        //iisDebugOutSafeParams((_T("MyDeleteLink(): CheckIfFileExists(%1!s!) = FALSE FAILURE\n"), szFile));
    }

    return TRUE;
}

void MyDeleteItem(LPCTSTR szGroupName, LPCTSTR szAppName)
{
    TCHAR szPath[_MAX_PATH];

    MyGetGroupPath(szGroupName, szPath);
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szAppName);
    _tcscat(szPath, _T(".lnk"));

    MyDeleteLink(szPath);

    // try to remove items added by AddURLShortcutItem()
    MyGetGroupPath(szGroupName, szPath);
    _tcscat(szPath, _T("\\"));
    _tcscat(szPath, szAppName);
    _tcscat(szPath, _T(".url"));

    MyDeleteLink(szPath);

    if (MyIsGroupEmpty(szGroupName)) {MyDeleteGroup(szGroupName);}
}

void MyGetGroupPath(LPCTSTR szGroupName, LPTSTR szPath)
{
    int            nLen = 0;
    LPITEMIDLIST   pidlPrograms;

    if (SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, &pidlPrograms) != NOERROR)
    {
        if (SHGetSpecialFolderLocation(NULL, CSIDL_PROGRAMS, &pidlPrograms) != NOERROR)
            {iisDebugOut(_T("MyGetGroupPath() SHGetSpecialFolderLocation FAILED\n"));}
    }

    if (SHGetPathFromIDList(pidlPrograms, szPath) != TRUE)
        {iisDebugOut(_T("MyGetGroupPath() SHGetPathFromIDList FAILED\n"));}

    nLen = _tcslen(szPath);
    if (szGroupName)
    {
        if (szPath[nLen-1] != _T('\\')){_tcscat(szPath, _T("\\"));}
        _tcscat(szPath, szGroupName);
    }

    //iisDebugOut(_T("MyGetGroupPath(%s). Returns %s.\n"), szGroupName, szPath);
    return;
}


BOOL MyIsGroupEmpty(LPCTSTR szGroupName)
{
    TCHAR             szPath[MAX_PATH];
    TCHAR             szFile[MAX_PATH];
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    BOOL              bFindFile = TRUE;
    BOOL              fReturn = TRUE;

    MyGetGroupPath(szGroupName, szPath);

    _tcscpy(szFile, szPath);
    _tcscat(szFile, _T("\\*.*"));

    hFind = FindFirstFile(szFile, &FindData);
    while((INVALID_HANDLE_VALUE != hFind) && bFindFile)
    {
       if(*(FindData.cFileName) != _T('.'))
       {
           fReturn = FALSE;
           break;
       }

       //find the next file
       bFindFile = FindNextFile(hFind, &FindData);
    }
    FindClose(hFind);

    return fReturn;
}


BOOL MyDeleteGroup(LPCTSTR szGroupName)
{
    BOOL fResult;
    TCHAR             szPath[MAX_PATH];
    TCHAR             szFile[MAX_PATH];
    SHFILEOPSTRUCT    fos;
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind;
    BOOL              bFindFile = TRUE;

    MyGetGroupPath(szGroupName, szPath);

    //we can't remove a directory that is not empty, so we need to empty this one

    _tcscpy(szFile, szPath);
    _tcscat(szFile, _T("\\*.*"));

    ZeroMemory(&fos, sizeof(fos));
    fos.hwnd = NULL;
    fos.wFunc = FO_DELETE;
    fos.fFlags = FOF_SILENT | FOF_NOCONFIRMATION;

    hFind = FindFirstFile(szFile, &FindData);
    while((INVALID_HANDLE_VALUE != hFind) && bFindFile)
    {
       if(*(FindData.cFileName) != _T('.'))
       {
          //copy the path and file name to our temp buffer
          memset( (PVOID)szFile, 0, sizeof(szFile));
          _tcscpy(szFile, szPath);
          _tcscat(szFile, _T("\\"));
          _tcscat(szFile, FindData.cFileName);
          //add a second NULL because SHFileOperation is looking for this
          _tcscat(szFile, _T("\0"));

          //delete the file
          fos.pFrom = szFile;
          if (SHFileOperation(&fos) != 0)
            {iisDebugOut(_T("MyDeleteGroup(): SHFileOperation FAILED\n"));}
       }

       //find the next file
       bFindFile = FindNextFile(hFind, &FindData);
    }
    FindClose(hFind);

    fResult = RemoveDirectory(szPath);
    if (fResult) {SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, szPath, 0);}
    return(fResult);
}


#define PWS_SHUTDOWN_EVENT "Inet_shutdown"
BOOL W95ShutdownW3SVC(void)
{
    HANDLE hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, _T(PWS_SHUTDOWN_EVENT));
    if ( hEvent == NULL ) 
	    {return(TRUE);}

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) 
	    {SetEvent( hEvent );}

    CloseHandle(hEvent);
    return(TRUE);
}


typedef void (*pFunctionIISDLL)(CHAR *szSectionName);

int Call_IIS_DLL_INF_Section(CHAR *szSectionName)
{
    int iReturn = FALSE;
    HINSTANCE hDll = NULL;
    pFunctionIISDLL pMyFunctionPointer = NULL;

    TCHAR szSystemDir[_MAX_PATH];
    TCHAR szFullPath[_MAX_PATH];

    // get the c:\winnt\system32 dir
    if (0 == GetSystemDirectory(szSystemDir, _MAX_PATH))
        {
        iisDebugOut(_T("Call_IIS_DLL_INF_Section(%s).GetSystemDirectory FAILED."),szSectionName);
        goto Call_IIS_DLL_INF_Section_Exit;
        }

    // Tack on the setup\iis.dll subdir and filename
    sprintf(szFullPath, "%s\\setup\\iis.dll",szSystemDir);
  
	// Check if the file exists
    if (TRUE != CheckIfFileExists(szFullPath))
        {
        iisDebugOut(_T("Call_IIS_DLL_INF_Section.CheckIfFileExists(%s) FAILED."),szFullPath);
        goto Call_IIS_DLL_INF_Section_Exit;
        }

    // Try to load the module,dll,ocx.
    hDll = LoadLibraryEx(szFullPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
	if (!hDll)
	    {
        iisDebugOut(_T("Call_IIS_DLL_INF_Section.LoadLibraryEx(%s) FAILED."),szFullPath);
        goto Call_IIS_DLL_INF_Section_Exit;
        }

    // get the function
    pMyFunctionPointer = (pFunctionIISDLL) GetProcAddress( hDll, "ProcessInfSection");
    if (pMyFunctionPointer)
    {
        // we have the function.. let's call it.
        iisDebugOut(_T("Call_IIS_DLL_INF_Section.Calling function [ProcessInfSection] Now...start"));
        (*pMyFunctionPointer)(szSectionName);
        iisDebugOut(_T("Call_IIS_DLL_INF_Section.Calling function [ProcessInfSection] Now...end"));
        iReturn = TRUE;
    }
    else
    {
        iisDebugOut(_T("Call_IIS_DLL_INF_Section.GetProcAddress(ProcessInfSection) FAILED."));
    }

Call_IIS_DLL_INF_Section_Exit:
    if (hDll){FreeLibrary(hDll);}
    return iReturn;
}


int GetInetSrvDir(CHAR *szOutputThisFullPath)
{
	int iEverythingIsKool = TRUE;
	TCHAR szMetabaseFullPath[_MAX_PATH];

	// Registry variables
	HKEY  hKey = NULL;
	DWORD dwType, cbData=1000,rc=0;
	BYTE  bData[1000];

	// CopyFiles information
	// ----------------------------
	// Lookup the inetstp key to get the location of inetsrv directory.
	iisDebugOut(_T("GetInetSrvDir.  lookup registry inetstp."));
	rc = RegOpenKey(HKEY_LOCAL_MACHINE, REG_INETSTP, &hKey);
	if ( ERROR_SUCCESS != rc) 
	{
		SetLastError (rc);
		SetupLogError_Wrap(LogSevError, "Failed to open registry key %s GetLastError()=%x", REG_INETSTP, GetLastError());
		// if the key does not exist, then hey, we won't be able to find
		// the metabase, much less upgrade it!
		// so let's bag out of here!
		iEverythingIsKool = FALSE;
		goto GetInetSrvDir_Exit;
	} 

	// try to query the value
	rc = RegQueryValueEx(hKey,REG_INETSTP_INSTALLPATH_STRINGVALUE,NULL,&dwType,bData,&cbData);
	if ( ERROR_SUCCESS != rc) 
	{
		SetLastError (rc);
		SetupLogError_Wrap(LogSevError, "Failed to Read Registry key %s Value in Key '%s'.  GetLastError()=%x", REG_INETSTP_INSTALLPATH_STRINGVALUE, REG_INETSTP, GetLastError());
		iEverythingIsKool = FALSE;
		goto GetInetSrvDir_Exit;
	}
	// We have the value, copy it to our string
	// Should look something like this "c:\\windows\system\inetsrv"
	_tcscpy(szMetabaseFullPath, (const char *) bData);
    // we only want the path part, so copy that to the output string
    _tcscpy(szOutputThisFullPath, szMetabaseFullPath);

    iEverythingIsKool = TRUE;
	iisDebugOut(_T("GetInetSrvDir.  Check if file exist %s = TRUE"), szMetabaseFullPath);

GetInetSrvDir_Exit:
    if (hKey){RegCloseKey(hKey);}
    return iEverythingIsKool;
}


int MyUpgradeTasks(LPCSTR AnswerFile)
{
	int    iReturn = FALSE;
	HANDLE hFile;
    TCHAR  szQuotedPath[_MAX_PATH];
    TCHAR  szMyInetsrvDir[_MAX_PATH];
    TCHAR  szFullMetadataPath[_MAX_PATH];
    TCHAR  szNewFileName[_MAX_PATH];
    int    iDoTheSwap = FALSE;
	iisDebugOut(_T("MyUpgradeTasks.  Start."));

	// if this is pws 1.0, then hey, we don't need to do anything
	// other than copy over the registry, so just get out of here.
	if (g_iPWS10Installed == TRUE) {goto MyUpgradeTasks_Exit;}

	// if this is pws 4.0 then we
	// need to take the iis 4.0 metabase and do certain things to it:
	// 1. Call DeleteApp
	if (g_iPWS40OrBetterInstalled == TRUE)
	{
		// Facts:
		// 1. win95 doesn't have security, so the encrypted stuff in metabase on win95
		//    is not encrypted.
		// 2. NT does have security, so the encrypted stuff in the metabase is read/write
		//    as encrypted automatically, within the metabase code.
		//
		// problem:
		// 1. If we are migrating the metabase from pws 4.0 on win95, then there is
		//    a bunch of encrypted keys in the metabase which aren't encrypted and
		//    we need a way to tell the metabase that it needs to read the data
		//    as "not encrypted" data.  it's okay to write it out as encrypted, but
		//    it's not cool to read the "not encrypted" data as encrypted.
		//
		// Solution:
		// 1. Set the registry stuff:
		// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\INetStp
		//    MetabaseUnSecuredRead= (DWORD) 1  or   0
		//    1= Yes, metabase, please read your stuff our of the metabase as unsecured.
		//    2= No, Metabase, read your stuff out of the metabase like you normally do.
		// The noexistance of the key is equal to MetabaseUnSecuredRead=0

		// Create a special key in the registry.
		if (SetMetabaseToDoUnEncryptedRead(TRUE) != TRUE)
		{
			SetupLogError_Wrap(LogSevError, "Unable to set Metabase (MetabaseUnSecuredRead flag) on.  PWS 4.0 metabase will not be Migrated.  FAILER.");
			goto MyUpgradeTasks_Exit;
		}
			
		// try to call the AppDeleteRecoverable() function in the metabase.
		// Which will tell the metabase to prepare to disconnect itself from
		// Transaction Server and save all it's data to it's dat file.
        /*
#ifdef SPECIAL_METABASE_STUFF
		if (TRUE != AppDeleteRecoverable_Wrap("LM/W3SVC"))
		{
			// Set to true anyway, because the user could be re-running this.
			iReturn = TRUE;
			SetupLogError_Wrap(LogSevError, "Call to AppDeleteRecoverable_Wrap() FAILED.");
			goto MyUpgradeTasks_Exit;
		}
#endif
        */

        // Before changing the metabase.bin file
        // let's save it somewhere.

        // 1. Get the %windir%\system\inetsrv directory where metabase.bin lives.
        // 2. copy that metabase.bin file to "anothername".
        _tcscpy(szMyInetsrvDir, _T(""));
        if (TRUE == GetInetSrvDir(szMyInetsrvDir))
        {
            _tcscpy(szFullMetadataPath, szMyInetsrvDir);
	        AddPath(szFullMetadataPath, METABASE_BIN_FILENAME);
	        // Check if it exists.
	        if (CheckIfFileExists(szFullMetadataPath) == TRUE)
	            {iDoTheSwap = TRUE;}
            if (TRUE == iDoTheSwap)
            {
                _tcscpy(szNewFileName, szMyInetsrvDir);
                AddPath(szNewFileName, METABASE_BIN_BEFORE_CHANGE);

                // Delete any that already exists.
                if (CheckIfFileExists(szNewFileName) == TRUE){DeleteFile(szNewFileName);}

	            iisDebugOut(_T("Calling WritePrivateProfileString.%s."), AnswerFile);
                sprintf(szQuotedPath, "\"%s\"",szFullMetadataPath);
	            if (0 == WritePrivateProfileString(UNATTEND_TXT_PWS_SECTION, UNATTEND_TXT_PWS_METABASE_ORGINAL, szQuotedPath, AnswerFile))
	            {
		            SetupLogError_Wrap(LogSevError, "Failed to WritePrivateProfileString Section=%s, in File %s.  GetLastError=%x.", UNATTEND_TXT_PWS_METABASE_ORGINAL, AnswerFile, GetLastError());
	            }
                
                // Copy Metadata.bin to anothername
		        if (0 == CopyFile(szFullMetadataPath, szNewFileName, FALSE))
		        {
			        SetupLogError_Wrap(LogSevError, "Call to CopyFile() Failed. from=s%,to=%s. GetLastError=%x.", szFullMetadataPath, szNewFileName, GetLastError());
                    iDoTheSwap = FALSE;
		        }
            }
        }
        // 3. change the metabase.bin
        //  Delete the "Schema" node
        DeleteMetabaseSchemaNode();

        // 4. stop the web server
        // 5. rename metabase.bin to "asdfghjk.002"
        // 6. rename "asdfghjk.001" to metabase.bin
        // 7. this way if setup is cancelled, then they will still have a win95/98 web server that works!
        if (TRUE == iDoTheSwap)
        {
            // Stop the web server...
            W95ShutdownW3SVC();
            W95ShutdownIISADMIN();

            _tcscpy(szFullMetadataPath, szMyInetsrvDir);
            AddPath(szFullMetadataPath, METABASE_BIN_FILENAME);
            // Check if it exists.
	        if (CheckIfFileExists(szFullMetadataPath) == TRUE)
            {
                // rename metadata.bin to somethingelsenew
                _tcscpy(szNewFileName, szMyInetsrvDir);
                AddPath(szNewFileName, METABASE_BIN_AFTER_CHANGE);
                // Delete any that already exists.
                if (CheckIfFileExists(szNewFileName) == TRUE){DeleteFile(szNewFileName);}
                // Copy Metadata.bin to anothername
		        if (0 == CopyFile(szFullMetadataPath, szNewFileName, FALSE))
		        {
                    SetupLogError_Wrap(LogSevError, "Call to CopyFile() Failed. from=s%,to=%s. GetLastError=%x.", szFullMetadataPath, szNewFileName, GetLastError());
		        }
                else
                {
	                iisDebugOut(_T("Calling WritePrivateProfileString.%s."), AnswerFile);
                    sprintf(szQuotedPath, "\"%s\"",szNewFileName);
	                if (0 == WritePrivateProfileString(UNATTEND_TXT_PWS_SECTION, UNATTEND_TXT_PWS_METABASE_NEW, szQuotedPath, AnswerFile))
	                {
		                SetupLogError_Wrap(LogSevError, "Failed to WritePrivateProfileString Section=%s, in File %s.  GetLastError=%x.", UNATTEND_TXT_PWS_METABASE_NEW, AnswerFile, GetLastError());
	                }

                    // rename old backedupname to metadata.bin
                    _tcscpy(szNewFileName, szMyInetsrvDir);
                    AddPath(szNewFileName, METABASE_BIN_BEFORE_CHANGE);

                    // Delete any that already exists.
                    if (CheckIfFileExists(szFullMetadataPath) == TRUE){DeleteFile(szFullMetadataPath);}
                
                    // Copy anothername to Metadata.bin
		            if (0 == CopyFile(szNewFileName, szFullMetadataPath, FALSE))
		            {
                        SetupLogError_Wrap(LogSevError, "Call to CopyFile() Failed. from=s%,to=%s. GetLastError=%x.", szNewFileName, szFullMetadataPath, GetLastError());
		            }
                    else
                    {
                        // Delete the anothername old file
                        DeleteFile(szNewFileName);
                    }
                }
            }
        }
        
		// we've gotten this far, things must be good.
		iReturn = TRUE;
	}

MyUpgradeTasks_Exit:
	iisDebugOut(_T("MyUpgradeTasks.  End.  Return = %d"), iReturn);
	return iReturn;
}


#define IISADMIN_SHUTDOWN_EVENT "Internet_infosvc_as_exe"
BOOL W95ShutdownIISADMIN(void)
{
    DWORD i;
    HANDLE hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, _T(IISADMIN_SHUTDOWN_EVENT));
    if ( hEvent == NULL ) {
        return(TRUE);
    }
    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {
        SetEvent( hEvent );
    }
    CloseHandle(hEvent);
    for (i=0; i < 20; i++) 
    {
        hEvent = CreateEvent(NULL, TRUE, FALSE, _T(IISADMIN_SHUTDOWN_EVENT));
        if ( hEvent != NULL ) {
            DWORD err = GetLastError();
            CloseHandle(hEvent);

            if ( err == ERROR_ALREADY_EXISTS ) {
                Sleep(500);
                continue;
            }
        }

        break;
    }

    return(TRUE);
}


int CheckFrontPageINI(void)
{
    int iReturn = FALSE;
    char szWindowsDir[_MAX_PATH];
    char szFullPathedFilename[_MAX_PATH];
    char szFrontPageINIFilename[] = "frontpg.ini\0";

	strcpy(szWindowsDir, "");
	if (0 == GetWindowsDirectory(szWindowsDir, sizeof(szWindowsDir)))
	{
		// Error so write it out
		SetupLogError_Wrap(LogSevError, "Call to GetWindowsDirectory() Failed. GetLastError=%x.", GetLastError());
		goto CheckFrontPageINI_Exit;
	}

	// copy our settings file to this directory.
	strcpy(szFullPathedFilename, szWindowsDir);
	AddPath(szFullPathedFilename, szFrontPageINIFilename);
    iReturn = CheckIfFileExists(szFullPathedFilename);

CheckFrontPageINI_Exit:
    return iReturn;
}


void MoveFrontPageINI(void)
{
    // since the frontpage guys didn't write a migrate.dll
    // we'll have to handle one file for them during the win95/98 upgrade.
    //
    // if we find the c:\windows\frontpg.ini file
    // then we'll have to rename it to frontpage.txt
    // then during they're install they will rename it back to frontpg.ini
    int iSomethingToDo = FALSE;
    int iFileExists = FALSE;
    int iFileExists_new = FALSE;
    char szWindowsDir[_MAX_PATH];
	char szFullPathedFilename[_MAX_PATH];
    char szFullPathedFilename_new[_MAX_PATH];
    char szFrontPageINIFilename[] = "frontpg.ini\0";
    char szFrontPageINIFilename_new[] = "frontpg.txt\0";

	strcpy(szWindowsDir, "");
	if (0 == GetWindowsDirectory(szWindowsDir, sizeof(szWindowsDir)))
	{
		// Error so write it out
		SetupLogError_Wrap(LogSevError, "Call to GetWindowsDirectory() Failed. GetLastError=%x.", GetLastError());
		goto MoveFrontPageINI_Exit;
	}

	// copy our settings file to this directory.
	strcpy(szFullPathedFilename, szWindowsDir);
	AddPath(szFullPathedFilename, szFrontPageINIFilename);
    iFileExists = CheckIfFileExists(szFullPathedFilename);

	strcpy(szFullPathedFilename_new, szWindowsDir);
	AddPath(szFullPathedFilename_new, szFrontPageINIFilename_new);
    iFileExists_new = CheckIfFileExists(szFullPathedFilename_new);

    if (FALSE == iFileExists && FALSE == iFileExists_new)
    {
        // Neither files exists, we don't have to do jack
        goto MoveFrontPageINI_Exit;
    }

    if (TRUE == iFileExists)
    {
        if (TRUE == iFileExists_new)
            {DeleteFile(szFullPathedFilename_new);}

		if (0 == CopyFile(szFullPathedFilename, szFullPathedFilename_new, FALSE))
		{
			SetupLogError_Wrap(LogSevError, "Call to CopyFile() Failed. GetLastError=%x.", GetLastError());
			goto MoveFrontPageINI_Exit;
		}
		else
		{
            iisDebugOut(_T("MoveFrontPageINI. %s renamed to %s"),szFullPathedFilename,szFrontPageINIFilename_new);
            // don't delete the old .ini file since the user could actually cancel the upgrade.
            //DeleteFile(szFullPathedFilename);
            iSomethingToDo = TRUE;
		}
    }
    else
    {
        // if we're here then that means that
        // file1 doesn't exists and file2 does exist.
        // that means that we probably already copied file1 to file2 and deleted file1.
        iSomethingToDo = TRUE;
    }

    if (iSomethingToDo)
    {
	    // Tell the upgrade module that we are going to 'handle' this newly created file.
	    // We really don't care if this get's added to the file or not, 
	    // so let's not check the return code.
	    MigInf_AddHandledFile(szFullPathedFilename_new);
	    // Important: Write memory version of migrate.inf to disk
	    if (!MigInf_WriteInfToDisk()) {SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.");}
    }
    else
    {
        iisDebugOut(_T("MoveFrontPageINI. %s not exist. no action."),szFullPathedFilename);
    }

MoveFrontPageINI_Exit:
    return;
}




HRESULT GetLNKProgramRunInfo(LPCTSTR lpszLink, LPTSTR lpszProgram)
{
    HRESULT hres;
    int iDoUninit = FALSE;
    IShellLink* pShellLink = NULL;
    WIN32_FIND_DATA wfd;

    if (SUCCEEDED(CoInitialize(NULL)))
        {iDoUninit = TRUE;}

    hres = CoCreateInstance(   CLSID_ShellLink,NULL,CLSCTX_INPROC_SERVER,IID_IShellLink,(LPVOID*)&pShellLink);
    if (SUCCEEDED(hres))
    {
       IPersistFile* pPersistFile = NULL;
       hres = pShellLink->QueryInterface(IID_IPersistFile, (LPVOID*)&pPersistFile);
       if (SUCCEEDED(hres))
       {
          WCHAR wsz[_MAX_PATH];

          // Ensure that the string is WCHAR.
#if defined(UNICODE) || defined(_UNICODE)
          _tcscpy(wsz, lpszLink);
#else
          MultiByteToWideChar( CP_ACP, 0, lpszLink, -1, wsz, _MAX_PATH);
#endif
          hres = pPersistFile->Load(wsz, STGM_READ);
          if (SUCCEEDED(hres))
          {
              hres = pShellLink->Resolve(NULL, SLR_ANY_MATCH | SLR_NO_UI);
              if (SUCCEEDED(hres))
              {
                   pShellLink->GetPath(lpszProgram, _MAX_PATH, (WIN32_FIND_DATA *)&wfd, SLGP_SHORTPATH);
              }
          }
          if (pPersistFile)
            {pPersistFile->Release();pPersistFile = NULL;}
       }
       if (pShellLink)
        {pShellLink->Release();pShellLink = NULL;}
    }

    if (TRUE == iDoUninit)
        {CoUninitialize();}
    return hres;
}


int LNKSearchAndReturn(LPTSTR szDirToLookThru, LPTSTR szExeNameWithoutPath, LPTSTR szFileNameReturned)
{
    int iReturn = FALSE;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szFilePath[_MAX_PATH];
    TCHAR szFilename_ext_only[_MAX_EXT];
    
    _tcscpy(szFileNameReturned, _T(""));
    _tcscpy(szFilePath, szDirToLookThru);
    AddPath(szFilePath, _T("*.lnk"));

    hFile = FindFirstFile(szFilePath, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE) 
    {
        do {
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        // this is a directory, so let's skip it
                    }
                    else
                    {
                        // check if this file is a .lnk file
                        // if it is then let's open it and 
                        // see if it points to our .exe we're looking for...
                        
                        // get only the filename's extention
                        _tsplitpath( FindFileData.cFileName, NULL, NULL, NULL, szFilename_ext_only);

                        // check for .lnk
                        if (0 == _tcsicmp(szFilename_ext_only, _T(".lnk")))
                        {
                            TCHAR szFilename_only[_MAX_FNAME];
                            TCHAR szFullPathAndFilename[_MAX_PATH];
                            TCHAR szTemporaryString[_MAX_PATH];

                            // this is a .lnk,
                            // open it and check the .exe..
                            _tcscpy(szFullPathAndFilename,szDirToLookThru);
                            AddPath(szFullPathAndFilename,FindFileData.cFileName);
                            _tcscpy(szTemporaryString,_T(""));

                            if (SUCCEEDED(GetLNKProgramRunInfo(szFullPathAndFilename, szTemporaryString)))
                            {
                                _tsplitpath( szTemporaryString, NULL, NULL, szFilename_only, szFilename_ext_only);
                                _tcscpy(szTemporaryString, szFilename_only);
                                _tcscat(szTemporaryString, szFilename_ext_only);

                                // check if it matches our .exe name.
                                if (0 == _tcsicmp(szTemporaryString,szExeNameWithoutPath))
                                {
                                    _tcscpy(szFileNameReturned,FindFileData.cFileName);
                                    iReturn = TRUE;
                                    FindClose(hFile);
                                    break;
                                }
                            }
                        }
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) ) 
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }

    return iReturn;
}

int MyGetSendToPath(LPTSTR szPath)
{
    LPITEMIDLIST   pidlSendTo;
    HRESULT hRes = NOERROR;
    int iTemp;
    int iReturn = FALSE;

    hRes = SHGetSpecialFolderLocation(NULL, CSIDL_SENDTO, &pidlSendTo);
    if (hRes != NOERROR)
        {
        iReturn = FALSE;
        }

    iTemp = SHGetPathFromIDList(pidlSendTo, szPath);
    if (iTemp != TRUE)
        {
        iReturn = FALSE;
        goto MyGetSendToPath_Exit;
        }

    iReturn = TRUE;

MyGetSendToPath_Exit:
    return iReturn;
}


int MyGetDesktopPath(LPTSTR szPath)
{
    LPITEMIDLIST   pidlSendTo;
    HRESULT hRes = NOERROR;
    int iTemp;
    int iReturn = FALSE;

    hRes = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY, &pidlSendTo);
    if (hRes != NOERROR)
        {
        iReturn = FALSE;
        }

    iTemp = SHGetPathFromIDList(pidlSendTo, szPath);
    if (iTemp != TRUE)
        {
        iReturn = FALSE;
        goto MyGetDesktopPath_Exit;
        }

    iReturn = TRUE;

MyGetDesktopPath_Exit:
    return iReturn;
}

void MyDeleteSendToItem(LPCTSTR szAppName)
{
    TCHAR szPath[_MAX_PATH];
    TCHAR szPath2[_MAX_PATH];

    MyGetSendToPath(szPath);
    _tcscpy(szPath2, szAppName);
    //_tcscat(szPath2, _T(".lnk")); // already in the resource, so let's not tack it on again.

    MyDeleteLinkWildcard(szPath, szPath2);
}

BOOL IsFileNameInDelimitedList(LPTSTR szCommaDelimList,LPTSTR szExeNameWithoutPath)
{
    BOOL bReturn = FALSE;
    char *token = NULL;
    TCHAR szCopyOfDataBecauseStrTokIsLame[_MAX_PATH];
    _tcscpy(szCopyOfDataBecauseStrTokIsLame,szCommaDelimList);

    // breakup the szCommaDelimList into strings and see if it contains the szExeNameWithoutPath string
    token = strtok(szCopyOfDataBecauseStrTokIsLame, g_LoadString_token_delimiters);
    while(token != NULL)
	{
        // check if it matches our .exe name.
        if (0 == _tcsicmp(token,szExeNameWithoutPath))
        {
            return TRUE;
        }
	    // Get next token
	    token = strtok(NULL, g_LoadString_token_delimiters);
    }

    return FALSE;
}


int LNKSearchAndDestroyRecursive(LPTSTR szDirToLookThru, LPTSTR szSemiColonDelmitedListOfExeNames, BOOL bDeleteItsDirToo, LPCSTR AnswerFile)
{
    int iReturn = FALSE;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szFilePath[_MAX_PATH];
    TCHAR szFilename_ext_only[_MAX_EXT];

    DWORD retCode = GetFileAttributes(szDirToLookThru);

    if (retCode == 0xFFFFFFFF || !(retCode & FILE_ATTRIBUTE_DIRECTORY))
    {
            return FALSE;
    }
   
    _tcscpy(szFilePath, szDirToLookThru);
    AddPath(szFilePath, _T("*.*"));

    hFile = FindFirstFile(szFilePath, &FindFileData);
    if (hFile != INVALID_HANDLE_VALUE) 
    {
        do {
                if ( _tcsicmp(FindFileData.cFileName, _T(".")) != 0 && _tcsicmp(FindFileData.cFileName, _T("..")) != 0 )
                {
                    if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
                    {
                        TCHAR szFullNewDirToLookInto[_MAX_EXT];
                        _tcscpy(szFullNewDirToLookInto, szDirToLookThru);
                        AddPath(szFullNewDirToLookInto,FindFileData.cFileName);

                        // this is a directory, so let's go into this
                        // directory recursively
                        LNKSearchAndDestroyRecursive(szFullNewDirToLookInto,szSemiColonDelmitedListOfExeNames,bDeleteItsDirToo,AnswerFile);
                    }
                    else
                    {
                        // check if this file is a .lnk file
                        // if it is then let's open it and 
                        // see if it points to our .exe we're looking for...
                        
                        // get only the filename's extention
                        _tsplitpath( FindFileData.cFileName, NULL, NULL, NULL, szFilename_ext_only);

                        // check for .lnk
                        if (0 == _tcsicmp(szFilename_ext_only, _T(".lnk")))
                        {
                            TCHAR szFilename_only[_MAX_FNAME];
                            TCHAR szFullPathAndFilename[_MAX_PATH];
                            TCHAR szTemporaryString[_MAX_PATH];

                            // this is a .lnk,
                            // open it and check the .exe..
                            _tcscpy(szFullPathAndFilename,szDirToLookThru);
                            AddPath(szFullPathAndFilename,FindFileData.cFileName);
                            _tcscpy(szTemporaryString,_T(""));

                            if (SUCCEEDED(GetLNKProgramRunInfo(szFullPathAndFilename, szTemporaryString)))
                            {
                                _tsplitpath( szTemporaryString, NULL, NULL, szFilename_only, szFilename_ext_only);
                                _tcscpy(szTemporaryString, szFilename_only);
                                _tcscat(szTemporaryString, szFilename_ext_only);

                                //_tprintf(TEXT("open:%s,%s\n"),szFullPathAndFilename,szTemporaryString);

                                // see if it is on our list of comma delimited names...
                                if (TRUE == IsFileNameInDelimitedList(szSemiColonDelmitedListOfExeNames,szTemporaryString))
                                {
                                    // DELETE the file that references this .exe
                                    MigInf_AddMovedFile(szFullPathAndFilename, "");
                                    AnswerFile_AppendDeletion(szFullPathAndFilename,AnswerFile);

                                    if (bDeleteItsDirToo)
                                    {
                                        // Get it's dirname and delete that too...
                                        MigInf_AddMovedDirectory(szDirToLookThru, "");
                                        AnswerFile_AppendDeletion(szDirToLookThru,AnswerFile);
                                    }

                                    iReturn = TRUE;
                                }
                             }
                        }
                    }
                }

                // get the next file
                if ( !FindNextFile(hFile, &FindFileData) ) 
                    {
                    FindClose(hFile);
                    break;
                    }
            } while (TRUE);
    }

    return iReturn;
}

// We need to tell migration setup that we are going to handle certain files...
// particularly the c:\windows\SendTo\Personal Web Server.lnk file
// since it doesn't seem to be accessible during win2000/20001 guimode setup
void HandleSendToItems(LPCSTR AnswerFile)
{
    char szPath[_MAX_PATH];
    char szSemiColonDelimitedList[255];

    // Now, Get the ";" delimited list of things to act upon
    strcpy(szSemiColonDelimitedList,"");
    if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_DEL_LNK_TO_THESE_EXE_FILENAMES, szSemiColonDelimitedList, sizeof(szSemiColonDelimitedList))) 
	{
	    iisDebugOut(_T("LoopThruStartMenuDeletions.Err LoadString IDS_DEL_LNK_TO_THESE_EXE_FILENAMES\n"));
        return;
    }

    if (TRUE == MyGetSendToPath(szPath))
    {
        LNKSearchAndDestroyRecursive(szPath,szSemiColonDelimitedList,FALSE,AnswerFile);
    }
    
    return;
}

void HandleDesktopItems(LPCSTR AnswerFile)
{
    char szPath[_MAX_PATH];
    char szSemiColonDelimitedList[255];

    // Now, Get the ";" delimited list of things to act upon
    strcpy(szSemiColonDelimitedList,"");
    if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_DEL_LNK_TO_THESE_EXE_FILENAMES, szSemiColonDelimitedList, sizeof(szSemiColonDelimitedList))) 
	{
	    iisDebugOut(_T("LoopThruStartMenuDeletions.Err LoadString IDS_DEL_LNK_TO_THESE_EXE_FILENAMES\n"));
        return;
    }

    if (TRUE == MyGetDesktopPath(szPath))
    {
        LNKSearchAndDestroyRecursive(szPath,szSemiColonDelimitedList,FALSE,AnswerFile);
    }
    
    return;
}

void HandleStartMenuItems(LPCSTR AnswerFile)
{
    TCHAR szPath[_MAX_PATH];
    char szSemiColonDelimitedList[255];

    // Now, Get the ";" delimited list of things to act upon
    strcpy(szSemiColonDelimitedList,"");
    if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_DEL_LNK_TO_THESE_EXE_FILENAMES, szSemiColonDelimitedList, sizeof(szSemiColonDelimitedList))) 
	{
	    iisDebugOut(_T("LoopThruStartMenuDeletions.Err LoadString IDS_DEL_LNK_TO_THESE_EXE_FILENAMES\n"));
        return;
    }

    MyGetGroupPath(_T(""), szPath);

    // search thru all the start menu items looking for
    // anything that links to our know programs...
    LNKSearchAndDestroyRecursive(szPath,szSemiColonDelimitedList,TRUE,AnswerFile);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\install\start.cpp ===
//----------------------------------------------
//
// program to use setupapi.dll to install the DefaultInstall section of a install.inf file
//
//----------------------------------------------
#include <tchar.h>
#include <windows.h>
#include <winbase.h>
#include <shlobj.h>
#include <io.h>
#include <stdio.h>

#include <setupapi.h>
#include "resource.h"
#include "advpub.h"

#define MAX_BUFFER        1024


typedef struct _QUEUECONTEXT {
    HWND OwnerWindow;
    DWORD MainThreadId;
    HWND ProgressDialog;
    HWND ProgressBar;
    BOOL Cancelled;
    PTSTR CurrentSourceName;
    BOOL ScreenReader;
    BOOL MessageBoxUp;
    WPARAM  PendingUiType;
    PVOID   PendingUiParameters;
    UINT    CancelReturnCode;
    BOOL DialogKilled;
    //
    // If the SetupInitDefaultQueueCallbackEx is used, the caller can
    // specify an alternate handler for progress. This is useful to
    // get the default behavior for disk prompting, error handling, etc,
    // but to provide a gas gauge embedded, say, in a wizard page.
    //
    // The alternate window is sent ProgressMsg once when the copy queue
    // is started (wParam = 0. lParam = number of files to copy).
    // It is then also sent once per file copied (wParam = 1. lParam = 0).
    //
    // NOTE: a silent installation (i.e., no progress UI) can be accomplished
    // by specifying an AlternateProgressWindow handle of INVALID_HANDLE_VALUE.
    //
    HWND AlternateProgressWindow;
    UINT ProgressMsg;
    UINT NoToAllMask;

    HANDLE UiThreadHandle;

#ifdef NOCANCEL_SUPPORT
    BOOL AllowCancel;
#endif

} QUEUECONTEXT, *PQUEUECONTEXT;


/* ************************ prototypes ***************************** */
LRESULT CALLBACK WindowFunc(HWND, UINT, WPARAM, LPARAM);

void MakePath(LPSTR lpPath);
void AddPath(LPSTR szPath, LPCSTR szName );
void MyMessageBox(int WhichString_ID, char g_szFilepath[] = '\0');
BOOL GetThisModulePath( LPSTR lpPath, int size );
int InstallDefaultInfSection(void);
int InstallDefaultInfSection2(void);
HRESULT MyRunSetupCommand(HWND hwnd, LPCSTR lpszInfFile, LPCSTR lpszSection);

/* ************************* globals ******************************* */
HINSTANCE g_hInstance       = NULL;
HINSTANCE g_hPrevInstance = NULL;
LPSTR   g_lpCmdLine     = NULL;
int     g_nCmdShow      = 0;
/* **************************************************************** */




int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    HWND        hwnd;
    MSG         msg;
    WNDCLASS    wcl;
    char        szWinName[255];

    g_hInstance = hInstance;
    g_hPrevInstance = hPrevInstance;
    g_lpCmdLine = lpCmdLine;
    g_nCmdShow = nCmdShow;

    LoadString( g_hInstance, IDS_TITLE, szWinName, _MAX_PATH );

    // define windows class
    wcl.hInstance = hInstance;
    wcl.lpszClassName = szWinName;
    wcl.lpfnWndProc = WindowFunc;
    wcl.style = 0;
    wcl.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wcl.hCursor = LoadCursor(NULL, IDC_ARROW);
    wcl.lpszMenuName = NULL;
    wcl.cbClsExtra = 0;
    wcl.cbWndExtra = 0;
    wcl.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);

    // register the window class.
    if (!RegisterClass (&wcl)) return 0;

    hwnd = CreateWindow(szWinName, NULL, WS_DISABLED | WS_CHILD, CW_USEDEFAULT, CW_USEDEFAULT, 10, 10, HWND_DESKTOP, NULL, hInstance , NULL);
    if (NULL != hwnd)
    {

      // display the window
      ShowWindow(hwnd, nCmdShow);

      // Install the inf section
      InstallDefaultInfSection();

      // Call PostQuit Message
      PostQuitMessage(0);

      while(GetMessage(&msg, NULL, 0, 0))
      {
          TranslateMessage(&msg);
          DispatchMessage(&msg);
      }
    }

    return (int)msg.wParam;
}


//***************************************************************************
//*
//* purpose: you know what
//*
//***************************************************************************
LRESULT CALLBACK WindowFunc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
        {
        case WM_CREATE:
            break;
        case WM_PAINT:
            break;
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
        default:
            return DefWindowProc(hwnd,message,wParam, lParam);
        }
    return 0;
}

//***************************************************************************
//*
//* purpose: TRUE if the file is opened, FALSE if the file does not exists.
//*
//***************************************************************************
int CheckIfFileExists(char * szFileName)
{
    char svTemp1[_MAX_PATH];
    char *pdest;
    strcpy(svTemp1, szFileName);
    // cut off the trailing \ if need to
    pdest = svTemp1;
    if (*(pdest + (strlen(pdest) - 1)) == '\\')
        {*(strrchr(svTemp1, '\\')) = '\0';}

  if ((_access(svTemp1,0)) != -1)
    {return TRUE;}
  else
    {return FALSE;}
}

//***************************************************************************
//*
//* purpose: display message that we were unable to runthe exe
//*
//***************************************************************************
void MyMessageBox(int WhichString_ID, char g_szFilepath[])
{
    TCHAR   TempString[_MAX_PATH];
    TCHAR   TempString1[_MAX_PATH];
    TCHAR   TempString2[_MAX_PATH];
    if(!LoadString(g_hInstance,IDS_ERROR,TempString1,sizeof(TempString1))) {*TempString1 = TEXT('\0');}
    if(!LoadString(g_hInstance,WhichString_ID,TempString2,sizeof(TempString2))) {*TempString2 = TEXT('\0');}

    strcpy(TempString, "Error");
    sprintf(TempString, TempString2, g_szFilepath);

    MessageBox(NULL, TempString, TempString1, MB_OK | MB_ICONSTOP);
    return;
}


int InstallDefaultInfSection2(void)
{
    HWND    Window          = NULL;
    BOOL    bError          = TRUE; // assume failure.

    char    szPath[_MAX_PATH];
    char    szINFFilename_Full[_MAX_PATH];
    char    szSectionName[_MAX_PATH];
    char    szINFFilename[_MAX_PATH];

    if(!LoadString(NULL,IDS_SECTION_NAME,szSectionName,sizeof(szSectionName)))
        {strcpy(szSectionName, "DefaultInstall");}
    if(!LoadString(NULL,IDS_INF_FILENAME,szINFFilename,sizeof(szINFFilename)))
        {strcpy(szINFFilename, "install.inf");}

    // Get the path to setup.exe and strip off filename so we only have the path
    GetModuleFileName((HINSTANCE) Window, szPath, _MAX_PATH);
    *(strrchr(szPath, '\\') + 1) = '\0';

    strcpy(szINFFilename_Full, szPath);
    strcat(szINFFilename_Full, szINFFilename);

    // Check if the file exists
    if (CheckIfFileExists(szINFFilename_Full) == FALSE)
        {
        MyMessageBox(IDS_UNABLE_TO_FIND, szINFFilename_Full);
        }
    else
    {
        MyRunSetupCommand(NULL, szINFFilename_Full, szSectionName);
    }

    return TRUE;
}


//-------------------------------------------------------------------
//  purpose: install default inf section from install.inf file
//-------------------------------------------------------------------
int InstallDefaultInfSection(void)
{

    HWND    Window          = NULL;
    PTSTR   SourcePath      = NULL;
    HINF    InfHandle       = INVALID_HANDLE_VALUE;
    HSPFILEQ FileQueue      = INVALID_HANDLE_VALUE;
    PQUEUECONTEXT   QueueContext    = NULL;
    BOOL    bReturn         = FALSE;
    BOOL    bError          = TRUE; // assume failure.
    TCHAR   ActualSection[1000];
    DWORD   ActualSectionLength;
    char    szSectionName[_MAX_PATH];
    char    szINFFilename[_MAX_PATH];

    if(!LoadString(NULL,IDS_SECTION_NAME,szSectionName,sizeof(szSectionName)))
        {strcpy(szSectionName, "DefaultInstall");}
    if(!LoadString(NULL,IDS_INF_FILENAME,szINFFilename,sizeof(szINFFilename)))
        {strcpy(szINFFilename, "install.inf");}
                    
__try {

    // Get the path to setup.exe and strip off filename so we only have the path
    char szPath[_MAX_PATH];
    char szINFFilename_Full[_MAX_PATH];
    GetModuleFileName((HINSTANCE) Window, szPath, _MAX_PATH);
    *(strrchr(szPath, '\\') + 1) = '\0';

    strcpy(szINFFilename_Full, szPath);
    strcat(szINFFilename_Full, szINFFilename);

    SourcePath = szPath;
    *(strrchr(SourcePath, '\\') ) = '\0';

    // Check if the file exists
    if (CheckIfFileExists(szINFFilename_Full) == FALSE)
        {
        MyMessageBox(IDS_UNABLE_TO_FIND, szINFFilename_Full);
        goto c0;
        }

    //
    // Load the inf file and get the handle
    //
    InfHandle = SetupOpenInfFile(szINFFilename_Full, NULL, INF_STYLE_WIN4, NULL);
    if(InfHandle == INVALID_HANDLE_VALUE) {goto c1;}

    //
    // See if there is an nt-specific section
    //
    SetupDiGetActualSectionToInstall(InfHandle,szSectionName,ActualSection,sizeof(ActualSection),&ActualSectionLength,NULL);

    //
    // Create a setup file queue and initialize the default queue callback.
    //
    FileQueue = SetupOpenFileQueue();
    if(FileQueue == INVALID_HANDLE_VALUE) {goto c1;}

    //QueueContext = SetupInitDefaultQueueCallback(Window);
    //if(!QueueContext) {goto c1;}

    QueueContext = (PQUEUECONTEXT) SetupInitDefaultQueueCallbackEx(Window,NULL,0,0,0);
    if(!QueueContext) {goto c1;}
    QueueContext->PendingUiType = IDF_CHECKFIRST;

    //
    // Enqueue file operations for the section passed on the cmd line.
    //
    //SourcePath = NULL;
    bReturn = SetupInstallFilesFromInfSection(InfHandle,NULL,FileQueue,ActualSection,SourcePath,SP_COPY_NEWER);
    if(!bReturn) {goto c1;}

    //
    // Commit file queue.
    //
    if(!SetupCommitFileQueue(Window, FileQueue, SetupDefaultQueueCallback, QueueContext)) {goto c1;}

    //
    // Perform non-file operations for the section passed on the cmd line.
    //
    bReturn = SetupInstallFromInfSection(Window,InfHandle,ActualSection,SPINST_ALL & ~SPINST_FILES,NULL,NULL,0,NULL,NULL,NULL,NULL);
    if(!bReturn) {goto c1;}

    //
    // Refresh the desktop.
    //
    SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_FLUSHNOWAIT,0,0);

    //
    // If we get to here, then this routine has been successful.
    //
    bError = FALSE;

c1:
    //
    // If the bError was because the user cancelled, then we don't want to consider
    // that as an bError (i.e., we don't want to give an bError popup later).
    //
    if(bError && (GetLastError() == ERROR_CANCELLED)) {bError = FALSE;}
    if(QueueContext) {SetupTermDefaultQueueCallback(QueueContext);QueueContext = NULL;}
    if(FileQueue != INVALID_HANDLE_VALUE) {SetupCloseFileQueue(FileQueue);FileQueue = INVALID_HANDLE_VALUE;}
    if(InfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(InfHandle);InfHandle = INVALID_HANDLE_VALUE;}

c0: ;

    } __except(EXCEPTION_EXECUTE_HANDLER)
        {
        if(QueueContext) {SetupTermDefaultQueueCallback(QueueContext);}
        if(FileQueue != INVALID_HANDLE_VALUE) {SetupCloseFileQueue(FileQueue);}
        if(InfHandle != INVALID_HANDLE_VALUE) {SetupCloseInfFile(InfHandle);}
        }

    //
    // If the bError was because the user cancelled, then we don't want to consider
    // that as an bError (i.e., we don't want to give an bError popup later).
    //
    if(bError && (GetLastError() == ERROR_CANCELLED)) {bError = FALSE;}

    // Display installation failed message
    if(bError) {MyMessageBox(IDS_INF_FAILED);}
    
    return bError;
}




//***************************************************************************
//*
//* purpose: pass a particular section (from the .inf file) to the "RunSetupCommand" function
//*          in advpack.dll.  depends upon if user wants to download another cpu/os
//*          than is own.
//*
//***************************************************************************
HRESULT MyRunSetupCommand(HWND hwnd, LPCSTR lpszInfFile, LPCSTR lpszSection)
{
    DWORD dwFlags;
    RUNSETUPCOMMAND fpRunSetupCommand;
    HRESULT         hr = E_FAIL;
    char            szTemp[MAX_BUFFER];

    HINSTANCE   g_hAdvpack = NULL;
    char  g_szSourceDir[MAX_PATH] = "";
    char szTmp[MAX_PATH];

    HRESULT         g_hr = E_FAIL;
    BOOL            bOleInited = FALSE ;

    if (SUCCEEDED(g_hr = CoInitialize(NULL)))
        {
            bOleInited = TRUE ;
            GetThisModulePath(g_szSourceDir, sizeof(g_szSourceDir));
            lstrcpy(szTmp, g_szSourceDir);
            AddPath(szTmp, "advpack.dll");

            lstrcpy(szTmp, "advpack.dll");

            g_hAdvpack = LoadLibrary( szTmp );
            
            if ( g_hAdvpack != NULL )
            {

                lstrcpy(szTemp, lpszSection);

                //dwFlags |= (RSC_FLAG_INF | RSC_FLAG_NGCONV);

                dwFlags = (RSC_FLAG_INF | RSC_FLAG_NGCONV);

                if (fpRunSetupCommand = (RUNSETUPCOMMAND)GetProcAddress(g_hAdvpack, achRUNSETUPCOMMANDFUNCTION))
                {
                    hr = fpRunSetupCommand(hwnd, lpszInfFile, szTemp, g_szSourceDir, NULL, NULL, dwFlags, NULL);

                    if (hr == S_OK){MessageBox(NULL, "", "Everything OK, no reboot needed.", MB_OK | MB_ICONSTOP);}
                    if (hr == S_ASYNCHRONOUS){MessageBox(NULL, "", "Please wait on phEXE.", MB_OK | MB_ICONSTOP);}
                    if (hr == ERROR_SUCCESS_REBOOT_REQUIRED){MessageBox(NULL, "", "Reboot required.", MB_OK | MB_ICONSTOP);}
                    if (hr == E_INVALIDARG){MessageBox(NULL, "", "E_INVALIDARG", MB_OK | MB_ICONSTOP);}
                    if (hr == E_UNEXPECTED){MessageBox(NULL, "", "E_UNEXPECTED", MB_OK | MB_ICONSTOP);}
                
                }
            }
            else
            {
                MyMessageBox(IDS_UNABLE_TO_FIND, szTmp);
            }
        }

    if (bOleInited) CoUninitialize();

    return hr;
}

//***************************************************************************
//*
//* purpose: getmodulefilename and return only the path
//*
//***************************************************************************
BOOL GetThisModulePath( LPSTR lpPath, int size )
{
    *lpPath = '\0';
    if ( GetModuleFileName( g_hInstance, lpPath, size ) )
    {
        MakePath(lpPath);
        return TRUE;
    }

    return FALSE;
}


//***************************************************************************
//*
//* purpose:
//*
//***************************************************************************
void AddPath(LPSTR szPath, LPCSTR szName )
{
    LPSTR szTmp;

        // Find end of the string
    szTmp = szPath + lstrlen(szPath);

        // If no trailing backslash then add one
    if ( szTmp > szPath && *(CharPrev( szPath, szTmp )) != '\\' )
        *(szTmp++) = '\\';

        // Add new name to existing path string
    while ( *szName == ' ' ) szName++;

    lstrcpy( szTmp, szName );
}


//***************************************************************************
//*
//* purpose:
//*
//***************************************************************************
void MakePath(LPSTR lpPath)
{
   LPSTR lpTmp;
   lpTmp = CharPrev( lpPath, lpPath+lstrlen(lpPath));

   // chop filename off
   while ( (lpTmp > lpPath) && *lpTmp && (*lpTmp != '\\') )
      lpTmp = CharPrev( lpPath, lpTmp );

   if ( *CharPrev( lpPath, lpTmp ) != ':' )
       *lpTmp = '\0';
   else
       *CharNext( lpTmp ) = '\0';
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\helper.h ===
#ifndef _HELPER_H_
#define _HELPER_H_


/*
#if DBG == 1
    #define iisDebugOut( x ) iisInlineDebugOut x
#else  // DBG == 0
    #define iisDebugOut( x )
#endif // DBG
	*/

//#define iisDebugOut(x) MyDebugOut x
//void MyDebugOut( TCHAR *pszfmt, ...);

void iisDebugOut( TCHAR *pszfmt, ...);

LPWSTR	MakeWideStrFromAnsi(LPSTR psz);
void	MakePath(LPTSTR lpPath);
void	AddPath(LPTSTR szPath, LPCTSTR szName );

int CheckIfFileExists(LPCTSTR szFile);

int CheckIfPWS95Exists(void);
int ReturnTrueIfPWS40_Installed(void);
int ReturnTrueIfPWS10_Installed(void);
int ReturnTrueIfVermeerPWS10_Installed(void);

int MySettingsFile_Write(void);
int MySettingsFile_Write_PWS10(void);
int MySettingsFile_Write_PWS40(void);
int MySettingsFile_Install(void);
int ReturnImportantDirs(void);

void SetupLogError_Wrap(IN LogSeverity TheSeverityErr, IN TCHAR * MessageString, ...);
int MyUpgradeTasks(LPCSTR);
int AddRegToInfIfExist_Dword(HKEY hRootKeyType,CHAR szRootKey[],CHAR szRootName[],HANDLE fAppendToFile);
void DeleteMetabaseSchemaNode(void);

BOOL MyIsGroupEmpty(LPCTSTR szGroupName);
void MyGetGroupPath(LPCTSTR szGroupName, LPTSTR szPath);
void MyDeleteItem(LPCTSTR szGroupName, LPCTSTR szAppName);
BOOL MyDeleteLink(LPTSTR lpszShortcut);
BOOL MyDeleteGroup(LPCTSTR szGroupName);
BOOL W95ShutdownW3SVC(void);
BOOL W95ShutdownIISADMIN(void);
int  Call_IIS_DLL_INF_Section(CHAR *szSectionName);
int  GetInetSrvDir(CHAR *szOutputThisFullPath);

int  CheckFrontPageINI(void);
void MoveFrontPageINI(void);

void HandleSpecialRegKey(void);
void MyDeleteSendToItem(LPCTSTR szAppName);
int  MyGetSendToPath(LPTSTR szPath);
int  MyGetDesktopPath(LPTSTR szPath);
void HandleStartMenuItems(LPCSTR AnswerFile);
void HandleSendToItems(LPCSTR AnswerFile);
void HandleDesktopItems(LPCSTR AnswerFile);
int  AnswerFile_ReadSectionAndDoDelete(IN HINF AnswerFileHandle);

#endif // _HELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\makefile.inc ===
#
# Supplemental rules for generating message file.
#

$(O)\vendinfo.h $(O)\vendinfo.rc $(O)\msg00001.bin: $(BASE_INC_PATH)\vendinfo.mc
    mc -A -v -h .\$(O) -r .\$(O) $(BASE_INC_PATH)\vendinfo.mc

$(O)\migrate.res: $(O)\vendinfo.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\log.h ===
#ifndef _MYLOGFILE_H_
#define _MYLOGFILE_H_

class MyLogFile
{
protected:
	// for our log file
	TCHAR		m_szLogFileName[MAX_PATH];
	TCHAR		m_szLogFileName_Full[MAX_PATH];
	BOOL        m_bDisplayTimeStamp;
	BOOL        m_bDisplayPreLineInfo;

	// logfile2
	HANDLE  m_hFile;

public:
    MyLogFile();
    ~MyLogFile();

	TCHAR		m_szLogPreLineInfo[100];
	TCHAR		m_szLogPreLineInfo2[100];
	
	int  LogFileCreate(TCHAR * lpLogFileName);
	int  LogFileClose();

	void LogFileTimeStamp();
	void LogFileWrite(TCHAR * pszFormatString, ...);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\mdkey.cpp ===
// MdKey.cpp
#include "stdafx.h"

// Do stuff to define the iadm guid
#include <objbase.h>
#include <initguid.h>
#define INITGUID
#include "iadm.h"

#include "mdkey.h"

#define TIMEOUT_VALUE 5000

CMDKey::CMDKey():
    m_cCoInits(0)
{
    m_pcCom = NULL;
    m_hKey = NULL;
}

CMDKey::~CMDKey()
{
    this->Close();

    // while there are outstanding coinits, close them
    while ( m_cCoInits > 0 && !(m_cCoInits < 0) )
        DoCoUnInit();
}

HRESULT CMDKey::DoCoInitEx()
{
    //HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	HRESULT hRes = CoInitialize(NULL);

    // track our calls to coinit
    if ( SUCCEEDED(hRes) )
    {
        m_cCoInits++;
    }

    return hRes;
}

void CMDKey::DoCoUnInit()
{
    HRESULT hRes = NOERROR;

    // if there are outstanding coinits, uninit one
    if ( m_cCoInits > 0 )
    {
        CoUninitialize();
        m_cCoInits--;
    }

    // we shouldn't ever have a negative count. But just in case...
    assert( m_cCoInits >= 0 );
    if ( m_cCoInits < 0 )
    {
        // something is seriously wrong here. Prevent looping
        // by going straight to zero, and write an error to the log.
        m_cCoInits = 0;
        iisDebugOut(_T("WARNING: CoInits in mdkey have gone negative"));
    }
}

HRESULT CMDKey::OpenNode(LPCTSTR pchSubKeyPath)
{
    HRESULT hRes = ERROR_SUCCESS;
    IClassFactory * pcsfFactory = NULL;
    BOOL b = FALSE;
    m_pcCom = NULL;
    m_hKey = NULL;
    WCHAR szSubKeyPath[_MAX_PATH];

    pszFailedAPI = NULL;

    iisDebugOut(_T("CMDKey::OpenNode(%s).\n"), pchSubKeyPath);

    if ( !pchSubKeyPath || !(*pchSubKeyPath) ) 
    {
        *szSubKeyPath = L'\0';
    }
    else 
    {
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH);
#endif
    }

    hRes = DoCoInitEx();
    if (FAILED(hRes))
    {
        iisDebugOut(_T("CoInitializeEx() failed, hRes=%x\n"), hRes);
    }

    hRes = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, NULL, IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hRes)) 
    {
        //SetErrorFlag(__FILE__, __LINE__);
        //MyMessageBox(NULL, _T("CoGetClassObject"), hRes, MB_OK | MB_SETFOREGROUND);
    }
    else 
    {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &m_pcCom);
        pcsfFactory->Release();
        if (FAILED(hRes)) 
        {
            //SetErrorFlag(__FILE__, __LINE__);
            //MyMessageBox(NULL, _T("CoCreateInstance"), hRes, MB_OK | MB_SETFOREGROUND);
        }
        else 
        {
            hRes = m_pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,szSubKeyPath,METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,TIMEOUT_VALUE,&m_hKey);
            if (FAILED(hRes)) 
            {
                if (hRes != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) 
                {
                    //SetErrorFlag(__FILE__, __LINE__);
                    //MyMessageBox(NULL, _T("OpenKey"), hRes, MB_OK | MB_SETFOREGROUND);
                }
            }
            else 
            {
                b = TRUE;
            }
        } // end of CoCreateInstance
    } // end of CoGetClassObject

    if (!b) {this->Close();}
    return hRes;
}

HRESULT CMDKey::Close()
{
    HRESULT hRes = ERROR_SUCCESS;
    if (m_pcCom) 
    {
        if (m_hKey){hRes = m_pcCom->CloseKey(m_hKey);}
        hRes = m_pcCom->Release();
    }
    DoCoUnInit();
    m_pcCom = NULL;
    m_hKey = NULL;
    return hRes;
}

HRESULT CMDKey::DeleteNode(LPCTSTR pchSubKeyPath)
{
    HRESULT hRes = ERROR_SUCCESS;
    WCHAR szSubKeyPath[_MAX_PATH];

    if ( pchSubKeyPath && (*pchSubKeyPath) ) 
    {
#if defined(UNICODE) || defined(_UNICODE)
        _tcscpy(szSubKeyPath, pchSubKeyPath);
#else
        MultiByteToWideChar( CP_ACP, 0, pchSubKeyPath, -1, szSubKeyPath, _MAX_PATH );
#endif
        hRes = m_pcCom->DeleteKey(m_hKey, szSubKeyPath);
    }

    return hRes;
}


#if !defined(UNICODE) && !defined(_UNICODE)
void MyMultiByteToWideChar( char *sData, WCHAR *wData, int cbBufSize, BOOL fMultiSZ)
{
    MultiByteToWideChar( CP_ACP, 0, sData, -1, wData, cbBufSize );
    while (fMultiSZ) 
    {
        sData = _tcsninc( sData, _tcslen(sData)) + 1;
        while (*wData++);
        if (*sData)
        {
            MultiByteToWideChar( CP_ACP, 0, sData, -1, wData, cbBufSize );
        }
        else 
        {
            *wData = L'\0';
            break;
        }
    }
    return;
}
void MyWideCharToMultiByte( WCHAR *wData, char *sData, int cbBufSize, BOOL fMultiSZ)
{
    WideCharToMultiByte( CP_ACP, 0, wData, -1, sData, cbBufSize, NULL, NULL );
    while (fMultiSZ) 
    {
        while (*wData++);
        sData = _tcsninc( sData, _tcslen(sData)) + 1;
        if (*wData)
        {
            WideCharToMultiByte( CP_ACP, 0, wData, -1, sData, cbBufSize, NULL, NULL );
        }
        else 
        {
            *sData = '\0';
            break;
        }
    }
    return;
}
#endif      // not unicode
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\mdkey.h ===
#ifndef _MDKEY_H_
#define _MDKEY_H_

//class CMDKey : public CObject
class CMDKey
{
protected:
    IMSAdminBase * m_pcCom;
    METADATA_HANDLE m_hKey;
    LPTSTR pszFailedAPI;

public:
    CMDKey();
    ~CMDKey();

    // allow CMDKey to be used where type METADATA_HANDLE is required
    operator METADATA_HANDLE () {return m_hKey;}
    METADATA_HANDLE GetMDKeyHandle() {return m_hKey;}
    IMSAdminBase *GetMDKeyICOM() {return m_pcCom;}

    // open an existing MD key
    HRESULT OpenNode(LPCTSTR pchSubKeyPath);
    // close node opened/created by OpenNode() or CreateNode()
    HRESULT Close();
    // Delete a node
    HRESULT DeleteNode(LPCTSTR pchSubKeyPath);

private:
    HRESULT DoCoInitEx();
    void DoCoUnInit();
    // a count of the calls to coinit
    INT m_cCoInits;
};

#endif // _MDKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\log.cpp ===
#include "stdafx.h"
#include <pudebug.h>


// critical section needed to safely write to the logfile
CRITICAL_SECTION        critical_section;

//***************************************************************************
//*                                                                         
//* purpose: constructor
//*
//***************************************************************************
MyLogFile::MyLogFile(void)
{
	_tcscpy(m_szLogFileName, _T(""));
	_tcscpy(m_szLogFileName_Full, _T(""));
	_tcscpy(m_szLogPreLineInfo, _T(""));
	_tcscpy(m_szLogPreLineInfo2, _T(""));
	m_bDisplayTimeStamp = TRUE;
	m_bDisplayPreLineInfo = TRUE;

	m_hFile = NULL;

	// initialize the critical section
	INITIALIZE_CRITICAL_SECTION( &critical_section );
}

//***************************************************************************
//*                                                                         
//* purpose: destructor
//*
//***************************************************************************
MyLogFile::~MyLogFile(void)
{
	DeleteCriticalSection( &critical_section );
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
int MyLogFile::LogFileCreate(TCHAR *lpLogFileName )
{
	int iReturn = FALSE;
	TCHAR szDrive_only[_MAX_DRIVE];
	TCHAR szPath_only[_MAX_PATH];
	TCHAR szFilename_only[_MAX_PATH];
	TCHAR szFilename_bak[_MAX_PATH];
	LPWSTR  pwsz = NULL;

	// because of the global flags and such, we'll make this critical
	EnterCriticalSection( &critical_section );

	if (lpLogFileName == NULL)
	{
		TCHAR szModuleFileName[_MAX_PATH];

		// if a logfilename was not specified then use the module name.
		if (GetModuleFileName(NULL, szModuleFileName, _MAX_PATH))
                {
                  // get only the filename
                  _tsplitpath( szModuleFileName, NULL, NULL, szFilename_only, NULL);
                  _tcscat(szFilename_only, _T(".LOG"));
                  _tcscpy(m_szLogFileName, szFilename_only);
                }
                else
                {
                  goto LogFileCreate_Exit;
                }
	}
	else
	{
		_tcscpy(m_szLogFileName, lpLogFileName);
	}

	if (GetWindowsDirectory(m_szLogFileName_Full, sizeof(m_szLogFileName_Full)))
    {
        AddPath(m_szLogFileName_Full, m_szLogFileName);
        if (GetFileAttributes(m_szLogFileName_Full) != 0xFFFFFFFF)
        {
            // Make a backup of the current log file
			_tsplitpath( m_szLogFileName_Full, szDrive_only, szPath_only, szFilename_only, NULL);

			_tcscpy(szFilename_bak, szDrive_only);
			_tcscat(szFilename_bak, szPath_only);
			_tcscat(szFilename_bak, szFilename_only);
            _tcscat(szFilename_bak, _T(".BAK"));

            SetFileAttributes(szFilename_bak, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szFilename_bak);
            if (MoveFile(m_szLogFileName_Full, szFilename_bak) == 0)
			{
				// This failed
				//::MessageBox(NULL, _T("LogFile MoveFile Failed"), _T("LogFile Error"), MB_OK | MB_SETFOREGROUND);
			}
        }

#if defined(UNICODE) || defined(_UNICODE)
	pwsz = m_szLogFileName_Full;
#else
	pwsz = MakeWideStrFromAnsi( m_szLogFileName_Full);
#endif

   
		// Open existing file or create a new one.
		m_hFile = CreateFile(m_szLogFileName_Full,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ | FILE_SHARE_WRITE,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
		if (m_hFile == INVALID_HANDLE_VALUE)
		{
			m_hFile = NULL;
			//::MessageBox(NULL, _T("Unable to create log file log file"), _T("LogFile Error"), MB_OK | MB_SETFOREGROUND);
		}
		else 
		{
			iReturn = TRUE;
		}
		//LogFileTimeStamp();
		LogFileWrite(_T("LogFile Open.\r\n"));
	}


LogFileCreate_Exit:
	// safe to leave the critical section
	LeaveCriticalSection( &critical_section );

	return iReturn;
}


//***************************************************************************
//*                                                                         
//* purpose:
//*
//***************************************************************************
int MyLogFile::LogFileClose(void)
{

	if (m_hFile)
	{
		LogFileWrite(_T("LogFile Close.\r\n"));
		CloseHandle(m_hFile);
		return TRUE;
	}
	return FALSE;
}


//***************************************************************************
//*                                                                         
//* purpose: add stuff to logfile
//*
//***************************************************************************
void MyLogFile::LogFileTimeStamp()
{
    SYSTEMTIME  SystemTime;
    GetLocalTime(&SystemTime);
	m_bDisplayTimeStamp = FALSE;
	m_bDisplayPreLineInfo = FALSE;
    LogFileWrite(_T("[%d/%d/%d %d:%d:%d]\r\n"),SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
	m_bDisplayTimeStamp = TRUE;
	m_bDisplayPreLineInfo = TRUE;
}


//***************************************************************************
//*                                                                         
//* purpose: 
//* 
//***************************************************************************
void MyLogFile::LogFileWrite(TCHAR *pszFormatString, ...)
{

    if (m_hFile)
    {
		// because of the global flags and such, we'll make this critical
		EnterCriticalSection( &critical_section );

		va_list args;
		TCHAR pszFullErrMsg[1000];
		char   pszFullErrMsgA[1000];
		strcpy(pszFullErrMsgA, "");

		DWORD dwBytesWritten = 0;

        va_start(args, pszFormatString);
		_vstprintf(pszFullErrMsg, pszFormatString, args); 
		va_end(args);

        if (pszFullErrMsg)
        {
#if defined(UNICODE) || defined(_UNICODE)
	// convert to ascii then write to stream
    WideCharToMultiByte( CP_ACP, 0, (TCHAR *)pszFullErrMsg, -1, pszFullErrMsgA, 2048, NULL, NULL );
#else
	// the is already ascii so just copy the pointer
	strcpy(pszFullErrMsgA,pszFullErrMsg);
#endif

			// If the Display timestap is set then display the timestamp
			if (m_bDisplayTimeStamp == TRUE)
			{
				// Get timestamp
				SYSTEMTIME  SystemTime;
				GetLocalTime(&SystemTime);
				char szDateandtime[50];
				sprintf(szDateandtime,"[%d/%d/%d %d:%d:%d] ",SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear,SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);
				// Write time to stream
				if (m_hFile) {WriteFile(m_hFile,szDateandtime,strlen(szDateandtime),&dwBytesWritten,NULL);}
			}

			char szPrelineWriteString[100];
			char szPrelineWriteString2[100];

			// If the Display timestap is set then display the timestamp
			if (m_bDisplayPreLineInfo == TRUE)
			{
				if (_tcscmp(m_szLogPreLineInfo,_T("")) != 0)
				{
#if defined(UNICODE) || defined(_UNICODE)
					// convert to ascii
					WideCharToMultiByte( CP_ACP, 0, (TCHAR *)m_szLogPreLineInfo, -1, szPrelineWriteString, 100, NULL, NULL );
#else
					// the is already ascii so just copy
					strcpy(szPrelineWriteString, m_szLogPreLineInfo);
#endif
					if (m_hFile) {WriteFile(m_hFile,szPrelineWriteString,strlen(szPrelineWriteString),&dwBytesWritten,NULL);}
				}

				if (_tcscmp(m_szLogPreLineInfo2,_T("")) != 0)
				{
#if defined(UNICODE) || defined(_UNICODE)
					// convert to ascii
					WideCharToMultiByte( CP_ACP, 0, (TCHAR *)m_szLogPreLineInfo2, -1, szPrelineWriteString2, 100, NULL, NULL );
#else
					// the is already ascii so just copy
					strcpy(szPrelineWriteString2, m_szLogPreLineInfo2);
#endif
					if (m_hFile) {WriteFile(m_hFile,szPrelineWriteString2,strlen(szPrelineWriteString2),&dwBytesWritten,NULL);}
				}
			}

			// if it does not end if '\r\n' then make one.
			int nLen = strlen(pszFullErrMsgA);

			if (pszFullErrMsgA[nLen-1] != '\n')
				{strcat(pszFullErrMsgA, "\r\n");}
			else
			{
				if (pszFullErrMsgA[nLen-2] != '\r') 
					{
					char * pPointer = NULL;
					pPointer = pszFullErrMsgA + (nLen-1);
					strcpy(pPointer, "\r\n");
					}
			}


			// Write Regular data to stream
			if (m_hFile) {WriteFile(m_hFile,pszFullErrMsgA,strlen(pszFullErrMsgA),&dwBytesWritten,NULL);}
        }

		// safe to leave the critical section
		LeaveCriticalSection( &critical_section );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\migrate.cpp ===
#include "stdafx.h"
#pragma hdrstop

//
// Constants
//
#define CP_USASCII          1252
#define END_OF_CODEPAGES    -1

// vendor info struct used in QueryVersion
typedef struct {
    CHAR    CompanyName[256];
    CHAR    SupportNumber[256];
    CHAR    SupportUrl[256];
    CHAR    InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO;

VENDORINFO g_VendorInfo;

//
// Code page array
//
INT g_CodePageArray[] = {CP_USASCII,END_OF_CODEPAGES};

//
// Multi-sz (i.e., double-nul terminated) list of files to find
//
CHAR g_ExeNamesBuf[] = "MetaData.bin\0";
CHAR g_MyProductId[100];
//#define UNATTEND_TXT_PWS_SECTION "PWS_W9x_Migrate_To_NT"
//#define UNATTEND_TXT_PWS_KEY1    "MigrateFile"
#define UNATTEND_TXT_PWS_SECTION "InternetServer"
#define UNATTEND_TXT_PWS_KEY1    "Win95MigrateDll"
#define PRODUCTID_IFRESOURCEFAILS "Microsoft Personal Web Server"
#define LOGFILENAME_IFRESOURCEFAILS "iis_w95.log"

CHAR g_MyDataFileName[] = "iis_w95.dat\0";
CHAR g_MyLogFileName[_MAX_FNAME];
CHAR g_PWS10_Migration_Section_Name_AddReg[] = "PWS10_MIGRATE_TO_NT5_REG\0";
CHAR g_PWS40_Migration_Section_Name_AddReg[] = "PWS40_MIGRATE_TO_NT5_REG\0";
char g_Migration_Section_Name_AddReg[50];
CHAR g_PWS10_Migration_Section_Name_CopyFiles[] = "PWS10_MIGRATE_TO_NT5_COPYFILES\0";
CHAR g_PWS40_Migration_Section_Name_CopyFiles[] = "PWS40_MIGRATE_TO_NT5_COPYFILES\0";
char g_Migration_Section_Name_CopyFiles[50];

CHAR g_WorkingDirectory[_MAX_PATH];
CHAR g_SourceDirectories[_MAX_PATH];
CHAR g_FullFileNamePathToSettingsFile[_MAX_PATH];

int g_iPWS40OrBetterInstalled = FALSE;
int g_iPWS10Installed = FALSE;
int g_iVermeerPWS10Installed = FALSE;

HANDLE g_MyModuleHandle = NULL;
MyLogFile g_MyLogFile;


int TurnOnPrivateLogFile(void)
{
    DWORD rc, err, size, type;
    HKEY  hkey;
    err = RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft"), &hkey);
    if (err != ERROR_SUCCESS) {return 0;}
    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,_T("SetupDebugLog"),0,&type,(LPBYTE)&rc,&size);
    if (err != ERROR_SUCCESS || type != REG_DWORD) {rc = 0;}
    RegCloseKey(hkey);

    //return 1;
    return (int) rc;
}

void My_MigInf_AddMessage(char *szProductId, char *szLoadedString)
{
	iisDebugOut(_T("MigInf_AddMessage:%s,%s"), g_MyProductId,szLoadedString);

	// 1. get the path to our pws migrate.inf
	// 2. stick this information in this section.
	//    [Incompatible Messages]
	//    Microsoft Personal Web Server = "szLoadedString"
	char szMyWorkingDirInfFile[_MAX_PATH];
	strcpy(szMyWorkingDirInfFile, g_WorkingDirectory);
	AddPath(szMyWorkingDirInfFile, "Migrate.inf");

	// the nt supplied api
	// this will write out the stuff below.
	//    [Incompatible Messages]
	//    Microsoft Personal Web Server = "szLoadedString"
	MigInf_AddMessage(g_MyProductId, szLoadedString);

	// Set the other required section.
	// This has to be written, otherwise the user will never get the message.
	// we have to set something, so let's just set the below, that way we know that this will showup.
	// HKLM\Software\Microsoft=Registry
	//
	// [Microsoft Personal Web Server]
	//  something=File
	//  something=Directory
	//  something=Registry
	// 
	if (FALSE == WritePrivateProfileString(szProductId, "\"HKLM\\Software\\Microsoft\"", "Registry", szMyWorkingDirInfFile))
		{iisDebugOut(_T("MigInf_AddMessage:WritePrivateProfileString(2) FAILED"));}

	return;
}


//
// Standard Win32 DLL Entry point
//
BOOL WINAPI DllMain(IN HANDLE DllHandle,IN DWORD  Reason,IN LPVOID Reserved)
{
    BOOL bReturn;
    bReturn = TRUE;

    switch(Reason) 
	{
		case DLL_PROCESS_ATTACH:
			g_MyModuleHandle = DllHandle;

			//
			// We don't need DLL_THREAD_ATTACH or DLL_THREAD_DETACH messages
			//
			DisableThreadLibraryCalls ((HINSTANCE) DllHandle);

			// open Our log file.
			if (TurnOnPrivateLogFile() != 0)
			{
				if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_MIGRATION_LOG_FILENAME, g_MyLogFileName, sizeof(g_MyLogFileName))) {strcpy(g_MyLogFileName, LOGFILENAME_IFRESOURCEFAILS);}
				strcpy(g_MyLogFile.m_szLogPreLineInfo, "DllMain, DLL_PROCESS_ATTACH:");
				g_MyLogFile.LogFileCreate(g_MyLogFileName);
			}
			
			// SetupAPI error log levels
			// -------------------------
			// LogSevInformation,
			// LogSevWarning,
			// LogSevError,
			// LogSevFatalError, (Reserved for use by windows nt setup)
			// LogSevMaximum

			// Open Setupapi log; FALSE means do not delete existing log
			SetupOpenLog(FALSE);

			LoadString((HINSTANCE) g_MyModuleHandle, IDS_PRODUCT_ID, g_MyProductId, sizeof(g_MyProductId));
			iisDebugOut(_T("ProductID=%s"), g_MyProductId);

            // if we can't initialize the migration writeback routines
			// then hey we can't do anything
			if (!MigInf_Initialize()) 
			{
				SetupLogError_Wrap(LogSevError, "MigInf_Initialize() FAILED.");
				return FALSE;
			}

            

			// Fall through to process first thread
		case DLL_THREAD_ATTACH:
			bReturn = TRUE;
			break;

		case DLL_PROCESS_DETACH:
			strcpy(g_MyLogFile.m_szLogPreLineInfo, "DllMain, DLL_PROCESS_DETACH:");
			//  clean up migration inf stuff
			MigInf_CleanUp();

			// Close our log file
			g_MyLogFile.LogFileClose();

			// Close setupapi log file
			SetupCloseLog();
			break;

		case DLL_THREAD_DETACH:
			break;
    }

    return(bReturn);
}


//-----------------------------------------------------------------------
// Required entry point that is called by setup
// Return Values:
//		ERROR_SUCCESS: if your migration DLL found one or more installed components for its target application. This guarantees that Setup will call your migration DLL for later processing. 
//		ERROR_NOT_INSTALLED: if your migration DLL initializes properly but did not find any of its components installed on the active Windows 9x installation. Note that Setup will not call your DLL again if it returns ERROR_NOT_INSTALLED. 
//
//		Your migration DLL must also return ERROR_SUCCESS if it does not attempt to detect installed components in QueryVersion. 
//
//		All other return values (Win32 error values) are considered initialization errors. Setup will report the error to the user, clean up your migration DLL's files, and ask the user to continue or cancel the Windows NT installation process. 
//-----------------------------------------------------------------------
LONG
CALLBACK
QueryVersion (
    OUT     LPCSTR *ProductID,
	OUT     LPUINT DllVersion,
	OUT     LPINT *CodePageArray,	    OPTIONAL
	OUT     LPCSTR *ExeNamesBuf,	    OPTIONAL
    OUT     PVENDORINFO *MyVendorInfo
    )
{
	long lReturn = ERROR_NOT_INSTALLED;
	strcpy(g_MyLogFile.m_szLogPreLineInfo, "QueryVersion:");
	iisDebugOut(_T("Start.  DllVersion=%d."), DllVersion);

    //
    // First, we do some preliminary investigation to see if 
    // our components are installed.  
    //
    if (TRUE != CheckIfPWS95Exists()) 
	{
        //
        // We didn't detect any components, so we return 
        // ERROR_NOT_INSTALLED and the DLL will stop being called.
        // Use this method as much as possible, because user enumeration
        // for MigrateUser9x is relatively slow.  However, don't spend too
        // much time here because QueryVersion is expected to run quickly.
        //

        // Check if frontpage.ini is there!
        if (TRUE != CheckFrontPageINI())
        {
		    goto QueryVersion_Exit;
        }
    }

    //
    // Screen saver is enabled, so tell Setup who we are.  ProductID is used
    // for display, so it must be localized.  The ProductID string is 
    // converted to UNICODE for use on Windows NT via the MultiByteToWideChar
    // Win32 API.  The first element of CodePageArray is used to specify
    // the code page of ProductID, and if no elements are returned in
    // CodePageArray, Setup assumes CP_ACP.
    //
	if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_PRODUCT_ID, g_MyProductId, sizeof(g_MyProductId))) 
		{strcpy(g_MyProductId, PRODUCTID_IFRESOURCEFAILS);}

	// return back this product id
	// warning: somehow they set this back to null or something, so
	// make sure to load g_MyProductId from the resource again.
    *ProductID = g_MyProductId;

    //
    // Report our version.  Zero is reserved for use by DLLs that
    // ship with Windows NT.
    //
    *DllVersion = 1;

    // 
    // Because we have English messages, we return an array that has
    // the English language ID.  The sublanguage is neutral because
    // we do not have currency, time, or other geographic-specific 
    // information in our messages.
    //
    // Tip: If it makes more sense for your DLL to use locales,
    // return ERROR_NOT_INSTALLED if the DLL detects that an appropriate 
    // locale is not installed on the machine.
    //

    // comment this line out so that it works on all languages...
    //*CodePageArray = g_CodePageArray;
    *CodePageArray = NULL;

    //
    // ExeNamesBuf - we pass a list of file names (the long versions)
    // and let Setup find them for us.  Keep this list short because
    // every instance of the file on every hard drive will be reported
    // in migrate.inf.
    //
    // Most applications don't need this behavior, because the registry
    // usually contains full paths to installed components.  We need it,
    // though, because there are no registry settings that give us the
    // paths of the screen saver DLLs.
    //

	// Check which directories we need to make sure are copied over.
	// for pws 1.0
	//   1. msftpsvc values for "Virtual Roots"
	//   2. w3svc values for "Script Map"
	//   3. w3svc values for "Virtual Roots"
	// for pws 4.0
	//   everything is in the metabase
    // do a function here which makes sure that our stuff in these above
	// directories gets copied over or that a warning gets put out to the
	// user that these directories will not be copied...etc,
	ReturnImportantDirs();

    *ExeNamesBuf = g_ExeNamesBuf;

    ZeroMemory(&g_VendorInfo, sizeof(g_VendorInfo));

    if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
        g_MyModuleHandle,
        MSG_VI_COMPANY_NAME,MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
        (LPTSTR) g_VendorInfo.CompanyName,
        sizeof(g_VendorInfo.CompanyName),
        NULL) <= 0) 
    {
        strcpy(g_VendorInfo.CompanyName, "Microsoft Corporation.");
    }

    if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
        g_MyModuleHandle,
        MSG_VI_SUPPORT_NUMBER,
        MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
        (LPTSTR) g_VendorInfo.SupportNumber,
        sizeof(g_VendorInfo.SupportNumber),
        NULL) <= 0) 
    {
        strcpy(g_VendorInfo.SupportNumber, "1-800-555-1212 (USA Only).");
    }

    if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
        g_MyModuleHandle,
        MSG_VI_SUPPORT_URL,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) g_VendorInfo.SupportUrl,
        sizeof(g_VendorInfo.SupportUrl),
        NULL) <= 0) 
    {
        strcpy(g_VendorInfo.SupportUrl, "http://www.microsoft.com/support.");
    }

    if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
        g_MyModuleHandle,
        MSG_VI_INSTRUCTIONS,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) g_VendorInfo.InstructionsToUser,
        sizeof(g_VendorInfo.InstructionsToUser),
        NULL) <= 0) 
    {
        strcpy(g_VendorInfo.InstructionsToUser, "Please contact Microsoft Technical Support for assistance with this problem..");
    }

    *MyVendorInfo = &g_VendorInfo;

    iisDebugOut(_T("CompanyName=%s"), g_VendorInfo.CompanyName);
    iisDebugOut(_T("SupportNumber=%s"), g_VendorInfo.SupportNumber);
    iisDebugOut(_T("SupportUrl=%s"), g_VendorInfo.SupportUrl);
    iisDebugOut(_T("InstructionsToUser=%s"), g_VendorInfo.InstructionsToUser);

	// We've gotten this far that means things are okay.
	lReturn = ERROR_SUCCESS;

QueryVersion_Exit:
	iisDebugOut(_T("  End.  Return=%d"), lReturn);
	return lReturn;
}


//-----------------------------------------------------------------------
// Required entry point that is called by setup
// Return Values:
//	ERROR_SUCCESS: if your migration DLL found one or more installed components for the target application. If your DLL does not attempt to detect installed components in Initialize9x, it must also return ERROR_SUCCESS 
//	ERROR_NOT_INSTALLED: if the migration DLL initializes properly but does not find any of its components installed on the active Windows 9x installation. Note that Setup will not call your DLL again if it returns ERROR_NOT_INSTALLED.
//-----------------------------------------------------------------------
LONG CALLBACK Initialize9x ( IN LPCSTR WorkingDirectory, IN LPCSTR SourceDirectories, LPVOID Reserved )
{
	strcpy(g_MyLogFile.m_szLogPreLineInfo, "Initialize9x:");
	long lReturn = ERROR_NOT_INSTALLED;
	iisDebugOut(_T("Start.  WorkingDir=%s, SourceDir=%s."), WorkingDirectory, SourceDirectories);

	// Load the productId into the global variable just incase
	LoadString((HINSTANCE) g_MyModuleHandle, IDS_PRODUCT_ID, g_MyProductId, sizeof(g_MyProductId));

    //
    // Because we returned ERROR_SUCCESS in QueryVersion, we are being
    // called for initialization.  Therefore, we know we are
    // enabled on the machine at this point.
    // 

    //
    // Make global copies of WorkingDirectory and SourceDirectories --
    // we will not get this information again, and we shouldn't
    // count on Setup keeping the pointer valid for the life of our
    // DLL.
    //
	// Save the working directories
	strcpy(g_WorkingDirectory, WorkingDirectory);
	strcpy(g_SourceDirectories, SourceDirectories);

	// name the settings file
	strcpy(g_FullFileNamePathToSettingsFile, g_WorkingDirectory);
	AddPath(g_FullFileNamePathToSettingsFile, g_MyDataFileName);

    //
    // First, we do some preliminary investigation to see if 
    // our components are installed.  
    //
    if (TRUE != CheckIfPWS95Exists()) 
    {
        // Check if frontpage.ini is there!
        if (TRUE != CheckFrontPageINI())
        {
		    goto Initialize9x_Exit;
        }
    }

    // We've gotten this far that means things are okay.
	lReturn = ERROR_SUCCESS;

Initialize9x_Exit:
	iisDebugOut(_T("  End.  Return=%d. g_WorkingDir=%s, g_SourceDir=%s, g_SettingsFile=%s."), lReturn, g_WorkingDirectory, g_SourceDirectories, g_FullFileNamePathToSettingsFile);
    return lReturn;
}

//-----------------------------------------------------------------------
// Required entry point that is called by setup
// we totally don't care about this part
// Return Values:
//		ERROR_SUCCESS if the target application is installed for the specified user. Also return ERROR_SUCCESS if your migration DLL needs further processing during the Windows NT phase. 
//		ERROR_NOT_INSTALLED if your target application is not installed for the specified user account and that user's registry does not require any processing. However, Setup will continue to call MigrateUser9x for the rest of the users, and MigrateSystem9x if this function returns ERROR_NOT_INSTALLED. 
//		ERROR_CANCELLED if the user wants to exit Setup. You should specify this return value only if ParentWnd is not set to NULL. 
//-----------------------------------------------------------------------
LONG
CALLBACK 
MigrateUser9x (
        IN HWND ParentWnd, 
        IN LPCSTR AnswerFile,
        IN HKEY UserRegKey, 
        IN LPCSTR UserName, 
        LPVOID Reserved
        )
    {
	strcpy(g_MyLogFile.m_szLogPreLineInfo, "MigrateUser9x:");
	long lReturn = ERROR_NOT_INSTALLED;

	// Return not installed since we don't do any user specific stuff.
	lReturn = ERROR_NOT_INSTALLED;

    return ERROR_NOT_INSTALLED;
    }


void HandleFrontPageUpgrade(LPCSTR AnswerFile)
{
    //[HKEY_LOCAL_MACHINE\Software\Microsoft\FrontPage\3.0]
    //"PWSInstalled"="1"
	iisDebugOut(_T("HandleFrontPageUpgrade.  Start."));

	// Check if pws 4.0 or better is installed.
	DWORD rc = 0;
	HKEY hKey = NULL;
	DWORD dwType, cbData;
	BYTE  bData[1000];
	cbData = 1000;
    int iTempFlag = FALSE;

    rc = RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\FrontPage", &hKey);
    if (rc != ERROR_SUCCESS) {goto HandleFrontPageUpgrade_Exit;}
	
	// Check if we can read a Value.
	//rc = RegQueryValueEx(hKey,REG_INETSTP_MAJORVERSION_STRINGVALUE,NULL,&dwType,bData,&cbData);
	//if (ERROR_SUCCESS != rc) {goto HandleFrontPageUpgrade_Exit;}

    // kool the key exists
    // let's tell Win2000 setup to make sure to upgrade the FrontPageServer Extensions
	if (0 == WritePrivateProfileString("Components", "fp_extensions", "ON", AnswerFile))
	{
		SetupLogError_Wrap(LogSevError, "Failed to WritePrivateProfileString Section=%s, in File %s.  GetLastError=%x.", "fp_extensions", AnswerFile, GetLastError());
	}
    else
    {
        iisDebugOut(_T("HandleFrontPageUpgrade.  Set 'fp_extensions=ON'"));
    }
    
HandleFrontPageUpgrade_Exit:
	if (hKey){RegCloseKey(hKey);}
	iisDebugOut(_T("HandleFrontPageUpgrade.  End."));
    return;
}

// function: HandleInetsrvDir
//
// This function marks all of the inetsrv files as handled.  This causes
// NT to correctly back them up, and reinstall if we remove Whistler, and
// go back to Win9x.
//
// Return Values
//   FALSE - It failed
//   TRUE - It succeeded
DWORD
HandleInetsrvDir()
{
  TCHAR             szSystemDir[_MAX_PATH];
  TCHAR             szWindowsSearch[_MAX_PATH];
  TCHAR             szFilePath[_MAX_PATH];
  WIN32_FIND_DATA   fd;
  HANDLE            hFile;

  // Create Path
  if ( GetWindowsDirectory(szSystemDir, sizeof(szSystemDir) / sizeof(TCHAR) ) == 0)
  {
    return FALSE;
  }
  AddPath(szSystemDir,_T("system\\inetsrv\\"));
  strcpy(szWindowsSearch,szSystemDir);
  AddPath(szWindowsSearch,_T("*.*"));

  iisDebugOut(_T("HandleInetsrvDir:Path=%s\r\n"),szWindowsSearch);

  // Find First File
  hFile = FindFirstFile(szWindowsSearch, &fd);
  if ( hFile == INVALID_HANDLE_VALUE )
  {
    // Could not find file
    return FALSE;
  }

  do {

    if ( !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
      // It is not a directory, so lets add it
      strcpy(szFilePath,szSystemDir);
      AddPath(szFilePath,fd.cFileName);
      iisDebugOut(_T("HandleInetsrvDir:delete=%s\r\n"),szFilePath);
      MigInf_AddHandledFile( szFilePath );
    }
    else
    {
        strcpy(szFilePath,fd.cFileName);
        iisDebugOut(_T("HandleInetsrvDir:skip del=%s\r\n"),szFilePath);
    }

  } while ( FindNextFile(hFile, &fd) ); 

  FindClose(hFile);

  return TRUE;
}

//-----------------------------------------------------------------------
// Required entry point that is called by setup
// Return Values:
//		ERROR_SUCCESS if your target application is installed on the system. Also returns ERROR_SUCCESS if system-wide changes need to be made for the target application during the Windows NT phase of the upgrade. 
//		ERROR_NOT_INSTALLED if your migration DLL detects no application components common to the entire system or if your DLL requires no further processing. Note that Setup will continue to call MigrateUser9x for the rest of the users, and MigrateSystem9x if this function returns ERROR_NOT_INSTALLED. 
//		ERROR_CANCELLED if the user elects to exit the Setup program. Use this return value only if ParentWnd is not NULL. 
//-----------------------------------------------------------------------
LONG 
CALLBACK 
MigrateSystem9x (
        IN HWND ParentWnd, 
        IN LPCSTR AnswerFile,
        LPVOID Reserved
        )
{
	strcpy(g_MyLogFile.m_szLogPreLineInfo, "MigrateSystem9x:");
	long lReturn = ERROR_NOT_INSTALLED;
	iisDebugOut(_T("Start.  AnswerFile=%s."), AnswerFile);
	char szMyWorkingDirInfFile[_MAX_PATH];
	strcpy(szMyWorkingDirInfFile, g_WorkingDirectory);
	AddPath(szMyWorkingDirInfFile, "Migrate.inf");

	// Load the productId into the global variable just incase
	LoadString((HINSTANCE) g_MyModuleHandle, IDS_PRODUCT_ID, g_MyProductId, sizeof(g_MyProductId));

    // do some special stuff for frontpage's .ini file
    MoveFrontPageINI();

    //
    // First, maybe iis isn't even installed, check first.
    // but do this after doing the frontpage stuff
    //
    if (TRUE != CheckIfPWS95Exists())
    {
	    lReturn = ERROR_SUCCESS;
        goto MigrateSystem9x_Exit;
    }


	// If the user has Vermeer pws 1.0 installed then we have to put up a
	// Message saying "sorry we can't upgrade this."
	if (g_iVermeerPWS10Installed == TRUE)
	{
		// get from resource
		char szLoadedString[512];
		if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_VERMEER_PWS_1_NOT_SUPPORTED, szLoadedString, sizeof(szLoadedString))) 
			{strcpy(szLoadedString, "Warning: Vermeer Frontpage Personal Web Server 1.0 detected and will not be upgraded to IIS 5.0.");}
		// Write the string out to our answer file so that nt5 setup will show it to  the user
		My_MigInf_AddMessage(g_MyProductId, szLoadedString);
		// Important: Write memory version of migrate.inf to disk
		if (!MigInf_WriteInfToDisk()) {SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.");lReturn = GetLastError();}
		goto MigrateSystem9x_Exit;
	}
	//
	// Upgrade from win95 to NT5/iis5 is not supported.
	// IDS_NT5_BETA2_NOT_SUPPORTED
	//
	/*
	8/19/98 commented this stuff for RTM
	if (TRUE == CheckIfPWS95Exists())
	{
		// get from resource
		char szLoadedString[512];
		if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_NT5_BETA2_NOT_SUPPORTED, szLoadedString, sizeof(szLoadedString))) 
			{strcpy(szLoadedString, "Win2000 Beta will not support upgrades of Personal Web Server from Windows 95, or Windows 98.  Please remove Personal Web Server from your Windows machine, and then add IIS after Win2000 setup has completed.  Setup will continue without installing IIS 5.0.");}
		// Write the string out to our answer file so that nt5 setup will show it to  the user
		My_MigInf_AddMessage(g_MyProductId, szLoadedString);
		// Important: Write memory version of migrate.inf to disk
		if (!MigInf_WriteInfToDisk()) {SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.");lReturn = GetLastError();}
		goto MigrateSystem9x_Exit;
	}
	*/

    // remove all old stuff from the win95 pws10/40 installation.
    // this has to be done regardless if the target os support iis...

    // We need to tell migration setup that we are going to handle certain files...
    // particularly the c:\windows\SendTo\Personal Web Server.lnk file
    // since it doesn't seem to be accessible during win2000/20001 guimode setup
    iisDebugOut(_T("Start.  Calling HandleSendToItems."));
    HandleSendToItems(AnswerFile);
    iisDebugOut(_T("Start.  Calling HandleDesktopItems."));
    HandleDesktopItems(AnswerFile);
    iisDebugOut(_T("Start.  Calling HandleStartMenuItems."));
    HandleStartMenuItems(AnswerFile);
    iisDebugOut(_T("Start.  Calling HandleSpecialRegKey."));
    HandleSpecialRegKey();
    // Handle the inetsrv dir
    iisDebugOut(_T("Start.  Calling HandleInetsrvDir."));
    HandleInetsrvDir();

    if (!MigInf_WriteInfToDisk()) {SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.");lReturn = GetLastError();}

    //MessageBox(NULL, "check out the file now", AnswerFile, MB_OK);

    // check if the target OS (that we want to upgrade to) supports iis on it
    if (FALSE == IsUpgradeTargetSupportIIS(szMyWorkingDirInfFile))
    {
        iisDebugOut(_T("Target OS does not support IIS. put up msg."));
		// get from resource
		char szLoadedString[512];
		if (!LoadString((HINSTANCE) g_MyModuleHandle, IDS_TARGET_OS_DOES_NOT_SUPPORT_UPGRADE, szLoadedString, sizeof(szLoadedString))) 
			{strcpy(szLoadedString, "Warning, the target OS does not support IIS.  IIS will be removed upon upgrade.");}
		// Write the string out to our answer file so that nt setup will show it to  the user
		My_MigInf_AddMessage(g_MyProductId, szLoadedString);
		// Important: Write memory version of migrate.inf to disk
		if (!MigInf_WriteInfToDisk()) {SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.");lReturn = GetLastError();}
        lReturn = ERROR_SUCCESS;
		goto MigrateSystem9x_Exit;
    }
   
	// 1. do any setup upgrade type of work to ensure
	// that we get all the settings stuff over to NT5 land.
	// -------------------------------
	iisDebugOut(_T("Start.  Calling MyUpgradeTasks."));
    MyUpgradeTasks(AnswerFile);

    // If FrontPage is installed, then do some funky hack since
    // the frontpage guys can't fix they upgrade setup bug.
    // HandleFrontPageUpgrade(AnswerFile);

	// 2. move over the registry stuff
	// -------------------------------
	// Lookup the registry settings and save into our "settings" file.
	iisDebugOut(_T("Start.  Calling MySettingsFile_Write."));
    MySettingsFile_Write();

	// We need to tell NT5 gui mode setup (where iis/pws will actually get upgraded).
	// Where to find the upgrade file.  
	// during upgrade it should just install the DefaultInstall section of the pwsmigt.dat file
	// We will tell iis/pws nt5 setup where the pwsmigt.dat in the answer file.
	// Answer file should be located in the c:\windows\setup\unattend.tmp file on the win95 side.
	// On the WinNT5 side, it should be at...
	assert(AnswerFile);
	iisDebugOut(_T("Start.  Calling WritePrivateProfileString.%s."), AnswerFile);
	if (0 == WritePrivateProfileString(UNATTEND_TXT_PWS_SECTION, UNATTEND_TXT_PWS_KEY1, g_FullFileNamePathToSettingsFile, AnswerFile))
	{
		SetupLogError_Wrap(LogSevError, "Failed to WritePrivateProfileString Section=%s, in File %s.  GetLastError=%x.", UNATTEND_TXT_PWS_SECTION, AnswerFile, GetLastError());
		goto MigrateSystem9x_Exit;
	}

/*
    Example: For Generating messages to the user during Win95 time
	MigInf_AddMessage(g_MyProductId, "We were unable to upgrade the pws 1.0 installation because of failure.");
	// Important: Write memory version of migrate.inf to disk
	if (!MigInf_WriteInfToDisk()) {SetupLogError_Wrap(LogSevError, "Error: MigInf_WriteInfToDisk() FAILED.");lReturn = GetLastError();}
*/
			
    // We've gotten this far that means things are okay.
	lReturn = ERROR_SUCCESS;

MigrateSystem9x_Exit:
    W95ShutdownW3SVC();
	iisDebugOut(_T("  End.  Return=%d."), lReturn);
    return lReturn;
}

//-----------------------------------------------------------------------
// Required entry point that is called by setup
// Return Values:
//		ERROR_SUCCESS if your migration DLL initializes properly within the Windows NT environment. 
//		All other return values (Win32 error values) are considered critical errors. Setup reports the error to the user and then cancels processing your migration DLL. However, Setup will not continue the upgrade. Any errors or logs generated will include the ProductID string specified in QueryVersion to identify your DLL. 
//-----------------------------------------------------------------------
LONG CALLBACK InitializeNT ( IN LPCWSTR WorkingDirectory, IN LPCWSTR SourceDirectories, LPVOID Reserved )
{
	strcpy(g_MyLogFile.m_szLogPreLineInfo, "InitializeNT:");
	iisDebugOut(_T("Start."));
	long lReturn = ERROR_NOT_INSTALLED;
	// Load the productId into the global variable just incase
	LoadString((HINSTANCE) g_MyModuleHandle, IDS_PRODUCT_ID, g_MyProductId, sizeof(g_MyProductId));

	// change the Wide characters to ansi
    WideCharToMultiByte (CP_ACP, 0, WorkingDirectory, -1,g_WorkingDirectory,_MAX_PATH,NULL,NULL);
	WideCharToMultiByte (CP_ACP, 0, SourceDirectories, -1,g_SourceDirectories,_MAX_PATH,NULL,NULL);
	// name the settings file
	strcpy(g_FullFileNamePathToSettingsFile, g_WorkingDirectory);
	AddPath(g_FullFileNamePathToSettingsFile, g_MyDataFileName);
	
    // We've gotten this far that means things are okay.
	lReturn = ERROR_SUCCESS;

	iisDebugOut(_T("  End.  Return=%d, g_WorkingDir=%s, g_SourceDir=%s, g_SettingsFile=%s."), lReturn, g_WorkingDirectory, g_SourceDirectories, g_FullFileNamePathToSettingsFile);
    return lReturn;
}

//-----------------------------------------------------------------------
// Required entry point that is called by setup
// Return Values:
//		ERROR_SUCCESS if the migration of user-specific settings is successful.
//		Other error codes will terminate the processing of your migration DLL. However, Windows NT Setup will proceed. Ideally, only critical problems (such as a hardware failure) should generate terminating error codes. 
//-----------------------------------------------------------------------
LONG CALLBACK MigrateUserNT (  IN HINF AnswerFileHandle, IN HKEY UserRegKey, IN LPCWSTR UserName,  LPVOID Reserved )
    {
	strcpy(g_MyLogFile.m_szLogPreLineInfo, "MigrateUserNT:");
	iisDebugOut(_T("Start."));
	long lReturn = ERROR_NOT_INSTALLED;
	// Load the productId into the global variable just incase
	LoadString((HINSTANCE) g_MyModuleHandle, IDS_PRODUCT_ID, g_MyProductId, sizeof(g_MyProductId));

    // We've gotten this far that means things are okay.
	lReturn = ERROR_SUCCESS;
	iisDebugOut(_T("  End.  Return=%d."), lReturn);
    return lReturn;
    }

//-----------------------------------------------------------------------
// Required entry point that is called by setup
// Return Values:
//		ERROR_SUCCESS if the migration of system-wide settings is successful.
//		Other error codes will terminate the processing of your migration DLL. However, Windows NT Setup will proceed. Ideally, only critical problems (such as a hardware failure) should generate terminating error codes
//-----------------------------------------------------------------------
LONG CALLBACK MigrateSystemNT (  IN HINF AnswerFileHandle, LPVOID Reserved )
{
	strcpy(g_MyLogFile.m_szLogPreLineInfo, "MigrateSystemNT:");
	long lReturn = ERROR_NOT_INSTALLED;
	iisDebugOut(_T("Start."));
	// Load the productId into the global variable just incase
	LoadString((HINSTANCE) g_MyModuleHandle, IDS_PRODUCT_ID, g_MyProductId, sizeof(g_MyProductId));

    // Delete the Win95 migrated StartMenu/Desktop Items!
    iisDebugOut(_T("Calling iis.dll section: %s. Start."),_T("OC_CLEANUP_WIN95_MIGRATE"));
    Call_IIS_DLL_INF_Section("OC_CLEANUP_WIN95_MIGRATE");
    iisDebugOut(_T("Calling iis.dll section: %s. End."), _T("OC_CLEANUP_WIN95_MIGRATE"));

	// ------------------------------------------
	// We don't need to do anything in this part:
	// Because:
	//  1. this migration stuff (MigrateSystemNT) Gets called in NT5 setup
	//     after all the ocmanage stuff is completed.  By then our IIS5/PWS5 setup 
	//     would have already upgrade the internet server.
	//     We just have to make sure that the iis/pws 5.0 setup finds our
	//     "Settings" file and installs the default section within it.
	//  2. based on #1 if we install the "settings" file, we will hose
	//     the registry settings which were created during the ocmanage nt5 gui mode setup.
	// ------------------------------------------

	// Execute an .inf section from our "settings" file
	//if (MySettingsFile_Install() != TRUE) {goto MigrateSystemNT_Exit;}
    AnswerFile_ReadSectionAndDoDelete(AnswerFileHandle);

    // We've gotten this far that means things are okay.
	lReturn = ERROR_SUCCESS;

//MigrateSystemNT_Exit:
	iisDebugOut(_T("  End.  Return=%d."), lReturn);
    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\miginf.cpp ===
#include "stdafx.h"

#define MIGRATEINF              ".\\migrate.inf"
#define INITIALBUFFERSIZE       1024
#define MIGINF_NOCREATE         FALSE
#define MIGINF_CREATE           TRUE


typedef struct tagMIGOBJECT MIGOBJECT, *PMIGOBJECT;
struct tagMIGOBJECT {

    PSTR        Key;
    PSTR        Value;
    
    PMIGOBJECT  Next;
};

typedef struct tagMIGSECTION MIGSECTION, * PMIGSECTION;
struct tagMIGSECTION {

    PSTR        Name;
    PMIGOBJECT  Items;

    PMIGSECTION Next;
};

PMIGSECTION g_MigrationInf;
POOLHANDLE  g_Pool = NULL;


static
PCSTR
pGetTypeAsString (
    IN MIGTYPE Type
    )
{
    //
    // Note: Strings must be in the same order as the 
    // corresponding types in the MIGTYPE enumeration above.
    //
    static PCHAR typeStrings[] = {
            "FIRST - Invalid",
            "File",
            "Path",
            "Registry",
            "Message - Invalid",
            "LAST - Invalid"
        };

    assert(Type > MIG_FIRSTTYPE && Type < MIG_LASTTYPE);

    return typeStrings[Type];
}

static
PMIGSECTION 
pFindSection (
    IN PCSTR SectionString,
    IN BOOL  CreateIfNotExist
    )
{
    PMIGSECTION rSection;

    //
    // We assume that SectionString is not null.
    //
    assert(SectionString);

    rSection = g_MigrationInf;

    while (rSection && (_mbsicmp((const unsigned char *) rSection -> Name,(const unsigned char *) SectionString) != 0)) {

        //
        // Continue looking.
        //
        rSection = rSection -> Next;
    }
        
    if (!rSection && CreateIfNotExist) {
        //
        // No section was found matching this name. Make a new section and add it 
        // to the list.
        //
        rSection = (PMIGSECTION) PoolMemGetMemory(g_Pool,sizeof(MIGSECTION));
        if (rSection) {

            ZeroMemory(rSection,sizeof(MIGSECTION));
            rSection -> Name  = PoolMemDuplicateStringA(g_Pool,SectionString);
            rSection -> Next  = g_MigrationInf;
            g_MigrationInf    = rSection;

            if (!rSection -> Name) {
                //
                // Something went wrong when we tried to duplicate the SectionString.
                // NULL out the rSection so that the caller doesn't get back a 
                // malformed section object.
                //
                rSection = NULL;
            }
        }
    }

    return rSection;
}

static
BOOL
pPathIsInPath(
    IN PCSTR    SubPath,
    IN PCSTR    ParentPath
    )
{
    DWORD parentLength;
    BOOL  rInPath;

    //
    // This function assumes both parameters are non-NULL.
    //
    assert(SubPath);
    assert(ParentPath);
    
    parentLength = _mbslen((const unsigned char *) ParentPath);

    //
    // A path is considered "in" another path if the path is in the ParentPath
    // or a subdirectory of it.
    //
    rInPath = !_mbsnicmp((const unsigned char *) SubPath,(const unsigned char *) ParentPath,parentLength);

    if (rInPath) {
        rInPath = SubPath[parentLength] == 0 || SubPath[parentLength] == '\\';
    }

    return rInPath;

}

static
DWORD
pGetMbsSize (
    IN  LPCSTR  String
    )
{
    DWORD rLength;
    
    //rLength = (DWORD) _mbschr((const unsigned char *) String,0) - (DWORD) String + 1;
    rLength = strlen(String + 1);

    return rLength;

}


static
LPSTR 
pEscapeString (
    IN  MIGTYPE Type,
    OUT LPSTR   EscapedString, 
    IN  LPCSTR  String
    )

{
    LPSTR   stringStart;
    static  CHAR exclusions[] = "[]~,;%\"";
    INT     currentChar;

    //
    // We assume that all parameters are valid.
    //
    assert(EscapedString && String);

    stringStart = EscapedString;

    while (*String)  {
        currentChar = _mbsnextc ((const unsigned char *) String);
        
        if (Type == MIG_REGKEY) {
            
            //
            // Registry keys require more complex escaping than do normal INF strings.
            //
            if (!_ismbcprint (currentChar) || _mbschr ((const unsigned char *) exclusions, currentChar)) {
                
                //
                // Escape unprintable or excluded character
                //
                wsprintfA (EscapedString, "~%X~", currentChar);
                EscapedString = (LPSTR) _mbschr ((const unsigned char *) EscapedString, 0);
                String = (LPCSTR) _mbsinc((const unsigned char *) String);
            }
            else {
                //
                // Copy multibyte character
                //
                if (isleadbyte (*String)) {
                    *EscapedString = *String;
                    EscapedString++;
                    String++;
                }
                
                *EscapedString = *String;
                EscapedString++;
                String++;
            }
        }
        else {

            //
            // Escaping is pretty simple for non-registry keys. All we do is double up
            // quotes and percents.
            //
            if (*String == '\"' || *String == '%') {

                *EscapedString = *String;
                EscapedString++;
            }
            
            //
            // Copy multibyte character
            //
            if (isleadbyte (*String)) {
                *EscapedString = *String;
                EscapedString++;
                String++;
            }
            
            *EscapedString = *String;
            EscapedString++;
            String++;
        }
    }

    //
    // Ensure that returned string is NULL terminated.
    //
    *EscapedString = 0;

    return stringStart;
}


static
PSTR
pGetValueString (
    IN MIGTYPE    ObjectType,
    IN LPCSTR     StringOne,
    IN LPCSTR     StringTwo
    )
{
    static PSTR     buffer;
    static DWORD    bufferSize;
    DWORD           maxLength;
    PSTR            bufferEnd;
    
    //
    // This function assumes that StringOne exists.
    //
    assert(StringOne);

    if (ObjectType == MIG_REGKEY) {
        //
        // Size: size of both strings, plus the size of the quotes, plus the size of the brackets 
        // for the value, * 6. This is the maximum size one of these could grow to, if every 
        // character had to be escaped out.
        //
        maxLength = (pGetMbsSize(StringOne) + (StringTwo ? pGetMbsSize(StringTwo) + 2 : 0)) * 6 + 2;
    }
    else {
        //
        // Size: size of the string * 2 (The max size if every char was a '%' or '"' plus the quotes.
        //
        maxLength = pGetMbsSize(StringOne) * 2 + 2;
    }

    if (maxLength > bufferSize) {

        //
        // Initialize our buffer, or create a larger one.
        //
        bufferSize = (maxLength > INITIALBUFFERSIZE) ? maxLength : INITIALBUFFERSIZE;
        buffer = PoolMemCreateStringA(g_Pool,bufferSize);
    }

    if (buffer != NULL) {
        
        //
        // Insert initial quote.
        //
        *buffer = '"';
 
        //
        // Massage the string to ensure it is a valid INF file string.
        //
        pEscapeString(ObjectType,(char *) _mbsinc((const unsigned char *) buffer),StringOne);

        //
        // If this is a REGISTRY entry, then we also need to add the value part of the string, 
        // if one was specified (In StringTwo)
        //

        if (ObjectType == MIG_REGKEY && StringTwo) {

            //
            // Add the opening bracket.
            //
            bufferEnd = (PSTR) _mbschr((const unsigned char *) buffer,0);
            if (bufferEnd)
            {
                *bufferEnd = '[';
            
                //
                // Add the value string in, again making sure the string is valid for an INF file.
                //
                pEscapeString(ObjectType,(char *) _mbsinc((const unsigned char *) bufferEnd),StringTwo);

                //
                // Now, add the closing braket.
                //
                bufferEnd = (PSTR) _mbschr((const unsigned char *) buffer,0);
                if (bufferEnd)
                {
                    *bufferEnd = ']';
                    //
                    // Terminate the string.
                    //
                    bufferEnd = (PSTR) _mbsinc((const unsigned char *) bufferEnd);
                    if (bufferEnd) {*bufferEnd = 0;}
                 }
            }
        }

        //
        // Add the final quote.
        //
        bufferEnd = (PSTR) _mbschr((const unsigned char *) buffer,0);
        if (bufferEnd) {*bufferEnd = '"';}
        bufferEnd = (PSTR) _mbsinc((const unsigned char *) bufferEnd);
        if (bufferEnd) {*bufferEnd = 0;}
    }
    
    return buffer;
}

static
BOOL
pCreateMigObject (
    IN MIGTYPE          ObjectType,
    IN PCSTR            ParamOne,
    IN PCSTR            ParamTwo,
    IN PMIGSECTION      Section
    )
{
    BOOL            rSuccess = FALSE;
    PMIGOBJECT      newObject = NULL;
    PSTR pTemp = NULL;

    //
    // pCreateMigObject uses a set of hueristics to correctly assemble an object. 
    // These hueristics are based on the ObjectType and the contents of ParamTwo.
    // 
    // ObjectType       ParamTwo      Key                   Value
    // -------------------------------------------------------------------------
    // MIG_REGKEY       <any>         ParamOne[ParamTwo]    Registry
    // <other>          NULL          ParamOne              <ObjectType As String>
    // <other>          non-NULL      ParamOne              ParamTwo
    //
    //

    if (Section) {

        //
        // First, create an object...
        //
        newObject = (PMIGOBJECT) PoolMemGetMemory(g_Pool,sizeof(MIGOBJECT));

        if (newObject) {

            if (ObjectType == MIG_REGKEY) {

                pTemp = pGetValueString(ObjectType,ParamOne,ParamTwo);
                if (pTemp)
                   {newObject -> Key = PoolMemDuplicateStringA(g_Pool,pTemp);}
                else 
                    {
                    // out of memory
                    goto pCreateMigObject_Exit;
                    }

                newObject -> Value = PoolMemDuplicateStringA(g_Pool,pGetTypeAsString(ObjectType));
            }
            else {
                
                pTemp = pGetValueString(ObjectType,ParamOne,NULL);
                if (pTemp)
                   {newObject -> Key = PoolMemDuplicateStringA(g_Pool,pTemp);}
                else
                    {
                    // out of memory
                    goto pCreateMigObject_Exit;
                    }

                if (ParamTwo) {
                    pTemp = pGetValueString(ObjectType,ParamTwo,NULL);
                    if (pTemp) 
                       {newObject -> Value = PoolMemDuplicateStringA(g_Pool,pTemp);}
                    else
                        {
                        // out of memory
                        goto pCreateMigObject_Exit;
                        }

                }
                else {
                     newObject -> Value = PoolMemDuplicateStringA(g_Pool,pGetTypeAsString(ObjectType));
                }
            }
        }
    }


    if (newObject)
    {
        if (newObject -> Key && newObject -> Value) {
            //
            // The object has been successfully created. Link it into the section.
            //
            newObject -> Next = Section -> Items;
            Section -> Items = newObject;
            rSuccess = TRUE;
        }
        else {
            rSuccess = FALSE;
        }
    }
    else {
        rSuccess = FALSE;
    }

pCreateMigObject_Exit:
    return rSuccess;
}


static
BOOL
pWriteInfSectionToDisk (
    IN PMIGSECTION Section
    )
{
    PMIGOBJECT curObject;
    BOOL       rSuccess = TRUE;

    if (Section) {

        curObject = Section -> Items;

        while (curObject && rSuccess) {

            if (Section -> Name && curObject -> Key && curObject -> Value) {
            
                rSuccess = WritePrivateProfileString(
                    Section   -> Name,
                    curObject -> Key, 
                    curObject -> Value,
                    MIGRATEINF
                    );
            }

            curObject = curObject -> Next;
        }
    }
    else {
        rSuccess = FALSE;
    }

    return rSuccess;
}


static
BOOL
pBuildListFromSection (
    IN PCSTR    SectionString
    )
{
    HINF            infHandle;
    PMIGSECTION     section;
    PMIGOBJECT      currentObject;
    INFCONTEXT      ic;
    DWORD           size;
    BOOL            rSuccess = TRUE;

    //
    // This function assumes that Section is non-NULL.
    //
    assert(SectionString);

    currentObject = NULL;
    
    //
    // First find the section specified.
    //
    section = pFindSection(SectionString,MIGINF_CREATE);

    if (section) {
        
        infHandle = SetupOpenInfFileA(MIGRATEINF,NULL,INF_STYLE_WIN4,NULL);
        
        if (infHandle != INVALID_HANDLE_VALUE) {
            
            if (SetupFindFirstLine(infHandle,SectionString,NULL,&ic)) {
                
                do {

                    //
                    // Create the object.
                    //
                    currentObject = (PMIGOBJECT) PoolMemGetMemory(g_Pool,sizeof(MIGOBJECT));
                    
                    if (!currentObject) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Get the size of the string.
                    //
                    if (!SetupGetLineTextA(&ic,NULL,NULL,NULL,NULL,0,&size)) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Create a string large enough.
                    //
                    currentObject -> Key = PoolMemCreateStringA(g_Pool,size);
                    
                    if (!currentObject -> Key) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Get the string.
                    //
                    if (!SetupGetLineTextA(&ic,NULL,NULL,NULL,currentObject -> Key,size,NULL)) {
                        rSuccess = FALSE;
                        break;
                    }
                    
                    //
                    // Successfully retrieved the line.
                    //
                    currentObject -> Value  = (PSTR) pGetTypeAsString(MIG_FILE);
                    currentObject -> Next   = section -> Items;
                    section -> Items        = currentObject;
                    
                } while(SetupFindNextLine(&ic,&ic));
                
            }
            
            SetupCloseInfFile(infHandle);
        }
    }
    else {
        rSuccess = FALSE;
    }

    return rSuccess;
}


BOOL
WINAPI
MigInf_Initialize(
    VOID
    )
{

    //
    // First, initialize our pool and Zero out the structure.
    //
    g_Pool = PoolMemInitPool();


    if (g_Pool) {
        
        //
        // Now, read in the migration paths and excluded paths sections.
        //
        if (!pBuildListFromSection(SECTION_MIGRATIONPATHS) ||
            !pBuildListFromSection(SECTION_EXCLUDEDPATHS)) {
            //
            // Something went wrong (i.e. out of memory. Destroy and NULL our pool.
            //
            PoolMemDestroyPool(g_Pool);
            g_Pool = NULL;
        }
    }

    //
    // If our memory pool initialized successfully, return TRUE.
    //
    return (g_Pool != NULL);

}


VOID
WINAPI
MigInf_CleanUp (
    VOID
    )
{
    //
    // Only thing we need to do is clean out pool mem. We'll NULL out the list header to make
    // sure it isn't usable.
    //
    if (g_Pool) {
        PoolMemDestroyPool(g_Pool);
        g_Pool = NULL;
    }
    
    g_MigrationInf = NULL;

}


BOOL
WINAPI
MigInf_AddObject (
    IN MIGTYPE  ObjectType,
    IN PCSTR    SectionString,
    IN PCSTR    ParamOne,
    IN PCSTR    ParamTwo
    )
{

    return pCreateMigObject(
        ObjectType,
        ParamOne,
        ParamTwo,
        pFindSection(SectionString,MIGINF_CREATE)
        );
}

BOOL 
WINAPI 
MigInf_FirstInSection(
    IN PCSTR SectionName, 
    OUT PMIGINFSECTIONENUM Enum
    )
{
    PMIGSECTION section;

    //
    // We assume that Enum is valid.
    //
    assert(Enum);

    section = pFindSection(SectionName,MIGINF_NOCREATE);

    if (section) {
        Enum -> EnumKey = (PVOID) section -> Items;
    }

    return MigInf_NextInSection(Enum);
}

BOOL 
WINAPI 
MigInf_NextInSection(
    IN OUT PMIGINFSECTIONENUM Enum
    )
{


    BOOL            rSuccess = FALSE;

    //
    // We assume that the Enum is valid.
    //
    assert(Enum);

    if (Enum -> EnumKey) {

        Enum -> Key     = ((PMIGOBJECT) (Enum -> EnumKey)) -> Key;
        Enum -> Value   = ((PMIGOBJECT) (Enum -> EnumKey)) -> Value;
        Enum -> EnumKey = ((PVOID) ((PMIGOBJECT) (Enum -> EnumKey)) -> Next);
        rSuccess = TRUE;
    }

    return rSuccess;
}


BOOL
WINAPI
MigInf_WriteInfToDisk (
    VOID
    )
{

    BOOL        rSuccess = TRUE;
    PMIGSECTION curSection;
    
    //
    // Simply loop through all of the sections, writing each of them to disk.
    // As long as WriteSectionToDisk works, we work.
    //
    curSection = g_MigrationInf;

    while (curSection && rSuccess) {

        //
        // We skip the [Excluded Paths] and [Migration Paths] sections.
        //
        if (_mbsicmp((const unsigned char *) curSection -> Name,(const unsigned char *) SECTION_EXCLUDEDPATHS) &&
            _mbsicmp((const unsigned char *) curSection -> Name,(const unsigned char *) SECTION_MIGRATIONPATHS)) {
            
            rSuccess = pWriteInfSectionToDisk(curSection);
        } 

        curSection = curSection -> Next;
        
    }

    return rSuccess;
}

BOOL
WINAPI
MigInf_PathIsExcluded (
    IN PCSTR    Path
    )
{
    PMIGOBJECT  curExcluded;
    PMIGSECTION section;
    BOOL        rIsExcluded = FALSE;

    //
    // We assume Path is valid.
    //
    assert(Path);
    
    section = pFindSection(SECTION_EXCLUDEDPATHS,MIGINF_NOCREATE);

    if (section) {

        curExcluded = section -> Items;
        
        while (curExcluded && !rIsExcluded) {
            
            rIsExcluded = pPathIsInPath(Path,curExcluded -> Key);
            curExcluded = curExcluded -> Next;
        }
    }
    
    return rIsExcluded;
}



PCSTR
WINAPI
MigInf_GetNewSectionName (
    VOID
    )
{

    static CHAR     sectionName[20];
    static DWORD    seedNum=0;


    sprintf(sectionName,"msg%0.7u",seedNum++);

    return sectionName;
}


BOOL IsUpgradeTargetSupportIIS(LPCSTR szMyAnswerFile)
{
    BOOL bReturn = TRUE;
    char szPlatformString[_MAX_PATH];

	if (GetPrivateProfileString("Version", "SetupSKU", _T(""), szPlatformString, _MAX_PATH, szMyAnswerFile))
    {
	    if (*szPlatformString)
        {
            iisDebugOut(_T("[%s] [Version] SetupSKU=%s"), szMyAnswerFile,szPlatformString);

            if (0 == _mbsicmp((const unsigned char *) szPlatformString,(const unsigned char *) "Personal"))
            {
                bReturn = FALSE;
            }
	    }
    }

    if (TRUE == bReturn)
    {
        // check a different key
	    if (GetPrivateProfileString("Version", "SetupPlatform", _T(""), szPlatformString, _MAX_PATH, szMyAnswerFile))
        {
	        if (*szPlatformString)
            {
                iisDebugOut(_T("[%s] [Version] SetupPlatform=%s"), szMyAnswerFile,szPlatformString);

                if (0 == _mbsicmp((const unsigned char *) szPlatformString,(const unsigned char *) "Personal"))
                {
                    bReturn = FALSE;
                }
	        }
        }
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\miginf.h ===
#ifndef MIGINF_H
#define MIGINF_H


#define SECTION_MIGRATIONPATHS  "Migration Paths"
#define SECTION_EXCLUDEDPATHS   "Excluded Paths"
#define SECTION_HANDLED         "Handled"
#define SECTION_MOVED           "Moved"
#define SECTION_INCOMPATIBLE    "Incompatible Messages"


typedef enum {

    MIG_FIRSTTYPE,
    MIG_FILE,
    MIG_PATH,
    MIG_REGKEY,
    MIG_MESSAGE,
    MIG_LASTTYPE

} MIGTYPE, *PMIGTYPE;

typedef struct tagMIGINFSECTIONENUM {

    PCSTR        Key;
    PCSTR        Value;
    PVOID        EnumKey;            // Internal.

} MIGINFSECTIONENUM, * PMIGINFSECTIONENUM;


BOOL IsUpgradeTargetSupportIIS(LPCSTR szMyAnswerFile);

BOOL WINAPI MigInf_Initialize (VOID);
VOID WINAPI MigInf_CleanUp (VOID);
BOOL WINAPI MigInf_PathIsExcluded (IN PCSTR Path);
BOOL WINAPI MigInf_FirstInSection(IN PCSTR SectionName, OUT PMIGINFSECTIONENUM Enum);
BOOL WINAPI MigInf_NextInSection(IN OUT PMIGINFSECTIONENUM Enum);
BOOL WINAPI MigInf_AddObject (IN MIGTYPE ObjectType,IN PCSTR SectionString,IN PCSTR ParamOne,IN PCSTR ParamTwo);
BOOL WINAPI MigInf_WriteInfToDisk (VOID);
PCSTR WINAPI MigInf_GetNewSectionName (VOID);



//
// Macros for common miginf actions.
//

//
// Adding Objects.
//
#define MigInf_AddHandledFile(file)                      MigInf_AddObject(MIG_FILE,SECTION_HANDLED,(file),NULL)
#define MigInf_AddHandledDirectory(directory)            MigInf_AddObject(MIG_PATH,SECTION_HANDLED,(directory),NULL)
#define MigInf_AddHandledRegistry(key,value)             MigInf_AddObject(MIG_REGKEY,SECTION_HANDLED,(key),(value))

#define MigInf_AddMovedFile(from,to)                     MigInf_AddObject(MIG_FILE,SECTION_MOVED,(from),(to))
#define MigInf_AddMovedDirectory(from,to)                MigInf_AddObject(MIG_PATH,SECTION_MOVED,(from),(to))

#define MigInf_AddMessage(msgSection,msg)                MigInf_AddObject(MIG_MESSAGE,SECTION_INCOMPATIBLE,(msgSection),(msg))

#define MigInf_AddMessageFile(msgSection,file)           MigInf_AddObject(MIG_FILE,(msgSection),(file),NULL)
#define MigInf_AddMessageDirectory(msgSection,directory) MigInf_AddObject(MIG_PATH,(msgSection,(directory),NULL)
#define MigInf_AddMessageRegistry(msgSection,key,value)  MigInf_AddObject(MIG_REGKEY,(msgSection),(key),(value))

//
// Enumerating Sections
//
#define MigInf_GetFirstMigrationPath(Enum)               MigInf_FirstInSection(SECTION_MIGRATIONPATHS,(Enum))
#define MigInf_GetFirstExcludedPath(Enum)                MigInf_FirstInSection(SECTION_EXCLUDEDPATHS,(Enum))



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\poolmem.h ===
#ifndef POOLMEM_H
#define POOLMEM_H

typedef LPVOID POOLHANDLE;


#define POOLMEMORYBLOCKSIZE 8192


POOLHANDLE WINAPI PoolMemInitPool ();
VOID       WINAPI PoolMemDestroyPool (IN POOLHANDLE Handle);
LPVOID     WINAPI PoolMemGetAlignedMemory(IN POOLHANDLE Handle, IN DWORD_PTR Size, IN DWORD_PTR AlignSize);


#define PoolMemCreateString(h,x)        ((LPTSTR) PoolMemGetAlignedMemory((h),(x)*sizeof(TCHAR)))
#define PoolMemCreateDword(h)           ((PDWORD) PoolMemGetMemory((h),sizeof(DWORD)))


__inline
LPVOID 
PoolMemGetMemory (
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{

    return PoolMemGetAlignedMemory(Handle,Size,0);

}

__inline
LPTSTR 
PoolMemCreateStringA ( 
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{
    return (LPSTR) PoolMemGetAlignedMemory(Handle,Size * sizeof(CHAR),sizeof(CHAR));
}

__inline
LPWSTR 
PoolMemCreateStringW (
    IN POOLHANDLE Handle,
    IN DWORD      Size
    ) 
{
    return (LPWSTR) PoolMemGetAlignedMemory(Handle,Size * sizeof(WCHAR),sizeof(WCHAR));
}


__inline
PTSTR 
PoolMemDuplicateStringA (
    IN POOLHANDLE    Handle,
    IN LPCSTR       StringToCopy
    )

{
    DWORD_PTR  stringLength;
    PSTR    rString;
    assert(StringToCopy);

    stringLength = strlen(StringToCopy)+1;
    rString      = (PSTR) PoolMemGetAlignedMemory(Handle,
        stringLength,
        sizeof(CHAR));

    if (rString) {
        _mbscpy((unsigned char *) rString, (const unsigned char *) StringToCopy);
    }

    return rString;
}


__inline
PWSTR 
PoolMemDuplicateStringW (
    IN POOLHANDLE    Handle,
    IN LPCWSTR       StringToCopy
    )

{

    
    DWORD    stringLength;
    PWSTR    rString;

    assert(StringToCopy);

    stringLength = ((wcslen(StringToCopy)+1)*sizeof(WCHAR));
    rString      = (PWSTR) PoolMemGetAlignedMemory(Handle,stringLength,sizeof(WCHAR));

    if (rString) {

        wcscpy(rString,StringToCopy);
    }

    return rString;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by migrate.rc
//
#define IDS_PRODUCT_STRING              1
#define IDS_PRODUCT_ID                  1
#define IDS_VERMEER_PWS_1_NOT_SUPPORTED 2
#define IDS_MIGRATION_LOG_FILENAME      4
#define IDS_PWS10_HKLM_REG_TO_MIGRATE   5
#define IDS_PWS40_HKLM_REG_TO_MIGRATE   6
#define IDS_NT5_BETA2_NOT_SUPPORTED     7
#define IDS_TARGET_OS_DOES_NOT_SUPPORT_UPGRADE 8
#define IDS_DEL_LNK_TO_THESE_EXE_FILENAMES 9

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\poolmem.cpp ===
#include "stdafx.h"
 
// Tree Memory Allocation structure.


typedef struct _POOLMEMORYBLOCK POOLMEMORYBLOCK, *PPOOLMEMORYBLOCK;

struct _POOLMEMORYBLOCK {
    DWORD_PTR             Index;
    DWORD_PTR             Size;
    PPOOLMEMORYBLOCK      NextBlock;
    PPOOLMEMORYBLOCK      PrevBlock;
    PBYTE                 RawMemory;  
};

typedef struct _POOLHEADER {
    PPOOLMEMORYBLOCK PoolHead;
    HANDLE           Heap;
} POOLHEADER, *PPOOLHEADER;


BOOL
PoolMemAddMemory (
    IN  POOLHANDLE  Handle,
    IN  DWORD_PTR     Size
    )
{
    PBYTE               allocedMemory;
    PPOOLMEMORYBLOCK    newBlock;
    PPOOLHEADER         poolHeader = (PPOOLHEADER) Handle;
    DWORD_PTR           sizeNeeded;

    assert(poolHeader != NULL);

    //
    // Determine size needed and attempt to allocate memory.
    //
    if (Size + sizeof(POOLMEMORYBLOCK) > POOLMEMORYBLOCKSIZE) {
        sizeNeeded = Size + sizeof(POOLMEMORYBLOCK);
    }
    else {
        sizeNeeded = POOLMEMORYBLOCKSIZE;
    }

    allocedMemory = (unsigned char *) HeapAlloc(poolHeader -> Heap,0,sizeNeeded);

    if (allocedMemory) {

        //
        // Use the beginning of the alloc'ed block as the poolblock structure.
        //
        newBlock                = (PPOOLMEMORYBLOCK) allocedMemory;
        newBlock -> Size        = sizeNeeded - sizeof(POOLMEMORYBLOCK);
        newBlock -> RawMemory   = allocedMemory + sizeof(POOLMEMORYBLOCK);
        newBlock -> Index       = 0;
    
        //
        // Link the block into the list.
        //
        if (poolHeader -> PoolHead) {
            poolHeader -> PoolHead -> PrevBlock = newBlock;
        }
        newBlock   -> NextBlock   = poolHeader -> PoolHead;
        newBlock   -> PrevBlock   = NULL;
        poolHeader -> PoolHead    = newBlock;


    }
    //
    // Assuming allocedMemory is non-NULL, we have succeeded.
    //
    return allocedMemory != NULL;
}


POOLHANDLE
WINAPI
PoolMemInitPool (
    )
{
    BOOL        ableToAddMemory;
    PPOOLHEADER header = NULL;
    HANDLE      procHeap;


    procHeap = GetProcessHeap();
    //
    // Allocate the header of this pool.
    //
    header = (PPOOLHEADER) HeapAlloc(procHeap,0,sizeof(POOLHEADER));

    if (header) {

        //
        // Allocation was successful. Now, initialize the pool.
        //
        header -> PoolHead = NULL;
        header -> Heap = procHeap;

        //
        // Actually add some memory to the pool.
        //
        ableToAddMemory = PoolMemAddMemory(header,0);

        if (!ableToAddMemory) {
            //
            // Unable to add memory to the pool.
            //
            HeapFree(header -> Heap,0,header);
            header = NULL;
        }

    }
    return (POOLHANDLE) header;
}


VOID
WINAPI
PoolMemDestroyPool (
    POOLHANDLE Handle
    )
{
    PPOOLMEMORYBLOCK nextBlock;
    PPOOLMEMORYBLOCK blockToFree; 
    PPOOLHEADER      poolHeader;

    assert(Handle != NULL);

    poolHeader = (PPOOLHEADER) Handle;

    //
    // Walk the list, freeing as we go.
    //
    blockToFree = poolHeader ->  PoolHead;

    while (blockToFree != NULL) {
    
        nextBlock = blockToFree->NextBlock;
        HeapFree(poolHeader -> Heap,0,blockToFree);
        blockToFree = nextBlock;
    }

    //
    // Also, deallocate the poolheader itself.
    //
    HeapFree(poolHeader -> Heap,0,poolHeader);

}

PVOID
WINAPI
PoolMemGetAlignedMemory (
    IN POOLHANDLE Handle,
    IN DWORD_PTR      Size,
    IN DWORD_PTR      AlignSize
    )

{
    BOOL                haveEnoughMemory = TRUE;
    PVOID               rMemory          = NULL;
    PPOOLHEADER         poolHeader       = (PPOOLHEADER) Handle;
    PPOOLMEMORYBLOCK    currentBlock;
    DWORD_PTR           sizeNeeded;
    DWORD_PTR           padLength;

    assert(poolHeader != NULL);

    currentBlock = poolHeader -> PoolHead;

    // Determine if more memory is needed, attempt to add if needed.
    sizeNeeded = Size;

    if (currentBlock -> Size - currentBlock -> Index < sizeNeeded + AlignSize) {

        haveEnoughMemory = PoolMemAddMemory(poolHeader,sizeNeeded + AlignSize);
        currentBlock = poolHeader -> PoolHead;
    }

    // If there is enough memory available, return it.
    if (haveEnoughMemory) {
        if (AlignSize) {

            padLength = (DWORD_PTR) currentBlock + sizeof(POOLMEMORYBLOCK) 
                + currentBlock -> Index;
            currentBlock -> Index += (AlignSize - (padLength % AlignSize)) % AlignSize;

        }
      
         
        //Now, get the address of the memory to return.
        rMemory = (PVOID) 
            &(currentBlock->RawMemory[currentBlock -> Index]);
 
        currentBlock->Index += sizeNeeded;
    }

    return rMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\migrate\stdafx.h ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include <objbase.h>
#include <shellapi.h>

// included for setupapi stuff
#include <setupapi.h>
#include <shlobj.h>
#include <advpub.h>

// for our metabase stuff
#include "iiscnfg.h"

// this module specific
#include "helper.h"
#include "log.h"

// migrate modules
#include <mbstring.h>
#include <tchar.h>
#include <assert.h>
#include "poolmem.h"
#include "miginf.h"

#include "resource.h"
#include "vendinfo.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\sldadd\utils.h ===
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <setupapi.h>

LPSTR  StripWhitespace(LPSTR pszString);
LPWSTR MakeWideStrFromAnsi(UINT uiCodePage, LPSTR psz);
BOOL   IsFileExist(LPCTSTR szFile);
void   AddPath(LPTSTR szPath, LPCTSTR szName);
int    DoesThisSectionExist(IN HINF hFile, IN LPCTSTR szTheSection);
void   DoExpandEnvironmentStrings(LPTSTR szFile);

#define DEBUG_FLAG

#ifdef DEBUG_FLAG
    inline void _cdecl DebugTrace(LPTSTR lpszFormat, ...)
    {
	    int nBuf;
	    TCHAR szBuffer[512];
	    va_list args;
	    va_start(args, lpszFormat);

	    nBuf = _vsntprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	    //ASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	    OutputDebugString(szBuffer);
	    va_end(args);
    }
#else
    inline void _cdecl DebugTrace(LPTSTR , ...){}
#endif

#define IISDebugOutput DebugTrace
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\sldadd\main.cpp ===
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include "utils.h"

// config.ini file should look like this:

// [sld_info]
// Input_Ini_FileName=test.ini
// Input_GUID={E66B49F6-4A35-4246-87E8-5C1A468315B5}
// Input_BuildTypeMask=819
// Input_Inf_FileName=iis.inf
// Input_Inf_CopySections=iis_doc_install
// Input_Inf_SubstitutionSection=inf_dirid_substitutions
// Output_AnsiFileName=sldinfo.txt
//
//[inf_dirid_substitutions]
//32768=%11%\inetsrv
//

/*
<RESOURCE ResTypeVSGUID="{E66B49F6-4A35-4246-87E8-5C1A468315B5}" BuildTypeMask="819" Name="File(819):&quot;%18%\iisHelp\iis\htm\asp&quot;,&quot;IIS_aogu2wab.htm&quot;">
<PROPERTY Name="SrcName" Format="String">IIS_aogu2wab.htm
</PROPERTY>
<PROPERTY Name="DstPath" Format="String">%18%\iisHelp\iis\htm\asp
</PROPERTY>
<PROPERTY Name="DstName" Format="String">IIS_aogu2wab.htm
</PROPERTY>
<PROPERTY Name="NoExpand" Format="Boolean">0
</PROPERTY>
</RESOURCE>
*/

typedef struct _ProcessSLDinfo {
    TCHAR  Input_Ini_FileName[_MAX_PATH];
    TCHAR  Input_GUID[_MAX_PATH];
    TCHAR  Input_BuildTypeMask[_MAX_PATH];
    TCHAR  Input_Inf_FileName[_MAX_PATH];
    TCHAR  Input_Inf_CopySections[_MAX_PATH + _MAX_PATH + _MAX_PATH + _MAX_PATH];
    TCHAR  Input_Inf_SubstitutionSection[_MAX_PATH];
    TCHAR  Output_AnsiFileName[_MAX_PATH];
    HINF   hFileInf;
    HANDLE hFileOutput;
} ProcessSLDinfo;

#define INIFILE_SECTION _T("SLD_INFO")

void ShowHelp(void);
int  ProcessParamFile(TCHAR *szFileName);
int  FillStructure(ProcessSLDinfo * MyInfo,TCHAR *szFileName);
int  ParseCommaDelimitedSectionDoSection(ProcessSLDinfo * MyInfo, LPTSTR szLine);
int  ProcessThisCopyFileSection(ProcessSLDinfo * MyInfo, LPTSTR szLine);
int  ParseCommaDelimitedSectionAndDoStuff(ProcessSLDinfo * MyInfo,LPTSTR szLine);
int  DoStuffWithThisSection(ProcessSLDinfo * MyInfo,LPTSTR szLine);
int  SearchThruKnownSectionForThisSection(ProcessSLDinfo * MyInfo, IN LPTSTR szSectionToMatch,OUT LPTSTR szReturnedDirInfo);
int  GimmieSubstituteNumber(ProcessSLDinfo * MyInfo, TCHAR * szOldNum, TCHAR * szReturnedString);
int  AppendToFile(HANDLE hFileOutput, TCHAR * szStringToAppend);


//***************************************************************************
//*                                                                         
//* purpose: main
//*
//***************************************************************************
int __cdecl  main(int argc,char *argv[])
{
    int iRet = 0;
    int argno;
	char * pArg = NULL;
	char * pCmdStart = NULL;
    TCHAR szFilePath1[_MAX_PATH];
    TCHAR szFilePath2[_MAX_PATH];
    TCHAR szParamString_C[_MAX_PATH];

    int iDo_A = FALSE;
    int iDo_B = FALSE;
    int iDoVersion = FALSE;
    int iGotParamC = FALSE;

    *szFilePath1 = '\0';
    *szFilePath2 = '\0';
    *szParamString_C = '\0';
    _tcscpy(szFilePath1,_T(""));
    _tcscpy(szFilePath2,_T(""));
    _tcscpy(szParamString_C,_T(""));
    
    for(argno=1; argno<argc; argno++) 
    {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' ) 
        {
            switch (argv[argno][1]) 
            {
                case 'a':
                case 'A':
                    iDo_A = TRUE;
                    break;
                case 'b':
                case 'B':
                    iDo_B = TRUE;
                    break;
                case 'v':
                case 'V':
                    iDoVersion = TRUE;
                    break;
                case 'c':
                case 'C':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') 
                    {
                        char szTempString[_MAX_PATH];

						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') 
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else 
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
#if defined(UNICODE) || defined(_UNICODE)
						MultiByteToWideChar(CP_ACP, 0, szTempString, -1, (LPWSTR) szParamString_C, _MAX_PATH);
#else
                        _tcscpy(szParamString_C,szTempString);
#endif

                        iGotParamC = TRUE;
					}
                    break;
                case '?':
                    goto main_exit_with_help;
                    break;
            }
        }
        else 
        {
            if (_tcsicmp(szFilePath1, _T("")) == 0)
            {
                // if no arguments, then get the filename portion
#if defined(UNICODE) || defined(_UNICODE)
                MultiByteToWideChar(CP_ACP, 0, argv[argno], -1, (LPTSTR) szFilePath1, _MAX_PATH);
#else
                _tcscpy(szFilePath1,argv[argno]);
#endif
            }
            else
            {
                if (_tcsicmp(szFilePath2, _T("")) == 0)
                {
                    // if no arguments, then get the filename portion
#if defined(UNICODE) || defined(_UNICODE)
                    MultiByteToWideChar(CP_ACP, 0, argv[argno], -1, (LPTSTR) szFilePath2, _MAX_PATH);
#else
                    _tcscpy(szFilePath2,argv[argno]);
#endif
                }
            }
        }
    }

    //
    // Check what were supposed to do
    //
    if (TRUE == iDo_A || (FALSE == iDo_A && FALSE == iDo_B) )
    {
        // check for required parameters
        if (_tcsicmp(szFilePath1, _T("")) == 0)
        {
            _tprintf(_T("[-z] parameter missing filename1 parameter\n"));
            goto main_exit_with_help;
        }

        // call the function.
        iRet = ProcessParamFile(szFilePath1);
        if (FALSE == iRet)
        {
            iRet = 1;
        }
        else
        {
            iRet = 0;
        }
    }

    if (iDo_B)
    {
        // do stuff
    }

    if (TRUE == iDoVersion)
    {
        // output the version
        _tprintf(_T("1\n\n"));

        iRet = 10;
        goto main_exit_gracefully;
    }

    if (_tcsicmp(szFilePath1, _T("")) == 0)
    {
        goto main_exit_with_help;
    }

    goto main_exit_gracefully;
  
main_exit_gracefully:
    exit(iRet);

main_exit_with_help:
    ShowHelp();
    exit(iRet);
}


//***************************************************************************
//*                                                                         
//* purpose: ?
//*
//***************************************************************************
void ShowHelp(void)
{
	TCHAR szModuleName[_MAX_PATH];
	TCHAR szFilename_only[_MAX_PATH];

    // get the modules full pathed filename
	if (0 != GetModuleFileName(NULL,(LPTSTR) szModuleName,_MAX_PATH))
    {
	    // Trim off the filename only.
	    _tsplitpath(szModuleName, NULL, NULL, szFilename_only, NULL);
   
        _tprintf(_T("Unicode File Utility\n\n"));
        _tprintf(_T("%s [-a] [-v] [-c:otherinfo] [drive:][path]filename1 [drive:][path]filename2\n\n"),szFilename_only);
        _tprintf(_T("[-a] paramter -- do stuff:\n"));
        _tprintf(_T("   -a           required parameter for this functionality\n"));
        _tprintf(_T("   filename1    .ini file which controls what program should do\n"));
        _tprintf(_T("\n"));
        _tprintf(_T("Examples:\n"));
        _tprintf(_T("%s -a c:\\MyFileAnsi.ini\n"),szFilename_only);
    }
    return;
}


int FillStructure(ProcessSLDinfo * MyInfo, TCHAR *szFileName)
{
	int iReturn = FALSE;
    TCHAR buf[_MAX_PATH];
    _tcscpy(buf,_T(""));

	if (IsFileExist(szFileName) != TRUE) 
	{
        goto FillStructure_Exit;
	}

    // Input_GUID={E66B49F6-4A35-4246-87E8-5C1A468315B5}
    // Input_BuildTypeMask=819
    // Input_Inf_FileName=iis.inf
    // Input_Inf_CopySections=iis_doc_install
    // Input_Inf_SubstitutionSection=inf_dirid_substitutions
    // Output_AnsiFileName=sldinfo.txt

    _tcscpy(MyInfo->Input_Ini_FileName,szFileName);

	GetPrivateProfileString(INIFILE_SECTION, _T("Input_GUID"), _T(""), buf, _MAX_PATH, szFileName);
	if (NULL == *buf) 
    {
        _tprintf(_T("Entry missing:Input_GUID\n"),buf);
        goto FillStructure_Exit;
    }

    _tcscpy(MyInfo->Input_GUID,buf);
   
	GetPrivateProfileString(INIFILE_SECTION, _T("Input_BuildTypeMask"), _T(""), buf, _MAX_PATH, szFileName);
	if (NULL == *buf) 
    {
        _tprintf(_T("Entry missing:Input_BuildTypeMask\n"),buf);
        goto FillStructure_Exit;
    }
    _tcscpy(MyInfo->Input_BuildTypeMask,buf);

	GetPrivateProfileString(INIFILE_SECTION, _T("Input_Inf_FileName"), _T(""), buf, _MAX_PATH, szFileName);
	if (NULL == *buf) 
    {
        _tprintf(_T("Entry missing:Input_Inf_FileName\n"),buf);
        goto FillStructure_Exit;
    }
    else
    {
        DoExpandEnvironmentStrings(buf);
    }
    _tcscpy(MyInfo->Input_Inf_FileName,buf);

	GetPrivateProfileString(INIFILE_SECTION, _T("Input_Inf_CopySections"), _T(""), buf, _MAX_PATH, szFileName);
	if (NULL == *buf) 
    {
        _tprintf(_T("Entry missing:Input_Inf_CopySections\n"),buf);
        goto FillStructure_Exit;
    }
    _tcscpy(MyInfo->Input_Inf_CopySections,buf);

	GetPrivateProfileString(INIFILE_SECTION, _T("Input_Inf_SubstitutionSection"), _T(""), buf, _MAX_PATH, szFileName);
	if (NULL == *buf) 
    {
        _tprintf(_T("Entry missing:Input_Inf_SubstitutionSection\n"),buf);
        goto FillStructure_Exit;
    }
    _tcscpy(MyInfo->Input_Inf_SubstitutionSection,buf);

	GetPrivateProfileString(INIFILE_SECTION, _T("Output_AnsiFileName"), _T(""), buf, _MAX_PATH, szFileName);
	if (NULL == *buf) 
    {
        _tprintf(_T("Entry missing:Output_AnsiFileName\n"),buf);
        goto FillStructure_Exit;
    }
    _tcscpy(MyInfo->Output_AnsiFileName,buf);

    iReturn = TRUE;

FillStructure_Exit:
	return iReturn;
}


int ProcessParamFile(TCHAR *szFileName)
{
    int iReturn = FALSE;
    ProcessSLDinfo MyInfo;
    LPTSTR pch = NULL;
    _tprintf(_T("ProcessParamFile:Start\n"));


    // Check if there is a "\" in there.(since GetPrivateProfileString needs a fully qualified path)
    pch = _tcschr(szFileName, _T('\\'));
	if (!pch || IsFileExist(szFileName) != TRUE) 
	{
        TCHAR szCurrentDir[_MAX_PATH];
        GetCurrentDirectory( _MAX_PATH, szCurrentDir);
        SetCurrentDirectory(szCurrentDir);
        AddPath(szCurrentDir,szFileName);

        _tcscpy(szFileName,szCurrentDir);
        if (IsFileExist(szFileName) != TRUE) 
        {
            _tprintf(_T("File %s, not found\n"),szFileName);
            goto ProcessParamFile_Exit;
        }
	}

    // open the ini file
    // and set all the parameters
    iReturn = FillStructure(&MyInfo,szFileName);
    if (FALSE == iReturn)
    {
        _tprintf(_T("Missing required parameters from %s file\n"),szFileName);
        goto ProcessParamFile_Exit;
    }

    // check if the inf filename exists....
    if (IsFileExist(MyInfo.Input_Inf_FileName) != TRUE) 
    {
        _tprintf(_T("File %s, not found\n"),MyInfo.Input_Inf_FileName);
        goto ProcessParamFile_Exit;
    }

    _tprintf(_T("ProcessParamFile:ini=%s\n"),MyInfo.Input_Ini_FileName);
    _tprintf(_T("ProcessParamFile:inf=%s\n"),MyInfo.Input_Inf_FileName);
    _tprintf(_T("ProcessParamFile:output=%s\n"),MyInfo.Output_AnsiFileName);

    // Open the .inf file 
    // and look for the specified section
    // Get a handle to it.
    MyInfo.hFileInf = SetupOpenInfFile(MyInfo.Input_Inf_FileName, NULL, INF_STYLE_WIN4, NULL);
    if(MyInfo.hFileInf == INVALID_HANDLE_VALUE) 
    {
        _tprintf(_T("err opening file %s\n"),MyInfo.Input_Inf_FileName);
        goto ProcessParamFile_Exit;
    }

    //
    // okay now do the work for ONE copyfile section
    //

    // open the output file
    // Create a new unicode file
    MyInfo.hFileOutput = INVALID_HANDLE_VALUE;
    MyInfo.hFileOutput = CreateFile((LPCTSTR) MyInfo.Output_AnsiFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if( MyInfo.hFileOutput == INVALID_HANDLE_VALUE)
    {
        _tprintf(_T("Failure to create file %s\n"),MyInfo.Output_AnsiFileName);
        goto ProcessParamFile_Exit;
    }

    // open list of copyfiles sections to get list of sections that we need to do....
    ParseCommaDelimitedSectionDoSection(&MyInfo,MyInfo.Input_Inf_CopySections);

    iReturn = TRUE;

ProcessParamFile_Exit:

    if (INVALID_HANDLE_VALUE != MyInfo.hFileOutput)
        {CloseHandle(MyInfo.hFileOutput);MyInfo.hFileOutput = INVALID_HANDLE_VALUE;}

    if (INVALID_HANDLE_VALUE != MyInfo.hFileInf)
        {SetupCloseInfFile(MyInfo.hFileInf);MyInfo.hFileInf = INVALID_HANDLE_VALUE;}

    if (TRUE == iReturn)
    {
        _tprintf(_T("ProcessParamFile:Success! File=%s\n"),MyInfo.Output_AnsiFileName);
    }
    else
    {
        _tprintf(_T("ProcessParamFile:End FAILED\n"));
    }

    return iReturn;
}


// input is something like this:
//    iisdoc_files_common_default,iisdoc_files_common_htmldocs,iisdoc_files_common_admsampdocs,etc...
// so we need to strtok thru this and act on every section that we process...
//
int ParseCommaDelimitedSectionDoSection(ProcessSLDinfo * MyInfo, LPTSTR szLine)
{
    int iReturn = FALSE;

    TCHAR *token = NULL;
    token = _tcstok(szLine, _T(","));
    while (token != NULL)
    {
        ProcessThisCopyFileSection(MyInfo,token);
        token = _tcstok(NULL, _T(","));
    }

    return iReturn;
}

int ProcessThisCopyFileSection(ProcessSLDinfo * MyInfo, LPTSTR szTheSection)
{
    int iReturn = FALSE;
    BOOL bFlag = FALSE;
    INFCONTEXT Context;
    DWORD dwRequiredSize = 0;
    LPTSTR szLine = NULL;

    if (FALSE == DoesThisSectionExist(MyInfo->hFileInf,szTheSection))
    {
        _tprintf(_T("section %s, doesn't exist in %s\n"),szTheSection,MyInfo->Input_Inf_FileName);
        goto ProcessThisCopyFileSection_Exit;
    }

    // go to the beginning of the section in the INF file
    bFlag = SetupFindFirstLine(MyInfo->hFileInf,szTheSection, NULL, &Context);
    if (!bFlag)
    {
        goto ProcessThisCopyFileSection_Exit;
    }

    // loop through the items in the section.
    while (bFlag) 
    {
        // get the size of the memory we need for this
        bFlag = SetupGetLineText(&Context, NULL, NULL, NULL, NULL, 0, &dwRequiredSize);

        // prepare the buffer to receive the line
        szLine = (LPTSTR)GlobalAlloc( GPTR, dwRequiredSize * sizeof(TCHAR) );
        if ( !szLine )
            {
            _tprintf(_T("Failure to get memory\n"));
            goto ProcessThisCopyFileSection_Exit;
            }
        
        // get the line from the inf file1
        if (SetupGetLineText(&Context, NULL, NULL, NULL, szLine, dwRequiredSize, NULL) == FALSE)
            {
            _tprintf(_T("SetupGetLineText Failed\n"));
            goto ProcessThisCopyFileSection_Exit;
            }

        //print it out.

        // should come back as:
        // one big line...
        //iisdoc_files_common_default,iisdoc_files_common_htmldocs,iisdoc_files_common_admsampdocs,etc...

        // For each of these entries
        // do something
        ParseCommaDelimitedSectionAndDoStuff(MyInfo,szLine);

        // find the next line in the section. If there is no next line it should return false
        bFlag = SetupFindNextLine(&Context, &Context);

        // free the temporary buffer
        if (szLine) {GlobalFree(szLine);}
        szLine = NULL;
        iReturn = TRUE;
    }

ProcessThisCopyFileSection_Exit:
    if (szLine) {GlobalFree(szLine);szLine=NULL;}
    return iReturn;
}


// input is something like this:
//    iisdoc_files_common_default,iisdoc_files_common_htmldocs,iisdoc_files_common_admsampdocs,etc...
// so we need to strtok thru this and act on every section that we process...
//
int ParseCommaDelimitedSectionAndDoStuff(ProcessSLDinfo * MyInfo, LPTSTR szLine)
{
    int iReturn = FALSE;

    TCHAR *token = NULL;
    token = _tcstok(szLine, _T(","));
    while (token != NULL)
    {
        DoStuffWithThisSection(MyInfo,token);
        token = _tcstok(NULL, _T(","));
    }

    return iReturn;
}

int SearchThruKnownSectionForThisSection(ProcessSLDinfo * MyInfo, IN LPTSTR szSectionToMatch,OUT LPTSTR szReturnedDirInfo)
{
    int iReturn = FALSE;
    INFCONTEXT Context;
    BOOL bFlag = FALSE;
    DWORD dwRequiredSize = 0;
    TCHAR szTempString1[_MAX_PATH] = _T("");
    TCHAR szTempString2[_MAX_PATH] = _T("");
    DWORD dwTemp = 0;

    //[DestinationDirs]
    //iisdoc_files_common = 18, iisHelp\common
    //iisdoc_files_fonts = 20
    //iisdoc_files_common_default = 18, iisHelp
    // go to the beginning of the section in the INF file

    bFlag = SetupFindFirstLine(MyInfo->hFileInf,_T("DestinationDirs"), szSectionToMatch, &Context);
    if (!bFlag)
    {
        goto SearchThruKnownSectionForThisSection_Exit;
    }

    if (!SetupGetStringField(&Context, 1, szTempString1, _MAX_PATH, NULL))
    {
        goto SearchThruKnownSectionForThisSection_Exit;
    }

    // This string will come back something like
    //-01,0xffff The directory from which the INF was installed. 
    //01 SourceDrive:\path. 
    //10 Windows directory. 
    //11 System directory. (%windir%\system on Windows 95, %windir%\system32 on Windows NT) 
    //12 Drivers directory.(%windir%\system32\drivers on Windows NT) 
    //17 INF file directory. 
    //18 Help directory. 
    //20 Fonts directory. 
    //21 Viewers directory. 
    //24 Applications directory. 
    //25 Shared directory. 
    //30 Root directory of the boot drive. 
    //50 %windir%\system 
    //51 Spool directory. 
    //52 Spool drivers directory. 
    //53 User Profile directory. 
    //54 Path to ntldr or OSLOADER.EXE 

    // if it's larger than 100 we probably don't know what it is
    // and it's probably been user defined
    _tcscpy(szReturnedDirInfo,szTempString1);
    dwTemp = _ttoi((LPCTSTR) szReturnedDirInfo);
    if (dwTemp >= 100)
    {
        if (FALSE == GimmieSubstituteNumber(MyInfo,szTempString1,szReturnedDirInfo))
        {
            // Failed to lookup number!
            _tprintf(_T("Failed find substitute for [%s] in section [%s] in file %s\n"),szTempString1,MyInfo->Input_Inf_SubstitutionSection,MyInfo->Input_Inf_FileName);
        }
    }
    else
    {
        _tcscpy(szReturnedDirInfo,_T("%"));
        _tcscat(szReturnedDirInfo,szTempString1);
        _tcscat(szReturnedDirInfo,_T("%"));
    }

    if (TRUE == SetupGetStringField(&Context, 2, szTempString2, _MAX_PATH, NULL))
    {
        _tcscat(szReturnedDirInfo,_T("\\"));
        _tcscat(szReturnedDirInfo,szTempString2);
    }

    iReturn = TRUE;

SearchThruKnownSectionForThisSection_Exit:
    return iReturn;
}

int GimmieSubstituteNumber(ProcessSLDinfo * MyInfo, TCHAR * szOldNum, TCHAR * szReturnedString)
{
    int iReturn = FALSE;
    BOOL bFlag = FALSE;
    INFCONTEXT Context;
    TCHAR szTempString[_MAX_PATH] = _T("");
    TCHAR szSectionToMatch[_MAX_PATH];
    HINF  hFileInfTemporary;
    _tcscpy(szTempString,_T(""));

    _tcscpy(szReturnedString, _T("%"));
    _tcscat(szReturnedString, szOldNum);
    _tcscat(szReturnedString, _T("%"));

	GetPrivateProfileString(MyInfo->Input_Inf_SubstitutionSection, szOldNum, _T(""), szTempString, _MAX_PATH, MyInfo->Input_Ini_FileName);
	if (NULL == *szTempString) 
    {
        iReturn = FALSE;
        goto GimmieSubstituteNumber_Exit;
    }
    else
    {
        _tcscpy(szReturnedString, szTempString);
    }
    iReturn = TRUE;

GimmieSubstituteNumber_Exit:
    return iReturn;
}

int DoStuffWithThisSection(ProcessSLDinfo * MyInfo, LPTSTR szInputLine)
{
    int iReturn = FALSE;
    BOOL bFlag = FALSE;
    TCHAR szReturnedDirInfo[_MAX_PATH];
    TCHAR szBigString[1000];
    TCHAR szFileName1[_MAX_PATH];
    DWORD dwRequiredSize = 0;
    INFCONTEXT Context;
    LPTSTR szLine = NULL;
    TCHAR szFileName[_MAX_PATH] = _T("");
    TCHAR szFileNameRename[_MAX_PATH] = _T("");
    
    if (FALSE == SearchThruKnownSectionForThisSection(MyInfo,szInputLine,szReturnedDirInfo))
    {
        goto DoStuffWithThisSection_Exit;
    }

    // Get the filename

    // go to the beginning of the section in the INF file
    bFlag = SetupFindFirstLine(MyInfo->hFileInf,szInputLine, NULL, &Context);
    if (!bFlag)
    {
        _tprintf(_T("Failed to find section for [%s] in %s\n"),szInputLine,MyInfo->Input_Inf_FileName);
        goto DoStuffWithThisSection_Exit;
    }
    while (bFlag) 
    {
        if (!SetupGetStringField(&Context, 1, szFileName, _MAX_PATH, NULL))
        {
            break;
        }

        // see if there is a rename to field.
        _tcscpy(szFileNameRename, _T(""));
        _tcscpy(szFileNameRename, szFileName);
        SetupGetStringField(&Context, 2, szFileNameRename, _MAX_PATH, NULL);

        // Output this stuff an ansi file.
        /*
        <RESOURCE ResTypeVSGUID="{E66B49F6-4A35-4246-87E8-5C1A468315B5}" BuildTypeMask="819" Name="File(819):&quot;%18%\iisHelp\iis\htm\adminsamples&quot;,&quot;contftp.htm&quot;">
        <PROPERTY Name="SrcName" Format="String">IIS_contftp.htm</PROPERTY>
        <PROPERTY Name="DstPath" Format="String">%18%\iisHelp\iis\htm\adminsamples</PROPERTY>
        <PROPERTY Name="DstName" Format="String">contftp.htm</PROPERTY>
        <PROPERTY Name="NoExpand" Format="Boolean">0</PROPERTY>
        </RESOURCE>
        */

        // --------------------
        // Do RESOURCE END
        // --------------------
        _stprintf(szBigString, _T("<RESOURCE ResTypeVSGUID=\"%s\" BuildTypeMask=\"%s\" Name=\"File(%s):&quot;%s&quot;,&quot;%s&quot;\">"),
            MyInfo->Input_GUID,
            MyInfo->Input_BuildTypeMask,
            MyInfo->Input_BuildTypeMask,
            szReturnedDirInfo,
            szFileName);
        AppendToFile(MyInfo->hFileOutput, szBigString);

        // --------------------
        // Do SRCNAME PROPERTY
        // --------------------
        _stprintf(szBigString, _T("<PROPERTY Name=\"SrcName\" Format=\"String\">%s</PROPERTY>"),szFileNameRename);
        AppendToFile(MyInfo->hFileOutput, szBigString);

        // --------------------
        // Do DSTPATH PROPERTY
        // --------------------
        _stprintf(szBigString, _T("<PROPERTY Name=\"DstPath\" Format=\"String\">%s</PROPERTY>"),szReturnedDirInfo);
        AppendToFile(MyInfo->hFileOutput, szBigString);

        // --------------------
        // Do DSTNAME PROPERTY
        // --------------------
        _stprintf(szBigString, _T("<PROPERTY Name=\"DstName\" Format=\"String\">%s</PROPERTY>"),szFileName);
        AppendToFile(MyInfo->hFileOutput, szBigString);

        // --------------------
        // Do NOEXPAND PROPERTY
        // --------------------
        _stprintf(szBigString, _T("<PROPERTY Name=\"NoExpand\" Format=\"Boolean\">0</PROPERTY>"));
        AppendToFile(MyInfo->hFileOutput, szBigString);

        // --------------------
        // Do RESOURCE END
        // --------------------
        _stprintf(szBigString, _T("</RESOURCE>"));
        AppendToFile(MyInfo->hFileOutput, szBigString);

        // find the next line in the section. If there is no next line it should return false
        bFlag = SetupFindNextLine(&Context, &Context);
    }

   
    iReturn = TRUE;

DoStuffWithThisSection_Exit:
    return iReturn;
}

int AppendToFile(HANDLE hFileOutput, TCHAR * szStringToAppend)
{
    int iReturn = FALSE;
    DWORD dwBytesWritten = 0;

    if (hFileOutput)
    {
        if (WriteFile(hFileOutput,szStringToAppend,_tcslen(szStringToAppend),&dwBytesWritten,NULL))
        {
            iReturn = TRUE;
        }
        else
        {
            _tprintf(_T("WriteFile FAILED:err=0x%x\n"),GetLastError());
        }
    }

    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\sldadd\utils.cpp ===
#include "utils.h"

//***************************************************************************
//*                                                                         
//* purpose: 
//*
//***************************************************************************
LPSTR StripWhitespace( LPSTR pszString )
{
    LPSTR pszTemp = NULL;

    if ( pszString == NULL ) 
    {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) 
    {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) 
    {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenA(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) 
    {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}


//***************************************************************************
//*                                                                         
//* purpose: return back a Alocated wide string from a ansi string
//*          caller must free the returned back pointer with GlobalFree()
//*
//***************************************************************************
LPWSTR MakeWideStrFromAnsi(UINT uiCodePage, LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    // make sure they gave us something
    if (!psz)
    {
        return NULL;
    }

    // compute the length
    i =  MultiByteToWideChar(uiCodePage, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate memory in that length
    pwsz = (LPWSTR) GlobalAlloc(GPTR,i * sizeof(WCHAR));
    if (!pwsz) return NULL;

    // clear out memory
    memset(pwsz, 0, wcslen(pwsz) * sizeof(WCHAR));

    // convert the ansi string into unicode
    i =  MultiByteToWideChar(uiCodePage, 0, (LPSTR) psz, -1, pwsz, i);
    if (i <= 0) 
        {
        GlobalFree(pwsz);
        pwsz = NULL;
        return NULL;
        }

    // make sure ends with null
    pwsz[i - 1] = 0;

    // return the pointer
    return pwsz;
}


BOOL IsFileExist(LPCTSTR szFile)
{
    // Check if the file has expandable Environment strings
    LPTSTR pch = NULL;
    pch = _tcschr( (LPTSTR) szFile, _T('%'));
    if (pch) 
    {
        TCHAR szValue[_MAX_PATH];
        _tcscpy(szValue,szFile);
        if (!ExpandEnvironmentStrings( (LPCTSTR)szFile, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {_tcscpy(szValue,szFile);}

        return (GetFileAttributes(szValue) != 0xFFFFFFFF);
    }
    else
    {
        return (GetFileAttributes(szFile) != 0xFFFFFFFF);
    }
}


void AddPath(LPTSTR szPath, LPCTSTR szName )
{
	LPTSTR p = szPath;

    // Find end of the string
    while (*p){p = _tcsinc(p);}
	
	// If no trailing backslash then add one
    if (*(_tcsdec(szPath, p)) != _T('\\'))
		{_tcscat(szPath, _T("\\"));}
	
	// if there are spaces precluding szName, then skip
    while ( *szName == ' ' ) szName = _tcsinc(szName);;

	// Add new name to existing path string
	_tcscat(szPath, szName);
}



int DoesThisSectionExist(IN HINF hFile, IN LPCTSTR szTheSection)
{
    int iReturn = FALSE;

    INFCONTEXT Context;

    // go to the beginning of the section in the INF file
    if (SetupFindFirstLine(hFile, szTheSection, NULL, &Context))
        {iReturn = TRUE;}

    return iReturn;
}

void DoExpandEnvironmentStrings(LPTSTR szFile)
{
    TCHAR szValue[_MAX_PATH];
    _tcscpy(szValue,szFile);
    // Check if the file has expandable Environment strings
    LPTSTR pch = NULL;
    pch = _tcschr( (LPTSTR) szFile, _T('%'));
    if (pch) 
    {
        if (!ExpandEnvironmentStrings( (LPCTSTR)szFile, szValue, sizeof(szValue)/sizeof(TCHAR)))
            {
            _tcscpy(szValue,szFile);
            }
    }
    _tcscpy(szFile,szValue);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\abadmin.h ===
#ifndef _ABADMIN_H_
#define _ABADMIN_H_


#include <abtype.h>
#include <abook.h>


#define ROW_RETURNED(pabe) ((pabe)->cRowReturned)
#define ROW_MATCHED(pabe)  ((pabe)->cRowMatched)

// Error message, implemented in abget.cpp
ABEXPDLLCPP ABRETC ABCALLCONV AbGetErrorString(ABRETC abrc, LPSTR lpBuf, DWORD cbBufSize);

// Persistent domain, implemented in abdomain.cpp
ABEXPDLLCPP ABRETC ABCALLCONV AbAddPersistentDomain(HANDLE hAbook, LPSTR szDomainName, BOOL fLocal);
ABEXPDLLCPP ABRETC ABCALLCONV AbDeletePersistentDomain(HANDLE hAbook, LPSTR szDomainName);

// Get APIs
ABEXPDLLCPP ABRETC ABCALLCONV AbGetAbinfoFromEmail(HANDLE hAbook, LPSTR szEmail, LPVOID pvBuf, LPDWORD pcbBuf);
ABEXPDLLCPP ABRETC ABCALLCONV AbGetAbinfoFromAbiid(HANDLE hAbook, ABIID abiid,  LPVOID pvBuf, LPDWORD pcbBuf);

// Resolve, GetList and Enum APIs
ABEXPDLLCPP ABRETC ABCALLCONV AbResolveDLMembers(HANDLE hAbook, HACCT hAcct, PABENUM pabEnum, BOOL fForward, LPSTR szMemberName, ABIID abiidDL);
ABEXPDLLCPP ABRETC ABCALLCONV AbMatchSimilarName(HANDLE hAbook, HACCT hAcct, PABENUM pabEnum, BOOL fForward, LPSTR szLoginName, ABTSF abtsf);
ABEXPDLLCPP ABRETC ABCALLCONV AbGetServerList(HANDLE hAbook, HACCT hAcct, PABENUM pabEnum);
ABEXPDLLCPP ABRETC ABCALLCONV AbGetDomainList(HANDLE hAbook, HACCT hAcct, PABENUM pabEnum);

// Enum
ABEXPDLLCPP ABRETC ABCALLCONV AbGetNextEnumResult(HANDLE hAbook, PABENUM pabEnum, LPVOID pvBuf, LPDWORD pcbBuf);
ABEXPDLLCPP ABRETC ABCALLCONV AbEndEnumResult(HANDLE hAbook, PABENUM pabEnum);

// User, implemented in abacct.cpp
ABEXPDLLCPP ABRETC ABCALLCONV AbCreateUser(HANDLE hAbook, LPSTR szEmail, LPSTR szForward, BOOL fLocalUser, LPSTR szVRoot, DWORD cbMailboxMax, DWORD cbMailboxMessageMax);
ABEXPDLLCPP ABRETC ABCALLCONV AbDeleteUser(HANDLE hAbook, LPSTR szEmail);
ABEXPDLLCPP ABRETC ABCALLCONV AbSetForward(HANDLE hAbook, LPSTR szEmail, LPSTR szForward);
ABEXPDLLCPP ABRETC ABCALLCONV AbSetMailboxSize(HANDLE hAbook, LPSTR szEmail, DWORD cbMailboxMax);
ABEXPDLLCPP ABRETC ABCALLCONV AbSetMailboxMessageSize(HANDLE hAbook, LPSTR szEmail, DWORD cbMailboxMessageMax);
ABEXPDLLCPP ABRETC ABCALLCONV AbSetMailRoot(HANDLE hAbook, LPSTR szEmail, LPSTR szVRoot);

// DL, implemented in abdl.cpp
ABEXPDLLCPP ABRETC ABCALLCONV AbCreateDL(HANDLE hAbook, LPSTR szEmail, DWORD dwType);
ABEXPDLLCPP ABRETC ABCALLCONV AbDeleteDL(HANDLE hAbook, LPSTR szEmail);
ABEXPDLLCPP ABRETC ABCALLCONV AbCreateDLMember(HANDLE hAbook, LPSTR szEmail, LPSTR szMember);
ABEXPDLLCPP ABRETC ABCALLCONV AbDeleteDLMember(HANDLE hAbook, LPSTR szEmail, LPSTR szMember);
ABEXPDLLCPP ABRETC ABCALLCONV AbSetDLToken(HANDLE hAbook, LPSTR szEmail, DWORD dwToken);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\testexe\main.cpp ===
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

void   ShowHelp(void);
LPSTR  StripWhitespace(LPSTR pszString);
LPWSTR MakeWideStrFromAnsi(UINT uiCodePage, LPSTR psz);
void   CheckForFullAccess(void);

//***************************************************************************
//*                                                                         
//* purpose: main
//*
//***************************************************************************
int __cdecl  main(int argc,char *argv[])
{
    int iRet = 0;
    int argno;
	char * pArg = NULL;
	char * pCmdStart = NULL;
    TCHAR szFilePath1[_MAX_PATH];
    TCHAR szFilePath2[_MAX_PATH];
    TCHAR szParamString_C[_MAX_PATH];

    int iDo_A         = FALSE;
    int iDo_B       = FALSE;
    int iDo_C = FALSE;
    int iDo_D = FALSE;
    int iGotParamE = FALSE;

    *szFilePath1 = '\0';
    *szFilePath2 = '\0';
    *szParamString_C = '\0';
    _tcscpy(szFilePath1,_T(""));
    _tcscpy(szFilePath2,_T(""));
    _tcscpy(szParamString_C,_T(""));
    
    for(argno=1; argno<argc; argno++) 
    {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' ) 
        {
            switch (argv[argno][1]) 
            {
                case 'a':
                case 'A':
                    iDo_A = TRUE;
                    break;
                case 'b':
                case 'B':
                    iDo_B = TRUE;
                    break;
                case 'c':
                case 'C':
                    iDo_C = TRUE;
                    break;
                case 'd':
                case 'D':
                    iDo_D = TRUE;
                    break;
                case 'e':
                case 'E':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') 
                    {
                        char szTempString[_MAX_PATH];

						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') 
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else 
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
#if defined(UNICODE) || defined(_UNICODE)
						MultiByteToWideChar(CP_ACP, 0, szTempString, -1, (LPWSTR) szParamString_C, _MAX_PATH);
#else
                        _tcscpy(szParamString_C,szTempString);
#endif

                        iGotParamE = TRUE;
					}
                    break;
                case '?':
                    goto main_exit_with_help;
                    break;
            }
        }
        else 
        {
            if (_tcsicmp(szFilePath1, _T("")) == 0)
            {
                // if no arguments, then get the filename portion
#if defined(UNICODE) || defined(_UNICODE)
                MultiByteToWideChar(CP_ACP, 0, argv[argno], -1, (LPTSTR) szFilePath1, _MAX_PATH);
#else
                _tcscpy(szFilePath1,argv[argno]);
#endif
            }
            else
            {
                if (_tcsicmp(szFilePath2, _T("")) == 0)
                {
                    // if no arguments, then get the filename portion
#if defined(UNICODE) || defined(_UNICODE)
                    MultiByteToWideChar(CP_ACP, 0, argv[argno], -1, (LPTSTR) szFilePath2, _MAX_PATH);
#else
                    _tcscpy(szFilePath2,argv[argno]);
#endif
                }
            }
        }
    }

    //
    // Check what were supposed to do
    //
    if (TRUE == iDo_A)
    {
        // Check if we have access
        CheckForFullAccess();
        goto main_exit_gracefully;
    }

    if (_tcsicmp(szFilePath1, _T("")) == 0)
    {
        goto main_exit_with_help;
    }

    goto main_exit_gracefully;
  
main_exit_gracefully:
    exit(iRet);

main_exit_with_help:
    ShowHelp();
    exit(iRet);
}


//***************************************************************************
//*                                                                         
//* purpose: ?
//*
//***************************************************************************
void ShowHelp(void)
{
	TCHAR szModuleName[_MAX_PATH];
	TCHAR szFilename_only[_MAX_PATH];

    // get the modules full pathed filename
	if (0 != GetModuleFileName(NULL,(LPTSTR) szModuleName,_MAX_PATH))
    {
	    // Trim off the filename only.
	    _tsplitpath(szModuleName, NULL, NULL, szFilename_only, NULL);
   
        _tprintf(_T("Testing Utility\n\n"));
        _tprintf(_T("%s [-a] [-b] [-c] [-d] [-e:paramfore] [drive:][path]filename1 [drive:][path]filename2\n\n"),szFilename_only);
    }
    return;
}


//***************************************************************************
//*                                                                         
//* purpose: 
//*
//***************************************************************************
LPSTR StripWhitespace( LPSTR pszString )
{
    LPSTR pszTemp = NULL;

    if ( pszString == NULL ) 
    {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) 
    {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) 
    {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenA(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) 
    {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}


//***************************************************************************
//*                                                                         
//* purpose: return back a Alocated wide string from a ansi string
//*          caller must free the returned back pointer with GlobalFree()
//*
//***************************************************************************
LPWSTR MakeWideStrFromAnsi(UINT uiCodePage, LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    // make sure they gave us something
    if (!psz)
    {
        return NULL;
    }

    // compute the length
    i =  MultiByteToWideChar(uiCodePage, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate memory in that length
    pwsz = (LPWSTR) GlobalAlloc(GPTR,i * sizeof(WCHAR));
    if (!pwsz) return NULL;

    // clear out memory
    memset(pwsz, 0, wcslen(pwsz) * sizeof(WCHAR));

    // convert the ansi string into unicode
    i =  MultiByteToWideChar(uiCodePage, 0, (LPSTR) psz, -1, pwsz, i);
    if (i <= 0) 
        {
        GlobalFree(pwsz);
        pwsz = NULL;
        return NULL;
        }

    // make sure ends with null
    pwsz[i - 1] = 0;

    // return the pointer
    return pwsz;
}


void CheckForFullAccess(void)
{
    HKEY hRootKeyType = HKEY_LOCAL_MACHINE;
    HKEY hKey1 = NULL;
    HKEY hKey2 = NULL;
    DWORD dwError;
    TCHAR szPath[200];

    _tcscpy(szPath, _T("System\\CurrentControlSet\\Services\\W3SVC"));
    dwError = RegOpenKeyEx(hRootKeyType, szPath, 0, KEY_ALL_ACCESS, &hKey1);
    _tprintf(_T("key=%s\r\n"),szPath);
    if (ERROR_ACCESS_DENIED == dwError){_tprintf(_T("Access Denied\r\n"));}
    else{_tprintf(_T("Access Granted!\r\n"));}
    _tprintf(_T("\r\n"),szPath);

    _tcscpy(szPath, _T("System\\CurrentControlSet\\Services\\W3SVC\\Parameters"));
    dwError = RegOpenKeyEx(hRootKeyType, szPath, 0, KEY_ALL_ACCESS, &hKey1);
    _tprintf(_T("key=%s\r\n"),szPath);
    if (ERROR_ACCESS_DENIED == dwError){_tprintf(_T("Access Denied\r\n"));}
    else{_tprintf(_T("Access Granted!\r\n"));}
    _tprintf(_T("\r\n"),szPath);

    _tcscpy(szPath, _T("System\\CurrentControlSet\\Services\\W3SVC\\Testing"));
    dwError = RegOpenKeyEx(hRootKeyType, szPath, 0, KEY_ALL_ACCESS, &hKey1);
    _tprintf(_T("key=%s\r\n"),szPath);
    if (ERROR_ACCESS_DENIED == dwError){_tprintf(_T("Access Denied\r\n"));}
    else{_tprintf(_T("Access Granted!\r\n"));}

    _tprintf(_T("\r\n"),szPath);

    _tcscpy(szPath, _T("System\\CurrentControlSet\\Services\\W3SVC\\Testing\\Testing2"));
    dwError = RegOpenKeyEx(hRootKeyType, szPath, 0, KEY_ALL_ACCESS, &hKey2);
    _tprintf(_T("key=%s\r\n"),szPath);
    if (ERROR_ACCESS_DENIED == dwError){_tprintf(_T("Access Denied\r\n"));}
    else{_tprintf(_T("Access Granted!\r\n"));}

    _tprintf(_T("\r\n"),szPath);

    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\uniutil\main.cpp ===
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

void   ShowHelp(void);
LPSTR  StripWhitespace(LPSTR pszString);
LPWSTR MakeWideStrFromAnsi(UINT uiCodePage, LPSTR psz);
int    Ansi2Unicode(TCHAR * szAnsiFile_input,TCHAR * szUnicodeFile_output,UINT iCodePage);
int    IsFileUnicode(TCHAR * szFile_input);
int    StripControlZfromUnicodeFile(TCHAR * szFilePath1,TCHAR * szFilePath2);

//***************************************************************************
//*                                                                         
//* purpose: main
//*
//***************************************************************************
int __cdecl  main(int argc,char *argv[])
{
    int iRet = 0;
    int argno;
	char * pArg = NULL;
	char * pCmdStart = NULL;
    TCHAR szFilePath1[_MAX_PATH];
    TCHAR szFilePath2[_MAX_PATH];
    TCHAR szParamString_C[_MAX_PATH];
    TCHAR szParamString_H[50];
    TCHAR szParamString_M[_MAX_PATH];

    int iDoAnsi2Unicode         = FALSE;
    int iDoIsUnicodeCheck       = FALSE;
    int iDoUnicodeStripControlZ = FALSE;
    int iDoVersion = FALSE;
    int iGotParamC = FALSE;
    int iGotParamH = FALSE;
    int iGotParamM = FALSE;

    *szFilePath1 = '\0';
    *szFilePath2 = '\0';
    *szParamString_C = '\0';
    *szParamString_H = '\0';
    *szParamString_M = '\0';
    _tcscpy(szFilePath1,_T(""));
    _tcscpy(szFilePath2,_T(""));
    _tcscpy(szParamString_C,_T(""));
    _tcscpy(szParamString_H,_T(""));
    _tcscpy(szParamString_M,_T(""));
        
    for(argno=1; argno<argc; argno++) 
    {
        if ( argv[argno][0] == '-'  || argv[argno][0] == '/' ) 
        {
            switch (argv[argno][1]) 
            {
                case 'a':
                case 'A':
                    iDoAnsi2Unicode = TRUE;
                    break;
                case 'i':
                case 'I':
                    iDoIsUnicodeCheck = TRUE;
                    break;
                case 'z':
                case 'Z':
                    iDoUnicodeStripControlZ = TRUE;
                    break;
                case 'v':
                case 'V':
                    iDoVersion = TRUE;
                    break;
                case 'c':
                case 'C':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') 
                    {
                        char szTempString[_MAX_PATH];

						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') 
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else 
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
#if defined(UNICODE) || defined(_UNICODE)
						MultiByteToWideChar(CP_ACP, 0, szTempString, -1, (LPWSTR) szParamString_C, _MAX_PATH);
#else
                        _tcscpy(szParamString_C,szTempString);
#endif

                        iGotParamC = TRUE;
					}
                    break;
                case 'h':
                case 'H':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') 
                    {
                        char szTempString[_MAX_PATH];

						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') 
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else 
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
#if defined(UNICODE) || defined(_UNICODE)
						MultiByteToWideChar(CP_ACP, 0, szTempString, -1, (LPWSTR) szParamString_H, _MAX_PATH);
#else
                        _tcscpy(szParamString_H,szTempString);
#endif
                        iGotParamH = TRUE;
					}
                    break;
                case 'm':
                case 'M':
					// Get the string for this flag
					pArg = CharNextA(argv[argno]);
					pArg = CharNextA(pArg);
					if (*pArg == ':') 
                    {
                        char szTempString[_MAX_PATH];

						pArg = CharNextA(pArg);

						// Check if it's quoted
						if (*pArg == '\"') 
                        {
							pArg = CharNextA(pArg);
							pCmdStart = pArg;
							while ((*pArg) && (*pArg != '\"')){pArg = CharNextA(pArg);}
                        }
                        else 
                        {
							pCmdStart = pArg;
							while (*pArg){pArg = CharNextA(pArg);}
						}
						*pArg = '\0';
						lstrcpyA(szTempString, StripWhitespace(pCmdStart));

						// Convert to unicode
#if defined(UNICODE) || defined(_UNICODE)
						MultiByteToWideChar(CP_ACP, 0, szTempString, -1, (LPWSTR) szParamString_M, _MAX_PATH);
#else
                        _tcscpy(szParamString_M,szTempString);
#endif
                        iGotParamM = TRUE;
					}
                    break;

                case '?':
                    goto main_exit_with_help;
                    break;
            }
        }
        else 
        {
            if (_tcsicmp(szFilePath1, _T("")) == 0)
            {
                // if no arguments, then get the filename portion
#if defined(UNICODE) || defined(_UNICODE)
                MultiByteToWideChar(CP_ACP, 0, argv[argno], -1, (LPTSTR) szFilePath1, _MAX_PATH);
#else
                _tcscpy(szFilePath1,argv[argno]);
#endif
            }
            else
            {
                if (_tcsicmp(szFilePath2, _T("")) == 0)
                {
                    // if no arguments, then get the filename portion
#if defined(UNICODE) || defined(_UNICODE)
                    MultiByteToWideChar(CP_ACP, 0, argv[argno], -1, (LPTSTR) szFilePath2, _MAX_PATH);
#else
                    _tcscpy(szFilePath2,argv[argno]);
#endif
                }
            }
        }
    }

    //
    // Check what were supposed to do
    //
    if (TRUE == iDoAnsi2Unicode)
    {
        UINT iCodePage = 1252;

        // check for required parameters
        if (_tcsicmp(szFilePath1, _T("")) == 0)
        {
            _tprintf(_T("[-a] parameter missing filename1 parameter\n"));
            goto main_exit_with_help;
        }

        if (_tcsicmp(szFilePath2, _T("")) == 0)
        {
            _tprintf(_T("[-a] parameter missing filename2 parameter\n"));
            goto main_exit_with_help;
        }

        // check for optional parameter
        if (TRUE == iGotParamC)
        {
            if (_tcsicmp(szParamString_C, _T("")) == 0)
            {
                // convert it to a number.
                iCodePage = _ttoi(szParamString_C);
            }
        }

        // call the function
        Ansi2Unicode(szFilePath1,szFilePath2,iCodePage);
        
        iRet = 0;
    }
    else
    {
        if (TRUE == iDoUnicodeStripControlZ)
        {
            // check for required parameters
            if (_tcsicmp(szFilePath1, _T("")) == 0)
            {
                _tprintf(_T("[-z] parameter missing filename1 parameter\n"));
                goto main_exit_with_help;
            }

            if (_tcsicmp(szFilePath2, _T("")) == 0)
            {
                _tprintf(_T("[-z] parameter missing filename2 parameter\n"));
                goto main_exit_with_help;
            }

            // call the function.
            iRet = StripControlZfromUnicodeFile(szFilePath1,szFilePath2);
            if (1 == iRet)
            {
                _tprintf(_T("control-z removed and saved to new file\n"));
            }
        
            iRet = 0;
        }
    }

    if (TRUE == iDoIsUnicodeCheck)
    {
        iRet = 0;

        // check for required parameters
        if (_tcsicmp(szFilePath1, _T("")) == 0)
        {
            _tprintf(_T("[-i] parameter missing filename1 parameter\n"));
            goto main_exit_with_help;
        }

        // call the function.
        // return 2 if the file is unicode
        // return 1 if the file is not unicode
        iRet = IsFileUnicode(szFilePath1);
        if (2 == iRet)
        {
            _tprintf(_T("%s is unicode\n"),szFilePath1);
        }
        else if (1 == iRet)
        {
            _tprintf(_T("%s is not unicode\n"),szFilePath1);
        }
        else
        {
            _tprintf(_T("error with file %s\n"),szFilePath1);
        }
    }

    if (TRUE == iDoVersion)
    {
        // output the version
        _tprintf(_T("1\n\n"));

        iRet = 10;
        goto main_exit_gracefully;
    }


    if (TRUE == iGotParamH)
    {
        // Output hex number
        if (_tcsicmp(szParamString_H, _T("")) != 0)
        {
            DWORD dwMyDecimal = _ttoi(szParamString_H);

            if (iGotParamM && (_tcsicmp(szParamString_M, _T("")) != 0))
            {
                _tprintf(szParamString_M,dwMyDecimal);
            }
            else
            {
                // convert it to a hex number
                _tprintf(_T("%x\n"),dwMyDecimal);
            }
            goto main_exit_gracefully;
        }
    }

    if (_tcsicmp(szFilePath1, _T("")) == 0)
    {
        goto main_exit_with_help;
    }

    goto main_exit_gracefully;
  
main_exit_gracefully:
    exit(iRet);

main_exit_with_help:
    ShowHelp();
    exit(iRet);
}


//***************************************************************************
//*                                                                         
//* purpose: ?
//*
//***************************************************************************
void ShowHelp(void)
{
	TCHAR szModuleName[_MAX_PATH];
	TCHAR szFilename_only[_MAX_PATH];

    // get the modules full pathed filename
	if (0 != GetModuleFileName(NULL,(LPTSTR) szModuleName,_MAX_PATH))
    {
	    // Trim off the filename only.
	    _tsplitpath(szModuleName, NULL, NULL, szFilename_only, NULL);
   
        _tprintf(_T("Unicode File Utility\n\n"));
        _tprintf(_T("%s [-a] [-i] [-v] [-z] [-c:codepage] [-h:number] [-m:printf format] [drive:][path]filename1 [drive:][path]filename2\n\n"),szFilename_only);
        _tprintf(_T("[-a] paramter -- converting ansi to unicode file:\n"));
        _tprintf(_T("   -a           required parameter for this functionality\n"));
        _tprintf(_T("   -c:codepage  specifies the codepage to use (optional,defaults to 1252 (usa ascii))\n"));
        _tprintf(_T("   filename1    ansi filename that should be converted\n"));
        _tprintf(_T("   filename2    unicode filename that result will be saved to\n\n"));
        _tprintf(_T("[-i] parameter -- is specified file unicode:\n"));
        _tprintf(_T("   -i           required paramter for this functionality\n"));
        _tprintf(_T("   filename1    filename to check if unicode.  if unicode ERRORLEVEL=2, if not unicode ERRORLEVEL=1.\n"));
        _tprintf(_T("[-z] parameter -- removing trailing control-z from end of unicode file:\n"));
        _tprintf(_T("   -z           required paramter for this functionality\n"));
        _tprintf(_T("   filename1    unicode filename that should have control-z removed from\n"));
        _tprintf(_T("   filename2    unicode filename that result will be saved to\n\n"));

        _tprintf(_T("[-h] parameter -- displaying version:\n"));
        _tprintf(_T("   -h:decimalnum required paramter for this functionality, input decimal number, get hex back.\n"));
        _tprintf(_T("[-m] parameter -- printf format for -h function:\n"));
        _tprintf(_T("   -m:%%x required paramter for this functionality.. eg:%%x,0x%%x,x%%08lx,x8%%07lx\n"));

        _tprintf(_T("[-v] parameter -- displaying version:\n"));
        _tprintf(_T("   -v           required paramter for this functionality, sets ERRORLEVEL=version num of this binary.\n"));
        _tprintf(_T("\n"));
        _tprintf(_T("Examples:\n"));
        _tprintf(_T("%s -a -c:1252 c:\\MyGroup\\MyFileAnsi.txt c:\\MyGroup\\MyFileUnicode.txt\n"),szFilename_only);
        _tprintf(_T("%s -i c:\\MyGroup\\MyFileUnicode.txt\n"),szFilename_only);
        _tprintf(_T("%s -z c:\\MyGroup\\MyFileUnicode.txt c:\\MyGroup\\MyFileUnicode.txt\n"),szFilename_only);
    }
    return;
}


//***************************************************************************
//*                                                                         
//* purpose: 
//*
//***************************************************************************
LPSTR StripWhitespace( LPSTR pszString )
{
    LPSTR pszTemp = NULL;

    if ( pszString == NULL ) 
    {
        return NULL;
    }

    while ( *pszString == ' ' || *pszString == '\t' ) 
    {
        pszString += 1;
    }

    // Catch case where string consists entirely of whitespace or empty string.
    if ( *pszString == '\0' ) 
    {
        return pszString;
    }

    pszTemp = pszString;

    pszString += lstrlenA(pszString) - 1;

    while ( *pszString == ' ' || *pszString == '\t' ) 
    {
        *pszString = '\0';
        pszString -= 1;
    }

    return pszTemp;
}


//***************************************************************************
//*                                                                         
//* purpose: return back a Alocated wide string from a ansi string
//*          caller must free the returned back pointer with GlobalFree()
//*
//***************************************************************************
LPWSTR MakeWideStrFromAnsi(UINT uiCodePage, LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    // make sure they gave us something
    if (!psz)
    {
        return NULL;
    }

    // compute the length
    i =  MultiByteToWideChar(uiCodePage, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate memory in that length
    pwsz = (LPWSTR) GlobalAlloc(GPTR,i * sizeof(WCHAR));
    if (!pwsz) return NULL;

    // clear out memory
    memset(pwsz, 0, wcslen(pwsz) * sizeof(WCHAR));

    // convert the ansi string into unicode
    i =  MultiByteToWideChar(uiCodePage, 0, (LPSTR) psz, -1, pwsz, i);
    if (i <= 0) 
        {
        GlobalFree(pwsz);
        pwsz = NULL;
        return NULL;
        }

    // make sure ends with null
    pwsz[i - 1] = 0;

    // return the pointer
    return pwsz;
}


//***************************************************************************
//*                                                                         
//* purpose: converts the ansi file to a unicode file
//*
//***************************************************************************
int Ansi2Unicode(TCHAR * szAnsiFile_input,TCHAR * szUnicodeFile_output,UINT iCodePage)
{
    int iReturn = FALSE;
    HANDLE hFile        = INVALID_HANDLE_VALUE;
    DWORD dwFileSize    = 0;
    unsigned char *pInputFileBuf = NULL;
    WCHAR * pwOutputFileBuf = NULL;
    DWORD dwBytesReadIn  = 0;
    DWORD dwBytesWritten = 0;
    BYTE bOneByte = 0;

    //
    // READ INPUT FILE
    //
    // open the input file with read access
    //
    hFile = CreateFile((LPCTSTR) szAnsiFile_input, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if( hFile == INVALID_HANDLE_VALUE)
    {
        _tprintf(_T("Unable to open input file:%s,err=0x%x\n"),szAnsiFile_input,GetLastError());
        goto Ansi2Unicode_Exit;
    }
	    
    // getfile size so we know how much memory we should allocate
    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == 0)
    {
        _tprintf(_T("input file:%s is empty\n"),szAnsiFile_input);
        goto Ansi2Unicode_Exit;
    }
	
    // allocate the memory the size of the file
    if ( ( pInputFileBuf = (unsigned char *) malloc( (size_t) dwFileSize + 1 ) ) == NULL )
    {	
        _tprintf(_T("Out of memory\n"));
        goto Ansi2Unicode_Exit;
    }
    
    // clear buffer we just created
    memset(pInputFileBuf, 0, dwFileSize + 1);

    // Read all the data from the file into the buffer
    if ( ReadFile( hFile, pInputFileBuf, dwFileSize, &dwBytesReadIn, NULL ) == FALSE )
    {
        _tprintf(_T("Readfile:%s, error=%s\n"),szAnsiFile_input,strerror(errno));
        goto Ansi2Unicode_Exit;
    }

    // if the amount of data that we read in is different than
    // what the file size is then get out... we didn't read all of the data into the buffer.
    if (dwFileSize != dwBytesReadIn)
    {
        _tprintf(_T("Readfile:%s, error file too big to read into memory\n"),szAnsiFile_input);
        goto Ansi2Unicode_Exit;
    }

    // check if the input file is already unicode!
    // if it is then just copy the damn file to the new filename!
    if (0xFF == pInputFileBuf[0] && 0xFE == pInputFileBuf[1])
    {
        // file is already unicode!
        if (FALSE == CopyFile((LPCTSTR)szAnsiFile_input,(LPCTSTR)szUnicodeFile_output, FALSE))
        {
            _tprintf(_T("Failed to copy file %s to %s\n"),szAnsiFile_input,szUnicodeFile_output);
        }
        
        // we copied the file to the new filename
        // we're done
        goto Ansi2Unicode_Exit;
    }
        
    // close handle to file#1
    CloseHandle(hFile);hFile = INVALID_HANDLE_VALUE;


    //
    // CREATE OUTPUT FILE
    //
    // Take the ansi string and convert it to unicode
    pwOutputFileBuf = (LPWSTR) MakeWideStrFromAnsi(iCodePage,(LPSTR) pInputFileBuf);
    if(NULL == pwOutputFileBuf)
    {
        _tprintf(_T("Out of memory\n"));
        goto Ansi2Unicode_Exit;
    } 

    // Create a new unicode file
    hFile = CreateFile((LPCTSTR) szUnicodeFile_output, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if( hFile == INVALID_HANDLE_VALUE)
    {
        _tprintf(_T("CreateFile:%s,error=0x%x\n"),szUnicodeFile_output,GetLastError());
        goto Ansi2Unicode_Exit;
    }

    // Write the BOF header to say that this is infact a unicode file
    bOneByte = 0xFF;
    WriteFile(hFile,(LPCVOID) &bOneByte, 1, &dwBytesWritten, NULL);
    bOneByte = 0xFE;
    WriteFile(hFile,(LPCVOID) &bOneByte, 1, &dwBytesWritten, NULL);

    // Append our data to the file
    if ( WriteFile( hFile, pwOutputFileBuf, wcslen(pwOutputFileBuf) * sizeof(WCHAR), &dwBytesWritten, NULL ) == FALSE )
    {
        _tprintf(_T("WriteFile:%s,error=%s\n"),szUnicodeFile_output,strerror(errno));
        goto Ansi2Unicode_Exit;
    }

    // SUCCESS
    iReturn = TRUE;

Ansi2Unicode_Exit:
    if (INVALID_HANDLE_VALUE != hFile)
        {CloseHandle(hFile);hFile = INVALID_HANDLE_VALUE;}
    if (pInputFileBuf)
        {free(pInputFileBuf);pInputFileBuf=NULL;}
    if (pwOutputFileBuf)
        {GlobalFree(pwOutputFileBuf);pwOutputFileBuf=NULL;}
    return iReturn;
}


// returns 2 if the file is unicode
// returns 1 if the file is not unicode
// returns 0 on error
int IsFileUnicode(TCHAR * szFile_input)
{
    int iReturn = 0;
    HANDLE hFile        = INVALID_HANDLE_VALUE;
    DWORD dwBytesToRead = 2;
    unsigned char *pInputFileBuf = NULL;
    DWORD dwBytesReadIn  = 0;

    //
    // READ INPUT FILE
    //
    // open the input file with read access
    //
    hFile = CreateFile((LPCTSTR) szFile_input, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if( hFile == INVALID_HANDLE_VALUE)
    {
        _tprintf(_T("Unable to open input file:%s,err=0x%x\n"),szFile_input,GetLastError());
        goto IsFileUnicode_Exit;
    }
	    
    // allocate the memory the size of the file
    if ( ( pInputFileBuf = (unsigned char *) malloc( (size_t) dwBytesToRead) ) == NULL )
    {	
        _tprintf(_T("Out of memory\n"));
        goto IsFileUnicode_Exit;
    }
    
    // clear buffer we just created
    memset(pInputFileBuf, 0, dwBytesToRead);

    // Read all the data from the file into the buffer
    if ( ReadFile( hFile, pInputFileBuf, dwBytesToRead, &dwBytesReadIn, NULL ) == FALSE )
    {
        _tprintf(_T("Readfile:%s, error=%s\n"),szFile_input,strerror(errno));
        goto IsFileUnicode_Exit;
    }

    // if the amount of data that we read in is different than
    // what the file size is then get out... we didn't read all of the data into the buffer.
    if (dwBytesToRead != dwBytesReadIn)
    {
        _tprintf(_T("Readfile:%s, error file too big to read into memory\n"),szFile_input);
        goto IsFileUnicode_Exit;
    }

    // check if the input file is unicode
    iReturn = 1;
    if (0xFF == pInputFileBuf[0] && 0xFE == pInputFileBuf[1])
    {
        iReturn = 2;
    }
        
IsFileUnicode_Exit:
    if (INVALID_HANDLE_VALUE != hFile)
        {CloseHandle(hFile);hFile = INVALID_HANDLE_VALUE;}
    if (pInputFileBuf)
        {free(pInputFileBuf);pInputFileBuf=NULL;}
    return iReturn;
}


int StripControlZfromUnicodeFile(TCHAR * szFile_input,TCHAR * szFile_output)
{
    // open the input file
    // if it's unicode, then see if it ends with a control Z
    int iReturn = 0;
    HANDLE hFile        = INVALID_HANDLE_VALUE;
    DWORD dwFileSize = 0;
    unsigned char *pInputFileBuf = NULL;
    DWORD dwBytesReadIn  = 0;
    int iFileIsUnicode = FALSE;
    int iWeNeedMakeChange = FALSE;

    //
    // READ INPUT FILE
    //
    // open the input file with read access
    //
    hFile = CreateFile((LPCTSTR) szFile_input, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if( hFile == INVALID_HANDLE_VALUE)
    {
        _tprintf(_T("Unable to open input file:%s,err=0x%x\n"),szFile_input,GetLastError());
        goto StripControlZfromUnicodeFile_Exit;
    }

    // getfile size so we know how much memory we should allocate
    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == 0)
    {
        _tprintf(_T("input file:%s is empty\n"),szFile_input);
        goto StripControlZfromUnicodeFile_Exit;
    }

    // allocate the memory the size of the file
    if ( ( pInputFileBuf = (unsigned char *) malloc( (size_t) dwFileSize + 1 ) ) == NULL )
    {	
        _tprintf(_T("Out of memory\n"));
        goto StripControlZfromUnicodeFile_Exit;
    }
    
    // clear buffer we just created
    memset(pInputFileBuf, 0, dwFileSize + 1);

    // Read all the data from the file into the buffer
    if ( ReadFile( hFile, pInputFileBuf, dwFileSize, &dwBytesReadIn, NULL ) == FALSE )
    {
        _tprintf(_T("Readfile:%s, error=%s\n"),szFile_input,strerror(errno));
        goto StripControlZfromUnicodeFile_Exit;
    }

    // if the amount of data that we read in is different than
    // what the file size is then get out... we didn't read all of the data into the buffer.
    if (dwFileSize != dwBytesReadIn)
    {
        _tprintf(_T("Readfile:%s, error file too big to read into memory\n"),szFile_input);
        goto StripControlZfromUnicodeFile_Exit;
    }

    // check if the input file is unicode
    if (0xFF == pInputFileBuf[0] && 0xFE == pInputFileBuf[1])
    {
        iFileIsUnicode = TRUE;
    }

    // close the file we opened
    CloseHandle(hFile);hFile = INVALID_HANDLE_VALUE;

    // open file #2

    if (TRUE == iFileIsUnicode)
    {
        // Check if it has a control-z at the end
        if (0x1A == pInputFileBuf[dwFileSize])
        {
            pInputFileBuf[dwFileSize] = 0x0;
            iWeNeedMakeChange = TRUE;
        }
        if (0x1A == pInputFileBuf[dwFileSize-1])
        {
            pInputFileBuf[dwFileSize-1] = 0x0;
            iWeNeedMakeChange = TRUE;
        }
    }

    if (TRUE == iWeNeedMakeChange)
    {
        DWORD dwBytesWritten = 0;

        // Create a new unicode file
        hFile = CreateFile((LPCTSTR) szFile_output, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if( hFile == INVALID_HANDLE_VALUE)
        {
            _tprintf(_T("CreateFile:%s,error=0x%x\n"),szFile_output,GetLastError());
            goto StripControlZfromUnicodeFile_Exit;
        }
        // write the file out that we fixed
        //
        // we have to minus out one byte here
        //
        // before:
        // 00 0D 00 0A 00 1A
        //
        // after
        // 00 0D 00 0A 00
        //
        if ( WriteFile( hFile, pInputFileBuf, dwBytesReadIn-1, &dwBytesWritten, NULL ) == FALSE )
        {
            _tprintf(_T("WriteFile:%s,error=%s\n"),szFile_output,strerror(errno));
            goto StripControlZfromUnicodeFile_Exit;
        }

        // return 1 to say that we had to strip of the control-z
        // from the end of the file
        iReturn = 1;
    }
    else
    {
        // just open the file over to the new filename
        if (FALSE == CopyFile((LPCTSTR)szFile_input,(LPCTSTR)szFile_output, FALSE))
        {
            _tprintf(_T("Failed to copy file %s to %s\n"),szFile_input,szFile_output);
        }
    }

    
StripControlZfromUnicodeFile_Exit:
    if (INVALID_HANDLE_VALUE != hFile)
        {CloseHandle(hFile);hFile = INVALID_HANDLE_VALUE;}
    if (pInputFileBuf)
        {free(pInputFileBuf);pInputFileBuf=NULL;}

    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\setup\util\verstamp\verstamp.c ===
#define _UNICODE
#define UNICODE
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

void Usage();
BOOL ParseCmdLine(int argc, TCHAR **argv);
void SetVersionOfImage(IN LPTSTR lpszFileName);
void VersionDwordLong2String(IN DWORDLONG Version, OUT LPTSTR lpszVerString);
void VersionString2DwordLong(IN LPCTSTR lpszVerString, OUT PDWORDLONG pVersion);
void DirWalker(LPCTSTR lpszPath, BOOL fRecursive, void (*pFunc)());

BOOL g_fRecursive = FALSE;
BOOL g_fForceTrue = FALSE;

TCHAR g_szPath[MAX_PATH]; // contains the DirName/FileName we're interested
BOOL g_fSet = FALSE; // TRUE if set new version, FALSE to only display version info
DWORDLONG g_dwlNewVersion = 0;

void __cdecl _tmain(int argc, TCHAR **argv)
{
    void (*pFunc)();
    
    if (ParseCmdLine(argc, argv) == FALSE) {
        Usage();
        return;
    }

    pFunc = SetVersionOfImage;

    DirWalker(g_szPath, g_fRecursive, pFunc);

    return;
}

void SetVersionOfImage(IN LPTSTR lpszFileName)
/*++

Routine Description:

    Get/Set file version.

    The version is specified in the dwFileVersionMS and dwFileVersionLS fields
    of a VS_FIXEDFILEINFO, as filled in by the win32 version APIs.

Arguments:

    lpszFileName - supplies the full path of the file whose version data is desired.

Return Value:

--*/
{
    DWORD d;
    PVOID pVersionBlock;
    VS_FIXEDFILEINFO *pFixedVersionInfo;
    UINT iDataLength;
    BOOL b = FALSE;
    DWORD dwIgnored;
    HANDLE hHandle = NULL;
    PVOID pTranslation;
    PWORD pLangId, pCodePage;
    TCHAR szQueryString[MAX_PATH];
    TCHAR *lpszVerString;
    TCHAR szOldVerString[MAX_PATH], szNewVerString[MAX_PATH];
    DWORDLONG dwlOldVersion = 0;
    
    VersionDwordLong2String(g_dwlNewVersion, szNewVerString);

    //
    // Get the size of version info block.
    //
    if(d = GetFileVersionInfoSize((LPTSTR)lpszFileName,&dwIgnored)) {
        //
        // Allocate memory block of sufficient size to hold version info block
        //
        pVersionBlock = LocalAlloc(LPTR, d);
        if(pVersionBlock) {

            //
            // Get the version block from the file.
            //
            if(GetFileVersionInfo((LPTSTR)lpszFileName,0,d,pVersionBlock)) {

                //
                // Get fixed version info.
                //
                if(VerQueryValue(pVersionBlock,TEXT("\\"),(LPVOID *)&pFixedVersionInfo,&iDataLength)) {

                    //
                    // display the verions info first
                    //
                    dwlOldVersion = (((DWORDLONG)pFixedVersionInfo->dwFileVersionMS) << 32)
                             + pFixedVersionInfo->dwFileVersionLS;
                    VersionDwordLong2String(dwlOldVersion, szOldVerString);

                    _tprintf(TEXT("%s: %s"), lpszFileName, szOldVerString);

                    if (g_fSet == FALSE) {
                        _tprintf(TEXT("\n"));
                    } else {
                        //
                        // set to the new version
                        //
                        pFixedVersionInfo->dwFileVersionMS = (DWORD)((g_dwlNewVersion >> 32) & 0xffffffff);
                        pFixedVersionInfo->dwFileVersionLS = (DWORD)(g_dwlNewVersion & 0xffffffff);

                        // Attempt to get language of file. We'll simply ask for the
                        // translation table and use the first language id we find in there
                        // as *the* language of the file.
                        //
                        // The translation table consists of LANGID/Codepage pairs.
                        //

                        if(VerQueryValue(pVersionBlock,TEXT("\\VarFileInfo\\Translation"),&pTranslation,&iDataLength)) {
                            pLangId = (PWORD)pTranslation;
                            pCodePage = (PWORD)pTranslation + 1;

                            // update FileVersion string
                            _stprintf(szQueryString, TEXT("\\StringFileInfo\\%04x%04x\\FileVersion"), *pLangId, *pCodePage);
                            if (VerQueryValue(pVersionBlock,szQueryString,(LPVOID *)&lpszVerString,&iDataLength)) {
                                memset(lpszVerString, 0, iDataLength * sizeof(TCHAR));
                                _tcsncpy(lpszVerString, szNewVerString, iDataLength - 1);
                            }
                        
                            // update ProductVersion string
                            _stprintf(szQueryString, TEXT("\\StringFileInfo\\%04x%04x\\ProductVersion"), *pLangId, *pCodePage);
                            if (VerQueryValue(pVersionBlock,szQueryString,(LPVOID *)&lpszVerString,&iDataLength)) {
                                memset(lpszVerString, 0, iDataLength * sizeof(TCHAR));
                                _tcsncpy(lpszVerString, szNewVerString, iDataLength - 1);
                            }

                        } // Language-related String Update

                        //
                        // Update the version resource
                        //
                        b = FALSE;
                        hHandle = BeginUpdateResource((LPTSTR) lpszFileName, FALSE);
                        if (hHandle) {
                           b = UpdateResource(
                                   hHandle, 
                                   RT_VERSION, 
                                   MAKEINTRESOURCE(VS_VERSION_INFO),
                                   MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), 
                                   pVersionBlock, 
                                   d);

                           if (b)
                             b = EndUpdateResource(hHandle, FALSE);

                        }

                        if (b)
                           _tprintf(TEXT(" ==> %s\n"), szNewVerString);
                        else
                           _tprintf(TEXT("\nError = %d\n"), GetLastError());

                    } // g_fGet
                } // VerQueryValue() on FixedVersionInfo
            } // GetFileVersionInfo()

            LocalFree(pVersionBlock);
        } // malloc()
    }

    return;
}

void DirWalker(LPCTSTR lpszPath, BOOL fRecursive, void (*pFunc)())
{
    DWORD retCode;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR szSubDir[MAX_PATH] = _T("");
    TCHAR szDirName[MAX_PATH] = _T("");
    int len = 0;

    retCode = GetFileAttributes(lpszPath);

    if (retCode == 0xFFFFFFFF) {
        // lpszPath is not a valid DirName or FileName
        return;
    }

    if ( !(retCode & FILE_ATTRIBUTE_DIRECTORY) ) {
        // apply the function call
        (*pFunc)(lpszPath);
        return;
    }

    len = _tcslen(lpszPath);
    if (lpszPath[len - 1] == _T('\\'))
        _stprintf(szDirName, _T("%s*"), lpszPath);
    else
        _stprintf(szDirName, _T("%s\\*"), lpszPath);

    hFile = FindFirstFile(szDirName, &FindFileData);

    if (hFile != INVALID_HANDLE_VALUE) {
        do {
            if (_tcsicmp(FindFileData.cFileName, _T(".")) != 0 &&
                _tcsicmp(FindFileData.cFileName, _T("..")) != 0 ) {

                if (lpszPath[len - 1] == _T('\\'))
                    _stprintf(szSubDir, _T("%s%s"), lpszPath, FindFileData.cFileName);
                else
                    _stprintf(szSubDir, _T("%s\\%s"), lpszPath, FindFileData.cFileName);

                if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    if (fRecursive)
                        DirWalker(szSubDir, fRecursive, pFunc);
                } else {
                    (*pFunc)(szSubDir);
                }
            }

            if (!FindNextFile(hFile, &FindFileData)) {
                FindClose(hFile);
                break;
            }
        } while (TRUE);
    }

    return;
}

void VersionDwordLong2String(IN DWORDLONG Version, OUT LPTSTR lpszVerString)
{
    WORD a, b, c, d;

    a = (WORD)(Version >> 48);
    b = (WORD)((Version >> 32) & 0xffff);
    c = (WORD)((Version >> 16) & 0xffff);
    d = (WORD)(Version & 0xffff);

    _stprintf(lpszVerString, TEXT("%d.%d.%d.%d"), a, b, c, d);

    return;
}

void VersionString2DwordLong(IN LPCTSTR lpszVerString, OUT PDWORDLONG pVersion)
{
    WORD a=0, b=0, c=0, d=0;

    _stscanf(lpszVerString, TEXT("%d.%d.%d.%d"), &a, &b, &c, &d);

    *pVersion = (((DWORDLONG)a) << 48) + 
                (((DWORDLONG)b) << 32) +
                (((DWORDLONG)c) << 16) +
                  (DWORDLONG)d;

    return;
}

BOOL ParseCmdLine(int argc, TCHAR **argv)
{
    BOOL fReturn = FALSE;
    TCHAR szVerString[MAX_PATH];
    TCHAR c;
    int i = 0;

    if (argc < 2 || argc > 4 ||
        _tcsicmp(argv[1], TEXT("/?")) == 0 ||
        _tcsicmp(argv[1], TEXT("-?")) == 0) {
        fReturn = FALSE;
    } else {

        i = 1;
        if (_tcsicmp(argv[1], TEXT("/r")) == 0 || _tcsicmp(argv[1], TEXT("-r")) == 0) {
            g_fRecursive = TRUE;
            i = 2;
        }

        if (_tcsicmp(argv[1], TEXT("/rf")) == 0 || _tcsicmp(argv[1], TEXT("-rf")) == 0) {
            g_fRecursive = TRUE;
            g_fForceTrue = TRUE;
            i = 2;
        }

        if (_tcsicmp(argv[1], TEXT("/f")) == 0 || _tcsicmp(argv[1], TEXT("-f")) == 0) {
            g_fForceTrue = TRUE;
            i = 2;
        }


        if (argv[i]) {
            if (GetFileAttributes(argv[i]) != 0xFFFFFFFF) {
                // argv[i] is pointing to a valid DirName or FileName
                _tcscpy(g_szPath, argv[i]);

                i++;
                if (argv[i] == NULL) {
                    // display version info only
                    // parse is done
                    g_fSet = FALSE;
                    fReturn = TRUE;
                } else {
                    // set version info
                    g_fSet = TRUE;
                    // make sure it's a valid version string
                    VersionString2DwordLong(argv[i], &g_dwlNewVersion);
                    VersionDwordLong2String(g_dwlNewVersion, szVerString);
                    _tprintf(TEXT("Stamp files with new version %s ? (y/n) "), szVerString);
                    if (g_fForceTrue)
                    {
                        _tprintf(TEXT("Yes\n"));
                        fReturn = TRUE;
                    }
                    else
                    {
                        _tscanf(TEXT("%c"), &c);
                        if (c == TEXT('y') || c == TEXT('Y')) {
                            fReturn = TRUE;
                        } else {
                            fReturn = FALSE;
                        }
                    }
                }
            } else {
                _tprintf(TEXT("Error: no such file called %s!\n"), argv[i]);
            }
        }

    }

    return fReturn;
}

void Usage()
{
    _tprintf(TEXT("\n"));
    _tprintf(TEXT("Display or change version info of files.\n"));
    _tprintf(TEXT("\n"));
    _tprintf(TEXT("Usage:\n"));
    _tprintf(TEXT("\n"));
    _tprintf(TEXT("verstamp [-rf] Path [newVersion]\n"));
    _tprintf(TEXT("\t-r\t\trecursively apply the Path\n"));
    _tprintf(TEXT("\t-rf\t\trecursively apply the Path and force to Yes.\n"));
    _tprintf(TEXT("\tPath\t\ta file name or directory name\n"));
    _tprintf(TEXT("\tnewVersion\tstamp file with this new version\n"));
    _tprintf(TEXT("\n"));
    _tprintf(TEXT("verstamp [-?]\t\tprint out this usage info.\n"));
    _tprintf(TEXT("\n"));
    _tprintf(TEXT("\n"));
    _tprintf(TEXT("Example:\n"));
    _tprintf(TEXT("verstamp iis.dll 5.0.1780.0\n"));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\acptntfy.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Mon Mar 03 15:18:06 1997
 */
/* Compiler settings for acptntfy.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __acptntfy_h__
#define __acptntfy_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IAcceptNotify_FWD_DEFINED__
#define __IAcceptNotify_FWD_DEFINED__
typedef interface IAcceptNotify IAcceptNotify;
#endif 	/* __IAcceptNotify_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IAcceptNotify_INTERFACE_DEFINED__
#define __IAcceptNotify_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAcceptNotify
 * at Mon Mar 03 15:18:06 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


#ifndef _LPSINDEXNOTIFYDEFINED
#define _LPSINDEXNOTIFYDEFINED
typedef IAcceptNotify __RPC_FAR *LPACCEPTNOTIFY;

#endif 
#ifndef __ACNTDEFS_H
#define __ACNTDEFS_H
typedef struct  tagNOTIFYDATA
    {
    DWORD dwDataType;
    unsigned long cbData;
    /* [size_is] */ unsigned char __RPC_FAR *pvData;
    }	NOTIFYDATA;

typedef 
enum tagANDchAdvise
    {	AND_ADD	= 0x1,
	AND_DELETE	= 0x2,
	AND_MODIFY	= 0x4,
	ANDM_ADVISE_ACTION	= 0x7,
	AND_TREATASDEEP	= 0x100,
	AND_DELETE_WHEN_DONE	= 0x200,
	ANDF_DATAINLINE	= 0x20000
    }	ANDchAdvise;

typedef 
enum tagANMMapping
    {	ANM_ADD	= 0x1,
	ANM_DELETE	= 0x2,
	ANM_MODIFY	= 0x4,
	ANM_PHYSICALTOLOGICAL	= 0x10,
	ANM_LOGICALTOPHYSICAL	= 0x20
    }	ANDMapping;

typedef 
enum tagANSStatus
    {	NSS_START	= 0,
	NSS_BEGINBATCH	= NSS_START + 1,
	NSS_INBATCH	= NSS_BEGINBATCH + 1,
	NSS_ENDBATCH	= NSS_INBATCH + 1,
	NSS_PAUSE	= NSS_ENDBATCH + 1,
	NSS_STOP	= NSS_PAUSE + 1,
	NSS_PAUSEPENDING	= 0x10000,
	NSS_STOPPENDING	= 0x20000
    }	ANSStatus;

#endif

EXTERN_C const IID IID_IAcceptNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IAcceptNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNotify( 
            /* [string][in] */ LPCSTR pszScopeName,
            /* [string][in] */ LPCSTR pszServerName,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMapping( 
            /* [string][in] */ LPCSTR pszScopeName,
            /* [in] */ DWORD eANMSetting,
            /* [string][in] */ LPCSTR pszPhysicalPrefix,
            /* [string][in] */ LPCSTR pszLogicalPrefix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDataChange( 
            /* [string][in] */ LPCSTR pszScopeName,
            /* [in] */ DWORD eANDChAdvise,
            /* [string][in] */ LPCSTR pszPhysicaAddress,
            /* [string][in] */ LPCSTR pszLogicalAddress,
            /* [in] */ NOTIFYDATA __RPC_FAR *pndData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStatusChange( 
            /* [string][in] */ LPCSTR pszScopeName,
            /* [in] */ DWORD eANSStatusChange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAcceptNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAcceptNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAcceptNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAcceptNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNotify )( 
            IAcceptNotify __RPC_FAR * This,
            /* [string][in] */ LPCSTR pszScopeName,
            /* [string][in] */ LPCSTR pszServerName,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMapping )( 
            IAcceptNotify __RPC_FAR * This,
            /* [string][in] */ LPCSTR pszScopeName,
            /* [in] */ DWORD eANMSetting,
            /* [string][in] */ LPCSTR pszPhysicalPrefix,
            /* [string][in] */ LPCSTR pszLogicalPrefix);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDataChange )( 
            IAcceptNotify __RPC_FAR * This,
            /* [string][in] */ LPCSTR pszScopeName,
            /* [in] */ DWORD eANDChAdvise,
            /* [string][in] */ LPCSTR pszPhysicaAddress,
            /* [string][in] */ LPCSTR pszLogicalAddress,
            /* [in] */ NOTIFYDATA __RPC_FAR *pndData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStatusChange )( 
            IAcceptNotify __RPC_FAR * This,
            /* [string][in] */ LPCSTR pszScopeName,
            /* [in] */ DWORD eANSStatusChange);
        
        END_INTERFACE
    } IAcceptNotifyVtbl;

    interface IAcceptNotify
    {
        CONST_VTBL struct IAcceptNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAcceptNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAcceptNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAcceptNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAcceptNotify_InitNotify(This,pszScopeName,pszServerName,dwReserved)	\
    (This)->lpVtbl -> InitNotify(This,pszScopeName,pszServerName,dwReserved)

#define IAcceptNotify_SetMapping(This,pszScopeName,eANMSetting,pszPhysicalPrefix,pszLogicalPrefix)	\
    (This)->lpVtbl -> SetMapping(This,pszScopeName,eANMSetting,pszPhysicalPrefix,pszLogicalPrefix)

#define IAcceptNotify_OnDataChange(This,pszScopeName,eANDChAdvise,pszPhysicaAddress,pszLogicalAddress,pndData)	\
    (This)->lpVtbl -> OnDataChange(This,pszScopeName,eANDChAdvise,pszPhysicaAddress,pszLogicalAddress,pndData)

#define IAcceptNotify_OnStatusChange(This,pszScopeName,eANSStatusChange)	\
    (This)->lpVtbl -> OnStatusChange(This,pszScopeName,eANSStatusChange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAcceptNotify_InitNotify_Proxy( 
    IAcceptNotify __RPC_FAR * This,
    /* [string][in] */ LPCSTR pszScopeName,
    /* [string][in] */ LPCSTR pszServerName,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IAcceptNotify_InitNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAcceptNotify_SetMapping_Proxy( 
    IAcceptNotify __RPC_FAR * This,
    /* [string][in] */ LPCSTR pszScopeName,
    /* [in] */ DWORD eANMSetting,
    /* [string][in] */ LPCSTR pszPhysicalPrefix,
    /* [string][in] */ LPCSTR pszLogicalPrefix);


void __RPC_STUB IAcceptNotify_SetMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAcceptNotify_OnDataChange_Proxy( 
    IAcceptNotify __RPC_FAR * This,
    /* [string][in] */ LPCSTR pszScopeName,
    /* [in] */ DWORD eANDChAdvise,
    /* [string][in] */ LPCSTR pszPhysicaAddress,
    /* [string][in] */ LPCSTR pszLogicalAddress,
    /* [in] */ NOTIFYDATA __RPC_FAR *pndData);


void __RPC_STUB IAcceptNotify_OnDataChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAcceptNotify_OnStatusChange_Proxy( 
    IAcceptNotify __RPC_FAR * This,
    /* [string][in] */ LPCSTR pszScopeName,
    /* [in] */ DWORD eANSStatusChange);


void __RPC_STUB IAcceptNotify_OnStatusChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAcceptNotify_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\actlapi.h ===
//>-------------------------------------------------------------------------------<
//
//  File:		Actlapi.h
//
//  Synopsis:	Access Control and Authentication API's:
//
//					UiGetAccountRights, 
//					UiGetValidationInfo
//
//				Sysop API's for accout/group/token maintenance in security DB:
//
//					AddAcct
//					UpdateAcct
//					DeleteAcct
//					DeleteAcctByLogin
//					SetPassword
//					GetHandle
//					GetAcctInfo
//					GetAcctPlan
//
//					EnumUserGroups 
//					EnumUserGroupsEx 
//					GetUserGroupDetails 
//					FindUserGroup
//					AddUserGroup 
//					UpdateUserGroup
//					DeleteUserGroup 
//					EnumGroupMembers 
//					EnumGroupMembersEx
//					EnumGroupMembersExpire 
//					EnumGroupMembersExpireEx
//					AddAcctToGroup
//					AddAcctToGroupExpire 
//					RemoveAcctFromGroup 
//					RemoveExpiredAcctsFromGroup 
//					
//					EnumTokens
//					EnumTokensEx
//					CreateToken
//					ModifyToken
//					DeleteToken
//					EnumAcctPrivateTokens
//					EnumAcctPrivateTokensEx
//					EnumGroupsWithToken
//					EnumGroupsWithTokenEx
//					EnumGroupsWithTokenExpire
//					EnumGroupsWithTokenExpireEx
//					AddGroupToToken
//					AddGroupToTokenExpire
//					EnumAcctsWithToken
//					RemoveGroupFromToken
//					RemoveExpiredGroupsFromToken
//					EnumAcctsWithToken
//					EnumAcctsWithTokenEx
//					EnumAcctsWithTokenExpire
//					EnumAcctsWithTokenExpireEx
//					AddAcctToToken
//					AddAcctToTokenExpire
//					RemoveAcctFromToken 
//					RemoveExpiredAcctsFromToken 
//					GetTokenDetails
//					TokenIdFromTokenName
//					UiIsAccountInGroup
//					EnumExcludedAccts 
//					EnumExcludedAcctsEx 
//					AddExclusion 
//					AddExclusionEx 
//					RemoveExclusion 
//					GetMaxTokenId 
//
//					AddAccessPlan
//					UpdateAccessPlan
//					DeleteAccessPlan
//					EnumAccessPlans
//					EnumAccessPlansEx
//
//					SearchAcctsWithToken
//					SearchExcludedAcctsWithToken
//					SearchGroupMembers
//					SearchGroupsWithToken
//					SearchTokens
//					SearchUserGroups
//					TotalAcctsWithToken
//					TotalExcludedAcctsWithToken
//					TotalGroupMembers
//					TotalGroupsWithToken
//					TotalTokens
//					TotalUserGroups
//
//  History:	DanielLi   Ported to 2.x tree	03/22/96
//
//   			Copyright (C) 1994-1996 Microsoft Corporation
//				All rights reserved
//
//>-------------------------------------------------------------------------------<


#if !defined(__ACTLAPI_H__)
#define __ACTLAPI_H__

#include <acsctl.h>

#if !defined(_ACTL_DLL_DEFINED)
#if defined(WIN32)
    #if defined(_ACTLDLL)
	#define ActlDLL DllExport __stdcall
    #else
	#define ActlDLL DllImport __stdcall
    #endif
#else
    #define ActlDLL
#endif
#define _ACTL_DLL_DEFINED
#endif

//--------------------------------------------------------------------------------
//
// Adjustable parameters
//
//--------------------------------------------------------------------------------
typedef struct _ACCESS_TUNING
{
	//
	// max number of user caches; default is: 100K
	//
	DWORD	dwMaxUserCaches;
	//
	// the beginning instance size of CPool list, in the power of 2, so, the actual
	// size is : 2^dwFirstCPool; default is: 7 (128 bytes)
	//
	DWORD	dwFirstPoolSize;
	//
	// the number of CPool in the CPool list; default is: 5 
	//
	DWORD	dwPoolSteps;


} ACCESS_TUNING, *PACCESS_TUNING;

//--------------------------------------------------------------------------------
//
// Performance counters 
//
//--------------------------------------------------------------------------------
typedef struct _ACCESS_STATISTICS
{

	//
	// number of times UiGetAccountRights got called
	//
	LONG	cGetAccountRights;
	LONG	cGetAccountRightsRate;
	//
	// number of times UiGetAccountRights failed
	//
	LONG	cGetAccountRightsFailures;
	LONG	cGetAccountRightsFailuresRate;

	//
	// number of times pass-through queries w/o hitting cache
	//
	LONG		cGetAccountRightsPassThru;
	LONG		cGetAccountRightsPassThruRate;

#if 0
	//
	// number of times UiGetAccountRigts failed due to query timeout
	//
	LONG	cGetAccountRightsTimeout;

	LONG	cGetValidationInfo;
	LONG	cGetValidationInfoFailures;

	//
	// number of times Security DB query (sp_get_tokens_and_groups) is issued to 
	// refresh the user cache
	//
	LONG	cNumDBQueriesForCache;

	//
	// number of times the user cache is added into the cache pool
	//
	LONG	cNumUserCacheAdded;
	//
	// number of times the user cache is released from the cache pool
	//
	LONG	cNumUserCacheReleased;

	//
	// number of times CDBUserCache::operator new() got called 
	//
	LONG	cNewUserCache;
	//
	// number of times CDBUserCache::operator delete() got called 
	//
	LONG	cDeleteUserCache;

	//
	// number of times token-group cache allocated (one token-group cache per CDBUserCache)
	//
	LONG	cAllocTokenGroupCache;
	//
	// number of token-group cache allocated (one token-group cache per CDBUserCache)
	//
	LONG	cFreeTokenGroupCache;

	//
	// number of times the plan list is refreshed (GetPlans)
	//
	LONG	cNumPlanListRefreshed;
	//
	// number of times GetPlanRightsOnToken is called
	//
	LONG	cGetPlanRightsOnToken;

	//
	// number of AddAcct are called
	//
	LONG		cAddAcct;
	//
	// number of AddAcct failed
	//
	LONG		cAddAcctFailures;

	//
	// number of UpdateAcct are called
	//
	LONG		cUpdateAcct;
	//
	// number of UpdateAcct failed
	//
	LONG		cUpdateAcctFailures;

	LONG		cDeleteAcct;
	LONG		cDeleteAcctFailures;

	LONG		cSetPassword;
	LONG		cSetPasswordFailures;

	LONG		cGetHandle;
	LONG		cGetHandleFailures;

	LONG		cAddAcctToToken;
	LONG		cAddAcctToTokenFailures;

	LONG		cRemoveAcctFromToken;
	LONG		cRemoveAcctFromTokenFailures;

	LONG		cGetTokenDetails;
	LONG		cGetTokenDetailsFailures;

	LONG		cEnumAcctPrivateTokens;
	LONG		cEnumAcctPrivateTokensFailures;

	LONG		cGetAcctInfo;
	LONG		cGetAcctInfoFailures;

#endif

} ACCESS_STATISTICS, *PACCESS_STATISTICS;


#define INC_ACCESS_COUNTER(counter)		if (g_pCntrs) \
											InterlockedIncrement((LPLONG)&g_pCntrs->##counter)
#define DEC_ACCESS_COUNTER(counter)		if (g_pCntrs) \
											InterlockedDecrement((LPLONG)&g_pCntrs->##counter)


//
// Structures to manipulate token, group, account info
//
typedef struct _ACCOUNT_INFO
{
	HACCT		hAcct;
	CHAR		szLoginName[AC_MAX_LOGIN_NAME_LENGTH+1];
	CHAR		szDomainName[AC_MAX_DOMAIN_NAME_LENGTH+1];	// reserved
	CHAR		szFirstName[AC_MAX_FIRST_NAME_LENGTH+1];
	CHAR		szLastName[AC_MAX_LAST_NAME_LENGTH+1];
	WORD		wAcctType;
	CHAR		szPassword[AC_MAX_PASSWORD_LENGTH+1];
	WORD		wAcctStatus;
	SYSTEMTIME  tmExpired;

} ACCOUNT_INFO, *PACCOUNT_INFO;

typedef struct _ACCOUNT_INFO_RIGHT
{
	HACCT		hAcct;
	CHAR		szLoginName[AC_MAX_LOGIN_NAME_LENGTH+1];
	CHAR		szFirstName[AC_MAX_FIRST_NAME_LENGTH+1];
	CHAR		szLastName[AC_MAX_LAST_NAME_LENGTH+1];
	AR			arRight;
	SYSTEMTIME  tmExpired;

} ACCOUNT_INFO_RIGHT, *PACCOUNT_INFO_RIGHT;


typedef struct _USER_GROUP
{
    HGROUP  hGroup;
    CHAR    szName[AC_MAX_GROUP_NAME_LENGTH];
} USER_GROUP, *PUSER_GROUP;

typedef struct _USER_GROUP_RIGHT
{
    HGROUP  	hGroup;
    CHAR    	szName[AC_MAX_GROUP_NAME_LENGTH+1];
	AR			arRight;
	SYSTEMTIME  tmExpired;

} USER_GROUP_RIGHT, *PUSER_GROUP_RIGHT;


typedef struct _USER_GROUP_DETAILS
{
    HGROUP  hGroup;
    CHAR    szName[AC_MAX_GROUP_NAME_LENGTH+1];
    TOKEN   token;
} USER_GROUP_DETAILS, *PUSER_GROUP_DETAILS;


typedef struct _TOKEN_DETAILS
{
    TOKEN   	token;
    CHAR    	szName[AC_MAX_TOKEN_NAME_LENGTH+1];
    CHAR    	szDesc[AC_MAX_TOKEN_DESC_LENGTH+1];
    HGROUP  	hOwnerGroup;

} TOKEN_DETAILS, *PTOKEN_DETAILS;

typedef struct _TOKEN_RIGHT
{
    TOKEN   	token;
	AR			arRight;
	SYSTEMTIME 	tmExpired;

} TOKEN_RIGHT, *PTOKEN_RIGHT;

typedef struct _ACCESS_PLAN
{
	CHAR	szName[AC_MAX_GROUP_NAME_LENGTH+1];
	HGROUP	hGroup;		// group id used as plan id
	HACCT	hAcct;		// proxy account for this group
	HACCT	hOwner;		// reserved for owner id
	TOKEN	token;
} ACCESS_PLAN, *PACCESS_PLAN;


//--------------------------------------------------------------------------------
//
// Prototypes of caller-defined callback functions passed into EnumXXXXEx API's
//
//--------------------------------------------------------------------------------
typedef UINT (__cdecl *PGROUPENUMPROC)( PUSER_GROUP pGroup, LPARAM lParam );
typedef UINT (__cdecl *PACCTENUMPROC)( PACCOUNT_INFO pAcct, LPARAM lParam );
typedef UINT (__cdecl *PTOKENENUMPROC)( PTOKEN_DETAILS pToken, LPARAM lParam );
typedef UINT (__cdecl *PTOKENRITENUMPROC)( PTOKEN_RIGHT pTokenRit, LPARAM lParam );
typedef UINT (__cdecl *PACCTRITENUMPROC)( PACCOUNT_INFO_RIGHT pAcctRit, LPARAM lParam );
typedef UINT (__cdecl *PGROUPRITENUMPROC)( PUSER_GROUP_RIGHT pGroupRit, LPARAM lParam );
typedef UINT (__cdecl *PPLANENUMPROC)( PACCESS_PLAN pPlan, LPARAM lParam );



extern "C"
{
BOOL ActlDLL 		FInitAccessLib(BOOL fCacheNeeded);
VOID ActlDLL		TerminateAccessLib();

UINT ActlDLL		UiResetAccessTuningBlock();
VOID ActlDLL		GetDefaultAccessTuningParam(PACCESS_TUNING pTuning);
UINT ActlDLL		UiSetAccessTuningBlock(PACCESS_TUNING pTuning);

PACCESS_STATISTICS	ActlDLL		
					GetAccessPerfmonBlock();

UINT ActlDLL			SetAccessPerfmonBlock(PACCESS_STATISTICS pStat);

UINT ActlDLL		UiRegisterAccessDB
						(
						CHAR *szServerName, 
						CHAR *szDBName, 
						CHAR *szLogin, 
						CHAR *szPassword,
						CHAR *szQryServerName, 
						CHAR *szQryDBName, 
						CHAR *szQryLogin, 
						CHAR *szQryPassword
						);

UINT ActlDLL		UiGetAccountRights(HACCT hAcct, TOKEN dwToken, AR *pRights);
UINT ActlDLL		UiGetValidationInfo
						( 
						CHAR	*szLoginName, 
						CHAR 	*szDomain,
						HACCT 	*phAcct, 
						WORD 	*pwAcctType,
						CHAR 	*szPassword, 
						WORD 	*pwStatus
						);

VOID ActlDLL		ReleaseUserCache(HACCT hAcct);
VOID ActlDLL		ReleaseGroupInCache(HGROUP hGroup);

UINT ActlDLL
AddAcct
	(
	PACCOUNT_INFO	pAcctInfo
	);

UINT ActlDLL
UpdateAcct
	(
	PACCOUNT_INFO	pAcctInfo
	);

UINT ActlDLL 
DeleteAcct
	(
	HACCT			hAcct
	);

UINT ActlDLL 
DeleteAcctByLogin
	(
	CHAR			*szLoginName
	);

UINT ActlDLL 
SetPassword
	(
	HACCT			hAcct,
	PCHAR			szOldPassword,
	PCHAR			szNewPassword
	);

UINT ActlDLL 
SetPasswordAdmin
	(
	HACCT			hAcct,
	PCHAR			szNewPassword
	);

UINT ActlDLL 
GetHandle
	(
	PCHAR			szLoginName,
	PHACCT			phAcct
	);

UINT ActlDLL 
GetAcctInfo
	(
	HACCT			hAcct,
	PACCOUNT_INFO	pAcctInfo
	);

UINT ActlDLL 
GetAcctPlan
	(
	HACCT			hAcct,
	PACCESS_PLAN	pPlan
	);

UINT ActlDLL  
EnumUserGroups
	( 
	PUSER_GROUP		pGroups, 
	DWORD 			cBuf, 
	LPDWORD 		pcTotal, 
	LPDWORD 		pcReturned
	);

UINT ActlDLL  
EnumUserGroupsEx
	( 
	PGROUPENUMPROC		lpGroupEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDLL   
GetUserGroupDetails 
	(
	HGROUP					hGroup, 
	PUSER_GROUP_DETAILS		pDetails 
	);

UINT ActlDLL  
FindUserGroup
	(
	PSTR					szName, 
	PUSER_GROUP_DETAILS		pDetails 
	);

UINT ActlDLL   
AddUserGroup 
	( 
	PUSER_GROUP_DETAILS		pDetails 
	);

UINT ActlDLL   
UpdateUserGroup 
	( 
	PUSER_GROUP_DETAILS		pDetails 
	);

UINT ActlDLL 
DeleteUserGroup
	(
	HGROUP		hGroup
	);


UINT ActlDLL  
EnumGroupMembers
	( 
	HGROUP			hGroup, 
	PACCOUNT_INFO	pAccts, 
	DWORD			cBuf, 
	LPDWORD			pcTotal, 
	LPDWORD			pcReturned
	);

UINT ActlDLL  
EnumGroupMembersEx
	( 
	HGROUP				hGroup, 
	PACCTENUMPROC		lpAcctEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDLL  
EnumGroupMembersExpire
	( 
	HGROUP			hGroup, 
	LPSYSTEMTIME	lptmExpired,
	PACCOUNT_INFO	pAccts, 
	DWORD			cBuf, 
	LPDWORD			pcTotal, 
	LPDWORD			pcReturned
	);

UINT ActlDLL  
EnumGroupMembersExpireEx
	( 
	HGROUP				hGroup, 
	LPSYSTEMTIME		lptmExpired,
	PACCTENUMPROC		lpAcctEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDLL   
AddAcctToGroup
	(
	HGROUP		hGroup, 
	HACCT		hAcct 
	);

UINT ActlDLL   
AddAcctToGroupExpire
	(
	HGROUP			hGroup, 
	HACCT			hAcct,
	LPSYSTEMTIME	lptmExpired
	);

UINT ActlDLL   
RemoveAcctFromGroup
	(
	HGROUP		hGroup,
	HACCT		hAcct 
	);

UINT ActlDLL   
RemoveExpiredAcctsFromGroup
	(
	HGROUP			hGroup
	);

UINT ActlDLL  
EnumTokens 
	( 
	PTOKEN_DETAILS	pTokens, 
	DWORD			cBuf, 
	LPDWORD			pcTotal, 
	LPDWORD			pcReturned
	);

UINT ActlDLL  
EnumTokensEx
	( 
	PTOKENENUMPROC	lpTokenEnumFunc, 
	LPARAM			lParam
	);

UINT ActlDLL   
CreateToken
	( 
	PTOKEN_DETAILS	pToken 
	);

UINT ActlDLL   
ModifyToken
	(
	PTOKEN_DETAILS	pToken 
	);

UINT ActlDLL   
DeleteToken
	(
	TOKEN	token 
	);

UINT ActlDLL 
EnumAcctPrivateTokens
	(
	HACCT					hAcct,
	AR						arRight,
	PTOKEN_RIGHT			pTokenRit,
	DWORD					cBuf,
	LPDWORD					pcTotal,
	LPDWORD					pcReturned
	);

UINT ActlDLL 
EnumAcctPrivateTokensEx
	(
	HACCT					hAcct,
	AR						arRight,
	PTOKENRITENUMPROC		lpTokenRitEnumFunc,
	LPARAM					lParam
	);

UINT ActlDLL  
EnumGroupsWithToken
	( 
	TOKEN					token, 
	PUSER_GROUP_RIGHT		pGroups, 
	DWORD					cBuf, 
	LPDWORD					pcTotal, 
	LPDWORD					pcReturned
	);

UINT ActlDLL  
EnumGroupsWithTokenEx
	( 
	TOKEN 				token, 
	PGROUPRITENUMPROC	lpGroupRitEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDLL  
EnumGroupsWithTokenExpire
	( 
	TOKEN					token, 
	LPSYSTEMTIME			lptmExpired,
	PUSER_GROUP_RIGHT		pGroups, 
	DWORD					cBuf, 
	LPDWORD					pcTotal, 
	LPDWORD					pcReturned
	);

UINT ActlDLL  
EnumGroupsWithTokenExpireEx
	( 
	TOKEN 				token, 
	LPSYSTEMTIME		lptmExpired,
	PGROUPRITENUMPROC	lpGroupRitEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDLL   
AddGroupToToken
	(
	TOKEN	token, 
	HGROUP	hGroup, 
	AR		wRights 
	);

UINT ActlDLL   
AddGroupToTokenExpire
	(
	TOKEN				token, 
	HGROUP				hGroup, 
	AR					wRights,
	LPSYSTEMTIME		lptmExpired
	);

UINT ActlDLL   
RemoveGroupFromToken
	(
	TOKEN	token, 
	HGROUP	hGroup 
	);

UINT ActlDLL   
RemoveExpiredGroupsFromToken
	(
	TOKEN			token 
	);

UINT ActlDLL  
EnumAcctsWithToken
	( 
	TOKEN				token,  							
	PACCOUNT_INFO_RIGHT	pAcctRits, 		
	DWORD				cBuf, 					
	LPDWORD				pcTotal, 			
	LPDWORD				pcReturned		
	);

UINT ActlDLL  
EnumAcctsWithTokenEx
	( 
	TOKEN				token, 
	PACCTRITENUMPROC	lpAcctRitEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDLL  
EnumAcctsWithTokenExpire
	( 
	TOKEN				token,  							
	LPSYSTEMTIME		lptmExpired,
	PACCOUNT_INFO_RIGHT	pAcctRits, 		
	DWORD				cBuf, 					
	LPDWORD				pcTotal, 			
	LPDWORD				pcReturned		
	);

UINT ActlDLL  
EnumAcctsWithTokenExpireEx
	( 
	TOKEN				token, 
	LPSYSTEMTIME		lptmExpired,
	PACCTRITENUMPROC	lpAcctRitEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDLL   
AddAcctToToken 
	(
	TOKEN	token, 
	HACCT 	hAcct, 
	AR		arRights
	);

UINT ActlDLL   
AddAcctToTokenExpire 
	(
	TOKEN				token, 
	HACCT 				hAcct, 
	AR					arRights,
	LPSYSTEMTIME		lptmExpired
	);

UINT ActlDLL   
RemoveAcctFromToken 
	(
	TOKEN	token, 
	HACCT	hAcct
	);

UINT ActlDLL   
RemoveExpiredAcctsFromToken 
	(
	TOKEN			token 
	);

UINT ActlDLL   
GetTokenDetails
	(
	TOKEN			token, 
	PTOKEN_DETAILS	pDetails
	);

UINT ActlDLL   
TokenIdFromTokenName
	(
	PSTR	szName, 
	TOKEN 	*ptoken 
	);

UINT ActlDLL   
UiIsAccountInGroup
	(
	HACCT	hAcct, 
	HGROUP	hGroup,
	PBOOL	pfRet
	);

UINT ActlDLL  
EnumExcludedAccts
	( 
	TOKEN 				token,  
	PACCOUNT_INFO_RIGHT pAcctRits, 
	DWORD 				cBuf, 
	LPDWORD 			pcTotal, 
	LPDWORD 			pcReturned
	);

UINT ActlDLL  
EnumExcludedAcctsEx
	( 
	TOKEN 				token, 
	PACCTRITENUMPROC 	lpAcctRitEnumFunc, 
	LPARAM 				lParam
	);

UINT ActlDLL  
AddExclusion 
	(
	TOKEN token, 
	HACCT hAcct
	);

UINT ActlDLL   
AddExclusionEx 
	(
	TOKEN	token, 
	HACCT 	hAcct, 
	AR 		arRights
	);

UINT ActlDLL   
RemoveExclusion 
	(
	TOKEN token, 
	HACCT hAcct
	);

UINT ActlDLL   
GetMaxTokenId 
	(
	PTOKEN plMaxTokenId 
	);


BOOL ActlDLL
IsLegalPassword
	(
	CHAR *szOldPassword,
	CHAR *szNewPassword
	);

BOOL ActlDLL
IsLegalLoginName
	(
	CHAR *szLoginName
	);


UINT ActlDLL
AddAccessPlan
	(
	PACCESS_PLAN	pPlan
	);

UINT ActlDLL
DeleteAccessPlan
	(
	HGROUP			hGroup
	);

UINT ActlDLL
UpdateAccessPlan
	(
	PACCESS_PLAN	pPlan
	);

UINT ActlDLL  
EnumAccessPlans
	( 
	PACCESS_PLAN	pPlan,
	DWORD			cBuf, 
	LPDWORD			pcTotal, 
	LPDWORD			pcReturned
	);

UINT ActlDLL  
EnumAccessPlansEx
	( 
	PPLANENUMPROC		lpPlanEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDLL
SearchAccts
    (
    ACCOUNT_INFO    *pAccts, 
    DWORD           cBuf,
    LPDWORD         pcTotal,
    LPDWORD         pcReturned,
	LPCSTR			szLogin,
	BOOL			fForward
    );

UINT ActlDLL
SearchUserGroups
    (
    PUSER_GROUP_DETAILS     pGroupsDetails,
    DWORD           cBuf,
    LPDWORD         pcTotal,
    LPDWORD         pcReturned,
	LPCSTR			szGroupName,
	BOOL			fForward
    );

UINT ActlDLL
SearchGroupMembers
    ( 
    HGROUP          hGroup, 
    ACCOUNT_INFO    *pAccts, 
    DWORD           cBuf, 
    LPDWORD         pcTotal, 
    LPDWORD         pcReturned,
    LPCSTR          szGroupMemberName,
    BOOL            fForward
    );

UINT ActlDLL
SearchTokens 
    ( 
    TOKEN_DETAILS   *pTokenDetails, 
    DWORD           cBuf, 
    LPDWORD         pcTotal, 
    LPDWORD         pcReturned,
    LPCSTR          szTokenName,
    BOOL            fForward
    );

UINT ActlDLL
SearchGroupsWithToken
    ( 
    TOKEN                   token, 
    USER_GROUP_RIGHT        *pGroups, 
    DWORD                   cBuf, 
    LPDWORD                 pcTotal, 
    LPDWORD                 pcReturned,
    LPCSTR                  szGroupName,
    BOOL                    fForward
    );

UINT ActlDLL
SearchAcctsWithToken
    ( 
    TOKEN               token,                              
    ACCOUNT_INFO_RIGHT  *pAcctRits,         
    DWORD               cBuf,                   
    LPDWORD             pcTotal,            
    LPDWORD             pcReturned,
    LPCSTR              szAcctName,
    BOOL                fForward
    );

UINT ActlDLL
SearchExcludedAccts
    ( 
    TOKEN                   token,  
    ACCOUNT_INFO_RIGHT      *pAcctRits, 
    DWORD                   cBuf, 
    LPDWORD                 pcTotal, 
    LPDWORD                 pcReturned,
    LPCSTR                  szAcctName,
    BOOL                    fForward
    );

UINT ActlDLL
SearchExcludedAcctsWithToken
    ( 
    TOKEN                   token,  
    ACCOUNT_INFO_RIGHT      *pAcctRits, 
    DWORD                   cBuf, 
    LPDWORD                 pcTotal, 
    LPDWORD                 pcReturned,
    LPCSTR                  szAcctName,
    BOOL                    fForward
    );

UINT ActlDLL
SearchAccessPlans
    ( 
    PACCESS_PLAN			pPlans,
    DWORD                   cBuf, 
    LPDWORD                 pcTotal, 
    LPDWORD                 pcReturned,
    LPCSTR                  szPlanName,
    BOOL                    fForward
    );

UINT ActlDLL
TotalAccts
    ( 
    LPDWORD         pcTotal
    );

UINT ActlDLL
TotalUserGroups
    ( 
    LPDWORD         pcTotal
    );

UINT ActlDLL
TotalGroupMembers
    ( 
    HGROUP          hGroup, 
    LPDWORD         pcTotal
    );

UINT ActlDLL
TotalTokens 
    ( 
    LPDWORD         pcTotal
    );

UINT ActlDLL
TotalGroupsWithToken
    ( 
    TOKEN                   token, 
    LPDWORD                 pcTotal
    );

UINT ActlDLL
TotalAcctsWithToken
    ( 
    TOKEN               token,                              
    LPDWORD             pcTotal         
    );

UINT ActlDLL
TotalExcludedAccts
    ( 
    TOKEN                   token,  
    LPDWORD                 pcTotal
    );

UINT ActlDLL
TotalExcludedAcctsWithToken
    ( 
    TOKEN                   token,  
    LPDWORD                 pcTotal
    );

}	//----- end of extern "C" ------


#endif // #if !defined(__ACTLAPI_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\acntdefs.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       acntdefs.h
//
//  Contents:   IAcceptNotify interface helper enums and structs
//
//  Classes:
//
//  Functions:
//
//  History:    2-22-96   Dmitriy Meyerzon   Created
//				4-26-96   SSanu   			 Ssync'd to latest spec
//
//----------------------------------------------------------------------------

cpp_quote("#ifndef __ACNTDEFS_H")
cpp_quote("#define __ACNTDEFS_H")
typedef struct tagNOTIFYDATA
{
	DWORD dwDataType;
	unsigned long cbData;	//size of any extra data
	[size_is(cbData)]	unsigned char * pvData; //extra data
}  NOTIFYDATA;

typedef enum tagANDchAdvise
{
	AND_ADD = 0x1,		//this has been added
	AND_DELETE = 0x2,	//this has been deleted
	AND_MODIFY = 0x4,	//this has been modified
	ANDM_ADVISE_ACTION = 0x7, //include add, delete or modify

	AND_TREATASDEEP =  0x100,     //directory or other container

	AND_DELETE_WHEN_DONE = 0x200, //delete content after processing notification

	ANDF_DATAINLINE = 0x20000,	//the notification has all the data inline
	
} ANDchAdvise;

typedef enum tagANMMapping
{
	ANM_ADD = 0x1,		//add this mapping
	ANM_DELETE = 0x2,	//delete this mapping
	ANM_MODIFY = 0x4,	//modify this mapping

	ANM_PHYSICALTOLOGICAL = 0x10, //use this to map from physical to logical
	ANM_LOGICALTOPHYSICAL = 0x20, //use this to map from logical to physical

} ANDMapping;


//all states may not be supported by all notifiers
typedef enum tagANSStatus
{
	NSS_START,		//normal state, sending notifications
	NSS_BEGINBATCH,	//At the start of a batch of notifications
	NSS_INBATCH,		//Within a batch of notifications
	NSS_ENDBATCH,		//Done with a batch of notifications
	NSS_PAUSE,		//Paused notification, still processing incoming
	NSS_STOP,		//stopped, not processing incoming or sending notifications

	NSS_PAUSEPENDING = 0x10000,	//pending change to pause
	NSS_STOPPENDING = 0x20000	//pending change to stop
} ANSStatus;	



cpp_quote("#endif")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\acsctl.h ===
//>-------------------------------------------------------------------------------<
//
//  File:		Acsctl.h
//
//  Synopsis:	The common headers for actlcach.dll and actldb.dll
//
//  History:	DanielLI	Created				06/19/95
//
//   			Copyright (C) 1994-1996 Microsoft Corporation
//				All rights reserved
//
//>-------------------------------------------------------------------------------<


#if !defined(__ACSCTL_H__)
#define __ACSCTL_H__

#if !defined(DllExport)

#define DllExport __declspec(dllexport)
#endif

#if !defined(DllImport)
#define DllImport __declspec(dllimport)

#endif

#include <dbsqltyp.h>
#include <dbsqldef.h>

//
// "rights" bits attached to security tokens
//

#define AR_VIEWER                                       0x01
#define AR_OBSERVER                                     0x02
#define AR_USER                                         0x04
#define AR_HOST                                         0x08
#define AR_SYSOP                                        0x10
#define AR_SYSOPMGR                                     0x20
#define AR_SUPERSYSOP                                   0x40
#define AR_FAIL_ON_TOLL_FREE                            0x80
#define AR_DIAGNOSTIC                                   0x100


#define AC_MAX_SQL_SYSNAME_LENGTH						30
#define AC_MAX_SERVER_NAME_LENGTH						AC_MAX_SQL_SYSNAME_LENGTH
#define AC_MAX_DBNAME_LENGTH							AC_MAX_SQL_SYSNAME_LENGTH
#define AC_MAX_DBLOGIN_LENGTH							AC_MAX_SQL_SYSNAME_LENGTH
#define AC_MAX_DBPASSWORD_LENGTH						AC_MAX_SQL_SYSNAME_LENGTH

#define AC_MIN_SQL_SYSNAME_LENGTH						1
#define AC_MIN_SERVER_NAME_LENGTH						AC_MIN_SQL_SYSNAME_LENGTH
#define AC_MIN_DBNAME_LENGTH							AC_MIN_SQL_SYSNAME_LENGTH
#define AC_MIN_DBLOGIN_LENGTH							AC_MIN_SQL_SYSNAME_LENGTH
#define AC_MIN_DBPASSWORD_LENGTH						AC_MIN_SQL_SYSNAME_LENGTH

//
// rights_adding_flags for AddAcctToTokenExpire and AddGroupToTokenExpire
//

typedef enum _RIGHTS_ADDING_FLAG
{
	RIGHTS_UNION	= 	0,
	RIGHTS_REPLACE	= 	1,
	RIGHTS_UNCHANGE =	2

} RIGHTS_ADDING_FLAG;

//
// The current MSN 1.3 has a physical limitation on number of query servers: 256,
// since a tinyint is used. Per ParikRao, MOSWEST is going to use two Account query
// servers eventually. Given 1M users in MSN, and Normandy is targetting 10M users,
// the limit of 256 is very very unlikely to be reached. Let's maintain the same
// limit here.
//
#define	AC_MAX_QUERY_SERVERS							256

//
// The following error codes defined in dbsqldef.h
//
/*
#define AC_SUCCESS								0
#define AC_VALID_ACCOUNT                        0
#define AC_DB_FAILED                            1
#define AC_ACCOUNT_NOT_FOUND					2
#define AC_INVALID_PASSWORD                     3
#define AC_BAD_PARAM                            4
#define AC_SEM_FAILED                           5
#define AC_CONNECT_FAILED                       6
#define AC_MUTEX_FAILED                         7
#define AC_MISSING_DATA                         8
#define AC_ILLEGAL_PASSWORD                     9
#define AC_INVALID_ACCOUNT                      10
#define AC_NOMORE_CONNECTIONS					11
#define AC_NEW_ACCOUNT                          12
#define AC_LOCKED_ACCOUNT                       13
#define AC_ILLEGAL_NAME                         14
#define AC_OUT_OF_MEMORY                        15
#define AC_TOO_MANY_ROWS                        16
#define AC_BANNED_PERSON                        17
#define AC_GROUP_NOT_FOUND                      18
#define AC_UPDATE_FAILED                        19
#define AC_DELETE_FAILED                        20
#define AC_TOKEN_NOT_FOUND                      21
#define AC_ALREADY_CONNECTED					22
#define AC_ACCESS_DENIED                        23
#define AC_OWNER_NOT_FOUND						24
#define AC_OWNER_UPDATE_FAILED					25
#define AC_ILLEGAL_LOGIN_NAME					26
#define AC_ILLEGAL_PASSWORD_SIMILAR				27
#define AC_ILLEGAL_PASSWORD_CHARS				28
#define AC_DUPLICATE_LOGIN_NAME					29
#define AC_INVALID_SUB_PLAN						30
#define AC_INVALID_PAYMENT_METHOD				31
#define AC_DUPLICATE_ENTRY						32
#define AC_TIMED_OUT							33
#define AC_THROTTLED							34
#define AC_OLDSYSTEM							35
#define AC_SBS									36
#define AC_NO_FREE_TRIAL_PERIOD					37
#define AC_CANCELLED							38
#define AC_RESUBMIT								39
#define AC_NOT_FOUND							40
#define AC_CYCLIC_DISTLIST						41
#define AC_BP_DEFEND_ERROR						42
#define AC_NO_MORE_RESULTS						43
#define AC_NO_MORE_ROWS							44
#define AC_INVALID_DOMAIN_NAME					45
#define AC_NAME_NOT_UNIQUE                      46


#define AC_BAD_HANDLE                           0xFFFFFFFF
*/

// 
// Additional error codes needed for A&A security DB
//
#define AC_INVALID_ACCT_STATUS					20001
#define AC_INVALID_ACCT_TYPE					20002


#endif // #if !defined(__ACSCTL_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\actlcach.h ===
//>-------------------------------------------------------------------------------<
//
//  File:		Actlcach.h
//
//  Synopsis:	UiGetAccountRights, UiGetValidationInfo
//
//  History:	KeithBi		Created				09/29/95
//  			DanielLi	Modified			04/26/96
//
//   			Copyright (C) 1994-1996 Microsoft Corporation
//				All rights reserved
//
//>-------------------------------------------------------------------------------<


#if !defined(__ACTLCACH_H__)
#define __ACTLCACH_H__

#include <acsctl.h>

#if !defined(_ACTL_DLL_DEFINED)
#if defined(WIN32)
    #if defined(_ACTLDLL)
	#define ActlDLL DllExport __stdcall
    #else
	#define ActlDLL DllImport __stdcall
    #endif
#else
    #define ActlDLL
#endif
#define _ACTL_DLL_DEFINED
#endif

//--------------------------------------------------------------------------------
//
// Adjustable parameters
//
//--------------------------------------------------------------------------------
typedef struct _ACCESS_TUNING
{
	//
	// max number of user caches; default is: 100K
	//
	DWORD	dwMaxUserCaches;
	//
	// the beginning instance size of CPool list, in the power of 2, so, the actual
	// size is : 2^dwFirstCPool; default is: 7 (128 bytes)
	//
	DWORD	dwFirstPoolSize;
	//
	// the number of CPool in the CPool list; default is: 5 
	//
	DWORD	dwPoolSteps;


} ACCESS_TUNING, *PACCESS_TUNING;

//--------------------------------------------------------------------------------
//
// Performance counters 
//
//--------------------------------------------------------------------------------
typedef struct _ACCESS_STATISTICS
{

	//
	// number of times UiGetAccountRights got called
	//
	DWORD	dwGetAccountRights;
	//
	// number of times UiGetAccountRights failed
	//
	DWORD	dwGetAccountRightsFailures;
	//
	// number of times UiGetAccountRigts failed due to query timeout
	//
	DWORD	dwGetAccountRightsTimeout;

	DWORD	dwGetValidationInfo;
	DWORD	dwGetValidationInfoFailures;

	//
	// number of times Security DB query (sp_get_tokens_and_groups) is issued to 
	// refresh the user cache
	//
	DWORD	dwNumDBQueriesForCache;

	//
	// number of times the user cache is added into the cache pool
	//
	DWORD	dwNumUserCacheAdded;
	//
	// number of times the user cache is released from the cache pool
	//
	DWORD	dwNumUserCacheReleased;

	//
	// number of times CDBUserCache::operator new() got called 
	//
	DWORD	dwNewUserCache;
	//
	// number of times CDBUserCache::operator delete() got called 
	//
	DWORD	dwDeleteUserCache;

	//
	// number of times token-group cache allocated (one token-group cache per CDBUserCache)
	//
	DWORD	dwAllocTokenGroupCache;
	//
	// number of token-group cache allocated (one token-group cache per CDBUserCache)
	//
	DWORD	dwFreeTokenGroupCache;

	//
	// number of times the plan list is refreshed (GetPlans)
	//
	DWORD	dwNumPlanListRefreshed;
	//
	// number of times GetPlanRightsOnToken is called
	//
	DWORD	dwGetPlanRightsOnToken;


} ACCESS_STATISTICS, *PACCESS_STATISTICS;


#define INC_ACCESS_COUNTER(counter)		(InterlockedIncrement((LPLONG)&g_statAccess.##counter))
#define DEC_ACCESS_COUNTER(counter)		(InterlockedDecrement((LPLONG)&g_statAccess.##counter))


extern "C"
{
BOOL ActlDLL 		FInitAccessLib();
VOID ActlDLL		TerminateAccessLib();

UINT ActlDLL		UiResetAccessTuningBlock();
VOID ActlDLL		GetDefaultAccessTuningParam(PACCESS_TUNING pTuning);
UINT ActlDLL		UiSetAccessTuningBlock(PACCESS_TUNING pTuning);

UINT ActlDLL		UiGetAccessPerfmonBlock(PACCESS_STATISTICS *ppStat);

UINT ActlDLL		UiRegisterAccessDB(CHAR *szServerName, CHAR *szDBName, CHAR *szLogin, CHAR *szPassword);

UINT ActlDLL		UiGetAccountRights(HACCT hAcct, TOKEN dwToken, AR *pRights);
UINT ActlDLL		UiGetValidationInfo
						( 
						CHAR	*szLoginName, 
						CHAR 	*szDomain,
						HACCT 	*phAcct, 
						WORD 	*pwAcctType,
						CHAR 	*szPassword, 
						WORD 	*pwStatus
						);

VOID ActlDLL		ReleaseUserCache(HACCT hAcct);
VOID ActlDLL		ReleaseGroupInCache(HGROUP hGroup);

}	//----- end of extern "C" ------


#endif // #if !defined(__ACTLCACH_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\actldb.h ===
//>-------------------------------------------------------------------------------<
//
//  File:		Actldb.h
//
//  Synopsis:	All defs and declarations for actldb.cpp, including the following
//				sysop API's for accout/group/token maintenance in security DB:
//
//					AddAcct
//					DeleteAcct
//					DeleteAcctByLogin
//					SetPassword
//					GetHandle
//					GetAcctInfo
//
//					EnumUserGroups 
//					EnumUserGroupsEx 
//					GetUserGroupDetails 
//					FindUserGroup
//					AddUserGroup 
//					UpdateUserGroup
//					DeleteUserGroup 
//					EnumGroupMembers 
//					EnumGroupMembersEx
//					EnumGroupMembersExpire 
//					EnumGroupMembersExpireEx
//					AddAcctToGroup
//					AddAcctToGroupExpire 
//					RemoveAcctFromGroup 
//					RemoveExpiredAcctsFromGroup 
//					
//					EnumTokens
//					EnumTokensEx
//					CreateToken
//					ModifyToken
//					DeleteToken
//					EnumAcctPrivateTokens
//					EnumAcctPrivateTokensEx
//					EnumGroupsWithToken
//					EnumGroupsWithTokenEx
//					EnumGroupsWithTokenExpire
//					EnumGroupsWithTokenExpireEx
//					AddGroupToToken
//					AddGroupToTokenExpire
//					EnumAcctsWithToken
//					RemoveGroupFromToken
//					RemoveExpiredGroupsFromToken
//					EnumAcctsWithToken
//					EnumAcctsWithTokenEx
//					EnumAcctsWithTokenExpire
//					EnumAcctsWithTokenExpireEx
//					AddAcctToToken
//					AddAcctToTokenExpire
//					RemoveAcctFromToken 
//					RemoveExpiredAcctsFromToken 
//					GetTokenDetails
//					TokenIdFromTokenName
//					UiIsAccountInGroup
//					EnumExcludedAccts 
//					EnumExcludedAcctsEx 
//					AddExclusion 
//					AddExclusionEx 
//					RemoveExclusion 
//					GetMaxTokenId 
//
//					AddAccessPlan
//					UpdateAccessPlan
//					DeleteAccessPlan
//					EnumAccessPlans
//					EnumAccessPlansEx
//
//					SearchAcctsWithToken
//					SearchExcludedAcctsWithToken
//					SearchGroupMembers
//					SearchGroupsWithToken
//					SearchTokens
//					SearchUserGroups
//					TotalAcctsWithToken
//					TotalExcludedAcctsWithToken
//					TotalGroupMembers
//					TotalGroupsWithToken
//					TotalTokens
//					TotalUserGroups
//
//  History:	DanielLi   Ported to 2.x tree	03/22/96
//
//   			Copyright (C) 1994-1996 Microsoft Corporation
//				All rights reserved
//
//>-------------------------------------------------------------------------------<

#if !defined(__ACTLDB_H__)
#define __ACTLDB_H__

#include <acsctl.h>

#if !defined(_ACTLDB_DLL_DEFINED)
#if defined(WIN32)
    #if defined(_ACTLDBDLL)
	#define ActlDBDLL DllExport __stdcall
    #else
	#define ActlDBDLL DllImport __stdcall
    #endif
#else
    #define ActlDBDLL
#endif
#define _ACTLDB_DLL_DEFINED
#endif


//
// Structures to manipulate token, group, account info
//
typedef struct _ACCOUNT_INFO
{
	HACCT		hAcct;
	CHAR		szLoginName[AC_MAX_LOGIN_NAME_LENGTH+1];
	CHAR		szDomainName[AC_MAX_DOMAIN_NAME_LENGTH+1];	// reserved
	CHAR		szFirstName[AC_MAX_FIRST_NAME_LENGTH+1];
	CHAR		szLastName[AC_MAX_LAST_NAME_LENGTH+1];
	WORD		wAcctType;
	CHAR		szPassword[AC_MAX_PASSWORD_LENGTH+1];
	WORD		wAcctStatus;
	SYSTEMTIME  tmExpired;

} ACCOUNT_INFO, *PACCOUNT_INFO;

typedef struct _ACCOUNT_INFO_RIGHT
{
	HACCT		hAcct;
	CHAR		szLoginName[AC_MAX_LOGIN_NAME_LENGTH+1];
	CHAR		szFirstName[AC_MAX_FIRST_NAME_LENGTH+1];
	CHAR		szLastName[AC_MAX_LAST_NAME_LENGTH+1];
	AR			arRight;
	SYSTEMTIME  tmExpired;

} ACCOUNT_INFO_RIGHT, *PACCOUNT_INFO_RIGHT;


typedef struct _USER_GROUP
{
    HGROUP  hGroup;
    CHAR    szName[AC_MAX_GROUP_NAME_LENGTH];
} USER_GROUP, *PUSER_GROUP;

typedef struct _USER_GROUP_RIGHT
{
    HGROUP  	hGroup;
    CHAR    	szName[AC_MAX_GROUP_NAME_LENGTH+1];
	AR			arRight;
	SYSTEMTIME  tmExpired;

} USER_GROUP_RIGHT, *PUSER_GROUP_RIGHT;


typedef struct _USER_GROUP_DETAILS
{
    HGROUP  hGroup;
    CHAR    szName[AC_MAX_GROUP_NAME_LENGTH];
    TOKEN   token;
} USER_GROUP_DETAILS, *PUSER_GROUP_DETAILS;


typedef struct _TOKEN_DETAILS
{
    TOKEN   	token;
    CHAR    	szName[AC_MAX_TOKEN_NAME_LENGTH+1];
    CHAR    	szDesc[AC_MAX_TOKEN_DESC_LENGTH+1];
    HGROUP  	hOwnerGroup;

} TOKEN_DETAILS, *PTOKEN_DETAILS;

typedef struct _TOKEN_RIGHT
{
    TOKEN   	token;
	AR			arRight;
	SYSTEMTIME 	tmExpired;

} TOKEN_RIGHT, *PTOKEN_RIGHT;

typedef struct _ACCESS_PLAN
{
	HGROUP	hGroup;		// group id used as plan id
	HACCT	hAcct;		// proxy account for this group
	HACCT	hOwner;		// reserved for owner id
} ACCESS_PLAN, *PACCESS_PLAN;


//--------------------------------------------------------------------------------
//
// Prototypes of caller-defined callback functions passed into EnumXXXXEx API's
//
//--------------------------------------------------------------------------------
typedef UINT (__cdecl *PGROUPENUMPROC)( PUSER_GROUP pGroup, LPARAM lParam );
typedef UINT (__cdecl *PACCTENUMPROC)( PACCOUNT_INFO pAcct, LPARAM lParam );
typedef UINT (__cdecl *PTOKENENUMPROC)( PTOKEN_DETAILS pToken, LPARAM lParam );
typedef UINT (__cdecl *PTOKENRITENUMPROC)( PTOKEN_RIGHT pTokenRit, LPARAM lParam );
typedef UINT (__cdecl *PACCTRITENUMPROC)( PACCOUNT_INFO_RIGHT pAcctRit, LPARAM lParam );
typedef UINT (__cdecl *PGROUPRITENUMPROC)( PUSER_GROUP_RIGHT pGroupRit, LPARAM lParam );
typedef UINT (__cdecl *PPLANENUMPROC)( PACCESS_PLAN pPlan, LPARAM lParam );

//--------------------------------------------------------------------------------
//
// Performance counters 
//
//--------------------------------------------------------------------------------
typedef struct _SECURITY_STATISTICS
{
	//
	// number of AddAcct are called
	//
	DWORD		dwAddAcct;
	//
	// number of AddAcct failed
	//
	DWORD		dwAddAcctFailures;

	DWORD		dwDeleteAcct;
	DWORD		dwDeleteAcctFailures;

	DWORD		dwSetPassword;
	DWORD		dwSetPasswordFailures;

	DWORD		dwGetHandle;
	DWORD		dwGetHandleFailures;

	DWORD		dwAddAcctToToken;
	DWORD		dwAddAcctToTokenFailures;

	DWORD		dwRemoveAcctFromToken;
	DWORD		dwRemoveAcctFromTokenFailures;

	DWORD		dwGetTokenDetails;
	DWORD		dwGetTokenDetailsFailures;

	DWORD		dwEnumAcctPrivateTokens;
	DWORD		dwEnumAcctPrivateTokensFailures;

	DWORD		dwGetAcctInfo;
	DWORD		dwGetAcctInfoFailures;

} SECURITY_STATISTICS, *PSECURITY_STATISTICS;


#define INC_SECURITY_COUNTER(counter)		(InterlockedIncrement((LPLONG)&g_statSecurity.##counter))
#define DEC_SECURITY_COUNTER(counter)		(InterlockedDecrement((LPLONG)&g_statSecurity.##counter))


extern "C"
{
BOOL ActlDBDLL 		FInitSecurityLib(BOOL fCacheExisted);
VOID ActlDBDLL		TerminateSecurityLib();

UINT ActlDBDLL		UiGetSecurityPerfmonBlock(PSECURITY_STATISTICS *ppStat);

UINT ActlDBDLL		UiRegisterSecurityDB(CHAR *szServerName, CHAR *szDBName, CHAR *szLogin, CHAR *szPassword);

UINT ActlDBDLL
AddAcct
	(
	PACCOUNT_INFO	pAcctInfo
	);

UINT ActlDBDLL 
DeleteAcct
	(
	HACCT			hAcct
	);

UINT ActlDBDLL 
DeleteAcctByLogin
	(
	CHAR			*szLoginName
	);

UINT ActlDBDLL 
SetPassword
	(
	HACCT			hAcct,
	PCHAR			szOldPassword,
	PCHAR			szNewPassword
	);

UINT ActlDBDLL 
GetHandle
	(
	PCHAR			szLoginName,
	PHACCT			phAcct
	);

UINT ActlDBDLL 
GetAcctInfo
	(
	HACCT			hAcct,
	PACCOUNT_INFO		pAcctInfo
	);

UINT ActlDBDLL  
EnumUserGroups
	( 
	PUSER_GROUP		pGroups, 
	DWORD 			cBuf, 
	LPDWORD 		pcTotal, 
	LPDWORD 		pcReturned
	);

UINT ActlDBDLL  
EnumUserGroupsEx
	( 
	PGROUPENUMPROC		lpGroupEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDBDLL   
GetUserGroupDetails 
	(
	HGROUP					hGroup, 
	PUSER_GROUP_DETAILS		pDetails 
	);

UINT ActlDBDLL  
FindUserGroup
	(
	PSTR					szName, 
	PUSER_GROUP_DETAILS		pDetails 
	);

UINT ActlDBDLL   
AddUserGroup 
	( 
	PUSER_GROUP_DETAILS		pDetails 
	);

UINT ActlDBDLL   
UpdateUserGroup 
	( 
	PUSER_GROUP_DETAILS		pDetails 
	);

UINT ActlDBDLL 
DeleteUserGroup
	(
	HGROUP		hGroup
	);


UINT ActlDBDLL  
EnumGroupMembers
	( 
	HGROUP			hGroup, 
	PACCOUNT_INFO	pAccts, 
	DWORD			cBuf, 
	LPDWORD			pcTotal, 
	LPDWORD			pcReturned
	);

UINT ActlDBDLL  
EnumGroupMembersEx
	( 
	HGROUP				hGroup, 
	PACCTENUMPROC		lpAcctEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDBDLL  
EnumGroupMembersExpire
	( 
	HGROUP			hGroup, 
	LPSYSTEMTIME	lptmExpired,
	PACCOUNT_INFO	pAccts, 
	DWORD			cBuf, 
	LPDWORD			pcTotal, 
	LPDWORD			pcReturned
	);

UINT ActlDBDLL  
EnumGroupMembersExpireEx
	( 
	HGROUP				hGroup, 
	LPSYSTEMTIME		lptmExpired,
	PACCTENUMPROC		lpAcctEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDBDLL   
AddAcctToGroup
	(
	HGROUP		hGroup, 
	HACCT		hAcct 
	);

UINT ActlDBDLL   
AddAcctToGroupExpire
	(
	HGROUP			hGroup, 
	HACCT			hAcct,
	LPSYSTEMTIME	lptmExpired
	);

UINT ActlDBDLL   
RemoveAcctFromGroup
	(
	HGROUP		hGroup,
	HACCT		hAcct 
	);

UINT ActlDBDLL   
RemoveExpiredAcctsFromGroup
	(
	HGROUP			hGroup
	);

UINT ActlDBDLL  
EnumTokens 
	( 
	PTOKEN_DETAILS	pTokens, 
	DWORD			cBuf, 
	LPDWORD			pcTotal, 
	LPDWORD			pcReturned
	);

UINT ActlDBDLL  
EnumTokensEx
	( 
	PTOKENENUMPROC	lpTokenEnumFunc, 
	LPARAM			lParam
	);

UINT ActlDBDLL   
CreateToken
	( 
	PTOKEN_DETAILS	pToken 
	);

UINT ActlDBDLL   
ModifyToken
	(
	PTOKEN_DETAILS	pToken 
	);

UINT ActlDBDLL   
DeleteToken
	(
	TOKEN	token 
	);

UINT ActlDBDLL 
EnumAcctPrivateTokens
	(
	HACCT					hAcct,
	AR						arRight,
	PTOKEN_RIGHT			pTokenRit,
	DWORD					cBuf,
	LPDWORD					pcTotal,
	LPDWORD					pcReturned
	);

UINT ActlDBDLL 
EnumAcctPrivateTokensEx
	(
	HACCT					hAcct,
	AR						arRight,
	PTOKENRITENUMPROC		lpTokenRitEnumFunc,
	LPARAM					lParam
	);

UINT ActlDBDLL  
EnumGroupsWithToken
	( 
	TOKEN					token, 
	PUSER_GROUP_RIGHT		pGroups, 
	DWORD					cBuf, 
	LPDWORD					pcTotal, 
	LPDWORD					pcReturned
	);

UINT ActlDBDLL  
EnumGroupsWithTokenEx
	( 
	TOKEN 				token, 
	PGROUPRITENUMPROC	lpGroupRitEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDBDLL  
EnumGroupsWithTokenExpire
	( 
	TOKEN					token, 
	LPSYSTEMTIME			lptmExpired,
	PUSER_GROUP_RIGHT		pGroups, 
	DWORD					cBuf, 
	LPDWORD					pcTotal, 
	LPDWORD					pcReturned
	);

UINT ActlDBDLL  
EnumGroupsWithTokenExpireEx
	( 
	TOKEN 				token, 
	LPSYSTEMTIME		lptmExpired,
	PGROUPRITENUMPROC	lpGroupRitEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDBDLL   
AddGroupToToken
	(
	TOKEN	token, 
	HGROUP	hGroup, 
	AR		wRights 
	);

UINT ActlDBDLL   
AddGroupToTokenExpire
	(
	TOKEN			token, 
	HGROUP			hGroup, 
	AR				wRights,
	LPSYSTEMTIME	lptmExpired
	);

UINT ActlDBDLL   
RemoveGroupFromToken
	(
	TOKEN	token, 
	HGROUP	hGroup 
	);

UINT ActlDBDLL   
RemoveExpiredGroupsFromToken
	(
	TOKEN			token 
	);

UINT ActlDBDLL  
EnumAcctsWithToken
	( 
	TOKEN				token,  							
	PACCOUNT_INFO_RIGHT	pAcctRits, 		
	DWORD				cBuf, 					
	LPDWORD				pcTotal, 			
	LPDWORD				pcReturned		
	);

UINT ActlDBDLL  
EnumAcctsWithTokenEx
	( 
	TOKEN				token, 
	PACCTRITENUMPROC	lpAcctRitEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDBDLL  
EnumAcctsWithTokenExpire
	( 
	TOKEN				token,  							
	LPSYSTEMTIME		lptmExpired,
	PACCOUNT_INFO_RIGHT	pAcctRits, 		
	DWORD				cBuf, 					
	LPDWORD				pcTotal, 			
	LPDWORD				pcReturned		
	);

UINT ActlDBDLL  
EnumAcctsWithTokenExpireEx
	( 
	TOKEN				token, 
	LPSYSTEMTIME		lptmExpired,
	PACCTRITENUMPROC	lpAcctRitEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDBDLL   
AddAcctToToken 
	(
	TOKEN	token, 
	HACCT 	hAcct, 
	AR		arRights
	);

UINT ActlDBDLL   
AddAcctToTokenExpire 
	(
	TOKEN			token, 
	HACCT 			hAcct, 
	AR				arRights,
	LPSYSTEMTIME	lptmExpired
	);

UINT ActlDBDLL   
RemoveAcctFromToken 
	(
	TOKEN	token, 
	HACCT	hAcct
	);

UINT ActlDBDLL   
RemoveExpiredAcctsFromToken 
	(
	TOKEN			token 
	);

UINT ActlDBDLL   
GetTokenDetails
	(
	TOKEN			token, 
	PTOKEN_DETAILS	pDetails
	);

UINT ActlDBDLL   
TokenIdFromTokenName
	(
	PSTR	szName, 
	TOKEN 	*ptoken 
	);

UINT ActlDBDLL   
UiIsAccountInGroup
	(
	HACCT	hAcct, 
	HGROUP	hGroup,
	PBOOL	pfRet
	);

UINT ActlDBDLL  
EnumExcludedAccts
	( 
	TOKEN 				token,  
	PACCOUNT_INFO_RIGHT pAcctRits, 
	DWORD 				cBuf, 
	LPDWORD 			pcTotal, 
	LPDWORD 			pcReturned
	);

UINT ActlDBDLL  
EnumExcludedAcctsEx
	( 
	TOKEN 				token, 
	PACCTRITENUMPROC 	lpAcctRitEnumFunc, 
	LPARAM 				lParam
	);

UINT ActlDBDLL  
AddExclusion 
	(
	TOKEN token, 
	HACCT hAcct
	);

UINT ActlDBDLL   
AddExclusionEx 
	(
	TOKEN	token, 
	HACCT 	hAcct, 
	AR 		arRights
	);

UINT ActlDBDLL   
RemoveExclusion 
	(
	TOKEN token, 
	HACCT hAcct
	);

UINT ActlDBDLL   
GetMaxTokenId 
	(
	PTOKEN plMaxTokenId 
	);


BOOL ActlDBDLL
IsLegalPassword
	(
	CHAR *szOldPassword,
	CHAR *szNewPassword
	);

BOOL ActlDBDLL
IsLegalLoginName
	(
	CHAR *szLoginName
	);


UINT ActlDBDLL
AddAccessPlan
	(
	PACCESS_PLAN	pPlan
	);

UINT ActlDBDLL
DeleteAccessPlan
	(
	HGROUP			hGroup
	);

UINT ActlDBDLL
UpdateAccessPlan
	(
	PACCESS_PLAN	pPlan
	);

UINT ActlDBDLL  
EnumAccessPlans
	( 
	PACCESS_PLAN	pPlan,
	DWORD			cBuf, 
	LPDWORD			pcTotal, 
	LPDWORD			pcReturned
	);

UINT ActlDBDLL  
EnumAccessPlansEx
	( 
	PPLANENUMPROC		lpPlanEnumFunc, 
	LPARAM				lParam
	);

UINT ActlDBDLL
SearchUserGroups
    (
    PUSER_GROUP_DETAILS     pGroupsDetails,
    DWORD           cBuf,
    LPDWORD         pcTotal,
    LPDWORD         pcReturned,
	LPCSTR			szGroupName,
	BOOL			fForward
    );

UINT ActlDBDLL
SearchGroupMembers
    ( 
    HGROUP          hGroup, 
    ACCOUNT_INFO    *pAccts, 
    DWORD           cBuf, 
    LPDWORD         pcTotal, 
    LPDWORD         pcReturned,
    LPCSTR          szGroupMemberName,
    BOOL            fForward
    );

UINT ActlDBDLL
SearchTokens 
    ( 
    TOKEN_DETAILS   *pTokenDetails, 
    DWORD           cBuf, 
    LPDWORD         pcTotal, 
    LPDWORD         pcReturned,
    LPCSTR          szTokenName,
    BOOL            fForward
    );

UINT ActlDBDLL
SearchGroupsWithToken
    ( 
    TOKEN                   token, 
    USER_GROUP_RIGHT        *pGroups, 
    DWORD                   cBuf, 
    LPDWORD                 pcTotal, 
    LPDWORD                 pcReturned,
    LPCSTR                  szGroupName,
    BOOL                    fForward
    );

UINT ActlDBDLL
SearchAcctsWithToken
    ( 
    TOKEN               token,                              
    ACCOUNT_INFO_RIGHT  *pAcctRits,         
    DWORD               cBuf,                   
    LPDWORD             pcTotal,            
    LPDWORD             pcReturned,
    LPCSTR              szAcctName,
    BOOL                fForward
    );

UINT ActlDBDLL
SearchExcludedAcctsWithToken
    ( 
    TOKEN                   token,  
    ACCOUNT_INFO_RIGHT      *pAcctRits, 
    DWORD                   cBuf, 
    LPDWORD                 pcTotal, 
    LPDWORD                 pcReturned,
    LPCSTR                  szAcctName,
    BOOL                    fForward
    );

UINT ActlDBDLL
TotalUserGroups
    ( 
    LPDWORD         pcTotal
    );

UINT ActlDBDLL
TotalGroupMembers
    ( 
    HGROUP          hGroup, 
    LPDWORD         pcTotal
    );

UINT ActlDBDLL
TotalTokens 
    ( 
    LPDWORD         pcTotal
    );

UINT ActlDBDLL
TotalGroupsWithToken
    ( 
    TOKEN                   token, 
    LPDWORD                 pcTotal
    );

UINT ActlDBDLL
TotalAcctsWithToken
    ( 
    TOKEN               token,                              
    LPDWORD             pcTotal         
    );

UINT ActlDBDLL
TotalExcludedAcctsWithToken
    ( 
    TOKEN                   token,  
    LPDWORD                 pcTotal
    );

} //---- end of extern "C" ---------


#endif // #if !defined(__ACTLDB_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\baseobj.h ===
/*==========================================================================*\

    Module:        baseobj.h

    Copyright Microsoft Corporation 1996, All Rights Reserved.

    Owner:         mikepurt

    Descriptions:  Provide OLE COM consistent reference counting.

\*==========================================================================*/


#ifndef __BASEOBJ_H__
#define __BASEOBJ_H__

#include "dbgtrace.h" //make sure we get _ASSERT

class CBaseObject {
public:
    CBaseObject()
    { m_lReferences = 1; };  // consistent with OLE COM
    
    virtual ~CBaseObject() {};
    
    // Included so the vtable is in a standard format ...
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(
          IID FAR& riid,
          LPVOID FAR* ppvObj) { return E_NOTIMPL; } 

    ULONG   AddRef()
    { return (ULONG)(InterlockedExchangeAdd(&m_lReferences, 1) + 1); };
    
    ULONG   Release() 
    {
        LONG lRef;
        
        lRef = InterlockedExchangeAdd(&m_lReferences, -1) - 1;
        
        _ASSERT(lRef >= 0);
        _ASSERT(lRef < 0x00100000);  // Sanity check against freed memory.
        
        if (0 == lRef)
            delete this;    // Don't touch any member vars after this.
        
        return (ULONG)lRef;
    };

protected:
    LONG m_lReferences;
        
    CBaseObject(CBaseObject&);  // Force an error in instances where a copy constructor
                                //   was needed, but none was provided.
};

#endif  // __BASEOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\align.h ===
/*++

Copyright (c) 1988-1992  Microsoft Corporation

Module Name:

    Align.h

Author:

    John Rogers (JohnRo) 15-May-1991

Environment:

    This code assumes that sizeof(DWORD_PTR) >= sizeof(LPVOID).

Revision History:

    15-May-1991 JohnRo
        Created align.h for NT/LAN from OS/2 1.2 HPFS pbmacros.h.
    19-Jun-1991 JohnRo
        Make sure pointer-to-wider-then-byte doesn't get messed up.
    10-Jul-1991 JohnRo
        Added ALIGN_BYTE and ALIGN_CHAR for completeness.
    21-Aug-1991 CliffV
        Fix ROUND_DOWN_* to include ~
    03-Dec-1991 JohnRo
        Worst-case on MIPS is 8-byte alignment.
        Added COUNT_IS_ALIGNED() and POINTER_IS_ALIGNED() macros.
    26-Jun-1992 JohnRo
        RAID 9933: ALIGN_WORST should be 8 for x86 builds.

--*/

#ifndef _ALIGN_
#define _ALIGN_


// BOOL
// COUNT_IS_ALIGNED(
//     IN DWORD Count,
//     IN DWORD Pow2      // undefined if this isn't a power of 2.
//     );
//
#define COUNT_IS_ALIGNED(Count,Pow2) \
        ( ( ( (Count) & (((Pow2)-1)) ) == 0) ? TRUE : FALSE )

// BOOL
// POINTER_IS_ALIGNED(
//     IN LPVOID Ptr,
//     IN DWORD Pow2      // undefined if this isn't a power of 2.
//     );
//
#define POINTER_IS_ALIGNED(Ptr,Pow2) \
        ( ( ( ((ULONG_PTR)(Ptr)) & (((Pow2)-1)) ) == 0) ? TRUE : FALSE )


#define ROUND_DOWN_COUNT(Count,Pow2) \
        ( (Count) & (~((Pow2)-1)) )

#define ROUND_DOWN_POINTER(Ptr,Pow2) \
        ( (LPVOID) ROUND_DOWN_COUNT( ((ULONG_PTR)(Ptr)), (Pow2) ) )


// If Count is not already aligned, then
// round Count up to an even multiple of "Pow2".  "Pow2" must be a power of 2.
//
// DWORD
// ROUND_UP_COUNT(
//     IN DWORD Count,
//     IN DWORD Pow2
//     );
#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~((Pow2)-1)) )

// LPVOID
// ROUND_UP_POINTER(
//     IN LPVOID Ptr,
//     IN DWORD Pow2
//     );

// If Ptr is not already aligned, then round it up until it is.
#define ROUND_UP_POINTER(Ptr,Pow2) \
        ( (LPVOID) ( (((ULONG_PTR)(Ptr))+(Pow2)-1) & (~((Pow2)-1)) ) )


// Usage: myPtr = ROUND_UP_POINTER(unalignedPtr, ALIGN_DWORD);


#if defined(_X86_)

#define ALIGN_BYTE              1
#define ALIGN_CHAR              1
#define ALIGN_DESC_CHAR         sizeof(DESC_CHAR)
#define ALIGN_DWORD             4
#define ALIGN_LONG              4
#define ALIGN_LPBYTE            4
#define ALIGN_LPDWORD           4
#define ALIGN_LPSTR             4
#define ALIGN_LPTSTR            4
#define ALIGN_LPVOID            4
#define ALIGN_LPWORD            4
#define ALIGN_TCHAR             sizeof(TCHAR)
#define ALIGN_WCHAR             sizeof(WCHAR)
#define ALIGN_WORD              2
#define ALIGN_QUAD              8

#define ALIGN_WORST             8

#elif defined(_AMD64_) || defined(_IA64_)

#define ALIGN_BYTE              1
#define ALIGN_CHAR              1
#define ALIGN_DESC_CHAR         sizeof(DESC_CHAR)
#define ALIGN_DWORD             4
#define ALIGN_LONG              4
#define ALIGN_LPBYTE            8
#define ALIGN_LPDWORD           8
#define ALIGN_LPSTR             8
#define ALIGN_LPTSTR            8
#define ALIGN_LPVOID            8
#define ALIGN_LPWORD            8
#define ALIGN_TCHAR             sizeof(TCHAR)
#define ALIGN_WCHAR             sizeof(WCHAR)
#define ALIGN_WORD              2
#define ALIGN_QUAD              8

#define ALIGN_WORST             8

#else  // none of the above

#error "Unknown alignment requirements for align.h"

#endif  // none of the above


#endif  // _ALIGN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\bldver.h ===
/*bldver.h*/

/******************************************************************
**
** This file is automatically generated by BLDVER.EXE.
** Do not attempt to change this file manually. Your changes will
** be overwritten during the next build.
**
********************************************************************/

#if !defined(_BLDVER_H_)
#define _BLDVER_H_
#define BUILD_NUMBER				"40.0"			/* String version */
#define BUILD_NUM					40,0				/* int version */
#define BUILD_VERSION BUILD_NUMBER
#define ICW16_VERSION				"3.0.40.0\0"		/* VERSIONINFO string */
#define ICW16_VERSION_BINARY		3,0,40,0			/* VERSIONINFO binary */
#define ICW32_VERSION				"4.71.40.0\0"	/* VERSIONINFO string */
#define ICW32_VERSION_BINARY		4,71,40,0		/* VERSIONINFO binary */
#define ISBU_VERSION				"6.0.40.0\0"		/* VERSIONINFO string */
#define ISBU_VERSION_BINARY			6,0,40,0			/* VERSIONINFO binary */
#endif // !defined(_BLDVER_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\basetrac.h ===
//-----------------------------------------------------------------------------
//
//
//  File: basetrac.h
//
//  Description:    Defines class designed for tracking call stacks.  Designed
//      for use in tracking Addref/Release... but can also be used to track
//      any user
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/28/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __BASETRAC_H__
#define __BASETRAC_H__

#include "baseobj.h"

#define DEFAULT_CALL_STACKS         10
#define DEFAULT_CALL_STACK_DEPTH    20
#define TRACKING_OBJ_SIG            'jbOT'

#ifndef DEBUG //Retail

//In retail... just map to straight COM AddRef/Release functionality
typedef CBaseObject             CBaseTrackingObject;

#else //DEBUG - add support for tracking Addref/Release by default

class   CDebugTrackingObject;
typedef CDebugTrackingObject    CBaseTrackingObject;

#endif //DEBUG

//---[ eObjectTrackingReasons ]------------------------------------------------
//
//
//  Description:   An enum that describes some basic tracking reasons.  If 
//      an implementor of a subclass need more reasons, then simply create
//      a subclass specific enum that start with the value of
//      TRACKING_OBJECT_START_USER_DEFINED.
//  
//-----------------------------------------------------------------------------
enum eObjectTrackingReasons
{
    TRACKING_OBJECT_UNUSED = 0,
    TRACKING_OBJECT_CONSTRUCTOR,
    TRACKING_OBJECT_DESTRUCTOR,
    TRACKING_OBJECT_ADDREF,
    TRACKING_OBJECT_RELEASE,
    TRACKING_OBJECT_START_USER_DEFINED,
};

//---[ CCallStackEntry_Base ]--------------------------------------------------
//
//
//  Description: 
//      The base class for store call stack entry information.  This class 
//      is not inteded to be instantiated directly... and exists primarily
//      for use by a debugger extension.
//  Hungarian: (think CDB and windbg command to get call stacks) 
//      kbeb, pkbeb
//  
//-----------------------------------------------------------------------------
class CCallStackEntry_Base
{
  public:
    DWORD       m_dwCallStackType;
    DWORD       m_dwCallStackDepth;
    DWORD_PTR  *m_pdwptrCallers;
    CCallStackEntry_Base();
    void GetCallers();
};

//---[ CCallStackEntry ]-------------------------------------------------------
//
//
//  Description: 
//      A default subclas of CCallStackEntry_Base.  Provides storage for 
//      a call stack of depth DEFAULT_CALL_STACK_DEPTH.
//  Hungarian: 
//      kbe, pkbe
//  
//-----------------------------------------------------------------------------
class CCallStackEntry : public CCallStackEntry_Base
{
  protected:
    //Storage for call stack data
    DWORD_PTR   m_rgdwptrCallers[DEFAULT_CALL_STACK_DEPTH];
  public:
    CCallStackEntry() 
    {
        m_pdwptrCallers = m_rgdwptrCallers;
        m_dwCallStackDepth = DEFAULT_CALL_STACK_DEPTH;
    };
};

//---[ CDebugTrackingObject_Base ]----------------------------------------------
//
//
//  Description: 
//      A class that provides the neccessary primitives for tracking call
//      stacks.  Like CCallStackEntry_Base it is designed to be used through
//      a subclass that provides storage for the required number call stack 
//      entries.
//
//      To effectively create a subclass... you will need to create a subclass
//      That contains (or allocates) the memory required to hold the 
//      tracking data, and set the following 3 protected member variables:
//          m_cCallStackEntries
//          m_cbCallStackEntries
//          m_pkbebCallStackEntries
//  Hungarian: 
//      tracb, ptracb
//  
//-----------------------------------------------------------------------------
class CDebugTrackingObject_Base : public CBaseObject
{
  private:
    DWORD   m_dwSignature;
    //A running total of the number of stack entires recorded
    //The index of the next call stack entry is defined as:
    //      m_cCurrentStackEntries % m_cCallStackEntries
    DWORD   m_cCurrentStackEntries; 
    
  protected:
    //The following 2 values are stored in memory as a way to have size
    //independent implementations... child classes may wish to implement 
    //a subclass with more (or less) entries... or store more debug 
    //information.  By having an explicit self-decriptive in-memory format, 
    //we can use a single implementation to handle getting the call stack 
    //and a single debugger extension can be used to dump all sizes of entries.
    DWORD                   m_cCallStackEntries;    //Number of callstacks kept
    DWORD                   m_cbCallStackEntries;   //Size of each callstack entry
    
    CCallStackEntry_Base   *m_pkbebCallStackEntries;
    
    //Used to internally log TRACKING events
    void LogTrackingEvent(DWORD dwTrackingReason);
  public:
    CDebugTrackingObject_Base();
    ~CDebugTrackingObject_Base();
};

//---[ CDebugTrackingObject ]---------------------------------------------------
//
//
//  Description: 
//      The default subclass for CDebugTrackingObject_Base.  It provides storage
//      for DEFAULT_CALL_STACKS CCallStackEntry objects
//  Hungarian: 
//      trac, ptrac
//  
//-----------------------------------------------------------------------------
class CDebugTrackingObject : 
    public CDebugTrackingObject_Base
{
  protected:
    CCallStackEntry m_rgkbeCallStackEntriesDefault[DEFAULT_CALL_STACKS];
  public:
    CDebugTrackingObject::CDebugTrackingObject()
    {
        m_cbCallStackEntries = sizeof(CCallStackEntry);
        m_cCallStackEntries = DEFAULT_CALL_STACKS;
        m_pkbebCallStackEntries = m_rgkbeCallStackEntriesDefault;
        LogTrackingEvent(TRACKING_OBJECT_CONSTRUCTOR);
    };
    CDebugTrackingObject::~CDebugTrackingObject()
    {
        LogTrackingEvent(TRACKING_OBJECT_DESTRUCTOR);
    };
    ULONG AddRef();
    ULONG Release();
};

#endif //__BASETRAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cacheapi.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       cacheapi.h
//
//  Contents:   The definitions of functions and structures which are used
//				external to the core of this library.
//
//  Functions:  
//
//  History:    8/28/96     JayH created
//
//  Todo:
//
//	Bugs:
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

typedef DWORD HCACHE;
typedef HCACHE FAR * LPHCACHE;
typedef DWORD HFORMAT;
//
// CACHE_TYPE is used to identify the type of cache entry being stored. Currently
// the only cache entry type is USERNAME_PASSWORD. This type uses a secret blob
// to hold the password, and does not store anything in the nonsecret blob.
//
typedef enum _CACHE_TYPE {
	CT_NONE,
	CT_USERNAME_PASSWORD
} CACHE_TYPE;

//
// HFORMAT's for hashes are derived by concating two words which represent the 
// authentication algorithm they are used for and the version of the hash algorithm
// 

#define	HFORMAT_DPA_HASH_1		0x00010001
#define HFORMAT_RPA_HASH_1		0x00020001

#define CR_SAVE_SECRET		0x00000001
#define CR_DELETE_PEERS		0x00000002

#define CL_STORED_CACHE		0x00000010
#define CL_CONFIRMED_CACHE	0x00000020

//+------------------------------------------------------------
//
// Function:	OpenCommonCache
//
// Synopsis:	This function opens the common cache and performs
//				everything necessary to get it to work. That means if this
//				is the first time it is being called, it will call
//				InitCacheLibrary. This keeps a ref count.
//
// Arguments:	szUserName --	Presently unused. This can be used to support
//								the sharing of the cache between users.
//				phCache --		The handle to the opened common cache is
//								returned here.
// Returns:		Nothing.
//
// History:		Jayhoo	Created		8/28/1996
//
//-------------------------------------------------------------

HRESULT OpenCommonCache(LPTSTR szUserName,
							LPHCACHE phCache);

//+------------------------------------------------------------
//
// Function:	CloseCommonCache
//
// Synopsis:	This function closes the cache and decrements the ref count on
//				it. If the reference count reaches zero, the library will be 
//				closed.
//
// Arguments:	szUserName --	Presently unused. This can be used to support
//								the sharing of the commmon cache between users.
//				phCache --		The handle to the opened common cache is
//								returned here.
// Returns:		Nothing.
//
// History:		Jayhoo	Created		8/28/1996
//
//-------------------------------------------------------------

HRESULT CloseCommonCache(HCACHE hCache);

//+------------------------------------------------------------
//
// Function:	SetCacheEntry
//
// Synopsis:	This function sets an entry in the cache. If the entry does
//				not already exist, it will create the entry. It sets the entry
//				in the persistent cache and the non-persistent cache, and it
//				creates hashed versions of the secret for every hash secret
//				format that it knows about.
//
// Arguments:	hCache			Handle of a valid, opened cache
//
//				szEntryName		The name of the entry, currently this must be
//								this must be the username since that is the
//								only supported form of cache entry.
//
//				szListName		This list of entries which that entry is valid
//								within. Currently this must be the domain name
//
//				ctCacheType		The type of cache entry being used. This must
//								be CT_USERNAME_PASSWORD.
//
//				lpbSecretOpaque		The secret information to be hashed before
//									it is stored (Sssshhh!)
//
//				dwSizeSecretOpaque	The size of the secret information
//
//				lpbOpaque		The information which doesn't need to be hashed
//
//				dwSizeOpaque	The size of the opaque info
//
//				fCacheReq		The flags about how this should be cached. The
//								only defined flag currently is CR_SAVE_SECRET
//
//				fCacheLoc		Allows the caller to specify where the cache
//								should be saved to. It is a bitmask of
//								CL_PERSISTENT and CL_NONPERSISTENT
//
// History:		Jayhoo	Created		8/28/1996
//
//-------------------------------------------------------------

HRESULT SetCacheEntry(HCACHE hCache,
					  LPTSTR szEntryName,
					  LPTSTR szListName,
					  CACHE_TYPE ctCacheType,
					  LPBYTE lpbSecretOpaque,
					  DWORD dwSizeSecretOpaque,
					  LPBYTE lpbOpaque,
					  DWORD dwSizeOpaque,
					  DWORD fCacheReq,
					  DWORD fCacheLoc);

//+------------------------------------------------------------
//
// Function:	DeleteCacheEntry
//
// Synopsis:	This function gets an entry in the cache. If the entry does
//				not already exist, it returns failure. If the username
//				entered into the function is null, the default user will be
//				returned. Currently the default user is the only one in the 
//				cache. You can only get secret information in the hashed 
//				format.
//
// Arguments:	hCache			Handle of a valid, opened cache
//
//				szEntryName		The name of the entry to delete
//
//				szListName		The name of the list that entry is in
//
//				ctCacheType		The type of the entry
//
//				fCacheLoc		Allows the caller to specify where the cache
//								should be deleted from. It is a bitmask of
//								CL_PERSISTENT and CL_NONPERSISTENT
//
// History:		Jayhoo	Created		8/28/1996
//
//-------------------------------------------------------------

HRESULT DeleteCacheEntry(HCACHE hCache,
						 LPTSTR szEntryName,
						 LPTSTR szListName,
						 CACHE_TYPE ctCacheType,
						 DWORD fCacheLoc);

//+------------------------------------------------------------
//
// Function:	GetCacheEntry
//
// Synopsis:	This function gets an entry in the cache. If the entry does
//				not already exist, it returns failure. If the username
//				entered into the function is null, the default user will be
//				returned. Currently the default user is the only one in the 
//				cache. You can only get secret information in the hashed 
//				format.
//
// Arguments:	hCache			Handle of a valid, opened cache
//
//				hFormat			Handle of the format we wish to use
//
//				szEntryName		The name of the entry, currently this must be
//								this must be the username since that is the
//								only supported form of cache entry.
//
//				szListName		This list of entries which that entry is valid
//								within. Currently this must be the domain name
//
//				ctCacheType		The type of cache entry being used. This must
//								be CT_USERNAME_PASSWORD.
//
//				lppbSecretOpaque		Used to return the hashed secret. The
//										caller must free this by calling the
//										ReleaseBuffer function.
//
//				lpdwSizeSecretOpaque	returns he size of the secret data
//
//				lppbOpaque		Used to return the insecure information. The
//								caller must free this by calling the 
//								ReleaseBuffer fucntion
//
//				lpdwSizeOpaque	Returns the size of the opaque info
//
//				pfCacheReq		Returns the flags about how this should be 
//								cached. The	only defined flag currently is 
//								CR_SAVE_SECRET
//
//				fCacheLoc		Allows the caller to specify where the cache
//								should be loaded from. It is a bitmask of
//								CL_PERSISTENT and CL_NONPERSISTENT
//
// History:		Jayhoo	Created		8/28/1996
//
//-------------------------------------------------------------

HRESULT GetCacheEntry(HCACHE hCache,
					  HFORMAT hFormat,
					  LPTSTR szEntryName,
					  LPTSTR szListName,
					  CACHE_TYPE ctCacheType,
					  LPBYTE FAR *lppbSecretOpaque,
					  LPDWORD	lpdwSizeSecretOpaque,
					  LPBYTE FAR *lppbOpaque,
					  LPDWORD	lpdwSizeOpaque,
					  LPTSTR FAR *lpszEntryName,
					  LPDWORD pfCacheReq,
					  DWORD fCacheLoc);

//+------------------------------------------------------------
//
// Function:	AllocateBuffer
//
// Synopsis:	This function is used to allocate all memory in the cache
//				library. This gives us a centralized way to optimize memory
//				allocation. Note that classes might use a cpool.
//
// Arguments:	dwSizeBuffer	The size of the buffer to be allocated
//
// History:		Jayhoo	Created		8/28/1996
//
//-------------------------------------------------------------

LPBYTE AllocateBuffer(DWORD dwSizeBuffer);

//+------------------------------------------------------------
//
// Function:	ReleaseBuffer
//
// Synopsis:	This function will release the buffer. This API is exposed
//				to the world so that we can allocate and return buffers and
//				have some way to be rid of them.
//
// Arguments:	lpbBuffer		The buffer to be released
//
// History:		Jayhoo	Created		8/28/1996
//
//-------------------------------------------------------------

HRESULT ReleaseBuffer(LPBYTE lpbBuffer);

//+------------------------------------------------------------
//
// Function:	HashSecret
//
// Synopsis:	This function will hash the secret for the caller. This
//				is done so that the hashing funciton will not be implemented
//				in multiple files.
//
// Arguments:	lpbBuffer		The buffer to be released
//
// History:		Jayhoo	Created		8/28/1996
//
//-------------------------------------------------------------

HRESULT HashSecret(HFORMAT hFormat,
                   CACHE_TYPE ctCacheType,
				   LPBYTE lpbSecretBlob,
				   DWORD dwSizeSecret,
				   LPBYTE FAR * lppbHashedBlob,
				   LPDWORD lpdwSizeHashedBlob);

//+------------------------------------------------------------
//
// Function:	ChangeEntryName
//
// Synopsis:	This function will change the name of an entry in a given
//				list of a given cache type, for all formats in which it exists
//
// Arguments:	lpbBuffer		The buffer to be released
//
// History:		Jayhoo	Created		8/28/1996
//
//-------------------------------------------------------------

HRESULT ChangeEntryName(HCACHE hCache,
						CACHE_TYPE ctCacheType,
						LPTSTR szStartEntryName,
						LPTSTR szEndEntryName,
						LPTSTR szListName,
						DWORD fCacheReq);

//+------------------------------------------------------------
//
// Function:	ConfirmCacheEntry
//
// Synopsis:	This function will copy an entry in the stored cache to 
//				the confirmed cache, for all hashed secret formats that
//				the cache type supports.
//
// Arguments:	hCache			Handle of a valid, opened cache
//
//				szEntryName		The name of the entry, currently this must be
//								this must be the username since that is the
//								only supported form of cache entry.
//
//				szListName		This list of entries which that entry is valid
//								within. Currently this must be the domain name
//
//				ctCacheType		The type of cache entry being used. This must
//								be CT_USERNAME_PASSWORD.
//
// History:		Jayhoo	Created		8/28/1996
//
//-------------------------------------------------------------

HRESULT ConfirmCacheEntry(HCACHE hCache,
					  LPTSTR szEntryName,
					  LPTSTR szListName,
					  CACHE_TYPE ctCacheType,
					  DWORD fCacheReq);

#ifdef __cplusplus
}
#endif //__cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cache.h ===
/*++

Cache.h

	This file defines some templates which implement
	a generic cache manager.


	In order to use the Cache manager, your class must
	have the following :



		//
		//	SampleClass derives from CRefCount as smart pointers
		//	'CRefPtr<Data>' are used to manage the life time of cached
		//	objects.
		//

	class	SampleClass : public CRefCount {


		//
		//	Cached class has a constructor which takes two
		//	arguments, the Key used to find the Data in the Cache
		//	and the 'Constructor' (which is a type specified in
		//	the cache template) which contains whatever
		//	initialization data that needs to be passed.
		//
		//	The Cached class should do minimal work within the
		//	constructor.  The FindOrCreate() function will also
		//	call an innitialization class which finishes initialization
		//	of the object.
		//
		SampleClass( Key& k, Constructor &constructor ) ;

		//
		//	If the Cached class does not do all of its initialization
		//	in its Constructor, then The ExclusiveLock() function must
		//	guarantee that no clients can use the object untill the
		//	lock is released.
		//
		//	If the Cached class is completely initialized after the
		//	constructor is called then this can be a no-op function.
		//
		ExclusiveLock() ;

		//
		//	After this is called clients may use the object.
		//
		ExclusiveUnlock() ;


		//
		//	The Init() function is called by FindOrCreate()
		//	after the contructor has been invoked.  This function
		//	must complete any initialization required.
		//
		//	Member functions are called by FindOrCreate() in this order :
		//
		//	SampleClass() // Constructor is called
		//	ExclusiveLock()
		//	Init()
		//	ExclusiveUnlock()
		//
		//	All Cache Client code must be able to deal with objects
		//	returned from the cache which failed initialization for
		//	whatever reason.
		//
		BOOL	Init( Constructor&	constructor ) ;

		//
		//	This function must return a reference to the
		//	Key value stored within the data.
		//
		Key&	GetKey() ;

		//
		//	Must return non-zero if the provided Key matches
		//	the one stored in the data .
		//
		int	MatchKey( Key& ) ;

	} ;


--*/


#ifndef	_CACHE_H_
#define	_CACHE_H_

#ifndef	_ASSERT	
#define	_ASSERT(x)	if(!(x)) DebugBreak() ; else
#endif


// This callback function is used to issue a stop hint during a
// long spin while shutting down so that the shutdown won't time
// out.
typedef void (*PSTOPHINT_FN)();

//
//	cacheint.h includes all the necessary helper classes
//	etc... that make the general cache engine work !
//
//
#include	"cacheint.h"

//
//	Utility class for those which wish to have pools of locks for
//	their objects !
//
class	CLockPool	{
private :

	//
	//	Array of locks to share amongst Xover data structures
	//
	_CACHELOCK	m_locks[256] ;

	//
	//
	//
	long		m_lockIndex ;
public :

	_CACHELOCK*	AllocateLock()	{
		return	&m_locks[	DWORD(InterlockedIncrement( &m_lockIndex )) % 256 ] ;
	}
} ;

//
//	CacheCallback class - clients can pass an object derived from
//	this into the Cache for functions which require some kind of user
//	callback processing !
//
template	<	class	Data >
class	CacheCallback	{
public :
	virtual	BOOL	fRemoveCacheItem(	Data&	d )	{
		return	FALSE ;
	}
} ;




//
//	Call these functions to initialize the Cache Library
//
extern	BOOL	__stdcall CacheLibraryInit() ;
extern	BOOL	__stdcall CacheLibraryTerm() ;





template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic = TRUE
				>
class	Cache :	public	CScheduleThread,
						CacheTable	{
private :

	//
	//	Define a 'CACHEENTRY' object which holds all the
	//	necessary data for each object which is placed in the cache !
	//
	typedef	CacheEntry< Data, Key, fAtomic >	CACHEENTRY ;

    //
    //  Define callback objects for Expunge Operations.
    //
    typedef CacheCallback< Data > CALLBACKOBJ;

	//
	//	Is the 'Cache' initialized and in a valid state !
	//
	BOOL							m_fValid ;

	//
	//	A list of everything in the Cache, used for TTL processing
	//
	CacheList						m_ExpireList ;

	//
	//	A hash table we use to find things within the Cache
	//
	TFHash< CACHEENTRY, Key >		m_Lookup ;

	//
	//	Pointer to a runtime-user provided function which is used
	//	to determine what things should be removed from the Cache
	//
	BOOL							(* m_pfnExpungeSpecific )( Data & ) ;

	//	
	//	Pointer to a runtime-user provided object derived from CacheCallback< Data >
	//	which lets the user invoke some function for each item in the Cache !
	//
	CALLBACKOBJ*                    m_pCallbackObject ;

	//
	//	Reader writer lock which protects all these data structures !
	//
	_CACHELOCK						m_Lock ;

	//
	//	The initial TTL we should assign to all newly cached objects !
	//
	DWORD							m_TTL ;

protected :

	//
	//	Virtual function called by CScheduleThread's thread which
	//	we use to bump TTL counters
	//
	void
	Schedule();

	//
	//	Function which removes an Entry from the Cache !
	//
	BOOL	
	RemoveEntry(	
			CacheState*	pEntry
			) ;

	//
	//	Virtual Function called by CacheList when we pass call
	//	CacheList::ExpungeSpecific
	//
	BOOL	
	QueryRemoveEntry(	
			CacheState*	pEntry
			) ;


	//
	//	Function which can remove a specific item from the Cache
	//	or walk the Cache deleting all the expired items.
	//	
	//
	BOOL	
	ExpungeInternal(	
			const	CACHEENTRY*	pProtected = 0,
			BOOL	fDoCheap = FALSE,
			Key*	key=0,	
			CACHEENTRY*	pData = 0
			)	;

	
public :

	//
	//	INTERNAL API's - These are public for convenience - not intended
	//	for Use outside of cachelib !!
	//
	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result through pDataOut no matter what !
	//
	BOOL	
	FindOrCreateInternal(	
			DWORD	dwHash,
			Key&	key,
			Constructor&	constructor,
			CRefPtr< Data >&	pDataOut
			) ;



	//
	//	Constructor - cMax specifies the maximum number of entries
	//	we should hold in the cache.
	//
	Cache( ) ;

	//
	//	Destructor - remove ourselves from schedule list before continuing !
	//
	~Cache() ;

	//
	//	Initialization function - take pointer to function
	//	which should be used to compute hash values on Key's
	//	Also takes the number of seconds objects should live in
	//	the cache !
	//
	BOOL	
	Init(	
			DWORD	(*pfnHash)( const Key& ),
			DWORD	dwLifetimeSeconds,
			DWORD	cMaxInstances,
			PSTOPHINT_FN pfnStopHint = NULL
			) ;

	//
	//	Function which can be used to remove items from the Cache
	//	If default args are used we pick an expired item in the Cache
	//	to remove
	//
	BOOL	
	Expunge(	
			Key*	key = 0,	
			CACHEENTRY*	pData = 0
			) ;

	//
	//	Function which can be passed a function pointer to determine
	//	exactly what items are to be removed from the Cache.
	//	if fForced == TRUE then items are removed from the Cache
	//	no matter what.
	//
	BOOL	
	ExpungeSpecific(	
			CALLBACKOBJ* pCallback,
			BOOL	fForced
			) ;




	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result through pDataOut no matter what !
	//
	BOOL	
	FindOrCreate(	
			Key&	key,
			Constructor&	constructor,
			CRefPtr< Data >&	pDataOut
			) ;


#ifdef	DEBUG

	static	long	s_cCreated ;

#endif

} ;



template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic = TRUE
				>
class	MultiCache {
private :

	//
	//	Define a 'CACHEENTRY' object which holds all the
	//	necessary data for each object which is placed in the cache !
	//
	typedef	CacheEntry< Data, Key, fAtomic >	CACHEENTRY ;

    //
    //  Define callback objects for Expunge Operations.
    //
    typedef CacheCallback< Data > CALLBACKOBJ;

	//
	//	Define the type for a single instance !
	//
	typedef	Cache< Data, Key, Constructor, fAtomic >	CACHEINSTANCE ;

	//
	//	Is the 'Cache' initialized and in a valid state !
	//
	BOOL							m_fValid ;

	//
	//	Pointer to the various Cache's we subdivide our work into
	//
	CACHEINSTANCE					*m_pCaches ;

	//
	//	Number of sub cache's we use to split up the work !
	//
	DWORD							m_cSubCaches ;

	//
	//	We use the hash function to choose which of our subcaches to work with !
	//
	DWORD							(*m_pfnHash)( const Key& ) ;

	//
	//	Return the correct cache instance to hold the selected piece of data !
	//
	//DWORD							ChooseInstance( Key&	k ) ;
	DWORD							ChooseInstance( DWORD	dwHash ) ;

public :

	//
	//	Constructor - cMax specifies the maximum number of entries
	//	we should hold in the cache.
	//
	MultiCache(  ) ;

	//
	//	Destructor - destroys are various sub cache's
	//
	~MultiCache() ;

	//
	//	Initialization function - take pointer to function
	//	which should be used to compute hash values on Key's
	//	Also takes the number of seconds objects should live in
	//	the cache !
	//
	BOOL	
	Init(	
			DWORD	(*pfnHash)( const Key& ),
			DWORD	dwLifetimeSeconds,
			DWORD	cSubCaches,
			DWORD	cMaxElements,
			PSTOPHINT_FN pfnStopHint = NULL
			) ;

	//
	//	Function which can be used to remove items from the Cache
	//	If default args are used we pick an expired item in the Cache
	//	to remove
	//
	BOOL	
	Expunge(	
			Key*	key = 0,	
			CACHEENTRY*	pData = 0
			) ;


	//
	//	Function which can be passed a function pointer to determine
	//	exactly what items are to be removed from the Cache.
	//	if fForced == TRUE then items are removed from the Cache
	//	no matter what.
	//
	BOOL	
	ExpungeSpecific(	
			CALLBACKOBJ* pCallback,
			BOOL	fForced
			) ;

	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result through pDataOut no matter what !
	//
	BOOL	
	FindOrCreate(	
			Key&	key,
			Constructor&	constructor,
			CRefPtr< Data >&	pDataOut
			) ;

	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result through pDataOut no matter what !
	//	NOTE : This is for use when the caller has a cheaper
	//	way to compute the hash value then us - in debug we
	//	need to assure that the caller correctly computes this !
	//
	BOOL	
	FindOrCreate(	
			Key&	key,
			DWORD	dwHash,
			Constructor&	constructor,
			CRefPtr< Data >&	pDataOut
			) ;


} ;



#include	"cacheimp.h"

#endif	// _CACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cacheimp.h ===
/*++

cacheimp.h -

	This file contains all the template function definitions required
	to make the cache manager work.


--*/

template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
void
Cache< Data, Key, Constructor, fAtomic >::Schedule()	{
/*++

Routine Description :

	This function runs through all the items in the Cache
	bumping TTL's.  If there are any items ready to go
	then we dump them from the Cache.

Arguments :

	None.

Return Value :

	Nothing

--*/

	if( !m_fValid )
		return ;

	m_Lock.ShareLock() ;

	DWORD	cExpungable = 0 ;
	BOOL	fExpunge = m_ExpireList.Expire( cExpungable ) ;
	m_Lock.ShareUnlock() ;

	if( fExpunge ) {
		Expunge() ;
	}
}

template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL	
Cache<Data, Key, Constructor, fAtomic>::RemoveEntry(	
					CacheState*	pEntry
					)	{
/*++

Routine Description :

	This function removes an entry from the Cache.
	We call our hash table to delete the item.
	the CacheState destructor automagically removes
	the item from our linked lists.

	CALLER MUST HOLD APPROPRIATE LOCKS!


Arguments :

	pEntry - item to be removed from cache

Return Value :

	TRUE if successfully removed !

--*/


	CACHEENTRY	*pCacheEntry = (CACHEENTRY*)pEntry ;

	return	m_Lookup.DeleteData( pCacheEntry->GetKey(), pCacheEntry ) ;
}

template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL	
Cache<Data, Key, Constructor, fAtomic>::QueryRemoveEntry(	
					CacheState*	pEntry )	{
/*++

Routine Description :

	This function is called from CacheList object to
	determine whether we want to remove an item from the Cache.
	This function is used to implement the ExpungeSpecific
	function available to clients.

	CALLER MUST HOLD APPROPRIATE LOCKS!


Arguments :

	pEntry - item we want to determine whether it should remain !

Return Value :

	TRUE if successfully removed !

--*/


	CACHEENTRY	*pCacheEntry = (CACHEENTRY*) pEntry ;

	if( m_pCallbackObject ) {
		return	m_pCallbackObject->fRemoveCacheItem( *pCacheEntry->m_pData ) ;
	}
	return	FALSE ;
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL	
Cache<Data, Key, Constructor, fAtomic>::ExpungeInternal(
					const	CACHEENTRY*	pProtected,	
					BOOL	fDoCheap,
					Key*	key,
					CACHEENTRY*	pData
					)	{
/*++

Routine Description :

	This function is called when we want to force some thing
	out of the cache.  The caller can provide a key	
	to force a particular item out of the cache.

	CALLER MUST HOLD APPROPRIATE LOCKS!


Arguments :

	pProtected - an Element we want to make sure is not removed !
	key - Pointer to the key identifying the item to be removed
	pData - pointer to the CACHEENTRY object containing the data
		and key we wish to remove.

Return Value :

	TRUE something is successfully removed from the cache.

--*/


	if( key != 0 ) {
		return	m_Lookup.DeleteData( *key, pData ) ;
	}	
	return m_ExpireList.Expunge( this, fDoCheap, pProtected ) ;
}


#ifdef	DEBUG

template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
long	Cache<Data, Key, Constructor, fAtomic>::s_cCreated = 0 ;

#endif

	
template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
Cache<Data, Key, Constructor, fAtomic>::Cache( ) : m_fValid( FALSE ) {
/*++

Routine Description :

	This function initializes our member variables.

Arguments :

	cMax - maximum number of elements the cache should hold

Return Value :

	Nothing

--*/

#ifdef	DEBUG

	InterlockedIncrement( &s_cCreated ) ;

#endif

	AddToSchedule() ;

}

template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
Cache<Data, Key, Constructor, fAtomic>::~Cache( ) {
/*++

Routine Description :

	This function destroys a Cache object !

Arguments :

	None

Return Value :

	Nothing

--*/

	RemoveFromSchedule() ;

	//
	//	Member and Base class destruction follows !!
	//

#ifdef	DEBUG

	InterlockedDecrement( &s_cCreated ) ;

#endif

}



template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
Cache<Data, Key, Constructor, fAtomic>::Init(	
				DWORD	(*pfnHash)( const Key& ),
				DWORD	dwLifetimeSeconds,
				DWORD	cMaxInstances,
				PSTOPHINT_FN pfnStopHint
		) {
/*++

Routine Description :

	This function initializes the cache so that it is ready
	to take entries.

Arguments :

	pfnHash - function to be used to compute hash values on keys
	dwLifetimeSeconds - The number of seconds objects should live in the Cache
	pfnStopHint - function to be used to send stop hints during
	  long spins so shutdown's don't time out.

Return Value :

	TRUE if successfull

--*/

	m_ExpireList.m_cMax = long(cMaxInstances) ;
	m_ExpireList.m_pfnStopHint = pfnStopHint;

	m_TTL = 1 + (dwLifetimeSeconds / CScheduleThread::dwNotificationSeconds) ;

	return	m_fValid = m_Lookup.Init( 100, 100, pfnHash ) ;
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
Cache<Data, Key, Constructor, fAtomic>::Expunge(	
				Key*	key,	
				CACHEENTRY*	pData
				)	{
/*++

Routine Description :

	This function is called when we want to force some thing
	out of the cache.  The caller can provide a key	
	to force a particular item out of the cache.

	WE WILL GRAB THE NECESSARY LOCKS !

Arguments :

	pfnHash - function to be used to compute hash values on keys

Return Value :

	TRUE if successfull

--*/

	_ASSERT( m_fValid ) ;

	m_Lock.ExclusiveLock() ;
	BOOL	fReturn = ExpungeInternal( 0, FALSE, key, pData ) ;
	m_Lock.ExclusiveUnlock() ;
	return	fReturn ;
}

template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
Cache<Data, Key, Constructor, fAtomic>::ExpungeSpecific(	
				CALLBACKOBJ* pCallbackObject,
				BOOL	fForced
				) {
/*++

Routine Description :

	This function is called when we want to force some thing
	out of the cache.  The caller can provide a key	
	to force a particular item out of the cache.

	WE WILL GRAB THE NECESSARY LOCKS !

Arguments :

	pfn - callback function used to determine what to remove
		from the Cache.
	fForced - if TRUE then we will remove from the Cache no matter
		what, even if other threads are using the object !

Return Value :

	TRUE if successfull

--*/



	m_Lock.ExclusiveLock() ;
	
	m_pCallbackObject = pCallbackObject ;
	
	BOOL	fReturn = m_ExpireList.ExpungeSpecific( this, fForced ) ;

	m_Lock.ExclusiveUnlock() ;
	return	fReturn ;
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
Cache<Data, Key, Constructor, fAtomic>::FindOrCreateInternal(
						DWORD	dwHash,
						Key&	key,
						Constructor&	constructor,
						CRefPtr< Data >&	pDataOut
						) {
/*++

Routine Description :

	This function is called when we want something out
	of the Cache.  We will either find the object or create it.

	WE WILL GRAB THE NECESSARY LOCKS !

Arguments :

	key - The unique key used to find the item in the Cache.
	constructor - An object to pass to the Data's constructor and Init
		functions.
	pDataOut - Smart pointer which receives the result

Return Value :

	TRUE if successfull

--*/


	BOOL	fReturn = FALSE ;
	pDataOut = 0 ;

	if( !m_fValid ) {
		SetLastError( 0 ) ;
		return	FALSE ;
	}	else	{
		m_Lock.ShareLock() ;

		//
		//	See if we can find an Entry in the cache for the item we want.
		//
		CACHEENTRY	*pEntry = m_Lookup.SearchKeyHash( dwHash, key ) ;
		if( pEntry ) {
			pDataOut = pEntry->m_pData ;
			fReturn = TRUE ;
			m_ExpireList.LiveLonger( pEntry, (m_TTL/2)+1 ) ;
		}

		m_Lock.ShareUnlock() ;

		if( pDataOut == 0 ) {

			m_Lock.ExclusiveLock() ;

			//
			//	Check that the Item we want in the Cache didn't make it
			//	into the Cache in the brief moment we switched from a shared
			//	to an exclusive lock.
			//

			pEntry = m_Lookup.SearchKeyHash( dwHash, key ) ;
			if( pEntry != 0 ) {
				//
				//	It's in the cache - return the cached object !
				//
				pDataOut = pEntry->m_pData ;
				fReturn = TRUE ;
				m_ExpireList.LiveLonger( pEntry, (m_TTL/2)+1 ) ;
				m_Lock.ExclusiveUnlock() ;
			}	else	{	

				//
				//	We're going to have to create one of the elements that goes
				//	in the cache.  Let's do that now !
				//

				const	CACHEENTRY	*pCacheEntry = 0 ;
				BOOL		fOverFlow = FALSE ;
				Data		*pData = 0 ;

				//
				//	We Add another brace here because we want to explicitly manage
				//	the lifetime of tempCacheEntry
				//
				{
					//
					//	tempCacheEntry will be copied by the FHash template into
					//	another CACHEENTRY object when it does its insertion.
					//
					CACHEENTRY	tempCacheEntry( m_TTL ) ;

					//
					//	The constructor of the Data object is expected to initialize
					//	only the 'key' data of the Data object so that the data can be
					//	found in the Cache.
					//
					tempCacheEntry.m_pData = pData = new	Data( key, constructor ) ;

					if( tempCacheEntry.m_pData ) {
	
						pCacheEntry = m_Lookup.InsertDataHash( dwHash, tempCacheEntry ) ;
						if( pCacheEntry ) {
							if( m_ExpireList.Append( pCacheEntry ) ) {
								if( !ExpungeInternal( pCacheEntry, TRUE ) ) {
									m_ExpireList.ForceExpunge( this, pCacheEntry ) ;
								}
							}
							pDataOut = pCacheEntry->m_pData ;
							pDataOut->ExclusiveLock() ;
						}	else	{

							//
							//	The Insertion failed !
							//	Falling through correctly handles this error case !
							//

						}

					}
					//
					//	Delete tempCacheEntry's reference to the Data object.
					//	if an error occurred inserting into hash tables etc...
					//	this will automatically destroy the data object.
					//
					tempCacheEntry.m_pData = 0 ;
				}	


				//
				//	Release the cache's lock.  We do this now - the constructor
				//	for the 'Data' object should do minimal work.  We will not call
				//	the init function for the Data object, with the 'cache' locks
				//	relingquished.  This lets others use the cache while expensive
				//	construction operations continue.
				//
				m_Lock.ExclusiveUnlock() ;

				//
				//	Complete the initialization of the new Data item if it exists !
				//
				if( pDataOut != 0 ) {
					BOOL	fSuccess = pDataOut->Init( constructor ) ;
					pDataOut->ExclusiveUnlock() ;

					if( fSuccess ) {

						fReturn = TRUE ;

					}	else	{

						pDataOut = 0 ;
			
						//
						//	Need to Expire the entry we just placed in the Cache !
						//
						//	NOTE : Expunge() manages its own locks !!!
						//
						Expunge( &key ) ;

					}
				}
			}
		}
	}
	return	fReturn ;
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
inline	BOOL
Cache<Data, Key, Constructor, fAtomic>::FindOrCreate(
						Key&	key,
						Constructor&	constructor,
						CRefPtr< Data >&	pDataOut  ) {
/*++

Routine Description :

	This function is called when we want something out
	of the Cache.  We will either find the object or create it.

	WE WILL GRAB THE NECESSARY LOCKS !

Arguments :

	key - The unique key used to find the item in the Cache.
	constructor - An object to pass to the Data's constructor and Init
		functions.
	pDataOut - Smart pointer which receives the result

Return Value :

	TRUE if successfull

--*/


	DWORD	dw = m_pfnHash( key ) ;

	return	FindOrCreateInternal(	dw,
									key,
									constructor,
									pDataOut
									) ;
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
MultiCache< Data, Key, Constructor, fAtomic >::MultiCache() :
	m_fValid( FALSE ),
	m_pCaches( 0 ) ,
	m_cSubCaches( 0 ),
	m_pfnHash( 0 ) {
/*++

Routine Description :

	This function initializes the MultiCache's data structures

Arguments :

	None.

Return Value :

	Nothing

--*/
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
MultiCache< Data, Key, Constructor, fAtomic >::~MultiCache()	{
/*++

Routine Description :

	This function destroys all of our data structures - release
	all of our subcaches !

Arguments :

	None.

Return Value :

	Nothing

--*/


	if( m_pCaches ) {

		delete[]	m_pCaches ;

	}

}

template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
MultiCache< Data, Key, Constructor, fAtomic >::Init(
				DWORD	(*pfnHash)( const	Key & ),
				DWORD	dwLifetimeSeconds,
				DWORD	cSubCaches,
				DWORD	cMaxElements,
				PSTOPHINT_FN pfnStopHint) {

/*++

Routine Description :

	This function initializes the MultiCache - we use
	multiple independent Caches to split the work
	of caching all the data.

Arguments :

	None.

Return Value :

	Nothing

--*/


	//	
	//	Check that we're in the right state for this !
	//
	_ASSERT( !m_fValid ) ;
	_ASSERT( m_pCaches == 0 ) ;

	//
	//	Validate our arguments !!!
	//
	_ASSERT(	pfnHash != 0 ) ;
	_ASSERT(	dwLifetimeSeconds != 0 ) ;
	_ASSERT(	cSubCaches != 0 ) ;
	_ASSERT(	cMaxElements != 0 ) ;

	m_pfnHash = pfnHash ;
	m_cSubCaches = cSubCaches ;

	//
	//	Allocate the necessary subcaches !
	//

	m_pCaches = new	CACHEINSTANCE[m_cSubCaches] ;

	if( !m_pCaches ) {
		return	FALSE ;
	}	else	{

		for( DWORD	i=0; i<cSubCaches; i++ ) {
			
			if( !m_pCaches[i].Init( m_pfnHash, dwLifetimeSeconds, (cMaxElements / cSubCaches) + 1, pfnStopHint ) ) {
				delete	m_pCaches ;
				return	FALSE ;
			}
		}
	}
	m_fValid = TRUE ;
	return	TRUE ;
}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
DWORD
MultiCache< Data, Key, Constructor, fAtomic >::ChooseInstance(
				DWORD	dwHash
				) {
/*++

Routine Description :

	Given a Key figure out which of our subinstances we wish to use.

Arguments :

	None.

Return Value :

	Nothing

--*/


	//	
	//	Check that we're in the right state for this !
	//
	_ASSERT( m_fValid ) ;
	_ASSERT( m_pCaches != 0 ) ;

	//
	//	Validate our arguments !!!
	//
	_ASSERT(	m_pfnHash != 0 ) ;
	_ASSERT(	m_cSubCaches != 0 ) ;

	
	//DWORD	dwHash = m_pfnHash( k ) ;
	
	//
	//	Constants below stolen from C-runtime rand() function !
	//

	dwHash = (((dwHash * 214013) +2531011) >> 8) % m_cSubCaches ;

	return	dwHash ;

}



template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
MultiCache< Data, Key, Constructor, fAtomic >::Expunge(
				Key*	pk,
				CACHEENTRY*	pData
				) {
/*++

Routine Description :

	Either force a specified element out of the cache,
	or force out all those that are ready to go !

Arguments :

	None.

Return Value :

	Nothing

--*/

	if( pk != 0 ) {

		DWORD	dw = m_pfnHash( *pk ) ;

		CACHEINSTANCE*	pInstance = &m_pCacges[ChooseInstance( dw )] ;
		return	pInstance->Expunge( pk, pData ) ;

	}	else	{

		BOOL	fReturn = TRUE ;
		for( DWORD i=0; i<m_cSubCaches; i++ ) {

			fReturn &= m_pCaches[i].Expunge() ;
		
		}
	}
	return	fReturn ;
}

template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
MultiCache< Data, Key, Constructor, fAtomic >::ExpungeSpecific(
				CALLBACKOBJ* pCallbackObject,
				BOOL	fForced
				) {
/*++

Routine Description :

	Either force a specified element out of the cache,
	or force out all those that are ready to go !

Arguments :

	None.

Return Value :

	Nothing

--*/

	BOOL	fReturn = TRUE ;
	for( DWORD i=0; i<m_cSubCaches; i++ ) {

		fReturn &= m_pCaches[i].ExpungeSpecific( pCallbackObject, fForced ) ;
	
	}
	return	fReturn ;
}

template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
MultiCache< Data, Key, Constructor, fAtomic >::FindOrCreate(
				Key&	key,
				Constructor&	constructor,
				CRefPtr< Data >&	pDataOut
				) {
/*++

Routine Description :


Arguments :

	None.

Return Value :

	Nothing

--*/

	DWORD	dw = m_pfnHash( key ) ;

	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;

	return	pInstance->FindOrCreateInternal( dw, key, constructor, pDataOut ) ;

}


template	<	class	Data,	
				class	Key,	
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
MultiCache< Data, Key, Constructor, fAtomic >::FindOrCreate(
				Key&	key,
				DWORD	dw,
				Constructor&	constructor,
				CRefPtr< Data >&	pDataOut
				) {
/*++

Routine Description :


Arguments :

	None.

Return Value :

	Nothing

--*/

	_ASSERT( dw == m_pfnHash( key ) ) ;

	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;

	return	pInstance->FindOrCreateInternal( dw, key, constructor, pDataOut ) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cacheimx.h ===
/*++

cacheimp.h -

	This file contains all the template function definitions required
	to make the cache manager work.


--*/

#pragma warning(1:4700)

template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
void
Cache< Data, Key, KEYREF, Constructor, fAtomic >::Schedule()	{
/*++

Routine Description :

	This function runs through all the items in the Cache
	bumping TTL's.  If there are any items ready to go
	then we dump them from the Cache.

Arguments :

	None.

Return Value :

	Nothing

--*/

	if( !m_fValid )
		return ;

	m_Lock.ShareLock() ;

	DWORD	cExpungable = 0 ;
	BOOL	fExpunge = m_ExpireList.Expire( cExpungable ) ;
	m_Lock.ShareUnlock() ;

	if( fExpunge ) {
		KEYREF  key;
        Expunge( key ) ;    // fIgnoreKey == TRUE by default
	}
}

template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL	
Cache<Data, Key, KEYREF, Constructor, fAtomic>::RemoveEntry(	
					CacheState*	pEntry
					)	{
/*++

Routine Description :

	This function removes an entry from the Cache.
	We call our hash table to delete the item.
	the CacheState destructor automagically removes
	the item from our linked lists.

	CALLER MUST HOLD APPROPRIATE LOCKS!


Arguments :

	pEntry - item to be removed from cache

Return Value :

	TRUE if successfully removed !

--*/


	CACHEENTRY	*pCacheEntry = (CACHEENTRY*)pEntry ;

    CACHEENTRY *pC = m_Lookup.DeleteData( pCacheEntry->GetKey(), pCacheEntry ) ;
    if (!pC)
    {
        return FALSE;
    }
    else
    {
        delete pC;
    }

    return TRUE;
}

template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL	
Cache<Data, Key, KEYREF, Constructor, fAtomic>::QueryRemoveEntry(	
					CacheState*	pEntry )	{
/*++

Routine Description :

	This function is called from CacheList object to
	determine whether we want to remove an item from the Cache.
	This function is used to implement the ExpungeSpecific
	function available to clients.

	CALLER MUST HOLD APPROPRIATE LOCKS!


Arguments :

	pEntry - item we want to determine whether it should remain !

Return Value :

	TRUE if successfully removed !

--*/


	CACHEENTRY	*pCacheEntry = (CACHEENTRY*) pEntry ;

	if( m_pCallbackObject ) {
		return	m_pCallbackObject->fRemoveCacheItem( pCacheEntry->m_pData ) ;
	}
	return	FALSE ;
}


template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL	
Cache<Data, Key, KEYREF, Constructor, fAtomic>::ExpungeInternal(
					KEYREF	key,
					CACHEENTRY*	pData,
                    BOOL    fIgnoreKey,
					const	CACHEENTRY*	pProtected,	
					BOOL	fDoCheap
					)	{
/*++

Routine Description :

	This function is called when we want to force some thing
	out of the cache.  The caller can provide a key	
	to force a particular item out of the cache.

	CALLER MUST HOLD APPROPRIATE LOCKS!


Arguments :

	pProtected - an Element we want to make sure is not removed !
	key - Pointer to the key identifying the item to be removed
	pData - pointer to the CACHEENTRY object containing the data
		and key we wish to remove.

Return Value :

	TRUE something is successfully removed from the cache.

--*/


	if( !fIgnoreKey ) {
        CACHEENTRY* pC = m_Lookup.DeleteData( key, pData ) ;
        if (pC)
        {
            delete pC;
        }
	}	
	return m_ExpireList.Expunge( this, fDoCheap, pProtected ) ;
}


#ifdef	DEBUG

template	<	class	Data,	
				class	Key,
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
long	Cache<Data, Key, KEYREF, Constructor, fAtomic>::s_cCreated = 0 ;

#endif

	
template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
Cache<Data, Key, KEYREF, Constructor, fAtomic>::Cache( ) : m_fValid( FALSE ) {
/*++

Routine Description :

	This function initializes our member variables.

Arguments :

	cMax - maximum number of elements the cache should hold

Return Value :

	Nothing

--*/

#ifdef	DEBUG

	InterlockedIncrement( &s_cCreated ) ;

#endif

	AddToSchedule() ;

}

template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
Cache<Data, Key, KEYREF, Constructor, fAtomic>::~Cache( ) {
/*++

Routine Description :

	This function destroys a Cache object !

Arguments :

	None

Return Value :

	Nothing

--*/

	RemoveFromSchedule() ;

	//
	//	Member and Base class destruction follows !!
	//

#ifdef	DEBUG

	InterlockedDecrement( &s_cCreated ) ;

#endif

}



template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
Cache<Data, Key, KEYREF, Constructor, fAtomic>::Init(	
				DWORD	(*pfnHash)( KEYREF ),
				DWORD	dwLifetimeSeconds,
				DWORD	cMaxInstances,
				PSTOPHINT_FN pfnStopHint
		) {
/*++

Routine Description :

	This function initializes the cache so that it is ready
	to take entries.

Arguments :

	pfnHash - function to be used to compute hash values on keys
	dwLifetimeSeconds - The number of seconds objects should live in the Cache
	pfnStopHint - function to be used to send stop hints during
	  long spins so shutdown's don't time out.

Return Value :

	TRUE if successfull

--*/

	m_ExpireList.m_cMax = long(cMaxInstances) ;
	m_ExpireList.m_pfnStopHint = pfnStopHint;

	m_TTL = 1 + (dwLifetimeSeconds / CScheduleThread::dwNotificationSeconds) ;

	return	m_fValid = m_Lookup.Init( &CACHEENTRY::m_pNext, 100, 100,
		pfnHash, 2, CACHEENTRY::GetKey, CACHEENTRY::MatchKey ) ;
}


template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
Cache<Data, Key, KEYREF, Constructor, fAtomic>::Expunge(	
				KEYREF	key,	
				CACHEENTRY*	pData,
                BOOL fIgnoreKey
				)	{
/*++

Routine Description :

	This function is called when we want to force some thing
	out of the cache.  The caller can provide a key	
	to force a particular item out of the cache.

	WE WILL GRAB THE NECESSARY LOCKS !

Arguments :

	pfnHash - function to be used to compute hash values on keys

Return Value :

	TRUE if successfull

--*/

	_ASSERT( m_fValid ) ;

	m_Lock.ExclusiveLock() ;
	BOOL	fReturn = ExpungeInternal( key, pData, fIgnoreKey, 0, FALSE ) ;
	m_Lock.ExclusiveUnlock() ;
	return	fReturn ;
}

template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
Cache<Data, Key, KEYREF, Constructor, fAtomic>::ExpungeSpecific(	
				CALLBACKOBJ* pCallbackObject,
				BOOL	fForced
				) {
/*++

Routine Description :

	This function is called when we want to force some thing
	out of the cache.  The caller can provide a key	
	to force a particular item out of the cache.

	WE WILL GRAB THE NECESSARY LOCKS !

Arguments :

	pfn - callback function used to determine what to remove
		from the Cache.
	fForced - if TRUE then we will remove from the Cache no matter
		what, even if other threads are using the object !

Return Value :

	TRUE if successfull

--*/



	m_Lock.ExclusiveLock() ;
	
	m_pCallbackObject = pCallbackObject ;
	
	BOOL	fReturn = m_ExpireList.ExpungeSpecific( this, fForced ) ;

	m_Lock.ExclusiveUnlock() ;
	return	fReturn ;
}


template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
Cache<Data, Key, KEYREF, Constructor, fAtomic>::FindOrCreateInternal(
						DWORD	dwHash,
						KEYREF	key,
						Constructor&	constructor,
						CRefPtr< Data >&	pDataOut
						) {
/*++

Routine Description :

	This function is called when we want something out
	of the Cache.  We will either find the object or create it.

	WE WILL GRAB THE NECESSARY LOCKS !

Arguments :

	key - The unique key used to find the item in the Cache.
	constructor - An object to pass to the Data's constructor and Init
		functions.
	pDataOut - Smart pointer which receives the result

Return Value :

	TRUE if successfull

--*/


	BOOL	fReturn = FALSE ;
	pDataOut = 0 ;

	if( !m_fValid ) {
		SetLastError( 0 ) ;
		return	FALSE ;
	}	else	{
		m_Lock.ShareLock() ;

		//
		//	See if we can find an Entry in the cache for the item we want.
		//
		CACHEENTRY	*pEntry = m_Lookup.SearchKeyHash( dwHash, key ) ;
		if( pEntry ) {
			pDataOut = pEntry->m_pData ;
			fReturn = TRUE ;
			m_ExpireList.LiveLonger( pEntry, (m_TTL/2)+1 ) ;
		}

		m_Lock.ShareUnlock() ;

		if( pDataOut == 0 ) {

			m_Lock.ExclusiveLock() ;

			//
			//	Check that the Item we want in the Cache didn't make it
			//	into the Cache in the brief moment we switched from a shared
			//	to an exclusive lock.
			//

			pEntry = m_Lookup.SearchKeyHash( dwHash, key ) ;
			if( pEntry != 0 ) {
				//
				//	It's in the cache - return the cached object !
				//
				pDataOut = pEntry->m_pData ;
				fReturn = TRUE ;
				m_ExpireList.LiveLonger( pEntry, (m_TTL/2)+1 ) ;
				m_Lock.ExclusiveUnlock() ;
			}	else	{	

				//
				//	We're going to have to create one of the elements that goes
				//	in the cache.  Let's do that now !
				//

				const	CACHEENTRY	*pCacheEntry = 0 ;
				BOOL		fOverFlow = FALSE ;
				Data		*pData = 0 ;

				//
				//	We Add another brace here because we want to explicitly manage
				//	the lifetime of tempCacheEntry
				//
				{
					//
					//	pEntry will be copied by the FHash template into
					//	another CACHEENTRY object when it does its insertion.
                    //  NOTE: do this to use the new TFHashEx code.
                    //  pEntry is created on the stack and its refcount should remain!
					//
					CACHEENTRY* pEntry = new CACHEENTRY( m_TTL ) ;
                    _ASSERT( pEntry );
                    if (pEntry)
                    {
					    //
					    //	The constructor of the Data object is expected to initialize
					    //	only the 'key' data of the Data object so that the data can be
					    //	found in the Cache.
					    //
					    pEntry->m_pData = pData = new	Data( key, constructor ) ;

					    if( pEntry->m_pData ) {
	
						    pCacheEntry = m_Lookup.InsertDataHash( dwHash, pEntry ) ;
						    if( pCacheEntry ) {
							    if( m_ExpireList.Append( pCacheEntry ) ) {
								    if( !ExpungeInternal( key, 0, TRUE, pCacheEntry, TRUE ) ) {  // ignore key by default
									    m_ExpireList.ForceExpunge( this, pCacheEntry ) ;
								    }
							    }
							    pDataOut = pCacheEntry->m_pData ;
							    pDataOut->ExclusiveLock() ;
						    }	else	{

							    //
							    //	The Insertion failed !
							    //	Falling through correctly handles this error case !
							    //
                                //
                                //  No, No, No!  We need to handle the failure case here!
                                //  Delete pEntry's reference to the Data object
                                //  if an error occurred inserting into hash tables.
                                //  This will automatically destroy the data object.
							    pEntry->m_pData = 0;

						    }

					    }
					    //
					    //	Delete pEntry's reference to the Data object.
					    //	if an error occurred inserting into hash tables etc...
					    //	this will automatically destroy the data object.
					    //
                        //  We've handled in the above error case!
					    // pEntry->m_pData = 0 ;
                    }
				}	


				//
				//	Release the cache's lock.  We do this now - the constructor
				//	for the 'Data' object should do minimal work.  We will not call
				//	the init function for the Data object, with the 'cache' locks
				//	relingquished.  This lets others use the cache while expensive
				//	construction operations continue.
				//
				m_Lock.ExclusiveUnlock() ;

				//
				//	Complete the initialization of the new Data item if it exists !
				//
				if( pDataOut != 0 ) {
					BOOL	fSuccess = pDataOut->Init( constructor ) ;
					pDataOut->ExclusiveUnlock() ;

					if( fSuccess ) {

						fReturn = TRUE ;

					}	else	{

						pDataOut = 0 ;
			
						//
						//	Need to Expire the entry we just placed in the Cache !
						//
						//	NOTE : Expunge() manages its own locks !!!
						//
						Expunge( key, 0, FALSE ) ;  // don't ignore key!!!

					}
				}
			}
		}
	}
	return	fReturn ;
}


template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
inline	BOOL
Cache<Data, Key, KEYREF, Constructor, fAtomic>::FindOrCreate(
						KEYREF	key,
						Constructor&	constructor,
						CRefPtr< Data >&	pDataOut  ) {
/*++

Routine Description :

	This function is called when we want something out
	of the Cache.  We will either find the object or create it.

	WE WILL GRAB THE NECESSARY LOCKS !

Arguments :

	key - The unique key used to find the item in the Cache.
	constructor - An object to pass to the Data's constructor and Init
		functions.
	pDataOut - Smart pointer which receives the result

Return Value :

	TRUE if successfull

--*/


	DWORD	dw = m_pfnHash( key ) ;

	return	FindOrCreateInternal(	dw,
									key,
									constructor,
									pDataOut
									) ;
}


template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
MultiCache< Data, Key, KEYREF, Constructor, fAtomic >::MultiCache() :
	m_fValid( FALSE ),
	m_pCaches( 0 ) ,
	m_cSubCaches( 0 ),
	m_pfnHash( 0 ) {
/*++

Routine Description :

	This function initializes the MultiCache's data structures

Arguments :

	None.

Return Value :

	Nothing

--*/
}


template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
MultiCache< Data, Key, KEYREF, Constructor, fAtomic >::~MultiCache()	{
/*++

Routine Description :

	This function destroys all of our data structures - release
	all of our subcaches !

Arguments :

	None.

Return Value :

	Nothing

--*/


	if( m_pCaches ) {

		delete[]	m_pCaches ;

	}

}

template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
MultiCache< Data, Key, KEYREF, Constructor, fAtomic >::Init(
				DWORD	(*pfnHash)( KEYREF ),
				DWORD	dwLifetimeSeconds,
				DWORD	cSubCaches,
				DWORD	cMaxElements,
				PSTOPHINT_FN pfnStopHint) {

/*++

Routine Description :

	This function initializes the MultiCache - we use
	multiple independent Caches to split the work
	of caching all the data.

Arguments :

	None.

Return Value :

	Nothing

--*/


	//	
	//	Check that we're in the right state for this !
	//
	_ASSERT( !m_fValid ) ;
	_ASSERT( m_pCaches == 0 ) ;

	//
	//	Validate our arguments !!!
	//
	_ASSERT(	pfnHash != 0 ) ;
	_ASSERT(	dwLifetimeSeconds != 0 ) ;
	_ASSERT(	cSubCaches != 0 ) ;
	_ASSERT(	cMaxElements != 0 ) ;

	m_pfnHash = pfnHash ;
	m_cSubCaches = cSubCaches ;

	//
	//	Allocate the necessary subcaches !
	//

	m_pCaches = new	CACHEINSTANCE[m_cSubCaches] ;

	if( !m_pCaches ) {
		return	FALSE ;
	}	else	{

		for( DWORD	i=0; i<cSubCaches; i++ ) {
			
			if( !m_pCaches[i].Init( m_pfnHash, dwLifetimeSeconds, (cMaxElements / cSubCaches) + 1, pfnStopHint ) ) {
				delete	m_pCaches ;
				return	FALSE ;
			}
		}
	}
	m_fValid = TRUE ;
	return	TRUE ;
}


template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
DWORD
MultiCache< Data, Key, KEYREF, Constructor, fAtomic >::ChooseInstance(
				DWORD	dwHash
				) {
/*++

Routine Description :

	Given a Key figure out which of our subinstances we wish to use.

Arguments :

	None.

Return Value :

	Nothing

--*/


	//	
	//	Check that we're in the right state for this !
	//
	_ASSERT( m_fValid ) ;
	_ASSERT( m_pCaches != 0 ) ;

	//
	//	Validate our arguments !!!
	//
	_ASSERT(	m_pfnHash != 0 ) ;
	_ASSERT(	m_cSubCaches != 0 ) ;

	
	//DWORD	dwHash = m_pfnHash( k ) ;
	
	//
	//	Constants below stolen from C-runtime rand() function !
	//

	dwHash = (((dwHash * 214013) +2531011) >> 8) % m_cSubCaches ;

	return	dwHash ;

}



template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
MultiCache< Data, Key, KEYREF, Constructor, fAtomic >::Expunge(
				KEYREF	key,
				CACHEENTRY*	pData,
                BOOL fExpungeAll
				) {
/*++

Routine Description :

	Either force a specified element out of the cache,
	or force out all those that are ready to go !

Arguments :

	None.

Return Value :

	Nothing

--*/

	BOOL fReturn = TRUE;
	if( !fExpungeAll ) {

		DWORD	dw = m_pfnHash( key ) ;

		CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance( dw )] ;
		return	pInstance->Expunge( key, pData ) ;

	}	else	{

		for( DWORD i=0; i<m_cSubCaches; i++ ) {

			fReturn &= m_pCaches[i].Expunge( key ) ;    // ignore key by default
		
		}
	}
	return	fReturn ;
}

template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
MultiCache< Data, Key, KEYREF, Constructor, fAtomic >::ExpungeSpecific(
				CALLBACKOBJ* pCallbackObject,
				BOOL	fForced
				) {
/*++

Routine Description :

	Either force a specified element out of the cache,
	or force out all those that are ready to go !

Arguments :

	None.

Return Value :

	Nothing

--*/

	BOOL	fReturn = TRUE ;
	for( DWORD i=0; i<m_cSubCaches; i++ ) {

		fReturn &= m_pCaches[i].ExpungeSpecific( pCallbackObject, fForced ) ;
	
	}
	return	fReturn ;
}

template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
MultiCache< Data, Key, KEYREF, Constructor, fAtomic >::FindOrCreate(
				KEYREF	key,
				Constructor&	constructor,
				CRefPtr< Data >&	pDataOut
				) {
/*++

Routine Description :


Arguments :

	None.

Return Value :

	Nothing

--*/

	DWORD	dw = m_pfnHash( key ) ;

	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;

	return	pInstance->FindOrCreateInternal( dw, key, constructor, pDataOut ) ;

}


template	<	class	Data,	
				class	Key,	
                class   KEYREF,
				class	Constructor,	
				BOOL	fAtomic
				>
BOOL
MultiCache< Data, Key, KEYREF, Constructor, fAtomic >::FindOrCreate(
				KEYREF	key,
				DWORD	dw,
				Constructor&	constructor,
				CRefPtr< Data >&	pDataOut
				) {
/*++

Routine Description :


Arguments :

	None.

Return Value :

	Nothing

--*/

	_ASSERT( dw == m_pfnHash( key ) ) ;

	CACHEINSTANCE*	pInstance = &m_pCaches[ChooseInstance(dw)] ;

	return	pInstance->FindOrCreateInternal( dw, key, constructor, pDataOut ) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cacheint.h ===
/*++

Cacheint.h

	This file defines all of the classes required to support
	the generic cache manager, who's interface is defined in
	cache.h



--*/

#ifndef	_CACHEINT_H_
#define	_CACHEINT_H_

#include	<windows.h>
#include	"dbgtrace.h"
#include	"smartptr.h"
#include	"fhash.h"

#ifdef	_USE_RWNH_	
#include	"rwnew.h"
typedef	CShareLockNH	_CACHELOCK ;
#else
#include	"rw.h"
typedef	CShareLock		_CACHELOCK ;
#endif

//
//	This class defines all the information we keep about 
//	objects that we are holding in our cache.
//
//
class	CacheState	{
protected : 

	//
	//	Doubly linked list of CacheEntry BLOCKS !
	//
	class	CacheState*	m_pPrev ;
	class	CacheState*	m_pNext ;

	//
	//	Cacge State Information - Time To Live and Orphanage status !
	//
	long				m_TTL ;
	BOOL				m_fOrphan ;

	//
	//	Insert us into the list after the specified element !
	//
	void
	InsertAfter( 
			class	CacheState*	pPrevious 
			) ;

	//
	//	Insert us into the circular list before the specified element !
	//
	void
	InsertBefore( 
			class	CacheState*	pNext 
			)	;

	//
	//	Remove this element from the circular list !
	//
	void
	Remove() ;

	//
	//	The CacheList object maintains a list of these objects and ages them 
	//	out !
	//
	friend	class	CacheList ;

public : 

	//
	//	Default Constructor NULLS everything out !
	//
	CacheState( DWORD	ttl = 0 )	: 
	   m_pPrev( 0 ), m_pNext( 0 ), m_TTL( ttl ), m_fOrphan( FALSE ) { 
#ifdef	DEBUG
		InterlockedIncrement( &s_cCreated ) ;
#endif
	}

	//
	//	Copy Constructor relinks linked list ! we place ourselves in the linked list
	//	after the rhs element.
	//
	CacheState( CacheState& rhs ) : m_pPrev( 0 ), 
			m_pNext( 0 ), 
			m_TTL( rhs.m_TTL ), 
			m_fOrphan( rhs.m_fOrphan )  {

		if( rhs.m_pPrev != 0 ) 
			InsertAfter( &rhs ) ;
#ifdef	DEBUG
		InterlockedIncrement( &s_cCreated ) ;
#endif
	}

	//
	//	If we are in a linked list - the default destructor needs to remove us
	//	from that list.
	//
	~CacheState() ;

	//
	//	Need a virtual function which we use to figure out when we can 
	//	safely remove an entry from the Cache !!
	//
	virtual	BOOL	fDeletable() {	return	TRUE ; } 	

#ifdef	DEBUG

	static	long	s_cCreated ;

#endif

} ;

//
//	This class defines a couple of virtual functions 
//	which are to be called from CacheList objects.
//
class	CacheTable	{
protected :

	friend	class	CacheList ;

	//
	//	Remove an entry from the Cache - return TRUE if 
	//	successful and pEntry destroyed.
	//
	virtual	BOOL	RemoveEntry( 
							CacheState*	pEntry 
							) ;

	//
	//	Called to determine whether we want to remove a 
	//	specified entry from the cache.
	//
	virtual	BOOL	QueryRemoveEntry(	
							CacheState*	pEntry 
							) ;

} ;

class	CacheList	{
private : 

	//
	//	Keep this element around so we can keep a doubly linked list
	//	of the elements in the Cache List.
	//
	CacheState	m_Head ;

	//
	//	Make this private - nobody gets to copy us !
	//
	CacheList( CacheList& ) ;	

protected : 


	//
	//	Number of Elements in the Cache !
	//
	long		m_cEntries ;

	//	
	//	Number of elements (approximately) ready to be removed from 
	//	the cache !
	//
	long		m_cReadyToDie ;

public : 

	//
	//	Maximum number of Elements in the List !
	//
	long		m_cMax ;

	//
	// Stop hint function to be called during long shutdown loops.
	//
	PSTOPHINT_FN m_pfnStopHint;

	//
	//	Initialize the Cache list !
	//
	CacheList(	long	Max = 128 ) ;

#ifdef	DEBUG
	//
	//	In debug builds the destructor helps track how many of these
	//	are created !!
	//
	~CacheList() ;
#endif

	//
	//	Append an Entry into the CacheList.  We Append as this element 
	//	should have the largest Age and most likely to be the last element expired !
	//
	//	Returns TRUE if the number of entries is larger than our pre-ordained Maximum !
	//
	BOOL
	Append(		const	CacheState*		pEntry ) ;


	//
	//	Remove an arbitrary Entry from the CacheList !
	//
	//	Returns TRUE if the number of remaining entries is larger than our pre-ordained Maximum !
	//
	BOOL
	Remove(		const	CacheState*		pEntry ) ;

	//
	//	Walk the list and Expire any entries in there !
	//	This means we decrement TTL's and count up the number of 
	//	entries in the list we could drop right now !
	//
	BOOL
	Expire(	DWORD&	cReady ) ;

	//
	//	Go find those elements who's TTL has dropped below 0 and 
	//	get rid of them from the cache !!
	//
	//	NOTE - if fDoCheap is set to TRUE then we use m_cReadyToDie
	//	to figure out if there's any work we can do !
	//
	BOOL
	Expunge(	CacheTable*	ptable,
				BOOL		fDoCheap = FALSE,	
				const	CacheState*	pProtected = 0 
				) ;

	//
	//	Go remove a single element who's TTL haven't dropped below 0
	//	and get rid of it from the Cache !
	//
	BOOL
	ForceExpunge(	CacheTable*	ptable, 
					const	CacheState*	pProtected = 0
					) ;

	//
	//	Go find those elements who's TTL has dropped below 0 and 
	//	get rid of them from the cache !!
	//
	BOOL
	ExpungeSpecific(	CacheTable*	ptable,	
						BOOL fForced  
						) ;

	//
	//	Bump the life time of the specified object up, 
	//	as somebody is re-using it from the cache !
	//
	void
	LiveLonger(		CacheState*	pEntry, 
					long		ttl
					) ;

#ifdef	DEBUG

	static	long	s_cCreated ;

#endif

} ;

	



//
//	This template class adds one member to the 'CacheState' class, 
//	which is the Reference counting pointer to the block of data we
//	are keeping in the Cache !  
//	In addition - we let the user specify whether Cache Blocks must be
//	atomic.  An atomic Cache block means we must never remove an element
//	from the Cache for which somebody external has a reference !
//	(ie  if fAtomic == TRUE then we only remove elements from the cache
//	when the reference count on the Data is zero meaning that we have the 
//	last reference !!!
//
//
template<	class	Data,	class	Key,	BOOL	fAtomic = TRUE >	
class	CacheEntry : public	CacheState		{
public : 

	CRefPtr< Data >		m_pData ;

	//
	//	Default constructor just passes on TTL data to CacheState object
	//
	CacheEntry( DWORD ttl=0 ) : CacheState( ttl ) {}

	//
	//	We do not declare a copy constructor as the default 
	//	compiler provided copy constructor which invokes 
	//	base class and member variable copy constructors works fine !
	//
	//	CacheEntry( CacheEntry& ) ;

	//
	//	We do not declare a destructor as the default compiler 
	//	provided destructor works fine !
	//
	//	~CacheEntry() ;

	//
	//	Return a reference to the Key data from the data portion !
	//
	Key&	GetKey()	{
		return	m_pData->GetKey() ;
	}

	//
	//	Return 0 if the provided Key matches that contained in the 
	//	data block !
	//
	int		MatchKey( Key&	key	)	{
		return	m_pData->MatchKey( key ) ;
	}

	//
	//	Determine whether we can remove the Data represented by this 
	//	entry from the Cache.  'fAtomic' == TRUE means that we should
	//	only release entries from the cache when the cache is the 
	//	only component holding a reference to the entry.
	//	This ensures that two pieces of 'Data' which are located 
	//	with the same 'Key' never exist at the same time.
	//
	BOOL	fDeleteable()	{
		if( !fAtomic ) {
			return	TRUE ;
		}
		return	m_pData->m_refs == 0 ;
	}

} ;



//
//	This is a base class for those objects which wish to be
//	called on a regularily scheduled basis.
//
//	The constructors for this class will automatically
//	put the object in a doubly linked list walked by a 
//	background thread which periodically executes a virtual function.
//
//
class	CScheduleThread {
private : 

	//
	//	Special constructor for the 'Head' element of the 
	//	doubly linked list this class maintains.
	//
	CScheduleThread( BOOL	fSpecial ) ;
	
protected : 

	//
	//	Has the scheduler been initialized ? 
	//
	static	BOOL			s_fInitialized ;

	//
	//	Crit sect protecting doubly linked list.
	//
	static	CRITICAL_SECTION	s_critScheduleList ;

	//
	//	Handle to event used to terminate background thread.
	//
	static	HANDLE			s_hShutdown ;

	//
	//	Handle to background thread.
	//
	static	HANDLE			s_hThread ;

	//
	//	The head element of the doubly linked list.
	//
	static	CScheduleThread		s_Head ;

	//
	//	The thread which calls our virtual functions
	//
	static	DWORD	WINAPI	ScheduleThread(	LPVOID	lpv ) ;

	//
	//	Previous and Next pointers which maintain doubly linked
	//	list of scheduled itesm.
	//
	class	CScheduleThread*	m_pPrev ;
	class	CScheduleThread*	m_pNext ;

protected : 

	//
	//	Derived classes should override this function - 
	//	it will be called on a regular basis by the scheduler thread.
	//
	virtual	void	Schedule( void ) {}

	//
	//	Constructor and Destructor automagically manage
	//	insertion into doubly linked list of other scheduled items.
	//	These are protected as we want people to buid only 
	//	derived objects which use this.
	//
	CScheduleThread() ; 

	//
	//	Member functions which put us into the regular schedule !
	//
	void	AddToSchedule() ;
	void	RemoveFromSchedule() ;
		
public : 

	//
	//	Initialize the class - don't construct
	//	any derived objects before this is called.
	//
	static	BOOL	Init() ;

	//
	//	Terminate class and background thread !
	//
	static	void	Term() ;

	//
	//	Global which tells clients how frequently they
	//	will be called !	
	//
	static	DWORD	dwNotificationSeconds ;

	//
	//	Destructor is protected - we should only be invoked
	//	by derived class constructors
	//
	~CScheduleThread() ;

} ;
		




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cachemti.h ===
/*++

	CACHEMTI.H

	This file contains the definitions of all the internal classes
	used to implement the multithreaded cache.

--*/



#ifndef	_CACHEMTI_H_
#define	_CACHEMTI_H_


//
//	This class defines all the information we keep about 
//	objects that we are holding in our cache.
//
//
class	CacheState	{
private : 
	//
	//	Signature for a piece of Cache state !
	//
	DWORD	m_dwSignature ;

	//
	//	No Copy construction !!!
	//
	CacheState( CacheState& ) ;
protected : 
	//
	//	Doubly linked list of CacheEntry BLOCKS !
	//
	//	This list is kept ordered by TTL, the newest blocks are at the end !
	//
	class	CacheState*	m_pPrev ;
	class	CacheState*	m_pNext ;

	//
	//	Cache State information - 
	//	the time the item was last touched, as well as orphanage info.
	//
	FILETIME			m_LastAccess ;	

	BOOL				m_fOrphan ;

	//
	//	Insert us into the list after the specified element !
	//
	void
	InsertAfter( 
			class	CacheState*	pPrevious 
			) ;

	//
	//	Insert us into the circular list before the specified element !
	//
	void
	InsertBefore( 
			class	CacheState*	pNext 
			)	;

	//
	//	Remove this element from the circular list !
	//
	void
	Remove() ;

	//
	//	The CacheList object maintains a list of these objects and ages them 
	//	out !
	//
	friend	class	CacheList ;

public : 

	//
	//	Default Constructor NULLS everything out !
	//
	CacheState( )	: 
		m_dwSignature( DWORD('atSC' ) ),
		m_pPrev( 0 ), 
		m_pNext( 0 ), 
		m_fOrphan( FALSE ) { 
#ifdef	DEBUG
		InterlockedIncrement( &s_cCreated ) ;
#endif
		ZeroMemory( &m_LastAccess, sizeof( m_LastAccess ) ) ;
	}

#if 0 
	//
	//	Copy Constructor relinks linked list ! we place ourselves in the linked list
	//	after the rhs element.
	//
	CacheState( CacheState& rhs ) : 
			m_pBucket( 0 ),
			m_pPrev( 0 ), 
			m_pNext( 0 ), 
			m_LastAccess( rhs.m_LastAccess ), 
			m_fOrphan( rhs.m_fOrphan )  {

		if( rhs.m_pPrev != 0 ) 
			InsertAfter( &rhs ) ;
#ifdef	DEBUG
		InterlockedIncrement( &s_cCreated ) ;
#endif
	}
#endif

	//
	//	If we are in a linked list - the default destructor needs to remove us
	//	from that list.
	//
	virtual	~CacheState() ;

	//
	//	Need a virtual function which we use to figure out when we can 
	//	safely remove an entry from the Cache !!
	//
	virtual	BOOL	fDeletable() {	return	TRUE ; } 	

	//
	//	Update the LastAccess time !
	//
	void
	Stamp( )	{

		GetSystemTimeAsFileTime( &m_LastAccess ) ;

	}

	//
	//	Compare to entries by comparing their LastAccess time's !
	//
	BOOL
	operator <= ( CacheState& rhs ) {
		return	CompareFileTime( &m_LastAccess, &rhs.m_LastAccess ) <= 0 ;
	}

	//
	//	Compare to entries by comparing their LastAccess time's !
	//
	BOOL
	operator >= ( CacheState& rhs ) {
		return	CompareFileTime( &m_LastAccess, &rhs.m_LastAccess ) >= 0 ;
	}

	//
	//	Compare to entries by comparing their LastAccess time's !
	//
	BOOL
	operator > ( CacheState& rhs ) {
		return	CompareFileTime( &m_LastAccess, &rhs.m_LastAccess ) > 0 ;
	}

	//
	//	Tell us if this entry is older than the specified time !
	//
	BOOL
	OlderThan( FILETIME	filetime )	{
		return	CompareFileTime( &m_LastAccess, &filetime ) < 0 ;
	}

	//
	//	Checks that the object is in a legal state !
	//
	virtual	BOOL
	IsValid( ) ;
	

#ifdef	DEBUG

	static	long	s_cCreated ;

#endif

} ;


//
//	This class defines a couple of virtual functions 
//	which are to be called from CacheList objects.
//
class	CacheTable	{
protected :

	friend	class	CacheList ;

	//
	//	Remove an entry from the Cache - return TRUE if 
	//	successful and pEntry destroyed.
	//
	virtual	void	RemoveEntry( 
							CacheState*	pEntry 
							) ;
} ;


class	CacheSelector : public	CacheTable	{
protected : 

	friend	class	CacheList ;
	//
	//	Called to determine whether we want to remove a 
	//	specified entry from the cache.
	//
	virtual	BOOL	QueryRemoveEntry(	
							CacheState*	pEntry 
							) ;

} ;

template<	class	Data,	class	Key,	BOOL	fAtomic = TRUE >	
class	TEntry : public	CacheState	{
private : 
	//
	//	No copy constructor allowed !
	//
	TEntry( TEntry& ) ;
public : 

	//
	//	For chaining in the hash table - this is our bucket pointer !
	//
	TEntry*	m_pBucket ;

	CRefPtr< Data >		m_pData ;

	//
	//	Default constructor just passes on TTL data to CacheState object
	//
	TEntry(	Data*	pData ) : 
		m_pBucket( 0 ), 
		m_pData( pData ) {
		Stamp() ;
	}

	//
	//	We do not declare a destructor as the default compiler 
	//	provided destructor works fine !
	//
	//	~CacheEntry() ;

	//
	//	Return a reference to the Key data from the data portion !
	//
	void	GetKey(Key &k)	{
		m_pData->GetKey(k) ;
	}

	//
	//	Return 0 if the provided Key matches that contained in the 
	//	data block !
	//
	int		MatchKey( Key&	key	)	{
		return	m_pData->MatchKey( key ) ;
	}

	//
	//	Determine whether we can remove the Data represented by this 
	//	entry from the Cache.  'fAtomic' == TRUE means that we should
	//	only release entries from the cache when the cache is the 
	//	only component holding a reference to the entry.
	//	This ensures that two pieces of 'Data' which are located 
	//	with the same 'Key' never exist at the same time.
	//
	BOOL	fDeleteable()	{
		if( !fAtomic ) {
			return	TRUE ;
		}
		return	m_pData->m_refs == 0 ;
	}

	BOOL
	IsValid()	{

		if( m_pData == 0 ) 
			return	FALSE ;

		return	CacheState::IsValid() ;

	}
} ;


class	CacheList	{
private : 

	//
	//	Keep this element around so we can keep a doubly linked list
	//	of the elements in the Cache List.
	//
	CacheState	m_Head ;

	//
	//	Make this private - nobody gets to copy us !
	//
	CacheList( CacheList& ) ;	

protected : 


	//
	//	Number of Elements in the Cache !
	//
	long		m_cEntries ;

public : 

	//
	//	Maximum number of Elements in the List !
	//
	long		m_cMax ;

	//
	// Stop hint function to be called during long shutdown loops.
	//
	PSTOPHINT_FN m_pfnStopHint;

	//
	//	Initialize the Cache list !
	//
	CacheList(	long	Max = 128 ) ;

#ifdef	DEBUG
	//
	//	In debug builds the destructor helps track how many of these
	//	are created !!
	//
	~CacheList() ;
#endif

	//
	//	Append an Entry into the CacheList.  We Append as this element 
	//	should have the largest Age and most likely to be the last element expired !
	//
	//	Returns TRUE if the number of entries is larger than our pre-ordained Maximum !
	//
	BOOL
	Append(		const	CacheState*		pEntry ) ;


	//
	//	Remove an arbitrary Entry from the CacheList !
	//
	//	Returns TRUE if the number of remaining entries is larger than our pre-ordained Maximum !
	//
	BOOL
	Remove(		const	CacheState*		pEntry ) ;

	//
	//	For users who destroy elements of the list, causing the 
	//	destructors to unlink elements and therefore skip Remove() - 
	//	call this so that our count of elements stays in sync.
	//
	void
	DecrementCount()	{
		m_cEntries-- ;
	}

	//
	//	Move an element to the end of the list. 
	//
	void
	MoveToBack(
			CacheState*	pEntry 
			)	;


	//
	//	Walk the list and Expire any entries in there !
	//	This means we decrement TTL's and count up the number of 
	//	entries in the list we could drop right now !
	//
	BOOL
	Expire(	DWORD&	cReady ) ;

	//
	//	Go find those elements who's TTL has dropped below 0 and 
	//	get rid of them from the cache !!
	//
	//	NOTE - if fDoCheap is set to TRUE then we use m_cReadyToDie
	//	to figure out if there's any work we can do !
	//
	BOOL
	Expunge(	CacheTable*	ptable,	
				FILETIME*	filetimeExpire,
				DWORD&		cExpunged,
				BOOL		fDoCheap = FALSE,	
				const	CacheState*	pProtected = 0 
				) ;

	//
	//	Go remove a single element who's TTL haven't dropped below 0
	//	and get rid of it from the Cache !
	//
	BOOL
	ForceExpunge(	CacheTable*	ptable, 
					const	CacheState*	pProtected = 0
					) ;

	//
	//	Go find those elements who's TTL has dropped below 0 and 
	//	get rid of them from the cache !!
	//
	BOOL
	ExpungeSpecific(	CacheSelector*	ptable,	
						BOOL fForced,
						DWORD	&cExpunged  
						) ;

	//
	//	Check to see whether the expiration list is in a valid state !
	//
	BOOL
	IsValid() ;

#if 0 
	//
	//	Bump the life time of the specified object up, 
	//	as somebody is re-using it from the cache !
	//
	void
	LiveLonger(		CacheState*	pEntry, 
					long		ttl
					) ;
#endif

#ifdef	DEBUG

	static	long	s_cCreated ;

#endif

} ;


#endif	// _CACHEMTI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cacheinx.h ===
/*++

Cacheint.h

	This file defines all of the classes required to support
	the generic cache manager, who's interface is defined in
	cache.h



--*/

#ifndef	_CACHEINT_H_
#define	_CACHEINT_H_

#include	<windows.h>
#include	"dbgtrace.h"
#include	"smartptr.h"
//#include	"refptr2.h"
#include	"fhashex.h"

#ifdef	_USE_RWNH_	
#include	"rwnew.h"
typedef	CShareLockNH	_CACHELOCK ;
#else
#include	"rw.h"
typedef	CShareLock		_CACHELOCK ;
#endif

//
//	This class defines all the information we keep about 
//	objects that we are holding in our cache.
//
//
class	CacheState	{
protected : 

	//
	//	Doubly linked list of CacheEntry BLOCKS !
	//
	class	CacheState*	m_pPrev ;
	class	CacheState*	m_pNext ;

	//
	//	Cacge State Information - Time To Live and Orphanage status !
	//
	long				m_TTL ;
	BOOL				m_fOrphan ;

	//
	//	Insert us into the list after the specified element !
	//
	void
	InsertAfter( 
			class	CacheState*	pPrevious 
			) ;

	//
	//	Insert us into the circular list before the specified element !
	//
	void
	InsertBefore( 
			class	CacheState*	pNext 
			)	;

	//
	//	Remove this element from the circular list !
	//
	void
	Remove() ;

	//
	//	The CacheList object maintains a list of these objects and ages them 
	//	out !
	//
	friend	class	CacheList ;

public : 

	//
	//	Default Constructor NULLS everything out !
	//
	CacheState( DWORD	ttl = 0 )	: 
	   m_pPrev( 0 ), m_pNext( 0 ), m_TTL( ttl ), m_fOrphan( FALSE ) { 
#ifdef	DEBUG
		InterlockedIncrement( &s_cCreated ) ;
#endif
	}

	//
	//	Copy Constructor relinks linked list ! we place ourselves in the linked list
	//	after the rhs element.
	//
	CacheState( CacheState& rhs ) : m_pPrev( 0 ), 
			m_pNext( 0 ), 
			m_TTL( rhs.m_TTL ), 
			m_fOrphan( rhs.m_fOrphan )  {

		if( rhs.m_pPrev != 0 ) 
			InsertAfter( &rhs ) ;
#ifdef	DEBUG
		InterlockedIncrement( &s_cCreated ) ;
#endif
	}

	//
	//	If we are in a linked list - the default destructor needs to remove us
	//	from that list.
	//
	~CacheState() ;

	//
	//	Need a virtual function which we use to figure out when we can 
	//	safely remove an entry from the Cache !!
	//
	virtual	BOOL	fDeletable() {	return	TRUE ; } 	

#ifdef	DEBUG

	static	long	s_cCreated ;

#endif

} ;

//
//	This class defines a couple of virtual functions 
//	which are to be called from CacheList objects.
//
class	CacheTable	{
protected :

	friend	class	CacheList ;

	//
	//	Remove an entry from the Cache - return TRUE if 
	//	successful and pEntry destroyed.
	//
	virtual	BOOL	RemoveEntry( 
							CacheState*	pEntry 
							) ;

	//
	//	Called to determine whether we want to remove a 
	//	specified entry from the cache.
	//
	virtual	BOOL	QueryRemoveEntry(	
							CacheState*	pEntry 
							) ;

} ;

class	CacheList	{
private : 

	//
	//	Keep this element around so we can keep a doubly linked list
	//	of the elements in the Cache List.
	//
	CacheState	m_Head ;

	//
	//	Make this private - nobody gets to copy us !
	//
	CacheList( CacheList& ) ;	

protected : 


	//
	//	Number of Elements in the Cache !
	//
	long		m_cEntries ;

	//	
	//	Number of elements (approximately) ready to be removed from 
	//	the cache !
	//
	long		m_cReadyToDie ;

public : 

	//
	//	Maximum number of Elements in the List !
	//
	long		m_cMax ;

	//
	// Stop hint function to be called during long shutdown loops.
	//
	PSTOPHINT_FN m_pfnStopHint;

	//
	//	Initialize the Cache list !
	//
	CacheList(	long	Max = 128 ) ;

#ifdef	DEBUG
	//
	//	In debug builds the destructor helps track how many of these
	//	are created !!
	//
	~CacheList() ;
#endif

	//
	//	Append an Entry into the CacheList.  We Append as this element 
	//	should have the largest Age and most likely to be the last element expired !
	//
	//	Returns TRUE if the number of entries is larger than our pre-ordained Maximum !
	//
	BOOL
	Append(		const	CacheState*		pEntry ) ;


	//
	//	Remove an arbitrary Entry from the CacheList !
	//
	//	Returns TRUE if the number of remaining entries is larger than our pre-ordained Maximum !
	//
	BOOL
	Remove(		const	CacheState*		pEntry ) ;

	//
	//	Walk the list and Expire any entries in there !
	//	This means we decrement TTL's and count up the number of 
	//	entries in the list we could drop right now !
	//
	BOOL
	Expire(	DWORD&	cReady ) ;

	//
	//	Go find those elements who's TTL has dropped below 0 and 
	//	get rid of them from the cache !!
	//
	//	NOTE - if fDoCheap is set to TRUE then we use m_cReadyToDie
	//	to figure out if there's any work we can do !
	//
	BOOL
	Expunge(	CacheTable*	ptable,
				BOOL		fDoCheap = FALSE,	
				const	CacheState*	pProtected = 0 
				) ;

	//
	//	Go remove a single element who's TTL haven't dropped below 0
	//	and get rid of it from the Cache !
	//
	BOOL
	ForceExpunge(	CacheTable*	ptable, 
					const	CacheState*	pProtected = 0
					) ;

	//
	//	Go find those elements who's TTL has dropped below 0 and 
	//	get rid of them from the cache !!
	//
	BOOL
	ExpungeSpecific(	CacheTable*	ptable,	
						BOOL fForced  
						) ;

	//
	//	Bump the life time of the specified object up, 
	//	as somebody is re-using it from the cache !
	//
	void
	LiveLonger(		CacheState*	pEntry, 
					long		ttl
					) ;

#ifdef	DEBUG

	static	long	s_cCreated ;

#endif

} ;

	



//
//	This template class adds one member to the 'CacheState' class, 
//	which is the Reference counting pointer to the block of data we
//	are keeping in the Cache !  
//	In addition - we let the user specify whether Cache Blocks must be
//	atomic.  An atomic Cache block means we must never remove an element
//	from the Cache for which somebody external has a reference !
//	(ie  if fAtomic == TRUE then we only remove elements from the cache
//	when the reference count on the Data is zero meaning that we have the 
//	last reference !!!
//
//
template<	class	Data,	class	Key,	class   KEYREF, BOOL	fAtomic = TRUE >	
class	CacheEntry : public	CacheState		{
public : 

	CRefPtr< Data >		m_pData ;

	CacheEntry*		m_pNext ;
	//
	//	Default constructor just passes on TTL data to CacheState object
	//
	CacheEntry( DWORD ttl=0 ) : CacheState( ttl ), m_pNext(0) {}

	//
	//	We do not declare a copy constructor as the default 
	//	compiler provided copy constructor which invokes 
	//	base class and member variable copy constructors works fine !
	//
	CacheEntry( CacheEntry& rhs ) :
        m_pData( rhs.m_pData ),
        m_pNext( rhs.m_pNext ),
        CacheState( *((CacheState *) &rhs) ) {
    }

	//
	//	We do not declare a destructor as the default compiler 
	//	provided destructor works fine !
	//
	//	~CacheEntry() ;

	//
	//	Return a reference to the Key data from the data portion !
	//
	KEYREF	GetKey()	{
		KEYREF  key;
        m_pData->GetKey(&key) ;
        return key;
	}

	//
	//	Return 0 if the provided Key matches that contained in the 
	//	data block !
	//
	int		MatchKey( KEYREF	key	)	{
		return	m_pData->MatchKey( key ) ;
	}

	//
	//	Determine whether we can remove the Data represented by this 
	//	entry from the Cache.  'fAtomic' == TRUE means that we should
	//	only release entries from the cache when the cache is the 
	//	only component holding a reference to the entry.
	//	This ensures that two pieces of 'Data' which are located 
	//	with the same 'Key' never exist at the same time.
	//
	BOOL	fDeleteable()	{
		if( !fAtomic ) {
			return	TRUE ;
		}
		return	m_pData->m_refs == 0 ;
	}

} ;



//
//	This is a base class for those objects which wish to be
//	called on a regularily scheduled basis.
//
//	The constructors for this class will automatically
//	put the object in a doubly linked list walked by a 
//	background thread which periodically executes a virtual function.
//
//
class	CScheduleThread {
private : 

	//
	//	Special constructor for the 'Head' element of the 
	//	doubly linked list this class maintains.
	//
	CScheduleThread( BOOL	fSpecial ) ;
	
protected : 

	//
	//	Has the scheduler been initialized ? 
	//
	static	BOOL			s_fInitialized ;

	//
	//	Crit sect protecting doubly linked list.
	//
	static	CRITICAL_SECTION	s_critScheduleList ;

	//
	//	Handle to event used to terminate background thread.
	//
	static	HANDLE			s_hShutdown ;

	//
	//	Handle to background thread.
	//
	static	HANDLE			s_hThread ;

	//
	//	The head element of the doubly linked list.
	//
	static	CScheduleThread		s_Head ;

	//
	//	The thread which calls our virtual functions
	//
	static	DWORD	WINAPI	ScheduleThread(	LPVOID	lpv ) ;

	//
	//	Previous and Next pointers which maintain doubly linked
	//	list of scheduled itesm.
	//
	class	CScheduleThread*	m_pPrev ;
	class	CScheduleThread*	m_pNext ;

protected : 

	//
	//	Derived classes should override this function - 
	//	it will be called on a regular basis by the scheduler thread.
	//
	virtual	void	Schedule( void ) {}

	//
	//	Constructor and Destructor automagically manage
	//	insertion into doubly linked list of other scheduled items.
	//	These are protected as we want people to buid only 
	//	derived objects which use this.
	//
	CScheduleThread() ; 

	//
	//	Member functions which put us into the regular schedule !
	//
	void	AddToSchedule() ;
	void	RemoveFromSchedule() ;
		
public : 

	//
	//	Initialize the class - don't construct
	//	any derived objects before this is called.
	//
	static	BOOL	Init() ;

	//
	//	Terminate class and background thread !
	//
	static	void	Term() ;

	//
	//	Global which tells clients how frequently they
	//	will be called !	
	//
	static	DWORD	dwNotificationSeconds ;

	//
	//	Destructor is protected - we should only be invoked
	//	by derived class constructors
	//
	~CScheduleThread() ;

} ;
		




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cldbg.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Normandy client debug defines
//
//	History:
//		davidsan	05/01/96	Created
//
//--------------------------------------------------------------------------------------------

#ifndef _CLDBG_H
#define _CLDBG_H

#ifdef DEBUG

#define ASSERT_GLE 0x00000001

extern void AssertProc(LPCSTR szMsg, LPCSTR szFile, UINT iLine, DWORD grf);

#define Assert(f) (void)((f) || (AssertProc(#f, __FILE__, __LINE__, 0), 0))
#define AssertGLE(f) (void)((f) || (AssertProc(#f, __FILE__, __LINE__, ASSERT_GLE), 0))
#define AssertSz(f,sz) (void)((f) || (AssertProc(sz, __FILE__, __LINE__, 0), 0))

#else

#define Assert(f)
#define AssertGLE(f)
#define AssertSz(f,sz)

#endif

#endif  // _CLDBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cachemt.h ===
/*++

	CacheMt.h

	This header file defines a template for 



--*/


#ifndef	_CACHEMT_H_
#define	_CACHEMT_H_


// This callback function is used to issue a stop hint during a
// long spin while shutting down so that the shutdown won't time
// out.
typedef void (*PSTOPHINT_FN)();

#include	"smartptr.h"
#include	<fhashex.h>
#include	<mtlib.h>
#include	"cachemti.h"


//
//	This is a little helper function for _ASSERT's - returns
//	TRUE if lpv is an address on the calling thread's stack !
//
BOOL
FOnMyStack( LPVOID	lpv ) ;


//
//	CacheCallback class - clients can pass an object derived from 
//	this into the Cache for functions which require some kind of user
//	callback processing !
//
template<	class	Data	>
class	CacheCallback	{
public : 
	virtual	BOOL	fRemoveCacheItem(	Data&	d )	{
		return	FALSE ;
	}
} ;

template<	class	Data,
			class	Key,
			class	Constructor
			>
class	CacheImp : public	CacheSelector	
			{
//
//	This class exists to implement a generic Caching system.
//	We assume that only a single thread ever enters any of our
//	API's at a time.  This class is not to be directly exposed
//	to customers, instead CacheInterface<> exists to provide 
//	an API for customers.
//

public : 
	//
	//	Defines an element of the cache !
	//
	typedef	TEntry< Data, Key >		TENTRY ;

private : 
	//
	//	A signature DWORD for identifying these things in memory !
	//
	DWORD		m_dwSignature ;

	//
	//	Define the hashtable we use to hold Cache Elements !
	//
	typedef	TFHashEx< TENTRY, Key >	CACHELOOKUP ;
	
	//
	//	The hash table we use to keep track of entries in the cache !
	//
	CACHELOOKUP		m_Lookup ;

	//
	//	This is the doubly linked list of elements in our cache !
	//	
	CacheList		m_ExpireList ;

	//
	//	The number of subtract from the current time to 
	//	determine our expire date !
	//
	ULARGE_INTEGER	m_qwExpire ;

public : 

	//
	//	The following structures and functions define the 
	//	portion of our interface designed to work with ASYNC
	//	mechanisms provide by TMtService<>
	//

	//
	//	Defines the structure that holds all of the
	//	arguments for FindOrCreate
	//	We wrap this stuff all into one struct to make it
	//	easy to use the TMtServce<> family of templates !
	//	
	struct	FORC_ARG	{
		DWORD			m_dwHash ;
		Key&			m_key ;
		Constructor&	m_constructor ;
		FORC_ARG(	DWORD	dw,
						Key&	key,
						Constructor&	constructor
						) : 
			m_dwHash( dw ),
			m_key( key ),
			m_constructor( constructor )	{
		}
	} ;

	//
	//	Define the object that selects items for removal from the
	//	Cache - 
	//
	typedef	CacheCallback< Data >	CCB_OBJ ;

	//
	//	Arguments for Expunge !
	//
	struct	EXP_ARG	{
		Key*		m_pkey ;
		TENTRY*		m_pData ;
		EXP_ARG( Key*	pkey, TENTRY*	pData ) : 
			m_pkey( pkey ), 
			m_pData( pData )	{
		}
	} ;

	//
	//	Define the structure that holds all arguments for 
	//	Expunge interface.	
	//
	struct	EXP_SPECIFIC_ARG	{
		//
		//	The object which selects what is to be removed from the cache
		//
		CCB_OBJ*	m_pCacheCallback ;
		//
		//	A pointer to an entry which should NOT be removed !
		//
		TENTRY*		m_pProtected ;
		//
		//	If TRUE kick things out even if they aren't ready to expire !
		//
		BOOL		m_fForced ;

		EXP_SPECIFIC_ARG(	CCB_OBJ*	pCallback,
					TENTRY*		pProtected, 
					BOOL		fForced 
					) : 
			m_pCacheCallback( pCallback ), 
			m_pProtected( pProtected ),
			m_fForced( fForced )	{
		}
	} ;

protected : 
	//
	//	When Executing ExpungeSpecific() - this holds onto the user
	//	provided Callback for selecting deleted items !
	//
	CCB_OBJ*	m_pCurrent ;

	//
	//	This member function removes entries from the cache -	
	//	we remove them from the hash table which leads to destruction !
	//
	void
	RemoveEntry(	
				CacheState*	pCacheState
				) ;
	//	
	//	This function checks to see whether we wish to remove an element !
	//
	BOOL
	QueryRemoveEntry( 	
				CacheState*	pState
				) ;

	//
	//	FindOrCreate results
	//
	typedef		CRefPtr< Data >	FORC_RES ;

public : 

	CacheImp() ;

	//
	//	If this function returns TRUE then callers can be
	//	notified at arbitrary times of the results.
	//	The BOOL return value is required by the TMtService templates.
	//
	//
	BOOL
	FindOrCreate(
			FORC_ARG&	args, 
			FORC_RES&	result
			) ;
	//
	//	This function removes specified items from the cache !
	//
	BOOL
	Expunge(
		EXP_ARG&		args,
		DWORD&			countExpunged
		) ;

	BOOL
	ExpungeSpecific(
		EXP_SPECIFIC_ARG&	args, 
		DWORD&				countExpunged
		) ;

	BOOL
	Expire(
		DWORD&	countExpunged
		) ;

	//
	//	The following set of functions are for synchronous use
	//	such as Initialization and Termination of the Cache.
	//

	//
	//	Initialization function - take pointer to function 
	//	which should be used to compute hash values on Key's
	//	Also takes the number of seconds objects should live in 
	//	the cache !
	//
	BOOL	
	Init(	
			DWORD	(*pfnHash)( const Key& ), 
			DWORD	dwLifetimeSeconds, 
			DWORD	cMaxInstances,
			PSTOPHINT_FN pfnStopHint = NULL
			)	;

	//
	//	Compute the hash of a key - provided for debug purposes and _ASSERT's
	//	not for regular use !
	//
	DWORD
	ComputeHash(	Key&	k ) ;

} ;

template<	class	Data,
			class	Key,
			class	Constructor	>
class	TAsyncCache {
public : 

	//
	//	The template class that implements the Cache.
	//
	typedef	CacheImp< Data, Key, Constructor >	IMP ;

private:

	//
	//	Singature for identifying these Async Cache things
	//
	DWORD		m_dwSignature ;

	//
	//	This is the object which actually implements the Cache functionality
	//	NOTE: appears before CACHE_SERVICE so its constructor is called first !
	//
	IMP			m_Implementation ;

public : 

	//
	//	A typedef for the objects we will take in our 
	//	interface which get completion notifications.
	//
	typedef	TCompletion< IMP::FORC_RES >	COMP_OBJ ;

	//
	//	A typedef for the objects which handle Expunge Completions !
	//	The completion function gets the number of objects expunged
	//	from the cache !
	//
	typedef	TCompletion< DWORD >			EXP_COMP_OBJ ;

	//
	//	Some typedefs so that users can extract our template parameters
	//	back out !
	//
	typedef	Data	CACHEDATA ;
	typedef	Key		CACHEKEY ;
	
private :
	//
	//	The kind of object we use to encapsulate a call
	//	to the cache.
	//
	typedef	TMFnDelay< 
						IMP, 
						IMP::FORC_RES, 
						IMP::FORC_ARG
						>	CACHE_CREATE_CALL ;

	//
	//	The kind of object we use to encapsulate an Expunge Call
	//
	typedef	TMFnDelay<
						IMP, 
						DWORD, 
						IMP::EXP_ARG
						>	EXPUNGE_CALL ;

	typedef	TMFnDelay<
						IMP,
						DWORD,
						IMP::EXP_SPECIFIC_ARG
						>	EXPUNGE_SPECIFIC ;

	typedef	TMFnNoArgDelay<
						IMP,
						DWORD
						>	EXPIRE_CALL ;

	//
	//	Define the type of our CACHE_SERVICE
	//
	typedef	TMtService< IMP >	CACHE_SERVICE ;

	//
	//	This is the object which manages the Queue of Async Cache requests !
	//
	CACHE_SERVICE	m_Service ;

	//	
	//	Set to TRUE if we have been successfully initialized.
	//
	BOOL			m_fGood ;

public : 

	//
	//	Default constructor
	//
	TAsyncCache() ;

	//
	//	Find an Item in the Cache or Create an Item to be held in the Cache !
	//
	BOOL
	FindOrCreate(	CStateStackInterface&	allocator,
					DWORD	dwHash,
					Key&	key,
					Constructor&	constructor,
					COMP_OBJ*	pComplete ) ;

	//
	//	Remove an Item from the cache !
	//
	//
	//	Function which can be used to remove items from the Cache
	//	
	BOOL	
	Expunge(	
			CStateStackInterface&	allocator,
			EXP_COMP_OBJ*	pComplete,
			Key*	key = 0,	
			IMP::TENTRY*	pData = 0 
			)	; 

	//
	//	Function which can be passed a function pointer to determine
	//	exactly what items are to be removed from the Cache.
	//	if fForced == TRUE then items are removed from the Cache
	//	no matter what. 
	//
	BOOL	
	ExpungeSpecific(	
			CStateStackInterface&	allocator,
			EXP_COMP_OBJ*	pComplete,
			class	CacheCallback< Data >*	pSelector, 
			BOOL	fForced,
			TEntry<Data,Key>*	pProtected = 0
			)	;

	//
	//	Expire old stuff in the cache - everything older than
	//	dwLifetimeSeconds (specified at Init() time
	//	which is NOT in use should be kicked out.
	//
	BOOL
	Expire(	
			CStateStackInterface&	allocator,
			EXP_COMP_OBJ*	pComplete
			)	;

	//
	//	Initialization function - take pointer to function 
	//	which should be used to compute hash values on Key's
	//	Also takes the number of seconds objects should live in 
	//	the cache !
	//
	BOOL	
	Init(	
			DWORD	(*pfnHash)( const Key& ), 
			DWORD	dwLifetimeSeconds, 
			DWORD	cMaxInstances,
			PSTOPHINT_FN pfnStopHint = NULL
			)	;
} ;


template<	class	Data,
			class	Key,
			class	Constructor
			>
class	TMultiAsyncCache {
private : 

	typedef	TAsyncCache< Data, Key, Constructor >	ASYNCCACHEINSTANCE ;

	//
	//	Signature for these objects in memory !
	//
	DWORD	m_dwSignature ;
	
	//
	//	Array of Caches to use for client requests 
	//
	ASYNCCACHEINSTANCE*		m_pCaches ;

	//
	//	Number of ASYNCCACHEINSTANCE objects pointed to be m_pCaches !
	//
	DWORD	m_cSubCaches ;

	//
	//	The Hash Function to be used !
	//
	DWORD	(*m_pfnHash)( const Key& ) ;

	//
	//	Function which computes which of our child caches to use !
	//
	DWORD
	ChooseInstance( DWORD	dwHash ) ;

public :

	typedef	ASYNCCACHEINSTANCE::COMP_OBJ		COMP_OBJ ;
	typedef	ASYNCCACHEINSTANCE::EXP_COMP_OBJ	EXP_COMP_OBJ ;

	TMultiAsyncCache() ;
	~TMultiAsyncCache() ;

	//
	//	Initialization function - take pointer to function 
	//	which should be used to compute hash values on Key's
	//	Also takes the number of seconds objects should live in 
	//	the cache !
	//
	BOOL	
	Init(	
			DWORD	cCaches,
			DWORD	(*pfnHash)( const Key& ), 
			DWORD	dwLifetimeSeconds, 
			DWORD	cMaxInstances,
			PSTOPHINT_FN pfnStopHint = NULL
			) ;

	//
	//	Find an Item in the Cache or Create an Item to be held in the Cache !
	//
	BOOL
	FindOrCreate(	CStateStackInterface&	allocator,
					DWORD	dwHash,
					Key&	key,
					Constructor&	constructor,
					COMP_OBJ*	pComplete ) ;

	//
	//
	//
	BOOL
	FindOrCreate(	CStateStackInterface&	allocator,
					Key&	key,
					Constructor&	constructor,
					COMP_OBJ*		pComplete
					) ;
			
	//
	//	Remove an Item from the cache !
	//
	//
	//	Function which can be used to remove items from the Cache
	//	
	BOOL	
	Expunge(	
			CStateStackInterface&	allocator,
			EXP_COMP_OBJ*	pComplete,
			Key*	key = 0
			) ;

	//
	//	Function which can be passed a function pointer to determine
	//	exactly what items are to be removed from the Cache.
	//	if fForced == TRUE then items are removed from the Cache
	//	no matter what. 
	//
	BOOL	
	ExpungeSpecific(	
			CStateStackInterface&	allocator,
			EXP_COMP_OBJ*	pComplete,
			class	CacheCallback< Data >*	pSelector, 
			BOOL	fForced
			) ;

	//
	//	Expire old stuff in the cache - everything older than
	//	dwLifetimeSeconds (specified at Init() time
	//	which is NOT in use should be kicked out.
	//
	BOOL
	Expire(	
			CStateStackInterface&	allocator,
			EXP_COMP_OBJ*	pComplete
			) ;
}	;

#include	"cachemtx.h"

#endif	// _CACHEMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cachex.h ===
/*++

Cachex.h

	This file defines some templates which implement
	a generic cache manager.


	In order to use the Cache manager, your class must
	have the following :



		//
		//	SampleClass derives from CRefCount as smart pointers
		//	'CRefPtr<Data>' are used to manage the life time of cached
		//	objects.
		//

	class	SampleClass : public CRefCount {


		//
		//	Cached class has a constructor which takes two
		//	arguments, the Key used to find the Data in the Cache
		//	and the 'Constructor' (which is a type specified in
		//	the cache template) which contains whatever
		//	initialization data that needs to be passed.
		//
		//	The Cached class should do minimal work within the
		//	constructor.  The FindOrCreate() function will also
		//	call an innitialization class which finishes initialization
		//	of the object.
		//
		SampleClass( Key& k, Constructor &constructor ) ;

		//
		//	If the Cached class does not do all of its initialization
		//	in its Constructor, then The ExclusiveLock() function must
		//	guarantee that no clients can use the object untill the
		//	lock is released.
		//
		//	If the Cached class is completely initialized after the
		//	constructor is called then this can be a no-op function.
		//
		ExclusiveLock() ;

		//
		//	After this is called clients may use the object.
		//
		ExclusiveUnlock() ;


		//
		//	The Init() function is called by FindOrCreate()
		//	after the contructor has been invoked.  This function
		//	must complete any initialization required.
		//
		//	Member functions are called by FindOrCreate() in this order :
		//
		//	SampleClass() // Constructor is called
		//	ExclusiveLock()
		//	Init()
		//	ExclusiveUnlock()
		//
		//	All Cache Client code must be able to deal with objects
		//	returned from the cache which failed initialization for
		//	whatever reason.
		//
		BOOL	Init( Constructor&	constructor ) ;

		//
		//	This function must return a reference to the
		//	Key value stored within the data.
		//
		void	GetKey(Key& key) ;

		//
		//	Must return non-zero if the provided Key matches
		//	the one stored in the data .
		//
		int	MatchKey( Key& ) ;

	} ;


--*/


#ifndef	_CACHEX_H_
#define	_CACHEX_H_

#ifndef	_ASSERT	
#define	_ASSERT(x)	if(!(x)) DebugBreak() ; else
#endif


// This callback function is used to issue a stop hint during a
// long spin while shutting down so that the shutdown won't time
// out.
typedef void (*PSTOPHINT_FN)();

//
//	cacheint.h includes all the necessary helper classes
//	etc... that make the general cache engine work !
//
//
#include	"cacheinx.h"

//
//	Utility class for those which wish to have pools of locks for
//	their objects !
//
class	CLockPool	{
private :

	//
	//	Array of locks to share amongst Xover data structures
	//
	_CACHELOCK	m_locks[256] ;

	//
	//
	//
	long		m_lockIndex ;
public :

	_CACHELOCK*	AllocateLock()	{
		return	&m_locks[	DWORD(InterlockedIncrement( &m_lockIndex )) % 256 ] ;
	}
} ;

//
//	CacheCallback class - clients can pass an object derived from
//	this into the Cache for functions which require some kind of user
//	callback processing !
//
template	<	class	Data >
class	CacheCallback	{
public :
	virtual	BOOL	fRemoveCacheItem(	Data*	d )	{
		return	FALSE ;
	}
} ;




//
//	Call these functions to initialize the Cache Library
//
extern	BOOL	__stdcall CacheLibraryInit() ;
extern	BOOL	__stdcall CacheLibraryTerm() ;





template	<	class	Data,	
				class	Key,	
				class	KEYREF,		/* This is the type used to point or reference items in the cache*/
				class	Constructor,	
				BOOL	fAtomic = TRUE
				>
class	Cache :	public	CScheduleThread,
						CacheTable	{
private :

	//
	//	Define a 'CACHEENTRY' object which holds all the
	//	necessary data for each object which is placed in the cache !
	//
	typedef	CacheEntry< Data, Key, KEYREF,  fAtomic >	CACHEENTRY ;

    //
    //  Define callback objects for Expunge Operations.
    //
    typedef CacheCallback< Data > CALLBACKOBJ;

	//
	//	Is the 'Cache' initialized and in a valid state !
	//
	BOOL							m_fValid ;

	//
	//	A list of everything in the Cache, used for TTL processing
	//
	CacheList						m_ExpireList ;

	//
	//	A hash table we use to find things within the Cache
	//
	TFHashEx< CACHEENTRY, Key, KEYREF >   m_Lookup ;

	//
	//	Pointer to a runtime-user provided function which is used
	//	to determine what things should be removed from the Cache
	//
	BOOL							(* m_pfnExpungeSpecific )( Data & ) ;

	//	
	//	Pointer to a runtime-user provided object derived from CacheCallback< Data >
	//	which lets the user invoke some function for each item in the Cache !
	//
	CALLBACKOBJ*            		m_pCallbackObject ;

	//
	//	Reader writer lock which protects all these data structures !
	//
	_CACHELOCK						m_Lock ;

	//
	//	The initial TTL we should assign to all newly cached objects !
	//
	DWORD							m_TTL ;

protected :

	//
	//	Virtual function called by CScheduleThread's thread which
	//	we use to bump TTL counters
	//
	void
	Schedule();

	//
	//	Function which removes an Entry from the Cache !
	//
	BOOL	
	RemoveEntry(	
			CacheState*	pEntry
			) ;

	//
	//	Virtual Function called by CacheList when we pass call
	//	CacheList::ExpungeSpecific
	//
	BOOL	
	QueryRemoveEntry(	
			CacheState*	pEntry
			) ;


	//
	//	Function which can remove a specific item from the Cache
	//	or walk the Cache deleting all the expired items.
	//	
	//
	BOOL	
	ExpungeInternal(	
			KEYREF	key,	
			CACHEENTRY*	pData = 0,
            BOOL    fIgnoreKey = TRUE,
			const	CACHEENTRY*	pProtected = 0,
			BOOL	fDoCheap = FALSE
			)	;

	
public :

	//
	//	INTERNAL API's - These are public for convenience - not intended
	//	for Use outside of cachelib !!
	//
	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result through pDataOut no matter what !
	//
	BOOL	
	FindOrCreateInternal(	
			DWORD	dwHash,
			KEYREF	key,
			Constructor&	constructor,
			CRefPtr< Data >&	pDataOut
			) ;



	//
	//	Constructor - cMax specifies the maximum number of entries
	//	we should hold in the cache.
	//
	Cache( ) ;

	//
	//	Destructor - remove ourselves from schedule list before continuing !
	//
	~Cache() ;

	//
	//	Initialization function - take pointer to function
	//	which should be used to compute hash values on Key's
	//	Also takes the number of seconds objects should live in
	//	the cache !
	//
	BOOL	
	Init(	
			DWORD	(*pfnHash)( KEYREF ),
			DWORD	dwLifetimeSeconds,
			DWORD	cMaxInstances,
			PSTOPHINT_FN pfnStopHint = NULL
			) ;

	//
	//	Function which can be used to remove items from the Cache
	//	If default args are used we pick an expired item in the Cache
	//	to remove
	//
	BOOL	
	Expunge(	
			KEYREF	key,	
			CACHEENTRY*	pData = 0,
            BOOL fIgnoreKey = TRUE
			) ;

	//
	//	Function which can be passed a function pointer to determine
	//	exactly what items are to be removed from the Cache.
	//	if fForced == TRUE then items are removed from the Cache
	//	no matter what.
	//
	BOOL	
	ExpungeSpecific(	
			CALLBACKOBJ* pCallback,
			BOOL	fForced
			) ;




	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result through pDataOut no matter what !
	//
	BOOL	
	FindOrCreate(	
			KEYREF	key,
			Constructor&	constructor,
			CRefPtr< Data >&	pDataOut
			) ;


#ifdef	DEBUG

	static	long	s_cCreated ;

#endif

} ;



template	<	class	Data,	
				class	Key,	
				class	KEYREF,		/* This is the type used to point or reference items in the cache*/
				class	Constructor,	
				BOOL	fAtomic = TRUE
				>
class	MultiCache {
private :

	//
	//	Define a 'CACHEENTRY' object which holds all the
	//	necessary data for each object which is placed in the cache !
	//
	typedef	CacheEntry< Data, Key, KEYREF,  fAtomic >	CACHEENTRY ;

	//
	//	Define the type for a single instance !
	//
	typedef	Cache< Data, Key, KEYREF, Constructor, fAtomic >	CACHEINSTANCE ;

	//
	//	Is the 'Cache' initialized and in a valid state !
	//
	BOOL							m_fValid ;

	//
	//	Pointer to the various Cache's we subdivide our work into
	//
	CACHEINSTANCE					*m_pCaches ;

	//
	//	Number of sub cache's we use to split up the work !
	//
	DWORD							m_cSubCaches ;

	//
	//	We use the hash function to choose which of our subcaches to work with !
	//
	DWORD							(*m_pfnHash)( KEYREF ) ;

	//
	//	Return the correct cache instance to hold the selected piece of data !
	//
	//DWORD							ChooseInstance( Key&	k ) ;
	DWORD							ChooseInstance( DWORD	dwHash ) ;

public :

    //
    //  Define callback objects for Expunge Operations.
    //
    typedef CacheCallback< Data > CALLBACKOBJ;

	//
	//	Constructor - cMax specifies the maximum number of entries
	//	we should hold in the cache.
	//
	MultiCache(  ) ;

	//
	//	Destructor - destroys are various sub cache's
	//
	~MultiCache() ;

	//
	//	Initialization function - take pointer to function
	//	which should be used to compute hash values on Key's
	//	Also takes the number of seconds objects should live in
	//	the cache !
	//
	BOOL	
	Init(	
			DWORD	(*pfnHash)( KEYREF ),
			DWORD	dwLifetimeSeconds,
			DWORD	cSubCaches,
			DWORD	cMaxElements,
			PSTOPHINT_FN pfnStopHint = NULL
			) ;

	//
	//	Function which can be used to remove items from the Cache
	//	If default args are used we pick an expired item in the Cache
	//	to remove
	//
	BOOL	
	Expunge(	
			KEYREF  key,	
			CACHEENTRY*	pData = 0,
            BOOL fExpungeAll = FALSE
			) ;


	//
	//	Function which can be passed a function pointer to determine
	//	exactly what items are to be removed from the Cache.
	//	if fForced == TRUE then items are removed from the Cache
	//	no matter what.
	//
	BOOL	
	ExpungeSpecific(	
			CALLBACKOBJ* pCallback,
			BOOL	fForced
			) ;

	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result through pDataOut no matter what !
	//
	BOOL	
	FindOrCreate(	
			KEYREF	key,
			Constructor&	constructor,
			CRefPtr< Data >&	pDataOut
			) ;

	//
	//	Either find an item in the cache or Construct a new item
	//	and place it in the Cache.
	//	return the result through pDataOut no matter what !
	//	NOTE : This is for use when the caller has a cheaper
	//	way to compute the hash value then us - in debug we
	//	need to assure that the caller correctly computes this !
	//
	BOOL	
	FindOrCreate(	
			KEYREF	key,
			DWORD	dwHash,
			Constructor&	constructor,
			CRefPtr< Data >&	pDataOut
			) ;


} ;



#include	"cacheimx.h"

#endif	// _CACHEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cachemtx.h ===
/*++

	CacheMTX.h

	This file provides the definition of the all the template
	functions required by cachemt.h


--*/

#ifndef	_CACHEMTX_H_
#define	_CACHEMTX_H_




//
//	This member function removes entries from the cache -	
//	we remove them from the hash table which leads to destruction !
//
template<	class	Data,
			class	Key,
			class	Constructor
			>
void
CacheImp<Data, Key, Constructor>::RemoveEntry(	
			CacheState*	pCacheState
			)	{
/*++

Routine Description : 

	Remove a CacheState object from the hash table

Arguments : 

	pCacheState - The CacheState derived object about to be destroyed 

Return Value : 

	TRUE if removed !

--*/
	TENTRY*	pEntry = (TENTRY*)pCacheState ;
	Key k;
	pEntry->GetKey(k);
	m_Lookup.DeleteData( k, pEntry ) ; 
} 

template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL
CacheImp<Data, Key, Constructor>::QueryRemoveEntry( 	
			CacheState*	pState
			)	{
/*++

Routine Description : 

	Determine whether we want to remove an entry from cache - do 
	so by calling a user provided object stored in a member variable - m_pCurrent

Arguments : 

	pCacheState - The CacheState object we're curious about

Return Value : 

	TRUE if removed !

--*/
	_ASSERT( m_pCurrent != 0 ) ;

	TENTRY*	pEntry = (TENTRY*)pState ;
	if( m_pCurrent ) 
		return	m_pCurrent->fRemoveCacheItem( *pEntry->m_pData ) ;
	return	TRUE ;
}

template<	class	Data,
			class	Key,
			class	Constructor
			>
CacheImp<Data, Key, Constructor>::CacheImp() : 
	m_dwSignature(	DWORD('hcaC') ) ,
	m_pCurrent( 0 )	{
/*++

Routine Description : 

	Construct a CacheImp object - Init() must be called before any use

Arguments : 

	None

Return Value : 

	None

--*/

}

template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL
CacheImp<Data, Key, Constructor>::FindOrCreate(
		FORC_ARG&	args, 
		FORC_RES&	result
		)	{
/*++

Routine Description : 

	Either find an object in the cache or create a new one !

Arguments : 

	args - a structure containing all of the things
		we need, 
		m_dwHash - the hash of the key
		m_key - the actual key of the item we're looking for
		m_constructor - the object which would create 
			a new item into the cace !

	result - 
		a smartptr to the resulting object !

Return Value : 

	We always return TRUE, indicating that the caller
	can marshall the results back to the end-user at any time.

--*/

	//
	//	Check that our state is good !
	//
	_ASSERT( m_ExpireList.IsValid() ) ;

	_ASSERT( args.m_dwHash == ComputeHash( args.m_key ) ) ;

	//
	//	Check to see whether the item is already in the cache !
	//
	TENTRY	*pEntry = m_Lookup.SearchKeyHash(	args.m_dwHash, 
												args.m_key
												) ;

	//
	//	Entry is already present - move it to the back !
	//
	if( pEntry ) {
		//
		//	Update the entry's last access time !
		//
		pEntry->Stamp() ;
		//
		//	Recently touched, so send to the back of the expire list !
		//
		m_ExpireList.MoveToBack(	pEntry ) ; 
		result = pEntry->m_pData ;
	}	else	{
		//
		//	NOTE : TENTRY's constructor will stamp the time fields as required !
		//
		Data*	pData = args.m_constructor.Create( args.m_key ) ;
		if( pData &&
			pData->Init( constructor )	)	{

			TENTRY*	pEntry = new	TENTRY( pData ) ;
			//
			//	Error paths will destroy this unless we set it to NULL !
			//
			pData = 0 ;

			//
			//	If we managed to construct everything !
			//
			if( pEntry ) {
				TENTRY*	pCacheEntry = m_Lookup.InsertDataHash( args.m_dwHash, *pEntry ) ;
				if( pCacheEntry ) {
					//
					//	Error paths will destroy this unless we set it to NULL !
					//
					pEntry = 0 ;
					//
					//	Add to the expiration list - 
					//
					if( m_ExpireList.Append( pCacheEntry ) )	{
						//
						//	The expiration list is at max capacity - should remove something !
						//
						EXP_ARG	args( 0, 0 ) ;
						DWORD	count ;
						Expunge( args, count ) ; 

					}
					result = pCacheEntry->m_pData ;
				}	
			}
			if( pEntry ) {
				delete	pEntry ;
			}
		}	
		if( pData ) {
			delete	pData ;
		}
	}

	//
	//	Check that our state is good !
	//
	_ASSERT( m_ExpireList.IsValid() ) ;

	return	TRUE ;	
}

template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL
CacheImp<Data, Key, Constructor>::Expunge(
	EXP_ARG&		args,
	DWORD&			countExpunged
	)	{
/*++

Routine Description : 

	Find an object in the cache and remove it!

Arguments : 

	args - a structure containing all of the things
		we need, 
		m_pkey - pointer to the key of the item to be removed
		m_pData - pointer to the Cache element holding the item.
	countExpunged - 
		how many objects removed from the cache - should be 1 if 
		the specified item is found.
		
Return Value : 

	We always return TRUE, indicating that the caller
	can marshall the results back to the end-user at any time.

--*/

	//
	//	Check that our state is good !
	//
	_ASSERT( m_ExpireList.IsValid() ) ;

	countExpunged = 0 ;
	if( args.m_pkey ) {
		TENTRY*	pRemoved = m_Lookup.DeleteData( *args.m_pkey, args.m_pData ) ;
		if( pRemoved )	{
			m_ExpireList.Remove( pRemoved ) ;
			countExpunged = 1;
			delete	pRemoved ;
			//
			//	Check that our state is good !
			//
			_ASSERT( m_ExpireList.IsValid() ) ;
			return	TRUE ;
		}
	}
	m_ExpireList.Expunge( this, 0, countExpunged, TRUE ) ; 

	//
	//	Check that our state is good !
	//
	_ASSERT( m_ExpireList.IsValid() ) ;
	return	TRUE ;
}

template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL
CacheImp<Data, Key, Constructor>::ExpungeSpecific(
	EXP_SPECIFIC_ARG&	args, 
	DWORD&				countExpunged
	)	{
/*++

Routine Description : 

	Select a set of items in the cache for removal !
	
Arguments : 

	args - a structure containing all of the things
		we need, 
		m_pCacheCallback - an object to be called to select the items
			to be removed from the cache.
	countExpunged - 
		how many objects removed from the cache - should be 1 if 
		the specified item is found.
		
Return Value : 

	We always return TRUE, indicating that the caller
	can marshall the results back to the end-user at any time.

--*/


	//
	//	Check that our state is good !
	//
	_ASSERT( m_ExpireList.IsValid() ) ;

	countExpunged = 0 ;

	m_pCurrent = args.m_pCacheCallback ;

	m_ExpireList.ExpungeSpecific( this, args.m_fForced, countExpunged ) ;

	m_pCurrent = 0 ;

	//
	//	Check that our state is good !
	//
	_ASSERT( m_ExpireList.IsValid() ) ;

	return	TRUE ;
}

template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL
CacheImp<Data, Key, Constructor>::Expire(
	DWORD&	countExpunged
	)	{
/*++

Routine Description : 

	Remove the old items from the cache !

Arguments : 

	countExpunged - 
		how many objects removed from the cache - should be 1 if 
		the specified item is found.
		
Return Value : 

	We always return TRUE, indicating that the caller
	can marshall the results back to the end-user at any time.

--*/

	//
	//	Check that our state is good !
	//
	_ASSERT( m_ExpireList.IsValid() ) ;

	countExpunged = 0 ;

	FILETIME	filetimeNow ;
	GetSystemTimeAsFileTime( &filetimeNow ) ;

	ULARGE_INTEGER	ulNow ;
	ulNow.LowPart = filetimeNow.dwLowDateTime ;
	ulNow.HighPart = filetimeNow.dwHighDateTime ;

	ulNow.QuadPart -= m_qwExpire.QuadPart ;

	filetimeNow.dwLowDateTime = ulNow.LowPart ;
	filetimeNow.dwHighDateTime = ulNow.HighPart ;
	
	m_ExpireList.Expunge(
				this,
				&filetimeNow, 
				countExpunged, 
				FALSE
				) ;

	//
	//	Check that our state is good !
	//
	_ASSERT( m_ExpireList.IsValid() ) ;
	return	TRUE ;
}

//
//	The following set of functions are for synchronous use
//	such as Initialization and Termination of the Cache.
//

//
//	Initialization function - take pointer to function 
//	which should be used to compute hash values on Key's
//	Also takes the number of seconds objects should live in 
//	the cache !
//
template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL	
CacheImp<Data, Key, Constructor>::Init(	
		DWORD	(*pfnHash)( const Key& ), 
		DWORD	dwLifetimeSeconds, 
		DWORD	cMaxInstances,
		PSTOPHINT_FN pfnStopHint
		)	{
/*++

Routine Description : 

	Initialize the cache !

Arguments : 

	pfnHash - The function which can compute the hash value of a key
	dwLifetimeSeconds - The oldest we should let items get within the cache
	cMaxInstances - The maximum number of items we should allow in the cache !
		
Return Value : 

	We return TRUE if the cache successfully initializes.

--*/

	m_qwExpire.QuadPart = DWORDLONG(dwLifetimeSeconds) * DWORDLONG( 10000000 ) ;

	return	m_Lookup.Init( 
						&TENTRY::m_pBucket,
						100, 
						100, 
						pfnHash 
						) ;
}

template<	class	Data,
			class	Key,
			class	Constructor
			>
DWORD
CacheImp<Data, Key, Constructor>::ComputeHash(	
		Key&	key
		)	{
	return	m_Lookup.ComputeHash( key ) ;
}


//
//	Default constructor
//
template<	class	Data,
			class	Key,
			class	Constructor
			>
TAsyncCache< Data, Key, Constructor >::TAsyncCache() : 
	m_Service( m_Implementation ), 
	m_dwSignature( DWORD('CysA' ) ) {
}

//
//	Find an Item in the Cache or Create an Item to be held in the Cache !
//
template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL
TAsyncCache< Data, Key, Constructor >::FindOrCreate(	
				CStateStackInterface&	allocator,
				DWORD	dwHash,
				Key&	key,
				Constructor&	constructor,
				COMP_OBJ*	pComplete )	{
/*++

Routine Description : 

	Marshall all the arguments for Finding and Creating Cache Items to 
	the implementation class !

Arguments : 

	key - The key of the item we want to find in the cache
	constructor - The object which can create an item if needed
	pComplete - the object which is notified if we manage
		to pend the call

Return Value : 

	TRUE if the operation is pending
	FALSE otherwise !

--*/

	_ASSERT( !FOnMyStack( pComplete ) ) ;
	_ASSERT( !FOnMyStack( &constructor ) ) ;
	_ASSERT( !FOnMyStack( &key ) ) ;

	_ASSERT( dwHash == m_Implementation.ComputeHash( key ) ) ;

	if( m_fGood ) {
		IMP::FORC_ARG	args( dwHash, key, constructor ) ;
		CACHE_CREATE_CALL*	pcall = new( allocator )
											CACHE_CREATE_CALL(
													allocator,	
													&IMP::FindOrCreate, 
													args, 
													pComplete 
													) ;
		if( pcall ) {
			m_Service.QueueRequest( pcall ) ;
			return	TRUE ;
		}
	}
	return	FALSE ;
}

//
//	Remove an Item from the cache !
//
//
//	Function which can be used to remove items from the Cache
//	
template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL	
TAsyncCache< Data, Key, Constructor >::Expunge(	
		CStateStackInterface&	allocator,
		EXP_COMP_OBJ*	pComplete,
		Key*	key,
		IMP::TENTRY*	pData
		)	{
/*++

Routine Description : 

	Marshall all the arguments for removing an item from the cache !

Arguments : 

	pComplete - the object which is notified if we manage
		to pend the call
	key - the key of the item to be removed from the cache 
	pData - for internal use only !

Return Value : 

	TRUE if the operation is pending
	FALSE otherwise !

--*/

	if( m_fGood ) {
		IMP::EXP_ARG		args( key, pData ) ;
		EXPUNGE_CALL*	pcall = new( allocator )
									 EXPUNGE_CALL(
											allocator,
											&IMP::Expunge, 
											args, 
											pComplete
											) ;
		if( pcall ) {
			m_Service.QueueRequest( pcall ) ;
			return	TRUE ;
		}
	}
	return	FALSE ;
}

//
//	Function which can be passed a function pointer to determine
//	exactly what items are to be removed from the Cache.
//	if fForced == TRUE then items are removed from the Cache
//	no matter what. 
//
template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL	
TAsyncCache< Data, Key, Constructor >::ExpungeSpecific(	
		CStateStackInterface&	allocator,
		EXP_COMP_OBJ*	pComplete,
		class	CacheCallback< Data >*	pSelector, 
		BOOL	fForced,
		TEntry<Data,Key>*	pProtected
		)	{
/*++

Routine Description : 

	Marshall all the arguments for removing a set of items
	form the cache 

Arguments : 

	pComplete - the object which is notified if we manage
		to pend the call
	pSelector - the object which will select what is to be removed
		from the cache !
	fForced - if TRUE kick items out of the cache even if there
		are external references !
	
Return Value : 

	TRUE if the operation is pending
	FALSE otherwise !

--*/

	if( m_fGood ) {
		IMP::EXP_SPECIFIC_ARG	args(	pSelector,
										pProtected, 
										fForced
										) ;
		EXPUNGE_SPECIFIC*	pcall = new( allocator )
										 EXPUNGE_SPECIFIC(
											allocator,
											&IMP::ExpungeSpecific, 
											args, 
											pComplete
											) ;
		if( pcall ) {
			m_Service.QueueRequest( pcall ) ;
			return	TRUE ;
		}
	}
	return	FALSE ;
}


//
//	Expire old stuff in the cache - everything older than
//	dwLifetimeSeconds (specified at Init() time
//	which is NOT in use should be kicked out.
//
template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL
TAsyncCache< Data, Key, Constructor >::Expire(	
		CStateStackInterface&	allocator,
		EXP_COMP_OBJ*	pComplete
		)	{
/*++

Routine Description : 

	Marshall all the arguments for expiring all the old items
	in the cache

Arguments : 

	pComplete - the object which is notified if we manage
		to pend the call
	
Return Value : 

	TRUE if the operation is pending
	FALSE otherwise !

--*/


	if( m_fGood ) {
		EXPIRE_CALL*	pcall = new( allocator )
									EXPIRE_CALL(
										allocator, 
										&IMP::Expire, 
										pComplete
										) ;
		if( pcall ) {
			m_Service.QueueRequest( pcall ) ;
			return	TRUE ;
		}
	}
	return	FALSE ;
}



//
//	Initialization function - take pointer to function 
//	which should be used to compute hash values on Key's
//	Also takes the number of seconds objects should live in 
//	the cache !
//
template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL	
TAsyncCache< Data, Key, Constructor >::Init(	
		DWORD	(*pfnHash)( const Key& ), 
		DWORD	dwLifetimeSeconds, 
		DWORD	cMaxInstances,
		PSTOPHINT_FN pfnStopHint 
		)	{
/*++

Routine Description : 
	
	Initialize the cache

Arguments : 

	pfnHash - the function used to compute hash values for keys 
	dwLifetimeSeconds - How long something should stay in the cache
		in units of seconds.
	cMaxInstances - the maximum number of items in the cache
	
Return Value : 

	TRUE if successfull 
	FALSE otherwise !

--*/

	m_fGood = m_Implementation.Init(	pfnHash,
										dwLifetimeSeconds, 
										cMaxInstances,
										pfnStopHint 
										) ;
	return	m_fGood ;
}



template<	class	Data,
			class	Key,
			class	Constructor
			>
TMultiAsyncCache< Data, Key, Constructor >::TMultiAsyncCache() : 
	m_dwSignature( DWORD( 'tluM' ) ),
	m_cSubCaches( 0 ),
	m_pfnHash( 0 ),
	m_pCaches( 0 )	{
/*++

Routine Description : 

	Construct a MultiAsyncCache - Init() must be called 
	before we can be used 

Arguments : 

	None

Return Value :

	None

--*/

}	

template<	class	Data,
			class	Key,
			class	Constructor
			>
TMultiAsyncCache< Data, Key, Constructor >::~TMultiAsyncCache()		{

	if( m_pCaches != 0 ) 
		delete[]	m_pCaches ;

}



template<	class	Data,
			class	Key,
			class	Constructor
			>
DWORD
TMultiAsyncCache< Data, Key, Constructor >::ChooseInstance(
			DWORD	dwHash
			)	{
/*++

Routine Description : 

	given the hash value of a key - figure out where it should 
	be stored.

Arguments : 

	dwHash - Computed hash value of a key

Return Value :

	index into m_pCaches

--*/

	_ASSERT( m_pCaches != 0 ) ;
	_ASSERT( m_cSubCaches != 0 ) ;

	dwHash = (((dwHash * 214013) +2531011) >> 8) % m_cSubCaches ;

	return	dwHash ;

}	

template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL
TMultiAsyncCache< Data, Key, Constructor >::Init(	
		DWORD	cCaches,
		DWORD	(*pfnHash)( const Key& ), 
		DWORD	dwLifetimeSeconds, 
		DWORD	cMaxInstances,
		PSTOPHINT_FN pfnStopHint
		)	{
/*++

Routine Description : 

	Initialize the MultiWay Cache - Allocate several
	subcaches to route requests too.

Arguments : 

	cCaches - Number of SubCaches to use !
	pfnHash - Hash Function for cache elements
	dwLifetimeSeconds - How long things can stay in the cache !
	cMaxInstances - Maximum number of elements in the cache !
	pfnStopHint - function to call during shutdown !

Return Value : 

	TRUE if successfull - FALSE otherwise.

--*/

	_ASSERT( cCaches != 0 ) ;
	_ASSERT( pfnHash != 0 ) ;
	_ASSERT( dwLifetimeSeconds > 0 ) ;
	_ASSERT( cMaxInstances > cCaches ) ;

	m_cSubCaches = cCaches ;
	m_pfnHash = pfnHash ;
	
	m_pCaches = new	ASYNCCACHEINSTANCE[m_cSubCaches ] ;

	if( !m_pCaches ) 	
		return	FALSE ;
	else	{
		for( DWORD	i=0; i<m_cSubCaches; i++ ) {
			if( !m_pCaches[i].Init(
								pfnHash,
								dwLifetimeSeconds,
								cMaxInstances / cCaches, 
								pfnStopHint
								) )	{
				delete	m_pCaches ;
				return	FALSE ;
			}
		}
	}
	return	TRUE ;
}
	
template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL
TMultiAsyncCache< Data, Key, Constructor >::FindOrCreate(	
		CStateStackInterface&	allocator,
		DWORD	dwHash,
		Key&	key,
		Constructor&	constructor,
		COMP_OBJ*		pComplete
		)	{
/*++

Routine Description : 

	Find an Element within the Cache - and if its not present,
	create it !

Arguments : 
	
	dwHash - the hash of the key
	key - the key of the item in the cache
	constructor	- the object which will create the
		data item if required.
	pComplete - the object which gets the completion notification !

Return Value : 

	TRUE if successfull - FALSE otherwise.

--*/

	_ASSERT( !FOnMyStack( pComplete ) ) ;
	_ASSERT( !FOnMyStack( &constructor ) ) ;
	_ASSERT( !FOnMyStack( &key ) ) ;

	_ASSERT( m_cSubCaches != 0 ) ;
	_ASSERT( m_pCaches != 0 ) ;
	_ASSERT( dwHash == m_pfnHash( key ) ) ;

	ASYNCCACHEINSTANCE*	pInstance = &m_pCaches[ ChooseInstance( dwHash ) ] ;	
	return	pInstance->FindOrCreate(
								allocator,
								dwHash,
								key,
								constructor,
								pComplete
								) ;
}

	
template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL
TMultiAsyncCache< Data, Key, Constructor >::FindOrCreate(	
		CStateStackInterface&	allocator,
		Key&	key,
		Constructor&	constructor,
		COMP_OBJ*		pComplete
		)	{
/*++

Routine Description : 

	Find an Element within the Cache - and if its not present,
	create it !

Arguments : 
	
	dwHash - the hash of the key
	key - the key of the item in the cache
	constructor	- the object which will create the
		data item if required.
	pComplete - the object which gets the completion notification !

Return Value : 

	TRUE if successfull - FALSE otherwise.

--*/

	_ASSERT( m_cSubCaches != 0 ) ;
	_ASSERT( m_pCaches != 0 ) ;
	_ASSERT( m_pfnHash != 0 ) ;

	_ASSERT( !FOnMyStack( pComplete ) ) ;
	_ASSERT( !FOnMyStack( &constructor ) ) ;
	_ASSERT( !FOnMyStack( &key ) ) ;


	DWORD	dwHash = m_pfnHash( key ) ;

	ASYNCCACHEINSTANCE*	pInstance = &m_pCaches[ ChooseInstance( dwHash ) ] ;	
	return	pInstance->FindOrCreate(
								allocator,
								dwHash,
								key,
								constructor,
								pComplete
								) ;
}


	
template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL
TMultiAsyncCache< Data, Key, Constructor >::Expunge(	
		CStateStackInterface&	allocator,
		EXP_COMP_OBJ*	pComplete,
		Key*	key
		)	{
/*++

Routine Description : 

	Remove a particular item from the cache - this will cause 
	the cache to loose its reference to the item.

Arguments : 

	pComplete - the object to be notified once the target object
		is removed
	key - key of the item to be removed - if NULL remove a 
		single random element.
	pData - Not for External Customers - points to internal
		Cache data structures when we want to ensure we 
		are removing exactly what we want to remove !

Return Value : 

	TRUE if successfull, FALSE otherwise !

--*/

	_ASSERT( !FOnMyStack( pComplete ) ) ;
	_ASSERT( !FOnMyStack( key ) ) ;


	//
	//	If they gave us a key we can select an Instance !
	//
	ASYNCCACHEINSTANCE*	pInstance = &m_pCaches[0] ;
	if( key != 0 ) {
		DWORD	dwHash = m_pfnHash( *key ) ;
		ASYNCCACHEINSTANCE*	pInstance = &m_pCaches[ ChooseInstance( dwHash ) ] ;
	}

	return	pInstance->Expunge(
				allocator, 
				pComplete,
				key, 
				0
				) ;
}


template<	class	AsyncCache >
class	ExpungeWrapper : public AsyncCache::EXP_COMP_OBJ	{
//
//	This class exists to help spread Expunge calls accross
//	all the individual classes 
//
//
private : 
	//
	//	The first cache instance 
	//
	AsyncCache*	m_pCurrent ;
	//
	//	Points beyond the last cache instance 
	//	
	AsyncCache*	m_pLast ;
	//
	//	The user provided Expunge Selector !
	//
	CacheCallback< AsyncCache::CACHEDATA >*	m_pSelector ;
	//
	//	Does the user want items forced from the cache !
	//
	BOOL				m_fForced ;
	//
	//	Object to notify when we have completed removing objects !
	//
	AsyncCache::EXP_COMP_OBJ*	m_pComplete ;
	//
	//	Total number of items removed from the cache !
	//
	DWORD				m_dwTotal ;
	//
	//	The stack used to allocate child objects !
	//
	CStateStackInterface&	m_Stack ;

public :
 
	ExpungeWrapper(
			CStateStackInterface&	stack,
			AsyncCache*	pFirst, 
			AsyncCache*	pLast, 
			AsyncCache::EXP_COMP_OBJ*		pComplete,
			CacheCallback< AsyncCache::CACHEDATA >*	pSelector,
			BOOL				fForced
			) : 
		m_Stack( stack ),
		m_pCurrent( pFirst ),
		m_pLast( pLast ),
		m_pComplete( pComplete ),
		m_pSelector( pSelector ),
		m_fForced( fForced ),
		m_dwTotal( 0 ) {
	}


	//
	//	The function which handles error completions !
	//	
	void	
	ErrorComplete( DWORD	dw ) {
		AsyncCache::EXP_COMP_OBJ*	pTemp = m_pComplete ;
		delete	this ;
		if( pTemp != 0 ) 
			pTemp->ErrorComplete( dw ) ;
	}

	//
	//	The function which handles regular completions !
	//
	void
	Complete( DWORD&	dw )	{
		//
		//	Add up the total number of items Expunged !
		//
		m_dwTotal += dw ;
		
		//
		//	If necessary - Do the Expunge in the next portion
		//	of the cache !
		//
		if( ++m_pCurrent < m_pLast ) {

			if( !m_pCurrent->ExpungeSpecific(
					m_Stack,
					this,
					m_pSelector,
					m_fForced 
					)	)	{
				ErrorComplete( 0 ) ;
			}
		}	else	{

			//
			//	Destroy ourselves before giving the client
			//	a chance to run !!
			//
			AsyncCache::EXP_COMP_OBJ*	pTemp = m_pComplete ;
			DWORD	dwTemp = m_dwTotal ;
			delete	this ;

			//
			//	Let the end user know how many items were removed !
			//
			if( pTemp != 0 ) 
				pTemp->Complete( dwTemp ) ;
		}
	}
} ;



template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL
TMultiAsyncCache< Data, Key, Constructor >::ExpungeSpecific(	
		CStateStackInterface&	allocator,
		EXP_COMP_OBJ*	pComplete,
		class	CacheCallback< Data >*	pSelector,
		BOOL	fForced
		)	{
/*++

Routine Description : 

	Remove many items from the cache, meeting some specified
	criteria !
	We have to wrap the users completion object with our own, 
	as we will notify the end user when all the other 
	notifications are completed.

Arguments : 

	pComplete - the object to be notified once the target object
		is removed
	
	key - key of the item to be removed - if NULL remove a 
		single random element.
	pData - Not for External Customers - points to internal
		Cache data structures when we want to ensure we 
		are removing exactly what we want to remove !

Return Value : 

	TRUE if successfull, FALSE otherwise !

--*/

	_ASSERT( !FOnMyStack( pComplete ) ) ;
	_ASSERT( !FOnMyStack( pSelector ) ) ;

	typedef	ExpungeWrapper< ASYNCCACHEINSTANCE >	WRAPPER ;

	WRAPPER*	pwrapper = new( allocator )
								 WRAPPER(
									allocator,
									&m_pCaches[0],	
									&m_pCaches[m_cSubCaches],
									pComplete,
									pSelector,
									fForced
									) ;

	if( pwrapper ) {
		if( m_pCaches[0].ExpungeSpecific(	allocator,
											pwrapper,
											pSelector,
											fForced
											) )	{
			return	TRUE ;
		}
		delete	pwrapper ;
	}
	return	FALSE ;
}

template<	class	AsyncCache >
class	ExpireWrapper : public	AsyncCache::EXP_COMP_OBJ {
private : 
	//
	//	First Cache we execute on !
	//
	AsyncCache*		m_pCurrent ;
	//
	//	One beyond the last cache we execute on !
	//
	AsyncCache*		m_pLast ;
	//
	//	Total number of objects expired !
	//
	DWORD			m_dwTotal ;
	//
	//	Client's completion object !
	//
	AsyncCache::EXP_COMP_OBJ*	m_pComplete ;
	//
	//	The stack used to allocate child objects !
	//
	CStateStackInterface&	m_Stack ;

public : 
	ExpireWrapper(	CStateStackInterface&	stack,
					AsyncCache*	pFirst, 
					AsyncCache*	pLast,
					AsyncCache::EXP_COMP_OBJ*	pComplete
					) : 
		m_Stack( stack ),
		m_pCurrent( pFirst ),
		m_pLast( pLast ),
		m_pComplete( pComplete ),
		m_dwTotal( 0 ) {
	}

	//
	//	The function which handles error completions !
	//	
	void	
	ErrorComplete( DWORD	dw ) {
		AsyncCache::EXP_COMP_OBJ*	pTemp = m_pComplete ;
		delete	this ;
		if( pTemp != 0 ) 
			pTemp->ErrorComplete( dw ) ;
	}

	//
	//	The function which handles regular completions !
	//
	void
	Complete( DWORD&	dw )	{
		//
		//	Add up the total number of items Expunged !
		//
		m_dwTotal += dw ;
		
		//
		//	If necessary - Do the Expunge in the next portion
		//	of the cache !
		//
		if( ++m_pCurrent < m_pLast ) {

			if( !m_pCurrent->Expire(m_Stack, this ) )	{
				ErrorComplete( 0 ) ;
			}
		}	else	{

			//
			//	Destroy ourselves before giving the client
			//	a chance to run !!
			//
			AsyncCache::EXP_COMP_OBJ*	pTemp = m_pComplete ;
			DWORD	dwTemp = m_dwTotal ;
			delete	this ;

			//
			//	Let the end user know how many items were removed !
			//
			if( pTemp != 0 ) 
				pTemp->Complete( dwTemp ) ;
		}
	}
} ;


template<	class	Data,
			class	Key,
			class	Constructor
			>
BOOL
TMultiAsyncCache< Data, Key, Constructor >::Expire(	
		CStateStackInterface&	allocator,
		EXP_COMP_OBJ*	pComplete
		)	{
/*++

Routine Description : 

	Remove many items from the cache, meeting some specified
	criteria !
	We have to wrap the users completion object with our own, 
	as we will notify the end user when all the other 
	notifications are completed.

Arguments : 

	pComplete - the object to be notified once the target object
		is removed
	
	key - key of the item to be removed - if NULL remove a 
		single random element.
	pData - Not for External Customers - points to internal
		Cache data structures when we want to ensure we 
		are removing exactly what we want to remove !

Return Value : 

	TRUE if successfull, FALSE otherwise !

--*/

	_ASSERT( !FOnMyStack( pComplete ) ) ;

	typedef		ExpireWrapper< ASYNCCACHEINSTANCE >	WRAPPER ;

	WRAPPER*	pwrapper = new( allocator )
								WRAPPER(	allocator, 
											&m_pCaches[0], 
											&m_pCaches[m_cSubCaches ] ,
											pComplete						
											) ;

	if( pwrapper ) {
		if( m_pCaches[0].Expire(	allocator, pwrapper ) )	{
			return	TRUE ;
		}
		delete	pwrapper ;
	}
	return	FALSE ;
}



#endif  // _CACHEMTX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cdescrip.h ===
//#---------------------------------------------------------------
//  File:		CDescrip.h
//        
//	Synopsis:	Header for the CDescriptor class
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//----------------------------------------------------------------

#ifndef	_CDECRIPTOR_H_
#define _CDECRIPTOR_H_

#define AVAIL_SIGNATURE 	(DWORD)'daeD' 
#define DEFAULT_SIGNATURE 	(DWORD)'Defa' 

typedef enum _DESCRIPTOR_STATE_TYPE
{
    DESCRIPTOR_FREE,
    DESCRIPTOR_INUSE,
} DESCRIPTOR_STATE_TYPE;

#include "dbgtrace.h"

class CPool;

void InitializeUniqueIDs( void );
void TerminateUniqueIDs( void );

class CDescriptor
{
	public:
		CDescriptor( DWORD dwSig );
		~CDescriptor( void );

		inline DWORD GetSignature( void );
		inline DWORD GetUniqueObjectID( void );
		inline DESCRIPTOR_STATE_TYPE GetState( void );

	private:
		//
		// Structure signature
		// 
	 	const DWORD				m_dwSignature;
		//
		// unique object identifier assigned from a static DWORD that is
		//	updated with each new object being marked, In_use.
		//
		DWORD					m_dwUniqueObjectID;
		//
		// the object state
		//
		DESCRIPTOR_STATE_TYPE	m_eState;
		//
		// pointer to a generic reference item (the membership pool)
		//
#ifdef DEBUG
		inline void IsValid( void );
#else
		void IsValid( void ) { return; }
#endif
};


//+---------------------------------------------------------------
//
//  Function:	GetSignature
//
//  Returns:	the current descriptor signature
//
//  History:	HowardCu	Created						8 May 1995
//              t-alexwe    cleaned up param checking   19 Jun 1995
//				t-alexwe	inlined						27 Jun 1995
//
//----------------------------------------------------------------
inline DWORD CDescriptor::GetSignature(void)
{
	return m_dwSignature;
}

//+---------------------------------------------------------------
//
//  Function:	GetUniqueObjectID
//
//  Returns:	the current object ID
//
//  History:	HowardCu	Created						8 May 1995
//              t-alexwe    cleaned up param checking   19 Jun 1995
//				t-alexwe	inlined						27 Jun 1995
//
//----------------------------------------------------------------
inline DWORD CDescriptor::GetUniqueObjectID(void)
{
	IsValid();
	return m_dwUniqueObjectID;
}

//+---------------------------------------------------------------
//
//  Function:	GetState
//
//  Returns:	the current descriptor state
//
//  History:	HowardCu	Created						8 May 1995
//              t-alexwe    cleaned up param checking   19 Jun 1995
//				t-alexwe	inlined						27 Jun 1995
//
//----------------------------------------------------------------
inline DESCRIPTOR_STATE_TYPE CDescriptor::GetState(void)
{
	IsValid();
	return m_eState;
}


//
// this function only exists in debug builds and does parameter
// checking on many of the member variable for the CDescriptor class.
//
#ifdef DEBUG
inline void CDescriptor::IsValid()
{
    _ASSERT( m_dwSignature != AVAIL_SIGNATURE );
    _ASSERT( m_dwUniqueObjectID != 0l );
    _ASSERT( m_eState == DESCRIPTOR_INUSE );
}
#endif

#endif //!_CDECRIPTOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cdns.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        cdns.h

   Abstract:

        This module defines the DNS connection class.

   Author:

           Rohan Phillips    ( Rohanp )    07-May-1998

   Project:


   Revision History:

--*/

# ifndef _ADNS_CLIENT_HXX_
# define _ADNS_CLIENT_HXX_

#include <dnsapi.h>

/************************************************************
 *     Include Headers
 ************************************************************/

//
//  Redefine the type to indicate that this is a call-back function
//
typedef  ATQ_COMPLETION   PFN_ATQ_COMPLETION;

/************************************************************
 *     Symbolic Constants
 ************************************************************/

//
//  Valid & Invalid Signatures for Client Connection object
//  (Ims Connection USed/FRee)
//
# define   DNS_CONNECTION_SIGNATURE_VALID    'DNSU'
# define   DNS_CONNECTION_SIGNATURE_FREE     'DNSF'

//
// POP3 requires a minimum of 10 minutes before a timeout
// (SMTP doesn't specify, but might as well follow POP3)
//
# define   MINIMUM_CONNECTION_IO_TIMEOUT        (10 * 60)   // 10 minutes
//
//

#define DNS_TCP_DEFAULT_PACKET_LENGTH   (0x4000)

enum DNSLASTIOSTATE
     {
       DNS_READIO, DNS_WRITEIO
     };

typedef struct _DNS_OVERLAPPED
{
    OVERLAPPED   Overlapped;
    DNSLASTIOSTATE    LastIoState;
}   DNS_OVERLAPPED;

/************************************************************
 *    Type Definitions
 ************************************************************/

/*++
    class CLIENT_CONNECTION

      This class is used for keeping track of individual client
       connections established with the server.

      It maintains the state of the connection being processed.
      In addition it also encapsulates data related to Asynchronous
       thread context used for processing the request.

--*/
class CAsyncDns
{
 private:


    ULONG   m_signature;            // signature on object for sanity check

    LONG    m_cPendingIoCount;

    LONG    m_cThreadCount;

    DWORD    m_cbReceived;
    
    DWORD    m_BytesToRead;

    DWORD    m_dwIpServer;

    DWORD    m_LocalPref;

    DWORD    m_Index;

    BOOL    m_fUdp;

    BOOL    m_fUsingMx;

    BOOL    m_FirstRead;

    BOOL    m_SeenLocal;

    PDNS_MESSAGE_BUFFER m_pMsgRecv;

    BYTE  *m_pMsgRecvBuf;

    PDNS_MESSAGE_BUFFER m_pMsgSend;

    BYTE *m_pMsgSendBuf;

    WORD  m_cbSendBufSize;

    SOCKADDR_IN     m_RemoteAddress;
    
    PDNS_RECORD m_ppRecord;

    PDNS_RECORD * m_ppResponseRecords;
    
    PATQ_CONTEXT    m_pAtqContext;

    SOCKET  m_DnsSocket;         // socket for this connection

    WCHAR m_wszHostName[MAX_PATH];
    DWORD    m_Weight [100];
    DWORD    m_Prefer [100];

 protected:
    DWORD         m_dwFlags;
    char          m_FQDNToDrop [MAX_PATH];
    char          m_HostName [MAX_PATH];
    DWORD         m_dwDiagnostic;
    PSMTPDNS_RECS m_AuxList;

    //
    // The overlapped structure for reads (one outstanding read at a time)
    // -- writes will dynamically allocate them
    //

    DNS_OVERLAPPED m_ReadOverlapped;
    DNS_OVERLAPPED m_WriteOverlapped;

    SOCKET QuerySocket( VOID) const
      { return ( m_DnsSocket); }


    PATQ_CONTEXT QueryAtqContext( VOID) const
      { return ( m_pAtqContext); }

    LPOVERLAPPED QueryAtqOverlapped( void ) const
    { return ( m_pAtqContext == NULL ? NULL : &m_pAtqContext->Overlapped ); }

public:

    CAsyncDns();

    virtual  ~CAsyncDns(VOID);


    DNS_STATUS DnsSendRecord();

    DNS_STATUS DnsParseMessage( IN      PDNS_MESSAGE_BUFFER    pMsg,
                                IN      WORD  wMessageLength,
                                OUT     PDNS_RECORD *   ppRecord);

    DNS_STATUS Dns_OpenTcpConnectionAndSend();

    DNS_STATUS Dns_Send( );
    DNS_STATUS SendPacket( void);

    DNS_STATUS Dns_QueryLib( DNS_NAME, WORD wQuestionType, DWORD dwFlags, char * MyFQDN, BOOL fUdp );

    SOCKET Dns_CreateSocket( IN  INT         SockType );
    

    //BOOL MakeDnsConnection(void);
    //
    //  IsValid()
    //  o  Checks the signature of the object to determine
    //
    //  Returns:   TRUE on success and FALSE if invalid.
    //
    BOOL IsValid( VOID) const
    {
        return ( m_signature == DNS_CONNECTION_SIGNATURE_VALID);
    }

    //-------------------------------------------------------------------------
    // Virtual method that MUST be defined by derived classes.
    //
    // Processes a completed IO on the connection for the client.
    //
    // -- Calls and maybe called from the Atq functions.
    //
    virtual BOOL ProcessClient(
                                IN DWORD            cbWritten,
                                IN DWORD            dwCompletionStatus,
                                IN OUT  OVERLAPPED * lpo
                              ) ;

    LONG IncPendingIoCount(void)
    {
        LONG RetVal;

        RetVal = InterlockedIncrement( &m_cPendingIoCount );

        return RetVal;
    }

    LONG DecPendingIoCount(void) { return   InterlockedDecrement( &m_cPendingIoCount );}

    LONG IncThreadCount(void)
    {
        LONG RetVal;

        RetVal = InterlockedIncrement( &m_cThreadCount );

        return RetVal;
    }

    LONG DecThreadCount(void) { return   InterlockedDecrement( &m_cThreadCount );}

    BOOL ReadFile(
            IN LPVOID pBuffer,
            IN DWORD  cbSize /* = MAX_READ_BUFF_SIZE */
            );

    BOOL WriteFile(
            IN LPVOID pBuffer,
            IN DWORD  cbSize /* = MAX_READ_BUFF_SIZE */
            );

    BOOL ProcessReadIO(IN      DWORD InputBufferLen,
                       IN      DWORD dwCompletionStatus,
                       IN OUT  OVERLAPPED * lpo);

    void DisconnectClient(void);

    void ProcessMxRecord(PDNS_RECORD pnewRR);
    void ProcessARecord(PDNS_RECORD pnewRR);

    //
    // These functions need access to data declared in CAsyncSmtpDns but are called from
    // CAsyncDns. For example some of the retry logic (when DNS servers are down for
    // example) is handled by CAsyncDns. However to kick off a retry, we need to create a
    // new DNS query and pass it all the parameters of the old DNS query, and some of the
    // parameters are in CAsyncSmtpDns. So we declare these as virtual functions to be
    // overridden by CAsyncSmtpDns.
    //

    virtual void HandleCompletedData(DNS_STATUS dwDnsStatus) = 0;
    virtual BOOL RetryAsyncDnsQuery(BOOL fUdp) = 0;

    BOOL SortMxList(void);

    BOOL CheckList(void);

    void MarkDown(DWORD dwIpServer, DWORD dwError, BOOL fUdp);

public:

    //
    //  LIST_ENTRY object for storing client connections in a list.
    //
    LIST_ENTRY  m_listEntry;

    LIST_ENTRY & QueryListEntry( VOID)
     { return ( m_listEntry); }

};

typedef CAsyncDns * PCAsyncDns;


//
// Auxiliary functions
//

INT ShutAndCloseSocket( IN SOCKET sock);

# endif

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cdoconstimsg.h ===
#ifndef __IConstructIMessageFromIMailMsg_INTERFACE_DEFINED__
#define __IConstructIMessageFromIMailMsg_INTERFACE_DEFINED__

/* interface IConstructIMessageFromIMailMsg */
/* [unique][helpstring][dual][uuid][hidden][object] */ 


EXTERN_C const IID IID_IConstructIMessageFromIMailMsg;

    MIDL_INTERFACE("CD000080-8B95-11D1-82DB-00C04FB1625D")
    IConstructIMessageFromIMailMsg : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Construct( 
            /* [in] */ CdoEventType eEventType,
            /* [in] */ IUnknown __RPC_FAR *pMailMessage) = 0;
        
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\chat.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    Chat.h

    This file contains constants & type definitions shared between the
    CHAT Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.
        KentCe      11-Dec-1995 Imported for new chat server

*/


#ifndef _CHAT_H_
#define _CHAT_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

#if !defined(MIDL_PASS)
#include <winsock.h>
#endif


//
//  Name of directory annotation file.  If this file exists
//  in the target directory of a CWD command, its contents
//  will be sent to the user as part of the CWD reply.
//

#define CHAT_ANNOTATION_FILE_A           "~CHATSVC~.CKM"
#define CHAT_ANNOTATION_FILE_W          L"~CHATSVC~.CKM"


//
//  Configuration parameters registry key.
//
# define CHAT_SERVICE_KEY_A  \
  "System\\CurrentControlSet\\Services\\" ## CHAT_SERVICE_NAME_A

# define CHAT_SERVICE_KEY_W \
  L"System\\CurrentControlSet\\Services\\" ## CHAT_SERVICE_NAME_W

#define CHAT_PARAMETERS_KEY_A   CHAT_SERVICE_KEY_A ## "\\Parameters"
  
#define CHAT_PARAMETERS_KEY_W   CHAT_SERVICE_KEY_W ## L"\\Parameters"


//
//  Performance key.
//

#define CHAT_PERFORMANCE_KEY_A  CHAT_SERVICE_KEY_A ## "\\Performance"

#define CHAT_PERFORMANCE_KEY_W  CHAT_SERVICE_KEY_W ## L"\\Performance"


//
//  If this registry key exists under the Parameters key,
//  it is used to validate CHATSVC access.  Basically, all new users
//  must have sufficient privilege to open this key before they
//  may access the CHAT Server.
//

#define CHAT_ACCESS_KEY_A                "AccessCheck"
#define CHAT_ACCESS_KEY_W               L"AccessCheck"


//
//  Configuration value names.
//

#define CHAT_ALLOW_ANONYMOUS_A           "AllowAnonymous"
#define CHAT_ALLOW_ANONYMOUS_W          L"AllowAnonymous"

#define CHAT_ALLOW_GUEST_ACCESS_A        "AllowGuestAccess"
#define CHAT_ALLOW_GUEST_ACCESS_W       L"AllowGuestAccess"

#define CHAT_ANONYMOUS_ONLY_A            "AnonymousOnly"
#define CHAT_ANONYMOUS_ONLY_W           L"AnonymousOnly"

#define CHAT_MSDOS_DIR_OUTPUT_A          "MsdosDirOutput"
#define CHAT_MSDOS_DIR_OUTPUT_W         L"MsdosDirOutput"

#define CHAT_GREETING_MESSAGE_A          "GreetingMessage"
#define CHAT_GREETING_MESSAGE_W         L"GreetingMessage"

#define CHAT_EXIT_MESSAGE_A              "ExitMessage"
#define CHAT_EXIT_MESSAGE_W             L"ExitMessage"

#define CHAT_MAX_CLIENTS_MSG_A           "MaxClientsMessage"
#define CHAT_MAX_CLIENTS_MSG_W          L"MaxClientsMessage"

#define CHAT_DEBUG_FLAGS_A               "DebugFlags"
#define CHAT_DEBUG_FLAGS_W              L"DebugFlags"

#define CHAT_ANNOTATE_DIRS_A             "AnnotateDirectories"
#define CHAT_ANNOTATE_DIRS_W            L"AnnotateDirectories"

#define CHAT_LOWERCASE_FILES_A           "LowercaseFiles"
#define CHAT_LOWERCASE_FILES_W          L"LowercaseFiles"

#define CHAT_LISTEN_BACKLOG_A            "ListenBacklog"
#define CHAT_LISTEN_BACKLOG_W           L"ListenBacklog"

#define CHAT_ENABLE_LICENSING_A          "EnableLicensing"
#define CHAT_ENABLE_LICENSING_W         L"EnableLicensing"

#define CHAT_DEFAULT_LOGON_DOMAIN_A      "DefaultLogonDomain"
#define CHAT_DEFAULT_LOGON_DOMAIN_W     L"DefaultLogonDomain"


//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon and virtual UNC roots
//

#define CHAT_ANONYMOUS_SECRET_A          "CHAT_ANONYMOUS_DATA"
#define CHAT_ANONYMOUS_SECRET_W         L"CHAT_ANONYMOUS_DATA"

#define CHAT_ROOT_SECRET_A               "CHAT_ROOT_DATA"
#define CHAT_ROOT_SECRET_W              L"CHAT_ROOT_DATA"

//
//  Handle ANSI/UNICODE sensitivity.
//

#ifdef UNICODE

#define CHAT_ANNOTATION_FILE            CHAT_ANNOTATION_FILE_W
#define CHAT_PARAMETERS_KEY             CHAT_PARAMETERS_KEY_W
#define CHAT_PERFORMANCE_KEY            CHAT_PERFORMANCE_KEY_W
#define CHAT_ACCESS_KEY                 CHAT_ACCESS_KEY_W
#define CHAT_ALLOW_ANONYMOUS            CHAT_ALLOW_ANONYMOUS_W
#define CHAT_ALLOW_GUEST_ACCESS         CHAT_ALLOW_GUEST_ACCESS_W
#define CHAT_ANONYMOUS_ONLY             CHAT_ANONYMOUS_ONLY_W
#define CHAT_MSDOS_DIR_OUTPUT           CHAT_MSDOS_DIR_OUTPUT_W
#define CHAT_GREETING_MESSAGE           CHAT_GREETING_MESSAGE_W
#define CHAT_EXIT_MESSAGE               CHAT_EXIT_MESSAGE_W
#define CHAT_MAX_CLIENTS_MSG            CHAT_MAX_CLIENTS_MSG_W
#define CHAT_DEBUG_FLAGS                CHAT_DEBUG_FLAGS_W
#define CHAT_ANNOTATE_DIRS              CHAT_ANNOTATE_DIRS_W
#define CHAT_ANONYMOUS_SECRET           CHAT_ANONYMOUS_SECRET_W
#define CHAT_LOWERCASE_FILES            CHAT_LOWERCASE_FILES_W
#define CHAT_LISTEN_BACKLOG             CHAT_LISTEN_BACKLOG_W
#define CHAT_ENABLE_LICENSING           CHAT_ENABLE_LICENSING_W
#define CHAT_DEFAULT_LOGON_DOMAIN       CHAT_DEFAULT_LOGON_DOMAIN_W

#else   // !UNICODE

#define CHAT_ANNOTATION_FILE            CHAT_ANNOTATION_FILE_A
#define CHAT_PARAMETERS_KEY             CHAT_PARAMETERS_KEY_A
#define CHAT_PERFORMANCE_KEY            CHAT_PERFORMANCE_KEY_A
#define CHAT_ACCESS_KEY                 CHAT_ACCESS_KEY_A
#define CHAT_ANONYMOUS_ONLY             CHAT_ANONYMOUS_ONLY_A
#define CHAT_ALLOW_ANONYMOUS            CHAT_ALLOW_ANONYMOUS_A
#define CHAT_ALLOW_GUEST_ACCESS         CHAT_ALLOW_GUEST_ACCESS_A
#define CHAT_MSDOS_DIR_OUTPUT           CHAT_MSDOS_DIR_OUTPUT_A
#define CHAT_GREETING_MESSAGE           CHAT_GREETING_MESSAGE_A
#define CHAT_EXIT_MESSAGE               CHAT_EXIT_MESSAGE_A
#define CHAT_MAX_CLIENTS_MSG            CHAT_MAX_CLIENTS_MSG_A
#define CHAT_DEBUG_FLAGS                CHAT_DEBUG_FLAGS_A
#define CHAT_ANNOTATE_DIRS              CHAT_ANNOTATE_DIRS_A
#define CHAT_ANONYMOUS_SECRET           CHAT_ANONYMOUS_SECRET_A
#define CHAT_LOWERCASE_FILES            CHAT_LOWERCASE_FILES_A
#define CHAT_LISTEN_BACKLOG             CHAT_LISTEN_BACKLOG_A
#define CHAT_ENABLE_LICENSING           CHAT_ENABLE_LICENSING_A
#define CHAT_DEFAULT_LOGON_DOMAIN       CHAT_DEFAULT_LOGON_DOMAIN_A

  
#endif  // UNICODE



//
// Structures for APIs
//

typedef struct _CHAT_USER_INFO
{
    DWORD    idUser;          //  User id
    LPWSTR   pszUser;         //  User name
    BOOL     fAnonymous;      //  TRUE if the user is logged on as
                              //  Anonymous, FALSE otherwise
    DWORD    inetHost;        //  Host Address
    DWORD    tConnect;        //  User Connection Time (elapsed seconds)

} CHAT_USER_INFO, * LPCHAT_USER_INFO;

typedef struct _CHAT_STATISTICS_0
{
    LARGE_INTEGER TotalBytesSent;
    LARGE_INTEGER TotalBytesReceived;
    DWORD         TotalFilesSent;
    DWORD         TotalFilesReceived;
    DWORD         CurrentAnonymousUsers;
    DWORD         CurrentNonAnonymousUsers;
    DWORD         TotalAnonymousUsers;
    DWORD         TotalNonAnonymousUsers;
    DWORD         MaxAnonymousUsers;
    DWORD         MaxNonAnonymousUsers;
    DWORD         CurrentConnections;
    DWORD         MaxConnections;
    DWORD         ConnectionAttempts;
    DWORD         LogonAttempts;
    DWORD         TimeOfLastClear;

} CHAT_STATISTICS_0, * LPCHAT_STATISTICS_0;


//
// API Prototypes
//

NET_API_STATUS
I_ChatEnumerateUsers(
    IN LPWSTR   pszServer OPTIONAL,
    OUT LPDWORD  lpdwEntriesRead,
    OUT LPCHAT_USER_INFO * Buffer
    );

NET_API_STATUS
I_ChatDisconnectUser(
    IN LPWSTR  pszServer OPTIONAL,
    IN DWORD   idUser
    );

NET_API_STATUS
I_ChatQueryVolumeSecurity(
    IN LPWSTR  pszServer OPTIONAL,
    OUT LPDWORD lpdwReadAccess,
    OUT LPDWORD lpdwWriteAccess
    );

NET_API_STATUS
I_ChatSetVolumeSecurity(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  dwReadAccess,
    IN DWORD  dwWriteAccess
    );

NET_API_STATUS
I_ChatQueryStatistics(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    );

NET_API_STATUS
I_ChatClearStatistics(
    IN LPWSTR pszServer OPTIONAL
    );

#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _CHAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cliproto.h ===
//#---------------------------------------------------------------
//  File:       cliproto.h
//        
//  Synopsis:   header for shuttle client protocol
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    t-alexwe
//----------------------------------------------------------------

#ifndef _CLIPROTO_H_
#define _CLIPROTO_H_

#include <windows.h>
#define SECURITY_WIN32

#define PROXY_PROTOCOL_VERSION MAKEWORD(1, 0)

#define MAXPACKETDATASIZE 960
#define MAXMSGSPERPACKET 4

//
// make sure everything is byte aligned
//
#pragma pack(1)

//
// the message structure
//
typedef struct {
	WORD			wCommand;			// the command requested
	WORD			cData;				// the amount of data
	WORD			cOffset;			// the offset of the data into the
										// the packets pData
} PROXYMESSAGE, *PPROXYMESSAGE;

//
// client connection protocol packet structure
//
// each packet contains 1 to 4 messages.  
//
typedef struct {
	WORD			cLength;			// the length of this packet
	WORD			cMessages;			// the message count in this packet
	//
	// information for each message
	//
	PROXYMESSAGE	pMessages[MAXMSGSPERPACKET];		
	//
	// the packets data
	//
	BYTE			pData[MAXPACKETDATASIZE];
} PROXYPACKET, *PPROXYPACKET;

#define PACKETHDRSIZE (sizeof(PROXYPACKET) - MAXPACKETDATASIZE)

//
// message types (wCommand in PROXYMESSAGE)
//
// format:
// | 16 | 15       -          0 |
//
// bit 16 - if 0 then message is handled by Shuttle server, if 1 then
// message is handled by client.
//
// generally these are laid out in the order that they are expected to be
// received in.  a command of type wCommand should return a message of type
// wCommand | 0x8000.
//
// Only exception is that PROXY_NEGOTIATE can return a PROXY_CHALLENGE or
// a PROXY_ACCEPT message.
//
#define PROXY_VERSION 				0x0000
#define PROXY_VERSION_RETURN 		0x8000
#define PROXY_NEGOTIATE 			0x0001
#define PROXY_CHALLENGE 			0x8001
#define PROXY_ACCEPT 				0x8002
#define PROXY_GETHOSTBYNAME			0x0003
#define PROXY_GETHOSTBYNAME_RETURN	0x8003
#define PROXY_CONNECT				0x0004
#define PROXY_CONNECT_RETURN		0x8004
#define PROXY_SETSOCKOPT			0x0005
#define PROXY_SETSOCKOPT_RETURN		0x8005
#define PROXY_DOGATEWAY				0x0006
#define PROXY_DOGATEWAY_RETURN		0x8006
#define MAX_PROXY_SRV_COMMAND		PROXY_DOGATEWAY

#define PROXY_NOMESSAGE				0xffff

//
// include the error codes from the client connection API
//
#include <clicnct.h>

//
// message data formats
//
// packet data sizes need to be < MAXDATASIZE bytes, so the total size
// of a group of messages going in one packet should be < MAXDATASIZE bytes.
//
// error codes are NT/WinSock or PROXYERR error codes
//
#define MAXCOMPUTERNAME MAX_COMPUTERNAME_LENGTH + 1
typedef struct {
	WORD				wRequestedVersion;	// requested ver of the protocol
	DWORD				cComputerName;		// length of the computer name
	CHAR				pszComputerName[MAXCOMPUTERNAME];	// cli's comp name
} PROXY_VERSION_DATA, *PPROXY_VERSION_DATA;

typedef struct {
	DWORD				dwError;			// error code
	WORD				wVersion;			// version of protocol used
	WORD				wHighVersion;		// highest version supported
} PROXY_VERSION_RETURN_DATA, *PPROXY_VERSION_RETURN_DATA;

#define SECBUFSIZE 768

typedef struct {
	WORD				cNegotiateBuffer;
	BYTE				pNegotiateBuffer[SECBUFSIZE];
} PROXY_NEGOTIATE_DATA, *PPROXY_NEGOTIATE_DATA;

typedef struct {
	WORD				cChallengeBuffer;
	BYTE				pChallengeBuffer[SECBUFSIZE];
} PROXY_CHALLENGE_DATA, *PPROXY_CHALLENGE_DATA;

typedef struct {
	DWORD				dwError;			// error code
} PROXY_ACCEPT_DATA, *PPROXY_ACCEPT_DATA;

#define MAXHOSTNAMELEN 512
#define MAXADDRLISTSIZE 128

typedef struct {
	WORD				cHostname;						// length of hostname
	char				pszHostname[MAXHOSTNAMELEN];	// hostname
} PROXY_GETHOSTBYNAME_DATA, *PPROXY_GETHOSTBYNAME_DATA;

typedef struct {
	DWORD				dwError;			// error code
	WORD				cAddr;				// number of addresses
	WORD				h_addrtype;			// should always be AF_INET
	WORD				h_length;			// the length of each addr
											// should always be 4
	//
	// the addresses.  this has cAddr addresses in it.  each address is of
	// length h_length and the first one starts at h_addr_list[0].
	//
	BYTE				h_addr_list[MAXADDRLISTSIZE];
} PROXY_GETHOSTBYNAME_RETURN_DATA, *PPROXY_GETHOSTBYNAME_RETURN_DATA;

typedef struct {
	WORD				cAddr;				// the length of the address (16)
	struct sockaddr		addr;				// the address
} PROXY_CONNECT_DATA, *PPROXY_CONNECT_DATA;

typedef struct {
	DWORD				dwError;			// error code
} PROXY_CONNECT_RETURN_DATA, *PPROXY_CONNECT_RETURN_DATA;

#define MAXSOCKOPTS 32						// maximum sockopts per packet
#define MAXOPTVAL 16						// maximum length of optval

typedef struct {
	WORD				level;				// option level
	WORD				optname;			// option name
	BYTE				optval[MAXOPTVAL];	// option value
	WORD				optlen;				// option length (<= MAXOPTVAL)
} NETSOCKOPT, *PNETSOCKOPT;

typedef struct {
	DWORD				cSockopt;				// number of socket options
	NETSOCKOPT			sockopts[MAXSOCKOPTS];	// the socket options
} PROXY_SETSOCKOPT_DATA, *PPROXY_SETSOCKOPT_DATA;

typedef struct {
	DWORD				dwError;			// error code
} PROXY_SETSOCKOPT_RETURN_DATA, *PPROXY_SETSOCKOPT_RETURN_DATA;

typedef struct {
	BYTE				reserved;			// we need some data...
} PROXY_DOGATEWAY_DATA, *PPROXY_DOGATEWAY_DATA;

typedef struct {
	DWORD				dwError;			// error code
} PROXY_DOGATEWAY_RETURN_DATA, *PPROXY_DOGATEWAY_RETURN_DATA;

#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cobjid.h ===
//#---------------------------------------------------------------
//  File:       CObjID.h
//        
//  Synopsis:   Header for the CObjectID
//
//    Copyright (C) 1995 Microsoft Corporation
//    All rights reserved.
//
//  Authors:    HowardCu
//----------------------------------------------------------------

#ifndef _COBJECTID_H_
#define _COBJECTID_H_

#define INITIALOBJECTID     0x12345678
#define OBJECTIDINCREMENT   1

class CObjectID
{
    public:
        CObjectID( void );
        ~CObjectID( void );
        DWORD GetUniqueID( void );
    private:
        //
        // object ID holder
        // 
        DWORD                   m_dwObjectID;
        //
        // critical section to generate unique ID
        // 
        CRITICAL_SECTION        m_ObjIDCritSect;
};

#endif //!_COBJECTID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\clicnct.h ===
//
// clicnct.h - the Rome/Shuttle Client Connection API
//
// initial version - July 1995 - t-alexwe
//
// This file lives in both the Shuttle and MOS SLM trees.  In shuttle it
// belongs in \mos\h\clicnct.h.  In MOS it belongs in \mos\include\mos.
//
#ifndef _CLICNCT_H_
#define _CLICNCT_H_
#include <windows.h>

//
// this has the event codes in it
//
#include "moscl.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DllExport
#define DllExport __declspec(dllexport)
#endif // DllExport

//
// Client Connection API error codes
//
// win32 error code - customer bit set, error bits set, facility 0x300
//
#define PROXYERR_BASE 				0xE3000000
#define PROXYERR_INVALID_STATE 		(PROXYERR_BASE+0)
#define PROXYERR_UNSUPPORTED_VER	(PROXYERR_BASE+1)
#define PROXYERR_INVALID_PACKET		(PROXYERR_BASE+2)
#define PROXYERR_HOSTNAME_TOO_LONG	(PROXYERR_BASE+3)
#define PROXYERR_TOO_MANY_SOCKOPTS	(PROXYERR_BASE+4)
#define PROXYERR_AUTH_ERROR			(PROXYERR_BASE+5)

//
// this is the callback function that will be called with event progress.
// it uses the events above
//
// possible events:
//
typedef void (WINAPI *EVENT_CALLBACK)(DWORD obj, DWORD event, DWORD errcode);
typedef void (WINAPI *ERRORLOG_CALLBACK)(DWORD obj, PSTR psz, DWORD dw);

//
// structure for passing socket options in ProxyConnectOpen().  Each element
// has the same purpose as the similarily named parameter in setsockopt().
//
typedef struct {
	int 			level;
	int				optname;
	const char FAR 	*optval;
	int				optlen;
} *PSOCKOPT, SOCKOPT;


// Init and Deinit functions because launching and killing threads in DLLMain
// causes major grief
DllExport void WINAPI ProxyDllStartup(void);
DllExport void WINAPI ProxyDllShutdown(void);

typedef void (WINAPI *LPFNPROXYDLLSTARTUP)(void);
typedef void (WINAPI *LPFNPROXYDLLSHUTDOWN)(void);

//
// Synopsis
// 	API takes a DialParams string in the form below
// 	dials up primary/backup phone number as configured in registry
//
// Parameters:
//  pszDialParams	- <P|B>:<username>:<password>
//	phEventHandle 	- returned: an event handle that is signalled when
//					  the dialing is complete (or an error has occured).
//	lpfnEventCb		- fn ptr to post events & errors
//	lpfnErrorCb		- fn ptr to log (for stats/debugging) errors 
//  dwLogParam		- magic cookie passed into lpfnEventCb, lpfnErrorCb
//	pdwDialId	    - returned: a dialing ID that can be used by
//					  ProxyDialClose() and ProxyDialGetResult().
//
// Returns: 
//	Success			- ERROR_SUCCESS (0)
//	Failure			- NT or WinSock error code
//
DllExport DWORD WINAPI ProxyDialOpen(PSTR 	  lpszDialParams,	// [in]
							EVENT_CALLBACK	  lpfnEventCb,		// [in]
							ERRORLOG_CALLBACK lpfnErrLogCb,		// [in]
							DWORD			  dwLogParam,		// [in]
							PHANDLE			  phEventHandle,	// [out]
							PDWORD			  pdwDialId );		// [out]

typedef DWORD (WINAPI *LPFNPROXYDIALOPEN)(PSTR, EVENT_CALLBACK, ERRORLOG_CALLBACK, DWORD, PHANDLE, PDWORD);

//
// Synopsis:
//	Closes a dial connection started by ProxyDialOpen().  
//	Cancels dial if still in progress.
//
// Parameters:
//	dwConnectId		- the dial ID returned by ProxyDialOpen()
//
// Returns:
//	Success			- ERROR_SUCCESS(0)
//	Failure			- NT or WinSock error code
//
// Notes:
// 	This should always succeed unless passed in invalid parameters.
//
DllExport DWORD WINAPI ProxyDialClose(DWORD	dwConnectId);	// [in]

typedef DWORD (WINAPI *LPFNPROXYDIALCLOSE)(DWORD);

//
// Synopsis:
//	Gets dial completion status a dial started by ProxyDialOpen().
//
// Parameters:
//	dwConnectId		- the dial ID returned by ProxyDialOpen()
//
// Returns:
//	Success			- ERROR_SUCCESS(0)
//	Failure			- NT or WinSock error code
// 	
DllExport DWORD WINAPI ProxyDialGetResult(DWORD dwConnectId);	// [in]

typedef DWORD (WINAPI *LPFNPROXYDIALGETRESULT)(DWORD);

//
// Synopsis:
//	Gets dial error-log string in specific format
//  applicable only to TCPCONN.DLL. Other proxy DLLs
//  should _not_ implement this entry point!!
//
// Parameters:
//	dwConnectId		- the dial ID returned by ProxyDialOpen()
//  pszErrStr		- buffer to write result into
//	dwLen			- length of buffer
//
// Returns:
//	Success			- ERROR_SUCCESS(0)
//	Failure			- NT or WinSock error code
// 	
DllExport DWORD WINAPI ProxyDialGetErrorLogString(DWORD dwConnectId, PSTR pszStr, DWORD dwLen);	// [in]

typedef DWORD (WINAPI *LPFNPROXYDIALGETERRORLOGSTRING)(DWORD, PSTR, DWORD);

//=====================================================

//
// Synopsis
// 	API takes a hostname for MSN and socket options for the socket to
// 	be created and returns immediatly with an event handle and a 
// 	connection ID.  The calling process should wait on the event
// 	handle for completion.  The connection ID is used for CancelConnect()
// 	and ProxyConnectGetResult().
//
// Parameters:
//	pszDNSName0		- the PRIMARY hostname to connect to
//	pszDNSName1		- the BACKUP hostname to connect to
//	wPort			- the TCP/IP port to connect to
//	pSockopts		- the socket options to use on the socket
//	cSockopts 		- the number of socket options in pSockopts
//	lpfnEventCb		- fn ptr to post events & errors
//	lpfnErrorCb		- fn ptr to log (for stats/debugging) errors 
//  dwLogParam		- magic cookie passed into lpfnEventCb, lpfnErrorCb
//	phEventHandle 	- returned: an event handle that is signalled when
//					  the connection is complete (or an error has occured).
//	pdwConnectId	- returned: a connection ID that can be used by
//					  ProxyConnectClose() and ProxyConnectGetResult().
//
// Returns: 
//	Success			- ERROR_SUCCESS (0)
//	Failure			- NT or WinSock error code
//
DllExport DWORD WINAPI ProxyConnectOpen(PSTR	pszDNSName0,	// [in]
							 PSTR				pszDNSName1,	// [in]
							 WORD				wPort,			// [in]
							 PSOCKOPT			pSockopts,		// [in]
							 DWORD				cSockopts,		// [in]
							 EVENT_CALLBACK		lpfnEventCb,	// [in]
							 ERRORLOG_CALLBACK	lpfnErrLogCb,	// [in]
							 DWORD				dwLogParam,		// [in]
							 PHANDLE			phEventHandle,	// [out]
							 PDWORD				pdwConnectId );	// [out]

typedef DWORD (WINAPI *LPFNPROXYCONNECTOPEN)(PSTR, PSTR, WORD, PSOCKOPT, DWORD, EVENT_CALLBACK, ERRORLOG_CALLBACK, DWORD, PHANDLE, PDWORD);

//
// Synopsis:
//	Closes a connection opened by ProxyConnectOpen().  
//	Cancels a connection attempt if in progress.
//
// Parameters:
//	dwConnectId		- the connection ID returned by ProxyConnectOpen()
//
// Returns:
//	Success			- ERROR_SUCCESS(0)
//	Failure			- NT or WinSock error code
//
// Notes:
// 	This should always succeed unless passed in invalid parameters.
//
DllExport DWORD WINAPI ProxyConnectClose(DWORD	dwConnectId	);		// [in]

typedef DWORD (WINAPI *LPFNPROXYCONNECTCLOSE)(DWORD);

//
// Synopsis:
//	Gets a connected socket handle from a connection started by
//	ProxyConnectOpen().
//
// Parameters:
//	hEventHandle	- the event handle returned by ProxyConnectOpen()
//	dwConnectId		- the connection ID returned by ProxyConnectOpen()
//	phSocket		- returned: the socket handle
//
// Returns:
//	Success			- ERROR_SUCCESS(0)
//	Failure			- NT or WinSock error code
// 	
DllExport DWORD WINAPI ProxyConnectGetResult(DWORD		dwConnectId, // [in]
								  			 PHANDLE	phSocket );	 // [out]

typedef DWORD (WINAPI *LPFNPROXYCONNECTGETRESULT)(DWORD, PHANDLE);

//
// Synopsis:
//	Gets the set of local IP addres in a string in specific format
//  applicable only to TCPCONN.DLL. Other proxy DLLs
//  should _not_ implement this entry point!!
//
// Parameters:
//	dwConnectId		- the dial ID returned by ProxyConnectOpen()
//
// Returns:
//	Success			- string ptr (LocalAlloc'd string)
//	Failure			- NULL
// 	
DllExport PSTR WINAPI ProxyConnectGetMyIPAddrs(DWORD dwConnectId);	// [in]

typedef PSTR (WINAPI *LPFNPROXYCONNECTGETMYIPADDRS)(DWORD);

typedef struct 
{
	HINSTANCE					hinst;
	LPFNPROXYDLLSTARTUP			lpfnProxyDllStartup;
	LPFNPROXYDLLSHUTDOWN		lpfnProxyDllShutdown;
	LPFNPROXYDIALOPEN			lpfnProxyDialOpen;
	LPFNPROXYDIALCLOSE			lpfnProxyDialClose;
	LPFNPROXYDIALGETRESULT		lpfnProxyDialGetResult;
	LPFNPROXYCONNECTOPEN		lpfnProxyConnectOpen;
	LPFNPROXYCONNECTCLOSE		lpfnProxyConnectClose;
	LPFNPROXYCONNECTGETRESULT	lpfnProxyConnectGetResult;
	LPFNPROXYCONNECTGETMYIPADDRS   lpfnProxyConnectGetMyIPAddrs;
	LPFNPROXYDIALGETERRORLOGSTRING lpfnProxyDialGetErrorLogString;
}
PROXYDLLPTRS, *PPROXYDLLPTRS;

#define SZPROXYDLLSTARTUP		"ProxyDllStartup"
#define SZPROXYDLLSHUTDOWN		"ProxyDllShutdown"
#define SZPROXYDIALOPEN			"ProxyDialOpen"
#define SZPROXYDIALCLOSE		"ProxyDialClose"
#define SZPROXYDIALGETRESULT	"ProxyDialGetResult"
#define SZPROXYCONNECTOPEN		"ProxyConnectOpen"
#define SZPROXYCONNECTCLOSE		"ProxyConnectClose"
#define SZPROXYCONNECTGETRESULT	"ProxyConnectGetResult"
#define SZPROXYCONNECTGETMYIPADDRS   "ProxyConnectGetMyIPAddrs"
#define SZPROXYDIALGETERRORLOGSTRING "ProxyDialGetErrorLogString"

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\crchash.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    crchash.h

Abstract:
	CRC Hash function
*/

#ifndef __CRCHASH_H
#define __CRCHASH_H

#define POLY 0x48000000L    /* 31-bit polynomial (avoids sign problems) */

extern long CrcTable[128];
void crcinit();

DWORD CRCHash(IN const BYTE * Key, IN DWORD KeyLength);

DWORD CRCHashNoCase(IN const BYTE * Key, IN DWORD KeyLength);

DWORD CRCHashWithPrecompute(IN DWORD	PreComputedHash,	IN const BYTE * Key, IN DWORD KeyLength);

DWORD
CRCChainingHash(	DWORD	sum,
					const	BYTE*	(&Key), 
					BYTE	bTerm
					) ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\codepageconvert.h ===
//+------------------------------------------------------------
//
// Copyright (C) 2000, Microsoft Corporation
//
// File: CodePageConvert.h
//
// Functions:
//   HrCodePageConvert
//   HrCodePageConvert
//   HrCodePageConvertFree
//   HrCodePageConvertInternal
//
// History:
// aszafer  2000/03/29  created
//-------------------------------------------------------------

#ifndef _CODEPAGECONVERT_H_
#define _CODEPAGECONVERT_H_

#include "windows.h"

#define TEMPBUFFER_WCHARS 316

HRESULT HrCodePageConvert (
    IN UINT uiSourceCodePage,           // Source code page
    IN LPSTR pszSourceString,           // Source String 
    IN UINT uiTargetCodePage,           // Target code page
    OUT LPSTR pszTargetString,          // p to prealloc buffer where target string is returned
    IN int cbTargetStringBuffer);      // cbytes in prealloc buffer for target string

HRESULT HrCodePageConvert (
    IN UINT uiSourceCodePage,           // Source code page
    IN LPSTR pszSourceString,           // Source string
    IN UINT uiTargetCodePage,           // Target code page
    OUT LPSTR * ppszTargetString);      // p to where target string is returned

VOID HrCodePageConvertFree (LPSTR pszTargetString); //p to memory allocated by HrCodePageConvert   

HRESULT HrCodePageConvertInternal (
    IN UINT uiSourceCodePage,               // source code page
    IN LPSTR pszSourceString,               // source string
    IN UINT uiTargetCodePage,               // target code page
    OUT LPSTR pszTargetString,              // target string or NULL
    IN int cbTargetStringBuffer,           // cb in target string or 0 
    OUT LPSTR* ppszTargetString );          // NULL or p to where target string is returned

 


#endif //_CODEPAGECONVERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cpsock.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    cpsock.h

    This module contains the communication package prototypes and
    the implementation for TCP sockets.

    FILE HISTORY:
        Johnl       08-Aug-1994 Created.

*/

#ifndef _CPSOCK_H_
#define _CPSOCK_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  This is the function callback that is called when the connect thread has
//  accepted a new connection
//

typedef
VOID
(*PFN_ON_CONNECT)(
    SOCKET        sNew,
    SOCKADDR_IN * psockaddr
    );

//
//  Contains Connection Package socket information
//

typedef struct _CP_INFO
{
    //
    //  Function to be called when a new connection comes in
    //

    PFN_ON_CONNECT   pfnOnConnect;

    //
    //  Addressing information
    //

    SOCKADDR_IN      sockaddr;

    //
    //  Thread handle of connect thread.  Used to synchronize shutdown
    //

    HANDLE           hConnectThread;

    //
    //  Critical section that should be taken when modifying any of the
    //  following members
    //

    CRITICAL_SECTION InfoCriticalSection;

    //
    //  Tells connect thread to terminate itself
    //

    BOOL             fShutDown;

    //
    //  Socket the connect thread listens on for incoming connections
    //

    SOCKET           ListenSocket;

} CP_INFO, *PCP_INFO;


////////////////////////////////////////////////////////////////////////////
//
//  Communication Package function pointers
//
////////////////////////////////////////////////////////////////////////////

typedef
BOOL
(*PFN_CPINITIALIZE)(
    PCP_INFO       * ppInfo,
    PFN_ON_CONNECT   pfnOnConnect,
    BYTE           * LocalAddress,
    u_short          port,
    DWORD            reserved
    );

typedef
INT
(*PFN_CPCREATELISTENSOCKET)(
    PCP_INFO pcpInfo
    );

typedef
BOOL
(*PFN_CPSTARTCONNECTTHREAD)(
    PCP_INFO pcpInfo
    );

typedef
BOOL
(*PFN_CPSTOPCONNECTTHREAD)(
    PCP_INFO pcpInfo
    );

//
//  Forcefully closes a socket
//

INT ResetSocket( SOCKET s );

//
//  Serialization for access to the CP_INFO data (used primarily during
//  shutdown)
//

#define LockCPInfo(pcpInfo)    EnterCriticalSection( &(pcpInfo)->InfoCriticalSection )
#define UnlockCPInfo(pcpInfo)  LeaveCriticalSection( &(pcpInfo)->InfoCriticalSection )



//
//  For now, we'll only support TCP sockets
//

#define CPInitialize           TcpInitialize
#define CPCreateListenSocket   TcpCreateListenSocket
#define CPStartConnectThread   TcpStartConnectThread
#define CPStopConnectThread    TcpStopConnectThread

////////////////////////////////////////////////////////////////////////////
//
//  TCP Sockets Communication Package prototypes
//
////////////////////////////////////////////////////////////////////////////

dllexp
BOOL TcpInitialize( PCP_INFO       * ppInfo,
                    PFN_ON_CONNECT   pfnOnConnect,
                    BYTE           * LocalAddress,
                    u_short          port,
                    DWORD            reserved );

dllexp INT     TcpCreateListenSocket( PCP_INFO pcpInfo );
dllexp BOOL    TcpStartConnectThread( PCP_INFO pcpInfo );
dllexp BOOL    TcpStopConnectThread( PCP_INFO pcpInfo );

#ifdef __cplusplus
}
#endif

#endif //!_CPSOCK_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\crsclsid.h ===
#ifndef __CRSCLSID_H__
#define __CRSCLSID_H__

//
// CLSID's for the CRS COM Objects
//

// {B5237E80-17FF-11d0-9B95-00C04FD5CD09}
DEFINE_GUID(CLSID_ReplicationServer, 
0xb5237e80, 0x17ff, 0x11d0, 0x9b, 0x95, 0x0, 0xc0, 0x4f, 0xd5, 0xcd, 0x9);

// {B5237E81-17FF-11d0-9B95-00C04FD5CD09}
DEFINE_GUID(CLSID_ReplicationProject, 
0xb5237e81, 0x17ff, 0x11d0, 0x9b, 0x95, 0x0, 0xc0, 0x4f, 0xd5, 0xcd, 0x9);

// {B5237E82-17FF-11d0-9B95-00C04FD5CD09}
DEFINE_GUID(CLSID_ReplicationInstance, 
0xb5237e82, 0x17ff, 0x11d0, 0x9b, 0x95, 0x0, 0xc0, 0x4f, 0xd5, 0xcd, 0x9);

// {EAC92DC0-2166-11d0-9B97-00C04FD5CD09}
DEFINE_GUID(CLSID_ReplicationRoute,
0xeac92dc0, 0x2166, 0x11d0, 0x9b, 0x97, 0x0, 0xc0, 0x4f, 0xd5, 0xcd, 0x9);


// {E26EA570-1737-11d0-9B95-00C04FD5CD09}
DEFINE_GUID(IID_IReplicationServer, 
0x66D6D7E9,0x22D2,0x11D0,0x9B,0x98,0x00,0xC0,0x4F,0xD5,0xCD,0x09);

// {E26EA571-1737-11d0-9B95-00C04FD5CD09}
DEFINE_GUID(IID_IReplicationProject, 
0x66D6D7EE,0x22D2,0x11D0,0x9B,0x98,0x00,0xC0,0x4F,0xD5,0xCD,0x09);

// {E26EA572-1737-11d0-9B95-00C04FD5CD09}
DEFINE_GUID(IID_IReplicationInstance, 
0x66D6D7F3,0x22D2,0x11D0,0x9B,0x98,0x00,0xC0,0x4F,0xD5,0xCD,0x09);

// {EAC92DC1-2166-11d0-9B97-00C04FD5CD09}
DEFINE_GUID(IID_IReplicationRoute,
0x66D6D7F8,0x22D2,0x11D0,0x9B,0x98,0x00,0xC0,0x4F,0xD5,0xCD,0x09);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\crsapi.h ===
// 
//
// Copyright (c) 1995-1996  Microsoft Corporation
//
// Module Name:
//
//    crsapi.h
//
// Abstract:
//
//    This module defines the common structures and prototypes for the   
//    Content Replication Service API.
//
// Revision History:
//

#ifndef CRSAPI_INCLUDED
#define CRSAPI_INCLUDED


#if defined(STATIC_REX)
#define CRSAPI
#elif defined(IN_CRSDLL)
#define CRSAPI	__declspec( dllexport ) _stdcall
#else
#define CRSAPI	__declspec( dllimport) _stdcall
#endif //IN_DLL


#define MAX_PROJECT 100
#define MAX_LOCATION 300
#define MAX_DESTINATION_BUFFER 0x1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>

#define NOREF(x) x=x

// @DOC 

#define RF_NO_DELETE			1		
#define RF_REPLICATE_ACLS		(1 << 1)	
#define RF_NO_DATA				(1 << 2)	
#define RF_FORCE_REPL			(1 << 3)	
#define RF_PERMIT_TREE			(1 << 4)
#define RF_IN_PROC				(1 << 5)	
#define RF_INCREMENTAL			(1 << 6)	
#define RF_FASTMODE				(1 << 7)
#define RF_ON_DIR_CHANGE		(1 << 8)
#define RF_AUTO_ROUTE			(1 << 9)
#define RF_ON_NOTIFY			(1 << 10)
#define RF_NO_CHAIN				(1 << 11)

// added by nathanf 10/3/96 for Raid 6904 - exclude all subdirs is missing
#define RF_EXCLUDE_ALL			(1 << 12)


#define RF_DELETE				(1 << 16)
#define RF_NO_REPLICATE_ACLS    (1 << 17)
#define RF_DATA					(1 << 18)	
#define RF_NO_FORCE_REPL		(1 << 19)	
#define RF_NO_PERMIT_TREE		(1 << 20)
#define RF_NO_IN_PROC			(1 << 21)
#define RF_NO_INCREMENTAL		(1 << 22)	
#define RF_NO_FASTMODE			(1 << 23)
#define RF_NO_ON_DIR_CHANGE		(1 << 24)
#define RF_NO_AUTO_ROUTE		(1 << 25)
#define RF_NO_ON_NOTIFY         (1 << 26)
#define RF_CHAIN				(1 << 27)


#define REPL_STATE_EMPTY	 0  
#define REPL_STATE_STARTING  1
#define REPL_STATE_RUNNING   2
#define REPL_STATE_COMPLETE  3
#define REPL_STATE_ABORTED   4
#define REPL_STATE_CANCLED	 5
#define REPL_STATE_RECEIVING 6

#define PARM_VALUE_ENCRYPTED 1


#define CP_PROPOGATE_ALL		 1


#define	 MAX_PARM_STRING	300


typedef void *REPLICATION_INSTANCE; // @type REPLICATION_INSTANCE | Identifier of a particular replication instance. Needed to call any function which manipulates or queries and existing replication


#ifndef UNICODE_ONLY
// @struct SELECTION_ENTRY_A |  Defines a single entry member of a fileset for a given replication request
typedef struct _SELECTION_ENTRY_A
{
	CHAR  cPath[MAX_PATH];	//@field The path specification 
	DWORD dwFlags;			//@field Flags which indicate handle the entry should be handled.
} SELECTION_ENTRY_A; 
#endif

#ifndef ANSI_ONLY
// @struct SELECTION_ENTRY_A |  Defines a single entry member of a fileset for a given replication request
typedef struct _SELECTION_ENTRY_W
{
	WCHAR cPath[MAX_PATH];	//@field The path specification 
	DWORD dwFlags;			//@field Flags which indicate handle the entry should be handled.
} SELECTION_ENTRY_W; 
#endif

#ifdef UNICODE
#define SELECTION_ENTRY SELECTION_ENTRY_W
#else
#define SELECTION_ENTRY SELECTION_ENTRY_A
#endif



// @struct SELECTION_LIST | Defines a complete fileset for a replication.
typedef struct _SELECTION_LIST
{
	int nEntries;				//@field The number of selection entries in the list.
	SELECTION_ENTRY sList[1];	//@field An Array of selection entries.
} SELECTION_LIST;


// @struct REPLICATION_COUNTERS | Counters used to record replication information. Returned by QueryReplication.
typedef struct _REPLICATION_COUNTERS
{
	DWORD dwStartStamp;		      //@field Start Time
	DWORD dwFilesSent; 		      //@field The Total files that have been sent across this connection.
	DWORD dwFilesReceived;	      //@field The total files that have been received across this connection.
	DWORD dwFilesMatched;         //@field The number of files that matched and did not need to be sent
	DWORD dwFilesErrored;         //@field The number of files which had errors
	DWORD dwBytesSent;            //@field The total bytes sent across this connection.
	DWORD dwBytesReceived;        //@field The total bytes received across this connection.
	DWORD dwBytesMatched;         //@field The total bytes which matched and did not need to be sent.
	DWORD dwBytesErrored;         //@field The total bytes errored

	DWORD dwDirectoriesProcessed; //@field The number of directories processed

} REPLICATION_COUNTERS;


#ifndef UNICODE_ONLY
//@struct REPLICATION_INFO_A | Contains information about a particular replication instance. 
// Is returned by <f QueryReplication> and <f EnumReplications>.
typedef struct _REPLICATION_INFO_A
{
	REPLICATION_INSTANCE hInstance; //@field The instance id for this replication.
	CHAR cProject[MAX_PROJECT];     //@field The project associated with this replication.
	DWORD dwState;                  //@field The Current State of this replication
	// @flag REPL_STATE_EMPTY	  | This Replication Info structure is empty.
	// @flag REPL_STATE_STARTING  | The replication is a startup state.
	// @flag REPL_STATE_RUNNING   | The replication is currently running.
	// @flag REPL_STATE_COMPLETE  | The replication is complete.
	// @flag REPL_STATE_ABORTED   | The replication aborted due to an error.
	// @flag REPL_STATE_CANCLED	  | The replication was canceled.
	// @flag REPL_STATE_RECEIVING | The replication is receiving data.
	DWORD dwError;	                // @field An error code if the replication aborted
	DWORD dwFlags;		            //@field Flags this replication was started with.
// @flag RF_NO_DELETE         | Turns of Delete Processing
// @flag RF_REPLICATE_ACLS    | Replicates ACL's
// @flag RF_NO_DATA           | Skips Replicating Data, will only replicate directories.
// @flag RF_FORCE_REPL        | Forces data to be replicated without checking first
// @flag RF_IN_PROC	          | Causes the StartReplication API to run in process (note: This blocks!)
// @flag RF_INCREMENTAL       | Runs replication in "Incremental" mode, meaning that only files which have been locally detected to have been modified since the last replication are checked and sent.
// @flag RF_FASTMODE          | Uses Unframed Protocol for enhanced performance over faster/secure links.
// @flag RF_ON_DIR_CHANGE     | Turns on monitor mode.  This will monitor a directory for changes and then replicate them to the destination.
// @flag RF_AUTO_ROUTE		  | Uses information in the routing table to determine destinations servers.
// @flag RF_NOTIFY            | Turns on notify mode.  Replications occur based on notifications from the IAcceptNotify COM interface.
// @flag RF_PERMIT_TREE       | Applies ACLs on the directory structure to the files beneath it.	
} REPLICATION_INFO_A;
#endif

#ifndef ANSI_ONLY
//@struct REPLICATION_INFO_W | Contains information about a particular replication instance. 
// Is returned by <f QueryReplication> and <f EnumReplications>.
typedef struct _REPLICATION_INFO_W
{
	REPLICATION_INSTANCE hInstance; //@field The instance id for this replication.
	WCHAR cProject[MAX_PROJECT];    //@field The project associated with this replication.
	DWORD dwState;                  //@field The Current State of this replication
	// @flag REPL_STATE_EMPTY	  | This Replication Info structure is empty.
	// @flag REPL_STATE_STARTING  | The replication is a startup state.
	// @flag REPL_STATE_RUNNING   | The replication is currently running.
	// @flag REPL_STATE_COMPLETE  | The replication is complete.
	// @flag REPL_STATE_ABORTED   | The replication aborted due to an error.
	// @flag REPL_STATE_CANCLED	  | The replication was canceled.
	// @flag REPL_STATE_RECEIVING | The replication is receiving data.										
	DWORD dwError;	                // @field An error code if the replication aborted
	DWORD dwFlags;		            //@field Flags this replication was started with.
// @flag RF_NO_DELETE         | Turns of Delete Processing
// @flag RF_REPLICATE_ACLS    | Replicates ACL's
// @flag RF_NO_DATA           | Skips Replicating Data, will only replicate directories.
// @flag RF_FORCE_REPL        | Forces data to be replicated without checking first
// @flag RF_IN_PROC	          | Causes the StartReplication API to run in process (note: This blocks!)
// @flag RF_INCREMENTAL       | Runs replication in "Incremental" mode, meaning that only files which have been locally detected to have been modified since the last replication are checked and sent.
// @flag RF_FASTMODE          | Uses Unframed Protocol for enhanced performance over faster/secure links.
// @flag RF_ON_DIR_CHANGE     | Turns on monitor mode.  This will monitor a directory for changes and then replicate them to the destination.
// @flag RF_AUTO_ROUTE		  | Uses information in the routing table to determine destinations servers.
// @flag RF_NOTIFY            | Turns on notify mode.  Replications occur based on notifications from the IAcceptNotify COM interface.
// @flag RF_PERMIT_TREE       | Applies ACLs on the directory structure to the files beneath it.
	
} REPLICATION_INFO_W;
#endif

#ifdef UNICODE
#define REPLICATION_INFO REPLICATION_INFO_W
#else
#define REPLICATION_INFO REPLICATION_INFO_A
#endif



#ifndef UNICODE_ONLY
//@struct PROJECT_INFO | Returns a list of projects with some additional information.
// Is returned by <f EnumProjects>.
typedef struct _PROJECT_INFO_A
{
	CHAR cProject[ MAX_PROJECT];			//@field Project name
	CHAR cReplicationMethod[MAX_PROJECT];   //@field Replication method ("SENDINET" or "PULL")
	CHAR cDestination[ MAX_LOCATION];		//@field Destination server or route.
	CHAR cRootUrl[MAX_LOCATION];			//@field Root URL of a pull replication.
	CHAR cLocalDir[MAX_LOCATION];			//@field Local directory.
	CHAR cComments[MAX_LOCATION];			//@field User comments.

} PROJECT_INFO_A;
#endif

#ifndef ANSI_ONLY
//@struct PROJECT_INFO | Returns a list of projects with some additional information.
// Is returned by <f EnumProjects>.
typedef struct _PROJECT_INFO_W
{
	WCHAR cProject[ MAX_PROJECT];			//@field Project name
	WCHAR cReplicationMethod[MAX_PROJECT];  //@field Replication method ("SENDINET" or "PULL")
	WCHAR cDestination[ MAX_LOCATION];		//@field Destination server or route.
	WCHAR cRootUrl[MAX_LOCATION];			//@field Root URL of a pull replication.
	WCHAR cLocalDir[MAX_LOCATION];			//@field Local directory.
	WCHAR cComments[MAX_LOCATION];			//@field User comments.

} PROJECT_INFO_W;
#endif

#ifdef UNICODE
#define PROJECT_INFO PROJECT_INFO_W
#else
#define PROJECT_INFO PROJECT_INFO_A
#endif


#ifndef UNICODE_ONLY
//@struct ROUTE_LIST_A | Returns the list of routes defined for a server.
// Is returned by <f ListRoutes>.
typedef struct _ROUTE_LIST_A
{
	CHAR cRouteName[MAX_PROJECT];	   //@field Name of the route.
	CHAR cDestinations[MAX_LOCATION];  //@field Multi-string list of destinations (format "dest1\0dest2\0\0")
	CHAR cBaseDirectory[MAX_LOCATION]; //@field Base directory for projects using this route.

} ROUTE_LIST_A;
#endif

#ifndef ANSI_ONLY
//@struct ROUTE_LIST_W | Returns the list of routes defined for a server.
// Is returned by <f ListRoutes>.
typedef struct _ROUTE_LIST_W
{
	WCHAR cRouteName[MAX_PROJECT];		//@field Name of the route.
	WCHAR cDestinations[MAX_LOCATION];  //@field Multi-string list of destinations (format "dest1\0dest2\0\0")
	WCHAR cBaseDirectory[MAX_LOCATION]; //@field Base directory for projects using this route.

} ROUTE_LIST_W;
#endif

#ifdef UNICODE
#define ROUTE_LIST ROUTE_LIST_W
#else
#define ROUTE_LIST ROUTE_LIST_A
#endif

#ifndef UNICODE_ONLY
//@struct PARMSET_A | Defines a Parameter for <f CreateNewProject>, <f SetProject>, and <f QueryProject>.
typedef struct 
{
	DWORD dwType;					   //@field Parameter Type (Registry type values, REG_SZ, etc).
	DWORD dwFlags;                     //@field Parameter flags
	DWORD dwSize;                      //@field Size of value parameter
	CHAR cParmName[MAX_PARM_STRING];   //@field Parameter Name
	CHAR cParmValue[MAX_PARM_STRING];  //@field Parameter Value
}PARMSET_A;
#endif

#ifndef ANSI_ONLY
//@struct PARMSET_W | Defines a Parameter for <f CreateNewProject>, <f SetProject>, and <f QueryProject>.
typedef struct 
{
	DWORD dwType;					   //@field Parameter Type (Registry type values, REG_SZ, etc).
	DWORD dwFlags;                     //@field Parameter flags
	DWORD dwSize;                      //@field Size of value parameter
	WCHAR cParmName[MAX_PARM_STRING];  //@field Parameter Name
	WCHAR cParmValue[MAX_PARM_STRING]; //@field Parameter Value
}PARMSET_W;
#endif

#ifdef UNICODE
#define PARMSET PARMSET_W
#else
#define PARMSET PARMSET_A
#endif


//@struct PARM_LIST | Contains a list of parameters to pass with <f CreateNewProject>, <f SetProject>, <f QueryProject>.
typedef struct _PARM_LIST
{
	DWORD dwNumParms; // @field The number of Parameters in this list
	PARMSET Parms[1]; // @field An array of Parameters
} PARM_LIST;

#ifndef UNICODE_ONLY
typedef struct _PARM_LIST_A
{
	DWORD dwNumParms;   // @field The number of Parameters in this list
	PARMSET_A Parms[1]; // @field An array of Parameters
} PARM_LIST_A;
#endif

#define CRS_STOP_SERVICE    (1<<1)
#define CRS_PAUSE_SERVICE   (1<<2)
#define CRS_RESUME_SERVICE  (1<<3)
#define CRS_START_SERVICE   (1<<4)

#define CRS_USER_ACCESS   ( KEY_READ )
#define CRS_ADMIN_ACCESS  ( KEY_ALL_ACCESS | READ_CONTROL )


typedef SELECTION_LIST *PSELECTION_LIST;
typedef REPLICATION_INSTANCE *PREPLICATION_INSTANCE;

#define SELECT_LIST_SIZE(p) ((p->nEntries * sizeof(SELECTION_ENTRY))+sizeof(p->nEntries))

#ifndef USE_COM_APIS

#ifndef UNICODE_ONLY
DWORD CRSAPI CancelReplicationA(LPCSTR pszServer, REPLICATION_INSTANCE hInstance,DWORD dwFlags );
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI CancelReplicationW(LPCWSTR pszServer, REPLICATION_INSTANCE hInstance,DWORD dwFlags );
#endif

#ifdef UNICODE
#define CancelReplication CancelReplicationW
#else
#define CancelReplication CancelReplicationA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI StartReplicationA(LPCSTR  pszServer, LPCSTR pszProject, PSELECTION_LIST slFileSet, DWORD dwFlags, PREPLICATION_INSTANCE hInstance);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI StartReplicationW(LPCWSTR pszServer, LPCWSTR pszProject, PSELECTION_LIST slFileSet, DWORD dwFlags, PREPLICATION_INSTANCE hInstance);
#endif

#ifdef UNICODE
#define StartReplication StartReplicationW
#else
#define StartReplication StartReplicationA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI QueryReplicationA(LPCSTR  pszServer, REPLICATION_INSTANCE hInstance, REPLICATION_INFO_A *rpInfo, REPLICATION_COUNTERS *rCounters);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI QueryReplicationW(LPCWSTR pszServer, REPLICATION_INSTANCE hInstance, REPLICATION_INFO_W *rpInfo, REPLICATION_COUNTERS *rCounters);
#endif

#ifdef UNICODE
#define QueryReplication QueryReplicationW
#else
#define QueryReplication QueryReplicationA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI EnumReplicationsA(LPCSTR  pszServer, LPCSTR  pszMatchProject, DWORD dwMatchState, DWORD *dwNumReplications, void **pBuffer);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI EnumReplicationsW(LPCWSTR pszServer, LPCWSTR pszMatchProject, DWORD dwMatchState, DWORD *dwNumReplications, void **pBuffer);
#endif

#ifdef UNICODE
#define EnumReplications EnumReplicationsW
#else
#define EnumReplications EnumReplicationsA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI LockTransactionsA(LPCSTR  pszServer,  LPCSTR pszProject, DWORD dwWait, DWORD dwFlags);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI LockTransactionsW(LPCTSTR pszServer, LPCTSTR pszProject, DWORD dwWait, DWORD dwFlags);
#endif

#ifdef UNICODE
#define LockTransactions LockTransactionsW
#else
#define LockTransactions LockTransactionsA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI UnlockTransactionsA(LPCSTR pszServer,  LPCSTR  pszProject, DWORD dwFlags);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI UnlockTransactionsW(LPCWSTR pszServer, LPCWSTR pszProject, DWORD dwFlags);
#endif

#ifdef UNICODE
#define UnlockTransactions UnlockTransactionsW
#else
#define UnlockTransactions UnlockTransactionsA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI RollbackReplicationA(LPCSTR  pszServer,  LPCSTR pszProject,int nRollbacks,DWORD dwFlags);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI RollbackReplicationW(LPCWSTR pszServer, LPCWSTR pszProject,int nRollbacks,DWORD dwFlags);
#endif

#ifdef UNICODE
#define RollbackReplication RollbackReplicationW
#else
#define RollbackReplication RollbackReplicationA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI ReturnLogA(LPCSTR  pszServer, DWORD dwOffset, DWORD *dwSize, PVOID pvBuffer);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI ReturnLogW(LPCWSTR pszServer, DWORD dwOffset, DWORD *dwSize, PVOID pvBuffer);
#endif

#ifdef UNICODE
#define ReturnLog ReturnLogW
#else
#define ReturnLog ReturnLogA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI CreateNewProjectA(LPCSTR  pszServer, LPCSTR  pszProjectType, LPCSTR  pszProject, DWORD dwFlags, LPCSTR  pszDest, LPCSTR  pszLocalDir, PARM_LIST *pParms);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI CreateNewProjectW(LPCWSTR pszServer, LPCWSTR pszProjectType, LPCWSTR pszProject, DWORD dwFlags, LPCWSTR pszDest, LPCWSTR pszLocalDir, PARM_LIST *pParms);
#endif

#ifdef UNICODE
#define CreateNewProject CreateNewProjectW
#else
#define CreateNewProject CreateNewProjectA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI DeleteProjectA(LPCSTR pszServer,  LPCSTR pzsProject,  DWORD dwFlags);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI DeleteProjectW(LPCWSTR pszServer, LPCWSTR pzsProject, DWORD dwFlags);
#endif

#ifdef UNICODE
#define DeleteProject DeleteProjectW
#else
#define DeleteProject DeleteProjectA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI EnumProjectsA( LPCSTR pszServer, DWORD dwFlags, DWORD *dwNumProjects, void **pBuffer); 
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI EnumProjectsW( LPCWSTR pszServer, DWORD dwFlags, DWORD *dwNumProjects, void **pBuffer); 
#endif

#ifdef UNICODE
#define EnumProjects EnumProjectsW
#else
#define EnumProjects EnumProjectsA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI QueryProjectA( LPCSTR pszServer, LPCSTR pszProject, PARM_LIST **pParmList);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI QueryProjectW( LPCWSTR pszServer, LPCWSTR pszProject, PARM_LIST **pParmList);
#endif

#ifdef UNICODE
#define QueryProject QueryProjectW
#else
#define QueryProject QueryProjectA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI SetProjectA(  LPCSTR pszServer,  LPCSTR pszProject, PARM_LIST *pParmList);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI SetProjectW( LPCWSTR pszServer, LPCWSTR pszProject, PARM_LIST *pParmList);
#endif

#ifdef UNICODE
#define SetProject SetProjectW
#else
#define SetProject SetProjectA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI AddRouteA( LPCSTR pszServer,  LPCSTR pszRoute,  LPSTR pszDestinations,  LPCSTR pszBaseDir );
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI AddRouteW( LPCWSTR pszServer, LPCWSTR pszRoute, LPWSTR pszDestinations, LPCWSTR pszBaseDir );
#endif

#ifdef UNICODE
#define AddRoute AddRouteW
#else
#define AddRoute AddRouteA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI ListRoutesA( LPCSTR pszServer, LPDWORD dwNumRoutes, ROUTE_LIST_A **pRouteList);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI ListRoutesW( LPCWSTR pszServer, LPDWORD dwNumRoutes, ROUTE_LIST_W **pRouteList);
#endif

#ifdef UNICODE
#define ListRoutes ListRoutesW
#else
#define ListRoutes ListRoutesA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI DeleteRouteA( LPCSTR pszServer, LPCSTR pszRoute);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI DeleteRouteW( LPCWSTR pszServer, LPCWSTR pszRoute);
#endif

#ifdef UNICODE
#define DeleteRoute DeleteRouteW
#else
#define DeleteRoute DeleteRouteA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI CrsInitLoggingA(LPCSTR pszLoggingName, BOOL fFullLogging);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI CrsInitLoggingW(LPCWSTR pszLoggingName, BOOL fFullLogging);
#endif

#ifdef UNICODE
#define CrsInitLogging CrsInitLoggingW
#else
#define CrsInitLogging CrsInitLoggingA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI CrsControlA( LPCSTR  pszServer, DWORD dwFlags);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI CrsControlW( LPCWSTR pszServer, DWORD dwFlags);
#endif

#ifdef UNICODE
#define CrsControl CrsControlW
#else
#define CrsControl CrsControlA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI QueryReplicationGlobalsA( LPCSTR pszServer, PARM_LIST **ppParmList);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI QueryReplicationGlobalsW( LPCWSTR pszServer, PARM_LIST **ppParmList);
#endif

#ifdef UNICODE
#define QueryReplicationGlobals QueryReplicationGlobalsW
#else
#define QueryReplicationGlobals QueryReplicationGlobalsA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI SetReplicationGlobalsA( LPCSTR pszServer, PARM_LIST *ppParmList);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI SetReplicationGlobalsW( LPCWSTR pszServer, PARM_LIST *ppParmList);
#endif

#ifdef UNICODE
#define SetReplicationGlobals SetReplicationGlobalsW
#else
#define SetReplicationGlobals SetReplicationGlobalsA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI CrsGrantAccessA( LPCSTR pszServer, LPCSTR pszProject, LPCSTR pszUserName, DWORD dwAccess );
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI CrsGrantAccessW( LPCWSTR pszServer, LPCWSTR pszProject, LPCWSTR pszUserName, DWORD dwAccess );
#endif

#ifdef UNICODE
#define CrsGrantAccess CrsGrantAccessW
#else
#define CrsGrantAccess CrsGrantAccessA
#endif

#ifndef UNICODE_ONLY
DWORD CRSAPI CrsRemoveAccessA( LPCSTR pszServer, LPCSTR pszProject, LPCSTR pszUserName);
#endif

#ifndef ANSI_ONLY
DWORD CRSAPI CrsRemoveAccessW( LPCWSTR pszServer, LPCWSTR pszProject, LPCWSTR pszUserName);
#endif

#ifdef UNICODE
#define CrsRemoveAccess CrsRemoveAccessW
#else
#define CrsRemoveAccess CrsRemoveAccessA
#endif


DWORD CRSAPI FreeEnumBuffer(void **pBuffer);
BOOL  CRSAPI IsCrsAdmin(void);

#endif // USE_COM_APIS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\crstypes.h ===
// 
//
// Copyright (c) 1995-1996  Microsoft Corporation
//
// Module Name:
//
//    crstypes.h
//
// Abstract:
//
//    This module defines the common structures and prototypes for the   
//    Content Replication Service API.
//
// Revision History:
//

#ifndef CRSTYPES_INCLUDED
#define CRSTYPES_INCLUDED

typedef enum CRS_PROJECT_CREATION
{
   CREATE_NEW_PROJECT = 0x1,
   OPEN_EXISTING_PROJECT = 0x2
} CRS_PROJECT_CREATION;

#define MAX_PATH    260
#define MAX_PROJECT 100
#define MAX_LOCATION 300
#define MAX_DESTINATION_BUFFER 0x1000
#define MAX_ROUTE_NAME 100


#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#define NOREF(x) x=x

// @DOC 

#define RF_NO_DELETE			1		
#define RF_REPLICATE_ACLS		(1 << 1)	
#define RF_NO_DATA				(1 << 2)	
#define RF_FORCE_REPL			(1 << 3)	
#define RF_PERMIT_TREE			(1 << 4)
#define RF_IN_PROC				(1 << 5)	
#define RF_INCREMENTAL			(1 << 6)	
#define RF_FASTMODE				(1 << 7)
#define RF_ON_DIR_CHANGE		(1 << 8)
#define RF_AUTO_ROUTE			(1 << 9)
#define RF_ON_NOTIFY			(1 << 10)
#define RF_NO_CHAIN				(1 << 11)


#define RF_DELETE				(1 << 16)
#define RF_NO_REPLICATE_ACLS    (1 << 17)
#define RF_DATA					(1 << 18)	
#define RF_NO_FORCE_REPL		(1 << 19)	
#define RF_NO_PERMIT_TREE		(1 << 20)
#define RF_NO_IN_PROC			(1 << 21)
#define RF_NO_INCREMENTAL		(1 << 22)	
#define RF_NO_FASTMODE			(1 << 23)
#define RF_NO_ON_DIR_CHANGE		(1 << 24)
#define RF_NO_AUTO_ROUTE		(1 << 25)
#define RF_NO_ON_NOTIFY        	(1 << 26)
#define RF_CHAIN				(1 << 27)


#define REPL_STATE_EMPTY	 0  
#define REPL_STATE_STARTING  1
#define REPL_STATE_RUNNING   2
#define REPL_STATE_COMPLETE  3
#define REPL_STATE_ABORTED   4
#define REPL_STATE_CANCLED	 5
#define REPL_STATE_RECEIVING 6

#define PARM_VALUE_ENCRYPTED 1


#define CP_PROPOGATE_ALL		 1


#define	 MAX_PARM_STRING	300


typedef DWORD REPL_INSTANCE; // @type REPLICATION_INSTANCE | Identifier of a particular replication instance. Needed to call any function which manipulates or queries and existing replication


// @struct REPLICATION_COUNTERS | Counters used to record replication information. Returned by QueryReplication.
typedef struct _REPL_COUNTERS
{
	DWORD dwStartStamp;		      //@field Start Time
	DWORD dwFilesSent; 		      //@field The Total files that have been sent across this connection.
	DWORD dwFilesReceived;	      //@field The total files that have been received across this connection.
	DWORD dwFilesMatched;         //@field The number of files that matched and did not need to be sent
	DWORD dwFilesErrored;         //@field The number of files which had errors
	DWORD dwBytesSent;            //@field The total bytes sent across this connection.
	DWORD dwBytesReceived;        //@field The total bytes received across this connection.
	DWORD dwBytesMatched;         //@field The total bytes which matched and did not need to be sent.
	DWORD dwBytesErrored;         //@field The total bytes errored

	DWORD dwDirectoriesProcessed; //@field The number of directories processed

} REPL_COUNTERS;


//@struct REPLICATION_INFO_W | Contains information about a particular replication instance. 
// Is returned by <f QueryReplication> and <f EnumReplications>.
typedef struct _REPL_INFO
{
	REPL_INSTANCE hInstance; //@field The instance id for this replication.
	WCHAR cProject[MAX_PROJECT];    //@field The project associated with this replication.
	DWORD dwState;                  //@field The Current State of this replication
	// @flag REPL_STATE_EMPTY	  | This Replication Info structure is empty.
	// @flag REPL_STATE_STARTING  | The replication is a startup state.
	// @flag REPL_STATE_RUNNING   | The replication is currently running.
	// @flag REPL_STATE_COMPLETE  | The replication is complete.
	// @flag REPL_STATE_ABORTED   | The replication aborted due to an error.
	// @flag REPL_STATE_CANCLED	  | The replication was canceled.
	// @flag REPL_STATE_RECEIVING | The replication is receiving data.										
	DWORD dwError;	                // @field An error code if the replication aborted
	DWORD dwFlags;		            //@field Flags this replication was started with.
// @flag RF_NO_DELETE         | Turns of Delete Processing
// @flag RF_REPLICATE_ACLS    | Replicates ACL's
// @flag RF_NO_DATA           | Skips Replicating Data, will only replicate directories.
// @flag RF_FORCE_REPL        | Forces data to be replicated without checking first
// @flag RF_IN_PROC	          | Causes the StartReplication API to run in process (note: This blocks!)
// @flag RF_INCREMENTAL       | Runs replication in "Incremental" mode, meaning that only files which have been locally detected to have been modified since the last replication are checked and sent.
// @flag RF_FASTMODE          | Uses Unframed Protocol for enhanced performance over faster/secure links.
// @flag RF_ON_DIR_CHANGE     | Turns on monitor mode.  This will monitor a directory for changes and then replicate them to the destination.
// @flag RF_AUTO_ROUTE		  | Uses information in the routing table to determine destinations servers.
// @flag RF_NOTIFY            | Turns on notify mode.  Replications occur based on notifications from the IAcceptNotify COM interface.
// @flag RF_PERMIT_TREE       | Applies ACLs on the directory structure to the files beneath it.
	
} REPL_INFO;


//@struct ROUTE_LIST_W | Returns the list of routes defined for a server.
// Is returned by <f ListRoutes>.
typedef struct _ROUTE_INFO
{
	WCHAR cRouteName[MAX_PROJECT];		//@field Name of the route.
	WCHAR cDestinations[MAX_LOCATION];  //@field Multi-string list of destinations (format "dest1\0dest2\0\0")
	WCHAR cBaseDirectory[MAX_LOCATION]; //@field Base directory for projects using this route.

} ROUTE_INFO;

//@struct PARMSET_W | Defines a Parameter for <f CreateNewProject>, <f SetProject>, and <f QueryProject>.
typedef struct _PARAM
{
	DWORD dwType;					   //@field Parameter Type (Registry type values, REG_SZ, etc).
	DWORD dwFlags;                     //@field Parameter flags
	DWORD dwSize;                      //@field Size of value parameter
	WCHAR cParmName[MAX_PARM_STRING];  //@field Parameter Name
	WCHAR cParmValue[MAX_PARM_STRING]; //@field Parameter Value
}PARAM;


//@struct PARM_LIST | Contains a list of parameters to pass with <f CreateNewProject>, <f SetProject>, <f QueryProject>.
typedef struct _PARAM_LIST
{
	DWORD dwNumParms; // @field The number of Parameters in this list
	PARAM Params[1]; // @field An array of Parameters
} PARAM_LIST;


#define CRS_STOP_SERVICE    (1<<1)
#define CRS_PAUSE_SERVICE   (1<<2)
#define CRS_RESUME_SERVICE  (1<<3)
#define CRS_START_SERVICE   (1<<4)

#define CRS_USER_ACCESS   ( KEY_READ )
#define CRS_ADMIN_ACCESS  ( KEY_ALL_ACCESS | READ_CONTROL )


typedef struct _CRS_ACCESS_LIST
{
	DWORD dwAccessMask;
	WCHAR cUser[MAX_PATH];
} CRS_ACCESS_LIST, *LPCRS_ACCESS_LIST;

#define CRS_SZ          ( REG_SZ )
#define CRS_MULTI_SZ    ( REG_MULTI_SZ )
#define CRS_DWORD       ( REG_DWORD )
#define CRS_DATE        ( REG_BINARY )


#define CRS_END_OF_LIST (0xffffffff)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\cstream.h ===
#pragma once

class CImpIStream : public IStream
{
	private:
        LONG	m_cRef;

	protected:
		ULONG	m_cbSeek;
		STATSTG m_statstg;

	public:
		CImpIStream(void);
		CImpIStream(PVOID pvData,ULONG cbSize);
		virtual ~CImpIStream(void);

		//IUnknown
        STDMETHODIMP QueryInterface( 
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppvObject);
        
        STDMETHODIMP_(ULONG) AddRef(void);
        
        STDMETHODIMP_(ULONG) Release(void);

		// IStream
        STDMETHODIMP Read(
        	void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbRead);
        
        STDMETHODIMP Write( 
            const void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbWritten);
        
        STDMETHODIMP Seek( 
            LARGE_INTEGER dlibMove,
            DWORD dwOrigin,
            ULARGE_INTEGER __RPC_FAR *plibNewPosition);
        
        STDMETHODIMP SetSize( 
            ULARGE_INTEGER libNewSize);

        STDMETHODIMP CopyTo( 
            IStream __RPC_FAR *pstm,
            ULARGE_INTEGER cb,
            ULARGE_INTEGER __RPC_FAR *pcbRead,
            ULARGE_INTEGER __RPC_FAR *pcbWritten);
        
        STDMETHODIMP Commit( 
            DWORD grfCommitFlags);
        
        STDMETHODIMP Revert( void);
        
        STDMETHODIMP LockRegion( 
            ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb,
            DWORD dwLockType);
        
        STDMETHODIMP UnlockRegion( 
            ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb,
            DWORD dwLockType);
        
        STDMETHODIMP Stat( 
            STATSTG __RPC_FAR *pstatstg,
            DWORD grfStatFlag);
        
        STDMETHODIMP Clone( 
            IStream __RPC_FAR *__RPC_FAR *ppstm);
};

class CStreamMem : public CImpIStream
{
	private:
		PVOID	m_pvData;
		BOOL	m_fExternalData;
	public:
		CStreamMem(void);
		CStreamMem(PVOID pvData,ULONG cbSize);
		~CStreamMem(void);

		// IStream
        STDMETHODIMP Read(
        	void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbRead);
        
        STDMETHODIMP Write( 
            const void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbWritten);
        
        STDMETHODIMP Seek( 
            LARGE_INTEGER dlibMove,
            DWORD dwOrigin,
            ULARGE_INTEGER __RPC_FAR *plibNewPosition);
        
        STDMETHODIMP SetSize( 
            ULARGE_INTEGER libNewSize);
        
        STDMETHODIMP CopyTo( 
            IStream __RPC_FAR *pstm,
            ULARGE_INTEGER cb,
            ULARGE_INTEGER __RPC_FAR *pcbRead,
            ULARGE_INTEGER __RPC_FAR *pcbWritten);

		STDMETHODIMP GetPointerFromStream(PVOID *ppv,DWORD *pdwSize);
};

class CStreamFile : public CImpIStream
{
	private:
		HANDLE m_hFile;
		BOOL m_fCloseHandle;
		BOOL m_fReadOnly;

	public:
		CStreamFile(HANDLE hFile,BOOL fCloseHandle = FALSE, BOOL fReadOnly = FALSE);
		~CStreamFile(void);

		// IStream
        STDMETHODIMP Read(
        	void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbRead);
        
        STDMETHODIMP Write( 
            const void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbWritten);
        
        STDMETHODIMP Seek( 
            LARGE_INTEGER dlibMove,
            DWORD dwOrigin,
            ULARGE_INTEGER __RPC_FAR *plibNewPosition);
        
        STDMETHODIMP SetSize( 
            ULARGE_INTEGER libNewSize);

        STDMETHODIMP Commit( 
            DWORD grfCommitFlags);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\dbcon.h ===
/*--------------------------------------------------------------------------
    dbcon.h
        
		Normandy 2.0 connection management dll (supporting SQL server hot switch).

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:	Fei Su (feisu)

    History:	07/16/96	feisu		Created
  --------------------------------------------------------------------------*/


#ifndef __DBCON_H__
#define __DBCON_H__


#ifdef _DBSQL_IMPLEMENTING
	#define	DbSqlDLL __declspec(dllexport)
#else
	#define DbSqlDLL __declspec(dllimport)
#endif


#define DBNTWIN32
#pragma warning (disable:4121)
#include <sqlfront.h>
#pragma warning (default:4121)
#include <sqldb.h>


#define MAXSERVERNAME	30	// in sqlfront.h, length of server name ( excluding NULL termintor )
#define MAXNAME			31	// in sqlfront.h, length of login, db, password


// total DB types currently supported
#define AC_MAX_NUMBER_DATABASE_TYPES	1024


// database types are from 0 to AC_MAX_NUMBER_DATABASE_TYPES - 1. The assignment 
// of database types must be centralized.
//
// Proposal:
//		0  -->  9			Reserved for future use
//		10 --> 19			Address Book
//		20 --> 29			Security
//		100--> 200			IDS
//
// Add new services here.

#define DT_ABOOK_BASE									10

#define DT_SECURITY_BASE								20

#define DT_IDS_BASE										100




// if dbopen failed for a source, mark it as bad for 2 minutes for the server to recover
// all times are in units of seconds
#define DEFAULT_RECOVER_TIME			120

#define DEFAULT_MAX_CNX_PER_ENTRY		10
#define DEFAULT_QUERY_TIME_OUT			120
#define DEFAULT_LOGIN_TIME_OUT			20


// the following 2 numbers are only used by CPool
// they are the max number of CConnection and CLoginEntry internal structures
#define MAXCONN							256
#define MAXLOGIN						256


// exported functions
extern "C" {

BOOL DbSqlDLL	DbInitialize();
BOOL DbSqlDLL	DbTerminate();

BOOL DbSqlDLL	DbAddSource(LONG lType, LPCTSTR lpszServerName, LPCTSTR lpszLoginName, 
							LPCTSTR lpszPassWord, LPCTSTR lpszDBName, 
							LONG lMaxCnx = DEFAULT_MAX_CNX_PER_ENTRY, 
							LONG lQueryTimeOutInSeconds = DEFAULT_QUERY_TIME_OUT, 
							DWORD dwRecoverTimeInSeconds = DEFAULT_RECOVER_TIME);

BOOL DbSqlDLL	DbDropSource(LONG lType, LPCTSTR lpszServerName, LPCTSTR lpszLoginName);

HANDLE DbSqlDLL	DbGetConnection(LONG lType, DBPROCESS **dbproc, 
								DWORD dwWaitTimeInSeconds = DEFAULT_LOGIN_TIME_OUT);

BOOL DbSqlDLL	DbReleaseConnection(HANDLE hCDBConnection);

BOOL DbSqlDLL	DbAssociate(LONG lType, LONG lBackup);

BOOL DbSqlDLL	DbGetError(PDBPROCESS pDbproc, INT *dberr);

BOOL DbSqlDLL   DbGetConnectionFlag(HANDLE hCDBConnection, DWORD* pdwFlag);
BOOL DbSqlDLL   DbSetConnectionFlag(HANDLE hCDBConnection, DWORD dwFlag);

}


#endif // #ifndef __DBCON_H__

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\crypt.h ===
//+---------------------------------------------------------------------------
//
//  File:       crypt.h
//
//  Contents:	Functions that had to be mostly borrowed from NT src tree
//
//  History:    SudK    Created     6/25/95
//
//----------------------------------------------------------------------------
#ifndef _NTCRYPT_
#define _NTCRYPT_

#ifndef MIDL_PASS    // Don't confuse MIDL

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#ifndef WIN16_BUILD
#include <rpc.h>   
#else 
#define NTAPI FAR PASCAL
#define IN
#define OUT
#define BOOLEAN BOOL
#define OPTIONAL
#define NTSYSAPI
#endif

#endif // MIDL_PASS


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#define CLEAR_BLOCK_LENGTH          8

typedef struct _CLEAR_BLOCK {
    CHAR    data[CLEAR_BLOCK_LENGTH];
}                                   CLEAR_BLOCK;
typedef CLEAR_BLOCK *               PCLEAR_BLOCK;


#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    CHAR    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef CYPHER_BLOCK *              PCYPHER_BLOCK;


#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    CHAR    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    ULONG   Length;         // Number of valid bytes in buffer
    ULONG   MaximumLength;  // Number of bytes pointed to by Buffer
    PVOID   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef CHAR *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)

typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;



//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH

typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;



//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;



//
// Define the index type used to encrypt OWF Passwords
//

typedef LONG                        CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types that are used to duplicate existing LM        //
//      functionality with improved algorithms.                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef UNICODE_STRING              NT_PASSWORD;
typedef NT_PASSWORD *               PNT_PASSWORD;


#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH

typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;


#define NT_CHALLENGE_LENGTH         LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;


#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;


#define ENCRYPTED_NT_OWF_PASSWORD_LENGTH ENCRYPTED_LM_OWF_PASSWORD_LENGTH

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;


#define NT_SESSION_KEY_LENGTH       LM_SESSION_KEY_LENGTH

typedef LM_SESSION_KEY              NT_SESSION_KEY;
typedef NT_SESSION_KEY *            PNT_SESSION_KEY;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types for new functionality not present in LM       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The user session key is similar to the LM and NT session key except it
// is different for each user on the system. This allows it to be used
// for secure user communication with a server.
//
#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef struct _USER_SESSION_KEY {
    CYPHER_BLOCK data[2];
}                                   USER_SESSION_KEY;
typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;



////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define RtlEncryptBlock                 SystemFunction001
#define RtlDecryptBlock                 SystemFunction002
#define RtlEncryptStdBlock              SystemFunction003
#define RtlEncryptData                  SystemFunction004
#define RtlDecryptData                  SystemFunction005
#define RtlCalculateLmOwfPassword       SystemFunction006
#define RtlCalculateNtOwfPassword       SystemFunction007
#define RtlCalculateLmResponse          SystemFunction008
#define RtlCalculateNtResponse          SystemFunction009
#define RtlCalculateUserSessionKeyLm    SystemFunction010
#define RtlCalculateUserSessionKeyNt    SystemFunction011
#define RtlEncryptLmOwfPwdWithLmOwfPwd  SystemFunction012
#define RtlDecryptLmOwfPwdWithLmOwfPwd  SystemFunction013
#define RtlEncryptNtOwfPwdWithNtOwfPwd  SystemFunction014
#define RtlDecryptNtOwfPwdWithNtOwfPwd  SystemFunction015
#define RtlEncryptLmOwfPwdWithLmSesKey  SystemFunction016
#define RtlDecryptLmOwfPwdWithLmSesKey  SystemFunction017
#define RtlEncryptNtOwfPwdWithNtSesKey  SystemFunction018
#define RtlDecryptNtOwfPwdWithNtSesKey  SystemFunction019
#define RtlEncryptLmOwfPwdWithUserKey   SystemFunction020
#define RtlDecryptLmOwfPwdWithUserKey   SystemFunction021
#define RtlEncryptNtOwfPwdWithUserKey   SystemFunction022
#define RtlDecryptNtOwfPwdWithUserKey   SystemFunction023
#define RtlEncryptLmOwfPwdWithIndex     SystemFunction024
#define RtlDecryptLmOwfPwdWithIndex     SystemFunction025
#define RtlEncryptNtOwfPwdWithIndex     SystemFunction026
#define RtlDecryptNtOwfPwdWithIndex     SystemFunction027
#define RtlGetUserSessionKeyClient      SystemFunction028
#define RtlGetUserSessionKeyServer      SystemFunction029
#define RtlEqualLmOwfPassword           SystemFunction030
#define RtlEqualNtOwfPassword           SystemFunction031
#define RtlEncryptData2                 SystemFunction032
#define RtlDecryptData2                 SystemFunction033


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


//
// Core block encryption functions
//

NTSTATUS
NTAPI
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

NTSTATUS
NTAPI
RtlDecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    );

NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

//
// Arbitrary length data encryption functions
//

NTSTATUS
NTAPI
RtlEncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    );

NTSTATUS
NTAPI
RtlDecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    );

//
// Faster arbitrary length data encryption functions (using RC4)
//

NTSTATUS
RtlEncryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

NTSTATUS
RtlDecryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

//
// Password hashing functions (One Way Function)
//

NTSTATUS
NTAPI
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
NTAPI
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );



//
// OWF password comparison functions
//

BOOLEAN
RtlEqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    );

BOOLEAN
RtlEqualNtOwfPassword(
    IN PNT_OWF_PASSWORD NtOwfPassword1,
    IN PNT_OWF_PASSWORD NtOwfPassword2
    );



//
// Functions for calculating response to server challenge
//

NTSTATUS
NTAPI
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    );


NTSTATUS
NTAPI
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    );




//
// Functions for calculating User Session Key.
//

//
// Calculate a User Session Key from LM data
//
NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

//
// Calculate a User Session Key from NT data
//
NTSTATUS
NTAPI
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );





//
// OwfPassword encryption functions
//


//
// Encrypt OwfPassword using OwfPassword as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtOwfPwd(
    IN PNT_OWF_PASSWORD DataNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtOwfPwd(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PNT_OWF_PASSWORD DataNtOwfPassword
    );


//
// Encrypt OwfPassword using SessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtSesKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtSesKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using UserSessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithUserKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithUserKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlEncryptNtOwfPwdWithUserKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithUserKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using an index as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithIndex(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithIndex(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Get the user session key for an RPC connection
//

#ifndef MIDL_PASS    // Don't confuse MIDL
NTSTATUS
RtlGetUserSessionKeyClient(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyServer(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey
    );
#endif // MIDL_PASS

#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\dbgfile.h ===
/*----------------------------------------------------------------------
	dbgfile.h
		Definitions for async tracing file ATF files

	Copyright (C) 1994 Microsoft Corporation
	All rights reserved.

	Authors:
		gordm          Gord Mangione

	History:
		01/30/95 gordm		Created.
----------------------------------------------------------------------*/


//
// Trace file types and definitions
//
// The binary trace file contains the trace statement of the
// following structure. All dwLengths include the entire structure
//


typedef struct tagFIXEDTRACE
{
	WORD		wSignature;
	WORD		wLength;
	WORD		wVariableLength;
	WORD		wBinaryType;
	DWORD		dwTraceMask;
	DWORD		dwProcessId;
	DWORD		dwThreadId;
	SYSTEMTIME	TraceTime;
	DWORD		dwParam;
	WORD		wLine;
	WORD		wFileNameOffset;
	WORD		wFunctNameOffset;
	WORD		wBinaryOffset;
} FIXEDTRACE, *PFIXEDTRACE, FIXEDTR, *PFIXEDTR;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\dbsql.h ===
/*--------------------------------------------------------

  dbsql.h
      Contains declarations for dbsql.lib.

  Copyright (C) 1995 Microsoft Corporation
  All rights reserved.

  Authors:
      keithbi    Keith Birney

  History:
      12-21-95    keithbi    Created. 

  -------------------------------------------------------*/

#ifndef _DBSQL_H_
#define _DBSQL_H_

// THIS_FILE is defined in source files 
//
// #if defined(DEBUG) && defined(INLINE)
// #undef THIS_FILE
// static char BASED_CODE DBSQL_H[] = "dbsql.h";
// #define THIS_FILE DBSQL_H
// #endif

#if !defined(DllExport)

#define DllExport __declspec(dllexport)
#endif

#if !defined(DllImport)
#define DllImport __declspec(dllimport)

#endif

#if !defined(_DBSQLDLL_DEFINED)
#if defined(WIN32) && !defined(DBSQL_LIB)
    #if defined(_DBSQLDLL)
	#define DbSqlDLL DllExport
    #else
	#define DbSqlDLL DllImport
    #endif
#else
    #define DbSqlDLL
#endif
#define _DBSQLDLL_DEFINED
#endif

#include <dbsqltyp.h>
#include <dbsqldef.h>
#include <dbsqlutl.h>
#include <dbsqlqry.h>
#include <dbsqlcon.h>

VOID DbSqlDLL LogEvent(WORD wEventLogType, DWORD dwEventId, 
                       DWORD dwSizeOfRawData, PVOID lpRawData,
		       WORD wNumberOfStrings,...);

extern "C"
{
BOOL DbSqlDLL FInitAcctsqlLib();
VOID DbSqlDLL TerminateAcctsqlLib();
INT  DbSqlDLL ExceptionFilter(LPEXCEPTION_POINTERS lpep, CHAR *szFunctionName);
UINT  DbSqlDLL GetPublicAcctHandle (HACCT *phacct);
UINT  DbSqlDLL GetLoginAcctHandle (HACCT *phacct);
UINT  DbSqlDLL GetEveryoneGroupID (HGROUP *phgroup);
UINT DbSqlDLL GetAcctDBConnection (WORD wType, DBPROCESS **dbproc);
UINT DbSqlDLL ReleaseDBConnection (DBPROCESS *dbproc);
} // extern "C"

#endif // _DBSQL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\dbgdumpx.h ===
/*++

Copyright (c) 1990, 1998 Microsoft Corporation

Module Name:

    ptdbgext.h
    *WAS* kdextlib.h

Abstract:

    Kernel Debugger extensions to allow the quick creation of CDB/Windbg
    debugger extensions.  Used in conjunction with the following:
        transdbg.h  - Minimal debugging extension helper macros
        ptdbgext.h  - Auto dump of classes and structures
        _dbgdump.h  - Used to define struct/class descriptors in 1 pass

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created
    21-Aug-1995 Milans  Copied for use in Mup Kernel Extensions
    19-April-1998 Mikeswa Modified for Exchange Platinum Transport

--*/

#ifndef _PTDBGEXT_H_
#define _PTDBGEXT_H_

#include <windef.h>
#include <transdbg.h>

#ifndef PTDBGEXT_USE_FRIEND_CLASSES
#include <_dbgdump.h>
#endif //PTDBGEXT_USE_FRIEND_CLASSES

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

//If you not include ntdefs.h, you will need this, otherwise set _ANSI_UNICODE_STRINGS_DEFINED_
#ifndef _ANSI_UNICODE_STRINGS_DEFINED_
//Define string types needed
typedef struct _ANSI_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} ANSI_STRING;
typedef ANSI_STRING *PANSI_STRING;
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt
#endif //_ANSI_UNICODE_STRINGS_DEFINED_


#define PT_DEBUG_EXTENSION(x) TRANS_DEBUG_EXTENSION(x)

//Define potentially exported functions... include those you want to expose in your def file
extern PT_DEBUG_EXTENSION(_help);    //display help based on ExtensionNames & Extensions
extern PT_DEBUG_EXTENSION(_dump);    //Dumps structs/classes as defined by macros in _dbgdump.h
extern PT_DEBUG_EXTENSION(_dumpoffsets);    //Dumps offsets of structs/classes as defined by macros in _dbgdump.h

#define DEFINE_EXPORTED_FUNCTIONS \
    PT_DEBUG_EXTENSION(help) { _help(DebugArgs);};   \
    PT_DEBUG_EXTENSION(dump) { _dump(DebugArgs);};

//
// The help strings printed out
//

extern LPSTR ExtensionNames[];

extern LPSTR Extensions[];

//
// The FIELD_DESCRIPTOR data structure is used to describe the field in a structure sufficiently
// for displaying information during debugging. The three pieces of information that are required
// are 1) the name of the field, 2) the offset in the corresponding structure and 3) a type descriptor.
// The type descriptor covers most primitive types.
//
// There are some types that can benefit from some auxillary information in the descriptors. A
// case in point is the "enum" defeinition. Merely printing out a numerical value for an enum
// type will invariably force the person using these extensions to refer to the corresponding
// include file. In order to avoid this we will accept an additional array for enum types that
// contains a textual description of the numerical value.  A "bit mask" type falls in the same
// category.  For the puposes of this extension lib, a "enum" and "bit mask" may be
// interchanged.  The key difference is that an "enum" will tested for a single value, while
// a "bit mask" will be testes using a bitwise OR against all values.  The ENUM_VALUE_DESCRIPTOR
// and BIT_MASK_DESCRIPTOR are interchangable.
//
// The macros to define the necessary structures can be found in _dbgdump.h.
//
typedef struct _ENUM_VALUE_DESCRIPTOR {
    ULONG   EnumValue;
    LPSTR   EnumName;
} ENUM_VALUE_DESCRIPTOR;

typedef struct _BIT_MASK_DESCRIPTOR {
    ULONG   BitmaskValue;
    LPSTR   BitmaskName;
} BIT_MASK_DESCRIPTOR;

typedef enum _FIELD_TYPE_CLASS {
    FieldTypeByte,
    FieldTypeChar,
    FieldTypeBoolean,
    FieldTypeBool,
    FieldTypeULong,
    FieldTypeLong,
    FieldTypeUShort,
    FieldTypeShort,
    FieldTypeGuid,
    FieldTypePointer,
    FieldTypePWStr, //used for LPWSTR fields
    FieldTypePStr,  //used for LPSTR fields
    FieldTypeWStrBuffer, //used for WCHAR[] fields
    FieldTypeStrBuffer, //used for CHAR[] fields
    FieldTypeUnicodeString,
    FieldTypeAnsiString,
    FieldTypeSymbol,
    FieldTypeEnum,
    FieldTypeByteBitMask,
    FieldTypeWordBitMask,
    FieldTypeDWordBitMask,
    FieldTypeFloat,
    FieldTypeDouble,
    FieldTypeStruct,
    FieldTypeLargeInteger,
    FieldTypeClassSignature,
    FieldTypeDword,
    FieldTypeListEntry,
    FieldTypeFiletime,            //Displays file time in human-readable format
    FieldTypeLocalizedFiletime,   //As above, but adjusts for TZ first
    FieldTypeEmbeddedStruct,      //dumps an embedded structure (4th param is struct array)
    FieldTypeNULL
} FIELD_TYPE_CLASS, *PFIELD_TYPE_CLASS;

typedef struct _FIELD_DESCRIPTOR_ {
    FIELD_TYPE_CLASS FieldType;   // The type of variable to be printed
    LPSTR            Name;        // The name of the field
    ULONG            Offset;      // The offset of the field in the structure
    union {
        VOID                   *pDescriptor;     // Generic Auxillary information - used by Field4 macro
        ENUM_VALUE_DESCRIPTOR  *pEnumValueDescriptor; // Auxillary information for enumerated types.
        BIT_MASK_DESCRIPTOR    *pBitMaskDescriptor; // Auxillary information for bitmasks.
        VOID                   *pStructDescriptor;
    } AuxillaryInfo;
} FIELD_DESCRIPTOR;

#define NULL_FIELD {FieldTypeNULL, NULL, 0, NULL}

//
// The structs that are displayed by the debugger extensions are further
// described in another array. Each entry in the array contains the name of
// the structure and the associated Field descriptor list.
//

typedef struct _STRUCT_DESCRITOR_ {
    LPSTR             StructName;
    ULONG             StructSize;
    FIELD_DESCRIPTOR  *FieldDescriptors;
} STRUCT_DESCRIPTOR;

//
//  The array of structs handled by the debugger extension.
//

extern STRUCT_DESCRIPTOR Structs[];

extern PWINDBG_OUTPUT_ROUTINE               g_lpOutputRoutine;
extern PWINDBG_GET_EXPRESSION               g_lpGetExpressionRoutine;
extern PWINDBG_GET_SYMBOL                   g_lpGetSymbolRoutine;
extern PWINDBG_READ_PROCESS_MEMORY_ROUTINE  g_lpReadMemoryRoutine;
extern HANDLE                               g_hCurrentProcess;

typedef PWINDBG_OLD_EXTENSION_ROUTINE PEXTLIB_INIT_ROUTINE;
extern PEXTLIB_INIT_ROUTINE               g_pExtensionInitRoutine;

#define    SETCALLBACKS() \
    g_lpOutputRoutine = pExtensionApis->lpOutputRoutine; \
    g_lpGetExpressionRoutine = pExtensionApis->lpGetExpressionRoutine; \
    g_lpGetSymbolRoutine = pExtensionApis->lpGetSymbolRoutine; \
    g_hCurrentProcess = hCurrentProcess; \
    g_lpReadMemoryRoutine = \
        ((pExtensionApis->nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
            NULL : pExtensionApis->lpReadProcessMemoryRoutine); \
    g_pExtensionInitRoutine ? (g_pExtensionInitRoutine)(dwCurrentPc, pExtensionApis, szArg) : 0;

#define KdExtReadMemory(a,b,c,d) \
    ((g_lpReadMemoryRoutine) ? \
    g_lpReadMemoryRoutine( (DWORD_PTR)(a), (b), (c), ((DWORD *)d) ) \
 :  ReadProcessMemory( g_hCurrentProcess, (LPCVOID)(a), (b), (c), (d) )) \

#define    PRINTF    g_lpOutputRoutine

VOID
PrintStructFields(
    DWORD_PTR dwAddress,
    VOID *ptr,
    FIELD_DESCRIPTOR *pFieldDescriptors,
    DWORD cIndentLevel
);

BOOL
PrintStringW(
    LPSTR msg,
    PUNICODE_STRING puStr,
    BOOL nl
);

BOOLEAN
GetData(
    DWORD_PTR dwAddress,
    PVOID ptr,
    ULONG size
);

#ifdef __cplusplus
}
#endif //__cplusplus

#endif // _PTDBGEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\dbsetup.h ===
//+---------------------------------------------------------------
//
//  File:	dbsetup.h
//
//  Synopsis: 
//
//  Copyright (C) 1995 Microsoft Corporation
//  		All rights reserved.
//
//  History:	Antony Halim Created			07/10/96
//
//----------------------------------------------------------------

#ifndef _DBSETUP_H_
#define _DBSETUP_H_


#define DBNTWIN32

#include <stdio.h>
#include <windows.h>

#pragma warning (disable:4121)
#include <sqlfront.h>
#pragma warning (default:4121)
#include <sqldb.h>

#include <dbgtrace.h>
#include <listmacr.h>

/* scanner stuff */
#define MBUFFER_SIZE	(1024*4)
#define LBUFFER_SIZE	(1024)
#define BUFFER_SIZE		(MBUFFER_SIZE + LBUFFER_SIZE + 1)
#define FULL_BUFFER_SIZE   (1024)
#define HALF_BUFFER_SIZE (FULL_BUFFER_SIZE/2)

#define TOKEN_ERROR     0
#define TOKEN_EOF       1
#define TOKEN_GO        2
#define TOKEN_LINE      3

typedef struct SCANBUF {
    CHAR pchBuffer[BUFFER_SIZE];
    CHAR *pchEndBuf;
    CHAR *pchMBuffer;
    CHAR *pchForward;
    CHAR *pchStart;
    CHAR *pchBegin;
    HANDLE hFile;
    INT state;
} *PSCANBUF;

extern int ScanToken(PSCANBUF pScanBuf);
extern BOOL InitScanner(PSCANBUF pScanBuf, HANDLE hExtFile);
extern LPSTR GetTokenString(PSCANBUF pScanBuf, CHAR *pchSaved);
extern VOID RestoreTokenString(PSCANBUF pScanBuf, CHAR chSaved);
/* end of scanner stuff */


//
//  dbsetup functions use this structure as the connection handle
//
typedef struct DBCONN {
	PDBPROCESS pDbproc;     //  DB-Lib handle
	DWORD dwDBError;        //  DB-Lib db error
	DWORD dwOSError;        //  DB-Lib os error
	char lpszDBError[128];    //  SQL Message
	char lpszSQLError[128];    //  SQL Message
    SCANBUF ScanBuf;        //  Scanner buffer
	LIST_ENTRY le;          //  linked list
} *PDBCONN;


typedef enum __COLTYPE {
	sql_int, sql_smallint, sql_tinyint, sql_char, sql_varchar, sql_float, sql_real,
	sql_text, sql_image
} COLTYPE;


typedef struct __COLUMN {
	CHAR		name[32];
	COLTYPE		type;
	int			length;
	BOOL		fNull;
} COLUMN;

//
// Function API
//
BOOL InitDB();
PDBCONN OpenDBConnection(LPSTR lpszServerName, LPSTR lpszLoginName,
    LPSTR lpszPasswd, LPSTR lpszDBName); 
BOOL CloseDBConnection(PDBCONN pDBConn);
BOOL TerminateDB();

BOOL UseDatabase(PDBCONN pDBConn, LPSTR lpszDBName);

BOOL AddAlias(PDBCONN pDBConn, LPSTR lpszLoginName, LPSTR lpszUserName);
BOOL DropUser(PDBCONN pDBConn, LPSTR lpszUserName);
BOOL CheckLoginExist(PDBCONN pDBConn, LPSTR lpszLogin,  BOOL *pfExist);

BOOL SetOption(PDBCONN pDBConn, INT iOption, LPSTR lpszParam);
BOOL SetConfig(PDBCONN pDBConn, LPSTR lpszConfigName, INT iValue);

BOOL CreateLogin(PDBCONN pDBConn, LPSTR lpszLoginName, LPSTR lpszPassword,
    LPSTR lpszDefaultDatabase);
BOOL DropLogin(PDBCONN pDBConn, LPSTR lpszLoginName);

BOOL CreateDevice(PDBCONN pDBConn, LPSTR lpszLogicalName,
    LPSTR lpszPhysicalName, DWORD dwSize);
BOOL DropDevice(PDBCONN pDBConn, LPSTR lpszLogicalName, BOOL fDeleteFile);
BOOL CheckDeviceExist(PDBCONN pDBConn, LPSTR lpszDevice,  BOOL *pfExist);

BOOL CreateDatabase(PDBCONN pDBConn, LPSTR lpszDBName, LPSTR lpszDataDev,
    DWORD dwDataSize, LPSTR lpszLogDev, DWORD dwLogSize);
BOOL DropDatabase(PDBCONN pDBConn, LPSTR lpszDBName);
BOOL CheckDatabaseExist(PDBCONN pDBConn, LPSTR lpszDatabase,  BOOL *pfExist);
BOOL AlterDatabase(PDBCONN pDBConn, LPSTR lpszDBName, LPSTR lpszDev,DWORD dwSize);
BOOL SetDBOption(PDBCONN pDBConn, LPSTR lpszDB, LPSTR lpszOption, BOOL fFlag);

BOOL CreateTable(PDBCONN pDBConn, LPSTR lpszTableName, COLUMN *Columns,
    DWORD dwCount);
BOOL DropTable(PDBCONN pDBConn, LPSTR lpszTableName);
BOOL DropAllTables(PDBCONN pDBConn, LPSTR lpszDB);

BOOL CreateIndex(PDBCONN pDBConn, LPSTR lpszIndexName, LPSTR lpszTableName,
    BOOL fUnique, BOOL fClustered, LPSTR lpszColName[], DWORD dwCount);
BOOL DropIndex(PDBCONN pDBConn, LPSTR lpszIndexName);
BOOL DropAllIndexes(PDBCONN pDBConn, LPSTR lpszDB);

BOOL ExecFile(PDBCONN pDBConn, LPSTR lpszFileName);
BOOL ExecCmd(PDBCONN pDBConn, LPSTR lpszSQLCmd);

#define CreateProc(pDBConn, lpszfileName)  ExecFile(pDBConn, lpszFileName)
BOOL DropProc(PDBCONN pDBConn, LPSTR lpszProcName);
BOOL DropAllProc(PDBCONN pDBConn, LPSTR lpszDB);

BOOL GetVersion(PDBCONN pDBConn, LPSTR lpszDatabase, LPSTR lpszTag, INT *iVer);

BOOL GetUserConnections(PDBCONN pDBConn, INT *lpiUserConn);

INT GetDbopenErrorNum();

LPSTR GetDbopenErrorMsg();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\dbsqlutl.h ===
/*--------------------------------------------------------

  dbsqlutl.h
  
  Copyright (C) 1995 - 1996 Microsoft Corporation
  All rights reserved.

  Authors:
      keithbi    Keith Birney

  History:
      10-09-95    keithbi    Created. 

  -------------------------------------------------------*/

#ifndef DBSQL_UTIL
#define DBSQL_UTIL

#if defined(DEBUG)

	extern "C"
	{
		void AcctDBDprintf(long lReportingLevel, PCSTR pcsz, ...);
		void AcctDBDebugSz(long lReportingLevel, PCSTR pcsz);
		void DebugLogEvent(PCSTR szFile, DWORD dwLine, PCSTR szMsg);
	}
	
	#define AcctDBAssert(f)	( (f) ? 0 : DebugLogEvent(__FILE__, __LINE__, "!(" #f ")") )

#else

	#define AcctDBDprintf			//
	#define AcctDBDebugSz(l, p)		//
	#define AcctDBAssert(f)	//

#endif

#if defined(NO_DBSQL_PERF)
	#define AcctDBPerf(s)
#else
	#define AcctDBPerf(s)	s
#endif

#endif // DBSQL_UTIL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\dbsqlqry.h ===
/*--------------------------------------------------------------------------
    dbsqlqry.h
        
        An additional layer to use in making dblib calls.

    Copyright (C) 1995 Microsoft Corporation
    All rights reserved.

    Authors:	Keith Birney (keithbi)

    History:	07/19/95	keithbi		Created
  --------------------------------------------------------------------------*/


#if !defined(__DBSQLQRY_H__)
#define __DBSQLQRY_H__


#define DBNTWIN32
#pragma warning (disable:4121)
#include <sqlfront.h>
#pragma warning (default:4121)
#include <sqldb.h>

// THIS_FILE is defined in source files
//
// #if defined(DEBUG) && defined(INLINE)
// #undef THIS_FILE
// static char BASED_CODE DBSQLQRY_H[] = "dbsqlqry.h";
// #define THIS_FILE DBSQLQRY_H
// #endif

#include <cpool.h>

class CDBConnection;
class CDBQueryBase;
class CDBQuery;

typedef UINT (FNPROCESSROWCALLBACK)(CDBQuery *, DWORD, DWORD, PVOID);
typedef FNPROCESSROWCALLBACK *PFNPROCESSROWCALLBACK;

class CDBQueryBase
{
public:
	virtual VOID 			Release() = 0;
	virtual VOID			ZeroDirtyParams() = 0;
	virtual VOID 			AddVarParam(WORD wDataType, PVOID pvParamValue, WORD wDataLen) = 0;
	virtual VOID			AddSzParam(WORD wDataType, PVOID pvParamValue) = 0;
	virtual VOID			AddParam(WORD wDataType, PVOID pvParamValue) = 0;
	virtual VOID			AddReturnParam(WORD wDataType, PVOID pvParamValue) = 0;
	virtual VOID			AddVarReturnParam(WORD wDataType, PVOID pvParamValue, WORD wDataLen, WORD wMaxLen) = 0;
	virtual VOID			AddResultsSet() = 0;
	virtual VOID			AddColumnToResultsSet(WORD wDataType) = 0;
	virtual VOID 			AddVarColumnToResultsSet(WORD wDataType, WORD wDataLen) = 0;
	virtual INT				IGetReturnStatus() = 0;
	virtual VOID			SetProcessRowCallback(PFNPROCESSROWCALLBACK pfnprocessrowcallback, PVOID pv) = 0;
	virtual UINT			UiGetResultRow(PVOID pvFirst, ...) = 0;
	virtual UINT			UiGetResultRowPtrs(PBYTE *pbFirst, ...) = 0;
	virtual BOOL			FQueryComplete() = 0;
	virtual BOOL			FQuerySuccess() = 0;
	virtual VOID			AddRef() = 0;
	virtual VOID			CancelExecution() = 0;
	virtual BYTE			BGetDatabaseType() = 0;
	virtual VOID			SetDatabaseType(BYTE bDatabaseType) = 0;
	virtual UINT			UiGetAPIReturnCode() = 0;
	virtual VOID			SetUserData(PVOID pv) = 0;
	virtual BOOL			FIsReentrantCall() = 0;
	virtual UINT			UiWaitUntilDone(DWORD dwTimeout) = 0;
	virtual VOID			SetAPIReturnCode(UINT uiRet) = 0;
	virtual VOID			SetRetryOnDBFail() = 0;
	virtual VOID			SetPartitionInfo(DWORD dwPartitionType, PVOID pvData) = 0;
	virtual DWORD			DwGetPartitionType() = 0;
	virtual PVOID			PvGetPartitionBasis() = 0;
	virtual UINT			UiWaitUntilResults(DWORD dwTimeout) = 0;
	virtual UINT			UiGetNextRow(PVOID pvFirst, ...) = 0;
	virtual	UINT			UiGetNextResultsSet() = 0;
};


class CDBQuery;

extern "C"
{
CDBQuery DbSqlDLL *PdbqueryNew(WORD wDatabaseType, CHAR *szStoredProcedureName);
}

#define AC_MAX_NUMBER_DBPARAMS 		32
#define AC_DB_OBJECT_NAME_SIZE		32
#define AC_MAX_NUMBER_RESULTS_SETS	5
#define AC_MAX_NUMBER_COLUMNS		32
#define AC_MAX_QUERIES_IN_POOL		1024
#define AC_RESULTS_ROW_BUFFER_WIDTH 2048

struct DBPARAM
{
	WORD			wDataType;
	WORD			wDataLen;
	WORD			wMaxLen;
	WORD			wStatus;
	PBYTE			pbParamValue;
};

struct DBRESULTCOLUMN
{
	WORD			wDataType;
	WORD			wDataLen;
	PBYTE			pbData;
};

struct DBRESULTINFO
{
	DWORD			dwNumberOfColumns;
	DBRESULTCOLUMN	dbrescol[AC_MAX_NUMBER_COLUMNS];
};

class CDBQuery : public CDBQueryBase
{
	friend CDBQuery DbSqlDLL *PdbqueryNew(WORD wDatabaseType, CHAR *szStoredProcedureName);

public:
	void * operator new(size_t size);
	void operator	delete(void *);

	VOID			AddRef();
	VOID 			Release();
	VOID			ZeroDirtyParams();

	VOID 			AddVarParam(WORD wDataType, PVOID pvParamValue, WORD wDataLen);
	VOID			AddSzParam(WORD wDataType, PVOID pvParamValue);
	VOID			AddParam(WORD wDataType, PVOID pvParamValue);

	VOID			AddReturnParam(WORD wDataType, PVOID pvParamValue);
	VOID			AddVarReturnParam(WORD wDataType, PVOID pvParamValue, WORD wDataLen, WORD wMaxLen);
	VOID			AddResultsSet();
	VOID			AddColumnToResultsSet(WORD wDataType);
	VOID 			AddVarColumnToResultsSet(WORD wDataType, WORD wDataLen);

	INT				IGetReturnStatus() { return m_iRetStatus; }
	VOID			SetProcessRowCallback(PFNPROCESSROWCALLBACK pfnprocessrowcallback, PVOID pv);

	UINT			UiGetResultRow(PVOID pvFirst, ...);
	UINT			UiGetResultRowPtrs(PBYTE *pbFirst, ...);

	UINT			UiWaitUntilResults(DWORD dwTimeout);
	UINT			UiGetNextRow(PVOID pvFirst, ...);
	UINT			UiGetNextResultsSet();

	PVOID			PvGetResultsBuffer();
	BOOL			FQueryComplete() { return m_fQueryIsComplete; }
	BOOL			FQuerySuccess() { return m_fQuerySucceeded; }
	VOID			CancelExecution();

	BYTE			BGetDatabaseType() { return m_bDatabaseType; }
	VOID			SetDatabaseType(BYTE bDatabaseType) { m_bDatabaseType = bDatabaseType; }
	UINT			UiGetAPIReturnCode() { return m_uiAPIReturnCode; }

	VOID			SetUserData(PVOID pv);

	VOID			CleanupCallback();

	BOOL			FIsReentrantCall() { return m_fReentrantCallbackCall; }

	INT				IGetNumberOfRowsProcessed(INT iResultsSet) { return m_iRowNum[iResultsSet]; }
	INT				IGetNumberOfResultsSetsProcessed() { return m_iResultsNum + 1; }

	VOID			SetBufferResultsSets(LONG lMaxRowsToBuffer);

	UINT 			UiAddRowToBuffer();
	UINT			UiWaitUntilDone(DWORD dwTimeout);

	VOID			SetAPIReturnCode(UINT uiRet) { m_uiAPIReturnCode = uiRet; }
	VOID			SetRetryOnDBFail() { m_fRetryOnFail = TRUE; }
	VOID			SetPartitionInfo(DWORD dwPartitionType, PVOID pvData) { m_dwPartitionType = dwPartitionType;
																			m_pvPartitionBasis = pvData; }
	DWORD			DwGetPartitionType() { return m_dwPartitionType; }
	PVOID			PvGetPartitionBasis() { return m_pvPartitionBasis; }


	static BOOL 	FInit();
	static VOID		Terminate();
	static BOOL		FQueryCompletePv(PVOID pv);

protected:
	CDBQuery(BYTE bDatabaseType, CHAR *szStoredProcedureName);
	~CDBQuery();

private:

	UINT			UiDoDatabaseQuery(DBPROCESS *dbproc);

	CDBConnection*		m_pdbconnection;
	DBPROCESS*			m_dbproc;

	RETCODE				m_retcodeLastDbresultsReturn;
	STATUS				m_statusLastDbnextrowReturn;

	BOOL				m_fReentrantCallbackCall;
	BOOL				m_fRetryOnFail;
	CHAR				m_szStoredProcedureName[AC_DB_OBJECT_NAME_SIZE];

	BOOL				m_fQueryIsComplete;
	BOOL				m_fQuerySucceeded;
	BOOL				m_fQueryCanceled;
	BOOL				m_fBufferResultsSets;
	LONG				m_lMaxRowsToBuffer;
	LONG				m_cbBytesInBuffer;
	ULONG				m_cRefCount;
	BYTE				m_bDatabaseType;
	BYTE				m_bNumberOfParams;
	BYTE				m_bNumberOfReturnParams;
	BYTE				m_bNumberOfResultsSets;
	INT					m_iRetStatus;
	INT					m_iResultsNum;
	INT					m_iRowNum[AC_MAX_NUMBER_RESULTS_SETS];
	UINT				m_uiAPIReturnCode;
	PVOID				m_pvUserData;
	PVOID				m_pvBufferedResultsSets;
	PBYTE				m_pbCurrentBufferOffset;
	PFNPROCESSROWCALLBACK	m_pfnProcessRowCallback;
	CRITICAL_SECTION	m_csCallbackCS;
	DWORD				m_dwPartitionType;
	PVOID				m_pvPartitionBasis;
	DBPARAM				m_dbparam[AC_MAX_NUMBER_DBPARAMS];
	DBRESULTINFO		m_dbresinfo[AC_MAX_NUMBER_RESULTS_SETS];	
	BYTE				m_bResultsSetRowBuffer[AC_RESULTS_ROW_BUFFER_WIDTH];

	static BOOL				fUseSuppliedDataLen[256];
	static DWORD			dwSqlBindValues[256];
	static DWORD			dwSqlDataLen[256];
	static CPool			*ppoolQuery;
	static BOOL				fTerminateCalled;
};

#define ACDB_CONTINUE	0
#define ACDB_CANCEL		1
#define ACDB_RESUBMIT	2
#define ACDB_CLEANUP	0xFFFFFFFF

#endif // #if !defined(__DBSQLQRY_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\dbsqlcon.h ===
/*--------------------------------------------------------------------------
    dbsqlcon.h
        
		Connection management class.

    Copyright (C) 1995 Microsoft Corporation
    All rights reserved.

    Authors:	Keith Birney (keithbi)

    History:	10/13/95	keithbi		Created
  --------------------------------------------------------------------------*/


#if !defined(__DBSQLCON_H__)
#define __DBSQLCON_H__


#define DBNTWIN32
#pragma warning (disable:4121)
#include <sqlfront.h>
#pragma warning (default:4121)
#include <sqldb.h>

// ThIS_FILE is defined in source files 
// #if defined(DEBUG) && defined(INLINE)
// #undef THIS_FILE
// static char BASED_CODE DBSQLCON_H[] = "dbsqlcon.h";
// #define THIS_FILE DBSQLCON_H
// #endif

#include <cpool.h>
#include <dbsqltyp.h>
#define	MAX_CONNECT_SEMAPHORES 4096

// partition basis types
#define ACPB_NOT_PARTITIONED	0
#define ACPB_HACCT				1
#define ACPB_LOGIN_NAME			2

#define MAX_SERVER_NAME_LENGTH			45
#define MAX_DB_NAME_LENGTH				64
#define AC_MAX_DB_NAME_LENGTH			MAX_DB_NAME_LENGTH
#define AC_MAX_DB_LOGIN_NAME_LENGTH		64
#define AC_MAX_DB_PASSWORD_LENGTH		16
#define AC_MAX_NUMBER_DATABASE_TYPES	4096

class CDBConnection;

extern "C"
{
CDBConnection DbSqlDLL *PdbconnectionNew(CDBQuery *pdbquery);
CDBConnection DbSqlDLL *PdbconnectionNewObsolete(CDBQuery *pdbquery, LONG lDatabaseType, DWORD dwPartitionType, PVOID pvPartitionBasis);
VOID DbSqlDLL ReleaseSystemRef(DBPROCESS *dbproc);
VOID DbSqlDLL ReleaseAllConnections();
VOID DbSqlDLL PerformDatabaseQueryThread(CDBConnection *pdbconnection);
BOOL DbSqlDLL FSetMaxConnectionNum(long lMaxNum);
BOOL DbSqlDLL FSetDBConfigServer(LPTSTR lpszDBMapServer);
BOOL DbSqlDLL FRegisterDBSource(const LONG lType, const WORD wLocatorId, const LPSTR lpszServerName, 
					   const LPSTR lpszDBName, const LPSTR lpszLoginName, const LPSTR lpszPassWord);
//BOOL DbSqlDLL FRegisterDBSourceEx(LPSTR lpszDBSource);
}

class CDBConnection
{
	friend CDBConnection DbSqlDLL *PdbconnectionNew(CDBQuery *pdbquery);
	friend CDBConnection DbSqlDLL *PdbconnectionNewObsolete(CDBQuery *pdbquery, LONG lDatabaseType, DWORD dwPartitionType, PVOID pvPartitionBasis);
	friend VOID DbSqlDLL ReleaseSystemRef(DBPROCESS *dbproc);
	friend VOID DbSqlDLL ReleaseAllConnections();
//	friend VOID DbSqlDLL PerformDatabaseQueryThread(CDBConnection *pdbconnection);

public:
	void * operator new(size_t size);
	void operator	delete(void *);

	static BOOL 	FInit();
	static VOID		Terminate();

//private:
	static VOID		LockList();
	static VOID		UnlockList();
	static CDBConnection *PdbconnectionFindType(LONG lDatabaseType, WORD wLocatorId);
	static CDBConnection *PdbconnectionFindDBPROC(DBPROCESS *dbproc);
	static UINT		UiGetLocatorId(WORD wLocatorTypeId, DWORD dwPartitionType, PVOID pvPartitionBasis, WORD *pwLocatorId);
	static UINT		UiGetCachedLocator(HACCT hacct, WORD *pwLocatorId);
	static VOID		StoreLocatorInCache(HACCT hacct, WORD wLocatorId);
	static VOID		LockLocatorCache();
	static VOID		UnlockLocatorCache();
	static UINT		UiLocateSqlServer (WORD wType, WORD wLocatorId, CHAR *szServerName, CHAR *szDBName, CHAR *szUserName, CHAR *szPassword);

//public:
	static UINT		UiOpenSqlConnection(DBPROCESS **dbproc, CHAR *szServerName, CHAR *szUser, CHAR *szApp, CHAR *szPwd, CHAR *szDB);
	static UINT		UiIsValidServer(WORD wDatabaseType, WORD wLocatorId, CHAR *szServerName, BOOL *pfValid);

	static int __cdecl err_handler(DBPROCESS * dbproc, int severity, int dberr, int oserr, const char * dberrstr, const char * oserrstr);
	static int __cdecl msg_handler(DBPROCESS *dbproc, DBINT msgno, int msgstate, int severity, const char *msgtext,
		const char *srvname, const char *procname, DBUSMALLINT line);
	static 	LPTHREAD_START_ROUTINE _stdcall DBConnectionValidationThread(UINT i);
	static VOID 	ValidateDBConnections();

	VOID			AddRef();
	VOID 			Release();
	DWORD			DwGetTimeEnteredInList() { return m_dwTimeEnteredInList; }
	BOOL			FCreated() { return m_fCreated; }
	VOID			AddToConnectionsList();
	VOID			RemoveFromConnectionsList();
	VOID			Create();
//	UINT			PerformDatabaseQuery();
	VOID			ReleaseClientRef();
	DBPROCESS		*DbprocGetDBPROC() { return m_dbproc; }
	BOOL			FPingExistingDBConnection();

//private:
	DBPROCESS       *m_dbproc;
//	HANDLE          m_hThread;
//	HANDLE          m_hSemaphore;
	BOOL            m_fInUse;
	LONG            m_lDatabaseType;
	PVOID			m_pvNext;
	ULONG			m_cRefCount;
	DWORD			m_dwTimeEnteredInList;
	CDBQuery		*m_pdbquery;
	BOOL			m_fExitNow;
	BOOL			m_fCreated;
	BOOL			m_fSystemRefReleased;
	WORD			m_wLocatorId;
	CHAR			m_szServer[MAX_SERVER_NAME_LENGTH + 1];

	static CPool			*ppoolConnection;
	static WORD				wLocatorTypeId[MAX_CONNECT_SEMAPHORES];
	static HANDLE			hDBConnectionValidationThread;
	static DWORD			dwDBConnectionValidationThreadID;
	static long				lMaxInUseDBConnections;
	static BOOL				fTerminateCalled;
	static HANDLE  			hDBConnectSemaphore[MAX_CONNECT_SEMAPHORES];
	static CRITICAL_SECTION	csConnectionsList;
	static CRITICAL_SECTION	csLocatorCache;
	static CDBConnection 	*pdbconnectionHead;
	static BOOL				fReportPerformance;
	static DWORD			dwNumWaitingThreads;
	static DWORD			dwSecondsSinceStartup;
	static CHAR				szDBMapSetByComannd[MAX_SERVER_NAME_LENGTH + 1];


	CDBConnection(CDBQuery *pdbquery, LONG lDatabaseType, WORD wLocatorId);
	~CDBConnection();
	
protected:

private:

};


class DBMapEntry
{
public:
	LONG	m_lType;
	WORD	m_wLocatorId;
	CHAR	m_szServerName[MAX_SERVER_NAME_LENGTH + 1];
	CHAR	m_szDBName[MAX_DB_NAME_LENGTH + 1];
	CHAR	m_szLoginName[AC_MAX_DB_LOGIN_NAME_LENGTH + 1];
	CHAR	m_szPassWord[AC_MAX_DB_PASSWORD_LENGTH +1];

	//void* operator new(size_t size);
	//void  operator delete(void *pvMem);

	DBMapEntry(){}
	DBMapEntry(const LONG, const WORD, const LPSTR, const LPSTR, const LPSTR, const LPSTR);
	~DBMapEntry(){}

	INT		NGetEntry(LPSTR lpszServerName, LPSTR lpszDBName,
						LPSTR lpszLoginName, LPSTR lpszPassWord);

};

#endif // #if !defined(__DBSQLCON_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\dbsqldef.h ===
/****************************************************************************************
 * NAME:        DBSQLDEF.H
 * MODULE:      DBSQLLIB/DBSQLDLL
 * AUTHOR:      keithbi
 *
 * HISTORY
 *      12/22/95	keithbi		Created
 *		05/07/96	DanielLi	Added account status and types 
 *
 * OVERVIEW
 *
 *
 ****************************************************************************************/

#ifndef DBSQLDEF_H
#define DBSQLDEF_H

/*
#define DBNTWIN32
#pragma warning (disable:4121)
#include <sqlfront.h>
#pragma warning (default:4121)
#include <sqldb.h>
*/

// errors
#define AC_SUCCESS								0
#define AC_VALID_ACCOUNT                        0
#define AC_DB_FAILED                            1
#define AC_ACCOUNT_NOT_FOUND					2
#define AC_INVALID_PASSWORD                     3
#define AC_BAD_PARAM                            4
#define AC_SEM_FAILED                           5
#define AC_CONNECT_FAILED                       6
#define AC_MUTEX_FAILED                         7
#define AC_MISSING_DATA                         8
#define AC_ILLEGAL_PASSWORD                     9
#define AC_INVALID_ACCOUNT                      10
#define AC_NOMORE_CONNECTIONS					11
#define AC_NEW_ACCOUNT                          12
#define AC_LOCKED_ACCOUNT                       13
#define AC_ILLEGAL_NAME                         14
#define AC_OUT_OF_MEMORY                        15
#define AC_TOO_MANY_ROWS                        16
#define AC_BANNED_PERSON                        17
#define AC_GROUP_NOT_FOUND                      18
#define AC_UPDATE_FAILED                        19
#define AC_DELETE_FAILED                        20
#define AC_TOKEN_NOT_FOUND                      21
#define AC_ALREADY_CONNECTED					22
#define AC_ACCESS_DENIED                        23
#define AC_OWNER_NOT_FOUND						24
#define AC_OWNER_UPDATE_FAILED					25
#define AC_ILLEGAL_LOGIN_NAME					26
#define AC_ILLEGAL_PASSWORD_SIMILAR				27
#define AC_ILLEGAL_PASSWORD_CHARS				28
#define AC_DUPLICATE_LOGIN_NAME					29
#define AC_INVALID_SUB_PLAN						30
#define AC_INVALID_PAYMENT_METHOD				31
#define AC_DUPLICATE_ENTRY						32
#define AC_TIMED_OUT							33
#define AC_THROTTLED							34
#define AC_OLDSYSTEM							35
#define AC_SBS									36
#define AC_NO_FREE_TRIAL_PERIOD					37
#define AC_CANCELLED							38
#define AC_RESUBMIT								39
#define AC_NOT_FOUND							40
#define AC_CYCLIC_DISTLIST						41
#define AC_BP_DEFEND_ERROR						42
#define AC_NO_MORE_RESULTS						43
#define AC_NO_MORE_ROWS							44
#define AC_INVALID_DOMAIN_NAME					45
#define AC_NAME_NOT_UNIQUE                      46


#define AC_BAD_HANDLE                           0xFFFFFFFF

// database types (used by ServerMap)

#define DT_CLIENT										1
#define DT_LOGINQUERY									2
#define DT_ADDRESSBOOKQUERY								3
/*
#define DT_SECURITYMASTER								4
*/
#define DT_CSQUERY										5
#define DT_ACCTMASTER									6
#define DT_ACCTQUERY									7
/*
#define DT_SECURITYQUERY								8
*/
#define DT_ADDRESSBOOKMASTER							9
#define DT_ONLSTMT										10
#define DT_CSWISSUE										12
#define typeConfLoc										13
#define DT_GUESTLISTMASTER								14
#define DT_ADDRBOOK20QUERY								15
#define DT_ADDRBOOK20MASTER								16
#define DT_LOCATORMASTER								17
#define DT_LOCATORQUERY									18
#define DT_EFORM										255
#define ACCTDB_APPID									1


// database states

#define DS_ACTIVE_NOT_IN_USE							0
#define DS_ACTIVE										1
#define DS_DRAINING										2
#define DS_INACTIVE										3

//
// account types
//
#define AC_ENDUSER										1
#define AC_CORPORATE									2
#define AC_IP											3
#define AC_SICILY_ICP									4
#define AC_PROXY										5
#define AC_INTERNET										8

//
// account status values
//
#define AS_NEW											1
#define AS_CURRENT										2
#define AS_EXPIRED										3
#define AS_LOCKED										4

//
// defs for security tables
//
#define AC_MAX_LOGIN_NAME_LENGTH                		64
#define AC_MIN_LOGIN_NAME_LENGTH						1
#define AC_MAX_DOMAIN_NAME_LENGTH               		64
#define AC_MIN_DOMAIN_NAME_LENGTH						1
#define AC_MAX_FIRST_NAME_LENGTH                		45
#define AC_MAX_LAST_NAME_LENGTH                 		45
#define AC_MAX_GROUP_NAME_LENGTH                		64
#define AC_MAX_TOKEN_NAME_LENGTH                		20
#define AC_MAX_TOKEN_DESC_LENGTH                		64
#define AC_MAX_PASSWORD_LENGTH							16
#define AC_MIN_PASSWORD_LENGTH							1

#endif // DBSQLDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\densso.h ===
/*
**	SSOBASE.H
**	Sean P. Nolan
**	
**	Simple MSN SSS Object Framework
*/

#ifndef _SSOBASE_H_
#define _SSOBASE_H_

#include <denwcs.h>
#include <denali.h>

/*--------------------------------------------------------------------------+
|	Types																	|
+--------------------------------------------------------------------------*/

typedef struct _SsoSupportStuff
	{
	LONG			lUser;
	IUnknown		*punk;
	OLECHAR			*wszMethodName;
	}
	SSSTUFF;

typedef HRESULT (*PFNSSOMETHOD)(WORD, DISPPARAMS *, VARIANT *, SSSTUFF *pssstuff);

typedef struct _SSOMethod
	{
	OLECHAR			*wszName;
	PFNSSOMETHOD	pfn;
	int				iMethod;
	}
	SSOMETHOD;

/*--------------------------------------------------------------------------+
|	Globals !!! Provided by the SSO !!!										|
+--------------------------------------------------------------------------*/

extern PFNSSOMETHOD g_pfnssoDynamic;
extern SSOMETHOD g_rgssomethod[];
extern LPSTR g_szSSOProgID;
extern GUID g_clsidSSO;
extern BOOL g_fPersistentSSO;

/*--------------------------------------------------------------------------+
|	Globals Provided by the Framework										|
+--------------------------------------------------------------------------*/

extern HINSTANCE g_hinst;

extern OLECHAR *c_wszOnNewTemplate;
extern OLECHAR *c_wszOnFreeTemplate;

/*--------------------------------------------------------------------------+
|	Routines Provided by the Framework										|
+--------------------------------------------------------------------------*/

extern HRESULT	SSOTranslateVirtualRoot(VARIANT *, IUnknown*, LPSTR, DWORD); 
extern BOOL		SSODllMain(HINSTANCE, ULONG, LPVOID);

/*--------------------------------------------------------------------------+
|	Other Data Needed by the Framework										|
+--------------------------------------------------------------------------*/

const int cTimeSamplesMax = 100;

#define SSO_OFFICIAL_NAME_PREFIX "Microsoft ActiveX Server Component" 

#endif // _SSOBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\denali.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: ASPTypeLibrary */

#ifndef _ASPTypeLibrary_H_
#define _ASPTypeLibrary_H_

DEFINE_GUID(LIBID_ASPTypeLibrary,0xD97A6DA0L,0xA85C,0x11CF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

DEFINE_GUID(IID_IStringList,0xD97A6DA0L,0xA85D,0x11CF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IStringList */
#undef INTERFACE
#define INTERFACE IStringList

DECLARE_INTERFACE_(IStringList, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IStringList methods */
    STDMETHOD(get_Item)(THIS_ VARIANT i, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* cStrRet) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IRequestDictionary,0xD97A6DA0L,0xA85F,0x11DF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IRequestDictionary */
#undef INTERFACE
#define INTERFACE IRequestDictionary

DECLARE_INTERFACE_(IRequestDictionary, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IRequestDictionary methods */
    STDMETHOD(get_Item)(THIS_ VARIANT Var, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IRequest,0xD97A6DA0L,0xA861,0x11CF,0x93,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IRequest */
#undef INTERFACE
#define INTERFACE IRequest

DECLARE_INTERFACE_(IRequest, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IRequest methods */
    STDMETHOD(get_Item)(THIS_ BSTR bstrVar, IDispatch * FAR* ppObjReturn) PURE;
    STDMETHOD(get_QueryString)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Form)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Body)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_ServerVariables)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_ClientCertificate)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Cookies)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
};

DEFINE_GUID(CLSID_Request,0x920C25D0L,0x25D9,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Request;
#endif

DEFINE_GUID(IID_IReadCookie,0x71EAF260L,0x0CE0,0x11D0,0xA5,0x3E,0x00,0xA0,0xC9,0x0C,0x20,0x91);

/* Definition of interface: IReadCookie */
#undef INTERFACE
#define INTERFACE IReadCookie

DECLARE_INTERFACE_(IReadCookie, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IReadCookie methods */
    STDMETHOD(get_Item)(THIS_ VARIANT Var, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get_HasKeys)(THIS_ VARIANT_BOOL FAR* pfHasKeys) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IWriteCookie,0xD97A6DA0L,0xA862,0x11CF,0x84,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IWriteCookie */
#undef INTERFACE
#define INTERFACE IWriteCookie

DECLARE_INTERFACE_(IWriteCookie, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IWriteCookie methods */
    STDMETHOD(put_Item)(THIS_ VARIANT key, BSTR bstrValue) PURE;
    STDMETHOD(put_Expires)(THIS_ DATE dtExpires) PURE;
    STDMETHOD(put_Domain)(THIS_ BSTR bstrDomain) PURE;
    STDMETHOD(put_Path)(THIS_ BSTR bstrPath) PURE;
    STDMETHOD(put_Secure)(THIS_ VARIANT_BOOL fSecure) PURE;
    STDMETHOD(get_HasKeys)(THIS_ VARIANT_BOOL FAR* pfHasKeys) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IResponse,0xD97A6DA0L,0xA864,0x11CF,0x83,0xBE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IResponse */
#undef INTERFACE
#define INTERFACE IResponse

DECLARE_INTERFACE_(IResponse, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IResponse methods */
    STDMETHOD(get_Buffer)(THIS_ VARIANT_BOOL FAR* fIsBuffering) PURE;
    STDMETHOD(put_Buffer)(THIS_ VARIANT_BOOL fIsBuffering) PURE;
    STDMETHOD(get_ContentType)(THIS_ BSTR FAR* pbstrContentTypeRet) PURE;
    STDMETHOD(put_ContentType)(THIS_ BSTR bstrContentType) PURE;
    STDMETHOD(get_Expires)(THIS_ VARIANT FAR* pvarExpiresMinutesRet) PURE;
    STDMETHOD(put_Expires)(THIS_ long lExpiresMinutes) PURE;
    STDMETHOD(get_ExpiresAbsolute)(THIS_ VARIANT FAR* pvarExpiresRet) PURE;
    STDMETHOD(put_ExpiresAbsolute)(THIS_ DATE dtExpires) PURE;
    STDMETHOD(get_Cookies)(THIS_ IRequestDictionary FAR* FAR* ppCookies) PURE;
    STDMETHOD(get_Status)(THIS_ BSTR FAR* pbstrStatusRet) PURE;
    STDMETHOD(put_Status)(THIS_ BSTR bstrStatus) PURE;
    STDMETHOD(Add)(THIS_ BSTR bstrHeaderValue, BSTR bstrHeaderName) PURE;
    STDMETHOD(AddHeader)(THIS_ BSTR bstrHeaderName, BSTR bstrHeaderValue) PURE;
    STDMETHOD(AppendToLog)(THIS_ BSTR bstrLogEntry) PURE;
    STDMETHOD(BinaryWrite)(THIS_ VARIANT varInput) PURE;
    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(End)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;
    STDMETHOD(Redirect)(THIS_ BSTR bstrURL) PURE;
    STDMETHOD(Write)(THIS_ VARIANT varText) PURE;
    STDMETHOD(WriteBlock)(THIS_ short iBlockNumber) PURE;
};

DEFINE_GUID(CLSID_Response,0x46E19BA0L,0x25DD,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Response;
#endif

DEFINE_GUID(IID_ISessionObject,0xD97A6DA0L,0xA865,0x11CF,0x83,0xAF,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: ISessionObject */
#undef INTERFACE
#define INTERFACE ISessionObject

DECLARE_INTERFACE_(ISessionObject, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ISessionObject methods */
    STDMETHOD(get_SessionID)(THIS_ BSTR FAR* pbstrRet) PURE;
    STDMETHOD(get_Value)(THIS_ BSTR bstrValue, VARIANT FAR* pvar) PURE;
    STDMETHOD(put_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(putref_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(get_Timeout)(THIS_ long FAR* plvar) PURE;
    STDMETHOD(put_Timeout)(THIS_ long lvar) PURE;
    STDMETHOD(Abandon)(THIS) PURE;
};

DEFINE_GUID(CLSID_Session,0x509F8F20L,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Session;
#endif

DEFINE_GUID(IID_IApplicationObject,0xD97A6DA0L,0xA866,0x11CF,0x83,0xAE,0x10,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IApplicationObject */
#undef INTERFACE
#define INTERFACE IApplicationObject

DECLARE_INTERFACE_(IApplicationObject, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IApplicationObject methods */
    STDMETHOD(get_Value)(THIS_ BSTR bstrValue, VARIANT FAR* pvar) PURE;
    STDMETHOD(put_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(putref_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(Lock)(THIS) PURE;
    STDMETHOD(UnLock)(THIS) PURE;
};

DEFINE_GUID(CLSID_Application,0x7C3BAF00L,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Application;
#endif

DEFINE_GUID(IID_IServer,0xD97A6DA0L,0xA867,0x11CF,0x83,0xAE,0x01,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IServer */
#undef INTERFACE
#define INTERFACE IServer

DECLARE_INTERFACE_(IServer, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IServer methods */
    STDMETHOD(get_ScriptTimeout)(THIS_ long FAR* plTimeoutSeconds) PURE;
    STDMETHOD(put_ScriptTimeout)(THIS_ long lTimeoutSeconds) PURE;
    STDMETHOD(CreateObject)(THIS_ BSTR bstrProgID, IDispatch * FAR* ppDispObject) PURE;
    STDMETHOD(HTMLEncode)(THIS_ BSTR bstrIn, BSTR FAR* pbstrEncoded) PURE;
    STDMETHOD(MapPath)(THIS_ BSTR bstrLogicalPath, BSTR FAR* pbstrPhysicalPath) PURE;
    STDMETHOD(URLEncode)(THIS_ BSTR bstrIn, BSTR FAR* pbstrEncoded) PURE;
};

DEFINE_GUID(CLSID_Server,0xA506D160L,0x25E0,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Server;
#endif

DEFINE_GUID(IID_IScriptingContext,0xD97A6DA0L,0xA868,0x11CF,0x83,0xAE,0x00,0xB0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IScriptingContext */
#undef INTERFACE
#define INTERFACE IScriptingContext

DECLARE_INTERFACE_(IScriptingContext, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptingContext methods */
    STDMETHOD(get_Request)(THIS_ IRequest FAR* FAR* ppRequest) PURE;
    STDMETHOD(get_Response)(THIS_ IResponse FAR* FAR* ppResponse) PURE;
    STDMETHOD(get_Server)(THIS_ IServer FAR* FAR* ppServer) PURE;
    STDMETHOD(get_Session)(THIS_ ISessionObject FAR* FAR* ppSession) PURE;
    STDMETHOD(get_Application)(THIS_ IApplicationObject FAR* FAR* ppApplication) PURE;
};

DEFINE_GUID(CLSID_ScriptingContext,0xD97A6DA0L,0xA868,0x11CF,0x83,0xAE,0x11,0xB0,0xC9,0x0C,0x2B,0xD8);

#ifdef __cplusplus
class ScriptingContext;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\descrypt.h ===
#include <ntlmsspi.h>

#define ENCRYPT   0
#define DECRYPT   1

#ifndef DECR_KEY
#define DECR_KEY  0
#define ENCR_KEY  1
#define ENCR_STD  2
#define ENCR_SES  4
#endif

#define CRYPT_ERR 1
#define CRYPT_OK  0

unsigned FAR
DES_CBC(    unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * IV,
            unsigned char FAR * Source,
            unsigned char FAR * Dest,
            unsigned            Size);


unsigned FAR
DES_CBC_LM( unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * IV,
            unsigned char FAR * Source,
            unsigned char FAR * Dest,
            unsigned            Size);

unsigned FAR
DES_ECB(    unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * Src,
            unsigned char FAR * Dst);

unsigned FAR _cdecl
DES_ECB_LM( unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * Src,
            unsigned char FAR * Dst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\denwcs.h ===
/*
**	wcsutil.h
**	Sean P. Nolan
**	
**	server-side utils
*/

#ifndef _WCSUTIL_H_
#define _WCSUTIL_H_

#include <windows.h>
#include <ole2.h>
#include <winsock.h>
#include <httpext.h>
#include "wcguids.h"

/*--------------------------------------------------------------------------+
|	Utilities Provided by the Framework										|
+--------------------------------------------------------------------------*/

extern LPSTR g_szSSOProgID;

// Logging to application event log -- see ReportEvent() in win32 sdk
// documentation for information on wType and dwEventID.
void LogEvent(WORD wType, DWORD dwEventID, char *sz);

// Asserts
#ifdef DEBUG
extern void AssertProc(PCSTR szFile, DWORD dwLine, PCSTR szMsg, DWORD dwFlags);
#define AssertSzFlg(f, sz, dwFlag)		( (f) ? 0 : AssertProc(__FILE__, __LINE__, sz, dwFlag))
#else // !DEBUG
#define AssertSzFlg(f, sz, dwFlg)
#endif // !DEBUG

#define AP_GETLASTERROR		0x00000001

// under non-debug, AssertSzFlg is defined away, so these #defines don't
// have to be #ifdef DEBUG
#define AssertSz(f, sz)				AssertSzFlg(f, sz, 0)
#define AssertEx(f)					AssertSz((f), "!(" #f ")")
#define Assert(f)					AssertEx(f)
#define AssertSzGLE(f, sz)			AssertSzFlg(f, sz, AP_GETLASTERROR)
#define AssertExGLE(f)				AssertSzGLE((f), "!(" #f ")")

// Debug Printing
#ifdef DEBUG
int dbgprintf(PCSTR pFormat, ...);
#else
#define dbgprintf()
#endif

// Memory Mgmt
LPVOID _MsnAlloc(DWORD cb);
LPVOID _MsnRealloc(LPVOID pv, DWORD cb);
void _MsnFree(LPVOID pv);

// Data Munging
LPSTR _SzFromVariant(VARIANT *pvar);
BSTR _BstrFromVariant(VARIANT *pvar, BOOL *pfFree);
BOOL _FIntFromVariant(VARIANT *pvar, int *pi);

BSTR BstrQuoteHtml(WCHAR *wsz);
BSTR BstrQuoteForUrl(WCHAR *wsz);
void UnquoteHtml(WCHAR *wszSrc, WCHAR *rgchDst, int cchDst);

// String Manipulation / Parsing											
void _AnsiStringFromGuid(REFGUID rguid, LPSTR sz);
LPSTR _SkipWhiteSpace(LPSTR sz);
LPSTR _FindEndOfLine(LPSTR sz);
DWORD _atoi(LPSTR sz);

// URL Fiddling
int UrlType(char *szUrl);
#define URL_TYPE_ABSOLUTE		0		// e.g. http://foo/bar or just //foo.com/bar.htm
#define URL_TYPE_LOCAL_ABSOLUTE	1		// e.g. /foo/bar/baz.htm
#define URL_TYPE_RELATIVE		2		// e.g. xyzzy/plugh.html

// IIS Hacks
#ifdef _HTTPEXT_H_
BOOL _FTranslateVirtualRoot(EXTENSION_CONTROL_BLOCK *pecb, LPSTR szPathIn, 
							LPSTR szPathTranslated, DWORD cbPathTranslated);
#endif // _HTTPEXT_H_

// Critical Sections
class CCritSec
	{
	private:
		CRITICAL_SECTION	m_cs;

	public:
		CCritSec(void)		{ ::InitializeCriticalSection(&m_cs);	}
		~CCritSec(void)		{ ::DeleteCriticalSection(&m_cs);		}
		void Lock(void)		{ ::EnterCriticalSection(&m_cs);		}
		void Unlock(void)	{ ::LeaveCriticalSection(&m_cs);		}
	};

/*--------------------------------------------------------------------------+
|	CThingWatcher/CFileWatcher/CRegKeyWatcher								|
+--------------------------------------------------------------------------*/

typedef void (*PFNFILECHANGED)(LPSTR szFile, LONG lUser);
typedef void (*PFNREGKEYCHANGED)(HKEY hkey, LONG lUser);

typedef int (__stdcall *PFNCLOSEHEVTNOTIFY)(HANDLE hevtNotify);

class CThingWatcher
{
	friend DWORD ThingWatcherThread(CThingWatcher *pfw);

public:
	CThingWatcher(PFNCLOSEHEVTNOTIFY pfnCloseHevtNotify);
	~CThingWatcher();
	
	BOOL				FWatchHandle(HANDLE hevtNotify);

private:	
	virtual BOOL		FireChange(DWORD dwWait)			= 0;

	HANDLE				m_rghWait[2];
	HINSTANCE           m_hModule;
	PFNCLOSEHEVTNOTIFY	m_pfnCloseHevtNotify;
};

class CFileWatcher : public CThingWatcher
{
private:
	char			m_szPath[MAX_PATH];
	FILETIME		m_ftLastWrite;
	LONG			m_lUser;
	PFNFILECHANGED	m_pfnChanged;
	BOOL			m_fDirectory;
	HANDLE			m_hevtNotify;

public:
	CFileWatcher(void);
	~CFileWatcher(void);

	BOOL FStartWatching(LPSTR szPath, LONG lUser, PFNFILECHANGED pfnChanged); 

private:
	virtual BOOL FireChange(DWORD dwWait);
};
	
class CRegKeyWatcher : public CThingWatcher
{
public:
	CRegKeyWatcher();
	~CRegKeyWatcher();

	BOOL				FStartWatching(HKEY hkey, BOOL fSubTree, DWORD dwNotifyFilter, LONG lUser, PFNREGKEYCHANGED pfnChanged);

private:
	virtual BOOL		FireChange(DWORD dwWait);
	
	HKEY				m_hkey;
	LONG				m_lUser;
	PFNREGKEYCHANGED	m_pfnChanged;
	HANDLE				m_hevtNotify;
};

/*--------------------------------------------------------------------------+
|	CDataFile																|
+--------------------------------------------------------------------------*/

class CDataFile
	{
	friend class CDataFileGroup;
	friend void DataFileChanged(LPSTR szFile, LONG lUser);

	private:
		ULONG			m_cRef;

		CDataFile	   *m_pdfNext;
		CDataFile	   *m_pdfPrev;
		CDataFileGroup *m_pfg;

	protected:
		CCritSec		m_cs;
		char			m_szDataPath[MAX_PATH];
		CFileWatcher	m_fw;

	public:
		CDataFile(LPSTR szDataPath, CDataFileGroup *pfg);
		~CDataFile(void);

		ULONG		AddRef(void);
		ULONG		Release(void);

		BOOL		FWatchFile(PFNFILECHANGED pfnChanged = NULL);

		virtual void FreeDataFile(void) { delete this; }

	private:
		ULONG		GetRefCount(void);
		BOOL		FMatch(LPSTR szDataPath);

		CDataFile	*GetNext(void)				{ return(m_pdfNext);	}
		CDataFile	*GetPrev(void)				{ return(m_pdfPrev);	}
		void		SetNext(CDataFile *pdf)		{ m_pdfNext = pdf;		}
		void		SetPrev(CDataFile *pdf)		{ m_pdfPrev = pdf;		}
	};

/*--------------------------------------------------------------------------+
|	CDataFileGroup															|
+--------------------------------------------------------------------------*/

#define NUM_GROUP_BUCKETS (1024)

typedef struct _HashBucket
	{
	CDataFile *pdfHead;
	CDataFile *pdfTail;
	}
	HB;

class CDataFileGroup
	{
	private:
		CCritSec	m_cs;
		HB			m_rghb[NUM_GROUP_BUCKETS];
				
	public:
		CDataFileGroup(void);
		~CDataFileGroup(void);

		CDataFile  *GetDataFile(LPSTR szDataPath);
		void		ForgetDataFile(CDataFile *pdf);

		virtual CDataFile *CreateDataFile(LPSTR szDataPath) = 0;

	private:
		void		RememberDataFile(CDataFile *pdf, HB *phb = NULL);
		HB		   *GetHashBucket(LPSTR szDataPath);
	};
	
/*--------------------------------------------------------------------------+
|	CGenericHash															|
+--------------------------------------------------------------------------*/

typedef struct _HashItem
	{
	BSTR				bstrName;
	LPVOID				pvData;
	struct _HashItem	*phiNext;
	struct _HashItem	*phiPrev;
	}
	HITEM;

class CGenericHash
	{
	protected:
		DWORD		m_chi;
		HITEM		**m_rgphi;
		CCritSec	m_cs;

	public:
		CGenericHash(DWORD cBuckets);
		~CGenericHash(void);

		LPVOID PvFind(OLECHAR *wszName);

		BOOL FAdd(OLECHAR *wszName, LPVOID pv);
		void Remove(OLECHAR *wszName);
		void RemoveAll(void);

		void Lock(void)		{ m_cs.Lock(); }
		void Unlock(void)	{ m_cs.Unlock(); }

		virtual DWORD	GetHashValue(OLECHAR *wsz);
		virtual void	FreeHashData(LPVOID pv);

	private:
		HITEM	*FindItem(OLECHAR *wszName, HITEM ***ppphiHead);
		void	RemoveItem(HITEM **pphiHead, HITEM *phi);
		BOOL	FEnsureBuckets(void);
	};

/*--------------------------------------------------------------------------+
|	CResourceCollection														|
+--------------------------------------------------------------------------*/

typedef struct _resource
{
	BOOL			fInUse;
	BOOL			fValid;
	PVOID			pv;
} RS, *PRS;

typedef PRS HRS;
#define hrsNil NULL

class CResourceCollection
{
public:
	CResourceCollection();
	~CResourceCollection();
	
	BOOL			FInit(int cRsrc);
	BOOL			FTerm();
	
	HRS				HrsGetResource();
	void			ReleaseResource(BOOL fReset, HRS hrs);

	void			CleanupAll(PVOID pvNil);
	BOOL			FValid(HRS hrs);

private:
	PRS				PrsFree();
	void			WaitForRs();

	CCritSec		m_cs;
	HANDLE			m_hsem;
	
	int				m_crs;
	PRS				m_rgrs;

	virtual BOOL	FInitResource(PRS prs)		= 0;
	virtual void	CleanupResource(PRS prs)	= 0;
};

/*--------------------------------------------------------------------------+
|	CSocketCollection														|
+--------------------------------------------------------------------------*/

class CSocketCollection : public CResourceCollection
{
public:
	CSocketCollection() : CResourceCollection()		{};
	~CSocketCollection()							{};
	
	BOOL			FInit(int cRsrc, char *szServer, USHORT usPort); // usPort should be in host byte order
	BOOL			FReinit(char *szServer, USHORT usPort);
	
	SOCKET			ScFromHrs(HRS hrs);
	
private:
	char			m_szServer[MAX_PATH];
	int				m_usPort;
	SOCKADDR_IN		m_sin;

	virtual BOOL	FInitResource(PRS prs);
	virtual void	CleanupResource(PRS prs);
};

#endif // _WCSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\dnsreci.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       dnsrec.h

   Abstract:

       This file contains type definitions for async DNS

   Author:

        Rohan Phillips (Rohanp)     June-19-1998

   Revision History:

--*/

# ifndef _ADNS_STRUCT_HXX_
# define _ADNS_STRUCT_HXX_

#include <rwnew.h>
#include <dnsapi.h>

#define TCP_REG_LIST_SIGNATURE    'TgeR'
#define DNS_FLAGS_NONE              0x0
#define DNS_FLAGS_TCP_ONLY          0x1
#define DNS_FLAGS_UDP_ONLY          0x2

#define SMTP_MAX_DNS_ENTRIES	100

typedef void (WINAPI * USERDELETEFUNC) (PVOID);

//-----------------------------------------------------------------------------
//
//  Description:
//      Encapsulates a list of IP addresses (for DNS servers) and maintains
//      state information on them... whether the servers are up or down, and
//      provides retry logic for down servers.
//
//-----------------------------------------------------------------------------
class CTcpRegIpList
{

private:
    DWORD           m_dwSig;
    int             m_cUpServers;
    PIP_ARRAY	    m_IpListPtr;
    DWORD           *m_prgdwFailureTick;
    BOOL            *m_prgfServerUp;
    CShareLockNH    m_sl;
public:
    static USERDELETEFUNC	m_DeleteFunc;
    CTcpRegIpList();
    ~CTcpRegIpList();
    void Update(PIP_ARRAY IpPtr);
    DWORD GetIp(DWORD *dwIp);
    void MarkDown(DWORD dwIp);
    void ResetServersIfNeeded();
    
    DWORD GetCount()
    {
        DWORD dwCount;

        m_sl.ShareLock();
        dwCount = m_IpListPtr ? m_IpListPtr->cAddrCount : 0;
        m_sl.ShareUnlock();

        return dwCount;
    }
};

typedef struct _MXIPLISTENTRY_
{
	DWORD	IpAddress;
	LIST_ENTRY	ListEntry;
}MXIPLIST_ENTRY, *PMXIPLIST_ENTRY;

typedef struct _MX_NAMES_
{
	char DnsName[MAX_INTERNET_NAME];
	DWORD NumEntries;
	LIST_ENTRY IpListHead;
}MX_NAMES, *PMX_NAMES;

typedef struct _SMTPDNS_REC_
{
	DWORD	NumRecords;		//number of record in DnsArray
	DWORD	StartRecord;	//the starting index 
	PVOID	pMailMsgObj;	//pointer to a mailmsg obj
	PVOID	pAdvQContext;
	PVOID	pRcptIdxList;
	DWORD	dwNumRcpts;
	MX_NAMES *DnsArray[SMTP_MAX_DNS_ENTRIES];
} SMTPDNS_RECS, *PSMTPDNS_RECS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\exchmem.h ===
/*
 -	E X C H M E M . H
 -
 *	Purpose:
 *		
 *
 *	Parameters:
 *		
 *
 *	Returns:
 *		
 *
 *	Copyright (C) 1995-96, Microsoft Corporation.
 */

#ifndef _EXCHMEM_
#define _EXCHMEM_


#ifdef __cplusplus
extern "C"
{
#endif

//	Additional Heap Flags

#define HEAP_NO_FREE			0x00001000


//	API Function Prototypes

HANDLE
WINAPI
ExchHeapCreate(
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize);
	
	
BOOL
WINAPI
ExchHeapDestroy(
	HANDLE	hHeap);
	
	
LPVOID
WINAPI
ExchHeapAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	DWORD	dwSize);
	
	
LPVOID
WINAPI
ExchHeapReAlloc(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvOld,
	DWORD	dwSize);
	
	
BOOL
WINAPI
ExchHeapFree(
	HANDLE	hHeap,
	DWORD	dwFlags,
	LPVOID	pvFree);


BOOL
WINAPI
ExchHeapLock(
	HANDLE hHeap);


BOOL
WINAPI
ExchHeapUnlock(
	HANDLE hHeap);


BOOL
WINAPI
ExchHeapWalk(
	HANDLE hHeap,
	LPPROCESS_HEAP_ENTRY lpEntry);


BOOL
WINAPI
ExchHeapValidate(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem);


SIZE_T
WINAPI
ExchHeapSize(
	HANDLE hHeap,
	DWORD dwFlags,
	LPCVOID lpMem);


SIZE_T
WINAPI
ExchHeapCompact(
	HANDLE hHeap,
	DWORD dwFlags);


HANDLE
WINAPI
ExchMHeapCreate(
	ULONG	cHeaps,
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize);
	
	
BOOL
WINAPI
ExchMHeapDestroy(void);
	
	
LPVOID
WINAPI
ExchMHeapAlloc(
	DWORD	dwSize);
	
LPVOID
WINAPI
ExchMHeapAllocDebug(DWORD dwSize, char *szFileName, DWORD dwLineNumber);

LPVOID
WINAPI
ExchMHeapReAlloc(LPVOID	pvOld, DWORD dwSize);

LPVOID
WINAPI
ExchMHeapReAllocDebug(LPVOID pvOld, DWORD dwSize, char *szFileName, DWORD dwLineNumber);

BOOL
WINAPI
ExchMHeapFree(
	LPVOID	pvFree);


SIZE_T
WINAPI
ExchMHeapSize(
	LPVOID	pvSize);
	
LPVOID
WINAPI
ExchAlloc(
	DWORD	dwSize);
	
	
LPVOID
WINAPI
ExchReAlloc(
	LPVOID	pvOld,
	DWORD	dwSize);
	
	
BOOL
WINAPI
ExchFree(
	LPVOID	pvFree);


SIZE_T
WINAPI
ExchSize(
	LPVOID	pv);


//
//	Misc. Debug functions.  Available in retail and debug exchmem, but retail version is simply a stub..
//
   
VOID
WINAPI
ExchmemGetCallStack(DWORD_PTR *rgdwCaller, DWORD cFind);

VOID
WINAPI
ExchmemFormatSymbol(HANDLE hProcess, DWORD_PTR dwCaller, char rgchSymbol[], DWORD cbSymbol);

DWORD
WINAPI
ExchmemReloadSymbols(void);

#ifdef __cplusplus
}
#endif

#endif	// _EXCHMEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\esh.h ===
// esh.h: interface for the CEventScriptHandler class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EVENTSCRIPTHANLDER_H__300C7F54_FE1E_11D0_A776_00C04FC2F5B3__INCLUDED_)
#define AFX_EVENTSCRIPTHANLDER_H__300C7F54_FE1E_11D0_A776_00C04FC2F5B3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


//
// CEventScriptHandler - Use or derive from this class to create a script
// handler for a specific sink.
//
// Usage: Use SetScript to pass the script to the script handler. You can
// make global variables available to your script by calling AddGlobalVariable.
// Use AddConnectionPoint to bind to specific functions within the script.
// Name the connection point Hello and the script parse will look for Hello_xxx
// functions and attempt to connect to them. Once you have set the script and
// any other options, you can call StartScript to cause the script to be loaded,
// parsed and intialized. Any global code in the script will be executed at this
// time. Use ExecuteConnectionPoint to cause a specific function to be executed.
//

class CEventScriptHandler  
{
public:
	CEventScriptHandler();
	virtual ~CEventScriptHandler();

	// set the script to be executed
	STDMETHOD(SetScript)(IStream* pstmScript);
	STDMETHOD(SetScript)(BSTR bstrFileName);
	// sets the maximum execution time for the script
	STDMETHOD(MaxExecutionTime)(DWORD dwMaxExecutionTime);
	// tells the script engine whether to allow CreateObject calls
	STDMETHOD(AllowCreateObject)(BOOL fCreateObjectAllowed);
	// tells the script parser that the script uses ASPSyntax
	STDMETHOD(ASPSyntax)(BOOL fIsASPSyntax);
	// adds a connnection point
	STDMETHOD(AddConnectionPoint)(BSTR bstrName, IConnectionPointContainer* pContainer);
	// adds a global variable
	STDMETHOD(AddGlobalVariable)(BSTR bstrName, VARIANT varVariable);

	// Initializes the script engine, parses the scripts and resolves
	// all connection points. Requires that SetScript be called first.
	// Above functions must be called before StartScript for them to 
	// affect script execution.
	STDMETHOD(StartScript)(void);
	// stops the script
	STDMETHOD(StopScript)(void);
	// stops and starts the script
	STDMETHOD(RestartScript)(void);
	// causes a specific script function to be executed
	STDMETHOD(ExecuteConnectionPoint)(IConnectionPoint* pConnectionPoint, DISPID dispid);

protected:
	VARIANT m_varScriptResponse;
	VARIANT m_varErrorResponse;
	IScripto* m_pScripto;
	ULONG m_cNamedProps;
	IPropertyBag* m_pBag;
private:
	BOOL m_fScriptStopped;
};

#endif // !defined(AFX_EVENTSCRIPTHANLDER_H__300C7F54_FE1E_11D0_A776_00C04FC2F5B3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\dns.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dns.h

Abstract:

    Domain Name System (DNS)

    General DNS definitions.

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

--*/


#ifndef _DNS_INCLUDED_
#define _DNS_INCLUDED_


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus



//
//  Basic DNS API definitions
//
//  These are basic definitions used by both DnsAPI and DNS server RPC interface.
//  Since dnsapi.h is not setup for a midl compile, dns.h servers as a common
//  header point with simple definitions used by both.

//
//  Use stdcall for our API conventions
//
//  Explicitly state this as C++ compiler will otherwise
//      assume cdecl.
//

#define DNS_API_FUNCTION    __stdcall

//
//  DNS public types
//

typedef LONG    DNS_STATUS, *PDNS_STATUS;
typedef DWORD   DNS_HANDLE, *PDNS_HANDLE;
typedef DWORD   DNS_APIOP;


//
//  IP Address
//

typedef DWORD   IP_ADDRESS, *PIP_ADDRESS;

#define SIZEOF_IP_ADDRESS            (4)
#define IP_ADDRESS_STRING_LENGTH    (15)

#define IP_STRING( ipAddress )  inet_ntoa( *(struct in_addr *)&(ipAddress) )


//
//  IP Address Array type
//

#if defined(MIDL_PASS)
typedef struct  _IP_ARRAY
{
    DWORD   cAddrCount;
    [size_is( cAddrCount )]  IP_ADDRESS  aipAddrs[];
}
IP_ARRAY, *PIP_ARRAY;

#else

typedef struct  _IP_ARRAY
{
    DWORD       cAddrCount;
    IP_ADDRESS  aipAddrs[1];
}
IP_ARRAY, *PIP_ARRAY;

#endif


//
//  IPv6 Address
//

typedef struct
{
    WORD    IPv6Word[8];
}
IPV6_ADDRESS, *PIPV6_ADDRESS;

#define IPV6_ADDRESS_STRING_LENGTH  (39)


//
//  DNS dotted name
//      - define type simply to clarify arguments
//

#ifdef UNICODE
typedef LPWSTR  DNS_NAME;
#else
typedef LPSTR   DNS_NAME;
#endif

//
//  DNS Text strings
//

#ifdef UNICODE
typedef LPWSTR  DNS_TEXT;
#else
typedef LPSTR   DNS_TEXT;
#endif


//
//  Byte flipping macros
//

#define FlipUnalignedDword( pDword ) \
            (DWORD)ntohl( *(UNALIGNED DWORD *)(pDword) )

#define FlipUnalignedWord( pWord )  \
            (WORD)ntohs( *(UNALIGNED WORD *)(pWord) )

//  Inline is faster, but NO side effects allowed in marco argument

#define InlineFlipUnaligned48Bits( pch )            \
            ( ( *(PUCHAR)(pch)        << 40 ) |     \
              ( *((PUCHAR)(pch) + 1)  << 32 ) |     \
              ( *((PUCHAR)(pch) + 2)  << 24 ) |     \
              ( *((PUCHAR)(pch) + 3)  << 16 ) |     \
              ( *((PUCHAR)(pch) + 4)  <<  8 ) |     \
              ( *((PUCHAR)(pch) + 5)  )     )

#define InlineFlipUnalignedDword( pch )             \
            ( ( *(PUCHAR)(pch)        << 24 ) |     \
              ( *((PUCHAR)(pch) + 1)  << 16 ) |     \
              ( *((PUCHAR)(pch) + 2)  <<  8 ) |     \
              ( *((PUCHAR)(pch) + 3)  )     )

#define InlineFlipUnalignedWord( pch )  \
            ( ((WORD)*((PUCHAR)(pch)) << 8) + (WORD)*((PUCHAR)(pch) + 1) )


//
//  Inline byte flipping -- can be done in registers
//

#define INLINE_WORD_FLIP(out, in)   \
        {                           \
            WORD _in = (in);        \
            (out) = (_in << 8) | (_in >> 8);  \
        }
#define INLINE_HTONS(out, in)   INLINE_WORD_FLIP(out, in)
#define INLINE_NTOHS(out, in)   INLINE_WORD_FLIP(out, in)

#define INLINE_DWORD_FLIP(out, in)  \
        {                           \
            DWORD _in = (in);       \
            (out) = ((_in << 8) & 0x00ff0000) | \
                    (_in << 24)               | \
                    ((_in >> 8) & 0x0000ff00) | \
                    (_in >> 24);                \
        }
#define INLINE_NTOHL(out, in) INLINE_DWORD_FLIP(out, in)
#define INLINE_HTONL(out, in) INLINE_DWORD_FLIP(out, in)


//
//  Inline byte flip and write to packet (unaligned)
//

#define INLINE_WRITE_FLIPPED_WORD( pout, in ) \
            INLINE_WORD_FLIP( *((UNALIGNED WORD *)(pout)), in )

#define INLINE_WRITE_FLIPPED_DWORD( pout, in ) \
            INLINE_DWORD_FLIP( *((UNALIGNED DWORD *)(pout)), in )

//
//  Unaligned write without flipping
//

#define WRITE_UNALIGNED_WORD( pout, word ) \
            ( *(UNALIGNED WORD *)(pout) = word )

#define WRITE_UNALIGNED_DWORD( pout, dword ) \
            ( *(UNALIGNED DWORD *)(pout) = dword )




//
//  Basic DNS definitions
//

//
//  DNS port for both UDP and TCP is 53.
//

#define DNS_PORT_HOST_ORDER (0x0035)    // port 53
#define DNS_PORT_NET_ORDER  (0x3500)

#define HOST_ORDER_DNS_PORT DNS_PORT_HOST_ORDER
#define NET_ORDER_DNS_PORT  DNS_PORT_NET_ORDER

//
//  DNS UDP packets no more than 512 bytes
//

#define DNS_RFC_MAX_UDP_PACKET_LENGTH (512)

//  these are going away DO NOT USE!!!
//  1472 is the maximum ethernet IP\UDP payload size
//  without causing fragmentation

#define DNS_UDP_MAX_PACKET_LENGTH               (512)
#define DNS_CLASSICAL_UDP_MAX_PACKET_LENGTH     (512)


//
//  DNS Names limited to 255, 63 in any one label
//

#define DNS_MAX_NAME_LENGTH         (255)
#define DNS_MAX_LABEL_LENGTH        (63)
#define DNS_LABEL_CASE_BYTE_COUNT   (8)

#define DNS_MAX_NAME_BUFFER_LENGTH  (256)
#define DNS_NAME_BUFFER_LENGTH      (256)
#define DNS_LABEL_BUFFER_LENGTH     (64)

//
//  Reverse lookup domain names
//

#define DNS_REVERSE_DOMAIN_STRING ("in-addr.arpa.")

#define DNS_MAX_REVERSE_NAME_LENGTH \
            (IP_ADDRESS_STRING_LENGTH+1+sizeof(DNS_REVERSE_DOMAIN_STRING))

#define DNS_MAX_REVERSE_NAME_BUFFER_LENGTH \
            (DNS_MAX_REVERSE_NAME_LENGTH + 1)


//
//  DNS Text string limited by size representable
//      in a single byte length field

#define DNS_MAX_TEXT_STRING_LENGTH  (255)




//
//  DNS On-The-Wire Structures
//

#include <packon.h>

//
//  DNS Message Header
//

typedef struct _DNS_HEADER
{
    WORD    Xid;

    BYTE    RecursionDesired : 1;
    BYTE    Truncation : 1;
    BYTE    Authoritative : 1;
    BYTE    Opcode : 4;
    BYTE    IsResponse : 1;

    BYTE    ResponseCode : 4;
    BYTE    Broadcast : 1;              // part of DNS reserved, use in WINS
    BYTE    Reserved : 2;
    BYTE    RecursionAvailable : 1;

    WORD    QuestionCount;
    WORD    AnswerCount;
    WORD    NameServerCount;
    WORD    AdditionalCount;
}
DNS_HEADER, *PDNS_HEADER;

//  Question immediately follows header so compressed question name
//      0xC000 | sizeof(DNS_HEADER)

#define DNS_COMPRESSED_QUESTION_NAME  (0xC00C)


//
//  Flags as WORD
//

#define DNS_HEADER_FLAGS(pHead)     ( *((PWORD)(pHead)+1) )


//
//  Swap count bytes
//  Include XID since our XID partitioning will be in host order.
//

#define SWAP_COUNT_BYTES(header)    \
        {                           \
            PDNS_HEADER _head = (header); \
            INLINE_HTONS(_head->Xid,            _head->Xid             ); \
            INLINE_HTONS(_head->QuestionCount,  _head->QuestionCount   ); \
            INLINE_HTONS(_head->AnswerCount,    _head->AnswerCount     ); \
            INLINE_HTONS(_head->NameServerCount,_head->NameServerCount ); \
            INLINE_HTONS(_head->AdditionalCount,_head->AdditionalCount ); \
        }

//
//  Question name follows header
//

#define DNS_OFFSET_TO_QUESTION_NAME     sizeof(DNS_HEADER)


//
//  Packet extraction macros
//

#define QUESTION_NAME_FROM_HEADER( _header_ ) \
            ( (PCHAR)( (PDNS_HEADER)(_header_) + 1 ) )

#define ANSWER_FROM_QUESTION( _question_ ) \
            ( (PCHAR)( (PDNS_QUESTION)(_question_) + 1 ) )


//
//  DNS Question
//

typedef struct _DNS_QUESTION
{
    //  Always preceeded by question name.

    WORD    QuestionType;
    WORD    QuestionClass;

} DNS_QUESTION, *PDNS_QUESTION;


//
//  DNS Resource Record
//

typedef struct _DNS_WIRE_RECORD
{
    //  Always preceded by an owner name.

    WORD    RecordType;
    WORD    RecordClass;
    DWORD   TimeToLive;
    WORD    ResourceDataLength;

    //  Followed by resource data.

} DNS_WIRE_RECORD, *PDNS_WIRE_RECORD;

#include <packoff.h>


//
//  DNS Query Types
//

#define DNS_OPCODE_QUERY            0  // Query
#define DNS_OPCODE_IQUERY           1  // Obsolete: IP to name
#define DNS_OPCODE_SERVER_STATUS    2  // Obsolete: DNS ping
#define DNS_OPCODE_UNKNOWN          3  // Unknown
#define DNS_OPCODE_NOTIFY           4  // Notify
#define DNS_OPCODE_UPDATE           5  // Update

//
//  DNS response codes.
//
//  Sent in the "ResponseCode" field of a DNS_HEADER.
//

#define DNS_RCODE_NOERROR       0
#define DNS_RCODE_FORMERR       1
#define DNS_RCODE_SERVFAIL      2
#define DNS_RCODE_NXDOMAIN      3
#define DNS_RCODE_NOTIMPL       4
#define DNS_RCODE_REFUSED       5
#define DNS_RCODE_YXDOMAIN      6
#define DNS_RCODE_YXRRSET       7
#define DNS_RCODE_NXRRSET       8
#define DNS_RCODE_NOTAUTH       9
#define DNS_RCODE_NOTZONE       10
#define DNS_RCODE_MAX           15

#define DNS_RCODE_BADSIG        16
#define DNS_RCODE_BADKEY        17
#define DNS_RCODE_BADTIME       18

#define DNS_EXTRCODE_BADSIG         DNS_RCODE_BADSIG
#define DNS_EXTRCODE_BADKEY         DNS_RCODE_BADKEY
#define DNS_EXTRCODE_BADTIME        DNS_RCODE_BADTIME

#define DNS_RCODE_NO_ERROR          DNS_RCODE_NOERROR
#define DNS_RCODE_FORMAT_ERROR      DNS_RCODE_FORMERR
#define DNS_RCODE_SERVER_FAILURE    DNS_RCODE_SERVFAIL
#define DNS_RCODE_NAME_ERROR        DNS_RCODE_NXDOMAIN
#define DNS_RCODE_NOT_IMPLEMENTED   DNS_RCODE_NOTIMPL


//
//  DNS Classes
//
//  Classes are on the wire as WORDs.
//
//  _CLASS_ defines in host order.
//  _RCLASS_ defines in net byte order.
//
//  Generally we'll avoid byte flip and test class in net byte order.
//

#define DNS_CLASS_INTERNET  0x0001      //  1
#define DNS_CLASS_CSNET     0x0002      //  2
#define DNS_CLASS_CHAOS     0x0003      //  3
#define DNS_CLASS_HESIOD    0x0004      //  4
#define DNS_CLASS_NONE      0x00fe      //  254
#define DNS_CLASS_ALL       0x00ff      //  255
#define DNS_CLASS_ANY       0x00ff      //  255

#define DNS_RCLASS_INTERNET 0x0100      //  1
#define DNS_RCLASS_CSNET    0x0200      //  2
#define DNS_RCLASS_CHAOS    0x0300      //  3
#define DNS_RCLASS_HESIOD   0x0400      //  4
#define DNS_RCLASS_NONE     0xfe00      //  254
#define DNS_RCLASS_ALL      0xff00      //  255
#define DNS_RCLASS_ANY      0xff00      //  255



//
//  DNS Record Types
//
//  _TYPE_ defines are in host byte order.
//  _RTYPE_ defines are in net byte order.
//
//  Generally always deal with types in host byte order as we index
//  resource record functions by type.
//

#define DNS_TYPE_ZERO       0x0000

//  RFC 1034/1035
#define DNS_TYPE_A          0x0001      //  1
#define DNS_TYPE_NS         0x0002      //  2
#define DNS_TYPE_MD         0x0003      //  3
#define DNS_TYPE_MF         0x0004      //  4
#define DNS_TYPE_CNAME      0x0005      //  5
#define DNS_TYPE_SOA        0x0006      //  6
#define DNS_TYPE_MB         0x0007      //  7
#define DNS_TYPE_MG         0x0008      //  8
#define DNS_TYPE_MR         0x0009      //  9
#define DNS_TYPE_NULL       0x000a      //  10
#define DNS_TYPE_WKS        0x000b      //  11
#define DNS_TYPE_PTR        0x000c      //  12
#define DNS_TYPE_HINFO      0x000d      //  13
#define DNS_TYPE_MINFO      0x000e      //  14
#define DNS_TYPE_MX         0x000f      //  15
#define DNS_TYPE_TEXT       0x0010      //  16

//  RFC 1183
#define DNS_TYPE_RP         0x0011      //  17
#define DNS_TYPE_AFSDB      0x0012      //  18
#define DNS_TYPE_X25        0x0013      //  19
#define DNS_TYPE_ISDN       0x0014      //  20
#define DNS_TYPE_RT         0x0015      //  21

//  RFC 1348
#define DNS_TYPE_NSAP       0x0016      //  22
#define DNS_TYPE_NSAPPTR    0x0017      //  23

//  RFC 2065    (DNS security)
#define DNS_TYPE_SIG        0x0018      //  24
#define DNS_TYPE_KEY        0x0019      //  25

//  RFC 1664    (X.400 mail)
#define DNS_TYPE_PX         0x001a      //  26

//  RFC 1712    (Geographic position)
#define DNS_TYPE_GPOS       0x001b      //  27

//  RFC 1886    (IPv6 Address)
#define DNS_TYPE_AAAA       0x001c      //  28

//  RFC 1876    (Geographic location)
#define DNS_TYPE_LOC        0x001d      //  29

//  RFC 2065    (Secure negative response)
#define DNS_TYPE_NXT        0x001e      //  30

//  RFC 2052    (Service location)
#define DNS_TYPE_SRV        0x0021      //  33

//  ATM Standard something-or-another
#define DNS_TYPE_ATMA       0x0022      //  34

//
//  Query only types (1035, 1995)
//
#define DNS_TYPE_TKEY       0x00f9      //  249
#define DNS_TYPE_TSIG       0x00fa      //  250
#define DNS_TYPE_IXFR       0x00fb      //  251
#define DNS_TYPE_AXFR       0x00fc      //  252
#define DNS_TYPE_MAILB      0x00fd      //  253
#define DNS_TYPE_MAILA      0x00fe      //  254
#define DNS_TYPE_ALL        0x00ff      //  255
#define DNS_TYPE_ANY        0x00ff      //  255

//
//  Temp Microsoft types -- use until get IANA approval for real type
//
#define DNS_TYPE_WINS       0xff01      //  64K - 255
#define DNS_TYPE_WINSR      0xff02      //  64K - 254
#define DNS_TYPE_NBSTAT     (DNS_TYPE_WINSR)


//
//  DNS Record Types -- Net Byte Order
//

#define DNS_RTYPE_A             0x0100      //  1
#define DNS_RTYPE_NS            0x0200      //  2
#define DNS_RTYPE_MD            0x0300      //  3
#define DNS_RTYPE_MF            0x0400      //  4
#define DNS_RTYPE_CNAME         0x0500      //  5
#define DNS_RTYPE_SOA           0x0600      //  6
#define DNS_RTYPE_MB            0x0700      //  7
#define DNS_RTYPE_MG            0x0800      //  8
#define DNS_RTYPE_MR            0x0900      //  9
#define DNS_RTYPE_NULL          0x0a00      //  10
#define DNS_RTYPE_WKS           0x0b00      //  11
#define DNS_RTYPE_PTR           0x0c00      //  12
#define DNS_RTYPE_HINFO         0x0d00      //  13
#define DNS_RTYPE_MINFO         0x0e00      //  14
#define DNS_RTYPE_MX            0x0f00      //  15
#define DNS_RTYPE_TEXT          0x1000      //  16

//  RFC 1183
#define DNS_RTYPE_RP            0x1100      //  17
#define DNS_RTYPE_AFSDB         0x1200      //  18
#define DNS_RTYPE_X25           0x1300      //  19
#define DNS_RTYPE_ISDN          0x1400      //  20
#define DNS_RTYPE_RT            0x1500      //  21

//  RFC 1348
#define DNS_RTYPE_NSAP          0x1600      //  22
#define DNS_RTYPE_NSAPPTR       0x1700      //  23

//  RFC 2065    (DNS security)
#define DNS_RTYPE_SIG           0x1800      //  24
#define DNS_RTYPE_KEY           0x1900      //  25

//  RFC 1664    (X.400 mail)
#define DNS_RTYPE_PX            0x1a00      //  26

//  RFC 1712    (Geographic position)
#define DNS_RTYPE_GPOS          0x1b00      //  27

//  RFC 1886    (IPv6 Address)
#define DNS_RTYPE_AAAA          0x1c00      //  28

//  RFC 1876    (Geographic location)
#define DNS_RTYPE_LOC           0x1d00      //  29

//  RFC 2065    (Secure negative response)
#define DNS_RTYPE_NXT           0x1e00      //  30

//  RFC 2052    (Service location)
#define DNS_RTYPE_SRV           0x2100      //  33

//  ATM Standard something-or-another
#define DNS_RTYPE_ATMA          0x2200      //  34

//
//  Query only types (1035, 1995)
//
#define DNS_RTYPE_TKEY          0xf900      //  249
#define DNS_RTYPE_TSIG          0xfa00      //  250
#define DNS_RTYPE_IXFR          0xfb00      //  251
#define DNS_RTYPE_AXFR          0xfc00      //  252
#define DNS_RTYPE_MAILB         0xfd00      //  253
#define DNS_RTYPE_MAILA         0xfe00      //  254
#define DNS_RTYPE_ALL           0xff00      //  255
#define DNS_RTYPE_ANY           0xff00      //  255

//
//  Temp Microsoft types -- use until get IANA approval for real type
//
#define DNS_RTYPE_WINS          0x01ff      //  64K - 255
#define DNS_RTYPE_WINSR         0x02ff      //  64K - 254




//
//  Record type specific definitions
//

//
//  ATMA (ATM address type) formats
//
//  Define these directly for any environment (ex NT4)
//  without winsock2 ATM support (ws2atm.h)
//

#ifndef  ATMA_E164
#define DNS_ATMA_FORMAT_E164            1
#define DNS_ATMA_FORMAT_AESA            2
#define DNS_ATMA_MAX_ADDR_LENGTH        (20)
#else
#define DNS_ATMA_FORMAT_E164            ATM_E164
#define DNS_ATMA_FORMAT_AESA            ATM_AESA
#define DNS_ATMA_MAX_ADDR_LENGTH        ATM_ADDR_SIZE
#endif

#define DNS_ATMA_AESA_ADDR_LENGTH       (20)
#define DNS_ATMA_MAX_RECORD_LENGTH      (DNS_ATMA_MAX_ADDR_LENGTH+1)


//
//  DNSSEC defs
//

//  DNSSEC algorithms

#define DNSSEC_ALGORITHM_RSAMD5     1
#define DNSSEC_ALGORITHM_NULL       253
#define DNSSEC_ALGORITHM_PRIVATE    254

//  DNSSEC KEY protocol table

#define DNSSEC_PROTOCOL_NONE        0
#define DNSSEC_PROTOCOL_TLS         1
#define DNSSEC_PROTOCOL_EMAIL       2
#define DNSSEC_PROTOCOL_DNSSEC      3
#define DNSSEC_PROTOCOL_IPSEC       4

//  DNSSEC KEY flag field

#define DNSSEC_KEY_FLAG_NOAUTH          0x0001
#define DNSSEC_KEY_FLAG_NOCONF          0x0002
#define DNSSEC_KEY_FLAG_FLAG2           0x0004
#define DNSSEC_KEY_FLAG_EXTEND          0x0008
#define DNSSEC_KEY_FLAG_
#define DNSSEC_KEY_FLAG_FLAG4           0x0010
#define DNSSEC_KEY_FLAG_FLAG5           0x0020

// bits 6,7 are name type

#define DNSSEC_KEY_FLAG_USER            0x0000
#define DNSSEC_KEY_FLAG_ZONE            0x0040
#define DNSSEC_KEY_FLAG_HOST            0x0080
#define DNSSEC_KEY_FLAG_NTPE3           0x00c0

// bits 8-11 are reserved for future use

#define DNSSEC_KEY_FLAG_FLAG8           0x0100
#define DNSSEC_KEY_FLAG_FLAG9           0x0200
#define DNSSEC_KEY_FLAG_FLAG10          0x0400
#define DNSSEC_KEY_FLAG_FLAG11          0x0800

// bits 12-15 are sig field

#define DNSSEC_KEY_FLAG_SIG0            0x0000
#define DNSSEC_KEY_FLAG_SIG1            0x1000
#define DNSSEC_KEY_FLAG_SIG2            0x2000
#define DNSSEC_KEY_FLAG_SIG3            0x3000
#define DNSSEC_KEY_FLAG_SIG4            0x4000
#define DNSSEC_KEY_FLAG_SIG5            0x5000
#define DNSSEC_KEY_FLAG_SIG6            0x6000
#define DNSSEC_KEY_FLAG_SIG7            0x7000
#define DNSSEC_KEY_FLAG_SIG8            0x8000
#define DNSSEC_KEY_FLAG_SIG9            0x9000
#define DNSSEC_KEY_FLAG_SIG10           0xa000
#define DNSSEC_KEY_FLAG_SIG11           0xb000
#define DNSSEC_KEY_FLAG_SIG12           0xc000
#define DNSSEC_KEY_FLAG_SIG13           0xd000
#define DNSSEC_KEY_FLAG_SIG14           0xe000
#define DNSSEC_KEY_FLAG_SIG15           0xf000


//
//  TKEY modes
//

#define DNS_TKEY_MODE_SERVER_ASSIGN         1
#define DNS_TKEY_MODE_DIFFIE_HELLMAN        2
#define DNS_TKEY_MODE_GSS                   3
#define DNS_TKEY_MODE_RESOLVER_ASSIGN       4

//
//  WINS + NBSTAT flag field
//

#define DNS_WINS_FLAG_SCOPE     (0x80000000)
#define DNS_WINS_FLAG_LOCAL     (0x00010000)


//
//  NT4
//

#ifdef DNSNT4

//  Sundown types

#define UINT_PTR    DWORD
#define ULONG_PTR   DWORD
#define DWORD_PTR   DWORD
#define LONG_PTR    LONG
#define INT_PTR     LONG


//
//  DNS API Errors / Status Codes
//
//  For NT5 DNS error\status codes shared by DNS API or RPC interface are in
//      winerror.h
//

#define DNS_ERROR_MASK              0xcc000000

//
//  Response codes mapped to non-colliding errors
//
//  Leave the first 4K of space for this in the assumption that DNS
//  RCODEs may be greatly expanded in some future E-DNS.
//

#define DNS_ERROR_RCODE_NO_ERROR        ERROR_SUCCESS
#define DNS_ERROR_RCODE_FORMAT_ERROR    ( DNS_ERROR_MASK | DNS_RCODE_FORMAT_ERROR    )
#define DNS_ERROR_RCODE_SERVER_FAILURE  ( DNS_ERROR_MASK | DNS_RCODE_SERVER_FAILURE  )
#define DNS_ERROR_RCODE_NAME_ERROR      ( DNS_ERROR_MASK | DNS_RCODE_NAME_ERROR      )
#define DNS_ERROR_RCODE_NOT_IMPLEMENTED ( DNS_ERROR_MASK | DNS_RCODE_NOT_IMPLEMENTED )
#define DNS_ERROR_RCODE_REFUSED         ( DNS_ERROR_MASK | DNS_RCODE_REFUSED         )
#define DNS_ERROR_RCODE_YXDOMAIN        ( DNS_ERROR_MASK | DNS_RCODE_YXDOMAIN        )
#define DNS_ERROR_RCODE_YXRRSET         ( DNS_ERROR_MASK | DNS_RCODE_YXRRSET         )
#define DNS_ERROR_RCODE_NXRRSET         ( DNS_ERROR_MASK | DNS_RCODE_NXRRSET         )
#define DNS_ERROR_RCODE_NOTAUTH         ( DNS_ERROR_MASK | DNS_RCODE_NOTAUTH         )
#define DNS_ERROR_RCODE_NOTZONE         ( DNS_ERROR_MASK | DNS_RCODE_NOTZONE         )

//  Extended TSIG\TKEY RCODEs

#define DNS_ERROR_RCODE_BADSIG          ( DNS_ERROR_MASK | DNS_EXTRCODE_BADSIG       )
#define DNS_ERROR_RCODE_BADKEY          ( DNS_ERROR_MASK | DNS_EXTRCODE_BADKEY       )
#define DNS_ERROR_RCODE_BADTIME         ( DNS_ERROR_MASK | DNS_EXTRCODE_BADTIME      )

#define DNS_ERROR_RCODE_LAST            DNS_ERROR_RCODE_BADTIME


//
//  Packet format
//

#define DNS_INFO_NO_RECORDS                         0x4c000030
#define DNS_ERROR_BAD_PACKET                        0xcc000031
#define DNS_ERROR_NO_PACKET                         0xcc000032
#define DNS_ERROR_RCODE                             0xcc000033
#define DNS_STATUS_PACKET_UNSECURE                  0xcc000034
#define DNS_ERROR_UNSECURE_PACKET                   0xcc000034

//
//  General API errors
//

#define DNS_ERROR_NO_MEMORY                         ERROR_OUTOFMEMORY
#define DNS_ERROR_INVALID_NAME                      ERROR_INVALID_NAME
#define DNS_ERROR_INVALID_DATA                      ERROR_INVALID_DATA
#define DNS_ERROR_INVALID_TYPE                      0xcc000051
#define DNS_ERROR_INVALID_IP_ADDRESS                0xcc000052
#define DNS_ERROR_INVALID_PROPERTY                  0xcc000053
#define DNS_ERROR_TRY_AGAIN_LATER                   0xcc000054
#define DNS_ERROR_NOT_UNIQUE                        0xcc000055
#define DNS_ERROR_NON_RFC_NAME                      0xcc000056

#define DNS_STATUS_FQDN                             0x4c000101
#define DNS_STATUS_DOTTED_NAME                      0x4c000102
#define DNS_STATUS_SINGLE_PART_NAME                 0x4c000103

//
//  Zone errors
//

#define DNS_ERROR_ZONE_DOES_NOT_EXIST               0xcc000101
#define DNS_ERROR_NO_ZONE_INFO                      0xcc000102
#define DNS_ERROR_INVALID_ZONE_OPERATION            0xcc000103
#define DNS_ERROR_ZONE_CONFIGURATION_ERROR          0xcc000104
#define DNS_ERROR_ZONE_HAS_NO_SOA_RECORD            0xcc000105
#define DNS_ERROR_ZONE_HAS_NO_NS_RECORDS            0xcc000106
#define DNS_ERROR_ZONE_LOCKED                       0xcc000107

#define DNS_ERROR_ZONE_CREATION_FAILED              0xcc000110
#define DNS_ERROR_ZONE_ALREADY_EXISTS               0xcc000111
#define DNS_ERROR_AUTOZONE_ALREADY_EXISTS           0xcc000112
#define DNS_ERROR_INVALID_ZONE_TYPE                 0xcc000113
#define DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP      0xcc000114

#define DNS_ERROR_ZONE_NOT_SECONDARY                0xcc000120
#define DNS_ERROR_NEED_SECONDARY_ADDRESSES          0xcc000121
#define DNS_ERROR_WINS_INIT_FAILED                  0xcc000122
#define DNS_ERROR_NEED_WINS_SERVERS                 0xcc000123
#define DNS_ERROR_NBSTAT_INIT_FAILED                0xcc000124
#define DNS_ERROR_SOA_DELETE_INVALID                0xcc000125

//
//  Datafile errors
//

#define DNS_ERROR_PRIMARY_REQUIRES_DATAFILE         0xcc000201
#define DNS_ERROR_INVALID_DATAFILE_NAME             0xcc000202
#define DNS_ERROR_DATAFILE_OPEN_FAILURE             0xcc000203
#define DNS_ERROR_FILE_WRITEBACK_FAILED             0xcc000204
#define DNS_ERROR_DATAFILE_PARSING                  0xcc000205

//
//  Database errors
//

#define DNS_ERROR_RECORD_DOES_NOT_EXIST             0xcc000300
#define DNS_ERROR_RECORD_FORMAT                     0xcc000301
#define DNS_ERROR_NODE_CREATION_FAILED              0xcc000302
#define DNS_ERROR_UNKNOWN_RECORD_TYPE               0xcc000303
#define DNS_ERROR_RECORD_TIMED_OUT                  0xcc000304

#define DNS_ERROR_NAME_NOT_IN_ZONE                  0xcc000305
#define DNS_ERROR_CNAME_LOOP                        0xcc000306
#define DNS_ERROR_NODE_IS_CNAME                     0xcc000307
#define DNS_ERROR_CNAME_COLLISION                   0xcc000308
#define DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT          0xcc000309
#define DNS_ERROR_RECORD_ALREADY_EXISTS             0xcc000310
#define DNS_ERROR_SECONDARY_DATA                    0xcc000311
#define DNS_ERROR_NO_CREATE_CACHE_DATA              0xcc000312
#define DNS_ERROR_NAME_DOES_NOT_EXIST               0xcc000313

#define DNS_WARNING_PTR_CREATE_FAILED               0x8c000332
#define DNS_WARNING_DOMAIN_UNDELETED                0x8c000333

#define DNS_ERROR_DS_UNAVAILABLE                    0xcc000340
#define DNS_ERROR_DS_ZONE_ALREADY_EXISTS            0xcc000341
#define DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE            0xcc000342


//
//  Operation errors
//

#define DNS_INFO_AXFR_COMPLETE                      0x4c000403
#define DNS_ERROR_AXFR                              0xcc000404
#define DNS_INFO_ADDED_LOCAL_WINS                   0x4c000405

//  Secure update

#define DNS_STATUS_CONTINUE_NEEDED                  0x4c000406

//
//  Setup errors
//

#define DNS_ERROR_NO_TCPIP                          0xcc000501
#define DNS_ERROR_NO_DNS_SERVERS                    0xcc000502

#endif  // NT4


//
//  Helpful checks
//

#define VALID_USER_MEMORY(p)    ( (DWORD)(p) < 0x80000000 )

#define IS_DWORD_ALIGNED(p)     ( !((DWORD_PTR)(p) & (DWORD_PTR)3) )


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNS_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\dnsapi.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dnsapi.h

Abstract:

    Domain Name System (DNS)

    DNS Client API Library

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

    Glenn Curtis (glennc)   January 22, 1997
        Added Dynamic Update Client API for DNSAPI.DLL

--*/


#ifndef _DNSAPI_INCLUDED_
#define _DNSAPI_INCLUDED_

#ifndef _WINSOCK2API_
#ifndef _WINSOCKAPI_
#include <winsock2.h>
#endif
#endif

#ifndef _DNS_INCLUDED_
#include <dns.h>
#endif


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus


//
//  Non-wrapping seconds timer (timer.c)
//

DWORD
GetCurrentTimeInSeconds(
    VOID
    );


//
//  General DNS utilities (dnsutil.c)
//

LPSTR
_fastcall
DnsGetDomainName(
    IN  LPSTR   pszName
    );

LPSTR
_fastcall
DnsStatusString(
    IN  DNS_STATUS  Status
    );

#define DnsStatusToErrorString_A(status)    DnsStatusString(status)

DNS_STATUS
_fastcall
DnsMapRcodeToStatus(
    IN  BYTE    ResponseCode
    );

BYTE
_fastcall
DnsIsStatusRcode(
    IN  DNS_STATUS  Status
    );

//
//  Machines IP address list (iplist.c)
//
//  Routine to get the current IP addresses from all adapters
//  configured for the machine.
//

DWORD
DnsGetIpAddressList(
    OUT PIP_ARRAY * ppIpAddresses
    );

//
//  Routine to get the current IP addresses and subnet masks
//  from all adapters configured for the machine.
//

typedef struct _DNS_ADDRESS_INFO_
{
    IP_ADDRESS ipAddress;
    IP_ADDRESS subnetMask;
}
DNS_ADDRESS_INFO, *PDNS_ADDRESS_INFO;

DWORD
DnsGetIpAddressInfoList(
    OUT PDNS_ADDRESS_INFO * ppAddrInfo
    );

DWORD
DnsGetDnsServerList(
    OUT PIP_ARRAY * ppDnsAddresses
    );


//
// Routines and structures for getting network configuration information
// for TCPIP interfaces
//

#define NETINFO_FLAG_IS_WAN_ADAPTER             (0x00000002)
#define NETINFO_FLAG_IS_AUTONET_ADAPTER         (0x00000004)
#define NETINFO_FLAG_IS_DHCP_CFG_ADAPTER        (0x00000008)


typedef struct _NAME_SERVER_INFORMATION_
{
    IP_ADDRESS      ipAddress;
    DWORD           Priority;
}
NAME_SERVER_INFORMATION, *PNAME_SERVER_INFORMATION;

typedef struct _ADAPTER_INFORMATION_
{
    LPSTR                   pszAdapterGuidName;
    LPSTR                   pszDomain;
    PIP_ARRAY               pIPAddresses;
    PIP_ARRAY               pIPSubnetMasks;
    DWORD                   InfoFlags;
    DWORD                   cServerCount;
    NAME_SERVER_INFORMATION aipServers[1];
}
ADAPTER_INFORMATION, *PADAPTER_INFORMATION;

typedef struct _SEARCH_INFORMATION_
{
    LPSTR           pszPrimaryDomainName;
    DWORD           cNameCount;
    LPSTR           aSearchListNames[1];
}
SEARCH_INFORMATION, *PSEARCH_INFORMATION;

typedef struct _NETWORK_INFORMATION_
{
    PSEARCH_INFORMATION  pSearchInformation;
    DWORD                cAdapterCount;
    PADAPTER_INFORMATION aAdapterInfoList[1];
}
NETWORK_INFORMATION, *PNETWORK_INFORMATION;


PNETWORK_INFORMATION
WINAPI
DnsGetNetworkInformation(
    void
    );

PSEARCH_INFORMATION
WINAPI
DnsGetSearchInformation(
    void
    );

VOID
WINAPI
DnsFreeAdapterInformation(
    IN  PADAPTER_INFORMATION pAdapterInformation
    );

VOID
WINAPI
DnsFreeSearchInformation(
    IN  PSEARCH_INFORMATION pSearchInformation
    );

VOID
WINAPI
DnsFreeNetworkInformation(
    IN  PNETWORK_INFORMATION pNetworkInformation
    );



//
//  Resource record type utilities (record.c)
//

BOOL
_fastcall
DnsIsAMailboxType(
    IN  WORD    wType
    );

WORD
DnsRecordTypeForName(
    IN  PCHAR   pszName,
    IN  INT     cchNameLength
    );

PCHAR
DnsRecordStringForType(
    IN  WORD    wType
    );

PCHAR
DnsRecordStringForWritableType(
    IN  WORD    wType
    );

BOOL
DnsIsStringCountValidForTextType(
    IN  WORD    wType,
    IN  WORD    StringCount
    );

BOOL
DnsIpv6StringToAddress(
    OUT PIPV6_ADDRESS   pAddress,
    IN  PCHAR           pchString,
    IN  DWORD           dwStringLength
    );

VOID
DnsIpv6AddressToString(
    OUT PCHAR           pchString,
    IN  PIPV6_ADDRESS   pAddress
    );



//
//  Resource record structure for send\recv records.
//

//
//  Record data for specific types
//

#ifdef SDK_DNS_RECORD

typedef struct
{
    IP_ADDRESS  ipAddress;
}
DNS_A_DATA, *PDNS_A_DATA;

typedef struct
{
    LPTSTR      pNameHost;
}
DNS_PTR_DATA, *PDNS_PTR_DATA;

typedef struct
{
    LPTSTR      pNamePrimaryServer;
    LPTSTR      pNameAdministrator;
    DWORD       dwSerialNo;
    DWORD       dwRefresh;
    DWORD       dwRetry;
    DWORD       dwExpire;
    DWORD       dwDefaultTtl;
}
DNS_SOA_DATA, *PDNS_SOA_DATA;

typedef struct
{
    LPTSTR      pNameMailbox;
    LPTSTR      pNameErrorsMailbox;
}
DNS_MINFO_DATA, *PDNS_MINFO_DATA;

typedef struct
{
    LPTSTR      pNameExchange;
    WORD        wPreference;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_MX_DATA, *PDNS_MX_DATA;

typedef struct
{
    DWORD       dwStringCount;
#ifdef MIDL_PASS
    [size_is(dwStringCount)] LPTSTR * pStringArray;
#else  // MIDL_PASS
    LPTSTR     pStringArray[1];
#endif // MIDL_PASS
}
DNS_TXT_DATA, *PDNS_TXT_DATA;

typedef struct
{
    DWORD       dwByteCount;
#ifdef MIDL_PASS
    [size_is(dwByteCount)] PBYTE bData;
#else  // MIDL_PASS
    BYTE       bData[1];
#endif // MIDL_PASS
}
DNS_NULL_DATA, *PDNS_NULL_DATA;

typedef struct
{
    IP_ADDRESS  ipAddress;
    UCHAR       chProtocol;
    BYTE        bBitMask[1];
}
DNS_WKS_DATA, *PDNS_WKS_DATA;

typedef struct
{
    IPV6_ADDRESS    ipv6Address;
}
DNS_AAAA_DATA, *PDNS_AAAA_DATA;

typedef struct
{
    LPTSTR      pNameSigner;
    WORD        wTypeCovered;
    BYTE        chAlgorithm;
    BYTE        chLabelCount;
    DWORD       dwOriginalTtl;
    DWORD       dwExpiration;
    DWORD       dwTimeSigned;
    WORD        wKeyTag;
    WORD        Pad;        // keep byte field aligned
    BYTE        Signature[1];
}
DNS_SIG_DATA, *PDNS_SIG_DATA;

typedef struct
{
    WORD        wFlags;
    BYTE        chProtocol;
    BYTE        chAlgorithm;
    BYTE        Key[1];
}
DNS_KEY_DATA, *PDNS_KEY_DATA;

typedef struct
{
    WORD        wVersion;
    WORD        wSize;
    WORD        wHorPrec;
    WORD        wVerPrec;
    DWORD       dwLatitude;
    DWORD       dwLongitude;
    DWORD       dwAltitude;
}
DNS_LOC_DATA, *PDNS_LOC_DATA;

typedef struct
{
    LPTSTR      pNameNext;
    BYTE        bTypeBitMap[1];
}
DNS_NXT_DATA, *PDNS_NXT_DATA;

typedef struct
{
    LPTSTR      pNameTarget;
    WORD        wPriority;
    WORD        wWeight;
    WORD        wPort;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_SRV_DATA, *PDNS_SRV_DATA;

typedef struct
{
    LPTSTR      pNameAlgorithm;
    PBYTE       pAlgorithmPacket;
    PBYTE       pKey;
    PBYTE       pOtherData;
    DWORD       dwCreateTime;
    DWORD       dwExpireTime;
    WORD        wMode;
    WORD        wError;
    WORD        wKeyLength;
    WORD        wOtherLength;
    UCHAR       cAlgNameLength;
    BOOL        fPacketPointers;
}
DNS_TKEY_DATA, *PDNS_TKEY_DATA;

typedef struct
{
    LPTSTR      pNameAlgorithm;
    PBYTE       pAlgorithmPacket;
    PBYTE       pSignature;
    PBYTE       pOtherData;
    LONGLONG    i64CreateTime;
    WORD        wFudgeTime;
    WORD        wOriginalID;
    WORD        wError;
    WORD        wSigLength;
    WORD        wOtherLength;
    UCHAR       cAlgNameLength;
    BOOL        fPacketPointers;
}
DNS_TSIG_DATA, *PDNS_TSIG_DATA;


#define DNS_ATM_TYPE_E164    0x01 // E.164 addressing scheme
#define DNS_ATM_TYPE_NSAP    0x02 // NSAP-style addressing scheme
#define DNS_ATM_TYPE_AESA    DNS_ATM_TYPE_NSAP

#define DNS_ATM_MAX_ADDR_SIZE    20

typedef struct
{
    BYTE        AddressType;
    BYTE        Address[ DNS_ATM_MAX_ADDR_SIZE ];

    // Endsystem Address IA5 digits
    // for E164, BCD encoding for NSAP
    // Array size is DNS_ATM_MAX_ADDR_SIZE for NSAP
    // address type, and a null terminated string
    // less than DNS_ATM_MAX_ADDR_SIZE characters
    // for E164 address type.
}
DNS_ATMA_DATA, *PDNS_ATMA_DATA;


//
//  MS only types -- only hit the wire in MS-MS zone transfer
//

typedef struct
{
    DWORD       dwMappingFlag;
    DWORD       dwLookupTimeout;
    DWORD       dwCacheTimeout;
    DWORD       cWinsServerCount;
    IP_ADDRESS  aipWinsServers[1];
}
DNS_WINS_DATA, *PDNS_WINS_DATA;

typedef struct
{
    DWORD       dwMappingFlag;
    DWORD       dwLookupTimeout;
    DWORD       dwCacheTimeout;
    LPTSTR      pNameResultDomain;
}
DNS_WINSR_DATA, *PDNS_WINSR_DATA;


//
//  Length of non-fixed-length data types
//

#define DNS_TEXT_RECORD_LENGTH(StringCount) \
            (sizeof(DWORD) + ((StringCount) * sizeof(PCHAR)))

#define DNS_NULL_RECORD_LENGTH(ByteCount) \
            (sizeof(DWORD) + (ByteCount))

#define DNS_WKS_RECORD_LENGTH(ByteCount) \
            (sizeof(DNS_WKS_DATA) + (ByteCount-1))

#define DNS_WINS_RECORD_LENGTH(IpCount) \
            (sizeof(DNS_WINS_DATA) + ((IpCount-1) * sizeof(IP_ADDRESS)))


//
//  Record flags
//

#if 0
typedef struct _DnsRecordFlags
{
    BYTE    Section     : 2;
    BYTE    Delete      : 1;
    BYTE    Unused      : 5;

    BYTE    Unused2     : 4;
    BYTE    FreeData    : 1;
    BYTE    FreeOwner   : 1;
    BYTE    Unicode     : 1;
    BYTE    Multiple    : 1;

    WORD    Reserved;
}
DNSREC_FLAGS;
#endif



typedef struct _DnsRecordFlags
{
    DWORD   Section     : 2;
    DWORD   Delete      : 1;
    DWORD   CharSet     : 2;
    DWORD   Unused      : 3;

    DWORD   Reserved    : 24;
}
DNSREC_FLAGS;


//
//  Record flags as bit flags
//  These may be or'd together to set the fields
//

//  RR Section in packet

#define     DNSREC_SECTION      (0x00000003)

#define     DNSREC_QUESTION     (0x00000000)
#define     DNSREC_ANSWER       (0x00000001)
#define     DNSREC_AUTHORITY    (0x00000002)
#define     DNSREC_ADDITIONAL   (0x00000003)

//  RR Section in packet (update)

#define     DNSREC_ZONE         (0x00000000)
#define     DNSREC_PREREQ       (0x00000001)
#define     DNSREC_UPDATE       (0x00000002)

//  Delete RR (update) or No-exist (prerequisite)

#define     DNSREC_DELETE       (0x00000004)
#define     DNSREC_NOEXIST      (0x00000004)


#ifdef MIDL_PASS
typedef [switch_type(WORD)] union _DNS_RECORD_DATA_TYPES
{
    [case(DNS_TYPE_A)]      DNS_A_DATA     A;

    [case(DNS_TYPE_SOA)]    DNS_SOA_DATA   SOA;

    [case(DNS_TYPE_PTR,
          DNS_TYPE_NS,
          DNS_TYPE_CNAME,
          DNS_TYPE_MB,
          DNS_TYPE_MD,
          DNS_TYPE_MF,
          DNS_TYPE_MG,
          DNS_TYPE_MR)]     DNS_PTR_DATA   PTR;

    [case(DNS_TYPE_MINFO,
          DNS_TYPE_RP)]     DNS_MINFO_DATA MINFO;

    [case(DNS_TYPE_MX,
          DNS_TYPE_AFSDB,
          DNS_TYPE_RT)]     DNS_MX_DATA    MX;

#if 0
    //  RPC is not able to handle a proper TXT record definition
    //  note:  that if other types are needed they are fixed
    //      (or semi-fixed) size and may be accomodated easily
    [case(DNS_TYPE_HINFO,
          DNS_TYPE_ISDN,
          DNS_TYPE_TEXT,
          DNS_TYPE_X25)]    DNS_TXT_DATA   TXT;

    [case(DNS_TYPE_NULL)]   DNS_NULL_DATA  Null;
    [case(DNS_TYPE_WKS)]    DNS_WKS_DATA   WKS;
    [case(DNS_TYPE_TKEY)]   DNS_TKEY_DATA  TKEY;
    [case(DNS_TYPE_TSIG)]   DNS_TSIG_DATA  TSIG;
    [case(DNS_TYPE_WINS)]   DNS_WINS_DATA  WINS;
    [case(DNS_TYPE_NBSTAT)] DNS_WINSR_DATA WINSR;
#endif

    [case(DNS_TYPE_AAAA)]   DNS_AAAA_DATA  AAAA;
    [case(DNS_TYPE_SRV)]    DNS_SRV_DATA   SRV;
    [case(DNS_TYPE_ATMA)]   DNS_ATMA_DATA  ATMA;
    //
    // BUGBUG - Commented out since this may not be needed - Check with MarioG
    //
    //[default] ;
}
DNS_RECORD_DATA_TYPES;
#endif // MIDL_PASS


//
//  Record \ RR set structure
//
//  Note:   The dwReserved flag serves to insure that the substructures
//          start on 64-bit boundaries.  Since adding the LONGLONG to
//          TSIG structure the compiler wants to start them there anyway
//          (to 64-align).  This insures that no matter what data fields
//          are present we are properly 64-aligned.
//
//          Do NOT pack this structure, as the substructures to be 64-aligned
//          for Win64.
//

typedef struct _DnsRecord
{
    struct _DnsRecord * pNext;
    LPTSTR              pName;
    WORD                wType;
    WORD                wDataLength; // Not referenced for DNS record types
                                     // defined above.
#ifdef MIDL_PASS
    DWORD               Flags;
#else // MIDL_PASS
    union
    {
        DWORD           DW; // flags as dword
        DNSREC_FLAGS    S;  // flags as structure

    } Flags;
#endif // MIDL_PASS

    DWORD               dwTtl;
    DWORD               dwReserved;
#ifdef MIDL_PASS
    [switch_is(wType)] DNS_RECORD_DATA_TYPES Data;
#else  // MIDL_PASS
    union
    {
        DNS_A_DATA      A;
        DNS_SOA_DATA    SOA, Soa;
        DNS_PTR_DATA    PTR, Ptr,
                        NS, Ns,
                        CNAME, Cname,
                        MB, Mb,
                        MD, Md,
                        MF, Mf,
                        MG, Mg,
                        MR, Mr;
        DNS_MINFO_DATA  MINFO, Minfo,
                        RP, Rp;
        DNS_MX_DATA     MX, Mx,
                        AFSDB, Afsdb,
                        RT, Rt;
        DNS_TXT_DATA    HINFO, Hinfo,
                        ISDN, Isdn,
                        TXT, Txt,
                        X25;
        DNS_NULL_DATA   Null;
        DNS_WKS_DATA    WKS, Wks;
        DNS_AAAA_DATA   AAAA;
        DNS_SRV_DATA    SRV, Srv;
        DNS_TKEY_DATA   TKEY, Tkey;
        DNS_TSIG_DATA   TSIG, Tsig;
        DNS_ATMA_DATA   ATMA, Atma;
        DNS_WINS_DATA   WINS, Wins;
        DNS_WINSR_DATA  WINSR, WinsR, NBSTAT, Nbstat;

    } Data;
#endif // MIDL_PASS
}
DNS_RECORD, *PDNS_RECORD;



#else   // not SDK_DNS_RECORD

//
//  Old DNS_RECORD definitions
//  JBUGBUG:  save only until Cliff (and any other NT file)
//      can be converted, then dump
//

//
//  Record data for specific types
//

typedef struct
{
    IP_ADDRESS  ipAddress;
}
DNS_A_DATA, *PDNS_A_DATA;

typedef struct
{
    DNS_NAME    nameHost;
}
DNS_PTR_DATA, *PDNS_PTR_DATA;

typedef struct
{
    DNS_NAME    namePrimaryServer;
    DNS_NAME    nameAdministrator;
    DWORD       dwSerialNo;
    DWORD       dwRefresh;
    DWORD       dwRetry;
    DWORD       dwExpire;
    DWORD       dwDefaultTtl;
}
DNS_SOA_DATA, *PDNS_SOA_DATA;

typedef struct
{
    DNS_NAME    nameMailbox;
    DNS_NAME    nameErrorsMailbox;
}
DNS_MINFO_DATA, *PDNS_MINFO_DATA;

typedef struct
{
    DNS_NAME    nameExchange;
    WORD        wPreference;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_MX_DATA, *PDNS_MX_DATA;

typedef struct
{
    DWORD       dwStringCount;
    DNS_TEXT    pStringArray[1];
}
DNS_TXT_DATA, *PDNS_TXT_DATA;

typedef struct
{
    // DWORD       dwByteCount;
    BYTE        bData[1];
}
DNS_NULL_DATA, *PDNS_NULL_DATA;

typedef struct
{
    IP_ADDRESS  ipAddress;
    UCHAR       chProtocol;
    BYTE        bBitMask[1];
}
DNS_WKS_DATA, *PDNS_WKS_DATA;

typedef struct
{
    IPV6_ADDRESS    ipv6Address;
}
DNS_AAAA_DATA, *PDNS_AAAA_DATA;

typedef struct
{
    DNS_NAME    nameSigner;
    WORD        wTypeCovered;
    BYTE        chAlgorithm;
    BYTE        chLabelCount;
    DWORD       dwOriginalTtl;
    DWORD       dwExpiration;
    DWORD       dwTimeSigned;
    WORD        wKeyTag;
    WORD        Pad;        // keep byte field aligned
    BYTE        Signature[1];
}
DNS_SIG_DATA, *PDNS_SIG_DATA;

typedef struct
{
    WORD        wFlags;
    BYTE        chProtocol;
    BYTE        chAlgorithm;
    BYTE        Key[1];
}
DNS_KEY_DATA, *PDNS_KEY_DATA;

typedef struct
{
    WORD        wVersion;
    WORD        wSize;
    WORD        wHorPrec;
    WORD        wVerPrec;
    DWORD       dwLatitude;
    DWORD       dwLongitude;
    DWORD       dwAltitude;
}
DNS_LOC_DATA, *PDNS_LOC_DATA;

typedef struct
{
    DNS_NAME    nameNext;
    BYTE        bTypeBitMap[1];
}
DNS_NXT_DATA, *PDNS_NXT_DATA;

typedef struct
{
    DNS_NAME    nameTarget;
    WORD        wPriority;
    WORD        wWeight;
    WORD        wPort;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_SRV_DATA, *PDNS_SRV_DATA;

typedef struct
{
    DNS_NAME    nameAlgorithm;
    PBYTE       pAlgorithmPacket;
    PBYTE       pKey;
    PBYTE       pOtherData;
    DWORD       dwCreateTime;
    DWORD       dwExpireTime;
    WORD        wMode;
    WORD        wError;
    WORD        wKeyLength;
    WORD        wOtherLength;
    UCHAR       cAlgNameLength;
    BOOLEAN     fPacketPointers;
}
DNS_TKEY_DATA, *PDNS_TKEY_DATA;

typedef struct
{
    DNS_NAME    nameAlgorithm;
    PBYTE       pAlgorithmPacket;
    PBYTE       pSignature;
    PBYTE       pOtherData;
    LONGLONG    i64CreateTime;
    WORD        wFudgeTime;
    WORD        wOriginalID;
    WORD        wError;
    WORD        wSigLength;
    WORD        wOtherLength;
    UCHAR       cAlgNameLength;
    BOOLEAN     fPacketPointers;
}
DNS_TSIG_DATA, *PDNS_TSIG_DATA;

#define DNS_ATM_TYPE_E164    0x01 // E.164 addressing scheme
#define DNS_ATM_TYPE_NSAP    0x02 // NSAP-style addressing scheme
#define DNS_ATM_TYPE_AESA    DNS_ATM_TYPE_NSAP

#define DNS_ATM_MAX_ADDR_SIZE    20

typedef struct
{
    BYTE    AddressType;    // E.164 or NSAP-style ATM Endsystem Address
    BYTE    Address[1];     // IA5 digits for E164, BCD encoding for NSAP
                            // Array size is DNS_ATM_MAX_ADDR_SIZE for NSAP
                            // address type, and a null terminated string
                            // less than DNS_ATM_MAX_ADDR_SIZE characters
                            // for E164 address type.
}
DNS_ATMA_DATA, *PDNS_ATMA_DATA;


//
//  MS only types -- only hit the wire in MS-MS zone transfer
//

typedef struct
{
    DWORD       dwMappingFlag;
    DWORD       dwLookupTimeout;
    DWORD       dwCacheTimeout;
    DWORD       cWinsServerCount;
    IP_ADDRESS  aipWinsServers[1];
}
DNS_WINS_DATA, *PDNS_WINS_DATA;

typedef struct
{
    DWORD       dwMappingFlag;
    DWORD       dwLookupTimeout;
    DWORD       dwCacheTimeout;
    DNS_NAME    nameResultDomain;
}
DNS_WINSR_DATA, *PDNS_WINSR_DATA;


//
//  Length of non-fixed-length data types
//

#define DNS_TEXT_RECORD_LENGTH(StringCount) \
            (sizeof(DWORD) + ((StringCount) * sizeof(PCHAR)))

#define DNS_NULL_RECORD_LENGTH(ByteCount) \
            (sizeof(DWORD) + (ByteCount))

#define DNS_WKS_RECORD_LENGTH(ByteCount) \
            (sizeof(DNS_WKS_DATA) + (ByteCount-1))

#define DNS_WINS_RECORD_LENGTH(IpCount) \
            (sizeof(DNS_WINS_DATA) + ((IpCount-1) * sizeof(IP_ADDRESS)))


//
//  Record flags
//

typedef struct _DnsRecordFlags
{
    DWORD   Section     : 2;
    DWORD   Delete      : 1;
    DWORD   Unused      : 5;

    DWORD   Unused2     : 4;
    DWORD   FreeData    : 1;
    DWORD   FreeOwner   : 1;
    DWORD   Unicode     : 1;
    DWORD   Multiple    : 1;

    DWORD   Reserved    : 16;
}
DNSREC_FLAGS;


//
//  Record flags as bit flags
//  These may be or'd together to set the fields
//

//  RR Section in packet

#define     DNSREC_SECTION      (0x00000003)

#define     DNSREC_QUESTION     (0x00000000)
#define     DNSREC_ANSWER       (0x00000001)
#define     DNSREC_AUTHORITY    (0x00000002)
#define     DNSREC_ADDITIONAL   (0x00000003)

//  RR Section in packet (update)

#define     DNSREC_ZONE         (0x00000000)
#define     DNSREC_PREREQ       (0x00000001)
#define     DNSREC_UPDATE       (0x00000002)

//  Delete RR (update) or No-exist (prerequisite)

#define     DNSREC_DELETE       (0x00000004)
#define     DNSREC_NOEXIST      (0x00000004)

//  Owner name is allocated and can be freed with record cleanup

#define     DNSREC_FREEOWNER    (0x00002000)

//  UNICODE names in record

#define     DNSREC_UNICODE      (0x00004000)

//  Multiple RR in this record buffer
//  This optimization may be used with fixed types only

#define     DNSREC_MULTIPLE     (0x00008000)


//
//  Record \ RR set structure
//
//  Note:   The dwReserved flag serves to insure that the substructures
//          start on 64-bit boundaries.  Since adding the LONGLONG to
//          TSIG structure the compiler wants to start them there anyway
//          (to 64-align).  This insures that no matter what data fields
//          are present we are properly 64-aligned.
//
//          Do NOT pack this structure, as the substructures to be 64-aligned
//          for Win64.
//

typedef struct _DnsRecord
{
    struct _DnsRecord * pNext;
    DNS_NAME            nameOwner;
    WORD                wType;
    WORD                wDataLength;
    union
    {
        DWORD           W;  // flags as dword
        DNSREC_FLAGS    S;  // flags as structure

    } Flags;

    DWORD               dwTtl;
    DWORD               dwReserved;
    union
    {
        DNS_A_DATA      A;
        DNS_SOA_DATA    SOA, Soa;
        DNS_PTR_DATA    PTR, Ptr,
                        NS, Ns,
                        CNAME, Cname,
                        MB, Mb,
                        MD, Md,
                        MF, Mf,
                        MG, Mg,
                        MR, Mr;
        DNS_MINFO_DATA  MINFO, Minfo,
                        RP, Rp;
        DNS_MX_DATA     MX, Mx,
                        AFSDB, Afsdb,
                        RT, Rt;
        DNS_TXT_DATA    HINFO, Hinfo,
                        ISDN, Isdn,
                        TXT, Txt,
                        X25;
        DNS_NULL_DATA   Null;
        DNS_WKS_DATA    WKS, Wks;
        DNS_AAAA_DATA   AAAA;
        DNS_SRV_DATA    SRV, Srv;
        DNS_TKEY_DATA   TKEY, Tkey;
        DNS_TSIG_DATA   TSIG, Tsig;
        DNS_ATMA_DATA   ATMA, Atma;
        DNS_WINS_DATA   WINS, Wins;
        DNS_WINSR_DATA  WINSR, WinsR, NBSTAT, Nbstat;

    } Data;
}
DNS_RECORD, *PDNS_RECORD;

#endif // End of old DNS_RECORD definitions


#define DNS_RECORD_FIXED_SIZE       FIELD_OFFSET( DNS_RECORD, Data )
#define SIZEOF_DNS_RECORD_HEADER    DNS_RECORD_FIXED_SIZE



//
//  Resource record set building
//
//  pFirst points to first record in list.
//  pLast points to last record in list.
//

typedef struct _DnsRRSet
{
    PDNS_RECORD pFirstRR;
    PDNS_RECORD pLastRR;
}
DNS_RRSET, *PDNS_RRSET;


//
//  To init pFirst is NULL.
//  But pLast points at the location of the pFirst pointer -- essentially
//  treating the pFirst ptr as a DNS_RECORD.  (It is a DNS_RECORD with
//  only a pNext field, but that's the only part we use.)
//
//  Then when the first record is added to the list, the pNext field of
//  this dummy record (which corresponds to pFirst's value) is set to
//  point at the first record.  So pFirst then properly points at the
//  first record.
//
//  (This works only because pNext is the first field in a
//  DNS_RECORD structure and hence casting a PDNS_RECORD ptr to
//  PDNS_RECORD* and dereferencing yields its pNext field)
//

#define DNS_RRSET_INIT( rrset )                 \
        {                                       \
            PDNS_RRSET  _prrset = &(rrset);     \
            _prrset->pFirstRR = NULL;           \
            _prrset->pLastRR = (PDNS_RECORD) &_prrset->pFirstRR; \
        }

#define DNS_RRSET_ADD( rrset, pnewRR )          \
        {                                       \
            PDNS_RRSET  _prrset = &(rrset);     \
            PDNS_RECORD _prrnew = (pnewRR);     \
            _prrset->pLastRR->pNext = _prrnew;  \
            _prrset->pLastRR = _prrnew;         \
        }


//
//  Record building (rralloc.c)
//

PDNS_RECORD
WINAPI
DnsAllocateRecord(
    IN      WORD        wBufferLength
    );

VOID
WINAPI
DnsRecordListFree(
    IN OUT  PDNS_RECORD pRecord,
    IN      BOOL        fFreeOwner
    );

#define DnsFreeRRSet( pRRSet, fFreeOwner )  \
        DnsRecordListFree( (pRRSet), (fFreeOwner) )


PDNS_RECORD
DnsRecordSetDetach(
    IN OUT  PDNS_RECORD pRR
    );

PDNS_RECORD
DnsCreatePtrRecord(
    IN      IP_ADDRESS  ipAddress,
    IN      DNS_NAME    pszHostName,
    IN      BOOL        fUnicodeName
    );


//
//  Record build from data strings (rrbuild.c)
//

PDNS_RECORD
DnsRecordBuild(
    IN OUT  PDNS_RRSET  pRRSet,
    IN      LPSTR       pszOwner,
    IN      WORD        wType,
    IN      BOOL        fAdd,
    IN      UCHAR       Section,
    IN      INT         Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
DnsRecordBuild_UTF8(
    IN OUT  PDNS_RRSET  pRRSet,
    IN      LPSTR       pszOwner,
    IN      WORD        wType,
    IN      BOOL        fAdd,
    IN      UCHAR       Section,
    IN      INT         Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
DnsRecordBuild_W(
    IN OUT  PDNS_RRSET  pRRSet,
    IN      LPWSTR      pszOwner,
    IN      WORD        wType,
    IN      BOOL        fAdd,
    IN      UCHAR       Section,
    IN      INT         Argc,
    IN      PWCHAR *    Argv
    );


//
//  Record set manipulation
//

//
//  Record Compare
//
//  Note:  these routines will NOT do proper unicode compare, unless
//         records have the fUnicode flag set. Both input record lists
//         must be either ANSI or UNICODE, but not one of each.
//

BOOL
WINAPI
DnsRecordCompare(
    IN      PDNS_RECORD     pRecord1,
    IN      PDNS_RECORD     pRecord2
    );

BOOL
WINAPI
DnsRecordSetCompare(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,
    OUT     PDNS_RECORD *   ppDiff2
    );


//
//  DNS Name compare
//

BOOL
WINAPI
DnsNameCompare_A(
    IN      LPSTR       pName1,
    IN      LPSTR       pName2
    );

BOOL
WINAPI
DnsNameCompare_W(
    IN      LPWSTR      pName1,
    IN      LPWSTR      pName2
    );

//
//  Record Copy
//  Record copy functions also do conversion between character sets.
//
//  Note, it might be advisable to directly expose non-Ex copy
//  functions _W, _A for record and set, to avoid exposing the
//  conversion enum.
//

typedef enum _DNS_CHARSET
{
    DnsCharSetUnknown,
    DnsCharSetUnicode,
    DnsCharSetUtf8,
    DnsCharSetAnsi,
}
DNS_CHARSET;


PDNS_RECORD
WINAPI
DnsRecordCopyEx(
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

PDNS_RECORD
WINAPI
DnsRecordSetCopyEx(
    IN      PDNS_RECORD     pRecordSet,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

#ifdef UNICODE
#define DnsRecordCopy(pRR)  \
        DnsRecordCopyEx( (pRR), DnsCharSetUnicode, DnsCharSetUnicode )
#define DnsRecordSetCopy(pRR)  \
        DnsRecordSetCopyEx( (pRR), DnsCharSetUnicode, DnsCharSetUnicode )
#else
#define DnsRecordCopy(pRR)  \
        DnsRecordCopyEx( (pRR), DnsCharSetAnsi, DnsCharSetAnsi )
#define DnsRecordSetCopy(pRR)  \
        DnsRecordSetCopyEx( (pRR), DnsCharSetAnsi, DnsCharSetAnsi )
#endif


#if 0
PDNS_RECORD
WINAPI
DnsRecordCopy(
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fUnicodeIn
    );

PDNS_RECORD
DnsRecordSetCopy(
    IN  PDNS_RECORD pRR,
    IN  BOOL        fUnicodeIn
    );

PDNS_RECORD
WINAPI
DnsRecordCopy_W(
    IN      PDNS_RECORD     pRecord
    );

PDNS_RECORD
WINAPI
DnsRecordSetCopy_W(
    IN      PDNS_RECORD     pRRSet
    );

#endif


//
// Routines to copy and convert UNICODE records to other string type records
//

PDNS_RECORD
WINAPI
DnsCopyUnicodeRecordToUnicodeRecord(
    IN  PDNS_RECORD pRecord
    );

PDNS_RECORD
WINAPI
DnsCopyUnicodeRecordToUtf8Record(
    IN  PDNS_RECORD pRecord
    );

PDNS_RECORD
WINAPI
DnsCopyUnicodeRecordToAnsiRecord(
    IN  PDNS_RECORD pRecord
    );

PDNS_RECORD
DnsCopyUnicodeRRSetToUnicodeRRSet(
    IN  PDNS_RECORD pRR
    );

PDNS_RECORD
DnsCopyUnicodeRRSetToUtf8RRSet(
    IN  PDNS_RECORD pRR
    );

PDNS_RECORD
DnsCopyUnicodeRRSetToAnsiRRSet(
    IN  PDNS_RECORD pRR
    );


//
//  DNS Update API
//
//  NOTE:
//
//  The DNS update API functions have new names to clearify their use.
//  The new functions for various DNS update operations are:
//
//      DnsAcquireContextHandle
//      DnsReleaseContextHandle
//      DnsAddRecords
//      DnsAddRecordSet
//      DnsModifyRecords
//      DnsModifyRecordSet
//      DnsRemoveRecords
//      DnsReplaceRecordSet
//      DnsUpdateTest
//      DnsGetLastServerUpdateIP
//
//  The old functions have been changed to macros so
//  as not to break the build.
//

//
//  Old DNS update function definitions
//
//  Options for DnsModifyRRSet & DnsRegisterRRSet
//

//
// Update flags
//

//
// Old flags used for DnsModifyRRSet & DnsRegisterRRSet
//
#define DNS_UPDATE_UNIQUE                   0x00000000
#define DNS_UPDATE_SHARED                   0x00000001

//
// New flags used for:
//   DnsModifyRecords
//   DnsModifyRecordSet
//   DnsAddRecords
//   DnsAddRecordSet
//   DnsRemoveRecords
//   DnsReplaceRecordSet
//

#define DNS_UPDATE_SECURITY_USE_DEFAULT     0x00000000
#define DNS_UPDATE_SECURITY_OFF             0x00000010
#define DNS_UPDATE_SECURITY_ON              0x00000020
#define DNS_UPDATE_SECURITY_ONLY            0x00000100
#define DNS_UPDATE_CACHE_SECURITY_CONTEXT   0x00000200
#define DNS_UPDATE_TEST_USE_LOCAL_SYS_ACCT  0x00000400
#define DNS_UPDATE_FORCE_SECURITY_NEGO      0x00000800
#define DNS_UPDATE_RESERVED                 0xfffff000

DNS_STATUS
WINAPI
DnsAcquireContextHandle_W(
    IN  DWORD    CredentialFlags,
    IN  PVOID    Credentials OPTIONAL, // Actually this will be a
                                       // PSEC_WINNT_AUTH_IDENTITY_W,
                                       // calling this a PVOID to avoid
                                       // having to include rpcdce.h
    OUT HANDLE * ContextHandle
    );

DNS_STATUS
WINAPI
DnsAcquireContextHandle_A(
    IN  DWORD    CredentialFlags,
    IN  PVOID    Credentials OPTIONAL, // Actually this will be a
                                       // PSEC_WINNT_AUTH_IDENTITY_A,
                                       // calling this a PVOID to avoid
                                       // having to include rpcdce.h
    OUT HANDLE * ContextHandle
    );

#ifdef UNICODE
#define DnsAcquireContextHandle DnsAcquireContextHandle_W
#else
#define DnsAcquireContextHandle DnsAcquireContextHandle_A
#endif


VOID
WINAPI
DnsReleaseContextHandle(
    IN  HANDLE ContextHandle
    );


DNS_STATUS
WINAPI
DnsModifyRecords_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsModifyRecords_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsModifyRecords_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsModifyRecords DnsModifyRecords_W
#else
#define DnsModifyRecords DnsModifyRecords_A
#endif


DNS_STATUS
WINAPI
DnsModifyRecordSet_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsModifyRecordSet_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsModifyRecordSet_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsModifyRecordSet DnsModifyRecordSet_W
#else
#define DnsModifyRecordSet DnsModifyRecordSet_A
#endif


#define DnsModifyRRSet_A( _pCSet,                                    \
                          _pNSet,                                    \
                          _Options,                                  \
                          _Servers )                                 \
            ( _Options & DNS_UPDATE_SHARED ) ?                       \
                DnsModifyRecords_A( NULL,                            \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )                   \
            :                                                        \
                DnsModifyRecordSet_A( NULL,                          \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )

#define DnsModifyRRSet_W( _pCSet,                                    \
                          _pNSet,                                    \
                          _Options,                                  \
                          _Servers )                                 \
            ( _Options & DNS_UPDATE_SHARED ) ?                       \
                DnsModifyRecords_W( NULL,                            \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )                   \
            :                                                        \
                DnsModifyRecordSet_W( NULL,                          \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )

#ifdef UNICODE
#define DnsModifyRRSet( _pCSet,                                      \
                        _pNSet,                                      \
                        _Options,                                    \
                        _Servers )                                   \
            ( _Options & DNS_UPDATE_SHARED ) ?                       \
                DnsModifyRecords_W( NULL,                            \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )                   \
            :                                                        \
                DnsModifyRecordSet_W( NULL,                          \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )
#else
#define DnsModifyRRSet( _pCSet,                                      \
                        _pNSet,                                      \
                        _Options,                                    \
                        _Servers )                                   \
            ( _Options & DNS_UPDATE_SHARED ) ?                       \
                DnsModifyRecords_A( NULL,                            \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )                   \
            :                                                        \
                DnsModifyRecordSet_A( NULL,                          \
                                    ( _pCSet ),                      \
                                    ( _pNSet ),                      \
                                    DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                    ( _Servers ) )
#endif


DNS_STATUS
WINAPI
DnsAddRecords_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsAddRecords_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsAddRecords_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsAddRecords DnsAddRecords_W
#else
#define DnsAddRecords DnsAddRecords_A
#endif


DNS_STATUS
WINAPI
DnsAddRecordSet_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsAddRecordSet_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

DNS_STATUS
WINAPI
DnsAddRecordSet_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsAddRecordSet DnsAddRecordSet_W
#else
#define DnsAddRecordSet DnsAddRecordSet_A
#endif


#define DnsRegisterRRSet_A( _pRSet,                                 \
                            _Options,                               \
                            _Servers )                              \
            ( _Options & DNS_UPDATE_SHARED ) ?                      \
                DnsAddRecords_A( NULL,                              \
                                 ( _pRSet ),                        \
                                 DNS_UPDATE_SECURITY_USE_DEFAULT,   \
                                 ( _Servers ) )                     \
            :                                                       \
                DnsAddRecordSet_A( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )

#define DnsRegisterRRSet_W( _pRSet,                                 \
                            _Options,                               \
                            _Servers )                              \
            ( _Options & DNS_UPDATE_SHARED ) ?                      \
                DnsAddRecords_W( NULL,                              \
                                 ( _pRSet ),                        \
                                 DNS_UPDATE_SECURITY_USE_DEFAULT,   \
                                 ( _Servers ) )                     \
            :                                                       \
                DnsAddRecordSet_W( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )

#ifdef UNICODE
#define DnsRegisterRRSet( _pRSet,                                   \
                          _Options,                                 \
                          _Servers )                                \
            ( _Options & DNS_UPDATE_SHARED ) ?                      \
                DnsAddRecords_W( NULL,                              \
                                 ( _pRSet ),                        \
                                 DNS_UPDATE_SECURITY_USE_DEFAULT,   \
                                 ( _Servers ) )                     \
            :                                                       \
                DnsAddRecordSet_W( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )
#else
#define DnsRegisterRRSet( _pRSet,                                   \
                          _Options,                                 \
                          _Servers )                                \
            ( _Options & DNS_UPDATE_SHARED ) ?                      \
                DnsAddRecords_A( NULL,                              \
                                 ( _pRSet ),                        \
                                 DNS_UPDATE_SECURITY_USE_DEFAULT,   \
                                 ( _Servers ) )                     \
            :                                                       \
                DnsAddRecordSet_A( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )
#endif


DNS_STATUS
WINAPI
DnsRemoveRecords_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsRemoveRecords_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsRemoveRecords_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

#ifdef UNICODE
#define DnsRemoveRecords DnsRemoveRecords_W
#else
#define DnsRemoveRecords DnsRemoveRecords_A
#endif


#define DnsRemoveRRSet_A( _pRSet,                                \
                          _Servers )                             \
            DnsRemoveRecords_A( NULL,                            \
                                ( _pRSet ),                      \
                                DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                ( _Servers ) )

#define DnsRemoveRRSet_W( _pRSet,                                \
                          _Servers )                             \
            DnsRemoveRecords_W( NULL,                            \
                                ( _pRSet ),                      \
                                DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                ( _Servers ) )

#ifdef UNICODE
#define DnsRemoveRRSet( _pRSet,                                  \
                        _Servers )                               \
            DnsRemoveRecords_W( NULL,                            \
                                ( _pRSet ),                      \
                                DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                ( _Servers ) )
#else
#define DnsRemoveRRSet( _pRSet,                                  \
                        _Servers )                               \
            DnsRemoveRecords_A( NULL,                            \
                                ( _pRSet ),                      \
                                DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                ( _Servers ) )
#endif


DNS_STATUS
WINAPI
DnsReplaceRecordSet_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsReplaceRecordSet_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsReplaceRecordSet_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  PDNS_RECORD pRRSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsReplaceRecordSet DnsReplaceRecordSet_W
#else
#define DnsReplaceRecordSet DnsReplaceRecordSet_A
#endif


#define DnsReplaceRRSet_A( _pRSet,                                  \
                           _Servers )                               \
            DnsReplaceRecordSet_A( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )

#define DnsReplaceRRSet_W( _pRSet,                                  \
                           _Servers )                               \
            DnsReplaceRecordSet_W( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )

#ifdef UNICODE
#define DnsReplaceRRSet( _pRSet,                                    \
                         _Servers )                                 \
            DnsReplaceRecordSet_W( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )
#else
#define DnsReplaceRRSet( _pRSet,                                    \
                         _Servers )                                 \
            DnsReplaceRecordSet_A( NULL,                            \
                                   ( _pRSet ),                      \
                                   DNS_UPDATE_SECURITY_USE_DEFAULT, \
                                   ( _Servers ) )
#endif


DNS_STATUS
WINAPI
DnsUpdateTest_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  LPSTR       pszName,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsUpdateTest_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  LPSTR       pszName,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsUpdateTest_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  LPWSTR      pszName,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsUpdateTest DnsUpdateTest_W
#else
#define DnsUpdateTest DnsUpdateTest_A
#endif


IP_ADDRESS
WINAPI
DnsGetLastServerUpdateIP (
    VOID
    );



//
//  DNS Query API
//

//
//  Options for DnsQuery
//

#define DNS_QUERY_STANDARD                  0x00000000
#define DNS_QUERY_ACCEPT_PARTIAL_UDP        0x00000001
#define DNS_QUERY_USE_TCP_ONLY              0x00000002
#define DNS_QUERY_NO_RECURSION              0x00000004
#define DNS_QUERY_BYPASS_CACHE              0x00000008
#define DNS_QUERY_CACHE_ONLY                0x00000010
#define DNS_QUERY_SOCKET_KEEPALIVE          0x00000100
#define DNS_QUERY_TREAT_AS_FQDN             0x00001000
#define DNS_QUERY_ALLOW_EMPTY_AUTH_RESP     0x00010000
#define DNS_QUERY_RESERVED                  0xfff00000

#define DNS_QUERY_ACCEPT_TRUNCATED_RESPONSE DNS_QUERY_ACCEPT_PARTIAL_UDP


DNS_STATUS WINAPI
DnsQuery_A(
    IN     LPSTR          lpstrName,
    IN     WORD           wType,
    IN     DWORD          fOptions,
    IN     PIP_ARRAY      aipServers            OPTIONAL,
    IN OUT PDNS_RECORD *  ppQueryResultsSet     OPTIONAL,
    IN OUT PVOID *        pReserved             OPTIONAL
    );

DNS_STATUS WINAPI
DnsQuery_UTF8(
    IN     LPSTR          lpstrName,
    IN     WORD           wType,
    IN     DWORD          fOptions,
    IN     PIP_ARRAY      aipServers            OPTIONAL,
    IN OUT PDNS_RECORD *  ppQueryResultsSet     OPTIONAL,
    IN OUT PVOID *        pReserved             OPTIONAL
    );

DNS_STATUS WINAPI
DnsQuery_W(
    IN     LPWSTR         lpstrName,
    IN     WORD           wType,
    IN     DWORD          fOptions,
    IN     PIP_ARRAY      aipServers            OPTIONAL,
    IN OUT PDNS_RECORD *  ppQueryResultsSet     OPTIONAL,
    IN OUT PVOID *        pReserved             OPTIONAL
    );

#ifdef UNICODE
#define DnsQuery DnsQuery_W
#else
#define DnsQuery DnsQuery_A
#endif


//
// Options for DnsCheckNameCollision
//

#define DNS_CHECK_AGAINST_HOST_ANY              0x00000000
#define DNS_CHECK_AGAINST_HOST_ADDRESS          0x00000001
#define DNS_CHECK_AGAINST_HOST_DOMAIN_NAME      0x00000002


DNS_STATUS WINAPI
DnsCheckNameCollision_A (
    IN  LPSTR pszName,
    IN  DWORD fOptions
    );

DNS_STATUS WINAPI
DnsCheckNameCollision_UTF8 (
    IN  LPSTR pszName,
    IN  DWORD fOptions
    );

DNS_STATUS WINAPI
DnsCheckNameCollision_W (
    IN  LPWSTR pszName,
    IN  DWORD  fOptions
    );

#ifdef UNICODE
#define DnsDnsCheckNameCollision DnsCheckNameCollision_W
#else
#define DnsDnsCheckNameCollision DnsCheckNameCollision_A
#endif


LPSTR WINAPI
DnsGetHostName_A(
    VOID
    );

LPSTR WINAPI
DnsGetHostName_UTF8(
    VOID
    );

LPWSTR WINAPI
DnsGetHostName_W(
    VOID
    );

#ifdef UNICODE
#define DnsGetHostName DnsGetHostName_W
#else
#define DnsGetHostName DnsGetHostName_A
#endif


LPSTR WINAPI
DnsGetPrimaryDomainName_A(
    VOID
    );

LPSTR WINAPI
DnsGetPrimaryDomainName_UTF8(
    VOID
    );

LPWSTR WINAPI
DnsGetPrimaryDomainName_W(
    VOID
    );

#ifdef UNICODE
#define DnsGetPrimaryDomainName DnsGetPrimaryDomainName_W
#else
#define DnsGetPrimaryDomainName DnsGetPrimaryDomainName_A
#endif



//
//  DNS Update API for DHCP client
//

typedef struct  _REGISTER_HOST_ENTRY
{
     union
     {
         IP_ADDRESS    ipAddr;
         IPV6_ADDRESS  ipV6Addr;
     } Addr;
     DWORD       dwOptions;
}
REGISTER_HOST_ENTRY, *PREGISTER_HOST_ENTRY;

//
//  Options for above
//

#define REGISTER_HOST_A             0x00000001
#define REGISTER_HOST_PTR           0x00000002  // Used by DHCP server
#define REGISTER_HOST_TRANSIENT     0x00000004  // Don't use, use DYNDNS_REG_RAS
#define REGISTER_HOST_AAAA          0x00000008
#define REGISTER_HOST_RESERVED      0x80000000  // Not used

#define DYNDNS_REG_FWD      0x0
#define DYNDNS_REG_PTR      0x8
#define DYNDNS_REG_RAS      0x10
#define DYNDNS_DEL_ENTRY    0x20


typedef struct  _REGISTER_HOST_STATUS
{
     HANDLE      hDoneEvent;
     DWORD       dwStatus;
}
REGISTER_HOST_STATUS, *PREGISTER_HOST_STATUS;

DNS_STATUS
WINAPI
DnsAsyncRegisterInit(
   LPSTR lpstrRootRegKey
   );

DNS_STATUS
WINAPI
DnsAsyncRegisterTerm(
   VOID
   );

DNS_STATUS WINAPI
DnsRemoveRegistrations(
   VOID
   );

DNS_STATUS
WINAPI
DnsAsyncRegisterHostAddrs_W(
    IN  LPWSTR                lpstrAdapterName,
    IN  LPWSTR                lpstrHostName,
    IN  PREGISTER_HOST_ENTRY  pHostAddrs,
    IN  DWORD                 dwHostAddrCount,
    IN  PIP_ADDRESS           pipDnsServerList,
    IN  DWORD                 dwDnsServerCount,
    IN  LPWSTR                lpstrDomainName,
    IN  PREGISTER_HOST_STATUS pRegisterStatus,
    IN  DWORD                 dwTTL,
    IN  DWORD                 dwFlags
    );

DNS_STATUS
WINAPI
DnsAsyncRegisterHostAddrs_UTF8(
    IN  LPSTR                 lpstrAdapterName,
    IN  LPSTR                 lpstrHostName,
    IN  PREGISTER_HOST_ENTRY  pHostAddrs,
    IN  DWORD                 dwHostAddrCount,
    IN  PIP_ADDRESS           pipDnsServerList,
    IN  DWORD                 dwDnsServerCount,
    IN  LPSTR                 lpstrDomainName,
    IN  PREGISTER_HOST_STATUS pRegisterStatus,
    IN  DWORD                 dwTTL,
    IN  DWORD                 dwFlags
    );

DNS_STATUS
WINAPI
DnsAsyncRegisterHostAddrs_A(
    IN  LPSTR                 lpstrAdapterName,
    IN  LPSTR                 lpstrHostName,
    IN  PREGISTER_HOST_ENTRY  pHostAddrs,
    IN  DWORD                 dwHostAddrCount,
    IN  PIP_ADDRESS           pipDnsServerList,
    IN  DWORD                 dwDnsServerCount,
    IN  LPSTR                 lpstrDomainName,
    IN  PREGISTER_HOST_STATUS pRegisterStatus,
    IN  DWORD                 dwTTL,
    IN  DWORD                 dwFlags
    );

#ifdef UNICODE
#define DnsAsyncRegisterHostAddrs DnsAsyncRegisterHostAddrs_W
#else
#define DnsAsyncRegisterHostAddrs DnsAsyncRegisterHostAddrs_A
#endif


//
//  DNS Update API for DHCP server.
//

//
//  Call back function. DHCP Server will pass a function to
//  DnsDhcpRegisterHostName and this will be called on successful
//  or unsuccessful completion of the task
//  If we have a condition like server down/try again later etc we
//  won't respond until we have an authoritative answer.
//

typedef VOID(*DHCP_CALLBACK_FN)(DWORD dwStatus, LPVOID pvData);

//
//  Callback return codes
//

#define     DNSDHCP_SUCCESS         0x0
#define     DNSDHCP_FWD_FAILED      0x1
#define     DNSDHCP_SUPERCEDED      0x2

#define     DNSDHCP_FAILURE         (DWORD)-1 //reverse failed

#define     DYNDNS_DELETE_ENTRY     0x1
#define     DYNDNS_ADD_ENTRY        0x2
#define     DYNDNS_REG_FORWARD      0x4

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterInit(
    VOID
    );

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterTerm(
    VOID
    );

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterHostName_A(
    IN REGISTER_HOST_ENTRY HostAddr,
    IN LPSTR               pszName,
    IN DWORD               dwTTL,
    IN DWORD               dwFlags,
    IN DHCP_CALLBACK_FN    pfnDhcpCallBack,
    IN PVOID               pvData,
    IN PIP_ADDRESS         pipDnsServerList OPTIONAL,
    IN DWORD               dwDnsServerCount
    );

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterHostName_UTF8(
    IN REGISTER_HOST_ENTRY HostAddr,
    IN LPSTR               pszName,
    IN DWORD               dwTTL,
    IN DWORD               dwFlags,
    IN DHCP_CALLBACK_FN    pfnDhcpCallBack,
    IN PVOID               pvData,
    IN PIP_ADDRESS         pipDnsServerList OPTIONAL,
    IN DWORD               dwDnsServerCount
    );

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterHostName_W(
    IN REGISTER_HOST_ENTRY HostAddr,
    IN LPWSTR              pszName,
    IN DWORD               dwTTL,
    IN DWORD               dwFlags,
    IN DHCP_CALLBACK_FN    pfnDhcpCallBack,
    IN PVOID               pvData,
    IN PIP_ADDRESS         pipDnsServerList OPTIONAL,
    IN DWORD               dwDnsServerCount
    );

#define DnsDhcpSrvRegisterHostName  DnsDhcpSrvRegisterHostName_A

#define RETRY_TIME_SERVER_FAILURE        5*60  // 5 minutes
#define RETRY_TIME_TRY_AGAIN_LATER       5*60  // 5 minutes
#define RETRY_TIME_TIMEOUT               5*60  // 5 minutes

#define RETRY_TIME_MAX                   10*60 // back off to 10 mins if
                                               // repeated failures occur




//
//  Memory allocation
//
//  Many dnsapi.dll routines allocate memory.
//  This memory allocation defaults to routines that use:
//      - LocalAlloc,
//      - LocalReAlloc,
//      - LocalFree.
//  If you desire alternative memory allocation mechanisms, use this
//  function to override the DNS API defaults.  All memory returned by dnsapi.dll
//  can then be freed with the specified free function.
//

typedef PVOID (* DNS_ALLOC_FUNCTION)();
typedef PVOID (* DNS_REALLOC_FUNCTION)();
typedef VOID (* DNS_FREE_FUNCTION)();

VOID
DnsApiHeapReset(
    IN  DNS_ALLOC_FUNCTION      pAlloc,
    IN  DNS_REALLOC_FUNCTION    pRealloc,
    IN  DNS_FREE_FUNCTION       pFree
    );

//
//  Modules using DNSAPI memory should use these routines if
//  they are capable of being called by a process that resets
//  the dnsapi.dll heap.  (Example:  the DNS server.)
//

PVOID
DnsApiAlloc(
    IN      INT             iSize
    );

PVOID
DnsApiRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );

VOID
DnsApiFree(
    IN OUT  PVOID           pMem
    );


//
//  String utilities (string.c)
//
//  Note some of these require memory allocation, see note
//  on memory allocation below.
//

#define DNS_ALLOW_RFC_NAMES_ONLY    (0)
#define DNS_ALLOW_NONRFC_NAMES      (0x00000001)
#define DNS_ALLOW_MULTIBYTE_NAMES   (0x00000002)
#define DNS_ALLOW_ALL_NAMES         (0x00000003)


LPSTR
DnsCreateStringCopy(
    IN      PCHAR       pchString,
    IN      DWORD       cchString
    );

DWORD
DnsGetBufferLengthForStringCopy(
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    );

PVOID
DnsCopyStringEx(
    OUT     PBYTE       pBuffer,
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    );

PVOID
DnsStringCopyAllocateEx(
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    );

PCHAR
DnsWriteReverseNameStringForIpAddress(
    OUT     PCHAR       pBuffer,
    IN      IP_ADDRESS  ipAddress
    );

PCHAR
DnsCreateReverseNameStringForIpAddress(
    IN      IP_ADDRESS  ipAddress
    );



//
//  Name validation
//

typedef enum _DNS_NAME_FORMAT
{
    DnsNameDomain,
    DnsNameDomainLabel,
    DnsNameHostnameFull,
    DnsNameHostnameLabel,
    DnsNameWildcard,
    DnsNameSrvRecord
}
DNS_NAME_FORMAT;


DNS_STATUS
DnsValidateName_UTF8(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    );

DNS_STATUS
DnsValidateName_W(
    IN      LPCWSTR         pwszName,
    IN      DNS_NAME_FORMAT Format
    );

DNS_STATUS
DnsValidateName_A(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    );

#ifdef UNICODE
#define DnsValidateName(p,f)    DnsValidateName_W( (p), (f) )
#else
#define DnsValidateName(p,f)    DnsValidateName_A( (p), (f) )
#endif


//
//  Macro away old routines
//

#define DnsValidateDnsName_UTF8(pname)  \
        DnsValidateName_UTF8( (pname), DnsNameDomain )

#define DnsValidateDnsName_W(pname) \
        DnsValidateName_W( (pname), DnsNameDomain )


//
//  Relational name compare result
//
typedef enum
{
   DNS_RELATE_NEQ,         // NOT EQUAL: name's in different name space.
   DNS_RELATE_EQL,         // EQUAL: name's are identical DNS names
   DNS_RELATE_LGT,         // LEFT GREATER THAN: left name is parent (contains) to right name
   DNS_RELATE_RGT,         // RIGHT GREATER THAN: right name is parent (contains) to left name
   DNS_RELATE_INVALID      // INVALID STATE: accompanied with DNS_STATUS return code
} DNS_RELATE_STATUS, *PDNS_RELATE_STATUS;

DNS_STATUS
DnsRelationalCompare_UTF8(
    IN      LPCSTR      pszLeftName,
    IN      LPCSTR      pszRightName,
    IN      DWORD       dwReserved,
    IN OUT DNS_RELATE_STATUS  *pRelation
    );

DNS_STATUS
DnsRelationalCompare_W(
    IN      LPCWSTR      pszLeftName,
    IN      LPCWSTR      pszRightName,
    IN      DWORD       dwReserved,
    IN OUT  DNS_RELATE_STATUS  *pRelation
    );

DNS_STATUS
DnsValidateDnsString_UTF8(
    IN      LPCSTR      pszName
    );

DNS_STATUS
DnsValidateDnsString_W(
    IN      LPCWSTR     pszName
    );

LPSTR
DnsCreateStandardDnsNameCopy(
    IN      PCHAR       pchName,
    IN      DWORD       cchName,
    IN      DWORD       dwFlag
    );

DWORD
DnsDowncaseDnsNameLabel(
    OUT     PCHAR       pchResult,
    IN      PCHAR       pchLabel,
    IN      DWORD       cchLabel,
    IN      DWORD       dwFlags
    );

DWORD
_fastcall
DnsUnicodeToUtf8(
    IN      PWCHAR      pwUnicode,
    IN      DWORD       cchUnicode,
    OUT     PCHAR       pchResult,
    IN      DWORD       cchResult
    );

DWORD
_fastcall
DnsUtf8ToUnicode(
    IN      PCHAR       pchUtf8,
    IN      DWORD       cchUtf8,
    OUT     PWCHAR      pwResult,
    IN      DWORD       cwResult
    );

DNS_STATUS
DnsValidateUtf8Byte(
    IN      BYTE        chUtf8,
    IN OUT  PDWORD      pdwTrailCount
    );


//
// Routines for NT services to call to get a Service Control Manager
// control message, (i.e. SERVICE_CONTROL_PARAMCHANGE - 0x00000006, etc.), in
// the event of a PnP change that affects DNS related data.
//

BOOL WINAPI
DnsServiceNotificationRegister_W (
    IN  LPWSTR pszServiceName,
    IN  DWORD  dwControl
    );

BOOL WINAPI
DnsServiceNotificationRegister_UTF8 (
    IN  LPSTR pszServiceName,
    IN  DWORD  dwControl
    );

BOOL WINAPI
DnsServiceNotificationRegister_A (
    IN  LPSTR pszServiceName,
    IN  DWORD  dwControl
    );

#ifdef UNICODE
#define DnsServiceNotificationRegister DnsServiceNotificationRegister_W
#else
#define DnsServiceNotificationRegister DnsServiceNotificationRegister_A
#endif

BOOL WINAPI
DnsServiceNotificationDeregister_W (
    IN  LPWSTR pszServiceName
    );

BOOL WINAPI
DnsServiceNotificationDeregister_UTF8 (
    IN  LPSTR pszServiceName
    );

BOOL WINAPI
DnsServiceNotificationDeregister_A (
    IN  LPSTR pszServiceName
    );

#ifdef UNICODE
#define DnsServiceNotificationDeregister DnsServiceNotificationDeregister_W
#else
#define DnsServiceNotificationDeregister DnsServiceNotificationDeregister_A
#endif


//
// Routines to clear all cached entries in the DNS Resolver Cache, this is
// called by ipconfig /flushdns, and add record sets to the cache.
//

BOOL WINAPI
DnsFlushResolverCache (
    VOID
    );

BOOL WINAPI
DnsFlushResolverCacheEntry_W (
    IN  LPWSTR pszName
    );

BOOL WINAPI
DnsFlushResolverCacheEntry_UTF8 (
    IN  LPSTR pszName
    );

BOOL WINAPI
DnsFlushResolverCacheEntry_A (
    IN  LPSTR pszName
    );

#ifdef UNICODE
#define DnsFlushResolverCacheEntry DnsFlushResolverCacheEntry_W
#else
#define DnsFlushResolverCacheEntry DnsFlushResolverCacheEntry_A
#endif


DNS_STATUS WINAPI
DnsCacheRecordSet_W(
    IN     LPWSTR      lpstrName,
    IN     WORD        wType,
    IN     DWORD       fOptions,
    IN OUT PDNS_RECORD pRRSet
    );


//
// Routines to enable or disable B-Node resolver service listening thread
//

VOID WINAPI
DnsEnableBNodeResolverThread (
    VOID
    );

VOID WINAPI
DnsDisableBNodeResolverThread (
    VOID
    );


//
// Routines to enable or disable dynamic DNS registrations on local machine
//

VOID WINAPI
DnsEnableDynamicRegistration (
    LPWSTR szAdapterName OPTIONAL   // If NULL, enables DDNS in general
    );

VOID WINAPI
DnsDisableDynamicRegistration (
    LPWSTR szAdapterName OPTIONAL   // If NULL, disables DDNS in general
    );

BOOL
DnsIsDynamicRegistrationEnabled (
    LPWSTR szAdapterName OPTIONAL   // If NULL, tells whether system has
    );                              // DDNS enabled.


//
// Routines to enable or disable dynamic DNS registration of a given
// adapter's domain name on the local machine
//

VOID WINAPI
DnsEnableAdapterDomainNameRegistration (
    LPWSTR szAdapterName
    );

VOID WINAPI
DnsDisableAdapterDomainNameRegistration (
    LPWSTR szAdapterName
    );

BOOL
DnsIsAdapterDomainNameRegistrationEnabled (
    LPWSTR szAdapterName
    );


//
// Routines to write a DNS Query packet request question in a buffer and
// convert response packet buffer to DNS_RECORD structure list.
//

typedef struct _DNS_MESSAGE_BUFFER
{
    DNS_HEADER MessageHead;
    CHAR       MessageBody[1];
}
DNS_MESSAGE_BUFFER, *PDNS_MESSAGE_BUFFER;

BOOL WINAPI
DnsWriteQuestionToBuffer_W (
    IN OUT PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN OUT LPDWORD             pdwBufferSize,
    IN     LPWSTR              pszName,
    IN     WORD                wType,
    IN     WORD                Xid,
    IN     BOOL                fRecursionDesired
    );

BOOL WINAPI
DnsWriteQuestionToBuffer_UTF8 (
    IN OUT PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN OUT LPDWORD             pdwBufferSize,
    IN     LPSTR               pszName,
    IN     WORD                wType,
    IN     WORD                Xid,
    IN     BOOL                fRecursionDesired
    );


DNS_STATUS WINAPI
DnsExtractRecordsFromMessage_W (
    IN  PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN  WORD                wMessageLength,
    OUT PDNS_RECORD *       ppRecord
    );

DNS_STATUS WINAPI
DnsExtractRecordsFromMessage_UTF8 (
    IN  PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN  WORD                wMessageLength,
    OUT PDNS_RECORD *       ppRecord
    );


//
// Routine to read the contents of the DNS Resolver Cache. The resulting
// table contains a list of record names and types stored in the cache.
// Each of these name/type records can be queried with DnsQuery with the
// option DNS_QUERY_CACHE_ONLY.
//

typedef struct _DNS_CACHE_TABLE_
{
    struct _DNS_CACHE_TABLE_ * pNext;
    LPWSTR                     Name;
    WORD                       Type1;
    WORD                       Type2;
    WORD                       Type3;
}
DNS_CACHE_TABLE, *PDNS_CACHE_TABLE;

BOOL WINAPI
DnsGetCacheDataTable (
    OUT PDNS_CACHE_TABLE * pTable
    );


//
//  Backward compatibility
//
//  Previously exposed functions now macroed to new functions.
//  Eventually need to clean this stuff out of build or
//  separate these defs from public headers
//

#define DNSBACKCOMPAT 1

#ifdef DNSBACKCOMPAT
#ifdef UNICODE
#define DnsCompareName(p1,p2)   DnsNameCompare_W( (p1), (p2) )
#else
#define DnsCompareName(p1,p2)   DnsNameCompare( (p1), (p2) )
#endif

#define DnsCompareName_W(p1,p2)   DnsNameCompare_W( (p1), (p2) )
#define DnsCompareName_A(p1,p2)   DnsNameCompare( (p1), (p2) )

#ifdef UNICODE
#define DnsCopyRR(pRR)  DnsRecordCopy( pRR, TRUE )
#else
#define DnsCopyRR(pRR)  DnsRecordCopy( pRR, FALSE )
#endif

#ifdef UNICODE
#define DnsCopyRRSet(pRRSet)    DnsRecordSetCopy( pRRSet, TRUE )
#else
#define DnsCopyRRSet(pRRSet)    DnsRecordSetCopy( pRRSet, FALSE )
#endif


//  Async registration only from DHCP client.
//  Once it is cleanedup, these can be deleted.

#define DnsMHAsyncRegisterInit(a)   DnsAsyncRegisterInit(a)
#define DnsMHAsyncRegisterTerm()    DnsAsyncRegisterTerm()
#define DnsMHRemoveRegistrations()  DnsRemoveRegistrations()

#define DnsMHAsyncRegisterHostAddrs_A(a,b,c,d,e,f,g,h,i,j) \
        DnsAsyncRegisterHostAddrs_A(a,b,c,d,e,f,g,h,i,j)

#define DnsMHAsyncRegisterHostAddrs_W(a,b,c,d,e,f,g,h,i,j) \
        DnsAsyncRegisterHostAddrs_W(a,b,c,d,e,f,g,h,i,j)

#define DnsMHAsyncRegisterHostAddrs_UTF8(a,b,c,d,e,f,g,h,i,j) \
        DnsAsyncRegisterHostAddrs_UTF8(a,b,c,d,e,f,g,h,i,j)

//  cleanup after clean build

#define DnsNameCompare(a,b) \
        DnsNameCompare_A((a),(b))

#endif DNSBACKCOMPAT



#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSAPI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\exver.h ===
#include <ntverp.h>
#include "iisver.h"

//
// Undo IIS's definitions and use our own
//
#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif
#define VER_PRODUCTNAME_STR			"Microsoft(R) Internet Services"

#ifdef VER_FILEVERSION
#undef VER_FILEVERSION
#endif

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#ifdef VER_FILESUBTYPE
#undef VER_FILESUBTYPE
#endif

#ifndef rmj
#define rmj VER_IISMAJORVERSION
#endif // !rmj 
#ifndef rmn
#define rmn VER_IISMINORVERSION
#endif // !rmn 
#define rmm VER_IISPRODUCTBUILD
#define rup 0
#define szVerName ""
#define szVerUser "_mpubld"


#ifdef MAC
#ifndef _rmacmaj
#define _rmacmaj 0x6
#endif
#ifndef _rmacmin
#define _rmacmin 0x
#endif
#ifndef _rmacint
#define _rmacint 0x
#endif
#ifndef _rmactype
#define _rmactype 
#endif
#ifndef _rmacstr
#define _rmacstr "6.0"
#endif
#endif //MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\fdlhash.h ===
/*++
	FDLHash.h

	This file contains a template class for a hash table.

	The templates used in here build off the templates in tfdlist.h for
	doubly linked lists.  The bucket chains implemented in this version
	of the hash table are doubly linked lists.

	The Data type must support the following :

	class Data {
		DLSIT_ENTRY	m_list;

		KEYREF	GetKey(	) ;

	} ;

	int		MatchKey(	KEYREF	otherkey, KEYREF	otherkey) ;	/* NOTE : MatchKey returns non-zero on equality
	DWORD	(* m_pfnReHash)(Data* p ) ;
	DWORD	(* m_pfnHash)( KEYREF k ) ;	
	
--*/

#ifndef	_FDLHASH_H_
#define	_FDLHASH_H_

#include	"tfdlist.h"


class	CHashStats	{
public :
	enum	COUNTER	{
		HASHITEMS = 0,		// Number of items in the hash table
		INSERTS,			// Number of times Insert has been called
		SPLITINSERTS,		// Number of inserts until the next split !
		DELETES,			// Number of times Delete has been called
		SEARCHES,			// Number of times Search has been called
		SEARCHHITS,			// Number of times we Search and find something !
		SPLITS,				// Number of times we've split the table on an insert !
		REALLOCS,			// Number of times we've reallocated memory for a split
		DEEPBUCKET,			// The deepest bucket we have !
		AVERAGEBUCKET,		// The average depth of the buckets
		EMPTYBUCKET,		// The number of Empty buckets !
		ALLOCBUCKETS,		// Number of buckets we've allocated
		ACTIVEBUCKETS,		// Number of Active buckets
		AVERAGESEARCH,		// Average number of buckets we examine each search
		DEEPSEARCH,			// Longest walk we do on a search
		SEARCHCOST,			// Sum of the number of items we've visited for all search hits !
		SEARCHCOSTMISS,		// Sum of the number of items we've visited for search misses !
		MAX_HASH_STATS		// Number of statistics we report !
	} ;

	long	m_cHashCounters[MAX_HASH_STATS] ;

	CHashStats()	{
		ZeroMemory( m_cHashCounters, sizeof( m_cHashCounters ) ) ;
		//m_cHashCounters[SMALLSEARCH] = 0x7FFF ;
	}

	static	inline	void
	IncrementStat(	CHashStats*	p, CHashStats::COUNTER	c ) {
		_ASSERT( c < CHashStats::MAX_HASH_STATS ) ;
		if( p != 0 ) {
			InterlockedIncrement( &p->m_cHashCounters[c] ) ;
		}
	}

	static	inline	void
	AddStat(	CHashStats*p, CHashStats::COUNTER	c, long	l ) {
		_ASSERT( c < CHashStats::MAX_HASH_STATS ) ;
		if( p != 0 ) {
			InterlockedExchangeAdd( &p->m_cHashCounters[c], l ) ;
		}
	}

	static	inline	void
	DecrementStat(	CHashStats* p, CHashStats::COUNTER	c )		{
		_ASSERT( c < CHashStats::MAX_HASH_STATS ) ;
		if( p != 0 ) {
			InterlockedDecrement( &p->m_cHashCounters[c] ) ;
		}
	}

	static	inline	void
	SetStat(	CHashStats*	p, CHashStats::COUNTER c, long l ) {
		_ASSERT( c < CHashStats::MAX_HASH_STATS ) ;
		if( p != 0 ) {
			p->m_cHashCounters[c] = l ;
		}
	}

} ;

#ifdef	METER
#define	INCREMENTSTAT( s )	CHashStats::IncrementStat( m_pStat, CHashStats::##s )
#define	DECREMENTSTAT( s )	CHashStats::DecrementStat( m_pStat, CHashStats::##s )
#define	ADDSTAT( s, a )		CHashStats::AddStat( m_pStat, CHashStats::##s, a )
#define	SETSTAT( s, a )		CHashStats::SetStat( m_pStat, CHashStats::##s, a )
//#if 0
#define	MAXBUCKET( i )		MaxBucket( i )
#define	AVERAGEBUCKET()		AverageBucket()
//#else
//#define	MAXBUCKET( i )
//#define	AVERAGEBUCKET()
//#endif
#else	// METER
#define	INCREMENTSTAT( s )
#define	DECREMENTSTAT( s )
#define	ADDSTAT( s, a )
#define	SETSTAT( s, a )
#define	MAXBUCKET( i )
#define	AVERAGEBUCKET()
#endif	// METER

template<	class	HASHTABLE	>	
class	TFDLHashIterator	{
private :

	//
	//	The hash table that the item is in !
	//
	HASHTABLE*			m_pTable ;

	//
	//	The bucket we are walking on !
	//
	int					m_iBucket ;

	//
	//	Keep track of our position in a list !
	//
	HASHTABLE::ITER		m_Iter ;

	//
	//	Move between hash table buckets as necessary !
	//
	void
	PrevBucket()	{
		_ASSERT( m_iBucket >= 0 && m_iBucket < m_pTable->m_cActiveBuckets ) ;
		_ASSERT( m_Iter.AtEnd() ) ;
		if( m_iBucket > 0 ) {
			do	{
				m_Iter.ReBind( &m_pTable->m_pBucket[--m_iBucket] ) ; 			
			}	while( m_Iter.AtEnd() && m_iBucket > 0 ) ;
		}
		_ASSERT( m_iBucket >= 0 && m_iBucket < m_pTable->m_cActiveBuckets ) ;
	}

	//
	//	Move between hash table buckets as necessary !
	//
	void
	NextBucket()	{
		_ASSERT( m_iBucket >= 0 && m_iBucket < m_pTable->m_cActiveBuckets ) ;
		_ASSERT( m_Iter.AtEnd() ) ;

		if( m_iBucket < m_pTable->m_cActiveBuckets-1 ) {
			do	{
				m_Iter.ReBind( &m_pTable->m_pBucket[++m_iBucket] ) ;
			}	while( m_Iter.AtEnd() && m_iBucket < m_pTable->m_cActiveBuckets-1 ) ;
		}
		_ASSERT( m_iBucket >= 0 && m_iBucket < m_pTable->m_cActiveBuckets ) ;
	}

public :

	typedef	HASHTABLE::DATA	DATA ;

	TFDLHashIterator( HASHTABLE&	ref, BOOL fForward = TRUE ) :
		m_pTable( &ref ),
		m_iBucket( fForward ? 0 : ref.m_cActiveBuckets-1 ),
		m_Iter( ref.m_pBucket[m_iBucket] )	{

		if( m_Iter.AtEnd() ) {
			if( fForward ) {
				NextBucket() ;
			}	else	{
				PrevBucket() ;
			}
		}
	}

	void
	Prev()	{
	/*++

	Routine Description :

		This function moves the iterator back one slot.

	Arguments :

		None.

	Return	Value :

		None.

	--*/
	
		m_Iter.Prev() ;
		if( m_Iter.AtEnd() ) {
			PrevBucket() ;
		}				
	}

	void
	Next()	{
	/*++

	Routine Description :

		This function moves the iterator forward one slot.

	Arguments :

		None.

	Return	Value :

		None.

	--*/
		m_Iter.Next() ;
		if( m_Iter.AtEnd() )	{
			NextBucket() ;
		}

	}
	void
	Front()	{
	/*++

	Routine Description :

		Reset the iterator to reference the first item of the list !

	Arguments :

		None.

	Return	Value :

		None.

	--*/

		m_Iter.ReBind( &m_pTable->m_pBucket[0], TRUE ) ;
		m_iBucket = 0 ;
		if( m_Iter.AtEnd() ) {
			NextBucket() ;
		}
	}
	void
	Back()	{
	/*++

	Routine Description :

		Reset the iterator to reference the last item of the list !

	Arguments :

		None.

	Return	Value :

		None.

	--*/
	
		m_Iter.ReBind( &m_pTable->m_pBucket[m_pTable->m_cActiveBuckets-1], FALSE ) ;
		m_iBucket = m_pTable->m_cActiveBuckets-1 ;
		if( m_Iter.AtEnd() ) {
			PrevBucket() ;
		}
	}

	BOOL
	AtEnd()	{
	/*++

	Routine Description :

		Return TRUE if we are at the end of the list !
		This is a little more complicated to compute -
		depends on which way we are going !

	Arguments :

		None.

	Return	Value :

		None.

	--*/
		return	m_Iter.AtEnd() ;
	}

	DATA*	
	CurrentEntry()	{
		return	m_Iter.Current() ;
	}

	DATA*
	RemoveItem()	{
	/*++

	Routine Description :

		Remove the item that the iterator currently
		references from the list.
		If we are going forward then the iterator
		will be setting on the previous element,
		otherwise the iterator is left on the next element.
		We have to take care that we don't leave the iterator
		sitting on an invalid element.

	Arguments :

		None.

	Return	Value :

		Pointer to the removed item.

	--*/

		DATA*	pData = m_Iter.RemoveItem() ;
		if( pData ) {
			m_pTable->NotifyOfRemoval() ;
		}
		if( m_Iter.AtEnd() ) {
			if( m_Iter.m_fForward ) {
				NextBucket() ;
			}	else	{
				PrevBucket() ;
			}
		}
		return	pData ;
	}



	inline DATA*
	Current( ) {
		return	m_Iter.Current() ;
	}

	inline void
	InsertBefore(	DATA*	p )		{
		m_Iter.InsertBefore( p ) ;
	}
	
	inline void
	InsertAfter(	DATA*	p )		{
		m_Iter.InsertAfter( p ) ;
	}
} ;


//------------------------------------------------------------
template<	class	Data,		/* This is the item that resides in the hashtable */
			class	KEYREF,		/* This is the type used to point or reference items in the cache*/
			Data::PFNDLIST	pfnDlist,
			BOOL	fOrdered = TRUE
			>
class	TFDLHash	{
//
//	This class defines a Hash table which can grow dynamically to
//	accomodate insertions into the table.  The table only grows, and
//	does not shrink.
//
public :

	//
	//	This is the iterator object that can walk the hash table !
	//
	friend	class	TFDLHashIterator<	TFDLHash< Data, KEYREF, pfnDlist > > ;

	//
	//	This is the type of the Data item !
	//
	//typedef	DATAHELPER		Data ;
	typedef	KEYREF	(Data::*GETKEY)() ;

	//
	//	This is the type that we use to maintain doubly linked lists of
	//	hash table items !
	//
	typedef	TDListHead< Data, pfnDlist >	DLIST ;	
	
	//
	//	This is the type we use to make iterators over the bucket chains !
	//
	typedef	TDListIterator< DLIST >		ITER ;

	//
	//	Define this type for our iterators !
	//
	typedef	Data	DATA ;

	//
	//	This is a member function pointer to a function which
	//	will retrieve the key we are to use !
	//
	//typedef	KEYREF	(Data::*GETKEY)( ) ;
	//typedef	Data::GETKEY	GETKEY ;

	//
	//	This is the type of function that computes the hash value !
	//
	typedef	DWORD	(*PFNHASH)( KEYREF ) ;

	//
	//	This is the type of function that can recompute the hash value when
	//	we are splitting up the hash table !
	//
	typedef	DWORD	(*PFNREHASH)( Data* ) ;

	//
	//	This is a member function pointer of the type that will
	//	compare keys for us !
	//
	typedef	int		(*MATCHKEY)( KEYREF key1, KEYREF	key2 ) ;


private :

	//
	// An array of buckets !
	//
	DLIST*	m_pBucket ;	

	//
	//	Member Pointer - will get the key out of the object for us !
	//
	GETKEY	m_pGetKey ;

	//
	//	Member Pointer - will compare the key in the item for us !
	//
	MATCHKEY	m_pMatchKey ;
	
	//
	// A counter that we use to determine when to grow the
	// hash table.  Each time we grow the table we set this
	// to a large positive value, and decrement as we insert
	// elements.  When this hits 0 its time to grow the table !
	//
	long	m_cInserts ;		

	//
	// The function we use to compute hash values.
	// (Provided by the Caller of Init())
	//
	PFNHASH	m_pfnHash ;	

	//
	//	The function we call when we are growing the hash table
	//	and splitting bucket chains and we need to rehash an element !
	//
	PFNREHASH	m_pfnReHash ;

	//
	// Number of Buckets used in index computation
	//
	int		m_cBuckets ;		

	//
	// Number of Buckets we are actually using
	// Assert( m_cBuckets >= m_cActiveBuckets ) always true.
	//
	int		m_cActiveBuckets ;	

	//
	// Number of Buckets we have allocated
	// Assert( m_cNumAlloced >= m_cActiveBuckets ) must
	// always be true.
	//
	int		m_cNumAlloced ;		

	//
	// The amount we should grow the hash table when we
	// decide to grow it.
	//
	int		m_cIncrement ;		

	//
	// The number of CBuckets we should allow in each
	// collision chain (on average).
	//
	int		m_load ;

#ifdef	METER
	//
	//	The structure for collecting our performance data !
	//
	CHashStats*	m_pStat ;

	//
	//	Compute the depth of a bucket !
	//
	long
	BucketDepth(	DWORD index ) ;

	//
	//	set the statistics for the deepest bucket !
	//
	void
	MaxBucket(	DWORD index ) ;

	//
	//	Compute the average Search depth !
	//
	void
	AverageSearch( BOOL	fHit, long lDepth ) ;

	//
	//	Compute the average Bucket depth !
	//
	void
	AverageBucket( ) ;
#endif

	//
	// The function we use to compute the
	// position of an element in the hash table given its
	// Hash Value.
	//
	DWORD	
	ComputeIndex( DWORD dw ) ;	

	DWORD	
	ReHash( Data*	p )		{
		if( m_pfnReHash )
			return	m_pfnReHash( p ) ;
		return	m_pfnHash( (p->*m_pGetKey)() ) ;
	}

public :
	TFDLHash( ) ;
	~TFDLHash( ) ;

	BOOL	
	Init(	int		cInitial,
			int		cIncrement,
			int		load,
			PFNHASH	pfnHash,
			GETKEY	pGetKey,
			MATCHKEY	pMatchKey,
			PFNREHASH	pfnReHash = 0,
			CHashStats*	pStats = 0
			) ;

	//
	//	Check that the hash table is in a valid state
	//	if fCheckHash == TRUE we will walk all the buckets and check that
	//	the data hashes to the correct value !
	//
	BOOL	
	IsValid( BOOL fCheckHash = FALSE ) ;

	//
	//	Check that the Bucket is valid - everything contains
	//	proper hash value and is in order !
	//
	BOOL	
	IsValidBucket( int	i ) ;

	//
	//	This function grows the number of hash buckets as the
	//	total number of items in the table grows !
	//
	BOOL
	Split() ;
	

	//
	//	Insert a piece of Data into the Hash Table
    //  We take a pointer to the Data object.
	//
	BOOL
	InsertDataHash(	DWORD	dw,
					KEYREF	k,
					Data*	pd
					) ;

	//
	//	Insert a piece of Data into the Hash Table
	//	
	//	We take an iterator that is already position in the
	//	correct location for inserting the item !
	//
	BOOL
	InsertDataHashIter(	ITER&	iter,
						DWORD	dw,
						KEYREF	k,
						Data*	pd
						) ;


	//
	//	Insert a piece of Data into the Hash Table
	//
	BOOL
	InsertData(	Data*	pd )	{
		KEYREF	keyref = (pd->*m_pGetKey)() ;
		return	InsertDataHash( m_pfnHash(keyref), keyref, pd ) ;
	}

	//
	//	Insert a piece of Data into the Hash table
	//	given an iterator that should be at the right location !
	//
	BOOL
	InsertDataIter(	ITER&	iter,
					Data*	pd	)	{
		KEYREF	keyref = (pd->*m_pGetKey)() ;
		return	InsertDataHashIter( iter, m_pfnHash(keyref), keyref, pd ) ;
	}
					
	//
	//	Search for an item in the cache - if we don't find
	//	it we return an ITERATOR that the user can use to insert
	//	the item by calling ITER.InsertBefore() ;
	//
	//	If the item is found, we'll return the item, as well
	//	as returning an iterator who's current element
	//	points at the data item !
	//
	ITER
	SearchKeyHashIter(
					DWORD	dw,
					KEYREF	k,
					Data*	&pd
					) ;

	//
	//	Search for a given Key in the Hash Table - return a pointer
	//	to the Data within our Bucket object
	//
	void	
	SearchKeyHash(	DWORD	dw,
					KEYREF	k,
					Data*	&pd
					) ;

	//
	//	Search for a given Key in the Hash Table - return a pointer
	//	to the Data within our Bucket object
	//
	Data*
	SearchKey(	KEYREF	k )	{
		Data*	p ;
		SearchKeyHash( m_pfnHash( k ), k, p ) ;
		return	 p ;		
	}

	//
	//	Search for the given item and return a good iterator !
	//
	ITER
	SearchKeyIter(	KEYREF	k,
					Data*	&pd ) {
		pd = 0 ;
		return	SearchKeyHashIter( m_pfnHash( k ), k, pd ) ;
	}
		

	Data*
	SearchKey(	DWORD	dw,
				KEYREF	k
				)	{
		Data*	p = 0 ;
		_ASSERT( dw == m_pfnHash( k ) ) ;
		SearchKeyHash( dw, k, p ) ;
		return	p ;
	}

	//
	//	Given an item in the hash table - remove it !
	//
	void
	Delete(	Data*	pd 	) ;

	//
	//	Find an element in the hash table - and remove it !
	//	(Confirm that the found item matches the Key!)
	//
	void
	DeleteData(	KEYREF	k,
				Data*	pd
			 	) ;

	//
	//	Remove an item from the hash table - and return it !
	//
	Data*
	DeleteData(	KEYREF	k )	{
		Data*	p ;
		//
		//	Find the item
		//
		SearchKeyHash( m_pfnHash( k ), k, p ) ;
		//
		//	Remove from Hash Table
		//
		if( p )
			Delete( p ) ;
		return	p ;
	}

	//
	//	Delete the key and associated data from the table.
	//
	BOOL	
	Destroy( KEYREF	k )	{
		Data*	p = DeleteData( k ) ;
		if( p ) {
			delete	p ;
			return	TRUE ;
		}
		return	FALSE ;
	}

	//
	//	Discards any memory we have allocated - after this, you must
	//  call Init() again!
	//
	void	Clear( ) ;

	//
	//	Removes all of the items in the hash table.  Does not call "delete"
	//  on them.
	//
	void	Empty( ) ;

	//
	//	Called by Iterators that want to let us know that items have been
	//	removed from the cache so we can do our splits correctly etc... !
	//
	void	NotifyOfRemoval() ;

	//
	//	Function to compute hash value of a key for callers
	//	who don't keep track of the hash function
	//
	DWORD
	ComputeHash(	KEYREF	k ) ;

} ;

#include	"fdlhash.inl"

#endif // _FDLHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\staxinc\exchmole.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Mon May 12 23:53:20 1997
 */
/* Compiler settings for mimeole.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __mimeole_h__
#define __mimeole_h__

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __IMimeInternational_FWD_DEFINED__
#define __IMimeInternational_FWD_DEFINED__
typedef interface IMimeInternational IMimeInternational;
#endif 	/* __IMimeInternational_FWD_DEFINED__ */


#ifndef __IMimeSecurity_FWD_DEFINED__
#define __IMimeSecurity_FWD_DEFINED__
typedef interface IMimeSecurity IMimeSecurity;
#endif 	/* __IMimeSecurity_FWD_DEFINED__ */


#ifndef __IMimeSecurityOptions_FWD_DEFINED__
#define __IMimeSecurityOptions_FWD_DEFINED__
typedef interface IMimeSecurityOptions IMimeSecurityOptions;
#endif 	/* __IMimeSecurityOptions_FWD_DEFINED__ */


#ifndef __IMimeSecurityInfo_FWD_DEFINED__
#define __IMimeSecurityInfo_FWD_DEFINED__
typedef interface IMimeSecurityInfo IMimeSecurityInfo;
#endif 	/* __IMimeSecurityInfo_FWD_DEFINED__ */


#ifndef __IMimeHeaderTable_FWD_DEFINED__
#define __IMimeHeaderTable_FWD_DEFINED__
typedef interface IMimeHeaderTable IMimeHeaderTable;
#endif 	/* __IMimeHeaderTable_FWD_DEFINED__ */


#ifndef __IMimePropertySchema_FWD_DEFINED__
#define __IMimePropertySchema_FWD_DEFINED__
typedef interface IMimePropertySchema IMimePropertySchema;
#endif 	/* __IMimePropertySchema_FWD_DEFINED__ */


#ifndef __IMimePropertySet_FWD_DEFINED__
#define __IMimePropertySet_FWD_DEFINED__
typedef interface IMimePropertySet IMimePropertySet;
#endif 	/* __IMimePropertySet_FWD_DEFINED__ */


#ifndef __IMimeAddressInfo_FWD_DEFINED__
#define __IMimeAddressInfo_FWD_DEFINED__
typedef interface IMimeAddressInfo IMimeAddressInfo;
#endif 	/* __IMimeAddressInfo_FWD_DEFINED__ */


#ifndef __IMimeAddressTable_FWD_DEFINED__
#define __IMimeAddressTable_FWD_DEFINED__
typedef interface IMimeAddressTable IMimeAddressTable;
#endif 	/* __IMimeAddressTable_FWD_DEFINED__ */


#ifndef __IMimeWebDocument_FWD_DEFINED__
#define __IMimeWebDocument_FWD_DEFINED__
typedef interface IMimeWebDocument IMimeWebDocument;
#endif 	/* __IMimeWebDocument_FWD_DEFINED__ */


#ifndef __IMimeBody_FWD_DEFINED__
#define __IMimeBody_FWD_DEFINED__
typedef interface IMimeBody IMimeBody;
#endif 	/* __IMimeBody_FWD_DEFINED__ */


#ifndef __IMimeMessageTree_FWD_DEFINED__
#define __IMimeMessageTree_FWD_DEFINED__
typedef interface IMimeMessageTree IMimeMessageTree;
#endif 	/* __IMimeMessageTree_FWD_DEFINED__ */


#ifndef __IMimeMessage_FWD_DEFINED__
#define __IMimeMessage_FWD_DEFINED__
typedef interface IMimeMessage IMimeMessage;
#endif 	/* __IMimeMessage_FWD_DEFINED__ */


#ifndef __IMimeMessageParts_FWD_DEFINED__
#define __IMimeMessageParts_FWD_DEFINED__
typedef interface IMimeMessageParts IMimeMessageParts;
#endif 	/* __IMimeMessageParts_FWD_DEFINED__ */


#ifndef __IMimeEnumHeaderRows_FWD_DEFINED__
#define __IMimeEnumHeaderRows_FWD_DEFINED__
typedef interface IMimeEnumHeaderRows IMimeEnumHeaderRows;
#endif 	/* __IMimeEnumHeaderRows_FWD_DEFINED__ */


#ifndef __IMimeEnumProperties_FWD_DEFINED__
#define __IMimeEnumProperties_FWD_DEFINED__
typedef interface IMimeEnumProperties IMimeEnumProperties;
#endif 	/* __IMimeEnumProperties_FWD_DEFINED__ */


#ifndef __IMimeEnumAddressTypes_FWD_DEFINED__
#define __IMimeEnumAddressTypes_FWD_DEFINED__
typedef interface IMimeEnumAddressTypes IMimeEnumAddressTypes;
#endif 	/* __IMimeEnumAddressTypes_FWD_DEFINED__ */


#ifndef __IMimeEnumMessageParts_FWD_DEFINED__
#define __IMimeEnumMessageParts_FWD_DEFINED__
typedef interface IMimeEnumMessageParts IMimeEnumMessageParts;
#endif 	/* __IMimeEnumMessageParts_FWD_DEFINED__ */


#ifndef __IMimeAllocator_FWD_DEFINED__
#define __IMimeAllocator_FWD_DEFINED__
typedef interface IMimeAllocator IMimeAllocator;
#endif 	/* __IMimeAllocator_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL_itf_mimeole_0000
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */














//--------------------------------------------------------------------------------
// MIMEOLE.H
//--------------------------------------------------------------------------------
// (C) Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//--------------------------------------------------------------------------------

#pragma comment(lib,"uuid.lib")

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {6AD6A1EA-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(LIBID_MIMEOLE, 0x6ad6a1ea, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1EB-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeEnumAddressTypes, 0x6ad6a1eb, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1EC-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeWebDocument, 0x6ad6a1ec, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1ED-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IUnicodeStream, 0x6ad6a1ed, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1EE-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeAddressTable, 0x6ad6a1ee, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1EF-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeAddressInfo, 0x6ad6a1ef, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F0-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeEnumHeaderRows, 0x6ad6a1f0, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F1-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeInlineSupport, 0x6ad6a1f1, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F2-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeEnumMessageParts, 0x6ad6a1f2, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F3-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeSecurityInfo, 0x6ad6a1f3, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F4-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeSecurityOptions, 0x6ad6a1f4, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F5-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeInternational, 0x6ad6a1f5, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F6-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeInternational, 0x6ad6a1f6, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F7-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeBody, 0x6ad6a1f7, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F8-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeBody, 0x6ad6a1f8, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1F9-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeMessageParts, 0x6ad6a1f9, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1FA-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeMessageParts, 0x6ad6a1fa, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1FB-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeAllocator, 0x6ad6a1fb, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1FC-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeAllocator, 0x6ad6a1fc, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1FD-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeSecurity, 0x6ad6a1fd, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1FE-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeSecurity, 0x6ad6a1fe, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A1FF-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IVirtualStream, 0x6ad6a1ff, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A200-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IVirtualStream, 0x6ad6a200, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A201-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeHeaderTable, 0x6ad6a201, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A202-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeHeaderTable, 0x6ad6a202, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A203-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimePropertySet, 0x6ad6a203, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A204-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimePropertySet, 0x6ad6a204, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A205-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeMessageTree, 0x6ad6a205, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A206-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeMessageTree, 0x6ad6a206, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A207-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeMessage, 0x6ad6a207, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A208-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeMessage, 0x6ad6a208, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A209-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimePropertySchema, 0x6ad6a209, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A20A-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimePropertySchema, 0x6ad6a20a, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A20B-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(IID_IMimeEnumProperties, 0x6ad6a20b, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {6AD6A20C-C19B-11d0-85EB-00C04FD85AB4}
DEFINE_GUID(CLSID_IMimeBindHost,0x6ad6a20c, 0xc19b, 0x11d0, 0x85, 0xeb, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// --------------------------------------------------------------------------------
// Errors
// --------------------------------------------------------------------------------
#ifndef FACILITY_INTERNET
#define FACILITY_INTERNET 12
#endif
#ifndef HR_E
#define HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_INTERNET, n)
#endif
#ifndef HR_S
#define HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_INTERNET, n)
#endif
#ifndef HR_CODE
#define HR_CODE(hr) (INT)(hr & 0xffff)
#endif

// --------------------------------------------------------------------------------
// MIMEOLE Failure Return Values
// --------------------------------------------------------------------------------
#define MIME_E_REG_CREATE_KEY                HR_E(0xCE01)
#define MIME_E_REG_QUERY_INFO                HR_E(0xCE02)
#define MIME_E_INVALID_ENCTYPE               HR_E(0xCE03)
#define MIME_E_BOUNDARY_MISMATCH             HR_E(0xCE04)
#define MIME_E_NOT_FOUND                     HR_E(0xCE05)
#define MIME_E_NO_DATA                       HR_E(0xCE05)
#define MIME_E_BUFFER_TOO_SMALL              HR_E(0xCE06)
#define MIME_E_INVALID_ITEM_FLAGS            HR_E(0xCE07)
#define MIME_E_ONE_LINE_ITEM                 HR_E(0xCE08)
#define MIME_E_INVALID_HANDLE                HR_E(0xCE09)
#define MIME_E_CHARSET_TRANSLATE             HR_E(0xCE0A)
#define MIME_E_NOT_INITIALIZED               HR_E(0xCE0B)
#define MIME_E_NO_MORE_ROWS                  HR_E(0xCE0C)
#define MIME_E_ALREADY_BOUND                 HR_E(0xCE0D)
#define MIME_E_CANT_RESET_ROOT               HR_E(0xCE0E)
#define MIME_E_INSERT_NOT_ALLOWED            HR_E(0xCE0F)
#define MIME_E_BAD_BODY_LOCATION             HR_E(0xCE10)
#define MIME_E_NOT_MULTIPART                 HR_E(0xCE11)
#define MIME_E_NO_MULTIPART_BOUNDARY         HR_E(0xCE12)
#define MIME_E_CONVERT_NOT_NEEDED            HR_E(0xCE13)
#define MIME_E_CANT_MOVE_BODY                HR_E(0xCE14)
#define MIME_E_UNKNOWN_BODYTREE_VERSION      HR_E(0xCE15)
#define MIME_E_NOTHING_TO_SAVE               HR_E(0xCE16)
#define MIME_E_NEED_SAVE_MESSAGE             HR_E(0xCE17)
#define MIME_E_NOTHING_TO_REVERT             HR_E(0xCE18)
#define MIME_E_MSG_SIZE_DIFF                 HR_E(0xCE19)
#define MIME_E_CANT_RESET_PARENT             HR_E(0xCE1A)
#define MIME_E_CORRUPT_CACHE_TREE            HR_E(0xCE1B)
#define MIME_E_BODYTREE_OUT_OF_SYNC          HR_E(0xCE1C)
#define MIME_E_INVALID_ENCODINGTYPE          HR_E(0xCE1D)
#define MIME_E_MULTIPART_NO_DATA             HR_E(0xCE1E)
#define MIME_E_INVALID_OPTION_VALUE          HR_E(0xCE1F)
#define MIME_E_INVALID_OPTION_ID             HR_E(0xCE20)
#define MIME_E_INVALID_HEADER_NAME           HR_E(0xCE21)
#define MIME_E_NOT_BOUND                     HR_E(0xCE22)
#define MIME_E_MAX_SIZE_TOO_SMALL            HR_E(0xCE23)
#define MIME_E_MULTIPART_HAS_CHILDREN        HR_E(0xCE25)
#define MIME_E_INVALID_PROP_FLAGS            HR_E(0xCE26)
#define MIME_E_INVALID_ADDRESS_TYPE          HR_E(0xCE27)
#define MIME_E_INVALID_OBJECT_IID            HR_E(0xCE28)
#define MIME_E_MLANG_DLL_NOT_FOUND           HR_E(0xCE29)
#define MIME_E_ROOT_NOT_EMPTY                HR_E(0xCE2A)
#define MIME_E_MLANG_BAD_DLL                 HR_E(0xCE2B)
#define MIME_E_REG_OPEN_KEY                  HR_E(0xCE2C)
#define MIME_E_INVALID_INET_DATE             HR_E(0xCE2D)
#define MIME_E_INVALID_BODYTYPE              HR_E(0xCE2E)
#define MIME_E_INVALID_DELETE_TYPE           HR_E(0xCE2F)
#define MIME_E_OPTION_HAS_NO_VALUE           HR_E(0xCE30)
#define MIME_E_INVALID_CHARSET_TYPE          HR_E(0xCE31)
#define MIME_E_VARTYPE_NO_CONVERT            HR_E(0xCE32)
#define MIME_E_INVALID_VARTYPE               HR_E(0xCE33)
#define MIME_E_NO_MORE_ADDRESS_TYPES         HR_E(0xCE34)
#define MIME_E_INVALID_ENCODING_TYPE         HR_E(0xCE35)
#define MIME_S_ILLEGAL_LINES_FOUND           HR_S(0xCE36)
#define MIME_S_MIME_VERSION                  HR_S(0xCE37)
#define MIME_E_INVALID_TEXT_TYPE             HR_E(0xCE38)
#define MIME_E_READ_ONLY                     HR_E(0xCE39)
#define MIME_S_INVALID_MESSAGE               HR_S(0xCE3A)

// ---------------------------------------------------------------------------
// MIMEOLE Security Error Return Values
// ---------------------------------------------------------------------------
#define MIME_E_SECURITY_NOTINIT              HR_E(0xCEA0)
#define MIME_E_SECURITY_LOADCRYPT32          HR_E(0xCEA1)
#define MIME_E_SECURITY_BADPROCADDR          HR_E(0xCEA2)
#define MIME_E_SECURITY_NODEFAULT            HR_E(0xCEB0)
#define MIME_E_SECURITY_NOOP                 HR_E(0xCEB1)
#define MIME_S_SECURITY_NOOP                 HR_S(0xCEB1)
#define MIME_S_SECURITY_NONE                 HR_S(0xCEB2)
#define MIME_S_SECURITY_ERROROCCURED         HR_S(0xCEB3)
#define MIME_E_SECURITY_USERCHOICE           HR_E(0xCEB4)
#define MIME_E_SECURITY_UNKMSGTYPE           HR_E(0xCEB5)
#define MIME_E_SECURITY_BADMESSAGE           HR_E(0xCEB6)
#define MIME_E_SECURITY_BADCONTENT           HR_E(0xCEB7)
#define MIME_E_SECURITY_BADSECURETYPE        HR_E(0xCEB8)
#define MIME_E_SECURITY_BADSTORE             HR_E(0xCED0)
#define MIME_E_SECURITY_NOCERT               HR_E(0xCED1)
#define MIME_E_SECURITY_CERTERROR            HR_E(0xCED2)
#define MIME_S_SECURITY_NODEFCERT            HR_S(0xCED3)
#define MIME_E_SECURITY_BADSIGNATURE         HR_E(0xCEE0)
#define MIME_E_SECURITY_MULTSIGNERS          HR_E(0xCEE1)
#define MIME_E_SECURITY_NOSIGNINGCERT        HR_E(0xCEE2)
#define MIME_E_SECURITY_CANTDECRYPT          HR_E(0xCEF0)
#define MIME_E_SECURITY_ENCRYPTNOSENDERCERT  HR_E(0xCEF1)

// ---------------------------------------------------------------------------
// MIMEOLE Security Ignore Masks
//  Pass these to the enocode/decode functions to admit "acceptible"
//  errors.  Acceptible defined to be the bits set on this mask.
// ---------------------------------------------------------------------------
#define MIME_SECURITY_IGNORE_ENCRYPTNOSENDERCERT     0x0001
#define MIME_SECURITY_IGNORE_BADSIGNATURE            0x0002
#define MIME_SECURITY_IGNORE_NOCERT                  0x0004
#define MIME_SECURITY_IGNORE_ALL                     0xffff

// --------------------------------------------------------------------------------
// String Definition Macros
// --------------------------------------------------------------------------------
#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C extern
#endif

#ifdef DEFINE_STRCONST
#define STRCONSTA(x,y)    EXTERN_C const char x[] = y
#define STRCONSTW(x,y)    EXTERN_C const WCHAR x[] = L##y
#else
#define STRCONSTA(x,y)    EXTERN_C const char x[]
#define STRCONSTW(x,y)    EXTERN_C const WCHAR x[]
#endif

// --------------------------------------------------------------------------------
// rfc822 Headers
// --------------------------------------------------------------------------------
STRCONSTA(STR_HDR_FROM,              "From");
STRCONSTA(STR_HDR_TO,                "To");
STRCONSTA(STR_HDR_CC,                "Cc");
STRCONSTA(STR_HDR_BCC,               "Bcc");
STRCONSTA(STR_HDR_SENDER,            "Sender");
STRCONSTA(STR_HDR_REPLYTO,           "Reply-To");
STRCONSTA(STR_HDR_RETURNPATH,        "Return-Path");
STRCONSTA(STR_HDR_RR,                "Rr");
STRCONSTA(STR_HDR_RETRCPTTO,         "Return-Receipt-To");
STRCONSTA(STR_HDR_APPARTO,           "Apparently-To");
STRCONSTA(STR_HDR_DATE,              "Date");
STRCONSTA(STR_HDR_RECEIVED,          "Received");
STRCONSTA(STR_HDR_MESSAGEID,         "Message-ID");
STRCONSTA(STR_HDR_XMAILER,           "X-Mailer");
STRCONSTA(STR_HDR_ENCODING,          "Encoding");
STRCONSTA(STR_HDR_ENCRYPTED,         "Encrypted");
STRCONSTA(STR_HDR_COMMENT,           "Comment");
STRCONSTA(STR_HDR_SUBJECT,           "Subject");
STRCONSTA(STR_HDR_MIMEVER,           "MIME-Version");
STRCONSTA(STR_HDR_CNTTYPE,           "Content-Type");
STRCONSTA(STR_HDR_CNTXFER,           "Content-Transfer-Encoding");
STRCONSTA(STR_HDR_CNTID,             "Content-ID");
STRCONSTA(STR_HDR_CNTDESC,           "Content-Description");
STRCONSTA(STR_HDR_CNTDISP,           "Content-Disposition");
STRCONSTA(STR_HDR_CNTBASE,           "Content-Base");
STRCONSTA(STR_HDR_CNTLOC,            "Content-Location");
STRCONSTA(STR_HDR_NEWSGROUPS,        "Newsgroups");
STRCONSTA(STR_HDR_PATH,              "Path");
STRCONSTA(STR_HDR_FOLLOWUPTO,        "Followup-To");
STRCONSTA(STR_HDR_EXPIRES,           "Expires");
STRCONSTA(STR_HDR_REFS,              "References");
STRCONSTA(STR_HDR_CONTROL,           "Control");
STRCONSTA(STR_HDR_DISTRIB,           "Distribution");
STRCONSTA(STR_HDR_KEYWORDS,          "Keywords");
STRCONSTA(STR_HDR_SUMMARY,           "Summary");
STRCONSTA(STR_HDR_APPROVED,          "Approved");
STRCONSTA(STR_HDR_LINES,             "Lines");
STRCONSTA(STR_HDR_XREF,              "Xref");
STRCONSTA(STR_HDR_ORG,               "Organization");
STRCONSTA(STR_HDR_XNEWSRDR,          "X-Newsreader");
STRCONSTA(STR_HDR_XPRI,              "X-Priority");
STRCONSTA(STR_HDR_XMSPRI,            "X-MSMail-Priority");
STRCONSTA(STR_HDR_OFFSETS,           "X-Offsets");
STRCONSTA(STR_HDR_XUNSENT,           "X-Unsent");
STRCONSTA(STR_HDR_ARTICLEID,         "X-ArticleId");
STRCONSTA(STR_HDR_NEWSGROUP,         "X-Newsgroup");

// --------------------------------------------------------------------------------
// Parameters Available through IMimePropertySet/IMimeBody
// --------------------------------------------------------------------------------
STRCONSTA(STR_PAR_CHARSET,           "par:content-type:charset");
STRCONSTA(STR_PAR_NUMBER,            "par:content-type:number");
STRCONSTA(STR_PAR_TOTAL,             "par:content-type:total");
STRCONSTA(STR_PAR_ID,                "par:content-type:id");
STRCONSTA(STR_PAR_BOUNDARY,          "par:content-type:boundary");
STRCONSTA(STR_PAR_NAME,              "par:content-type:name");
STRCONSTA(STR_PAR_PROTOCOL,          "par:content-type:protocol");
STRCONSTA(STR_PAR_MICALG,            "par:content-type:micalg");
STRCONSTA(STR_PAR_FILENAME,          "par:content-disposition:filename");
STRCONSTA(STR_PAR_TYPE,              "par:content-type:type");
STRCONSTA(STR_PAR_START,             "par:content-type:start");

// --------------------------------------------------------------------------------
// Attributes Available through IMimePropertySet/IMimeBody
// --------------------------------------------------------------------------------
STRCONSTA(STR_ATT_FILENAME,          "att:filename");
STRCONSTA(STR_ATT_GENFNAME,          "att:generated-filename");
STRCONSTA(STR_ATT_PRITYPE,           "att:pri-content-type");
STRCONSTA(STR_ATT_SUBTYPE,           "att:sub-content-type");
STRCONSTA(STR_ATT_NORMSUBJ,          "att:normalized-subject");
STRCONSTA(STR_ATT_ILLEGAL,           "att:illegal-lines");
STRCONSTA(STR_ATT_RESOURL,           "att:resolved-url");
STRCONSTA(STR_ATT_SENTTIME,          "att:sent-time");
STRCONSTA(STR_ATT_RECVTIME,          "att:received-time");
STRCONSTA(STR_ATT_PRIORITY,          "att:priority");

// --------------------------------------------------------------------------------
// MIME Content Types
// --------------------------------------------------------------------------------
STRCONSTA(STR_MIME_TEXT_PLAIN,       "text/plain");
STRCONSTA(STR_MIME_TEXT_HTML,        "text/html");
STRCONSTA(STR_MIME_APPL_STREAM,      "application/octet-stream");
STRCONSTA(STR_MIME_MPART_MIXED,      "multipart/mixed");
STRCONSTA(STR_MIME_MPART_ALT,        "multipart/alternative");
STRCONSTA(STR_MIME_MPART_RELATED,    "multipart/related");
STRCONSTA(STR_MIME_MSG_PART,         "message/partial");
STRCONSTA(STR_MIME_MSG_RFC822,       "message/rfc822");
STRCONSTA(STR_MIME_APPLY_MSTNEF,     "application/ms-tnef");

// --------------------------------------------------------------------------------
// MIME Primary Content Types
// --------------------------------------------------------------------------------
STRCONSTA(STR_CNT_TEXT,		    	"text");
STRCONSTA(STR_CNT_MULTIPART,			"multipart");
STRCONSTA(STR_CNT_MESSAGE,			"message");
STRCONSTA(STR_CNT_IMAGE,				"image");
STRCONSTA(STR_CNT_AUDIO,				"audio");
STRCONSTA(STR_CNT_VIDEO,				"video");
STRCONSTA(STR_CNT_APPLICATION,		"application");

// --------------------------------------------------------------------------------
// MIME Secondary Content Types
// --------------------------------------------------------------------------------
STRCONSTA(STR_SUB_PLAIN,             "plain");
STRCONSTA(STR_SUB_HTML,              "html");
STRCONSTA(STR_SUB_RTF,               "ms-rtf");
STRCONSTA(STR_SUB_MIXED,             "mixed");
STRCONSTA(STR_SUB_PARALLEL,          "parallel");
STRCONSTA(STR_SUB_DIGEST,            "digest");
STRCONSTA(STR_SUB_RELATED,           "related");
STRCONSTA(STR_SUB_ALTERNATIVE,       "alternative");
STRCONSTA(STR_SUB_RFC822,            "rfc822");
STRCONSTA(STR_SUB_PARTIAL,           "partial");
STRCONSTA(STR_SUB_EXTERNAL,          "external-body");
STRCONSTA(STR_SUB_OCTETSTREAM,       "octet-stream");
STRCONSTA(STR_SUB_POSTSCRIPT,        "postscript");
STRCONSTA(STR_SUB_GIF,               "gif");
STRCONSTA(STR_SUB_JPEG,              "jpeg");
STRCONSTA(STR_SUB_BASIC,             "basic");
STRCONSTA(STR_SUB_MPEG,              "mpeg");
STRCONSTA(STR_SUB_MSTNEF,            "ms-tnef");
STRCONSTA(STR_SUB_MSWORD,            "msword");
STRCONSTA(STR_SUB_WAV,               "wav");
STRCONSTA(STR_SUB_PKCS7MIME,         "x-pkcs7-mime");
STRCONSTA(STR_SUB_PKCS7SIG,          "x-pkcs7-signature");
STRCONSTA(STR_SUB_SIGNED,            "signed");

// --------------------------------------------------------------------------------
// MIME Content-Transfer-Encoding Types
// --------------------------------------------------------------------------------
STRCONSTA(STR_ENC_7BIT,              "7bit");
STRCONSTA(STR_ENC_QP,                "quoted-printable");
STRCONSTA(STR_ENC_BASE64,            "base64");
STRCONSTA(STR_ENC_8BIT,              "8bit");
STRCONSTA(STR_ENC_BINARY,            "binary");
STRCONSTA(STR_ENC_UUENCODE,          "uuencode");
STRCONSTA(STR_ENC_XUUENCODE,         "x-uuencode");
STRCONSTA(STR_ENC_XUUE,              "x-uue");

// --------------------------------------------------------------------------------
// MIME Content-Disposition Types
// --------------------------------------------------------------------------------
STRCONSTA(STR_DIS_INLINE,            "inline");
STRCONSTA(STR_DIS_ATTACHMENT,        "attachment");

// --------------------------------------------------------------------------------
// MIME Protocol Types
// --------------------------------------------------------------------------------
STRCONSTA(STR_PRO_SHA1,              "sha1");
STRCONSTA(STR_PRO_MD5,               "rsa-md5");

// --------------------------------------------------------------------------------
// Known Priority Strings
// --------------------------------------------------------------------------------
STRCONSTA(STR_PRI_MS_HIGH,           "High");
STRCONSTA(STR_PRI_MS_NORMAL,         "Normal");
STRCONSTA(STR_PRI_MS_LOW,            "Low");
STRCONSTA(STR_PRI_HIGH,              "1");
STRCONSTA(STR_PRI_NORMAL,            "3");
STRCONSTA(STR_PRI_LOW,               "5");

// --------------------------------------------------------------------------------
// IMimeMessage IDataObject clipboard formats (also include CF_TEXT)
// --------------------------------------------------------------------------------
STRCONSTA(STR_CF_HTML,               "HTML Format");
STRCONSTA(STR_CF_INETMSG,            "Internet Message (rfc822/rfc1522)");
STRCONSTA(STR_CF_RFC822,             "message/rfc822");

// --------------------------------------------------------------------------------
// PIDSTRING - Use in GetProp, SetProp, QueryProp, DeleteProp
// --------------------------------------------------------------------------------
#define PID_BASE                     2
#define PIDTOSTR(_dwPropId)          ((LPCSTR)((DWORD_PTR)(_dwPropId)))
#define STRTOPID(_pszName)           ((DWORD)((DWORD_PTR)((LPCSTR)(_pszName))))
#define ISPIDSTR(_pszName)           ((HIWORD((DWORD_PTR)(_pszName)) == 0))
#define ISKNOWNPID(_dwPropId)        (_dwPropId >= PID_BASE && _dwPropId < PID_LAST)

// --------------------------------------------------------------------------------
// Mime Property Ids
// --------------------------------------------------------------------------------
typedef enum tagMIMEPROPID {
    PID_HDR_NEWSGROUP       = 2,
    PID_HDR_NEWSGROUPS      = 3,
    PID_HDR_REFS            = 4,
    PID_HDR_SUBJECT         = 5,
    PID_HDR_FROM            = 6,
    PID_HDR_MESSAGEID       = 7,
    PID_HDR_RETURNPATH      = 8,
    PID_HDR_RR              = 9,
    PID_HDR_RETRCPTTO       = 10,
    PID_HDR_APPARTO         = 11,
    PID_HDR_DATE            = 12,
    PID_HDR_RECEIVED        = 13,
    PID_HDR_REPLYTO         = 14,
    PID_HDR_XMAILER         = 15,
    PID_HDR_BCC             = 16,
    PID_HDR_MIMEVER         = 17,
    PID_HDR_CNTTYPE         = 18,
    PID_HDR_CNTXFER         = 19,
    PID_HDR_CNTID           = 20,
    PID_HDR_CNTDESC         = 21,
    PID_HDR_CNTDISP         = 22,
    PID_HDR_CNTBASE         = 23,
    PID_HDR_CNTLOC          = 24,
    PID_HDR_TO              = 25,
    PID_HDR_PATH            = 26,
    PID_HDR_FOLLOWUPTO      = 27,
    PID_HDR_EXPIRES         = 28,
    PID_HDR_CC              = 29,
    PID_HDR_CONTROL         = 30,
    PID_HDR_DISTRIB         = 31,
    PID_HDR_KEYWORDS        = 32,
    PID_HDR_SUMMARY         = 33,
    PID_HDR_APPROVED        = 34,
    PID_HDR_LINES           = 35,
    PID_HDR_XREF            = 36,
    PID_HDR_ORG             = 37,
    PID_HDR_XNEWSRDR        = 38,
    PID_HDR_XPRI            = 39,
    PID_HDR_XMSPRI          = 40,
    PID_PAR_FILENAME        = 41,
    PID_PAR_BOUNDARY        = 42,
    PID_PAR_CHARSET         = 43,
    PID_PAR_NAME            = 44,
    PID_ATT_FILENAME        = 45,
    PID_ATT_GENFNAME        = 46,
    PID_ATT_PRITYPE         = 47,
    PID_ATT_SUBTYPE         = 48,
    PID_ATT_NORMSUBJ        = 49,
    PID_ATT_ILLEGAL         = 50,
    PID_ATT_RESOURL         = 51,
    PID_ATT_SENTTIME        = 52,
    PID_ATT_RECVTIME        = 53,
    PID_ATT_PRIORITY        = 54,
    PID_HDR_COMMENT         = 55,
    PID_HDR_ENCODING        = 56,
    PID_HDR_ENCRYPTED       = 57,
    PID_HDR_OFFSETS         = 58,
    PID_HDR_XUNSENT         = 59,
    PID_HDR_ARTICLEID       = 60,
    PID_HDR_SENDER          = 61,
    PID_LAST                = 62
};

// --------------------------------------------------------------------------------
// Variant Typed Identifiers
// --------------------------------------------------------------------------------
#define TYPEDID_MASK                     ((ULONG)0x0000FFFF)
#define TYPEDID_TYPE(_typedid)	        (VARTYPE)(((ULONG)(_typedid)) & TYPEDID_MASK)
#define TYPEDID_ID(_typedid)		        (((ULONG)(_typedid))>>16)
#define TYPEDID(_vartype,_id)	        ((((TYPEDID)(_id))<<16)|((ULONG)(_vartype)))

// --------------------------------------------------------------------------------
// Options Ids
// --------------------------------------------------------------------------------
#define OID_ALLOW_8BIT_HEADER            TYPEDID(VT_BOOL,    0x0001) // TRUE or FALSE
#define OID_CBMAX_HEADER_LINE            TYPEDID(VT_UI4,     0x0002) // Bytes
#define OID_SAVE_FORMAT                  TYPEDID(VT_UI4,     0x0003) // SAVE_RFC822 or SAVE_RFC1521 (mime)
#define OID_WRAP_BODY_TEXT               TYPEDID(VT_BOOL,    0x0004) // TRUE or FALSE
#define OID_CBMAX_BODY_LINE              TYPEDID(VT_UI4,     0x0005) // Bytes
#define OID_TRANSMIT_BODY_ENCODING       TYPEDID(VT_UI4,     0x0006) // ENCODINGTYPE
#define OID_TRANSMIT_TEXT_ENCODING       TYPEDID(VT_UI4,     0x0007) // ENCODINGTYPE
#define OID_GENERATE_MESSAGE_ID          TYPEDID(VT_BOOL,    0x0008) // TRUE or FALSE
#define OID_HASH_ALG_ID                  TYPEDID(VT_UI4,     0x0009)
#define OID_ENCRYPTION_ALG_ID            TYPEDID(VT_UI4,     0x000A)
#define OID_MESSAGE_SECURE_TYPE          TYPEDID(VT_UI2,     0x000B)
#define OID_SENDER_SIGNATURE_THUMBPRINT  TYPEDID(VT_BLOB,    0X000C)
#define OID_INCLUDE_SENDER_CERT          TYPEDID(VT_BOOL,    0X000D) // TRUE or FALSE
#define OID_HIDE_TNEF_ATTACHMENTS        TYPEDID(VT_BOOL,    0X000E) // TRUE or FALSE
#define OID_CLEANUP_TREE_ON_SAVE         TYPEDID(VT_BOOL,    0X000F) // TRUE or FALSE
#define OID_SENDER_ENCRYPTION_THUMBPRINT TYPEDID(VT_BLOB,    0X0010)
#define OID_ENCODE_SIDE_OPTIONSET        TYPEDID(VT_BOOL,    0X0011) // TRUE or FALSE
#define OID_SENDER_CERTIFICATE           TYPEDID(VT_BOOL,    0x0012) // TRUE or FALSE
#define OID_SECURITY_IGNOREMASK          TYPEDID(VT_UI4,     0x0013) // MIME_SECURITY_IGNORE_*
#define OID_BODY_REMOVE_NBSP             TYPEDID(VT_BOOL,    0x0014) // TRUE or FALSE
#define OID_DEFAULT_BODY_CHARSET         TYPEDID(VT_UI4,     0x0015) // HCHARSET
#define OID_DEFAULT_HEADER_CHARSET       TYPEDID(VT_UI4,     0x0016) // HCHARSET
#define OID_TRUST_SENDERS_CERTIFICATE    TYPEDID(VT_BOOL,    0x0017) // TRUE or FALSE
#define OID_DBCS_ESCAPE_IS_8BIT          TYPEDID(VT_BOOL,    0x0018) // TRUE or FALSE

// --------------------------------------------------------------------------------
// Default Option Values
// --------------------------------------------------------------------------------
#define DEF_ALLOW_8BIT_HEADER            FALSE
#define DEF_CBMAX_HEADER_LINE            1000
#define DEF_SAVE_FORMAT                  SAVE_RFC1521
#define DEF_WRAP_BODY_TEXT               TRUE
#define DEF_CBMAX_BODY_LINE              74
#define DEF_GENERATE_MESSAGE_ID          FALSE
#define DEF_HASH_ALG_ID                  0x8004  //SHA //N needed?
#define DEF_ENCRYPTION_ALG_ID            0x6602  //RC2 //N needed?
#define DEF_INCLUDE_SENDER_CERT          FALSE
#define DEF_HIDE_TNEF_ATTACHMENTS        TRUE
#define DEF_CLEANUP_TREE_ON_SAVE         TRUE
#define DEF_BODY_REMOVE_NBSP             TRUE
#define DEF_SECURITY_IGNOREMASK          0
#define DEF_DBCS_ESCAPE_IS_8BIT          FALSE
#define DEF_TRANSMIT_BODY_ENCODING       IET_UNKNOWN
#define DEF_TRANSMIT_TEXT_ENCODING       IET_7BIT

// --------------------------------------------------------------------------------
// Min-Max Option Values
// --------------------------------------------------------------------------------
#define MAX_CBMAX_HEADER_LINE            0xffffffff
#define MIN_CBMAX_HEADER_LINE            76
#define MAX_CBMAX_BODY_LINE              0xffffffff
#define MIN_CBMAX_BODY_LINE              30

// --------------------------------------------------------------------------------
// LIBID_MIMEOLE
// --------------------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_mimeole_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mimeole_0000_v0_0_s_ifspec;


#ifndef __MIMEOLE_LIBRARY_DEFINED__
#define __MIMEOLE_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: MIMEOLE
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [version][helpstring][uuid] */


typedef DWORD TYPEDID;

typedef
enum tagMIMESAVETYPE
    {	SAVE_RFC822	= 0,
	SAVE_RFC1521	= SAVE_RFC822 + 1
    }	MIMESAVETYPE;

typedef
enum tagCSETAPPLYTYPE
    {	CSET_APPLY_UNTAGGED	= 0,
	CSET_APPLY_ALL	= CSET_APPLY_UNTAGGED + 1
    }	CSETAPPLYTYPE;

typedef
enum tagENCODINGTYPE
    {	IET_BINARY	= 0,
	IET_BASE64	= IET_BINARY + 1,
	IET_UUENCODE	= IET_BASE64 + 1,
	IET_QP	= IET_UUENCODE + 1,
	IET_7BIT	= IET_QP + 1,
	IET_8BIT	= IET_7BIT + 1,
	IET_INETCSET	= IET_8BIT + 1,
	IET_UNICODE	= IET_INETCSET + 1,
	IET_RFC1522	= IET_UNICODE + 1,
	IET_ENCODED	= IET_RFC1522 + 1,
	IET_CURRENT	= IET_ENCODED + 1,
	IET_UNKNOWN	= IET_CURRENT + 1
    }	ENCODINGTYPE;

#define	IET_DECODED	( IET_BINARY )

struct  HCHARSET__
    {
    DWORD unused;
    };
typedef struct HCHARSET__ *HCHARSET;

typedef HCHARSET __RPC_FAR *LPHCHARSET;

struct  HBODY__
    {
    DWORD unused;
    };
typedef struct HBODY__ *HBODY;

typedef HBODY __RPC_FAR *LPHBODY;

struct  HHEADERROW__
    {
    DWORD unused;
    };
typedef struct HHEADERROW__ *HHEADERROW;

typedef HHEADERROW __RPC_FAR *LPHHEADERROW;

#define	CCHMAX_HEADER_LINE	( 1000 )


EXTERN_C const IID LIBID_MIMEOLE;

#ifndef __IMimeInternational_INTERFACE_DEFINED__
#define __IMimeInternational_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeInternational
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeInternational __RPC_FAR *LPMIMEINTERNATIONAL;

typedef DWORD CODEPAGEID;

#define	CP_USASCII	( 1252 )

#define	CP_UNICODE	( 1200 )

#define	CP_JAUTODETECT	( 50932 )

#define	CCHMAX_CSET_NAME	( 128 )

#define	CCHMAX_LANG_NAME	( 128 )

#define	CCHMAX_FACE_NAME	( 128 )

typedef struct  tagINETCSETINFO
    {
    CHAR szName[ 128 ];
    HCHARSET hCharset;
    CODEPAGEID cpiWindows;
    CODEPAGEID cpiInternet;
    DWORD dwReserved1;
    }	INETCSETINFO;

typedef struct tagINETCSETINFO __RPC_FAR *LPINETCSETINFO;

typedef
enum tagINETLANGMASK
    {	ILM_FAMILY	= 0x1,
	ILM_NAME	= 0x2,
	ILM_BODYCSET	= 0x4,
	ILM_HEADERCSET	= 0x8,
	ILM_WEBCSET	= 0x10,
	ILM_FIXEDFONT	= 0x20,
	ILM_VARIABLEFONT	= 0x40
    }	INETLANGMASK;

typedef struct  tagCODEPAGEINFO
    {
    DWORD dwMask;
    CODEPAGEID cpiCodePage;
    BOOL fIsValidCodePage;
    ULONG ulMaxCharSize;
    BOOL fInternetCP;
    CODEPAGEID cpiFamily;
    CHAR szName[ 128 ];
    CHAR szBodyCset[ 128 ];
    CHAR szHeaderCset[ 128 ];
    CHAR szWebCset[ 128 ];
    CHAR szFixedFont[ 128 ];
    CHAR szVariableFont[ 128 ];
    ENCODINGTYPE ietNewsDefault;
    ENCODINGTYPE ietMailDefault;
    DWORD dwReserved1;
    }	CODEPAGEINFO;

typedef struct tagCODEPAGEINFO __RPC_FAR *LPCODEPAGEINFO;

typedef struct  tagRFC1522INFO
    {
    BOOL fRfc1522Allowed;
    BOOL fRfc1522Used;
    BOOL fAllow8bit;
    HCHARSET hRfc1522Cset;
    }	RFC1522INFO;

typedef struct tagRFC1522INFO __RPC_FAR *LPRFC1522INFO;

typedef
enum tagCHARSETTYPE
    {	CHARSET_BODY	= 0,
	CHARSET_HEADER	= CHARSET_BODY + 1,
	CHARSET_WEB	= CHARSET_HEADER + 1
    }	CHARSETTYPE;


EXTERN_C const IID IID_IMimeInternational;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1F6-C19B-11d0-85EB-00C04FD85AB4")
    IMimeInternational : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDefaultCharset(
            /* [in] */ HCHARSET hCharset) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetDefaultCharset(
            /* [out] */ LPHCHARSET phCharset) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCodePageCharset(
            /* [in] */ CODEPAGEID cpiCodePage,
            /* [in] */ CHARSETTYPE ctCsetType,
            /* [out] */ LPHCHARSET phCharset) = 0;

        virtual HRESULT STDMETHODCALLTYPE FindCharset(
            /* [in] */ LPCSTR pszCharset,
            /* [out] */ LPHCHARSET phCharset) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCharsetInfo(
            /* [in] */ HCHARSET hCharset,
            /* [out][in] */ LPINETCSETINFO pCsetInfo) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCodePageInfo(
            /* [in] */ CODEPAGEID cpiCodePage,
            /* [out][in] */ LPCODEPAGEINFO pCodePageInfo) = 0;

        virtual HRESULT STDMETHODCALLTYPE CanConvertCodePages(
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest) = 0;

        virtual HRESULT STDMETHODCALLTYPE DecodeHeader(
            /* [in] */ HCHARSET hCharset,
            /* [in] */ LPCSTR pszData,
            /* [out][in] */ LPPROPVARIANT pDecoded,
            /* [out][in] */ LPRFC1522INFO pRfc1522Info) = 0;

        virtual HRESULT STDMETHODCALLTYPE EncodeHeader(
            /* [in] */ HCHARSET hCharset,
            /* [in] */ LPPROPVARIANT pData,
            /* [out] */ LPSTR __RPC_FAR *ppszEncoded,
            /* [out][in] */ LPRFC1522INFO pRfc1522Info) = 0;

        virtual HRESULT STDMETHODCALLTYPE ConvertBuffer(
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest,
            /* [in] */ LPBLOB pIn,
            /* [out][in] */ LPBLOB pOut,
            /* [out] */ ULONG __RPC_FAR *pcbRead) = 0;

        virtual HRESULT STDMETHODCALLTYPE ConvertString(
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest,
            /* [in] */ LPPROPVARIANT pIn,
            /* [out][in] */ LPPROPVARIANT pOut) = 0;

        virtual HRESULT STDMETHODCALLTYPE MLANG_ConvertInetReset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE MLANG_ConvertInetString(
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest,
            /* [in] */ LPCSTR pSource,
            /* [in] */ int __RPC_FAR *pnSizeOfSource,
            /* [out] */ LPSTR pDestination,
            /* [in] */ int __RPC_FAR *pnDstSize) = 0;

        virtual HRESULT STDMETHODCALLTYPE Rfc1522Decode(
            /* [in] */ LPCSTR pszValue,
            /* [ref][in] */ LPSTR pszCharset,
            /* [in] */ ULONG cchmax,
            /* [out] */ LPSTR __RPC_FAR *ppszDecoded) = 0;

        virtual HRESULT STDMETHODCALLTYPE Rfc1522Encode(
            /* [in] */ LPCSTR pszValue,
            /* [in] */ HCHARSET hCharset,
            /* [out] */ LPSTR __RPC_FAR *ppszEncoded) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeInternationalVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeInternational __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeInternational __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultCharset )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultCharset )(
            IMimeInternational __RPC_FAR * This,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageCharset )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ CODEPAGEID cpiCodePage,
            /* [in] */ CHARSETTYPE ctCsetType,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindCharset )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ LPCSTR pszCharset,
            /* [out] */ LPHCHARSET phCharset);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCharsetInfo )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [out][in] */ LPINETCSETINFO pCsetInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageInfo )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ CODEPAGEID cpiCodePage,
            /* [out][in] */ LPCODEPAGEINFO pCodePageInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanConvertCodePages )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DecodeHeader )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [in] */ LPCSTR pszData,
            /* [out][in] */ LPPROPVARIANT pDecoded,
            /* [out][in] */ LPRFC1522INFO pRfc1522Info);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EncodeHeader )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ HCHARSET hCharset,
            /* [in] */ LPPROPVARIANT pData,
            /* [out] */ LPSTR __RPC_FAR *ppszEncoded,
            /* [out][in] */ LPRFC1522INFO pRfc1522Info);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertBuffer )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest,
            /* [in] */ LPBLOB pIn,
            /* [out][in] */ LPBLOB pOut,
            /* [out] */ ULONG __RPC_FAR *pcbRead);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertString )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest,
            /* [in] */ LPPROPVARIANT pIn,
            /* [out][in] */ LPPROPVARIANT pOut);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MLANG_ConvertInetReset )(
            IMimeInternational __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MLANG_ConvertInetString )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ CODEPAGEID cpiSource,
            /* [in] */ CODEPAGEID cpiDest,
            /* [in] */ LPCSTR pSource,
            /* [in] */ int __RPC_FAR *pnSizeOfSource,
            /* [out] */ LPSTR pDestination,
            /* [in] */ int __RPC_FAR *pnDstSize);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rfc1522Decode )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ LPCSTR pszValue,
            /* [ref][in] */ LPSTR pszCharset,
            /* [in] */ ULONG cchmax,
            /* [out] */ LPSTR __RPC_FAR *ppszDecoded);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Rfc1522Encode )(
            IMimeInternational __RPC_FAR * This,
            /* [in] */ LPCSTR pszValue,
            /* [in] */ HCHARSET hCharset,
            /* [out] */ LPSTR __RPC_FAR *ppszEncoded);

        END_INTERFACE
    } IMimeInternationalVtbl;

    interface IMimeInternational
    {
        CONST_VTBL struct IMimeInternationalVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeInternational_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeInternational_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeInternational_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeInternational_SetDefaultCharset(This,hCharset)	\
    (This)->lpVtbl -> SetDefaultCharset(This,hCharset)

#define IMimeInternational_GetDefaultCharset(This,phCharset)	\
    (This)->lpVtbl -> GetDefaultCharset(This,phCharset)

#define IMimeInternational_GetCodePageCharset(This,cpiCodePage,ctCsetType,phCharset)	\
    (This)->lpVtbl -> GetCodePageCharset(This,cpiCodePage,ctCsetType,phCharset)

#define IMimeInternational_FindCharset(This,pszCharset,phCharset)	\
    (This)->lpVtbl -> FindCharset(This,pszCharset,phCharset)

#define IMimeInternational_GetCharsetInfo(This,hCharset,pCsetInfo)	\
    (This)->lpVtbl -> GetCharsetInfo(This,hCharset,pCsetInfo)

#define IMimeInternational_GetCodePageInfo(This,cpiCodePage,pCodePageInfo)	\
    (This)->lpVtbl -> GetCodePageInfo(This,cpiCodePage,pCodePageInfo)

#define IMimeInternational_CanConvertCodePages(This,cpiSource,cpiDest)	\
    (This)->lpVtbl -> CanConvertCodePages(This,cpiSource,cpiDest)

#define IMimeInternational_DecodeHeader(This,hCharset,pszData,pDecoded,pRfc1522Info)	\
    (This)->lpVtbl -> DecodeHeader(This,hCharset,pszData,pDecoded,pRfc1522Info)

#define IMimeInternational_EncodeHeader(This,hCharset,pData,ppszEncoded,pRfc1522Info)	\
    (This)->lpVtbl -> EncodeHeader(This,hCharset,pData,ppszEncoded,pRfc1522Info)

#define IMimeInternational_ConvertBuffer(This,cpiSource,cpiDest,pIn,pOut,pcbRead)	\
    (This)->lpVtbl -> ConvertBuffer(This,cpiSource,cpiDest,pIn,pOut,pcbRead)

#define IMimeInternational_ConvertString(This,cpiSource,cpiDest,pIn,pOut)	\
    (This)->lpVtbl -> ConvertString(This,cpiSource,cpiDest,pIn,pOut)

#define IMimeInternational_MLANG_ConvertInetReset(This)	\
    (This)->lpVtbl -> MLANG_ConvertInetReset(This)

#define IMimeInternational_MLANG_ConvertInetString(This,cpiSource,cpiDest,pSource,pnSizeOfSource,pDestination,pnDstSize)	\
    (This)->lpVtbl -> MLANG_ConvertInetString(This,cpiSource,cpiDest,pSource,pnSizeOfSource,pDestination,pnDstSize)

#define IMimeInternational_Rfc1522Decode(This,pszValue,pszCharset,cchmax,ppszDecoded)	\
    (This)->lpVtbl -> Rfc1522Decode(This,pszValue,pszCharset,cchmax,ppszDecoded)

#define IMimeInternational_Rfc1522Encode(This,pszValue,hCharset,ppszEncoded)	\
    (This)->lpVtbl -> Rfc1522Encode(This,pszValue,hCharset,ppszEncoded)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMimeInternational_SetDefaultCharset_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ HCHARSET hCharset);


void __RPC_STUB IMimeInternational_SetDefaultCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_GetDefaultCharset_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [out] */ LPHCHARSET phCharset);


void __RPC_STUB IMimeInternational_GetDefaultCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_GetCodePageCharset_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ CODEPAGEID cpiCodePage,
    /* [in] */ CHARSETTYPE ctCsetType,
    /* [out] */ LPHCHARSET phCharset);


void __RPC_STUB IMimeInternational_GetCodePageCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_FindCharset_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ LPCSTR pszCharset,
    /* [out] */ LPHCHARSET phCharset);


void __RPC_STUB IMimeInternational_FindCharset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_GetCharsetInfo_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ HCHARSET hCharset,
    /* [out][in] */ LPINETCSETINFO pCsetInfo);


void __RPC_STUB IMimeInternational_GetCharsetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_GetCodePageInfo_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ CODEPAGEID cpiCodePage,
    /* [out][in] */ LPCODEPAGEINFO pCodePageInfo);


void __RPC_STUB IMimeInternational_GetCodePageInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_CanConvertCodePages_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ CODEPAGEID cpiSource,
    /* [in] */ CODEPAGEID cpiDest);


void __RPC_STUB IMimeInternational_CanConvertCodePages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_DecodeHeader_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ HCHARSET hCharset,
    /* [in] */ LPCSTR pszData,
    /* [out][in] */ LPPROPVARIANT pDecoded,
    /* [out][in] */ LPRFC1522INFO pRfc1522Info);


void __RPC_STUB IMimeInternational_DecodeHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_EncodeHeader_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ HCHARSET hCharset,
    /* [in] */ LPPROPVARIANT pData,
    /* [out] */ LPSTR __RPC_FAR *ppszEncoded,
    /* [out][in] */ LPRFC1522INFO pRfc1522Info);


void __RPC_STUB IMimeInternational_EncodeHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_ConvertBuffer_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ CODEPAGEID cpiSource,
    /* [in] */ CODEPAGEID cpiDest,
    /* [in] */ LPBLOB pIn,
    /* [out][in] */ LPBLOB pOut,
    /* [out] */ ULONG __RPC_FAR *pcbRead);


void __RPC_STUB IMimeInternational_ConvertBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_ConvertString_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ CODEPAGEID cpiSource,
    /* [in] */ CODEPAGEID cpiDest,
    /* [in] */ LPPROPVARIANT pIn,
    /* [out][in] */ LPPROPVARIANT pOut);


void __RPC_STUB IMimeInternational_ConvertString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_MLANG_ConvertInetReset_Proxy(
    IMimeInternational __RPC_FAR * This);


void __RPC_STUB IMimeInternational_MLANG_ConvertInetReset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_MLANG_ConvertInetString_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ CODEPAGEID cpiSource,
    /* [in] */ CODEPAGEID cpiDest,
    /* [in] */ LPCSTR pSource,
    /* [in] */ int __RPC_FAR *pnSizeOfSource,
    /* [out] */ LPSTR pDestination,
    /* [in] */ int __RPC_FAR *pnDstSize);


void __RPC_STUB IMimeInternational_MLANG_ConvertInetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_Rfc1522Decode_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ LPCSTR pszValue,
    /* [ref][in] */ LPSTR pszCharset,
    /* [in] */ ULONG cchmax,
    /* [out] */ LPSTR __RPC_FAR *ppszDecoded);


void __RPC_STUB IMimeInternational_Rfc1522Decode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMimeInternational_Rfc1522Encode_Proxy(
    IMimeInternational __RPC_FAR * This,
    /* [in] */ LPCSTR pszValue,
    /* [in] */ HCHARSET hCharset,
    /* [out] */ LPSTR __RPC_FAR *ppszEncoded);


void __RPC_STUB IMimeInternational_Rfc1522Encode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMimeInternational_INTERFACE_DEFINED__ */


#ifndef __IMimeSecurity_INTERFACE_DEFINED__
#define __IMimeSecurity_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMimeSecurity
 * at Mon May 12 23:53:20 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][helpstring][uuid] */


typedef /* [unique] */ IMimeSecurity __RPC_FAR *LPMIMESECURITY;

typedef /* [unique] */ const IMimeSecurity __RPC_FAR *LPCMIMESECURITY;

typedef BLOB THUMBBLOB;

typedef const void __RPC_FAR *PCX509CERT;

typedef void __RPC_FAR *HCAPICERTSTORE;

#ifndef IMS_ALGIDDEF
#define IMS_ALGIDDEF
typedef unsigned int ALG_ID;

#endif
typedef
enum tagCERTSTATE
    {	CERTIFICATE_OK	= 0,
	CERTIFICATE_NOT_PRESENT	= CERTIFICATE_OK + 1,
	CERTIFICATE_EXPIRED	= CERTIFICATE_NOT_PRESENT + 1,
	CERTIFICATE_CHAIN_TOO_LONG	= CERTIFICATE_EXPIRED + 1,
	CERTIFICATE_TIMES_DONT_NEST	= CERTIFICATE_CHAIN_TOO_LONG + 1,
	CERTIFICATE_MISSING_ISSUER	= CERTIFICATE_TIMES_DONT_NEST + 1,
	CERTIFICATE_CRL_LISTED	= CERTIFICATE_MISSING_ISSUER + 1,
	CERTIFICATE_NOT_TRUSTED	= CERTIFICATE_CRL_LISTED + 1,
	CERTIFICATE_INVALID	= CERTIFICATE_NOT_TRUSTED + 1,
	CERTIFICATE_ERROR	= CERTIFICATE_INVALID + 1,
	CERTIFICATE_NOPRINT	= CERTIFICATE_ERROR + 1,
	CERTIFICATE_UNKNOWN	= CERTIFICATE_NOPRINT + 1
    }	CERTSTATE;

typedef
enum tagCERTNAMETYPE
    {	SIMPLE	= 0,
	OID	= SIMPLE + 1,
	X500	= OID + 1
    }	CERTNAMETYPE;

typedef
enum tagSECURESTATE
    {	SECURITY_TOGGLE	= -1,
	SECURITY_DISABLED	= SECURITY_TOGGLE + 1,
	SECURITY_ENABLED	= SECURITY_DISABLED + 1,
	SECURITY_BAD	= SECURITY_ENABLED + 1,
	SECURITY_UNTRUSTED	= SECURITY_BAD + 1,
	SECURITY_UNKNOWN	= SECURITY_UNTRUSTED + 1,
	SECURITY_STATE_MAX	= SECURITY_UNKNOWN + 1
    }	SECURESTATE;

typedef
enum tagCERTDATAID
    {	CDID_EMAIL	= 0,
	CDID_MAX	= CDID_EMAIL + 1
    }	CERTDATAID;

typedef
enum tagSECURETYPE
    {	SECURITY_NONE	= 0,
	SMIME_ENCRYPT	= 0x1,
	SMIME_SIGN	= 0x2,
	SMIME_CLEARSIGN	= 0x4,
	SMIME_SIGNANDENCRYPT	= SMIME_ENCRYPT | SMIME_SIGN
    }	SECURETYPE;

typedef
enum tagSECURECLASS
    {	ISC_NULL	= 0,
	ISC_SIGNED	= SMIME_SIGN | SMIME_CLEARSIGN,
	ISC_ENCRYPTED	= SMIME_ENCRYPT,
	ISC_ALL	= 0xffff
    }	SECURECLASS;

typedef struct  tagSMIMESECURITY
    {
    SECURESTATE stState;
    LPSTR oidAlg;
    ULONG cCert;
    PCX509CERT __RPC_FAR *rgpCert;
    }	SMIMESECURITY;

typedef struct tagSMIMESECURITY __RPC_FAR *PSMIMESECURITY;

typedef const SMIMESECURITY __RPC_FAR *PCSMIMESECURITY;

typedef struct  tagSMIMEINFO
    {
    SECURETYPE stMsgEnhancement;
    SMIMESECURITY ssSign;
    SMIMESECURITY ssEncrypt;
    PCX509CERT pSendersCert;
    BOOL fTrustedCert;
    BOOL fCertWithMsg;
    DWORD dwIgnoreFlags;
    HCAPICERTSTORE hMsgCertStore;
    }	SMIMEINFO;

typedef struct tagSMIMEINFO __RPC_FAR *PSMIMEINFO;

typedef const SMIMEINFO __RPC_FAR *PCSMIMEINFO;

typedef struct  tagX509CERTRESULT
    {
    DWORD cEntries;
    CERTSTATE __RPC_FAR *rgcs;
    PCX509CERT __RPC_FAR *rgpCert;
    }	X509CERTRESULT;

typedef struct tagX509CERTRESULT __RPC_FAR *PX509CERTRESULT;

typedef const X509CERTRESULT __RPC_FAR *PCX509CERTRESULT;


EXTERN_C const IID IID_IMimeSecurity;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("6AD6A1FE-C19B-11d0-85EB-00C04FD85AB4")
    IMimeSecurity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EncodeMessage(
            /* [out][in] */ IMimeMessageTree __RPC_FAR *const pTree,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE DecodeMessage(
            /* [out][in] */ IMimeMessageTree __RPC_FAR *const pTree,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE EncodeStream(
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPSTREAM lpstmIn,
            /* [in] */ LPSTREAM lpstmOut) = 0;

        virtual HRESULT STDMETHODCALLTYPE DecodeStream(
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPSTREAM lpstmIn,
            /* [in] */ LPSTREAM lpstmOut) = 0;

        virtual HRESULT STDMETHODCALLTYPE EncodeBlob(
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPBLOB pIn,
            /* [out] */ LPBLOB pOut) = 0;

        virtual HRESULT STDMETHODCALLTYPE DecodeBlob(
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPBLOB pIn,
            /* [out] */ LPBLOB pOut) = 0;

        virtual HRESULT STDMETHODCALLTYPE DecodeDetachedStream(
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPSTREAM lpstmIn,
            /* [in] */ const LPSTREAM lpstmSig,
            /* [in] */ LPSTREAM lpstmOut) = 0;

        virtual HRESULT STDMETHODCALLTYPE DecodeDetachedBlob(
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPBLOB pData,
            /* [in] */ const LPBLOB pSig,
            /* [out] */ LPBLOB pOut) = 0;

        virtual HRESULT STDMETHODCALLTYPE InitNew( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE CheckInit( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE AddCertificateToStore(
            /* [in] */ HCAPICERTSTORE hc,
            /* [in] */ PCX509CERT pCert,
            /* [in] */ const BOOL fReplace,
            /* [in] */ const BOOL fAllowDups) = 0;

        virtual HRESULT STDMETHODCALLTYPE OpenSystemStore(
            /* [in] */ LPCTSTR szProtocol,
            /* [ref][out] */ HCAPICERTSTORE __RPC_FAR *pc) = 0;

        virtual HRESULT STDMETHODCALLTYPE CloseCertificateStore(
            /* [in] */ HCAPICERTSTORE hc) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCertsFromThumbprints(
            /* [in] */ THUMBBLOB __RPC_FAR *const rgThumbprint,
            /* [out][in] */ X509CERTRESULT __RPC_FAR *const pResults) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumCertificates(
            /* [in] */ HCAPICERTSTORE hc,
            /* [in] */ DWORD dwUsage,
            /* [in] */ PCX509CERT pPrev,
            /* [retval][out] */ PCX509CERT __RPC_FAR *ppCert) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCertificateName(
            /* [in] */ const PCX509CERT pX509Cert,
            /* [in] */ const CERTNAMETYPE cn,
            /* [retval][out] */ LPSTR __RPC_FAR *ppszName) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCertificateThumbprint(
            /* [in] */ const PCX509CERT pX509Cert,
            /* [retval][out] */ THUMBBLOB __RPC_FAR *const pPrint) = 0;

        virtual HRESULT STDMETHODCALLTYPE DuplicateCertificate(
            /* [in] */ const PCX509CERT pX509Cert,
            /* [retval][out] */ PCX509CERT __RPC_FAR *ppDupCert) = 0;

        virtual HRESULT STDMETHODCALLTYPE FreeCertificate(
            /* [unique][in] */ const PCX509CERT pc) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetMessageType(
            /* [unique][in] */ const LPSTREAM lpstmIn,
            /* [retval][out] */ SECURETYPE __RPC_FAR *pst) = 0;

        virtual HRESULT STDMETHODCALLTYPE VerifyTimeValidity(
            /* [in] */ const PCX509CERT pX509Cert) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetCertData(
            /* [in] */ const PCX509CERT pX509Cert,
            /* [in] */ const CERTDATAID dataid,
            /* [ref][out] */ LPPROPVARIANT pValue) = 0;

    };

#else 	/* C style interface */

    typedef struct IMimeSecurityVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IMimeSecurity __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IMimeSecurity __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EncodeMessage )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ IMimeMessageTree __RPC_FAR *const pTree,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DecodeMessage )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ IMimeMessageTree __RPC_FAR *const pTree,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EncodeStream )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPSTREAM lpstmIn,
            /* [in] */ LPSTREAM lpstmOut);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DecodeStream )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPSTREAM lpstmIn,
            /* [in] */ LPSTREAM lpstmOut);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EncodeBlob )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPBLOB pIn,
            /* [out] */ LPBLOB pOut);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DecodeBlob )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPBLOB pIn,
            /* [out] */ LPBLOB pOut);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DecodeDetachedStream )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPSTREAM lpstmIn,
            /* [in] */ const LPSTREAM lpstmSig,
            /* [in] */ LPSTREAM lpstmOut);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DecodeDetachedBlob )(
            IMimeSecurity __RPC_FAR * This,
            /* [out][in] */ SMIMEINFO __RPC_FAR *const psi,
            /* [in] */ const LPBLOB pData,
            /* [in] */ const LPBLOB pSig,
            /* [out] */ LPBLOB pOut);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitNew )(
            IMimeSecurity __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckInit )(
            IMimeSecurity __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddCertificateToStore )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ HCAPICERTSTORE hc,
            /* [in] */ PCX509CERT pCert,
            /* [in] */ const BOOL fReplace,
            /* [in] */ const BOOL fAllowDups);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenSystemStore )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ LPCTSTR szProtocol,
            /* [ref][out] */ HCAPICERTSTORE __RPC_FAR *pc);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseCertificateStore )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ HCAPICERTSTORE hc);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertsFromThumbprints )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ THUMBBLOB __RPC_FAR *const rgThumbprint,
            /* [out][in] */ X509CERTRESULT __RPC_FAR *const pResults);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCertificates )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ HCAPICERTSTORE hc,
            /* [in] */ DWORD dwUsage,
            /* [in] */ PCX509CERT pPrev,
            /* [retval][out] */ PCX509CERT __RPC_FAR *ppCert);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertificateName )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ const PCX509CERT pX509Cert,
            /* [in] */ const CERTNAMETYPE cn,
            /* [retval][out] */ LPSTR __RPC_FAR *ppszName);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertificateThumbprint )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ const PCX509CERT pX509Cert,
            /* [retval][out] */ THUMBBLOB __RPC_FAR *const pPrint);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DuplicateCertificate )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ const PCX509CERT pX509Cert,
            /* [retval][out] */ PCX509CERT __RPC_FAR *ppDupCert);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeCertificate )(
            IMimeSecurity __RPC_FAR * This,
            /* [unique][in] */ const PCX509CERT pc);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMessageType )(
            IMimeSecurity __RPC_FAR * This,
            /* [unique][in] */ const LPSTREAM lpstmIn,
            /* [retval][out] */ SECURETYPE __RPC_FAR *pst);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *VerifyTimeValidity )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ const PCX509CERT pX509Cert);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertData )(
            IMimeSecurity __RPC_FAR * This,
            /* [in] */ const PCX509CERT pX509Cert,
            /* [in] */ const CERTDATAID dataid,
            /* [ref][out] */ LPPROPVARIANT pValue);

        END_INTERFACE
    } IMimeSecurityVtbl;

    interface IMimeSecurity
    {
        CONST_VTBL struct IMimeSecurityVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IMimeSecurity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMimeSecurity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMimeSecurity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMimeSecurity_EncodeMessage(This,pTree,dwFlags)	\
    (This)->lpVtbl -> EncodeMessage(This,pTree,dwFlags)

#define IMimeSecurity_DecodeMessage(This,pTree,dwFlags)	\
    (This)->lpVtbl -> DecodeMessage(This,pTree,dwFlags)

#define IMimeSecurity_EncodeStream(This,psi,lpstmIn,lpstmOut)	\
    (This)->lpVtbl -> EncodeStream(This,psi,lpstmIn,lpstmOut)

#define IMimeSecurity_DecodeStream(This,psi,lpstmIn,lpstmOut)	\
    (This)->lpVtbl -> DecodeStream(This,psi,lpstmIn,lpstmOut)

#define IMimeSecurity_EncodeBlob(This,psi,pIn,pOut)	\
    (This)->lpVtbl -> EncodeBlob(This,psi,pIn,pOut)

#define IMimeSecurity_DecodeBlob(This,psi,pIn,pOut)	\
    (This)->lpVtbl -> DecodeBlob(This,psi,pIn,pOut)

#define IMimeSecurity_DecodeDetachedStream(This,psi,lpstmIn,lpstmSig,lpstmOut)	\
    (This)->lpVtbl -> DecodeDetachedStream(This,psi,lpstmIn,lpstmSig,lpstmOut)

#define IMimeSecurity_DecodeDetachedBlob(This,psi,pData,pSig,pOut)	\
    (This)->lpVtbl -> DecodeDetachedBlob(This,psi,pData,pSig,pOut)

#define IMimeSecurity_InitNew(This)	\
    (This)->lpVtbl -> InitNew(This)

#define IMimeSecurity_CheckInit(This)	\
    (This)->lpVtbl -> CheckInit(This)

#define IMimeSecurity_AddCertificateToStore(This,hc,pCert,fReplace,fAllowDups)	\
    (This)->lpVtbl -> AddCertificateToStore(This,hc,pCert,fReplace,fAllowDups)

#define IMimeSecurity_OpenSystemStore(This,szProtocol,pc)	\
    (This)->lpVtbl -> OpenSystemStore(This,szProtocol,pc)

#define IMimeSecurity_CloseCertificateStore(This,hc)	\
    (This)->lpVtbl -> CloseCertificateStore(This,hc)

#define IMimeSecurity_GetCertsFromThumbprints(This,rgThumbprint,pResults)	\
    (This)->lpVtbl -> GetCertsFromThumbprints(This,rgThumbprint,pResults)

#define IMimeSecurity_EnumCertificates(This,hc,dwUsage,pPrev,ppCert)	\
    (This)->lpVtbl -> EnumCertificates(This,hc,dwUsage,pPrev,ppCert)

#define IMimeSecurity_GetCertificateName(This,pX509Cert,cn,ppszName)	\
    (This)->lpVtbl -> GetCertificateName(This,pX509Cert,cn,ppszName)

#define IMimeSecurity_GetCertificateThumbprint(This,pX509Cert,pPrint)	\
    (This)->lpVtbl -> GetCertificateThumbprint(This,pX509Cert,pPrint)

#define IMimeSecurity_DuplicateCertificate(This,pX509Cert,ppDupCert)	\
    (This)->lpVtbl -> DuplicateCertificate(This,pX509Cert,ppDupCert)

#define IMimeSecurity_FreeCertificate(This,pc)	\
    (This)->lpVtbl -> FreeCertificate(This,pc)

#define IMimeSecurity_GetMessageType(This,lpstmIn,pst)	\
    (This)->lpVtbl -> GetMessageType(This,lpstmIn,pst)

#define IMimeSecurity_VerifyTimeValidity(This,pX509Cert)	\
    (This)->lpVtbl -> VerifyTimeValidity(This,pX509Cert)

#define IMimeSecurity_GetCertData(This,pX509Cert,dataid,pValue)	\
    (This)->lpVtbl -> GetCertData(This,pX509Cert,dataid,pValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETH