Font;
    ITEMDATA ItemData;
    TCHAR szFaceName[LF_FACESIZE];
    HANDLE hmemRTF, hmemClip;
    LPTSTR lpstrClipString;
    TCHAR achHeader[] = TEXT("{\\rtf1\\ansi {\\fonttbl{\\f0\\");
    TCHAR achMiddle[] = TEXT(";}}\\sectd\\pard\\plain\\f0 ");

    #define MAXLENGTHFONTFAMILY 8
    #define ALITTLEEXTRA 10    // Covers extra characters + length of font size.

    iCurrFont = (INT)SendDlgItemMessage(hwndDlg, ID_FONT, CB_GETCURSEL, 0, 0L);

    // Get the item data - contains fonttype, charset, and pitchandfamily.
    *(DWORD *)&ItemData = (DWORD)SendDlgItemMessage(hwndDlg, ID_FONT, CB_GETITEMDATA,
                                             iCurrFont, 0L);

    // Get the facename from the combo box.
    SendDlgItemMessage(hwndDlg, ID_FONT, CB_GETLBTEXT, iCurrFont,
                       (LPARAM)(LPTSTR)szFaceName);

    hmemRTF = GlobalAlloc(0, CTOB(lstrlen((LPTSTR)achHeader) +
                          MAXLENGTHFONTFAMILY +
                          lstrlen(szFaceName) +
                          lstrlen((LPTSTR)achMiddle) +
                          4 * lstrlen(lpstrText) +  // 4 times in case they're all > 7 bits
                          ALITTLEEXTRA));
    if (hmemRTF == NULL)
        return;

    // Allocate memory for local storage of clipboard string for owner draw.
    if (hmemClip  = GlobalAlloc(0, CTOB(lstrlen(lpstrText) + 1))) {
        // Get rid of old guys.
        if (hstrClipboard)
            GlobalFree(hstrClipboard);
        if (fDelClipboardFont) {
            fDelClipboardFont = FALSE;
            DeleteObject(hFontClipboard);
        }

        // Save this stuff away for owner drawing in a clipboard viewer.
        hFontClipboard = sycm.hFont;
        hstrClipboard = hmemClip;
        lstrcpy(GlobalLock(hstrClipboard), lpstrText);
        GlobalUnlock(hstrClipboard);
    } else {
        GlobalFree(hmemRTF);
        return;
    }

    lpstrClipString = GlobalLock(hmemRTF);

    lstrcpy(lpstrClipString, achHeader);

    if (ItemData.CharSet == SYMBOL_CHARSET) {
        lstrcat(lpstrClipString, (LPTSTR)TEXT("ftech "));
    } else {
        // top four bits specify family
        switch (ItemData.PitchAndFamily & 0xf0) {
            case FF_DECORATIVE:
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fdecor "));
                break;

            case FF_MODERN:
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fmodern "));
                break;

            case FF_ROMAN:
                lstrcat(lpstrClipString, (LPTSTR)TEXT("froman "));
                break;

            case FF_SCRIPT:
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fscript "));
                break;

            case FF_SWISS:
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fswiss "));
                break;

            default:
                break;
        }
    }

    lstrcat(lpstrClipString, szFaceName);

    lstrcat(lpstrClipString, (LPTSTR)achMiddle);

    /*
     * We need to do the text character by character, making sure
     * that we output a special sequence \'hh for characters bigger
     * than 7 bits long!
     */
    lpstrClipString = (LPTSTR)(lpstrClipString + lstrlen(lpstrClipString));
    while (*lpstrText) {
        if ((UTCHAR)*lpstrText < 128) {
            if (*lpstrText == TEXT('\\') || *lpstrText == TEXT('{') || *lpstrText == TEXT('}'))
                /*
                 * Need to preface these symbols with a '\' since they are
                 * special control characters for RTF.
                 */
                *lpstrClipString++ = TEXT('\\');

            *lpstrClipString++ = *lpstrText++;
        } else {
            *lpstrClipString++ = TEXT('\\');
            *lpstrClipString++ = TEXT('\'');
#ifdef BUG
//
//PERF - GregoryW 23/10/92  need a Unicode version of itoa...
//
            _itoa(*(UTCHAR FAR *)lpstrText++, achMiddle, 16);
#else
            wsprintf(achMiddle, TEXT("%x"), (INT)*lpstrText);
            lpstrText++;
#endif
            *lpstrClipString++ = achMiddle[0];
            *lpstrClipString++ = achMiddle[1];
        }
    }
    *lpstrClipString++ = TEXT('}');
    *lpstrClipString = TEXT('\0');

    if (!wCFRichText) {
         TCHAR szRTF[80];

         LoadString(hInst, IDS_RTF, szRTF, BTOC(sizeof(szRTF)) - 1);
         wCFRichText = RegisterClipboardFormat(szRTF);
    }

    // Put RTF and OwnerDisplay formats in the clipboard.
    SetClipboardData(wCFRichText, hmemRTF);
    SetClipboardData(CF_OWNERDISPLAY, NULL);
}

/****************************************************************************

    FUNCTION: PointsToHeight(int);

    PURPOSE:  Calculates the height in pixels of the specified point
              size for the current display.

    COMMENTS:

****************************************************************************/

INT PointsToHeight(INT iPoints)
{
    HDC hdc;
    INT iHeight;

    hdc = GetDC(HWND_DESKTOP);
    iHeight = MulDiv(iPoints, GetDeviceCaps(hdc, LOGPIXELSY), 72);
    ReleaseDC(HWND_DESKTOP, hdc);
    return(iHeight);
}

/****************************************************************************

    FUNCTION: UpdateKeystrokeText(HDC, UTCHAR, BOOL);

    PURPOSE:  Calculates and updates the text string displayed in the
              Keystroke field of the status bar.

    COMMENTS:  Repaints status field if fRedraw == TRUE.

****************************************************************************/

VOID UpdateKeystrokeText(
    HDC hdc,
    UTCHAR chNew,
    BOOL fRedraw)
{
    TCHAR szUnshifted[2];
    SHORT vkRes;

#ifdef UNICODE
    if (chNew > 255) {
        lstrcpy(szKeystrokeText, szUnicodeLabel);
        wsprintf((LPTSTR)(szKeystrokeText + iUnicodeLabelStart), TEXT("U+%04x"), chNew);
    } else {
#endif
    lstrcpy(szKeystrokeText, szKeystrokeLabel);
    if (chNew == TEXT(' ')) {
        lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szSpace);
    } else {
        vkRes = VkKeyScan(chNew);
        /*
         * Map the virtual key code into an unshifted character value
         */
        szUnshifted[0] = (TCHAR)MapVirtualKey(LOBYTE(vkRes), 2);
        szUnshifted[1] = TEXT('\0');

        switch(HIBYTE(vkRes)) {
            case 0: // Unshifted char.
            case 1: // Character is shifted, just display the shifted char.
                szKeystrokeText[iKeystrokeTextStart] = chNew;
                szKeystrokeText[iKeystrokeTextStart + 1] = TEXT('\0');
                break;

            case 2: // Character is control character.
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szCtrl);
                lstrcat(szKeystrokeText, (LPTSTR)szUnshifted);
                break;

            case 6: // Character is CONTROL+ALT.
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szCtrlAlt);
                lstrcat(szKeystrokeText, (LPTSTR)szUnshifted);
                break;

            case 7: // Character is SHIFT+CONTROL+ALT.
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szShiftCtrlAlt);
                lstrcat(szKeystrokeText, (LPTSTR)szUnshifted);
                break;

            default: // Character created via Alt + Numpad
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szAlt);
                wsprintf((LPTSTR)(szKeystrokeText + lstrlen(szKeystrokeText)), TEXT("%d"), chNew);
                break;
        }
    }
#ifdef UNICODE
    }
#endif

    if (fRedraw)
        PaintStatusLine(hdc, FALSE, TRUE);
}


/****************************************************************************

    FUNCTION: UpdateHelpText(LPMSG, HWND);

    PURPOSE:  Calculates if the Help string needs to be updated, and does
              so if necessary.

    COMMENTS:  If hwndCtrl is not NULL, then it specifies the window handle
               of the control gaining focus, and lpmsg is ignored.

               If hwndCtrl is NULL, then lpmsg must point to a valid message
               structure.  If it is a tab character, then we calculate
               what the next control is that will receive the focus.
****************************************************************************/

BOOL UpdateHelpText(
    LPMSG lpmsg,
    HWND hwndCtrl)
{
    HDC hdc;
    BOOL fPaintStatus = FALSE;
    BOOL fRet = TRUE;

    if (hwndCtrl != NULL) {
        fPaintStatus = TRUE;
        iControl = GetDlgCtrlID(hwndCtrl);
    } else  if (lpmsg->message == WM_KEYDOWN) {
        if (lpmsg->wParam == VK_TAB) {
            fPaintStatus = TRUE;
            hwndCtrl = GetNextDlgTabItem(hwndDialog,
                                         GetDlgItem(hwndDialog, iControl),
                                         (BOOL)(GetKeyState(VK_SHIFT) & 0x8000));
            iControl = GetDlgCtrlID(hwndCtrl);
            if (iControl == ID_STRING) {
                /*
                 * Do this ourselves, otherwise default action will select
                 * the whole edit control.
                 */
                SetFocus(hwndCtrl);
                fRet = FALSE;
            }
            if (iControl == ID_CHARGRID) {
                /*
                 * Set the default button back to "Select".  The default
                 * might have changed to the "Next" or "Previous" button.
                 */
                SendMessage(hwndDialog, DM_SETDEFID, ID_SELECT, 0);
            }
        } else if (lpmsg->wParam == VK_F1) {
            PostMessage(hwndDialog, WM_COMMAND, ID_HELP, 0L);
        }
    }

    if (fPaintStatus) {
        hdc = GetDC(hwndDialog);
        PaintStatusLine(hdc, TRUE, FALSE);
        ReleaseDC(hwndDialog, hdc);
    }

    return (fRet);
}

/****************************************************************************

    FUNCTION: UpdateSymbolSelection(HWND, INT, INT);

    PURPOSE:  Updates the values of the following global values:
                  chSymFirst
                  chSymLast
                  sycm.chCurr
              Subsets in the Unicode character set have different numbers
              of characters.  We have to do some bounds checking in order
              to set an appropriate sycm.chCurr value.  The "Keystroke"
              status field is updated.

    COMMENTS:  Repaints Keystroke field if HWND != NULL.

****************************************************************************/
VOID UpdateSymbolSelection(
    HWND hwnd,
    INT FirstChar,
    INT LastChar)
{
    UTCHAR chSymOffset;

    chSymOffset = sycm.chCurr - chSymFirst;
    chSymFirst = (UTCHAR)FirstChar;
    chSymLast = (UTCHAR)LastChar;
    sycm.chCurr = chSymOffset + chSymFirst;
    if (sycm.chCurr > chSymLast) {
        sycm.chCurr = chSymFirst;
    }
    if (hwnd != NULL) {
        HDC hdc;

        hdc = GetDC(hwnd);
        UpdateKeystrokeText(hdc, sycm.chCurr, TRUE);
        ReleaseDC(hwnd, hdc);
    } else {
        UpdateKeystrokeText(NULL, sycm.chCurr, FALSE);
    }
}

/****************************************************************************

    FUNCTION: PaintStatusLine(HDC, BOOL, BOOL);

    PURPOSE:  Paints the Help and Keystroke fields in the status bar.

    COMMENTS:  Repaints Help field if fHelp == TRUE, repaints the Keystroke
               field if fKeystroke == TRUE.

****************************************************************************/

VOID PaintStatusLine(
    HDC hdc,
    BOOL fHelp,
    BOOL fKeystroke)
{
    HFONT hfontOld = NULL;
    RECT rect;
    INT dyBorder;
    TCHAR szHelpText[100];

    dyBorder = GetSystemMetrics(SM_CYBORDER);

    if (hfontStatus)
        hfontOld = SelectObject(hdc, hfontStatus);

    // set the text and background colors

    SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));

    if (fHelp) {
        // now the help text, with a gray background

        rect.top    = rcStatusLine.top + 3 * dyBorder;
        rect.bottom = rcStatusLine.bottom - 3 * dyBorder;
        rect.left   = 9 * dyBorder;
        rect.right  = rect.left + dxHelpField - 2 * dyBorder;

        LoadString(hInst, iControl, szHelpText, BTOC(sizeof(szHelpText)) - 1);

        ExtTextOut(hdc, rect.left + dyBorder * 2, rect.top,
                   ETO_OPAQUE | ETO_CLIPPED, &rect, szHelpText,
                   lstrlen(szHelpText), NULL);
    }

    if (fKeystroke) {
        // now the keystroke text, with a gray background
        rect.top    = rcStatusLine.top + 3 * dyBorder;
        rect.bottom = rcStatusLine.bottom - 3 * dyBorder;
        rect.right = rcStatusLine.right - 9 * dyBorder;
        rect.left = rect.right - dxKeystrokeField + 2 * dyBorder;

        ExtTextOut(hdc, rect.left + dyBorder * 2, rect.top,
                   ETO_OPAQUE | ETO_CLIPPED, &rect, szKeystrokeText,
                   lstrlen(szKeystrokeText), NULL);
    }

    if (hfontOld)
        SelectObject(hdc, hfontOld);

}

/****************************************************************************

    FUNCTION: DrawFamilyComboItem(LPDRAWITEMSTRUCT)

    PURPOSE:  Paints the font facenames and TT bitmap in the font combo box.

    COMMENTS:

****************************************************************************/

BOOL DrawFamilyComboItem(
    LPDRAWITEMSTRUCT lpdis)
{
    HDC hDC, hdcMem;
    DWORD rgbBack, rgbText;
    TCHAR szFace[LF_FACESIZE];
    HBITMAP hOld;
    INT dy;
    SHORT  sFontType;

    hDC = lpdis->hDC;

    if (lpdis->itemState & ODS_SELECTED) {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    } else {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    SendMessage(lpdis->hwndItem, CB_GETLBTEXT, lpdis->itemID, (LPARAM)(LPTSTR)szFace);
    ExtTextOut(hDC, lpdis->rcItem.left + DX_BITMAP, lpdis->rcItem.top, ETO_OPAQUE | ETO_CLIPPED, &lpdis->rcItem, szFace, lstrlen(szFace), NULL);

    hdcMem = CreateCompatibleDC(hDC);
    if (hdcMem) {
        if (hbmFont) {
            hOld = SelectObject(hdcMem, hbmFont);
            sFontType = ((ITEMDATA FAR *)&(lpdis->itemData))->FontType;

            if (sFontType)
            {
                int xSrc;

                dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - DY_BITMAP) / 2;

                if (sFontType & TRUETYPE_FONT)
                    xSrc = 0;
                else if (sFontType & TT_OPENTYPE_FONT)
                    xSrc = 2;
                else if (sFontType & PS_OPENTYPE_FONT)
                    xSrc = 3;
                else if (sFontType & TYPE1_FONT)
                    xSrc = 4;

                BitBlt(hDC, lpdis->rcItem.left, lpdis->rcItem.top + dy, DX_BITMAP, DY_BITMAP, hdcMem,
                        xSrc*DX_BITMAP, lpdis->itemState & ODS_SELECTED ? DY_BITMAP : 0, SRCCOPY);
            }

            SelectObject(hdcMem, hOld);
        }
        DeleteDC(hdcMem);
    }

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return TRUE;
}

/****************************************************************************

    FUNCTION: LoadBitmaps(int)

    PURPOSE:  This routine loads DIB bitmaps, and "fixes up" their color tables
              so that we get the desired result for the device we are on.

    COMMENTS: This routine requires:
              - The DIB is a 16 color DIB authored with the standard windows colors.
              - bright blue (00 00 FF) is converted to the background color.
              - light grey  (C0 C0 C0) is replaced with the button face color.
              - dark grey   (80 80 80) is replaced with the button shadow color.

              This means you can't have any of these colors in your bitmap.

****************************************************************************/

HBITMAP LoadBitmaps(INT id)
{
  HDC                   hdc;
  HANDLE                h;
  DWORD FAR             *p;
  LPBYTE                lpBits;
  HANDLE                hRes;
  LPBITMAPINFOHEADER    lpBitmapInfo;
  INT numcolors;
  DWORD rgbSelected;
  DWORD rgbUnselected;
  HBITMAP hbm;

  rgbSelected = GetSysColor(COLOR_HIGHLIGHT);
  // Flip the colors.
  rgbSelected = RGB(GetBValue(rgbSelected),
                    GetGValue(rgbSelected),
                    GetRValue(rgbSelected));
  rgbUnselected = GetSysColor(COLOR_WINDOW);
  // Flip the colors.
  rgbUnselected = RGB(GetBValue(rgbUnselected),
                      GetGValue(rgbUnselected),
                      GetRValue(rgbUnselected));


  h = FindResource(hInst, MAKEINTRESOURCE(id), RT_BITMAP);
  hRes = LoadResource(hInst, h);

  /* Lock the bitmap and get a pointer to the color table. */
  lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

  if (!lpBitmapInfo)
        return FALSE;

  p = (DWORD FAR *)((LPSTR)(lpBitmapInfo) + lpBitmapInfo->biSize);

  /* Search for the Solid Blue entry and replace it with the current
   * background RGB.
   */
  numcolors = 16;

  while (numcolors-- > 0) {
      if (*p == BACKGROUND)
          *p = rgbUnselected;
      else if (*p == BACKGROUNDSEL)
          *p = rgbSelected;
      p++;
  }
  UnlockResource(hRes);

  /* Now create the DIB. */
  lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

  /* First skip over the header structure */
  lpBits = (LPBYTE)(lpBitmapInfo + 1);

  /* Skip the color table entries, if any */
  lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

  /* Create a color bitmap compatible with the display device */
  hdc = GetDC(NULL);
  hbm = CreateDIBitmap(hdc, lpBitmapInfo, (DWORD)CBM_INIT, lpBits, (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS);
  ReleaseDC(NULL, hdc);

  GlobalUnlock(hRes);
  FreeResource(hRes);

  return hbm;
}


/****************************************************************************

    FUNCTION: DoHelp(HWND, BOOL)

    PURPOSE:  This routine invokes help if BOOL is true, or dismisses help
              if BOOL is false.

    COMMENTS:

****************************************************************************/

VOID DoHelp(HWND hWnd, BOOL fInvokeHelp)
{
    TCHAR szHelp[80];

    if (LoadString(hInst, IDS_HELP, szHelp, BTOC(sizeof(szHelp)) - 1)) {
        if (fInvokeHelp)
            WinHelp(hWnd, (LPTSTR)szHelp, HELP_INDEX, 0L);
        else
            WinHelp(hWnd, (LPTSTR)szHelp, HELP_QUIT, 0L);
    }

}

/****************************************************************************

    FUNCTION: SaveFont(HWND)

    PURPOSE:  Used to save the current font facename in win.ini, so that
              it can be selected the next time charmap comes up.

    COMMENTS:

****************************************************************************/

VOID SaveCurrentFont(HWND hWndDlg)
{
    TCHAR szFaceName[LF_FACESIZE] = TEXT("");

    SendDlgItemMessage(hWndDlg, ID_FONT, CB_GETLBTEXT,
                       (WORD)SendDlgItemMessage(hWndDlg, ID_FONT, CB_GETCURSEL,
                                                0, 0L),
                       (LPARAM)(LPTSTR)szFaceName);

    WriteProfileString(TEXT("MSCharMap"), TEXT("Font"), (LPTSTR)szFaceName);
}


/****************************************************************************

    FUNCTION: SelectInitialFont(HWND)

    PURPOSE:  Used to select the initial font by getting a saved facename
              from win.ini and selecting it in the combo box.

    COMMENTS: Returns index to font selected.

****************************************************************************/

INT SelectInitialFont(HWND hWndDlg)
{
    TCHAR szFaceName[LF_FACESIZE] = TEXT("");
    INT iIndex;

    if ((GetProfileString(TEXT("MSCharMap"), TEXT("Font"), NULL, (LPTSTR)szFaceName,
                          BTOC(sizeof(szFaceName))) == 0) ||
        ((iIndex = (INT)SendDlgItemMessage(hWndDlg, ID_FONT, CB_SELECTSTRING, (WPARAM)-1,
                               (LPARAM)(LPTSTR)szFaceName)) == CB_ERR)) {
        /*
         * If there was no profile or the selection failed then try selecting
         * the symbol font, if that fails then select the first one.
         */
        if ((iIndex = (INT)SendDlgItemMessage(hWndDlg, ID_FONT, CB_SELECTSTRING,
                                (WPARAM)-1, (LPARAM)(LPTSTR)TEXT("Symbol"))) == CB_ERR)
            SendDlgItemMessage(hWndDlg, ID_FONT, CB_SETCURSEL, iIndex = 0, 0L);
    }

    return(iIndex);
}


/****************************************************************************

    FUNCTION: SaveCurrentSubset(HWND)

    PURPOSE:  Used to save the current subset name in win.ini, so that
              it can be selected the next time charmap comes up.

    COMMENTS:

****************************************************************************/

VOID SaveCurrentSubset(HWND hWndDlg)
{
    TCHAR szSubsetName[LF_SUBSETSIZE] = TEXT("");

    SendDlgItemMessage(hWndDlg, ID_UNICODESUBSET, CB_GETLBTEXT,
                       (WORD)SendDlgItemMessage(hWndDlg, ID_UNICODESUBSET, CB_GETCURSEL,
                                                0, 0L),
                       (LPARAM)(LPTSTR)szSubsetName);

    WriteProfileString(TEXT("MSCharMap"), TEXT("Block"), (LPTSTR)szSubsetName);
}


/****************************************************************************

    FUNCTION: SelectInitialSubset(HWND)

    PURPOSE:  Used to select the initial Unicode subset by getting a saved
              block name from win.ini.

    COMMENTS: Returns index to subset selected.

****************************************************************************/

INT SelectInitialSubset(HWND hWndDlg)
{
    TCHAR szSubsetName[LF_SUBSETSIZE] = TEXT("");
    INT iIndex;

    if (
        (GetProfileString(
             TEXT("MSCharMap"),
             TEXT("Block"),
             NULL,
             (LPTSTR)szSubsetName,
             BTOC(sizeof(szSubsetName))
             ) == 0)
       || ((iIndex = (INT)SendDlgItemMessage(
                              hWndDlg,
                              ID_UNICODESUBSET,
                              CB_SELECTSTRING,
                              (WPARAM)-1,
                              (LPARAM)(LPTSTR)szSubsetName
                              )) == CB_ERR)) {
        /*
         * If there was no profile or the selection failed then try selecting
         * the Basic Latin block, if that fails then select the first one.
         */
        if ((iIndex = (INT)SendDlgItemMessage(
                               hWndDlg,
                               ID_UNICODESUBSET,
                               CB_SELECTSTRING,
                               (WPARAM)-1,
                               (LPARAM)(LPTSTR)TEXT("Basic Latin")
                               )) == CB_ERR)
            SendDlgItemMessage(hWndDlg, ID_UNICODESUBSET, CB_SETCURSEL, iIndex = 0, 0L);
    }

    chSymFirst = (UTCHAR)aSubsetData[iIndex].BeginRange;
    chSymLast = (UTCHAR)aSubsetData[iIndex].EndRange;
    sycm.chCurr = chSymFirst;

    return iIndex;
}


/****************************************************************************

    FUNCTION: ExitMagnify(HWND, SYCM)

    PURPOSE:  Used to release mouse capture, exit magnify mode,
              and restore the cursor.

    COMMENTS:

****************************************************************************/

VOID ExitMagnify(
    HWND hWnd,
    PSYCM psycm)
{
    // Release capture, remove magnified character, restore cursor.
    ReleaseCapture();
    RestoreSymMag(psycm);
    DrawSymChOutlineHwnd(psycm, hWnd, psycm->chCurr, TRUE, TRUE);
    if (psycm->fCursorOff)
        ShowCursor(TRUE);
    psycm->fMouseDn = psycm->fCursorOff = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ucharmap\charmap.h ===
#include "cmdlg.h"

/* Type definitions. */
#ifdef UNICODE
typedef unsigned short UTCHAR;
#else
typedef unsigned char UTCHAR;
#endif

#define BTOC(bytes)  ((bytes) / sizeof(TCHAR))
#define CTOB(cch)    ((cch) * sizeof(TCHAR))
#define UCHAR unsigned char

typedef struct tagSYCM
  {
    INT dxpBox;
    INT dypBox;
    INT dxpCM;
    INT dypCM;
    INT xpCh;
    INT ypCh;
    INT dxpMag;
    INT dypMag;
    INT xpMagCurr;
    INT ypMagCurr;
    INT ypDest;
    INT xpCM;
    INT ypCM;

    BOOL fHasFocus;
    BOOL fFocusState;
    BOOL fMouseDn;
    BOOL fCursorOff;
    BOOL fAnsiFont;
    UTCHAR chCurr;
    HFONT hFontMag;
    HFONT hFont;
    HDC hdcMag;
    HBITMAP hbmMag;
    INT rgdxp[255];
  } SYCM;
typedef SYCM *PSYCM;

typedef struct tagITEMDATA
  {
    SHORT FontType;
    BYTE CharSet;
    BYTE PitchAndFamily;
  } ITEMDATA;


#define LF_SUBSETSIZE 40

typedef struct tagUSUBSET
  {
    INT BeginRange;
    INT EndRange;
    INT StringResId;
    TCHAR Name[LF_SUBSETSIZE];
  } USUBSET;

/* Function declarations. */

BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, INT);
INT_PTR  APIENTRY CharMapDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT  APIENTRY CharGridWndProc(HWND, UINT, WPARAM, LPARAM);
INT ChFromSymLParam(PSYCM, LPARAM);
VOID DrawSymChOutlineHwnd(PSYCM, HWND, UTCHAR, BOOL, BOOL);
VOID RecalcCharMap(HWND, PSYCM, INT, BOOL);
VOID DrawSymbolMap(PSYCM, HDC);
VOID DrawSymbolGrid(PSYCM, HDC);
VOID DrawSymbolChars(PSYCM, HDC);
VOID DrawSymChOutline(PSYCM, HDC, UTCHAR, BOOL, BOOL);
VOID MoveSymbolSel(PSYCM, UTCHAR);
VOID RestoreSymMag(PSYCM);
INT  APIENTRY FontLoadProc(LPLOGFONT, NEWTEXTMETRICEX*, DWORD, LPARAM);
HANDLE GetEditText(HWND);
VOID CopyString(HWND);
VOID SendRTFToClip(HWND, LPTSTR);
INT PointsToHeight(INT);
VOID UpdateKeystrokeText(HDC, UTCHAR, BOOL);
VOID PaintStatusLine(HDC, BOOL, BOOL);
BOOL UpdateHelpText(LPMSG, HWND);
INT KeyboardVKeyFromChar(UTCHAR);
BOOL DrawFamilyComboItem(LPDRAWITEMSTRUCT);
HBITMAP LoadBitmaps(INT);
VOID DoHelp(HWND, BOOL);
VOID SaveCurrentFont(HWND);
INT SelectInitialFont(HWND);
VOID ExitMagnify(HWND, PSYCM);
INT SelectInitialSubset(HWND);
VOID SaveCurrentSubset(HWND);
BOOL CALLBACK SubSetDlgProc(HWND, UINT, WPARAM, LPARAM);
VOID UpdateSymbolSelection(HWND, INT, INT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\winchat\dialogs.h ===
/*---------------------------------------------------------------------------*\
| DIALOGS HEADER
|   This module contains the definitions for the dialog object.
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 01-Nov-91
| history: 01-Nov-91 <clausgi>  created.
|          29-Dec-92 <chriswil> port to NT, cleanup.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

#define IDD_CONNECT         100
#define IDC_CONNECTNAME     101
#define IDD_PREFERENCES     200
#define ID_SIDEBYSIDE       201
#define ID_ANSONRESTORE     202
#define ID_TOPANDBOTTOM     203
#define ID_RECEIVEPFONT     204
#define ID_RECEIVEOFONT     205

/*
 * Context sensitive help IDs
 */
#define IDH_TOPANDBOTTOM    302
#define IDH_SIDEBYSIDE      303
#define IDH_RECEIVEPFONT    304
#define IDH_RECEIVEOFONT    305
#define IDH_OKBUTTON        306
#define IDH_CANCELBUTTON    307


INT_PTR  FAR  dlgDisplayBox(HINSTANCE,HWND,LPTSTR,DLGPROC,LPARAM);
INT_PTR CALLBACK dlgPreferencesProc(HWND,UINT,WPARAM,LPARAM);
INT_PTR CALLBACK dlgConnectProc(HWND,UINT,WPARAM,LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\ucharmap\cmdlg.h ===
#define ID_HELP                     100
#define ID_CLOSE                    101
#define ID_COPY                     102
#define ID_SELECT                   103
#define ID_STRING                   104
#define ID_FONT                     105
#define ID_TOPLEFT                  107
#define ID_CHARGRID                 108
#define ID_SUBSET                   109
#define IDBM_TT                     110
#define IDIC_CHARMAP                111
#define IDS_HELP                    112
#define IDS_RTF                     113
#define IDS_KEYSTROKE               114
#define IDS_SPACE                   115
#define IDS_CTRL                    116
#define IDS_CTRLALT                 117
#define IDS_SHIFTCTRLALT            118
#define IDS_ALT                     119
#define IDS_UNICODELABEL            120
#define IDS_LATIN1                    1
#define IDS_LATINEXA                  3
#define IDS_LATINEXB                  4
#define IDS_IPAEX                     5
#define IDS_SPACINGMODIFIERS          6
#define IDS_COMBININGDIACRITICS       7
#define IDS_BASICGREEK                8
#define IDS_GREEKSYMBOLS              9
#define IDS_CYRILLIC                 10
#define IDS_ARMENIAN                 11
#define IDS_HEBREW                   12
#define IDS_BASICHEBREW              12
#define IDS_HEBREWEX                 13
#define IDS_BASICARABIC              14
#define IDS_ARABICEX                 15
#define IDS_DEVANAGARI               16
#define IDS_BENGALI                  17
#define IDS_GURMUKHI                 18
#define IDS_GUJARATI                 19
#define IDS_ORIYA                    20
#define IDS_TAMIL                    21
#define IDS_TELUGU                   22
#define IDS_KANNADA                  23
#define IDS_MALAYALAM                24
#define IDS_THAI                     25
#define IDS_LAO                      26
#define IDS_BASICGEORGIAN            27
#define IDS_GEORGIANEX               28
#define IDS_HANGULJAMO               29
#define IDS_LATINEXADDITIONAL        30
#define IDS_GREEKEX                  31
#define IDS_GENERALPUNCTUATION       32
#define IDS_SUPERANDSUBSCRIPTS       33
#define IDS_CURRENCYSYMBOLS          34
#define IDS_COMBININGDIACRITICSFORSYMBOLS 35
#define IDS_LETTERLIKESYMBOLS        36
#define IDS_NUMBERFORMS              37
#define IDS_ARROWS                   38
#define IDS_MATHEMATICALOPS          39
#define IDS_MISCTECHNICAL            40
#define IDS_CONTROLPICTURES          41
#define IDS_OPTICALCHAR              42
#define IDS_ENCLOSEDALPHANUM         43
#define IDS_BOXDRAWING               44
#define IDS_BLOCKELEMENTS            45
#define IDS_GEOMETRICSHAPES          46
#define IDS_MISCDINGBATS             47
#define IDS_DINGBATS                 48
#define IDS_CJKSYMBOLSANDPUNC        49
#define IDS_HIRAGANA                 50
#define IDS_KATAKANA                 51
#define IDS_BOPOMOFO                 52
#define IDS_HANGULCOMPATIBILITYJAMO  53
#define IDS_CJKMISC                  54
#define IDS_ENCLOSEDCJKLETTERSANDMONTHS 55
#define IDS_CJKCOMPATIBILITY         56
#define IDS_HANGUL                   57
#define IDS_HANGULSUPPA              58
#define IDS_HANGULSUPPB              59
#define IDS_CJKUNIFIEDIDEOGRAPHS     60
#define IDS_PRIVATEUSEAREA           61
#define IDS_CJKCOMPATIBILITYIDEOGRAPHS 62
#define IDS_ALPAHPRESENTATIONFORMS   63
#define IDS_ARABICPRESENTATIONFORMSA 64
#define IDS_CJKCOMPFORMS             65
#define IDS_SMALLFORMVARIANTS        66
#define IDS_ARABICPRESENTATIONFORMSB 67
#define IDS_HALFANDFULLWIDTHFORMS    68
#define IDS_SPECIALS                 69



#define ID_SUBSETLB                 201
#define ID_NEXTSUBSET               203
#define ID_PREVSUBSET               205

#define ID_UNICODESUBSET            202
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\winchat\dialogs.c ===
/*---------------------------------------------------------------------------*\
| WINCHAT RESOURCE FILE
|   This module defines the resources for the WinChat application
|
|   FUNCTIONS
|   ---------
|   dlgConnectProc
|   dlgPreferencesProc
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 01-Nov-91
| history: 01-Nov-91 <clausgi>  created.
|          29-Dec-92 <chriswil> port to NT, cleanup.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

#include <windows.h>
#include <ddeml.h>
#include <commdlg.h>
#include <winchat.h>
#include "dialogs.h"
#include "globals.h"


#ifdef WIN16
#pragma alloc_text (_DLGS, dlgConnectProc, dlgPreferencesProc)
#endif
/*---------------------------------------------------------------------------*\
| DISPLAY DIALOG BOX
|   This is a routine to display a generic modal-dialog box.
|
| created: 29-Dec-92
| history: 29-Dec-92 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
INT_PTR FAR dlgDisplayBox(HINSTANCE hInstance, HWND hWndParent, LPTSTR lpszTemplate, DLGPROC lpfFunction, LPARAM lParam)
{
    INT_PTR nRet;


    nRet = DialogBoxParam(hInstance,lpszTemplate,hWndParent,lpfFunction,lParam);

    return(nRet);
}


/*---------------------------------------------------------------------------*\
| CONNECT DIALOGBOX PROCEDURE
|   This routines prompts the connection dialogbox
|
| created: 11-Nov-91
| history: 29-Dev-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
INT_PTR CALLBACK dlgConnectProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled;


    bHandled = TRUE;
    switch(msg)
    {
        // result in global szConvPartner (CODEWORK replace lParam)
        //
        case WM_INITDIALOG:
            szConvPartner[0] = TEXT('\0');
            break;


        case WM_COMMAND:
            switch(wParam)
            {
                case IDOK:
                    GetDlgItemText(hwnd,IDC_CONNECTNAME,szBuf,SZBUFSIZ);
                    EndDialog(hwnd,0);
                    break;

                case IDCANCEL:
                    szConvPartner[0] = TEXT('\0');
                    EndDialog(hwnd,0);
                    break;

                default:
                    bHandled = FALSE;
                    break;
            }
            break;


        default:
            bHandled = FALSE;
            break;
    }

    return(bHandled);
}


/*---------------------------------------------------------------------------*\
| PREFERENCES DIALOGBOX PROCEDURE
|   This routines prompts the connection dialogbox
|
| created: 11-Nov-91
| history: 29-Dev-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/

// context sensitive help array
static const DWORD aHelpIDs[] =
{
    ID_TOPANDBOTTOM,    IDH_TOPANDBOTTOM,
    ID_SIDEBYSIDE  ,    IDH_SIDEBYSIDE,
    ID_RECEIVEPFONT,    IDH_RECEIVEPFONT,
    ID_RECEIVEOFONT,    IDH_RECEIVEOFONT,
    IDOK           ,    IDH_OKBUTTON,
    IDCANCEL       ,    IDH_CANCELBUTTON,
    0,    0
};

INT_PTR CALLBACK dlgPreferencesProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled;
    UINT tmp;


    bHandled = TRUE;
    switch(msg)
    {
        case WM_INITDIALOG:
            CheckDlgButton(hwnd,ID_SIDEBYSIDE  ,ChatState.fSideBySide);
            CheckDlgButton(hwnd,ID_TOPANDBOTTOM,!ChatState.fSideBySide);
            CheckDlgButton(hwnd,ID_RECEIVEOFONT,ChatState.fUseOwnFont);
            CheckDlgButton(hwnd,ID_RECEIVEPFONT,!ChatState.fUseOwnFont);
            break;


        case WM_COMMAND:
            switch(wParam)
            {
                case IDOK:
                    tmp = (BOOL)SendDlgItemMessage(hwnd,ID_RECEIVEOFONT,BM_GETCHECK,0,0L);

                    if(tmp != ChatState.fUseOwnFont)
                    {
                        ChatState.fUseOwnFont = tmp;

                        // delete old objects
                        //
                        if(hEditRcvFont)
                            DeleteObject(hEditRcvFont);

                        if(hEditRcvBrush)
                            DeleteObject(hEditRcvBrush);

                        if(ChatState.fUseOwnFont)
                        {
                            hEditRcvFont  = CreateFontIndirect((LPLOGFONT)&lfSnd);
                            hEditRcvBrush = CreateSolidBrush(SndBrushColor);
                        }
                        else
                        {
                            RcvBrushColor = PartBrushColor;
                            hEditRcvFont  = CreateFontIndirect((LPLOGFONT)&lfRcv);
                            hEditRcvBrush = CreateSolidBrush(RcvBrushColor);
                        }

                        if(hEditRcvFont)
                        {
                            SendMessage(hwndRcv,WM_SETFONT,(WPARAM)hEditRcvFont,1L);
                            InvalidateRect(hwndRcv,NULL,TRUE);
                        }

                    }

                    tmp = (BOOL)SendDlgItemMessage(hwnd,ID_SIDEBYSIDE,BM_GETCHECK,0,0L);

                    if(tmp != ChatState.fSideBySide)
                    {
                        ChatState.fSideBySide = tmp;
                        AdjustEditWindows();
                        InvalidateRect(hwndApp,NULL,FALSE);
                    }

                    EndDialog(hwnd,0);
                    break;


                case IDCANCEL:
                    EndDialog(hwnd,0);
                    break;


                default:
                    bHandled = FALSE;
                    break;
            }
            break;

           case WM_HELP:
                {
                    LPHELPINFO lphi;
                    lphi = (LPHELPINFO)lParam;
                    if (lphi->iContextType == HELPINFO_WINDOW)   // must be for a control
                    {         WinHelp (lphi->hItemHandle, szHelpFile,
                                  HELP_WM_HELP, (ULONG_PTR)aHelpIDs);
                    }
                    return TRUE;
                }
                break;

           case WM_CONTEXTMENU:
                {
                    WinHelp ((HWND)wParam, szHelpFile, HELP_CONTEXTMENU,
                    (ULONG_PTR)aHelpIDs);
                    return TRUE;
                }
                break;

        default:
            bHandled = FALSE;
            break;
    }

    return(bHandled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\winchat\globals.c ===
/*---------------------------------------------------------------------------*\
| GLOBAL MODULE
|   This module contains global-variables for the appliciation.  These were
|   isolate purely for maintainability of the app.
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 29-Dec-92
| history: 29-Dec-92 <clausgi>  created with port to NT.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <ddeml.h>
#include <commdlg.h>
#include <commctrl.h>
#include <shellapi.h>
#include "winchat.h"
#include "dialogs.h"


// Send-Window Information.
//
HFONT    hEditSndFont = NULL;
HWND     hwndSnd;
HBRUSH   hEditSndBrush;
COLORREF SndColorref,SndBrushColor;
LOGFONT  lfSnd;
RECT     SndRc;


// Receive-Window Information.
//
HFONT    hEditRcvFont = NULL;
HWND     hwndRcv;
HBRUSH   hEditRcvBrush;
COLORREF RcvColorref,RcvBrushColor;
COLORREF PartBrushColor;
LOGFONT  lfRcv;
RECT     RcvRc;


// DDEML Conversation.
//
DWORD idInst         = 0;
HSZ   hszServiceName = (HSZ)0;
HSZ   hszConnect     = (HSZ)0;
HSZ   hszChatTopic   = (HSZ)0;
HSZ   hszChatShare   = (HSZ)0;
HSZ   hszTextItem    = (HSZ)0;
HSZ   hszConvPartner = (HSZ)0;
HSZ   hszConnectTest = (HSZ)0;
HSZ   hszLocalName   = (HSZ)0;
HCONV ghConv;



// Misc global variables.
//
int      dyStatus,dyButtonBar,dyBorder,cxIcon,cyIcon,cbTextLen;
UINT_PTR idTimer;
DWORD    XactID,StrXactID;
HANDLE   hInst;
HACCEL   hAccel;
HDC      hMemDC;
HBITMAP  hOldBitmap,hPhnBitmap,hOldMemObj;
HICON    hPhones[3];
HFONT    hFontStatus,hOldFont;
HBRUSH   hBtnFaceBrush;
HPEN     hShadowPen,hHilitePen,hFramePen;
UINT     cf_chatdata;
HWND     hwndActiveEdit,hwndApp;
WNETCALL WNetServerBrowseDialog;


int     ASeq[4]         = {0,1,0,2};
WORD    cAnimate        = 0;
HANDLE  hMemTextBuffer  = NULL;
int     nConnectAttempt = 0;
HWND    hwndToolbar     = NULL;
HWND    hwndStatus      = NULL;



// Pointer information.
//
WNDPROC  lpfnOldEditProc;
LPBYTE   lpbTextBuffer;



// Common-Dialog variables.
//
CHOOSEFONT  chf;
CHOOSECOLOR chc;
DWORD       CustColors[16];


CHATSTATE       ChatState;
CHATDATA        ChatData, ChatDataRcv;
WINDOWPLACEMENT Wpl;



// Global Buffers.
//
TCHAR szHelv          [SMLRCBUF];
TCHAR szAppName       [SMLRCBUF];
TCHAR szServiceName   [SMLRCBUF];
TCHAR szAlreadyConnect[BIGRCBUF];
TCHAR szAbandonFirst  [BIGRCBUF];
TCHAR szDialing       [BIGRCBUF];
TCHAR szYouCaller     [BIGRCBUF];
TCHAR szNotCalled     [BIGRCBUF];
TCHAR szNotConnected  [BIGRCBUF];
TCHAR szConnectAbandon[BIGRCBUF];
TCHAR szHangingUp     [BIGRCBUF];
TCHAR szHasTerminated [BIGRCBUF];
TCHAR szConnectedTo   [BIGRCBUF];
TCHAR szConnecting    [BIGRCBUF];
TCHAR szIsCalling     [BIGRCBUF];
TCHAR szDialHelp      [BIGRCBUF];
TCHAR szAnswerHelp    [BIGRCBUF];
TCHAR szHangUpHelp    [BIGRCBUF];
TCHAR szNoConnect     [BIGRCBUF];
TCHAR szNoConnectionTo[BIGRCBUF];
TCHAR szSysErr        [BIGRCBUF];
TCHAR szAlwaysOnTop   [BIGRCBUF];
TCHAR szNoNet         [SZBUFSIZ];
TCHAR szBuf           [SZBUFSIZ];        // general purpose string buffer
TCHAR szHelp          [SZBUFSIZ];

TCHAR szIniSection    [SZBUFSIZ];
TCHAR szIniKey1       [BIGRCBUF];
TCHAR szIniKey2       [BIGRCBUF];
TCHAR szIniRingIn     [BIGRCBUF];
TCHAR szIniRingOut    [BIGRCBUF];

TCHAR szConvPartner   [UNCNLEN] = TEXT("");    // Conversation partner.
TCHAR szLocalName     [UNCNLEN] = TEXT("");    // Computer name.


// localized strings
//
CONST TCHAR szChatTopic   [] = TEXT("Chat");
TCHAR szChatShare   [] = TEXT("CHAT$");
CONST TCHAR szWcRingIn    [] = TEXT("RingIn");
CONST TCHAR szWcRingOut   [] = TEXT("RingOut");
CONST TCHAR szSysIni      [] = TEXT("system.ini");
CONST TCHAR szVredir      [] = TEXT("Network");
CONST TCHAR szComputerName[] = TEXT("ComputerName");
CONST TCHAR szChatText    [] = TEXT("ChatText");
CONST TCHAR szConnectTest [] = TEXT("___cnc3tst___");
CONST TCHAR szWinChatClass[] = TEXT("WinChatWClass");
CONST TCHAR szWinChatMenu [] = TEXT("WinChatMenu");
CONST TCHAR szHelpFile    [] = TEXT("winchat.hlp");
CONST TCHAR szIni         [] = TEXT("Winchat.ini");
CONST TCHAR szFnt         [] = TEXT("Font");
CONST TCHAR szPref        [] = TEXT("Preferences");
CONST TCHAR szSnd         [] = TEXT("Sound");
CONST TCHAR szTool        [] = TEXT("ToolBar");
CONST TCHAR szStat        [] = TEXT("StatusBar");
CONST TCHAR szTop         [] = TEXT("TopMost");
CONST TCHAR szUseOF       [] = TEXT("UseOwnFont");
CONST TCHAR szSbS         [] = TEXT("SideBySide");
CONST TCHAR szAutoAns     [] = TEXT("AutoAnswer");
CONST TCHAR szBkgnd       [] = TEXT("BkGnd");
CONST TCHAR szNull        [] = TEXT("");




// This list must be NULL-terminated.
//
CONST UINT nIDs[] = {MH_BASE,MH_POPUPBASE,0,0};




// Code for all font aspects (CODEWORK - reduce to essential?)
//
CONST TCHAR szHeight      [] = TEXT("Height");
CONST TCHAR szWeight      [] = TEXT("Weight");
CONST TCHAR szPitchFam    [] = TEXT("PitchFam");
CONST TCHAR szItalic      [] = TEXT("Italic");
CONST TCHAR szUnderline   [] = TEXT("Underline");
CONST TCHAR szStrikeOut   [] = TEXT("Strikeout");
CONST TCHAR szFontName    [] = TEXT("Name");
CONST TCHAR szWidth       [] = TEXT("Width");
CONST TCHAR szCharSet     [] = TEXT("TCHARset");
CONST TCHAR szOutPrecision[] = TEXT("OutPrecision");
CONST TCHAR szClipPrec    [] = TEXT("ClipPrecision");
CONST TCHAR szQuality     [] = TEXT("Quality");
CONST TCHAR szColor       [] = TEXT("Color");
CONST TCHAR szPlacement   [] = TEXT("Placement");
CONST TCHAR szPlcFmt      [] = TEXT("%d %d %d %d %d %d %d");

BOOL gfDbcsEnabled;

UINT WINAPI fakeFunc()
{
    return 0;
}

HIMC (WINAPI* pfnImmGetContext)(HWND) = (PVOID)fakeFunc;
BOOL (WINAPI* pfnImmReleaseContext)(HWND, HIMC) = (PVOID)fakeFunc;
LONG (WINAPI* pfnImmGetCompositionStringW)(HIMC, DWORD, LPVOID, DWORD) = (PVOID)fakeFunc;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\winchat\dde.c ===
/*---------------------------------------------------------------------------*\
| DDE MODULE
|   This module contains the routines necessary for maintaining dde
|   conversations.
|
|   FUNCTIONS
|   ---------
|   CreateCharData
|   CreatePasteData
|   SendFontToPartner
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 01-Nov-91
| history: 01-Nov-91 <clausgi>  created.
|          29-Dec-92 <chriswil> port to NT, cleanup.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <ddeml.h>
#include <commdlg.h>
#include <commctrl.h>
#include "winchat.h"
#include "globals.h"

// CP963
BOOL TranslateMultiBytePosToWideCharPos( HWND hWnd, DWORD dwStart, DWORD dwEnd, LPDWORD lpdwStart, LPDWORD lpdwEnd )
{

    INT     nLine=0, wChars = 0, i, j, delta;   // Just to make compiler happy, initialize wChars here.
    DWORD   mCnt=0, mChars, offset, p_offset=0;
    HANDLE  hText;
    PTCHAR  pStartText;
    CHAR   szBuff[800];
    LONG   wStart, wEnd;


    *lpdwStart = 0;
    *lpdwEnd   = 0;
    wStart     = -1;
    wEnd       = -1;

    hText = (HANDLE)SendMessage( hWnd, EM_GETHANDLE, 0, 0);
    if( !( hText ) )
        return( FALSE );

    pStartText = LocalLock( hText);
    if( !( pStartText ) )
    {
        LocalUnlock( hText );
        return( FALSE );
    }

    while(1)
    {
        INT flag = 0;

        offset = (DWORD)SendMessage( hWnd, EM_LINEINDEX, nLine++, 0 );

        if( offset > 0 ) {                           //0D0A
            delta = offset - (p_offset+wChars);
            if( delta ) mCnt += delta;
            p_offset = offset;
        } else if ( offset == 0) {
            *lpdwStart = dwStart;
            *lpdwEnd   = dwEnd;
            LocalUnlock( hText );
            return( TRUE );
        } else {
            LocalUnlock( hText );
            return( FALSE );
        }

        wChars = (WORD)SendMessage( hWnd, EM_LINELENGTH, offset, 0 );

        mChars = WideCharToMultiByte( CP_ACP, 0, pStartText+offset,
            wChars, NULL, 0, NULL, NULL );

        if( (dwStart>=mCnt) && (dwStart<=mCnt+mChars)) flag |= 1;
        if((dwEnd>=mCnt) && (dwEnd<=mCnt+mChars))      flag |= 2;
        if( flag )
        {
            WideCharToMultiByte( CP_ACP, 0, pStartText+offset, wChars,
                szBuff, mChars, NULL, NULL );

            for(i=0,j=0; ; i++,j++ )
            {
                if( (flag&1) && (wStart==-1) )
                {
                    if(dwStart <= (mCnt+i) )
                    {
                        wStart = offset+j;
                        if( flag == 1 ) break;
                    }
                }
                if( (flag&2) && (wEnd==-1) )
                {
                    if(dwEnd <= (mCnt+i) )
                    {
                        wEnd = offset+j;
                        if( flag == 2 ) break;
                    }
                }
                if( (flag==3) && (wStart>-1) && (wEnd>-1) ) break;
                if( IsDBCSLeadByte(szBuff[i]) ) i++;
            }
        }
        if( (wStart>-1) && (wEnd>-1) )  break;
        mCnt += mChars;
    }

    *lpdwStart = (DWORD)wStart;
    *lpdwEnd   = (DWORD)wEnd;

   LocalUnlock( hText );
   return( TRUE );
}

BOOL
TranslateWideCharPosToMultiBytePos( HWND hWnd, DWORD dwStart, DWORD dwEnd, LPDWORD lpdwStart, LPDWORD lpdwEnd )
{
    INT     nLine=0, wChars = 0, i, j,delta;    // Just to make compiler happy, initialize wChars here.
    DWORD   mChars, mCnt=0, offset, p_offset=0;
    HANDLE  hText;
    PTCHAR  pStartText;
    CHAR   szBuff[800];
    LONG   mStart, mEnd;


    *lpdwStart = 0;
    *lpdwEnd = 0;
    mStart = -1;
    mEnd = -1;

    hText = (HANDLE)SendMessage( hWnd, EM_GETHANDLE, 0, 0);
    if( !( hText ) )
        return( FALSE );

    pStartText = LocalLock( hText);
    if( !( pStartText ) )
    {
        LocalUnlock( hText );
        return( FALSE );
    }

    while(1)
    {
        INT flag = 0;

        offset = (DWORD)SendMessage( hWnd, EM_LINEINDEX, nLine++, 0 );

        if( offset > 0 ) {                           //ODOA
            delta = offset - (p_offset+wChars);
            if( delta ) mCnt += delta;
            p_offset = offset;
        } else if ( offset == 0) {
            *lpdwStart = dwStart;
            *lpdwEnd   = dwEnd;
            LocalUnlock( hText );
            return( TRUE );
        } else {
            LocalUnlock( hText );
            return( FALSE );
        }

        wChars = (WORD)SendMessage( hWnd, EM_LINELENGTH, offset, 0 );

        mChars = WideCharToMultiByte( CP_ACP, 0, pStartText+offset,
            wChars, NULL, 0, NULL, NULL );

        if( (dwStart>=offset) && (dwStart<=offset+wChars)) flag |= 1;
        if( (dwEnd>=offset) && (dwEnd<=offset+wChars) ) flag |= 2;
        if( flag )
        {
            WideCharToMultiByte( CP_ACP, 0, pStartText+offset, wChars,
                szBuff, mChars, NULL, NULL );

            for(i=0,j=0; ; i++, j++ )
            {
                if( (flag&1) && (mStart==-1) )
                {
                    if(dwStart == (offset+i) )
                    {
                        mStart = mCnt+j;
                        if( flag==1 ) break;
                    }
                }
                if( (flag&2) && (mEnd==-1) )
                {
                    if(dwEnd == (offset+i) )
                    {
                        mEnd = mCnt+j;
                        if( flag == 2 ) break;
                    }
                }
                if( (flag==3) && (mStart>-1) && (mEnd>-1) ) break;
                if( IsDBCSLeadByte(szBuff[j]) ) j++;
            }
        }
        if( (mStart>-1) && (mEnd>-1) )  break;
        mCnt += mChars;
    }
    *lpdwStart = (DWORD)mStart;
    *lpdwEnd   = (DWORD)mEnd;

   LocalUnlock( hText );
   return( TRUE );
}


/*---------------------------------------------------------------------------*\
| DDE CALLBACK PROCEDURE
|   This routine handles the events sent by DDEML.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
HDDEDATA CALLBACK DdeCallback(UINT wType, UINT wFmt, HCONV hConv, HSZ hszTopic, HSZ hszItem, HDDEDATA hData, DWORD lData1, DWORD lData2)
{
    HDC      hdc;
    HDDEDATA hRet;
    WPARAM   wParam;
    LPARAM   lParam;
    DWORD    dwTemp1,dwTemp2;

    hRet = (HDDEDATA)0;
    switch(wType)
    {
        case XTYP_REGISTER:
        case XTYP_UNREGISTER:
            break;


            case XTYP_XACT_COMPLETE:
                    if(lData1 == XactID)
            {
                            if(hData != (HDDEDATA)0)
                {
                                    ChatState.fServerVerified = TRUE;
                            }
                else
                {
                                    SetStatusWindowText(szNoConnect);
                                    ChatState.fConnectPending = FALSE;
                                    UpdateButtonStates();
                            }
            }
            break;


            case XTYP_ADVDATA:
            case XTYP_POKE:
            if(ChatState.fConnected && (wFmt == cf_chatdata))
            {
                DdeGetData(hData,(LPBYTE)&ChatDataRcv,sizeof(ChatDataRcv),0L);

// This is failing in some cases.  Eventually, this should be in.
//
#ifndef DDEMLBUG
                if(DdeGetLastError(idInst) == DMLERR_NO_ERROR)
#endif
                {
                    switch(ChatDataRcv.type)
                    {
                        // FE specific:
                        // We have a DBCS string selection.
                        //
                        case CHT_DBCS_STRING:
                        {
                            HANDLE  hStrBuf;
                            LPSTR   lpStrBuf;

                            hStrBuf = GlobalAlloc(GMEM_FIXED,ChatDataRcv.uval.cd_dbcs.size+1);
                            if (hStrBuf)
                            {
                                lpStrBuf = GlobalLock(hStrBuf);
                                if (lpStrBuf)
                                {
                                    DdeGetData(hData,(BYTE *)lpStrBuf,ChatDataRcv.uval.cd_dbcs.size+1,XCHATSIZEA);

#ifndef DDEMLBUG
                                    if (DdeGetLastError(idInst) == DMLERR_NO_ERROR)
#endif
                                    {
                                        SendMessage(hwndRcv,EM_SETREADONLY,(WPARAM)FALSE,0L);
                                    #ifdef UNICODE
                                    {
                                        LPWSTR lpStrUnicode;
                                        ULONG  cChars = strlen(lpStrBuf) + 1;

                                        //
                                        // Get text output position from DDE packet, and set it to EditControl.
                                        //
                                        // !!! BUG BUG BUG !!!
                                        //
                                        //  If the sender is not Unicode Edit control. the position data might be
                                        // stored for MBCS string context.
                                        // in that case, we might draw the text at incorrect position.
                                        //
                                        // We have to convert to fit Unicode string.

//                                        wParam = SET_EM_SETSEL_WPARAM(LOWORD(
//ChatDataRcv.uval.cd_dbcs.SelPos),HIWORD(ChatDataRcv.uval.cd_dbcs.SelPos));
//                                        lParam = SET_EM_SETSEL_LPARAM(LOWORD(
//ChatDataRcv.uval.cd_dbcs.SelPos),HIWORD(ChatDataRcv.uval.cd_dbcs.SelPos));


                                        TranslateMultiBytePosToWideCharPos(
                                            hwndRcv,
                                            (DWORD)LOWORD(ChatDataRcv.uval.cd_dbcs.SelPos),
                                            (DWORD)HIWORD(ChatDataRcv.uval.cd_dbcs.SelPos),
                                            &dwTemp1,
                                            &dwTemp2 );
                                        // sign extend them
                                        wParam=(WPARAM)(INT_PTR)dwTemp1;
                                        lParam=(LPARAM)(INT_PTR)dwTemp2;
                                        SendMessage(hwndRcv, EM_SETSEL, wParam, lParam);

                                        //
                                        // Allocate temporary buffer for Nls conversion.
                                        //

                                        if((lpStrUnicode = LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT,
                                                                      cChars * 2)) == NULL )
                                        {
                                           break;
                                        }

                                        //
                                        //  Convert MBCS to Unicode. because DDE packet contains MBCS string any time
                                        // for downlevel connectivity, But if we are compiled with -DUNICODE flag,
                                        // EditControl can only handled Unicode, just convert it.
                                        //

                                        MultiByteToWideChar(CP_ACP,0,
                                                            lpStrBuf,cChars,
                                                            lpStrUnicode,cChars * sizeof(WCHAR)
                                                           );

                                        // Set string to EditControl.

                                        SendMessage(hwndRcv,EM_REPLACESEL,0,(LPARAM)lpStrUnicode);
                                        LocalFree(lpStrUnicode);
                                    }
                                    #else // !UNICODE
                                        wParam = SET_EM_SETSEL_WPARAM(LOWORD(ChatDataRcv.uval.cd_dbcs.SelPos),HIWORD(ChatDataRcv.uval.cd_dbcs.SelPos));
                                        lParam = SET_EM_SETSEL_LPARAM(LOWORD(ChatDataRcv.uval.cd_dbcs.SelPos),HIWORD(ChatDataRcv.uval.cd_dbcs.SelPos));
                                        SendMessage(hwndRcv,EM_SETSEL,wParam,lParam);
                                        SendMessage(hwndRcv,EM_REPLACESEL,0,(LPARAM)lpStrBuf);
                                    #endif // UNICODE
                                        SendMessage(hwndRcv,EM_SETREADONLY,(WPARAM)TRUE,0L);
                                        hRet = (HDDEDATA)TRUE;
                                    }

                                    GlobalUnlock(hStrBuf);
                                }

                                GlobalFree(hStrBuf);
                            }
                        }

                        break;


                        // This is a Unicode conversation, so mark the flag.
                        //
                        case CHT_UNICODE:
                            ChatState.fUnicode = TRUE;
                            hRet               = (HDDEDATA)TRUE;
                            break;


                        // We got a character...stuff it into the control.
                        //
                        case CHT_CHAR:

                            // In case user is tracking, so WM_CHAR is not tossed (thanks Dave)
                            //
                            SendMessage(hwndRcv,WM_LBUTTONUP,0,0L);
                            SendMessage(hwndRcv,EM_SETREADONLY,(WPARAM)FALSE,0L);

                            if (gfDbcsEnabled) {
                                TranslateMultiBytePosToWideCharPos( hwndRcv,
                                  (DWORD)HIWORD(ChatDataRcv.uval.cd_dbcs.SelPos),
                                  (DWORD)LOWORD(ChatDataRcv.uval.cd_dbcs.SelPos),
                                  &dwTemp1, &dwTemp2 );
                                // sign extend them
                                wParam=(WPARAM)(INT_PTR)dwTemp1;
                                lParam=(LPARAM)(INT_PTR)dwTemp2;
                            } else {

                                wParam = SET_EM_SETSEL_WPARAM(LOWORD(ChatDataRcv.uval.cd_char.SelPos),HIWORD(ChatDataRcv.uval.cd_char.SelPos));
                                lParam = SET_EM_SETSEL_LPARAM(LOWORD(ChatDataRcv.uval.cd_char.SelPos),HIWORD(ChatDataRcv.uval.cd_char.SelPos));
                            }
                            SendMessage(hwndRcv,EM_SETSEL,wParam,lParam);
                            SendMessage(hwndRcv,WM_CHAR,ChatDataRcv.uval.cd_char.Char,0L);
                            SendMessage(hwndRcv,EM_SETREADONLY,TRUE,0L);
                            hRet = (HDDEDATA)TRUE;
                            break;



                        // We have a paste selection.
                        //
                        case CHT_PASTEA:
                        case CHT_PASTEW:
                            {
                                HANDLE hPasteBuf,hAnsiBuf;
                                LPSTR  lpPasteBuf,lpAnsiBuf;
                                DWORD  BufSize;


                                BufSize = (ChatDataRcv.type == CHT_PASTEA ? ((ChatDataRcv.uval.cd_paste.size + 1) * sizeof(TCHAR)) : (ChatDataRcv.uval.cd_paste.size + sizeof(WCHAR)));

                                hPasteBuf = GlobalAlloc(GMEM_FIXED,BufSize);
                                if(hPasteBuf)
                                {
                                    lpPasteBuf = GlobalLock(hPasteBuf);
                                    if(lpPasteBuf)
                                    {
                                        if(ChatDataRcv.type == CHT_PASTEA)
                                        {
                                            hAnsiBuf = GlobalAlloc(GMEM_FIXED,ChatDataRcv.uval.cd_paste.size+sizeof(WCHAR));
                                            if(hAnsiBuf)
                                            {
                                                lpAnsiBuf = GlobalLock(hAnsiBuf);
                                                if(lpAnsiBuf)
                                                {
                                                    DdeGetData(hData,(BYTE *)lpAnsiBuf,ChatDataRcv.uval.cd_paste.size+sizeof(WCHAR),XCHATSIZEA);
                                                    MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,lpAnsiBuf,ChatDataRcv.uval.cd_paste.size+sizeof(WCHAR),
                                                                        (LPWSTR)lpPasteBuf,ChatDataRcv.uval.cd_paste.size+1);

                                                    GlobalUnlock(hAnsiBuf);
                                                }

                                                GlobalFree(hAnsiBuf);
                                            }
                                        }
                                        else
                                            DdeGetData(hData,(BYTE *)lpPasteBuf,ChatDataRcv.uval.cd_paste.size+sizeof(WCHAR),XCHATSIZEW);


#ifndef DDEMLBUG
                                        if(DdeGetLastError(idInst) == DMLERR_NO_ERROR)
#endif
                                        {
                                            SendMessage(hwndRcv,EM_SETREADONLY,(WPARAM)FALSE,0L);

                                            wParam = SET_EM_SETSEL_WPARAM(LOWORD(ChatDataRcv.uval.cd_char.SelPos),HIWORD(ChatDataRcv.uval.cd_char.SelPos));
                                            lParam = SET_EM_SETSEL_LPARAM(LOWORD(ChatDataRcv.uval.cd_char.SelPos),HIWORD(ChatDataRcv.uval.cd_char.SelPos));
                                            SendMessage(hwndRcv,EM_SETSEL,wParam,lParam);
                                            SendMessage(hwndRcv,EM_REPLACESEL,0,(LPARAM)lpPasteBuf);
                                            SendMessage(hwndRcv,EM_SETREADONLY,(WPARAM)TRUE,0L);
                                            hRet = (HDDEDATA)TRUE;
                                        }

                                        GlobalUnlock(hPasteBuf);
                                    }

                                    GlobalFree(hPasteBuf);
                                }
                            }
                            break;


                        // We got a font change.  Create and stuff.
                        //
                                case CHT_FONTA:
                                case CHT_FONTW:
                            if(ChatDataRcv.type == CHT_FONTA)
                            {
                               CHATDATAA ChatDataA;

                               memcpy(ChatDataA.uval.cd_win.lf.lfFaceName,ChatDataRcv.uval.cd_win.lf.lfFaceName,LF_XPACKFACESIZE + (sizeof(COLORREF) * 2));
                               ChatDataRcv.uval.cd_win.cref  = ChatDataA.uval.cd_win.cref;
                               ChatDataRcv.uval.cd_win.brush = ChatDataA.uval.cd_win.brush;

                               MultiByteToWideChar(CP_OEMCP,MB_PRECOMPOSED,ChatDataA.uval.cd_win.lf.lfFaceName,LF_XPACKFACESIZE,ChatDataRcv.uval.cd_win.lf.lfFaceName,LF_XPACKFACESIZE);
                            }

                            UnpackFont(&lfRcv,&ChatDataRcv.uval.cd_win.lf);

                            hdc = GetDC(hwndApp);
                            if(hdc)
                            {
                                RcvBrushColor = PartBrushColor = GetNearestColor(hdc,ChatDataRcv.uval.cd_win.brush);
                                RcvColorref   = GetNearestColor(hdc,ChatDataRcv.uval.cd_win.cref);
                                ReleaseDC(hwndApp,hdc);
                            }

                            if(!ChatState.fUseOwnFont)
                            {
                                if(hEditRcvFont)
                                    DeleteObject(hEditRcvFont);
                                hEditRcvFont = CreateFontIndirect(&lfRcv);

                                DeleteObject(hEditRcvBrush);
                                hEditRcvBrush = CreateSolidBrush(RcvBrushColor);

                                if(hEditRcvFont)
                                {
                                    SendMessage(hwndRcv,WM_SETFONT,(WPARAM)hEditRcvFont,1L);
                                    InvalidateRect(hwndRcv,NULL,TRUE);
                                }
                            }
                            hRet = (HDDEDATA)TRUE;
                            break;

#ifdef PROTOCOL_NEGOTIATE
                        case CHT_PROTOCOL:
                            // Determine characteristics we have in common.
                            //
                            FlagIntersection(ChatDataRcv.uval.cd_protocol.pckt);

                            // Return the flavor, if not already done.
                            //
                            if(!ChatState.fProtocolSent)
                                AnnounceSupport();
                            hRet = (HDDEDATA)TRUE;
                            break;
#endif

                        default:
                            break;
                    }
                }
            }
            break;


        case XTYP_CONNECT:
            if(!ChatState.fConnected && !ChatState.fConnectPending && !ChatState.fInProcessOfDialing)
            {
                // allow connect only on the chat topic.
                //
                if(!DdeCmpStringHandles(hszTopic,hszChatTopic))
                    hRet = (HDDEDATA)TRUE;
            }
            break;


        case XTYP_CONNECT_CONFIRM:
            ChatState.fConnectPending = TRUE;
            ChatState.fAllowAnswer    = FALSE;
            ChatState.fIsServer       = TRUE;
            ghConv                    = hConv;
            nConnectAttempt           = 0;
            UpdateButtonStates();
            break;


        case XTYP_DISCONNECT:
            if(ChatState.fConnectPending || ChatState.fConnected)
            {
                if(ChatState.fConnected)
                    wsprintf(szBuf,szHasTerminated,(LPTSTR)szConvPartner);
                else
                if(ChatState.fServerVerified)
                    wsprintf(szBuf,szNoConnectionTo,(LPTSTR)szConvPartner);
                else
                    lstrcpy(szBuf,szNoConnect);

                SetStatusWindowText(szBuf);
                ChatState.fConnectPending = FALSE;
                ChatState.fConnected      = FALSE;
                ChatState.fIsServer       = FALSE;
                ChatState.fUnicode        = FALSE;

#ifdef PROTOCOL_NEGOTIATE
                ChatState.fProtocolSent   = FALSE;
#endif

                // suspend text entry
                //
                UpdateButtonStates();
                SendMessage(hwndSnd,EM_SETREADONLY,TRUE,0L);
                SetWindowText(hwndApp,szAppName);


                // stop the ringing immediately
                //
                if(ChatState.fMMSound)
                    sndPlaySound(NULL,SND_ASYNC);


                // cut the animation short
                //
                if(cAnimate)
                   cAnimate = 1;
            }
            break;


        case XTYP_REQUEST:
            break;


        case XTYP_ADVREQ:
            if(ChatState.fIsServer && ChatState.fConnected)
            {
                switch(ChatData.type)
                {
                    case CHT_DBCS_STRING:
                        hRet = CreateDbcsStringData();
                        break;

                    case CHT_CHAR:
                    case CHT_FONTA:
                    case CHT_FONTW:
                    case CHT_UNICODE:
                        hRet = CreateCharData();
                        break;

                    case CHT_PASTEA:
                    case CHT_PASTEW:
                        hRet = CreatePasteData();
                        break;

#ifdef PROTOCOL_NEGOTIATE
                    case CHT_PROTOCOL:
                        hRet = CreateProtocolData();
                        break;
#endif
                    default:
                        break;
                }
            }
            break;


        case XTYP_ADVSTART:
            if(ChatState.fConnectPending)
            {
                // is this the connect confirm attempt?
                //
                if(!DdeCmpStringHandles(hszItem,hszConnectTest))
                    return((HDDEDATA)TRUE);


                DdeQueryString(idInst,hszItem,szConvPartner,32L,0);
                wsprintf(szBuf,szIsCalling,(LPTSTR)szConvPartner);
                SetStatusWindowText(szBuf);


                // set window text on initial connect attempt
                //
                if(nConnectAttempt == 0)
                {
                    wsprintf(szBuf,TEXT("%s - [%s]"),(LPTSTR)szAppName,(LPTSTR)szConvPartner);
                    SetWindowText(hwndApp,szBuf);
                }


                if(ChatState.fAllowAnswer)
                {
                    ChatState.fConnected      = TRUE;
                    ChatState.fConnectPending = FALSE;
                    UpdateButtonStates();
                    ClearEditControls();

                    SendMessage(hwndSnd,EM_SETREADONLY,FALSE,0L);
                    wsprintf(szBuf,szConnectedTo,(LPTSTR)szConvPartner);
                    SetStatusWindowText(szBuf);

                    if(hszConvPartner)
                        DdeFreeStringHandle(idInst,hszConvPartner);

                    hszConvPartner = DdeCreateStringHandle(idInst,szConvPartner,CP_WINUNICODE);


                    // Indicate that it is a Unicode conversation.
                    //
                    PostMessage(hwndApp,WM_COMMAND,IDX_UNICODECONV,0L);


                    // SendFontToPartner(); -- would like to do this - won't work
                    // so we workaround it by posting the app window a message
                    // to perform this function...
                    //
                    PostMessage(hwndApp,WM_COMMAND,IDX_DEFERFONTCHANGE,0L);

#ifdef PROTOCOL_NEGOTIATE
                    PostMessage(hwndApp,WM_COMMAND,IDX_DEFERPROTOCOL,0L);
#endif
                    hRet = (HDDEDATA)TRUE;
                }
                else
                if(!(nConnectAttempt++ % 6))
                {
                    // Number of animation cycles == 24: ring remote.
                    //
                    cAnimate = 24;
                    idTimer  = SetTimer(hwndApp,(UINT_PTR)1,(UINT_PTR)55,NULL);
                    FlashWindow(hwndApp,TRUE);
                    DoRing(szWcRingIn);
                }
            }
            break;

        default:
            break;
    }

    return(hRet);
}


/*---------------------------------------------------------------------------*\
| FE specific:
| CREATE DBCS STRING TRANSACTION DATA
|   This routine creates a DDE object representing the DBCS string information.
|
| created: 07-Jul-93
|
\*---------------------------------------------------------------------------*/
HDDEDATA CreateDbcsStringData(VOID)
{
    HDDEDATA hTmp = (HDDEDATA)0;
    LPSTR    lpDbcsMem;
    DWORD    cbDbcs;


    hTmp = (HDDEDATA)0;
    lpDbcsMem = GlobalLock(ChatData.uval.cd_dbcs.hString);
    if(lpDbcsMem)
    {
        cbDbcs                     = (DWORD)GlobalSize(ChatData.uval.cd_dbcs.hString);
        ChatData.uval.cd_dbcs.size = (DWORD)cbDbcs;

        hTmp = DdeCreateDataHandle(idInst,NULL,sizeof(ChatData)+cbDbcs,0L,hszTextItem,cf_chatdata,0);
        if(hTmp)
        {
            DdeAddData(hTmp,(LPBYTE)&ChatData,sizeof(ChatData),0L);
            DdeAddData(hTmp,(BYTE *)lpDbcsMem,cbDbcs,XCHATSIZEA);
        }

        GlobalUnlock(ChatData.uval.cd_dbcs.hString);
    }

    GlobalFree(ChatData.uval.cd_dbcs.hString);

    return(hTmp);
}



/*---------------------------------------------------------------------------*\
| CREATE CHARACTER TRANSACTION DATA
|   This routine creates a DDE object representing the charater information.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
HDDEDATA CreateCharData(VOID)
{
    HANDLE     hData;
    LPCHATDATA lpData;
    HDDEDATA   hTmp;
    BOOL       fDefCharUsed;


    hTmp = (HDDEDATA)0;
    hData = GlobalAlloc(GMEM_ZEROINIT | GMEM_MOVEABLE | GMEM_DDESHARE,sizeof(ChatData));
    if(hData)
    {
        lpData = (LPCHATDATA)GlobalLock(hData);
        if(lpData)
        {
            *lpData = ChatData;

            if(ChatData.type == CHT_FONTA)
            {
                lpData->uval.cd_win.cref  = ((LPCHATDATAA)lpData)->uval.cd_win.cref;
                lpData->uval.cd_win.brush = ((LPCHATDATAA)lpData)->uval.cd_win.brush;
            }

            hTmp = DdeCreateDataHandle(idInst,(LPBYTE)lpData,sizeof(ChatData),0L,hszTextItem,cf_chatdata,0);

            GlobalUnlock(hData);
        }

        GlobalFree(hData);
    }

    return(hTmp);
    UNREFERENCED_PARAMETER(fDefCharUsed);
}


/*---------------------------------------------------------------------------*\
| CREATE PASTE TRANSACTION DATA
|   This routine creates a DDE object representing the paste information.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
HDDEDATA CreatePasteData(VOID)
{
    HDDEDATA hTmp,hRet;
    HANDLE   hClipb;
    LPTSTR   lpClipMem;
    DWORD    cbClip;
    LPSTR    lpBuf;
    DWORD    dwBytes;


    hRet = (HDDEDATA)0;
    if(OpenClipboard(hwndSnd))
    {
        hClipb = GetClipboardData(CF_UNICODETEXT);
        if(hClipb)
        {
            lpClipMem = GlobalLock(hClipb);
            if(lpClipMem)
            {
                cbClip                      = (DWORD)GlobalSize(hClipb);
                                ChatData.uval.cd_paste.size = cbClip;
                hTmp = DdeCreateDataHandle(idInst,NULL,(sizeof(ChatData)+cbClip),
                                              0,hszTextItem,cf_chatdata,0);
                if(hTmp)
                {
                    DdeAddData(hTmp,(LPBYTE)&ChatData,sizeof(ChatData),0L);

                    if(ChatData.type == CHT_PASTEA)
                    {
                        dwBytes                     = WideCharToMultiByte(CP_ACP,0,lpClipMem,-1,NULL,0,NULL,NULL);
                        ChatData.uval.cd_paste.size = dwBytes;

                        lpBuf = LocalAlloc(LPTR,dwBytes);
                        if(lpBuf)
                        {
                            WideCharToMultiByte(CP_ACP,0,lpClipMem,-1,lpBuf,dwBytes,NULL,NULL);

                            DdeAddData(hTmp,(LPBYTE)lpBuf,dwBytes,XCHATSIZEA);

                            hRet = hTmp;

                            LocalFree(lpBuf);
                        }
                    }
                    else
                    {
                        DdeAddData(hTmp,(LPBYTE)lpClipMem,cbClip,XCHATSIZEW);

                        hRet = hTmp;
                    }
                }

                GlobalUnlock(hClipb);
                        }
        }

                CloseClipboard();
    }

    return(hRet);
}


#ifdef PROTOCOL_NEGOTIATE
/*---------------------------------------------------------------------------*\
| CREATE PROTOCOL TRANSACTION DATA
|   This routine creates a DDE object representing the protocol information.
|
| created: 11-Nov-91
| history: 07-Apr-93 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
HDDEDATA CreateProtocolData(VOID)
{
    HANDLE     hData;
    LPCHATDATA lpData;
    HDDEDATA   hTmp;


    hTmp = (HDDEDATA)0;
    hData = GlobalAlloc(GMEM_ZEROINIT | GMEM_MOVEABLE | GMEM_DDESHARE,sizeof(ChatData));
    if(hData)
    {
        lpData = (LPCHATDATA)GlobalLock(hData);
        if(lpData)
        {
            ChatData.type                   = CHT_PROTOCOL;
            ChatData.uval.cd_protocol.dwVer = CHT_VER;
            ChatData.uval.cd_protocol.pckt  = GetCurrentPckt();

            *lpData = ChatData;
            hTmp    = DdeCreateDataHandle(idInst,(LPBYTE)lpData,sizeof(ChatData),0L,hszTextItem,cf_chatdata,0);

            GlobalUnlock(hData);
        }

        GlobalFree(hData);
    }

    return(hTmp);
}
#endif


#ifdef PROTOCOL_NEGOTIATE
/*---------------------------------------------------------------------------*\
| GET CURRENT PACKET
|   This routine returns the current packet capabilities of the system.
|
| created: 11-Nov-91
| history: 07-Apr-93 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
PCKT GetCurrentPckt(VOID)
{
    PCKT pckt;


    pckt = PCKT_TEXT;

    return(pckt);
}
#endif


#ifdef PROTOCOL_NEGOTIATE
/*---------------------------------------------------------------------------*\
| FLAG INTERSECTION
|   This routine determines which packet types are supporte and flags the
|   appropriate ones.
|
| created: 11-Nov-91
| history: 07-Apr-93 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FlagIntersection(PCKT pcktPartner)
{
    PCKT pcktNet;


    pcktNet = GetCurrentPckt() & pcktPartner;

    return;
}
#endif


/*---------------------------------------------------------------------------*\
| SEND FONT TO PARTNER
|   This routine sends the font-information to the partner in this
|   conversation.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID SendFontToPartner(VOID)
{
        HDDEDATA   hDdeData;
    PCHATDATAA pAChat;


    ChatData.type = (WORD)((ChatState.fUnicode ? CHT_FONTW : CHT_FONTA));

    PackFont(&ChatData.uval.cd_win.lf,&lfSnd);

    if(ChatData.type == CHT_FONTA)
    {
        pAChat                    = (PCHATDATAA)&ChatData;
        pAChat->uval.cd_win.cref  = SndColorref;
        pAChat->uval.cd_win.brush = SndBrushColor;
    }
    else
    {
        ChatData.uval.cd_win.cref  = SndColorref;
        ChatData.uval.cd_win.brush = SndBrushColor;
    }

    if(!ChatState.fIsServer)
    {
        hDdeData = DdeCreateDataHandle(idInst,(LPBYTE) &ChatData,sizeof(ChatData),0L,hszTextItem,cf_chatdata,0);
        if(hDdeData)
            DdeClientTransaction((LPBYTE)hDdeData,(DWORD)-1,ghConv,hszTextItem,cf_chatdata,XTYP_POKE,(DWORD)TIMEOUT_ASYNC,(LPDWORD)&StrXactID);
        }
    else
        DdePostAdvise(idInst,hszChatTopic,hszConvPartner);

    return;
}


/*---------------------------------------------------------------------------*\
| UNPACK FONT
|   This routine unpacks the font stored in the packed transaction.
|
| created: 04-Feb-93
| history: 04-Feb-93 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
VOID UnpackFont(LPLOGFONT lf, LPXPACKFONT lfPacked)
{
    lf->lfHeight         = (LONG)(short)lfPacked->lfHeight;
    lf->lfWidth          = (LONG)(short)lfPacked->lfWidth;
    lf->lfEscapement     = (LONG)(short)lfPacked->lfEscapement;
    lf->lfOrientation    = (LONG)(short)lfPacked->lfOrientation;
    lf->lfWeight         = (LONG)(short)lfPacked->lfWeight;
    lf->lfItalic         = (BYTE)lfPacked->lfItalic;
    lf->lfUnderline      = (BYTE)lfPacked->lfUnderline;
    lf->lfStrikeOut      = (BYTE)lfPacked->lfStrikeOut;
    lf->lfCharSet        = (BYTE)lfPacked->lfCharSet;
    lf->lfOutPrecision   = (BYTE)lfPacked->lfOutPrecision;
    lf->lfClipPrecision  = (BYTE)lfPacked->lfClipPrecision;
    lf->lfQuality        = (BYTE)lfPacked->lfQuality;
    lf->lfPitchAndFamily = (BYTE)lfPacked->lfPitchAndFamily;

    lstrcpy(lf->lfFaceName,lfPacked->lfFaceName);

    return;
}


/*---------------------------------------------------------------------------*\
| PACK FONT
|   This routine packs the font for transaction.
|
| created: 04-Feb-93
| history: 04-Feb-93 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
VOID PackFont(LPXPACKFONT lfPacked, LPLOGFONT lf)
{
    BOOL fDefCharUsed;

    lfPacked->lfHeight          = (WORD)lf->lfHeight;
    lfPacked->lfWidth           = (WORD)lf->lfWidth;
    lfPacked->lfEscapement      = (WORD)lf->lfEscapement;
    lfPacked->lfOrientation     = (WORD)lf->lfOrientation;
    lfPacked->lfWeight          = (WORD)lf->lfWeight;
    lfPacked->lfItalic          = (BYTE)lf->lfItalic;
    lfPacked->lfUnderline       = (BYTE)lf->lfUnderline;
    lfPacked->lfStrikeOut       = (BYTE)lf->lfStrikeOut;
    lfPacked->lfCharSet         = (BYTE)lf->lfCharSet;
    lfPacked->lfOutPrecision    = (BYTE)lf->lfOutPrecision;
    lfPacked->lfClipPrecision   = (BYTE)lf->lfClipPrecision;
    lfPacked->lfQuality         = (BYTE)lf->lfQuality;
    lfPacked->lfPitchAndFamily  = (BYTE)lf->lfPitchAndFamily;

    if(ChatData.type == CHT_FONTA)
        WideCharToMultiByte(CP_OEMCP,0,lf->lfFaceName,LF_XPACKFACESIZE,(LPSTR)(lfPacked->lfFaceName),LF_XPACKFACESIZE,NULL,&fDefCharUsed);
    else
        lstrcpy(lfPacked->lfFaceName,lf->lfFaceName);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\winchat\globals.h ===
/*---------------------------------------------------------------------------*\
| GLOBALS HEADER FILE
|   This module contains the external references for the global-variables
|   in globals.c
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 29-Dec-92
| history: 29-Dec-92 <chriswil> created with port to NT.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

#ifndef WINCHAT_GLOBALS_H
#define WINCHAT_GLOBALS_H

extern HFONT    hEditSndFont;
extern HWND     hwndSnd;
extern HBRUSH   hEditSndBrush;
extern COLORREF SndColorref;
extern COLORREF SndBrushColor;
extern LOGFONT  lfSnd;
extern RECT     SndRc;

extern HFONT    hEditRcvFont;
extern HWND     hwndRcv;
extern HBRUSH   hEditRcvBrush;
extern COLORREF RcvColorref;
extern COLORREF RcvBrushColor;
extern COLORREF PartBrushColor;
extern LOGFONT  lfRcv;
extern RECT     RcvRc;

extern DWORD    idInst;
extern HSZ      hszServiceName;
extern HSZ      hszConnect;
extern HSZ      hszChatTopic;
extern HSZ      hszChatShare;
extern HSZ      hszTextItem;
extern HSZ      hszConvPartner;
extern HSZ      hszConnectTest;
extern HSZ      hszLocalName;
extern HCONV    ghConv;
extern UINT_PTR idTimer;
extern int      dyStatus;
extern int      dyButtonBar;
extern int      dyBorder;
extern int      cxIcon;
extern int      cyIcon;
extern int      cbTextLen;

extern DWORD    StrXactID;
extern DWORD    XactID;
extern HANDLE   hInst;
extern HACCEL   hAccel;
extern HDC      hMemDC;
extern HBITMAP  hOldBitmap;
extern HBITMAP  hPhnBitmap;
extern HBITMAP  hOldMemObj;
extern HICON    hPhones[3];
extern HFONT    hFontStatus;
extern HFONT    hOldFont;
extern HBRUSH   hBtnFaceBrush;
extern HPEN     hShadowPen;
extern HPEN     hHilitePen;
extern HPEN     hFramePen;
extern UINT     cf_chatdata;
extern HWND     hwndActiveEdit;
extern HWND     hwndApp;
extern HWND     hwndToolbar;
extern HWND     hwndStatus;

extern WNETCALL WNetServerBrowseDialog;


extern int     ASeq[];
extern WORD    cAnimate;
extern HANDLE  hMemTextBuffer;
extern int     nConnectAttempt;


extern WNDPROC  lpfnOldEditProc;
extern WNDPROC  lpfnOldRcvEditProc;

extern LPBYTE   lpbTextBuffer;



extern CHOOSEFONT  chf;
extern CHOOSECOLOR chc;
extern DWORD       CustColors[16];


extern CHATSTATE       ChatState;
extern CHATDATA        ChatData;
extern CHATDATA        ChatDataRcv;
extern WINDOWPLACEMENT Wpl;


extern TCHAR szHelv          [];
extern TCHAR szAppName       [];
extern TCHAR szServiceName   [];
extern TCHAR szAlreadyConnect[];
extern TCHAR szAbandonFirst  [];
extern TCHAR szDialing       [];
extern TCHAR szYouCaller     [];
extern TCHAR szNotCalled     [];
extern TCHAR szNotConnected  [];
extern TCHAR szConnectAbandon[];
extern TCHAR szHangingUp     [];
extern TCHAR szHasTerminated [];
extern TCHAR szConnectedTo   [];
extern TCHAR szConnecting    [];
extern TCHAR szIsCalling     [];
extern TCHAR szDialHelp      [];
extern TCHAR szAnswerHelp    [];
extern TCHAR szHangUpHelp    [];
extern TCHAR szNoConnect     [];
extern TCHAR szNoConnectionTo[];
extern TCHAR szSysErr        [];
extern TCHAR szAlwaysOnTop   [];
extern TCHAR szNoNet         [];
extern TCHAR szBuf           [];
extern TCHAR szHelp          [];
extern TCHAR szConvPartner   [];
extern TCHAR szLocalName     [];
extern CONST TCHAR szChatTopic     [];
extern TCHAR szChatShare     [];
extern CONST TCHAR szWcRingIn      [];
extern CONST TCHAR szWcRingOut     [];
extern CONST TCHAR szSysIni        [];
extern CONST TCHAR szVredir        [];
extern CONST TCHAR szComputerName  [];
extern CONST TCHAR szChatText      [];
extern CONST TCHAR szConnectTest   [];
extern CONST TCHAR szWinChatClass  [];
extern CONST TCHAR szWinChatMenu   [];
extern CONST TCHAR szHelpFile      [];
extern CONST TCHAR szIni           [];
extern CONST TCHAR szFnt           [];
extern CONST TCHAR szPref          [];
extern CONST TCHAR szSnd           [];
extern CONST TCHAR szTool          [];
extern CONST TCHAR szStat          [];
extern CONST TCHAR szTop           [];
extern CONST TCHAR szUseOF         [];
extern CONST TCHAR szSbS           [];
extern CONST TCHAR szAutoAns       [];
extern CONST TCHAR szBkgnd         [];
extern CONST TCHAR szNull          [];

extern TCHAR szIniSection    [];
extern TCHAR szIniKey1       [];
extern TCHAR szIniKey2       [];
extern TCHAR szIniRingIn     [];
extern TCHAR szIniRingOut    [];

extern CONST TCHAR szHeight        [];
extern CONST TCHAR szWeight        [];
extern CONST TCHAR szPitchFam      [];
extern CONST TCHAR szItalic        [];
extern CONST TCHAR szUnderline     [];
extern CONST TCHAR szStrikeOut     [];
extern CONST TCHAR szFontName      [];
extern CONST TCHAR szWidth         [];
extern CONST TCHAR szCharSet       [];
extern CONST TCHAR szOutPrecision  [];
extern CONST TCHAR szClipPrec      [];
extern CONST TCHAR szQuality       [];
extern CONST TCHAR szColor         [];
extern CONST TCHAR szPlacement     [];
extern CONST TCHAR szPlcFmt        [];


extern UINT CONST nIDs[];

extern BOOL gfDbcsEnabled;

extern HIMC (WINAPI* pfnImmGetContext)(HWND);
extern BOOL (WINAPI* pfnImmReleaseContext)(HWND, HIMC);
extern LONG (WINAPI* pfnImmGetCompositionStringW)(HIMC, DWORD, LPVOID, DWORD);

#endif  // WINCHAT_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\winchat\wcinit.c ===
/*---------------------------------------------------------------------------*\
| INITIALIZATION MODULE
|   This module contains the one-time initialization routines.
|
|   FUNCTIONS
|   ---------
|   InitFontFromIni
|   SaveFontToIni
|   SaveBkGndToIni
|   LoadIntlStrings
|   SaveWindowPlacement
|   ReadWindowPlacement
|   CreateTools
|   DeleteTools
|   CreateChildWindows
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 01-Nov-91
| history: 01-Nov-91 <clausgi>  created.
|          29-Dec-92 <chriswil> port to NT, cleanup.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

#include <windows.h>
#include <ddeml.h>
#include <commdlg.h>
#include <stdio.h>
#include <stdlib.h>
#include <commctrl.h>
#include <tchar.h>
#include "winchat.h"
#include "globals.h"
//#include "uniconv.h"


static TBBUTTON tbButtons[] =
{
    {0,0,         TBSTATE_ENABLED, TBSTYLE_SEP,  0},
    {0,IDM_DIAL  ,TBSTATE_ENABLED,TBSTYLE_BUTTON,0},
    {1,IDM_ANSWER,TBSTATE_ENABLED,TBSTYLE_BUTTON,0},
    {2,IDM_HANGUP,TBSTATE_ENABLED,TBSTYLE_BUTTON,0},
};
#define cTbButtons sizeof(tbButtons)/sizeof(TBBUTTON)

#ifdef WIN16
#pragma alloc_text (_INIT, InitFontFromIni)
#endif
/*---------------------------------------------------------------------------*\
| INITIALIZE FONT FROM INI FILE
|   This routine initializes the font information from the winchat.ini file.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR InitFontFromIni(VOID)
{
    CHARSETINFO csi;
    DWORD dw = GetACP();

    if (!TranslateCharsetInfo((DWORD*)&dw, &csi, TCI_SRCCODEPAGE)) {
        csi.ciCharset = ANSI_CHARSET;
    }

    // font related stuff
    // CODEWORK - the following code defines some somewhat arbitrary
    // constants for a first shot font - we should default to the
    // system font in an easier more portable manner.
    //
    lfSnd.lfHeight         = (int) GetPrivateProfileInt(szFnt,szHeight      ,(UINT)-13          ,szIni);
    lfSnd.lfWeight         = (int) GetPrivateProfileInt(szFnt,szWeight      ,700                ,szIni);
    lfSnd.lfWidth          = (int) GetPrivateProfileInt(szFnt,szWidth       ,  0                ,szIni);
    lfSnd.lfPitchAndFamily = (BYTE)GetPrivateProfileInt(szFnt,szPitchFam    , 22                ,szIni);
    lfSnd.lfItalic         = (BYTE)GetPrivateProfileInt(szFnt,szItalic      ,  0                ,szIni);
    lfSnd.lfUnderline      = (BYTE)GetPrivateProfileInt(szFnt,szUnderline   ,  0                ,szIni);
    lfSnd.lfStrikeOut      = (BYTE)GetPrivateProfileInt(szFnt,szStrikeOut   ,  0                ,szIni);

    lfSnd.lfCharSet        = (BYTE)GetPrivateProfileInt(szFnt, szCharSet    ,csi.ciCharset      ,szIni);

    lfSnd.lfOutPrecision   = (BYTE)GetPrivateProfileInt(szFnt,szOutPrecision,OUT_DEFAULT_PRECIS ,szIni);
    lfSnd.lfClipPrecision  = (BYTE)GetPrivateProfileInt(szFnt,szClipPrec    ,CLIP_DEFAULT_PRECIS,szIni);
    lfSnd.lfQuality        = (BYTE)GetPrivateProfileInt(szFnt,szQuality     ,DEFAULT_QUALITY    ,szIni);
    lfSnd.lfEscapement     = 0;
    lfSnd.lfOrientation    = 0;

#ifdef UNICODE
    if (gfDbcsEnabled) {
        GetPrivateProfileString(szFnt,szFontName,TEXT("MS Shell Dlg"),lfSnd.lfFaceName,LF_XPACKFACESIZE,szIni);
    }
    else {
        GetPrivateProfileString(szFnt,szFontName,TEXT("MS Shell Dlg"),lfSnd.lfFaceName,LF_XPACKFACESIZE,szIni);
    }
#else
    GetPrivateProfileString(szFnt,szFontName,TEXT("MS Shell Dlg"),lfSnd.lfFaceName,LF_XPACKFACESIZE,szIni);
#endif


    if(GetPrivateProfileString(szFnt,szColor,szNull,szBuf,SZBUFSIZ,szIni))
        SndColorref = myatol(szBuf);
    else
        SndColorref = GetSysColor(COLOR_WINDOWTEXT);

    return;
}


#ifdef WIN16
#pragma alloc_text (_INIT, SaveFontToIni)
#endif
/*---------------------------------------------------------------------------*\
| SAVE FONT TO INI FILE
|   This routine saves the font to the ini-file.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR SaveFontToIni(VOID)
{
    wsprintf(szBuf, TEXT("%d"), lfSnd.lfHeight);
    WritePrivateProfileString(szFnt, szHeight, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), lfSnd.lfWidth);
    WritePrivateProfileString(szFnt, szWidth, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), (WORD)lfSnd.lfCharSet);
    WritePrivateProfileString(szFnt, szCharSet, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), (WORD)lfSnd.lfOutPrecision);
    WritePrivateProfileString(szFnt, szOutPrecision, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), (WORD)lfSnd.lfClipPrecision);
    WritePrivateProfileString(szFnt, szClipPrec, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), (WORD)lfSnd.lfQuality);
    WritePrivateProfileString(szFnt, szQuality, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), lfSnd.lfWeight);
    WritePrivateProfileString(szFnt, szWeight, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), (WORD)lfSnd.lfPitchAndFamily);
    WritePrivateProfileString(szFnt, szPitchFam, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), (WORD)lfSnd.lfItalic);
    WritePrivateProfileString(szFnt, szItalic, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), (WORD)lfSnd.lfUnderline);
    WritePrivateProfileString(szFnt, szUnderline, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), (WORD)lfSnd.lfStrikeOut);
    WritePrivateProfileString(szFnt, szStrikeOut, szBuf, szIni);

    WritePrivateProfileString(szFnt, szFontName, lfSnd.lfFaceName, szIni);
    wsprintf(szBuf, TEXT("%ld"), (DWORD)SndColorref);

    WritePrivateProfileString(szFnt, szColor, szBuf, szIni);

    return;
}


#ifdef WIN16
#pragma alloc_text (_INIT, SaveBkGndToIni)
#endif
/*---------------------------------------------------------------------------*\
| SAVE BACKGROUND TO INI FILE
|   This routine saves the background-color to file.
|
| created: 27-Mar-95
| history: 27-Mar-95 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
VOID FAR SaveBkGndToIni(VOID)
{
    wsprintf(szBuf, TEXT("%ld"), (DWORD)SndBrushColor);
    WritePrivateProfileString(szPref, szBkgnd, szBuf, szIni);

    return;
}


#ifdef WIN16
#pragma alloc_text (_INIT, LoadIntlStrings)
#endif
/*---------------------------------------------------------------------------*\
| LOAD INTERNAL STRINGS
|   This routine loads the resources strings.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR LoadIntlStrings(VOID)
{
    LoadString(hInst,IDS_HELV          , szHelv          , SMLRCBUF);
    LoadString(hInst,IDS_APPNAME       , szAppName       , SMLRCBUF);
    LoadString(hInst,IDS_SERVICENAME   , szServiceName   , SMLRCBUF);
    LoadString(hInst,IDS_SYSERR        , szSysErr        , BIGRCBUF);
    LoadString(hInst,IDS_DIALING       , szDialing       , BIGRCBUF);
    LoadString(hInst,IDS_CONNECTABANDON, szConnectAbandon, BIGRCBUF);
    LoadString(hInst,IDS_HANGINGUP     , szHangingUp     , BIGRCBUF);
    LoadString(hInst,IDS_HASTERMINATED , szHasTerminated , BIGRCBUF);
    LoadString(hInst,IDS_CONNECTEDTO   , szConnectedTo   , BIGRCBUF);
    LoadString(hInst,IDS_CONNECTING    , szConnecting    , BIGRCBUF);
    LoadString(hInst,IDS_ISCALLING     , szIsCalling     , BIGRCBUF);
    LoadString(hInst,IDS_DIALHELP      , szDialHelp      , BIGRCBUF);
    LoadString(hInst,IDS_ANSWERHELP    , szAnswerHelp    , BIGRCBUF);
    LoadString(hInst,IDS_HANGUPHELP    , szHangUpHelp    , BIGRCBUF);
    LoadString(hInst,IDS_NOCONNECT     , szNoConnect     , BIGRCBUF);
    LoadString(hInst,IDS_ALWAYSONTOP   , szAlwaysOnTop   , BIGRCBUF);
    LoadString(hInst,IDS_NOCONNECTTO   , szNoConnectionTo, BIGRCBUF);
    LoadString(hInst,IDS_NONETINSTALLED, szNoNet         , SZBUFSIZ);

    LoadString(hInst,IDS_INISECTION, szIniSection    , SZBUFSIZ);
    LoadString(hInst,IDS_INIPREFKEY, szIniKey1       , BIGRCBUF);
    LoadString(hInst,IDS_INIFONTKEY, szIniKey2       , BIGRCBUF);
    LoadString(hInst,IDS_INIRINGIN , szIniRingIn     , BIGRCBUF);
    LoadString(hInst,IDS_INIRINGOUT, szIniRingOut    , BIGRCBUF);

    return;
}


#ifdef WIN16
#pragma alloc_text (_INIT, SaveWindowPlacement)
#endif
/*---------------------------------------------------------------------------*\
| SAVE WINDOW PLACEMENT
|   This routine saves the window position to the inifile.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR SaveWindowPlacement(PWINDOWPLACEMENT w)
{
    wsprintf(szBuf,szPlcFmt,w->showCmd,
                            w->ptMaxPosition.x,
                            w->ptMaxPosition.y,
                            w->rcNormalPosition.left,
                            w->rcNormalPosition.top,
                            w->rcNormalPosition.right,
                            w->rcNormalPosition.bottom);

    WritePrivateProfileString(szPref,szPlacement,szBuf,szIni);

    return;
}


/*---------------------------------------------------------------------------*\
| GET WINDOW PLACEMENT
|   This routine loads the window placement from the inifile.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
BOOL FAR ReadWindowPlacement(PWINDOWPLACEMENT w)
{
    BOOL bRet;


    bRet = FALSE;
    if(GetPrivateProfileString(szPref,szPlacement,szNull,szBuf,SZBUFSIZ,szIni))
    {
        w->length = sizeof(WINDOWPLACEMENT);

        if(_stscanf(szBuf,szPlcFmt,&(w->showCmd),
                                 &(w->ptMaxPosition.x),
                                 &(w->ptMaxPosition.y),
                                 &(w->rcNormalPosition.left),
                                 &(w->rcNormalPosition.top),
                                 &(w->rcNormalPosition.right),
                                 &(w->rcNormalPosition.bottom)) == 7)
        {

            bRet = TRUE;
        }
    }

    return(bRet);
}


#ifdef WIN16
#pragma alloc_text (_INIT, CreateTools)
#endif
/*---------------------------------------------------------------------------*\
| CREATE TOOLS
|   This routine creates the visual tools for the interface.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR CreateTools(HWND hwnd)
{
    HDC hdc;


    hdc        = GetDC(hwnd);
    hMemDC     = CreateCompatibleDC(hdc);
    hPhnBitmap = CreateCompatibleBitmap(hdc,cxIcon * 3,cyIcon);
    hOldMemObj = SelectObject(hMemDC,hPhnBitmap);
    ReleaseDC(hwnd,hdc);


    hHilitePen    = CreatePen(PS_SOLID,1,GetSysColor(COLOR_BTNHIGHLIGHT));
    hShadowPen    = CreatePen(PS_SOLID,1,GetSysColor(COLOR_BTNSHADOW));
    hFramePen     = CreatePen(PS_SOLID,1,GetSysColor(COLOR_WINDOWFRAME));

    hBtnFaceBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    hEditSndBrush = CreateSolidBrush(SndBrushColor);
    hEditRcvBrush = CreateSolidBrush(RcvBrushColor);

    // Create the statusbar/toolbar for the interface.
    //
    hwndToolbar = CreateToolbarEx(hwnd,(ChatState.fToolBar ? WS_VISIBLE : 0) | WS_BORDER | TBSTYLE_TOOLTIPS,IDC_TOOLBAR,6,hInst,IDBITMAP,tbButtons,cTbButtons,0,0,0,0,sizeof(TBBUTTON));
    hwndStatus  = CreateStatusWindow((ChatState.fStatusBar ? WS_VISIBLE : 0) | WS_BORDER | WS_CHILD,szNull,hwnd,IDSTATUS);

    // Load the application icons.
    //
    hPhones[0] = LoadIcon(hInst,TEXT("phone1"));
    hPhones[1] = LoadIcon(hInst,TEXT("phone2"));
    hPhones[2] = LoadIcon(hInst,TEXT("phone3"));


    // now build the parameters based on the font we will be using
    //
    dyBorder = GetSystemMetrics(SM_CYBORDER);

    return;
}


#ifdef WIN16
#pragma alloc_text (_INIT, DeleteTools)
#endif
/*---------------------------------------------------------------------------*\
| DELETES TOOLS
|   This routine deletes the visual tools for the interface.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR DeleteTools(HWND hwnd)
{
    DestroyWindow(hwndStatus);
    DestroyWindow(hwndToolbar);


    if(hEditSndFont)
        DeleteObject(hEditSndFont);

    if(hEditRcvFont)
        DeleteObject(hEditRcvFont);

    DeleteObject(hHilitePen);
    DeleteObject(hShadowPen);
    DeleteObject(hFramePen);
    DeleteObject(hBtnFaceBrush);
    DeleteObject(hEditSndBrush);
    DeleteObject(hEditRcvBrush);

    SelectObject(hMemDC,hOldMemObj);
    DeleteObject(hPhnBitmap);
    DeleteDC(hMemDC);

    return;
}


#ifdef WIN16
#pragma alloc_text (_INIT, CreateChildWindows)
#endif
/*---------------------------------------------------------------------------*\
| CREATE CHILD WINDOWS
|   This routine creates the child-windows for the application.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR CreateChildWindows(HWND hwnd)
{
    hwndSnd = CreateWindow (TEXT("edit"),
                            NULL,
                            WS_CHILD | WS_BORDER | WS_MAXIMIZE | WS_VISIBLE |
                            WS_VSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | ES_READONLY,
                            0, 0, 0, 0,
                            hwnd,
                            (HMENU)ID_EDITSND,
                            hInst,
                            NULL);


    hwndRcv = CreateWindow (TEXT("edit"),
                            NULL,
                            WS_CHILD | WS_BORDER | WS_MAXIMIZE | WS_VISIBLE |
                            WS_VSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | ES_READONLY,
                            0, 0, 0, 0,
                            hwnd,
                            (HMENU)ID_EDITRCV,
                            hInst,
                            NULL);

    // hook the send window...
    //
    lpfnOldEditProc = (WNDPROC)GetWindowLongPtr(hwndSnd,GWLP_WNDPROC);
    SetWindowLongPtr(hwndSnd,GWLP_WNDPROC,(LONG_PTR)EditProc);

    ShowWindow(hwndSnd,SW_SHOW);
    ShowWindow(hwndRcv,SW_SHOW);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\winchat\winchat.h ===
/*---------------------------------------------------------------------------*\
| WINCHAT MAIN HEADER FILE
|   This is the main header file for the application.
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 01-Nov-91
| history: 01-Nov-91 <clausgi>  created.
|          29-Dec-92 <chriswil> port to NT, cleanup.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

//////////// compile options //////////////
#define BRD 6
///////////////////////////////////////////


#ifdef WIN16
#define APIENTRY FAR PASCAL
#define ERROR_NO_NETWORK   0
#endif

#ifdef PROTOCOL_NEGOTIATE
typedef DWORD      PCKT;        // Bitfield capabilities.
#define CHT_VER    0x100        // Version 1.00 of WinChat.
#define PCKT_TEXT  0x00000001   // All versions had better support this.
#endif




// Constants.
//
#define SZBUFSIZ            255     // maximum size buffer.
#define SMLRCBUF             32     // size A .rc file buffer
#define BIGRCBUF             64     // size B .rc file buffer
#define UNCNLEN              32     //
#define CTRL_V               22     // Edit-control paste acccelerator.
#define IDACCELERATORS        1     // Menu accelerator resource ID.



// Menuhelp Constants.
//
#define MH_BASE             0x1000
#define MH_POPUPBASE        0x1100



// Child-Window ID's for send/receive windows.
//
#define ID_BASE             0x0CAC
#define ID_EDITSND          (ID_BASE + 0)
#define ID_EDITRCV          (ID_BASE + 1)



// Child-Window Identifiers for toolbar/statusbar.
//
#define IDC_TOOLBAR         200
#define IDBITMAP            201
#define IDSTATUS            202



// Menu Identifiers.
//
#define IDM_EDITFIRST       IDM_EDITUNDO
#define IDM_EDITLAST        IDM_EDITSELECT
#define IDM_ABOUT           100
#define IDM_DIAL            101
#define IDM_HANGUP          102
#define IDM_ANSWER          103
#define IDM_EXIT            104
#define IDM_EDITUNDO        105
#define IDM_EDITCUT         106
#define IDM_EDITCOPY        107
#define IDM_EDITPASTE       108
#define IDM_EDITCLEAR       109
#define IDM_EDITSELECT      110
#define IDM_SOUND           111
#define IDM_PREFERENCES     112
#define IDM_FONT            113
#define IDM_CONTENTS        114
#define IDM_SEARCHHELP      115
#define IDM_HELPHELP        116
#define IDM_COLOR           117
#define IDM_TOPMOST         118
#define IDM_CLOCK           119
#define IDM_TOOLBAR         120
#define IDM_STATUSBAR       121
#define IDM_SWITCHWIN       122
#define IDX_DEFERFONTCHANGE 123
#define IDX_UNICODECONV     126
#define IDM_FIRST           IDM_ABOUT

#define IDH_SELECTCOMPUTER  200


#ifdef PROTOCOL_NEGOTIATE
#define IDX_DEFERPROTOCOL   124
#endif


// Resource-String Identifiers.
//
#define IDS_HELV             1
#define IDS_APPNAME          2
#define IDS_LONGAPPNAME      3
#define IDS_SYSERR           4
#define IDS_CONNECTTO        5
#define IDS_ALREADYCONNECT   6
#define IDS_ABANDONFIRST     7
#define IDS_DIALING          8
#define IDS_YOUCALLER        9
#define IDS_NOTCALLED       10
#define IDS_NOTCONNECTED    11
#define IDS_CONNECTABANDON  12
#define IDS_HANGINGUP       13
#define IDS_HASTERMINATED   14
#define IDS_CONNECTEDTO     15
#define IDS_ISCALLING       16
#define IDS_CONNECTING      17
#define IDS_SERVICENAME     18
#define IDS_DIALHELP        19
#define IDS_ANSWERHELP      20
#define IDS_HANGUPHELP      21
#define IDS_NOCONNECT       22
#define IDS_ALWAYSONTOP     23
#define IDS_NOCONNECTTO     24
#define IDS_NONETINSTALLED  25

#define IDS_INISECTION      26
#define IDS_INIPREFKEY      27
#define IDS_INIFONTKEY      28
#define IDS_INIRINGIN       29
#define IDS_INIRINGOUT      30

#define IDS_TSNOTSUPPORTED  31


// Edit-Control Notification codes.  These
// are sent to the parent of the edit
// control just as any system-notify is.
//
#define EN_CHAR             0x060F
#define EN_PASTE            0x0610

// FE specific
#define EN_DBCS_STRING      0x0611


// Chat formats.  These are used to identify
// the type of data being transfered in a
// DDE transaction.
//
#define CHT_CHAR            0x100
#define CHT_FONTA           0x101
#define CHT_PASTEA          0x102
#define CHT_UNICODE         0x110
#define CHT_FONTW           0x111
#define CHT_PASTEW          0x112

// FE specific (not Taiwan)
#define CHT_DBCS_STRING     0x103


#ifdef PROTOCOL_NEGOTIATE
#define CHT_PROTOCOL        0x105
#endif


#if 0
#define CHT_HPENDATA        0x103   // defined in WFW311.  Conflicts w/DBCS.
#define CHT_CLEARPENDATA    0x104   //
#define CHT_ADDCHATTER      0x106   //
#define CHT_DELCHATTER      0x107   //
#define CHT_CHARBURST       0x108   //
#endif



// Window Related Functions  (winchat.c)
//
int     PASCAL   WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
LRESULT CALLBACK MainWndProc(HWND,UINT,WPARAM,LPARAM);
LRESULT CALLBACK EditProc(HWND,UINT,WPARAM,LPARAM);
BOOL    FAR      InitApplication(HINSTANCE);
BOOL    FAR      InitInstance(HINSTANCE,int);
VOID    FAR      UpdateButtonStates(VOID);
VOID    FAR      AdjustEditWindows(VOID);
LONG    FAR      myatol(LPTSTR);
BOOL    FAR      appGetComputerName(LPTSTR);
VOID             DrawShadowRect(HDC,LPRECT);
VOID             SendFontToPartner(VOID);
VOID             DoRing(LPCTSTR);
VOID             ClearEditControls(VOID);



// Initialization Routines  (wcinit.c)
//
VOID FAR SaveFontToIni(VOID);
VOID FAR SaveBkGndToIni(VOID);
VOID FAR InitFontFromIni(VOID);
VOID FAR LoadIntlStrings(VOID);
VOID FAR SaveWindowPlacement(PWINDOWPLACEMENT);
BOOL FAR ReadWindowPlacement(PWINDOWPLACEMENT);
VOID FAR CreateTools(HWND);
VOID FAR DeleteTools(HWND);
VOID FAR CreateChildWindows(HWND);



// Window handler routines  (winchat.c)
//
VOID    appWMCreateProc(HWND);
VOID    appWMWinIniChangeProc(HWND);
VOID    appWMSetFocusProc(HWND);
VOID    appWMMenuSelectProc(HWND,WPARAM,LPARAM);
VOID    appWMTimerProc(HWND);
VOID    appWMPaintProc(HWND);
VOID    appWMDestroyProc(HWND);
BOOL    appWMCommandProc(HWND,WPARAM,LPARAM);
VOID    appWMInitMenuProc(HMENU);
VOID    appWMSizeProc(HWND,WPARAM,LPARAM);
BOOL    appWMEraseBkGndProc(HWND);
LRESULT appWMSysCommandProc(HWND,WPARAM,LPARAM);
HBRUSH  appWMCtlColorProc(HWND,WPARAM,LPARAM);
HICON   appWMQueryDragIconProc(HWND);



// DDE Related Functions.
//
HDDEDATA CALLBACK DdeCallback(UINT,UINT,HCONV,HSZ,HSZ,HDDEDATA,DWORD,DWORD);
HDDEDATA          CreateCharData(VOID);
HDDEDATA          CreatePasteData(VOID);

// FE specific
HDDEDATA          CreateDbcsStringData(VOID);

#ifdef PROTOCOL_NEGOTIATE
HDDEDATA          CreateProtocolData(VOID);
PCKT              GetCurrentPckt(VOID);
VOID              FlagIntersection(PCKT);
VOID              AnnounceSupport(VOID);
#endif


//
//
typedef UINT (WINAPI *WNETCALL)(HWND,LPTSTR,LPTSTR,WORD,DWORD);
HINSTANCE APIENTRY WNetGetCaps(WORD);



// Chat Data.
//   This data-structure must maintain
//   fixed-size fields so that they may
//   be transfered accross platforms.
//
#ifndef RC_INVOLKED

#define LF_XPACKFACESIZE  32
#define XCHATSIZEA        60
#define XCHATSIZEW        92

#pragma pack(2)
typedef struct tagXPACKFONTA
{
    WORD lfHeight;
    WORD lfWidth;
    WORD lfEscapement;
    WORD lfOrientation;
    WORD lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[LF_XPACKFACESIZE];
} XPACKFONTA;

typedef struct tagXPACKFONTW
{
    WORD lfHeight;
    WORD lfWidth;
    WORD lfEscapement;
    WORD lfOrientation;
    WORD lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[LF_XPACKFACESIZE];
} XPACKFONTW;

typedef struct _CHATDATAA
{
    WORD type;

    union
    {

        // This data for DBCS string transfer.
        //
        struct
        {
            DWORD   SelPos;
            DWORD   size;
            HGLOBAL hString;
        } cd_dbcs;

        // This data for character transfer.
        //
        struct
        {
            DWORD SelPos;
            WORD  Char;
        } cd_char;


        // This data for remote font change.
        //
        struct
        {
            XPACKFONTA lf;
            COLORREF   cref;
            COLORREF   brush;
        } cd_win;


        // This data for remote paste.
        //
        struct
        {
            DWORD SelPos;
            DWORD size;
        } cd_paste;

#ifdef PROTOCOL_NEGOTIATE
        // This data for Protocol Negotiate.
        //
        struct
        {
            DWORD dwVer;
            PCKT  pckt;
        } cd_protocol;
#endif

    } uval;
} CHATDATAA;

typedef struct _CHATDATAW
{
    WORD type;

    union
    {

        // This data for DBCS string transfer.
        //
        struct
        {
            DWORD   SelPos;
            DWORD   size;
            HGLOBAL hString;
        } cd_dbcs;

        // This data for character transfer.
        //
        struct
        {
            DWORD SelPos;
            WORD  Char;
        } cd_char;


        // This data for remote font change.
        //
        struct
        {
            XPACKFONTW  lf;
            COLORREF    cref;
            COLORREF    brush;
        } cd_win;


        // This data for remote paste.
        //
        struct
        {
            DWORD SelPos;
            DWORD size;
        } cd_paste;

#ifdef PROTOCOL_NEGOTIATE
        // This data for Protocol Negotiate.
        //
        struct
        {
            DWORD dwVer;
            PCKT  pckt;
        } cd_protocol;
#endif

    } uval;

} CHATDATAW;

#pragma pack()

typedef XPACKFONTA      *PXPACKFONTA;
typedef XPACKFONTA NEAR *NPXPACKFONTA;
typedef XPACKFONTA FAR  *LPXPACKFONTA;

typedef CHATDATAA       *PCHATDATAA;
typedef CHATDATAA NEAR  *NPCHATDATAA;
typedef CHATDATAA FAR   *LPCHATDATAA;

typedef XPACKFONTW      *PXPACKFONTW;
typedef XPACKFONTW NEAR *NPXPACKFONTW;
typedef XPACKFONTW FAR  *LPXPACKFONTW;

typedef CHATDATAW       *PCHATDATAW;
typedef CHATDATAW NEAR  *NPCHATDATAW;
typedef CHATDATAW FAR   *LPCHATDATAW;

#ifdef UNICODE
#define XPACKFONT  XPACKFONTW
#else
#define XPACKFONT  XPACKFONTA
#endif

typedef XPACKFONT      *PXPACKFONT;
typedef XPACKFONT NEAR *NPXPACKFONT;
typedef XPACKFONT FAR  *LPXPACKFONT;

#ifdef UNICODE
#define CHATDATA   CHATDATAW
#else
#define CHATDATA   CHATDATAA
#endif

typedef CHATDATA      *PCHATDATA;
typedef CHATDATA NEAR *NPCHATDATA;
typedef CHATDATA FAR  *LPCHATDATA;

#endif


// Chat state info struct
//
typedef struct _CHATSTATE
{
    UINT fConnected          : 1;
    UINT fConnectPending     : 1;
    UINT fAllowAnswer        : 1;
    UINT fIsServer           : 1;
    UINT fServerVerified     : 1;
    UINT fInProcessOfDialing : 1;
    UINT fSound              : 1;
    UINT fMMSound            : 1;
    UINT fUseOwnFont         : 1;
    UINT fSideBySide         : 1;
    UINT fMinimized          : 1;
    UINT fTopMost            : 1;
    UINT fToolBar            : 1;
    UINT fStatusBar          : 1;
    UINT fUnicode            : 1;

#ifdef PROTOCOL_NEGOTIATE
    UINT fProtocolSent       : 1;
#endif

} CHATSTATE;
typedef CHATSTATE      *PCHATSTATE;
typedef CHATSTATE NEAR *NPCHATSTATE;
typedef CHATSTATE FAR  *LPCHATSTATE;



// Insertable macroes.
//
#define KILLSOUND              {if(ChatState.fMMSound) sndPlaySound(NULL,SND_ASYNC);}
#define SetStatusWindowText(x) {if(hwndStatus)SendMessage(hwndStatus,SB_SETTEXT,0,(LPARAM)(LPSTR)(x));}



// Helpfull porting macroes.  These were necessary
// especially for notification codes which changed
// drastically between DOS/WIN and NT.
//
#ifdef WIN32
#define GET_WM_MENUSELECT_CMD(wParam,lParam)    (UINT)(int)(short)LOWORD(wParam)
#define GET_WM_MENUSELECT_FLAGS(wParam,lParam)  (UINT)(int)(short)HIWORD(wParam)
#define GET_WM_MENUSELECT_HMENU(wParam,lParam)  (HMENU)lParam
#define SET_EM_SETSEL_WPARAM(nStart,nEnd)       (WPARAM)nStart
#define SET_EM_SETSEL_LPARAM(nStart,nEnd)       (LPARAM)nEnd
#define GET_WM_CTLCOLOREDIT_HDC(wParam,lParam)  (HDC)wParam
#define GET_WM_CTLCOLOREDIT_HWND(wParam,lParam) (HWND)lParam
#define GET_EN_SETFOCUS_NOTIFY(wParam,lParam)   (UINT)HIWORD(wParam)
#define GET_EN_SETFOCUS_CMD(wParam,lParam)      (UINT)LOWORD(wParam)
#define GET_EN_SETFOCUS_HWND(wParam,lParam)     (HWND)lParam
#define SET_EN_NOTIFY_WPARAM(id,notify,hwnd)    (WPARAM)MAKELONG(id,notify)
#define SET_EN_NOTIFY_LPARAM(id,notify,hwnd)    (LPARAM)hwnd
#define WNETGETCAPS(wFlag)                      NULL
#define WNETGETUSER(szlocal,szuser,ncount)      WNetGetUser(szlocal,szuser,ncount)
#define SETMESSAGEQUEUE(size)                   size

#else

int APIENTRY ShellAbout(HWND hWnd, LPSTR szApp, LPSTR szOtherStuff, HICON hIcon);
#define GET_WM_MENUSELECT_CMD(wParam,lParam)    (UINT)wParam
#define GET_WM_MENUSELECT_FLAGS(wParam,lParam)  (UINT)(LOWORD(lParam))
#define GET_WM_MENUSELECT_HMENU(wParam,lParam)  (HMENU)(HIWORD(lParam))
#define SET_EM_SETSEL_WPARAM(nStart,nEnd)       (WPARAM)0
#define SET_EM_SETSEL_LPARAM(nStart,nEnd)       (LPARAM)(MAKELONG(nStart,nEnd))
#define GET_WM_CTLCOLOREDIT_HDC(wParam,lParam)  (HDC)wParam
#define GET_WM_CTLCOLOREDIT_HWND(wParam,lParam) (HWND)(LOWORD(lParam))
#define GET_EN_SETFOCUS_NOTIFY(wParam,lParam)   (UINT)(HIWORD(lParam))
#define GET_EN_SETFOCUS_CMD(wParam,lParam)      (UINT)wParam
#define GET_EN_SETFOCUS_HWND(wParam,lParam)     (HWND)(LOWORD(lParam))
#define SET_EN_NOTIFY_WPARAM(id,notify,hwnd)    (WPARAM)id
#define SET_EN_NOTIFY_LPARAM(id,notify,hwnd)    (LPARAM)(MAKELONG(hwnd,notify))
#define WNETGETCAPS(wFlag)                      WNetGetCaps(wFlag)
#define WNETGETUSER(szlocal,szuser,ncount)      ERROR_NO_NETWORK
#define SETMESSAGEQUEUE(size)                   SetMessageQueue(size)
#endif




VOID PackFont(LPXPACKFONT,LPLOGFONT);
VOID UnpackFont(LPLOGFONT,LPXPACKFONT);
VOID StartIniMapping(VOID);
VOID EndIniMapping(VOID);

#ifndef ByteCountOf
#define ByteCountOf(x) sizeof(TCHAR)*(x)
#endif

#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\winchat\winchat.c ===
/*---------------------------------------------------------------------------*\
| WINCHAT APPLICATION MODULE
|   This is the main module file for the application.  The application was
|   originally written by ClausGi for the Windows-For-WorkGroup product.
|   In the port to NT, all references to PEN-awareness and Protocol were
|   removed.  Extensive cleanup and documenting was also added in the port.
|
|   FUNCTIONS
|   ---------
|   myatol
|   UpdateButtonStates
|   appGetComputerName
|   AdjustEditWindows
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 01-Nov-91
| history: 01-Nov-91 <clausgi>  created.
|          29-Dec-92 <chriswil> port to NT, cleanup.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <ddeml.h>
#include <commdlg.h>
#include <commctrl.h>
#include <shellapi.h>
#include <nddeapi.h>
#include <richedit.h>
#include "winchat.h"
#include "dialogs.h"
#include "globals.h"
#include "nddeagnt.h"

#include <tchar.h>
#include <imm.h>
#include <htmlhelp.h>

#define ASSERT(x)

// This is used in the port to NT.  Since NT doesn't haven a dialogbox for
// this function, we'll use the lanman export.
//
#ifdef WIN32
#define FOCUSDLG_DOMAINS_ONLY        (1)
#define FOCUSDLG_SERVERS_ONLY        (2)
#define FOCUSDLG_SERVERS_AND_DOMAINS (3)

#define FOCUSDLG_BROWSE_LOGON_DOMAIN         0x00010000
#define FOCUSDLG_BROWSE_WKSTA_DOMAIN         0x00020000
#define FOCUSDLG_BROWSE_OTHER_DOMAINS        0x00040000
#define FOCUSDLG_BROWSE_TRUSTING_DOMAINS     0x00080000
#define FOCUSDLG_BROWSE_WORKGROUP_DOMAINS    0x00100000

#define FOCUSDLG_BROWSE_LM2X_DOMAINS         (FOCUSDLG_BROWSE_LOGON_DOMAIN | FOCUSDLG_BROWSE_WKSTA_DOMAIN | FOCUSDLG_BROWSE_OTHER_DOMAINS)
#define FOCUSDLG_BROWSE_ALL_DOMAINS          (FOCUSDLG_BROWSE_LOCAL_DOMAINS | FOCUSDLG_BROWSE_WORKGROUP_DOMAINS)
#define FOCUSDLG_BROWSE_LOCAL_DOMAINS        (FOCUSDLG_BROWSE_LM2X_DOMAINS | FOCUSDLG_BROWSE_TRUSTING_DOMAINS)

#define MY_LOGONTYPE                         (FOCUSDLG_BROWSE_ALL_DOMAINS | FOCUSDLG_SERVERS_ONLY)

UINT APIENTRY I_SystemFocusDialog(HWND,UINT,LPWSTR,UINT,PBOOL,LPWSTR,DWORD);
#endif

BOOL TranslateWideCharPosToMultiBytePos(HWND,DWORD,DWORD,LPDWORD,LPDWORD);


/*---------------------------------------------------------------------------*\
| WINDOWS MAIN
|   This is the main event-processing loop for the application.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    MSG msg;


    msg.wParam = 0;

    if(InitApplication(hInstance))
    {
        if(InitInstance(hInstance,nCmdShow))
        {
            while(GetMessage(&msg,NULL,0,0))
            {
                if(!TranslateAccelerator(hwndApp,hAccel,&msg))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }

            if(hszConvPartner)
                DdeFreeStringHandle(idInst,hszConvPartner);

            DdeFreeStringHandle(idInst,hszChatTopic);
            DdeFreeStringHandle(idInst,hszChatShare);
            DdeFreeStringHandle(idInst,hszLocalName );
            DdeFreeStringHandle(idInst,hszTextItem);
            DdeFreeStringHandle(idInst,hszConnectTest);
            DdeUninitialize(idInst);

            EndIniMapping();
        }
    }

    return((int)msg.wParam);
}


#ifdef WIN16
#pragma alloc_text ( _INIT, InitApplication )
#endif
/*---------------------------------------------------------------------------*\
| INITIALIZE APPLICATION
|   This routine registers the application with user.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
BOOL FAR InitApplication(HINSTANCE hInstance)
{
    WNDCLASS wc;


    wc.style         = 0;
    wc.lpfnWndProc   = MainWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon(hInstance, TEXT("PHONE1"));
    wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    wc.lpszMenuName  = szWinChatMenu;
    wc.lpszClassName = szWinChatClass;

    return(RegisterClass(&wc));
}


#define IMMMODULENAME L"IMM32.DLL"
#define PATHDLM     L'\\'
#define IMMMODULENAMELEN    ((sizeof PATHDLM + sizeof IMMMODULENAME) / sizeof(WCHAR))

VOID GetImmFileName(PWSTR wszImmFile)
{
    UINT i = GetSystemDirectoryW(wszImmFile, MAX_PATH);
    if (i > 0 && i < MAX_PATH - IMMMODULENAMELEN) {
        wszImmFile += i;
        if (wszImmFile[-1] != PATHDLM) {
            *wszImmFile++ = PATHDLM;
        }
    }
    wcscpy(wszImmFile, IMMMODULENAME);
}

/*---------------------------------------------------------------------------*\
| IsTSRemoteSession
|
| Input:      None
| Output:     BOOL - TRUE if in a Terminal Server remote session (SessionId != 0)
|             FALSE - if error OR not in a TS rermote session
| Function:   To determine whether we are running in a TS remote session or not.
|
\*---------------------------------------------------------------------------*/
BOOL IsTSRemoteSession()
{
    BOOL      bRetVal;
    DWORD     dwSessionID;
    HINSTANCE hInst;
    FARPROC   lpfnProcessIdToSessionId;

    //assume failure
    bRetVal = FALSE;

    // load library and get proc address
    hInst=LoadLibrary(TEXT("kernel32.dll"));

    if (hInst)
    {
        lpfnProcessIdToSessionId = GetProcAddress(hInst,"ProcessIdToSessionId");

        if (lpfnProcessIdToSessionId )
        {
            if (lpfnProcessIdToSessionId(GetCurrentProcessId(),&dwSessionID))
            {
                if(dwSessionID!=0)
                {
                    bRetVal = TRUE;
                }
            }
        }

        // free the library
        FreeLibrary(hInst);
    }

    return bRetVal;
}




#ifdef WIN16
#pragma alloc_text ( _INIT, InitInstance )
#endif
/*---------------------------------------------------------------------------*\
| INITIALIZE APPLICATION INTSTANCE
|   This routine initializes instance information.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
BOOL FAR InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    HWND      hwnd;
    HMENU     hMenu;
        HINSTANCE hmodNetDriver;
    int       cAppQueue;
    BOOL      bRet;

    hInst = hInstance;


    //
    // get DBCS flag
    //
    gfDbcsEnabled = GetSystemMetrics(SM_DBCSENABLED);

    if (GetSystemMetrics(SM_IMMENABLED)) {
        //
        // if IME is enabled, get real API addresses
        //
        WCHAR wszImmFile[MAX_PATH];
        HINSTANCE hInstImm32;
        GetImmFileName(wszImmFile);
        hInstImm32 = GetModuleHandle(wszImmFile);
        if (hInstImm32) {
            pfnImmGetContext = (PVOID)GetProcAddress(hInstImm32, "ImmGetContext");
            ASSERT(pfnImmGetContext);
            pfnImmReleaseContext = (PVOID)GetProcAddress(hInstImm32, "ImmReleaseContext");
            ASSERT(pfnImmReleaseContext);
            pfnImmGetCompositionStringW = (PVOID)GetProcAddress(hInstImm32, "ImmGetCompositionStringW");
            ASSERT(pfnImmGetCompositionStringW);
        }
    }

    // increase our app queue for better performance...
    //
    for(cAppQueue=128; !SETMESSAGEQUEUE(cAppQueue); cAppQueue >>= 1);


    //
    //
    bRet = FALSE;
    if(cAppQueue >= 8)
    {
        bRet = TRUE;

        cxIcon = GetSystemMetrics(SM_CXICON);
        cyIcon = GetSystemMetrics(SM_CYICON);
        hAccel = LoadAccelerators(hInstance,MAKEINTRESOURCE(IDACCELERATORS));



        LoadIntlStrings();
        StartIniMapping();


        InitFontFromIni();


        // check if it's a Terminal Server remote session
        if (IsTSRemoteSession())
        {
            TCHAR szTSNotSupported[SZBUFSIZ];

            LoadString(hInst, IDS_TSNOTSUPPORTED, szTSNotSupported, SZBUFSIZ);

            MessageBeep(MB_ICONSTOP);
            MessageBox(NULL, szTSNotSupported, szAppName, MB_OK | MB_ICONSTOP);
            return(FALSE);
        }

        // get our machine name and map to correct character set.
        //
        if(!appGetComputerName(szLocalName))
        {
            MessageBeep(MB_ICONSTOP);
            MessageBox(NULL,szSysErr,szAppName,MB_OK | MB_ICONSTOP);
            return(FALSE);
        }


        // initialize DDEML.
        //
        if(DdeInitialize(&idInst,(PFNCALLBACK)MakeProcInstance((FARPROC)DdeCallback,hInst),APPCLASS_STANDARD,0L))
        {
            MessageBeep(MB_ICONSTOP);
            MessageBox(NULL,szSysErr,szAppName,MB_OK | MB_ICONSTOP);
            return(FALSE);
        }


        ChatState.fMinimized  = (nCmdShow == SW_MINIMIZE) ? TRUE : FALSE;
        ChatState.fMMSound    = waveOutGetNumDevs();
        ChatState.fSound      = GetPrivateProfileInt(szPref,szSnd  ,1,szIni);
        ChatState.fToolBar    = GetPrivateProfileInt(szPref,szTool ,1,szIni);
        ChatState.fStatusBar  = GetPrivateProfileInt(szPref,szStat ,1,szIni);
        ChatState.fTopMost    = GetPrivateProfileInt(szPref,szTop  ,0,szIni);
        ChatState.fSideBySide = GetPrivateProfileInt(szPref,szSbS  ,0,szIni);
        ChatState.fUseOwnFont = GetPrivateProfileInt(szPref,szUseOF,0,szIni);

        hszLocalName          = DdeCreateStringHandle(idInst,szLocalName  ,0);
        hszChatTopic          = DdeCreateStringHandle(idInst,szChatTopic  ,0);
        hszChatShare          = DdeCreateStringHandle(idInst,szChatShare  ,0);
        hszServiceName        = DdeCreateStringHandle(idInst,szServiceName,0);
        hszConnectTest        = DdeCreateStringHandle(idInst,szConnectTest,0);
        hszTextItem           = DdeCreateStringHandle(idInst,szChatText   ,0);

        if(!hszLocalName || !hszChatTopic || !hszServiceName || !hszTextItem || !hszChatShare)
        {
            MessageBeep(MB_ICONSTOP);
            MessageBox(NULL,szSysErr,szAppName,MB_OK | MB_ICONSTOP);
            return(FALSE);
        }

        DdeNameService(idInst,hszServiceName,(HSZ)0,DNS_REGISTER);


        if(DdeGetLastError(idInst) != DMLERR_NO_ERROR)
        {
            MessageBeep(MB_ICONSTOP);
            MessageBox (NULL,szSysErr,szAppName,MB_OK | MB_ICONSTOP);
            return(FALSE);
        }

        cf_chatdata = RegisterClipboardFormat(TEXT("Chat Data"));
        if(!(cf_chatdata))
        {
            MessageBeep(MB_ICONSTOP);
            MessageBox(NULL,szSysErr,szAppName,MB_OK | MB_ICONSTOP);
            return(FALSE);
        }


        // get winnet extension browse dialog entry point
        //
        WNetServerBrowseDialog = NULL;
        hmodNetDriver          = WNETGETCAPS(0xFFFF);

        if(hmodNetDriver != NULL)
            WNetServerBrowseDialog = (WNETCALL)GetProcAddress(hmodNetDriver,(LPSTR)146);



        // create main window
        hwnd = CreateWindow(
            szWinChatClass,
            szAppName,
            WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            NULL,
            NULL,
            hInstance,
            NULL
        );

        if(!hwnd)
        {
            MessageBeep(MB_ICONSTOP);
            MessageBox(NULL,szSysErr,szAppName,MB_OK | MB_ICONSTOP);
            return(FALSE);
        }

        hwndApp = hwnd; // save global

        // font choice struct init
        //
        chf.lStructSize    = sizeof(CHOOSEFONT);
        chf.lpLogFont      = &lfSnd;
        chf.Flags          = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT;
        chf.rgbColors      = GetSysColor(COLOR_WINDOWTEXT);
        chf.lCustData      = 0L;
        chf.lpfnHook       = NULL;
        chf.lpTemplateName = NULL;
        chf.hInstance      = NULL;
        chf.lpszStyle      = NULL;
        chf.nFontType      = SCREEN_FONTTYPE;
        chf.nSizeMin       = 0;
        chf.nSizeMax       = 0;


        // color choice init
        //
        chc.lStructSize    = sizeof(CHOOSECOLOR);
        chc.hwndOwner      = hwndApp;
        chc.hInstance      = hInst;
        chc.lpCustColors   = (LPDWORD)CustColors;
        chc.Flags          = CC_RGBINIT | CC_PREVENTFULLOPEN;
        chc.lCustData      = 0;
        chc.lpfnHook       = NULL;
        chc.lpTemplateName = NULL;


        // window placement...
        //
        if(ReadWindowPlacement(&Wpl))
        {
            // override these - CODEWORK don't need to save
            // them to .ini, but will mis-parse old .ini files
            // if change is made.
            //
            Wpl.showCmd         = nCmdShow;
            Wpl.ptMaxPosition.x = -1;
            Wpl.ptMaxPosition.y = -1;
            Wpl.flags           = 0;

            SetWindowPlacement(hwnd,&Wpl);
            UpdateWindow(hwnd);
        }
        else
            ShowWindow(hwnd,nCmdShow);

        //
        //
        hMenu = GetSystemMenu(hwnd,FALSE);
        AppendMenu(hMenu,MF_SEPARATOR,0,NULL);

        if(ChatState.fTopMost)
            AppendMenu(hMenu,MF_ENABLED | MF_CHECKED | MF_STRING,IDM_TOPMOST,szAlwaysOnTop);
        else
            AppendMenu(hMenu,MF_ENABLED | MF_UNCHECKED | MF_STRING,IDM_TOPMOST,szAlwaysOnTop);


        // Set topmost style...
        //
        SetWindowPos(hwndApp,ChatState.fTopMost ? HWND_TOPMOST : HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        UpdateButtonStates();

#if !defined(_WIN64)

        {
            static NDDESHAREINFO nddeShareInfo = {
                1,              // revision
                szChatShare,
                SHARE_TYPE_STATIC,
                TEXT("WinChat|Chat\0\0"),
                TRUE,           // shared
                FALSE,          // not a service
                TRUE,           // can be started
                SW_SHOWNORMAL,
                {0,0},          // mod id
                0,              // no item list
                TEXT("")
            };

            TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 3] = TEXT("\\\\");
            DWORD cbName = MAX_COMPUTERNAME_LENGTH + 1;

            //
            // Make sure NetDDE DSDM has trusted shares set up properly for us.
            // This fix allows us to work with floating profiles.
            //

            START_NETDDE_SERVICES(hwnd);
            GetComputerName(&szComputerName[2],&cbName);
            NDdeShareAdd(szComputerName,2,NULL,(LPBYTE)&nddeShareInfo,sizeof(NDDESHAREINFO));
            NDdeSetTrustedShare(szComputerName, szChatShare,
                    NDDE_TRUST_SHARE_START | NDDE_TRUST_SHARE_INIT);
        }

#endif

    }

    return(bRet);
}


/*---------------------------------------------------------------------------*\
| MAIN WINDOW PROC
|   This is the main event-handler for the application.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT  lResult;


    lResult = 0l;
    switch(message)
    {
        case WM_CREATE:
            appWMCreateProc(hwnd);
            break;

        case WM_WININICHANGE:
            appWMWinIniChangeProc(hwnd);
            break;

        case WM_ERASEBKGND:
            if((lResult = (LRESULT)appWMEraseBkGndProc(hwnd)) == 0)
                lResult = DefWindowProc(hwnd,message,wParam,lParam);
            break;

        case WM_SETFOCUS:
            appWMSetFocusProc(hwnd);
            break;

        case WM_MENUSELECT:
            appWMMenuSelectProc(hwnd,wParam,lParam);
            break;

        case WM_TIMER:
            appWMTimerProc(hwnd);
            break;

        case WM_PAINT:
            appWMPaintProc(hwnd);
            break;

        case WM_QUERYDRAGICON:
            lResult = (LRESULT)(LPVOID)appWMQueryDragIconProc(hwnd);
            break;

        case WM_SIZE:
            appWMSizeProc(hwnd,wParam,lParam);
            break;

        case WM_INITMENU:
            appWMInitMenuProc((HMENU)wParam);
            break;

        case WM_SYSCOMMAND:
            if(!appWMSysCommandProc(hwnd,wParam,lParam))
                lResult = DefWindowProc(hwnd,message,wParam,lParam);
            break;

        case WM_COMMAND:
            if(!appWMCommandProc(hwnd,wParam,lParam))
                lResult = DefWindowProc(hwnd,message,wParam,lParam);
            break;

        case WM_NOTIFY:
            {
            LPTOOLTIPTEXT lpTTT = (LPTOOLTIPTEXT) lParam;

            if (lpTTT->hdr.code == TTN_NEEDTEXT) {
                LoadString (hInst, (UINT)(MH_BASE + lpTTT->hdr.idFrom), lpTTT->szText, 80);
                return TRUE;
            }
            }
            break;

#ifdef WIN32
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORSTATIC:
#else
        case WM_CTLCOLOR:
#endif
            if((lResult = (LRESULT)(LPVOID)appWMCtlColorProc(hwnd,wParam,lParam)) == 0l)
                lResult = DefWindowProc(hwnd,message,wParam,lParam);
            break;

        case WM_DESTROY:
            appWMDestroyProc(hwnd);
            break;

        case WM_CLOSE:
            WinHelp(hwnd,(LPTSTR)szHelpFile,HELP_QUIT,0L);

            // Fall through for final close.
            //


        default:
            lResult = DefWindowProc(hwnd,message,wParam,lParam);
            break;
    }

    return(lResult);
}


/*---------------------------------------------------------------------------*\
| EDIT-HOOK PROCEDURE
|   This is the main event-handler for the edit-control hook.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
LRESULT CALLBACK EditProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    WPARAM wSet;
    LPARAM lSet;
    GETTEXTLENGTHEX gettextlengthex;
    LRESULT lResult;
    LPTSTR lpszText;
    HANDLE hText;
    INT count;
    LPTSTR lpszStartSel;
    DWORD dwTemp1;
    DWORD dwTemp2;

    switch(msg) {
    case WM_IME_COMPOSITION:
        {
            LPWSTR  lpStrParam;
            LPSTR   lpStrTmp;
            HANDLE  hTmp;

            if (lParam & GCS_RESULTSTR)
            {
                HIMC  hImc;
                ULONG cCharsMbcs, cChars;

                //
                // Get input context of hwnd
                //

                if ((hImc = pfnImmGetContext(hwnd)) == 0)
                    break;

                //
                //ImmGetComposition returns the size of buffer needed in byte
                //

                cCharsMbcs =  pfnImmGetCompositionStringW(hImc,GCS_RESULTSTR, NULL , 0);
                if(!(cCharsMbcs))
                {
                    pfnImmReleaseContext(hwnd, hImc);
                    break;
                }

                lpStrParam = (LPWSTR)GlobalAlloc(GPTR,//HEAP_ZERO_MEMORY,
                                    cCharsMbcs + sizeof(WCHAR));

                if (lpStrParam==NULL)
                {
                    pfnImmReleaseContext(hwnd, hImc);
                    break;
                }

                pfnImmGetCompositionStringW(hImc, GCS_RESULTSTR, lpStrParam,
                                    cCharsMbcs);

                //
                // Compute character count including NULL char.
                //

                cChars = wcslen(lpStrParam) + 1;

                //
                // Set ChatData packet
                //

                ChatData.type                = CHT_DBCS_STRING;

                //
                // Get current cursor position
                //
                // !!! BUG BUG BUG !!!
                //
                //  This position data is only nice for Unicode Edit control.
                // is the partner has not Unicode Edit control. the string
                // will be truncated.
                //

                SendMessage(hwndSnd,EM_GETSEL,(WPARAM)&dwTemp1,(LPARAM)&dwTemp2);
                ChatData.uval.cd_dbcs.SelPos = MAKELONG((WORD)dwTemp1, (WORD)dwTemp2 );

                if (gfDbcsEnabled) {
                    //
                    // since text is passed as multi byte character string,
                    // position fixup is needed if DBCS is enabled
                    //
                    DWORD dwStart, dwEnd;

                    TranslateWideCharPosToMultiBytePos( hwndSnd,
                        (DWORD)LOWORD(ChatData.uval.cd_dbcs.SelPos),
                        (DWORD)HIWORD(ChatData.uval.cd_dbcs.SelPos),
                        &dwStart, &dwEnd );
                    ChatData.uval.cd_dbcs.SelPos
                        = MAKELONG((WORD)dwStart, (WORD)dwEnd );
               }

               //
               // Allocate string buffer for DDE.
               //

               if((hTmp = GlobalAlloc( GMEM_ZEROINIT |
                                       GMEM_MOVEABLE |
                                       GMEM_DDESHARE   ,
                                       (DWORD)cCharsMbcs)) == NULL)
               {
                    pfnImmReleaseContext(hwnd, hImc);
                    GlobalFree(lpStrParam);
                    break;
               }

               lpStrTmp                     = GlobalLock(hTmp);

               //
               // Store MBCS string into DDE buffer.
               //
               // In CHT_DBCS_STRING context, we should send mbcs string
               // for downlevel connectivity.
               //

               WideCharToMultiByte(CP_ACP,0,lpStrParam,cChars/* + 1*/,
                                            lpStrTmp  ,cCharsMbcs/* + 1*/,
                                            NULL,NULL);

               //
               // Keep the buffer handle in to DDE message packet.
               //

               GlobalUnlock(hTmp);
               ChatData.uval.cd_dbcs.hString = hTmp;

               //
               // Now, we have a packet to send server/client, just send it.
               //

               wSet = SET_EN_NOTIFY_WPARAM(ID_EDITSND,EN_DBCS_STRING,hwnd);
               lSet = SET_EN_NOTIFY_LPARAM(ID_EDITSND,EN_DBCS_STRING,hwnd);
               SendMessage(hwndApp,WM_COMMAND,wSet,lSet);

               //
               // if we have still a connection to server/client. repaint text.
               //

               if(ChatState.fConnected)
                   SendMessage(hwndSnd,EM_REPLACESEL,0,(LPARAM)lpStrParam);

               pfnImmReleaseContext(hwnd, hImc);
               GlobalFree(lpStrParam);

               return(TRUE);
            }
            break;
        }

#if 0   // FE: obsolete. leave it here only FYI
    case WM_IME_REPORT:
        {
            LPTSTR   lpStrParam,lpStrTmp;
            HANDLE  hTmp;

            if(wParam == IR_STRING)
            {
                if(lpStrParam = GlobalLock((HANDLE)lParam))
                {
                    if(hTmp = GlobalAlloc(GMEM_ZEROINIT | GMEM_MOVEABLE | GMEM_DDESHARE,(DWORD)(lstrlen(lpStrParam) + 1)))
                    {
                        ChatData.type                = CHT_DBCS_STRING;
                        ChatData.uval.cd_dbcs.SelPos = SendMessage(hwndSnd,EM_GETSEL,0,0L);
                        lpStrTmp                     = GlobalLock(hTmp);
                        lstrcpy(lpStrTmp, lpStrParam);
                        GlobalUnlock(hTmp);
                        ChatData.uval.cd_dbcs.hString = hTmp;

                        wSet = SET_EN_NOTIFY_WPARAM(ID_EDITSND,EN_DBCS_STRING,hwnd);
                        lSet = SET_EN_NOTIFY_LPARAM(ID_EDITSND,EN_DBCS_STRING,hwnd);
                        SendMessage(hwndApp,WM_COMMAND,wSet,lSet);

                        if(ChatState.fConnected)
                            SendMessage(hwndSnd,EM_REPLACESEL,0,(LPARAM)lpStrParam);

                        GlobalUnlock((HANDLE)lParam);

                        return(TRUE);
                    }
                    else
                    {
                        GlobalUnlock((HANDLE)lParam);
                        break;
                    }
                }
            }
            break;
        }
#endif  // FE: obsolete

    case WM_KEYDOWN:
        if (wParam == VK_DELETE) {
            DWORD dwLastError;
            ChatData.type                = CHT_CHAR;

            SendMessage(hwndSnd,EM_GETSEL,(WPARAM)&dwTemp1,(LPARAM)&dwTemp2);
            ChatData.uval.cd_dbcs.SelPos = MAKELONG((WORD)dwTemp1, (WORD)dwTemp2 );

            lResult=SendMessage(hwndSnd,WM_GETTEXTLENGTH,0,0);
            // if we are trying to delete at the end of the line then ignore it
            if(lResult<=LOWORD(ChatData.uval.cd_char.SelPos)) break;

            if (LOWORD(ChatData.uval.cd_char.SelPos) == HIWORD(ChatData.uval.cd_char.SelPos)) {

                // get handle to the text
                hText = (HANDLE)SendMessage( hwndSnd, EM_GETHANDLE, 0, 0);
                if( !(hText) )
                    break;

                lpszText = LocalLock( hText);
                if( !(lpszText))
                {
                    LocalUnlock(hText);
                    break;
                }
                lpszStartSel=lpszText;
                for(count=0;count<LOWORD(ChatData.uval.cd_char.SelPos);count++)
                {
                    lpszStartSel=CharNext(lpszStartSel);
                    if(lpszStartSel[0] == TEXT('\0')) break;  // if at the end then break since something is mesed
                }

                if(lpszStartSel[0] != TEXT('\0') && lpszStartSel[0] == TEXT('\r'))
                {
                    if(lpszStartSel[1] != TEXT('\0') && lpszStartSel[1] == TEXT('\n'))
                    {
                        ChatData.uval.cd_char.SelPos=MAKELONG(LOWORD(ChatData.uval.cd_char.SelPos),
                                                              HIWORD(ChatData.uval.cd_char.SelPos)+2);
                    }
                    else
                    {
                        ChatData.uval.cd_char.SelPos=MAKELONG(LOWORD(ChatData.uval.cd_char.SelPos)+1,
                                                              HIWORD(ChatData.uval.cd_char.SelPos)+1);
                    }
                }
                else
                {
                    ChatData.uval.cd_char.SelPos=MAKELONG(LOWORD(ChatData.uval.cd_char.SelPos)+1,
                                                          HIWORD(ChatData.uval.cd_char.SelPos)+1);
                }


                LocalUnlock( hText );
            }


            if (gfDbcsEnabled) {
                DWORD dwStart, dwEnd;

                TranslateWideCharPosToMultiBytePos( hwndSnd,
                    (DWORD)LOWORD(ChatData.uval.cd_dbcs.SelPos),
                    (DWORD)HIWORD(ChatData.uval.cd_dbcs.SelPos),
                     &dwStart, &dwEnd );
                ChatData.uval.cd_dbcs.SelPos
                    = MAKELONG((WORD)dwStart, (WORD)dwEnd);
            }

            ChatData.uval.cd_char.Char   = VK_BACK;

            wSet = SET_EN_NOTIFY_WPARAM(ID_EDITSND,EN_CHAR,hwnd);
            lSet = SET_EN_NOTIFY_LPARAM(ID_EDITSND,EN_CHAR,hwnd);

            SendMessage(hwndApp,WM_COMMAND,(WPARAM)wSet,(LPARAM)lSet);
        }
        break;
    case WM_CHAR:
        if(wParam != CTRL_V)
        {
            ChatData.type                = CHT_CHAR;
            SendMessage(hwndSnd,EM_GETSEL,(WPARAM)&dwTemp1,(LPARAM)&dwTemp2);
            ChatData.uval.cd_dbcs.SelPos = MAKELONG((WORD)dwTemp1, (WORD)dwTemp2 );

            if (gfDbcsEnabled) {
                DWORD dwStart, dwEnd;

                TranslateWideCharPosToMultiBytePos( hwndSnd,
                    (DWORD)LOWORD(ChatData.uval.cd_dbcs.SelPos),
                    (DWORD)HIWORD(ChatData.uval.cd_dbcs.SelPos),
                     &dwStart, &dwEnd );
                ChatData.uval.cd_dbcs.SelPos
                    = MAKELONG((WORD)dwStart, (WORD)dwEnd);
            }

            ChatData.uval.cd_char.Char   = (WORD)wParam;

            wSet = SET_EN_NOTIFY_WPARAM(ID_EDITSND,EN_CHAR,hwnd);
            lSet = SET_EN_NOTIFY_LPARAM(ID_EDITSND,EN_CHAR,hwnd);

            SendMessage(hwndApp,WM_COMMAND,wSet,lSet);
        }
        break;


    case WM_PASTE:
        ChatData.type                 = (WORD)(ChatState.fUnicode ? CHT_PASTEW : CHT_PASTEA);
        SendMessage(hwndSnd,EM_GETSEL,(WPARAM)&dwTemp1,(LPARAM)&dwTemp2);
        ChatData.uval.cd_paste.SelPos = MAKELONG(dwTemp1,dwTemp2);
        wSet = SET_EN_NOTIFY_WPARAM(ID_EDITSND,EN_PASTE,hwnd);
        lSet = SET_EN_NOTIFY_LPARAM(ID_EDITSND,EN_PASTE,hwnd);

        SendMessage(hwndApp,WM_COMMAND,wSet,lSet);
        break;
    }

    return(CallWindowProc(lpfnOldEditProc,hwnd,msg,wParam,lParam));
}


/*---------------------------------------------------------------------------*\
| APPLICATION CREATE PROCEDURE
|   This is the main event-handler for the WM_CREATE event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMCreateProc(HWND hwnd)
{
    HDC   hdc;
    TCHAR buf[16] = {0};
    RECT  rc;


    // read from ini
    //
    wsprintf(buf,TEXT("%ld"),GetSysColor(COLOR_WINDOW));
    GetPrivateProfileString(szPref,szBkgnd,buf,szBuf,SZBUFSIZ,szIni);
    SndBrushColor = myatol(szBuf);


    // just in case display driver changed, set the send-color.
    //
    hdc = GetDC (hwnd);
    if(hdc)
    {
        SndBrushColor = GetNearestColor(hdc,SndBrushColor);
        ReleaseDC(hwnd,hdc);
    }

    if(ChatState.fUseOwnFont)
    {
        RcvBrushColor = SndBrushColor;
        RcvColorref   = SndColorref;
    }
    else
        RcvBrushColor = GetSysColor ( COLOR_WINDOW );

    ChatState.fConnected          = FALSE;
    ChatState.fConnectPending     = FALSE;
    ChatState.fIsServer           = FALSE;
    ChatState.fServerVerified     = TRUE;
    ChatState.fInProcessOfDialing = FALSE;
    ChatState.fUnicode            = FALSE;

    CreateTools(hwnd);
    CreateChildWindows(hwnd);

    UpdateButtonStates();

    // determine height of toolbar window and save...
    //
    GetClientRect(hwndToolbar, &rc);
    dyButtonBar = rc.bottom - rc.top;

    // determine height of statusbar window and save...
    GetClientRect(hwndStatus, &rc);
    dyStatus = rc.bottom - rc.top;


    // stuff our local font into one or both edit controls
    //
    hEditSndFont = CreateFontIndirect((LPLOGFONT)&lfSnd);
    if(hEditSndFont)
    {
        SendMessage(hwndSnd,WM_SETFONT,(WPARAM)hEditSndFont,1L);
        if(ChatState.fUseOwnFont)
            SendMessage(hwndRcv,WM_SETFONT,(WPARAM)hEditSndFont,1L);
    }


    hwndActiveEdit = hwndSnd;

    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION WININICHANGE PROCEDURE
|   This is the main event-handler for the WM_WININICHANGE event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMWinIniChangeProc(HWND hwnd)
{

    if(hEditSndFont)
    {
        DeleteObject(hEditSndFont);
        hEditSndFont = CreateFontIndirect((LPLOGFONT)&lfSnd);
        if(hEditSndFont)
            SendMessage(hwndSnd,WM_SETFONT,(WPARAM)hEditSndFont,1L);
    }


    if(hEditRcvFont)
    {
        DeleteObject(hEditRcvFont);
        hEditRcvFont = CreateFontIndirect((LPLOGFONT)&lfRcv);
    }


    if(ChatState.fUseOwnFont && hEditSndFont)
        SendMessage(hwndRcv,WM_SETFONT,(WPARAM)hEditSndFont,1L);
    else
    {
        if(hEditRcvFont)
            SendMessage(hwndRcv,WM_SETFONT,(WPARAM)hEditRcvFont,1L);
    }


    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION ERASEBKGND PROCEDURE
|   This is the main event-handler for the WM_ERASEBKBND event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
BOOL appWMEraseBkGndProc(HWND hwnd)
{
    BOOL bErase;


    bErase = IsIconic(hwnd) ? TRUE : FALSE;

    return(bErase);
}


/*---------------------------------------------------------------------------*\
| APPLICATION SETFOCUS PROCEDURE
|   This is the main event-handler for the WM_SETFOCUS event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMSetFocusProc(HWND hwnd)
{
    SetFocus(hwndActiveEdit);

    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION CTLCOLOR PROCEDURE
|   This is the main event-handler for the WM_CTLCOLOR event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
HBRUSH appWMCtlColorProc(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    HDC    hDC;
    HWND   hWndCtl;
    HBRUSH hBrush;


    hBrush  = NULL;
    hDC     = GET_WM_CTLCOLOREDIT_HDC(wParam,lParam);
    hWndCtl = GET_WM_CTLCOLOREDIT_HWND(wParam,lParam);


    if(hWndCtl == hwndSnd)
    {
        SetTextColor(hDC,SndColorref);
        SetBkColor(hDC,SndBrushColor);

        hBrush = hEditSndBrush;
    }
    else
    if(hWndCtl == hwndRcv)
    {
        if(ChatState.fUseOwnFont)
        {
            SetTextColor(hDC,SndColorref);
            SetBkColor(hDC,SndBrushColor);
        }
        else
        {
            SetTextColor(hDC,RcvColorref);
            SetBkColor(hDC,RcvBrushColor);
        }

        hBrush = hEditRcvBrush;
    }

    return(hBrush);
}


/*---------------------------------------------------------------------------*\
| APPLICATION SELECTMENU PROCEDURE
|   This is the main event-handler for the WM_MENUSELECT event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMMenuSelectProc(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    if(wParam == IDM_TOPMOST)
    {
        if(LoadString(hInst,MH_BASE+IDM_TOPMOST,szBuf,SZBUFSIZ))
            SendMessage(hwndStatus,SB_SETTEXT,SBT_NOBORDERS|255,(LPARAM)(LPSTR)szBuf);
    }

    MenuHelp((WORD)WM_MENUSELECT,wParam,lParam,GetMenu(hwnd),hInst,hwndStatus,(LPUINT)nIDs);

    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION PAINT PROCEDURE
|   This is the main event-handler for the WM_PAINT event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMPaintProc(HWND hwnd)
{
    HDC         hdc;
        PAINTSTRUCT ps;
    RECT        rc;

    hdc = BeginPaint(hwnd,&ps);
    if(hdc)
    {
        if(IsIconic(hwnd))
        {
            //
            //
            DefWindowProc(hwnd,WM_ICONERASEBKGND,(WPARAM)ps.hdc,0L);
            BitBlt(hMemDC,0,0,cxIcon,cyIcon,hdc,0,0,SRCCOPY);
            DrawIcon(hdc,0,0,hPhones[0]);


            // make 2 more copies.
            //
            BitBlt(hMemDC,cxIcon  ,0,cxIcon,cyIcon,hMemDC,0,0,SRCCOPY);
            BitBlt(hMemDC,2*cxIcon,0,cxIcon,cyIcon,hMemDC,0,0,SRCCOPY);

            // draw phones into them.
            //
            DrawIcon(hMemDC,0       ,0,hPhones[0]);
            DrawIcon(hMemDC,cxIcon  ,0,hPhones[1]);
            DrawIcon(hMemDC,2*cxIcon,0,hPhones[2]);
        }
        else
        {

#if BRD > 2
            rc = SndRc;
            rc.top--;
            rc.left--;
            DrawShadowRect(hdc,&rc);
            rc = RcvRc;
            rc.top--;
            rc.left--;
            DrawShadowRect(hdc,&rc);
#endif
        }

        EndPaint ( hwnd, &ps );
    }

    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION TIMER PROCEDURE
|   This is the main event-handler for the WM_TIMER event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMTimerProc(HWND hwnd)
{
    HDC   hdc;
    DWORD dummy;


    // Animate the phone icon.
    //
    if(cAnimate)
    {
        if(--cAnimate == 0)
        {
            KillTimer(hwnd,idTimer);
            FlashWindow(hwnd,FALSE);
                }

        if(IsIconic(hwnd))
        {
            hdc = GetDC(hwndApp);
            if(hdc)
            {
                BitBlt(hdc,0,0,cxIcon,cyIcon,hMemDC,ASeq[cAnimate % 4] * cxIcon,0,SRCCOPY);
                ReleaseDC(hwndApp,hdc);
            }
        }

                return;
        }



    // We must be ringing...
    //
    if(!ChatState.fConnectPending)
    {
        KillTimer(hwnd,idTimer);
                return;
        }


    // has the existence of the server been verified (by completion
    // of the async advstart xact)?
    //
    if(!ChatState.fServerVerified)
    {
                return;
        }


    // don't want to lose this...
    //
    DdeKeepStringHandle(idInst,hszLocalName);

    if(DdeClientTransaction(NULL,0L,ghConv,hszLocalName,cf_chatdata,XTYP_ADVSTART,(DWORD)3000L,(LPDWORD)&dummy) == (HDDEDATA)TRUE)
    {
        ChatState.fConnected      = TRUE;
        ChatState.fConnectPending = FALSE;
        UpdateButtonStates();

        KILLSOUND;

        SendFontToPartner();

        wsprintf(szBuf,szConnectedTo,(LPSTR)szConvPartner);
        SetStatusWindowText(szBuf);

        wsprintf(szBuf,TEXT("%s - [%s]"),(LPTSTR)szAppName,(LPTSTR)szConvPartner);
        SetWindowText(hwnd,szBuf);


        // allow text entry...
        //
        SendMessage(hwndSnd,EM_SETREADONLY,(WPARAM)FALSE,0L);

        KillTimer(hwnd,idTimer);

        AnnounceSupport();
    }
    else
    {
        // The other party has not answered yet... ring every 6 seconds.
        // Ring local,
        //
        if(!(nConnectAttempt++ % 6))
            DoRing(szWcRingOut);
    }

    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION QUERYDRAGICON PROCEDURE
|   This is the main event-handler for the WM_QUERYDRAGICON event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
HICON appWMQueryDragIconProc(HWND hwnd)
{
    HICON hIcon;


    hIcon = hPhones[0];

    return(hIcon);
}


/*---------------------------------------------------------------------------*\
| APPLICATION SIZE PROCEDURE
|   This is the main event-handler for the WM_SIZE event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMSizeProc(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    if(ChatState.fMinimized && ChatState.fConnectPending && ChatState.fIsServer)
    {
        ChatState.fAllowAnswer = TRUE;
        SetStatusWindowText(szConnecting);


        // stop the ringing immediately.
        //
        KILLSOUND;
        if(ChatState.fMMSound)
            sndPlaySound(NULL,SND_ASYNC);

        // cut the animation short.
        //
        if(cAnimate)
            cAnimate = 1;
    }


    //
    //
    InvalidateRect(hwnd,NULL,TRUE);
    SendMessage(hwndToolbar,WM_SIZE,0,0L);
    SendMessage(hwndStatus ,WM_SIZE,0,0L);
    AdjustEditWindows();

    ChatState.fMinimized = (wParam == SIZE_MINIMIZED) ? TRUE : FALSE;

    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION INITMENU PROCEDURE
|   This is the main event-handler for the WM_INITMENU event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMInitMenuProc(HMENU hmenu)
{
    UINT status;
    LONG l;
    TCHAR szTest[] = TEXT(" ");
    DWORD dwTemp1,dwTemp2;

    SendMessage(hwndActiveEdit,EM_GETSEL,(LPARAM)&dwTemp1,(WPARAM)&dwTemp2);
    l = MAKELONG(dwTemp1,dwTemp2);

    if(HIWORD(l) != LOWORD(l))
                status = MF_ENABLED;
        else
                status = MF_GRAYED;

    EnableMenuItem(hmenu,IDM_EDITCUT ,(hwndActiveEdit == hwndSnd && ChatState.fConnected) ? status : MF_GRAYED);
    EnableMenuItem(hmenu,IDM_EDITCOPY,status);

    status = MF_GRAYED;
    if(hwndActiveEdit == hwndSnd && ChatState.fConnected && IsClipboardFormatAvailable(CF_TEXT))
    {
        status = MF_ENABLED;
        }
    EnableMenuItem(hmenu,IDM_EDITPASTE,status);


    // select all enabled if control non-empty.
    //
    status = MF_GRAYED;
    if(SendMessage(hwndActiveEdit,WM_GETTEXT,2,(LPARAM)szTest))
                status = MF_ENABLED;
    EnableMenuItem(hmenu,IDM_EDITSELECT,status);


    // can we dial, answer and hangup.
    //
    EnableMenuItem(hmenu,IDM_DIAL  ,(!ChatState.fConnected     && !ChatState.fConnectPending) ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hmenu,IDM_ANSWER,(ChatState.fConnectPending && ChatState.fIsServer)        ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hmenu,IDM_HANGUP,(ChatState.fConnected      || ChatState.fConnectPending)  ? MF_ENABLED : MF_GRAYED);


    // Is toolbar, statusbar and sound allowed?
    //
    CheckMenuItem(hmenu,IDM_SOUND    ,(ChatState.fSound)     ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmenu,IDM_TOOLBAR  ,(ChatState.fToolBar)   ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmenu,IDM_STATUSBAR,(ChatState.fStatusBar) ? MF_CHECKED : MF_UNCHECKED);

    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION SYSCOMMAND PROCEDURE
|   This is the main event-handler for the WM_SYSCOMMAND event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
LRESULT appWMSysCommandProc(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    HMENU   hmenu;


    lResult = 0l;
    switch(wParam)
    {
        case IDM_TOPMOST:
            ChatState.fTopMost = ChatState.fTopMost ? FALSE : TRUE;

            hmenu = GetSystemMenu(hwnd,FALSE);
            if(hmenu)
                CheckMenuItem(hmenu,IDM_TOPMOST,(ChatState.fTopMost) ? MF_CHECKED : MF_UNCHECKED);

            SetWindowPos(hwnd,ChatState.fTopMost ? HWND_TOPMOST : HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
            break;
    }

    return(lResult);
}


/*---------------------------------------------------------------------------*\
| APPLICATION COMMAND PROCEDURE
|   This is the main event-handler for the WM_COMMAND event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
BOOL appWMCommandProc(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    HDC      hdc;
    int      tmp;
    UINT     uNotify;
    DWORD    dummy;
    DWORD    dwBufSize;
    HDDEDATA hDdeData;
    BOOL     bHandled,bOK,bOKPressed=FALSE;
    WPARAM   wSelStart;
    LPARAM   lSelEnd;


    bHandled = TRUE;
    switch(LOWORD(wParam))
    {
                case ID_EDITRCV:
            uNotify = GET_EN_SETFOCUS_NOTIFY(wParam,lParam);
            switch(uNotify)
            {
                case EN_SETFOCUS:
                    hwndActiveEdit = hwndRcv;
                    break;


                // If the control is out of space, honk.
                //
                case EN_ERRSPACE:
                    MessageBeep(0);
                    break;
                        }
            break;


                case ID_EDITSND:
            uNotify = GET_EN_SETFOCUS_NOTIFY(wParam,lParam);
            switch(uNotify)
            {
                // This string came from the edit-hook
                // procedure.
                //
                case EN_DBCS_STRING:
                    if(ChatState.fConnected)
                    {
                        if(!ChatState.fIsServer)
                        {
                            hDdeData = CreateDbcsStringData();
                            if(hDdeData)
                                DdeClientTransaction((LPBYTE)hDdeData,(DWORD)-1,ghConv,hszTextItem,cf_chatdata,XTYP_POKE,(DWORD)TIMEOUT_ASYNC,(LPDWORD)&dummy);
                        }
                        else
                        {
                            hszConvPartner = DdeCreateStringHandle(idInst,szConvPartner,0);
                            DdePostAdvise(idInst,hszChatTopic,hszConvPartner);
                        }
                    }
                    break;


                // This character came from the edit-hook
                // procedure.
                //
                case EN_CHAR:
                    if(ChatState.fConnected)
                    {
                        if(!ChatState.fIsServer)
                        {
                            hDdeData = CreateCharData();
                            if(hDdeData)
                                DdeClientTransaction((LPBYTE)hDdeData,(DWORD)-1,ghConv,hszTextItem,cf_chatdata,XTYP_POKE,(DWORD)TIMEOUT_ASYNC,(LPDWORD)&dummy);
                        }
                        else
                        {
                            hszConvPartner = DdeCreateStringHandle(idInst,szConvPartner,0);
                            DdePostAdvise(idInst,hszChatTopic,hszConvPartner);
                        }
                    }
                    break;

                case EN_PASTE:
                    if(ChatState.fConnected)
                    {
                        if(!ChatState.fIsServer)
                        {
                            if(IsClipboardFormatAvailable(CF_UNICODETEXT))
                            {
                                hDdeData = CreatePasteData();
                                if(hDdeData)
                                    DdeClientTransaction((LPBYTE)hDdeData,(DWORD)-1,ghConv,hszTextItem,cf_chatdata,XTYP_POKE,(DWORD)TIMEOUT_ASYNC,(LPDWORD)&StrXactID);
                            }
                        }
                        else
                        {
                             hszConvPartner = DdeCreateStringHandle(idInst,szConvPartner,0);
                             DdePostAdvise(idInst,hszChatTopic,hszConvPartner);
                        }
                    }
                    break;

                case EN_SETFOCUS:
                    hwndActiveEdit = hwndSnd;
                    break;

                case EN_ERRSPACE:
                    // If the control is out of space, honk.
                    //
                    MessageBeep(0);
                    break;
                    }
                    break;


        case IDC_TOOLBAR:
            MenuHelp(WM_COMMAND,wParam,lParam,GetMenu(hwnd),hInst,hwndStatus,(LPUINT)nIDs);
            break;


        case IDM_EXIT:
            SendMessage(hwnd,WM_CLOSE,0,0L);
            break;


        case IDM_TOOLBAR:
            if(ChatState.fToolBar)
            {
                ChatState.fToolBar = FALSE;
                ShowWindow(hwndToolbar,SW_HIDE);
                InvalidateRect(hwnd,NULL,TRUE);
                AdjustEditWindows();
            }
            else
            {
                ChatState.fToolBar = TRUE;
                InvalidateRect(hwnd,NULL,TRUE);
                AdjustEditWindows();
                ShowWindow(hwndToolbar,SW_SHOW);
            }
            break;


        case IDM_STATUSBAR:
            if(ChatState.fStatusBar)
            {
                ChatState.fStatusBar = FALSE;
                ShowWindow(hwndStatus,SW_HIDE);
                InvalidateRect(hwnd,NULL,TRUE);
                AdjustEditWindows();
            }
            else
            {
                ChatState.fStatusBar = TRUE;
                InvalidateRect(hwnd,NULL,TRUE);
                AdjustEditWindows();
                ShowWindow(hwndStatus,SW_SHOW);
            }
            break;


        case IDM_SWITCHWIN:
            if(hwndActiveEdit == hwndSnd)
                SetFocus(hwndActiveEdit = hwndRcv);
            else
                SetFocus(hwndActiveEdit = hwndSnd);
            break;


        case IDM_SOUND:
            ChatState.fSound = ChatState.fSound ? FALSE : TRUE;
            break;


        case IDM_COLOR:
            SetFocus(hwndActiveEdit);
            chc.rgbResult = SndBrushColor;

            tmp = ChooseColor((LPCHOOSECOLOR)&chc);
            if(tmp)
            {
                hdc = GetDC(hwnd);
                if(hdc)
                {
                    // must map to solid color (edit-control limitation).
                    //
                    SndBrushColor = GetNearestColor(hdc,chc.rgbResult);
                    ReleaseDC(hwnd,hdc);
                }

                DeleteObject(hEditSndBrush);
                hEditSndBrush = CreateSolidBrush(SndBrushColor);
                InvalidateRect(hwndSnd,NULL,TRUE);

                SaveBkGndToIni();

                if(ChatState.fUseOwnFont)
                {
                    RcvBrushColor = SndBrushColor;
                    DeleteObject(hEditRcvBrush);
                    hEditRcvBrush = CreateSolidBrush(RcvBrushColor);
                    InvalidateRect(hwndRcv, NULL, TRUE);
                }

                if(ChatState.fConnected)
                    SendFontToPartner();
            }
            break;


        case IDM_FONT:
            SetFocus(hwndActiveEdit);
            chf.hwndOwner = hwndSnd;
            chf.rgbColors = SndColorref;

            tmp = ChooseFont((LPCHOOSEFONT)&chf);
            if(tmp)
            {
                if(hEditSndFont)
                    DeleteObject(hEditSndFont);

                hEditSndFont = CreateFontIndirect((LPLOGFONT)&lfSnd);
                if(hEditSndFont)
                {
                    SndColorref = chf.rgbColors;
                    SaveFontToIni();

                    SendMessage(hwndSnd,WM_SETFONT,(WPARAM)hEditSndFont,1L);
                    if(ChatState.fUseOwnFont)
                    {
                        SendMessage(hwndRcv,WM_SETFONT,(WPARAM)hEditSndFont,1L);
                        RcvColorref = SndColorref;
                    }


                    // notify partner of the change
                    //
                    if(ChatState.fConnected)
                        SendFontToPartner();
                }
            }
            break;


        case IDM_DIAL:
            if(ChatState.fConnected)
            {
                SetStatusWindowText(szAlreadyConnect);
                break;
            }

            if(ChatState.fConnectPending)
            {
                SetStatusWindowText ( szAbandonFirst);
                break;
            }

            dwBufSize = SZBUFSIZ;

            WNETGETUSER((LPTSTR)NULL,(LPTSTR)szBuf,&dwBufSize);

            if(GetLastError() == ERROR_NO_NETWORK)
            {
                if(MessageBox(hwnd,szNoNet,TEXT("Chat"),MB_YESNO | MB_ICONQUESTION) == IDNO)
                    break;
            }


            ChatState.fInProcessOfDialing = TRUE;
            if(WNetServerBrowseDialog == NULL || (*WNetServerBrowseDialog)(hwnd,TEXT("MRU_Chat"),szBuf,SZBUFSIZ,0L) == WN_NOT_SUPPORTED)
            {
#if WIN32
                bOKPressed = FALSE;
                *szBuf     = TEXT('\0');


                lstrcpy(szHelp, TEXT("winchat.hlp"));
                I_SystemFocusDialog(hwnd,MY_LOGONTYPE,(LPWSTR)szBuf,SZBUFSIZ,&bOKPressed,(LPWSTR)szHelp,IDH_SELECTCOMPUTER);

                if(bOKPressed)
                {
                    bOK    = TRUE;
                    lstrcpy(szConvPartner,szBuf);
                }
#else
                dlgDisplayBox(hInst,hwnd,(LPSTR)MAKEINTRESOURCE(IDD_CONNECT),dlgConnectProc,0l);
#endif
            }

            SetFocus(hwndActiveEdit);

            if(*szBuf && bOKPressed)
            {
                CharUpper(szBuf);

                if((lstrlen(szBuf) > 2)  && (szBuf[0] == TEXT('\\')) && (szBuf[1] == TEXT('\\')))
                    lstrcpy(szConvPartner,szBuf+2);
                else
                    lstrcpy(szConvPartner,szBuf);

                ClearEditControls();

                wsprintf(szBuf,szDialing,(LPSTR)szConvPartner);
                SetStatusWindowText(szBuf);

#if TESTLOCAL
                wsprintf(szBuf,TEXT("%s"),(LPTSTR)szServiceName);
                hszConnect = DdeCreateStringHandle(idInst,szBuf,0);
                ghConv     = DdeConnect(idInst,hszConnect,hszChatTopic,NULL);
#else
                wsprintf(szBuf,TEXT("\\\\%s\\NDDE$"),(LPTSTR)szConvPartner);
                hszConnect = DdeCreateStringHandle(idInst,szBuf,0);
                ghConv     = DdeConnect(idInst,hszConnect,hszChatShare,NULL);
#endif

                if(ghConv == (HCONV)0)
                {
                    SetStatusWindowText(szNoConnect);
                    DdeFreeStringHandle(idInst,hszConnect);
                    ChatState.fInProcessOfDialing = FALSE;
                    break;
                }

                ChatState.fConnectPending = TRUE;
                UpdateButtonStates();

                // set up server verify async xaction.
                //
                ChatState.fServerVerified = FALSE;
                DdeKeepStringHandle(idInst,hszConnectTest);
                DdeClientTransaction(NULL,0L,ghConv,hszConnectTest,cf_chatdata,XTYP_ADVSTART,(DWORD)TIMEOUT_ASYNC,(LPDWORD)&XactID);


                // Indicate that this is a Unicode conversation.
                //
                ChatData.type = CHT_UNICODE;
                hDdeData = CreateCharData ();
                if(hDdeData)
                   DdeClientTransaction((LPBYTE)hDdeData,(DWORD)-1,ghConv,hszTextItem,cf_chatdata,XTYP_POKE,(DWORD)TIMEOUT_ASYNC,(LPDWORD)&dummy);


                // set ring timer...
                // connect attempts every second - will be divided by
                // 6 for actual phone rings. This is done to speed the
                // connection process
                // want first message immediately...
                //
                idTimer = SetTimer(hwnd,1,1000,NULL);
                PostMessage(hwnd,WM_TIMER,1,0L);
                nConnectAttempt = 0;
            }

            ChatState.fInProcessOfDialing = FALSE;
            DdeFreeStringHandle(idInst,hszConnect);
            break;


        case IDM_ANSWER:
            if(ChatState.fConnectPending)
            {
                if(!ChatState.fIsServer)
                {
                    SetStatusWindowText(szYouCaller);
                    break;
                }
                else
                {
                    // allow the connection.
                    //
                    ChatState.fAllowAnswer = TRUE;
                    SetStatusWindowText(szConnecting);


                    // stop the ringing immediately.
                    //
                    if(ChatState.fMMSound)
                        sndPlaySound(NULL,SND_ASYNC);


                    // cut the animation short.
                    //
                    if(cAnimate)
                        cAnimate = 1;
                }
            }
            break;


                case IDM_HANGUP:
            if(!ChatState.fConnected && !ChatState.fConnectPending)
            {
                                break;
                        }


            if(ChatState.fConnectPending && !ChatState.fConnected)
            {
                SetStatusWindowText(szConnectAbandon);
            }
            else
            {
                SetStatusWindowText(szHangingUp);
            }


                        KILLSOUND;

            DdeDisconnect(ghConv);

                        ChatState.fConnectPending = FALSE;
            ChatState.fConnected      = FALSE;
            ChatState.fIsServer       = FALSE;
            ChatState.fUnicode        = FALSE;

#ifdef PROTOCOL_NEGOTIATE
            ChatState.fProtocolSent   = FALSE;
#endif

            // suspend text entry.
            //
            UpdateButtonStates();
            SendMessage(hwndSnd,EM_SETREADONLY,TRUE,0L);
            SetWindowText(hwndApp,szAppName);
            break;


       case IDX_UNICODECONV:
            ChatData.type  = CHT_UNICODE;
            hszConvPartner = DdeCreateStringHandle(idInst,szConvPartner,0);
            DdePostAdvise(idInst,hszChatTopic,hszConvPartner);
            break;


                case IDX_DEFERFONTCHANGE:
                        SendFontToPartner();
            break;

#ifdef PROTOCOL_NEGOTIATE
        case IDX_DEFERPROTOCOL:
            AnnounceSupport();
            break;
#endif

        case IDM_CONTENTS:
            HtmlHelpA(GetDesktopWindow(),"winchat.chm",HH_DISPLAY_TOPIC,0L);
            break;


        case IDM_ABOUT:
            ShellAbout(hwndSnd,szAppName,szNull,hPhones[0]);
                        SetFocus(hwndActiveEdit);
            break;


        case IDM_PREFERENCES:
            DialogBoxParam(hInst,(LPTSTR)MAKEINTRESOURCE(IDD_PREFERENCES),hwnd,dlgPreferencesProc,(LPARAM)0);
            break;


        case IDM_EDITCOPY:
            SendMessage(hwndActiveEdit,WM_COPY,0,0L);
            break;


        case IDM_EDITPASTE:
            SendMessage(hwndActiveEdit,WM_PASTE,0,0L);
            break;


        case IDM_EDITCUT:
            SendMessage(hwndActiveEdit,WM_CUT,0,0L);
            break;


        case IDM_EDITSELECT:
            wSelStart = SET_EM_SETSEL_WPARAM(0,-1);
            lSelEnd   = SET_EM_SETSEL_LPARAM(0,-1);
            SendMessage(hwndActiveEdit,EM_SETSEL,wSelStart,lSelEnd);
            break;


        case IDM_EDITUNDO:
            SendMessage(hwndActiveEdit,EM_UNDO,0,0L);
            break;


        default:
            bHandled = FALSE;
            break;
    }

    return(bHandled);
}


/*---------------------------------------------------------------------------*\
| APPLICATION DESTROY PROCEDURE
|   This is the main event-handler for the WM_DESTROY event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMDestroyProc(HWND hwnd)
{

    // Abandon transaction if in progress.  Force hangup
    // of conversation.
    //
    if(!ChatState.fServerVerified)
        DdeAbandonTransaction(idInst,ghConv,XactID);
    SendMessage(hwnd,WM_COMMAND,IDM_HANGUP,0L);


    // Destroy resources allocated on behalf of app.
    //
    KILLSOUND;
    DeleteTools(hwnd);


    // Save the state information.
    //
    Wpl.length = sizeof(Wpl);
    if(GetWindowPlacement(hwnd,&Wpl))
        SaveWindowPlacement(&Wpl);

    wsprintf(szBuf, TEXT("%d"), (UINT)ChatState.fSound);
    WritePrivateProfileString(szPref, szSnd, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), (UINT)ChatState.fToolBar);
    WritePrivateProfileString(szPref, szTool, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), (UINT)ChatState.fStatusBar);
    WritePrivateProfileString(szPref, szStat, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), (UINT)ChatState.fTopMost);
    WritePrivateProfileString(szPref, szTop, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), (UINT)ChatState.fSideBySide);
    WritePrivateProfileString(szPref, szSbS, szBuf, szIni);

    wsprintf(szBuf, TEXT("%d"), (UINT)ChatState.fUseOwnFont);
    WritePrivateProfileString(szPref, szUseOF, szBuf, szIni);

    PostQuitMessage(0);

    return;
}


/*---------------------------------------------------------------------------*\
| ASCII TO LONG
|   This routine converts an ascii string to long.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
LONG FAR myatol(LPTSTR s)
{
        LONG ret = 0L;


    while(*s) ret = ret * 10 + (*s++ - TEXT('0'));

    return(ret);
}

/*---------------------------------------------------------------------------*\
| UPDATE BUTTON STATES
|   This routine updates the menu/toolbar buttons.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR UpdateButtonStates(VOID)
{
    BOOL DialState   = FALSE;
        BOOL AnswerState = FALSE;
        BOOL HangUpState = FALSE;


    if(ChatState.fConnected)
                HangUpState = TRUE;
    else
    if(ChatState.fConnectPending)
    {
        if(!ChatState.fIsServer)
                        HangUpState = TRUE;
                else
                        AnswerState = TRUE;
        }
        else
                DialState = TRUE;

    SendMessage(hwndToolbar,TB_ENABLEBUTTON,IDM_DIAL  ,DialState);
    SendMessage(hwndToolbar,TB_ENABLEBUTTON,IDM_ANSWER,AnswerState);
    SendMessage(hwndToolbar,TB_ENABLEBUTTON,IDM_HANGUP,HangUpState);

    return;
}


/*---------------------------------------------------------------------------*\
| GET COMPUTER NAME
|   This routine returns the computer name of the machine.
|
| created: 31-Dec-92
| history: 31-Dec-92 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
BOOL FAR appGetComputerName(LPTSTR lpszName)
{
    BOOL  bGet;
    DWORD dwSize;


#ifdef WIN32

    dwSize = MAX_COMPUTERNAME_LENGTH+1;
    bGet   = GetComputerName(lpszName,&dwSize);

#else

    bGet   = TRUE;
    dwSize = 0l;
    if(GetPrivateProfileString(szVredir,szComputerName,szNull,lpszName,UNCNLEN,szSysIni))
        OemToAnsi(lpszName,lpszName);

#endif

    return(bGet);
}


/*---------------------------------------------------------------------------*\
| ADJUST EDIT WINDOWS
|   This routine sizes the edit-controls.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR AdjustEditWindows(VOID)
{
    int  tmpsplit;
        RECT rc;


    GetClientRect(hwndApp,&rc);

    rc.top    += ChatState.fToolBar   ? dyButtonBar + BRD : BRD;
    rc.bottom -= ChatState.fStatusBar ? dyStatus    + BRD : BRD;

    if(!ChatState.fSideBySide)
    {
        tmpsplit = rc.top + (rc.bottom - rc.top) / 2;

        SndRc.left   = RcvRc.left  = rc.left  - 1 + BRD;
        SndRc.right  = RcvRc.right = rc.right + 1 - BRD;
        SndRc.top    = rc.top;
                SndRc.bottom = tmpsplit;
        RcvRc.top    = tmpsplit + BRD;
                RcvRc.bottom = rc.bottom;
        }
    else
    {
        tmpsplit = rc.left + (rc.right - rc.left) / 2;

        SndRc.left   = rc.left  - 1   + BRD;
        SndRc.right  = tmpsplit - BRD / 2;
        RcvRc.left   = tmpsplit + BRD / 2;
        RcvRc.right  = rc.right + 1 - BRD;
        SndRc.top    = RcvRc.top    = rc.top;
        SndRc.bottom = RcvRc.bottom = rc.bottom;

    }

    MoveWindow(hwndSnd,SndRc.left,SndRc.top,SndRc.right-SndRc.left,SndRc.bottom-SndRc.top,TRUE);
    MoveWindow(hwndRcv,RcvRc.left,RcvRc.top,RcvRc.right-RcvRc.left,RcvRc.bottom-RcvRc.top,TRUE);

    return;
}


/*---------------------------------------------------------------------------*\
| CLEAR EDIT CONTROLS
|   This routine clears the send/receive edit controls.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID ClearEditControls(VOID)
{
    SendMessage(hwndSnd,EM_SETREADONLY,FALSE,0L);
    SendMessage(hwndSnd,WM_SETTEXT    ,0    ,(LPARAM)(LPSTR)szNull);
    SendMessage(hwndSnd,EM_SETREADONLY,TRUE ,0L);

    SendMessage(hwndRcv,EM_SETREADONLY,FALSE,0L);
    SendMessage(hwndRcv,WM_SETTEXT    ,0    ,(LPARAM)(LPSTR)szNull);
    SendMessage(hwndRcv,EM_SETREADONLY,TRUE ,0L);

    return;
}


/*---------------------------------------------------------------------------*\
| DO RING
|   This routine performs the phone ringing.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID DoRing(LPCTSTR sound)
{
    if(ChatState.fSound)
    {
        if(ChatState.fMMSound)
            sndPlaySound(sound,SND_ASYNC);
        else
            MessageBeep(0);
    }

    return;
}


/*---------------------------------------------------------------------------*\
| DRAW SHADOW RECT
|   This routine draws a shadow outline.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID DrawShadowRect(HDC hdc, LPRECT rc)
{
    HPEN hSavePen = SelectObject(hdc,hShadowPen);


    MoveToEx(hdc,rc->left,rc->bottom,NULL);
    LineTo(hdc,rc->left,rc->top );
    LineTo(hdc,rc->right,rc->top );
    SelectObject(hdc,hHilitePen);
    LineTo(hdc,rc->right,rc->bottom);
    LineTo(hdc,rc->left-1,rc->bottom);
    SelectObject(hdc,hSavePen);

    return;
}

#ifdef PROTOCOL_NEGOTIATE
/*---------------------------------------------------------------------------*\
| ANNOUNCE SUPPORT
|   This routine announces to the partner what we support.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID AnnounceSupport(VOID)
{
    HDDEDATA hDdeData;
    DWORD    dummy;


    if(ChatState.fConnected)
    {
        ChatData.type = CHT_PROTOCOL;

        if(!ChatState.fIsServer)
        {
            hDdeData = CreateProtocolData();
            if(hDdeData)
                DdeClientTransaction((LPBYTE)hDdeData,(DWORD)-1L,ghConv,hszTextItem,cf_chatdata,XTYP_POKE,(DWORD)TIMEOUT_ASYNC,(LPDWORD)&dummy);
        }
        else
        {
            hszConvPartner = DdeCreateStringHandle(idInst,szConvPartner,0);
            if(hszConvPartner)
                DdePostAdvise(idInst,hszChatTopic,hszConvPartner);
        }

        ChatState.fProtocolSent = TRUE;
    }

    return;
}
#endif


/*---------------------------------------------------------------------------*\
| START INI-FILE MAPPING
|   This routines sets the private-profile settings to go to the registry on\
|   a per-user basis.
|
|
\*---------------------------------------------------------------------------*/
VOID StartIniMapping(VOID)
{
    HKEY  hKey1,hKey2,hKey3,hKeySnd;
    DWORD dwDisp,dwSize;


    if(RegCreateKeyEx(HKEY_LOCAL_MACHINE,szIniSection,0,NULL,REG_OPTION_NON_VOLATILE,KEY_WRITE,NULL,&hKey1,&dwDisp) == ERROR_SUCCESS)
    {
        if(dwDisp == REG_CREATED_NEW_KEY)
        {
            RegSetValueEx(hKey1,TEXT("Preferences"),0,REG_SZ,(LPBYTE)szIniKey1,ByteCountOf(lstrlen(szIniKey1)+1));
            RegSetValueEx(hKey1,TEXT("Font")       ,0,REG_SZ,(LPBYTE)szIniKey2,ByteCountOf(lstrlen(szIniKey2)+1));
        }

        if(RegCreateKeyEx(HKEY_CURRENT_USER,TEXT("Software\\Microsoft\\Winchat"),0,NULL,REG_OPTION_NON_VOLATILE,KEY_WRITE,NULL,&hKey1,&dwDisp) == ERROR_SUCCESS)
        {
            if(dwDisp == REG_CREATED_NEW_KEY)
            {
                RegCreateKeyEx(HKEY_CURRENT_USER,TEXT("Software\\Microsoft\\Winchat\\Preferences"),0,NULL,REG_OPTION_NON_VOLATILE,KEY_WRITE,NULL,&hKey2,&dwDisp);
                RegCreateKeyEx(HKEY_CURRENT_USER,TEXT("Software\\Microsoft\\Winchat\\Font")       ,0,NULL,REG_OPTION_NON_VOLATILE,KEY_WRITE,NULL,&hKey3,&dwDisp);

                RegCloseKey(hKey2);
                RegCloseKey(hKey3);
            }
        }

        RegCloseKey(hKey1);
    }


    // The sndPlaySound() first looks in the registry for the wav-files.  The
    // NT version doesn't have these here at setup, so Winchat will write out
    // the defaults when the strings don't exist.  This will allow uses to change
    // sounds for ringing-in and ringing-out.
    //
    if(RegOpenKeyEx(HKEY_CURRENT_USER,TEXT("Control Panel\\Sounds"),0,KEY_WRITE | KEY_QUERY_VALUE,&hKeySnd) == ERROR_SUCCESS)
    {
        dwSize = 0;
        dwDisp = REG_SZ;
        if(RegQueryValueEx(hKeySnd,TEXT("RingIn"),NULL,&dwDisp,NULL,&dwSize) != ERROR_SUCCESS)
        {
            if(dwSize == 0)
            {
                // Set the wav-file values.  Add (1) extra count to account for the null
                // terminator.
                //
                RegSetValueEx(hKeySnd,TEXT("RingIn") ,0,REG_SZ,(LPBYTE)szIniRingIn ,ByteCountOf(lstrlen(szIniRingIn)+1));
                RegSetValueEx(hKeySnd,TEXT("RingOut"),0,REG_SZ,(LPBYTE)szIniRingOut,ByteCountOf(lstrlen(szIniRingOut)+1));
            }
        }

        RegCloseKey(hKeySnd);
    }

    return;
}



/*---------------------------------------------------------------------------*\
| END INI-FILE MAPPING
|   This routines ends the ini-file mapping.  It doesn't do anything at this
|   point, but I've kept it in for some reason.
|
|
\*---------------------------------------------------------------------------*/
VOID EndIniMapping(VOID)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\afxcmn2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCMN2.H

#ifdef _AFXCMN2_INLINE

_AFXCMN2_INLINE CRichEdit2Ctrl::CRichEdit2Ctrl()
	{ }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::CanUndo() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0); }
_AFXCMN2_INLINE int CRichEdit2Ctrl::GetLineCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0); }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::GetModify() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::SetModify(BOOL bModified /* = TRUE */)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0);}
_AFXCMN2_INLINE void CRichEdit2Ctrl::GetRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect); }
_AFXCMN2_INLINE CPoint CRichEdit2Ctrl::GetCharPos(long lChar) const
	{ ASSERT(::IsWindow(m_hWnd)); CPoint pt; ::SendMessage(m_hWnd, EM_POSFROMCHAR, (WPARAM)&pt, (LPARAM)lChar); return pt;}
_AFXCMN2_INLINE void CRichEdit2Ctrl::SetOptions(WORD wOp, DWORD dwFlags)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETOPTIONS, (WPARAM)wOp, (LPARAM)dwFlags); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::EmptyUndoBuffer()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo)
	{ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::SetRect(LPCRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect); }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::Undo()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::Clear()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CLEAR, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::Copy()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_COPY, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::Cut()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CUT, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::Paste()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PASTE, 0, 0); }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::SetReadOnly(BOOL bReadOnly /* = TRUE */ )
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L); }
_AFXCMN2_INLINE int CRichEdit2Ctrl::GetFirstVisibleLine() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L); }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::DisplayBand(LPRECT pDisplayRect)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_DISPLAYBAND, 0, (LPARAM)pDisplayRect); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::GetSel(CHARRANGE &cr) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr); }

_AFXCMN2_INLINE void CRichEdit2Ctrl::LimitText(long nChars)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXLIMITTEXT, 0, nChars); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::LineFromChar(long nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_EXLINEFROMCHAR, 0, nIndex); }

_AFXCMN2_INLINE void CRichEdit2Ctrl::SetSel(CHARRANGE &cr)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr); }

#ifndef _CHICAGO_
_AFXCMN2_INLINE long CRichEdit2Ctrl::FindText(DWORD dwFlags, FINDTEXTEX* pFindText) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_FINDTEXTEX, dwFlags, (LPARAM)pFindText); }
#endif // !_CHICAGO_

_AFXCMN2_INLINE long CRichEdit2Ctrl::FormatRange(FORMATRANGE* pfr, BOOL bDisplay)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_FORMATRANGE, (WPARAM)bDisplay, (LPARAM)pfr); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::GetEventMask() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETEVENTMASK, 0, 0L); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::GetLimitText() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0L); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::GetSelText(LPSTR lpBuf) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpBuf); }

_AFXCMN2_INLINE void CRichEdit2Ctrl::HideSelection(BOOL bHide, BOOL bPerm)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_HIDESELECTION, bHide, bPerm); }

_AFXCMN2_INLINE void CRichEdit2Ctrl::RequestResize()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REQUESTRESIZE, 0, 0L); }

_AFXCMN2_INLINE WORD CRichEdit2Ctrl::GetSelectionType() const
	{ ASSERT(::IsWindow(m_hWnd)); return (WORD)::SendMessage(m_hWnd, EM_SELECTIONTYPE, 0, 0L); }

_AFXCMN2_INLINE COLORREF CRichEdit2Ctrl::SetBackgroundColor(BOOL bSysColor, COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF)::SendMessage(m_hWnd, EM_SETBKGNDCOLOR, bSysColor, cr); }

_AFXCMN2_INLINE DWORD CRichEdit2Ctrl::SetEventMask(DWORD dwEventMask)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, EM_SETEVENTMASK, 0, dwEventMask); }

_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::SetOLECallback(IRichEditOleCallback* pCallback)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETOLECALLBACK, 0, (LPARAM)pCallback); }

_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::SetTargetDevice(HDC hDC, long lLineWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)hDC, lLineWidth); }

_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::SetTargetDevice(CDC &dc, long lLineWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)dc.m_hDC, lLineWidth); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::StreamIn(int nFormat, EDITSTREAM &es)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_STREAMIN, nFormat, (LPARAM)&es); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::StreamOut(int nFormat, EDITSTREAM &es)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_STREAMOUT, nFormat, (LPARAM)&es); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::GetTextLength() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, WM_GETTEXTLENGTH, NULL, NULL); }


#endif //_AFXCMN2_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\afxcmn2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCMN2_H__
#define __AFXCMN2_H__

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifndef IMAGE_BITMAP
#define IMAGE_BITMAP 0
#endif


/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

	#ifndef _RICHEDIT_
		#include <richedit.h>
	#endif
	#ifdef __AFXOLE_H__  // only include richole if OLE support is included
		#ifndef _RICHOLE_
			#include <richole.h>
			#define _RICHOLE_
		#endif
	#else
		struct IRichEditOle;
		struct IRichEditOleCallback;
	#endif

/////////////////////////////////////////////////////////////////////////////
// AFXCMN2 - RichEdit2 Control Class

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd
			class CRichEdit2Ctrl;

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Ctrl

class CRichEdit2Ctrl : public CWnd
{
	DECLARE_DYNAMIC(CRichEdit2Ctrl)

// Constructors
public:
	CRichEdit2Ctrl();
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	BOOL CanUndo() const;
	int GetLineCount() const;
	BOOL GetModify() const;
	void SetModify(BOOL bModified = TRUE);
	void GetRect(LPRECT lpRect) const;
	CPoint GetCharPos(long lChar) const;
	void SetOptions(WORD wOp, DWORD dwFlags);

	// NOTE: first word in lpszBuffer must contain the size of the buffer!
	int GetLine(int nIndex, LPTSTR lpszBuffer) const;
	int GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const;

	BOOL CanPaste(UINT nFormat = 0) const;
	void GetSel(long& nStartChar, long& nEndChar) const;
	void GetSel(CHARRANGE &cr) const;
	void LimitText(long nChars = 0);
	long LineFromChar(long nIndex) const;
	void SetSel(long nStartChar, long nEndChar);
	void SetSel(CHARRANGE &cr);
	DWORD GetDefaultCharFormat(CHARFORMAT &cf) const;
	DWORD GetSelectionCharFormat(CHARFORMAT &cf) const;
	long GetEventMask() const;
	long GetLimitText() const;
	DWORD GetParaFormat(PARAFORMAT &pf) const;
	// richedit EM_GETSELTEXT is ANSI
	long GetSelText(LPSTR lpBuf) const;
	CString GetSelText() const;
	WORD GetSelectionType() const;
	COLORREF SetBackgroundColor(BOOL bSysColor, COLORREF cr);
	BOOL SetDefaultCharFormat(CHARFORMAT &cf);
	BOOL SetSelectionCharFormat(CHARFORMAT &cf);
	BOOL SetWordCharFormat(CHARFORMAT &cf);
	DWORD SetEventMask(DWORD dwEventMask);
	BOOL SetParaFormat(PARAFORMAT &pf);
	BOOL SetTargetDevice(HDC hDC, long lLineWidth);
	BOOL SetTargetDevice(CDC &dc, long lLineWidth);
	long GetTextLength() const;
	BOOL SetReadOnly(BOOL bReadOnly = TRUE);
	int GetFirstVisibleLine() const;

// Operations
	void EmptyUndoBuffer();

	int LineIndex(int nLine = -1) const;
	int LineLength(int nLine = -1) const;
	void LineScroll(int nLines, int nChars = 0);
	void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE);
	void SetRect(LPCRECT lpRect);

	BOOL DisplayBand(LPRECT pDisplayRect);
	long FindText(DWORD dwFlags, FINDTEXTEX* pFindText) const;
	long FormatRange(FORMATRANGE* pfr, BOOL bDisplay = TRUE);
	void HideSelection(BOOL bHide, BOOL bPerm);
	void PasteSpecial(UINT nClipFormat, DWORD dvAspect = 0, HMETAFILE hMF = 0);
	void RequestResize();
	long StreamIn(int nFormat, EDITSTREAM &es);
	long StreamOut(int nFormat, EDITSTREAM &es);

	// Clipboard operations
	BOOL Undo();
	void Clear();
	void Copy();
	void Cut();
	void Paste();

// OLE support
	IRichEditOle* GetIRichEditOle() const;
	BOOL SetOLECallback(IRichEditOleCallback* pCallback);

// Implementation
public:
	virtual ~CRichEdit2Ctrl();
};
/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXCMN_INLINE inline
#include <afxcmn2.inl>
#undef _AFXCMN_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXCMN2_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\afximpl2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// Auxiliary System/Screen metrics

struct AUX_DATA
{
        // system metrics
        int cxVScroll, cyHScroll;
        int cxIcon, cyIcon;

        int cxBorder2, cyBorder2;

        // device metrics for screen
        int cxPixelsPerInch, cyPixelsPerInch;

        // convenient system color
        HBRUSH hbrWindowFrame;
        HBRUSH hbrBtnFace;
#ifdef _MAC
        HBRUSH hbr3DLight;
#endif

        // color values of system colors used for CToolBar
        COLORREF clrBtnFace, clrBtnShadow, clrBtnHilite;
        COLORREF clrBtnText, clrWindowFrame;
#ifdef _MAC
        COLORREF clr3DLight;
#endif

        // standard cursors
        HCURSOR hcurWait;
        HCURSOR hcurArrow;
        HCURSOR hcurHelp;       // cursor used in Shift+F1 help

        // special GDI objects allocated on demand
        HFONT   hStatusFont;
        HFONT   hToolTipsFont;
        HBITMAP hbmMenuDot;

        // other system information
        UINT    nWinVer;        // Major.Minor version numbers
        BOOL    bWin32s;        // TRUE if Win32s (or Windows 95)
        BOOL    bWin4;          // TRUE if Windows 4.0
        BOOL    bNotWin4;       // TRUE if not Windows 4.0
        BOOL    bSmCaption;     // TRUE if WS_EX_SMCAPTION is supported
        BOOL    bMarked4;       // TRUE if marked as 4.0

#ifdef _MAC
        BOOL    bOleIgnoreSuspend;
#endif

// Implementation
        AUX_DATA();
        ~AUX_DATA();
        void UpdateSysColors();
        void UpdateSysMetrics();
};

extern AFX_DATA_IMPORT AUX_DATA afxData;

/////////////////////////////////////////////////////////////////////////////
// _AFX_EDIT_STATE

class _AFX_EDIT_STATE : public CNoTrackObject
{
public:
        _AFX_EDIT_STATE();
        virtual ~_AFX_EDIT_STATE();

        CFindReplaceDialog* pFindReplaceDlg; // find or replace dialog
        BOOL bFindOnly; // Is pFindReplace the find or replace?
        CString strFind;    // last find string
        CString strReplace; // last replace string
        BOOL bCase; // TRUE==case sensitive, FALSE==not
        int bNext;  // TRUE==search down, FALSE== search up
        BOOL bWord; // TRUE==match whole word, FALSE==not
};

#undef AFX_DATA
#define AFX_DATA

class _AFX_RICHEDIT2_STATE : public _AFX_EDIT_STATE
{
public:
	HINSTANCE m_hInstRichEdit;      // handle to richedit dll
	virtual ~_AFX_RICHEDIT2_STATE();
};

EXTERN_PROCESS_LOCAL(_AFX_RICHEDIT2_STATE, _afxRichEdit2State)

_AFX_RICHEDIT2_STATE* AFX_CDECL AfxGetRichEdit2State();


// dialog/commdlg hook procs
INT_PTR CALLBACK AfxDlgProc(HWND, UINT, WPARAM, LPARAM);

// support for standard dialogs
extern const UINT _afxNMsgSETRGB;
typedef UINT (CALLBACK* COMMDLGPROC)(HWND, UINT, WPARAM, LPARAM);

/////////////////////////////////////////////////////////////////////////////
// Special helpers

BOOL AFXAPI AfxHelpEnabled();  // determine if ID_HELP handler exists
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\afxdlgs2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXDLGS2.H

#ifdef _AFXDLGS2_INLINE

_AFXDLGS2_INLINE CString CFontDialog2::GetFaceName() const
	{ return (LPCTSTR)m_cf.lpLogFont->lfFaceName; }
_AFXDLGS2_INLINE CString CFontDialog2::GetStyleName() const
	{ return m_cf.lpszStyle; }
_AFXDLGS2_INLINE int CFontDialog2::GetSize() const
	{ return m_cf.iPointSize; }
_AFXDLGS2_INLINE int CFontDialog2::GetWeight() const
	{ return (int)m_cf.lpLogFont->lfWeight; }
_AFXDLGS2_INLINE BOOL CFontDialog2::IsItalic() const
	{ return m_cf.lpLogFont->lfItalic ? TRUE : FALSE; }
_AFXDLGS2_INLINE BOOL CFontDialog2::IsStrikeOut() const
	{ return m_cf.lpLogFont->lfStrikeOut ? TRUE : FALSE; }
_AFXDLGS2_INLINE BOOL CFontDialog2::IsBold() const
	{ return m_cf.lpLogFont->lfWeight == FW_BOLD ? TRUE : FALSE; }
_AFXDLGS2_INLINE BOOL CFontDialog2::IsUnderline() const
	{ return m_cf.lpLogFont->lfUnderline ? TRUE : FALSE; }
_AFXDLGS2_INLINE COLORREF CFontDialog2::GetColor() const
	{ return m_cf.rgbColors; }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXDLGS2_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\afxdlgs2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDLGS2_H__
#define __AFXDLGS2_H__

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#ifndef _INC_COMMDLG
	#include <commdlg.h>    // common dialog APIs
#endif

	#ifndef _RICHEDIT_
		#include <richedit.h>
	#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifndef _AFX_NOFORCE_LIBS
#ifndef _MAC

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#else //!_MAC

/////////////////////////////////////////////////////////////////////////////
// Mac libraries

#endif //_MAC
#endif //!_AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXDLGS - MFC Standard dialogs

// Classes declared in this file

	// CDialog
		//class CCommonDialog;  // implementation base class

			class CFontDialog2;    // Font chooser dialog

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
// CFontDialog2 - used to select a font

class CFontDialog2 : public CCommonDialog
{
	DECLARE_DYNAMIC(CFontDialog2)

public:
// Attributes
	// font choosing parameter block
	CHOOSEFONT m_cf;

// Constructors
	CFontDialog2(LPLOGFONT lplfInitial = NULL,
		DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
		CDC* pdcPrinter = NULL,
		CWnd* pParentWnd = NULL);
	CFontDialog2(const CHARFORMAT& charformat,
		DWORD dwFlags = CF_SCREENFONTS,
		CDC* pdcPrinter = NULL,
		CWnd* pParentWnd = NULL);
// Operations
	virtual INT_PTR DoModal();

	// Get the selected font (works during DoModal displayed or after)
	void GetCurrentFont(LPLOGFONT lplf);

	// Helpers for parsing information after successful return
	CString GetFaceName() const;  // return the face name of the font
	CString GetStyleName() const; // return the style name of the font
	int GetSize() const;          // return the pt size of the font
	COLORREF GetColor() const;    // return the color of the font
	int GetWeight() const;        // return the chosen font weight
	BOOL IsStrikeOut() const;     // return TRUE if strikeout
	BOOL IsUnderline() const;     // return TRUE if underline
	BOOL IsBold() const;          // return TRUE if bold font
	BOOL IsItalic() const;        // return TRUE if italic font
	void GetCharFormat(CHARFORMAT& cf) const;

// Implementation
	LOGFONT m_lf; // default LOGFONT to store the info
	DWORD FillInLogFont(const CHARFORMAT& cf);

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	TCHAR m_szStyleName[64]; // contains style name after return
};


#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#ifndef _AFXDLGS_INLINE
#define _AFXDLGS_INLINE inline
#endif
#include <afxdlgs2.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXDLGS2_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\buttondi.cpp ===
// buttondi.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "resource.h"
#include "buttondi.h"
#include "strings.h"
#include "wordpad.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifndef DS_CONTEXTHELP
#define DS_CONTEXTHELP 0x2000L
#endif

static const int nFontSize = 10;

/////////////////////////////////////////////////////////////////////////////
// CButtonDialog dialog

INT_PTR CButtonDialog::DisplayMessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption,
	LPCTSTR lpszButtons, WORD wStyle, int nDef, int nCancel,
	DWORD* pHelpIDs, CWnd* pParentWnd)
{
	CButtonDialog dlg(lpszText, lpszCaption, lpszButtons, wStyle, pHelpIDs,
		pParentWnd);
	dlg.SetDefault(nDef);
	dlg.SetCancel(nCancel);
	return dlg.DoModal();
}

CButtonDialog::CButtonDialog(LPCTSTR lpszText, LPCTSTR lpszCaption,
	LPCTSTR lpszButtons, WORD wStyle, DWORD* pHelpIDs ,
	CWnd* pParentWnd) : CCSDialog()
{

	ASSERT(lpszText != NULL);
	ASSERT(lpszCaption != NULL);
	if (HIWORD(lpszText) == 0)
		VERIFY(m_strText.LoadString(LOWORD(lpszText)));
	else
		m_strText = lpszText;
	if (HIWORD(lpszCaption) == 0)
		VERIFY(m_strCaption.LoadString(LOWORD(lpszCaption)));
	else
		m_strCaption = lpszCaption;
	if (lpszButtons != NULL)
		AddButtons(lpszButtons);

	m_pParentWnd = pParentWnd;
	m_nDefButton = 0;
	m_nCancel = -1;
	m_pButtons = NULL;
	m_wStyle = wStyle;
	m_nBaseID = nFontSize; // don't use IDOK, IDCANCEL, etc
	m_hDlgTmp = NULL;

	LOGFONT lf;
	memcpy(&lf, &theApp.m_lf, sizeof(LOGFONT));
	lf.lfWeight = FW_NORMAL;
    lf.lfWidth = 0;
	VERIFY(m_font.CreateFontIndirect(&lf));

	m_pHelpIDs = pHelpIDs;
}

CButtonDialog::~CButtonDialog()
{
	delete [] m_pButtons;
	if (m_hDlgTmp != NULL)
		GlobalFree(m_hDlgTmp);
}

BEGIN_MESSAGE_MAP(CButtonDialog, CCSDialog)
	//{{AFX_MSG_MAP(CButtonDialog)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CButtonDialog message handlers

int CButtonDialog::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (m_pHelpIDs != NULL)
	{
		for (int i=0;i<m_strArray.GetSize();i++)
			m_pHelpIDs[i*2] = i+m_nBaseID;
	}
	if (CCSDialog::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	SetWindowText(m_strCaption);
	m_pButtons = new CButton[(size_t)m_strArray.GetSize()];

	CRect rect(0, 0, 10, 10);
	if (!m_staticIcon.Create(NULL,
		SS_ICON | WS_GROUP | WS_CHILD | WS_VISIBLE, rect, this))
	{
		return -1;
	}
	m_staticIcon.SetIcon(::LoadIcon(NULL, GetIconID(m_wStyle)));

	if (!m_staticText.Create(m_strText, SS_LEFT | SS_NOPREFIX | WS_GROUP |
		WS_CHILD | WS_VISIBLE, rect, this))
	{
		return -1;
	}
	m_staticText.SetFont(&m_font);
	
	for (int i=0;i<m_strArray.GetSize();i++)
	{
		if (!m_pButtons[i].Create(m_strArray[i], WS_TABSTOP | WS_CHILD |
			WS_VISIBLE | ((i == 0) ? WS_GROUP : 0) |
		    ((i == m_nDefButton) ? BS_DEFPUSHBUTTON : BS_PUSHBUTTON),
		    rect, this, i+m_nBaseID))
		{
			return -1;
		}
		m_pButtons[i].SetFont(&m_font);
	}
	PositionControls();
	return 0;
}

BOOL CButtonDialog::OnInitDialog()
{
	CCSDialog::OnInitDialog();
	if (m_pHelpIDs == NULL) // no context help
		ModifyStyleEx(WS_EX_CONTEXTHELP, 0); //remove

	m_pButtons[m_nDefButton].SetFocus();	
	return FALSE;  // return TRUE  unless you set the focus to a control
}

/////////////////////////////////////////////////////////////////////////////
// CButtonDialog operations

void CButtonDialog::AddButtons(LPCTSTR lpszButton)
{
	CString str, strButtons;
	int i=0;
	if (HIWORD(lpszButton) == 0)
		strButtons.LoadString(LOWORD(lpszButton));
	else
		strButtons = lpszButton;
	while (AfxExtractSubString(str, strButtons, i++, '\n'))
		AddButton(str);
}

#ifndef DS_3DLOOK
#define DS_3DLOOK 0x4
#endif

void CButtonDialog::FillInHeader(LPDLGTEMPLATE lpDlgTmp)
{
	USES_CONVERSION;
	lpDlgTmp->style = DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_VISIBLE |
		WS_CAPTION | WS_SYSMENU;
	if (theApp.m_bWin4)
		lpDlgTmp->style |= DS_CONTEXTHELP;
	lpDlgTmp->dwExtendedStyle = 0;
	lpDlgTmp->cdit = 0;
	lpDlgTmp->x = 0;
	lpDlgTmp->y = 0;
	lpDlgTmp->cx = 100;
	lpDlgTmp->cy = 100;
	
	LPWSTR lpStr = (LPWSTR)(lpDlgTmp + 1); /* Move ptr to the variable fields */

	*lpStr++ = 0;  /* No Menu resource for Message Box */
	*lpStr++ = 0;  /* No Class name for MessageBox */

	int nLen = m_strCaption.GetLength();
	wcscpy(lpStr, T2CW(m_strCaption));

	lpStr += nLen+1;
	WORD* pWord = (WORD*)lpStr;
	*pWord = 10; // 10 pt font
	pWord++;
	lpStr = (LPWSTR) pWord;

	wcscpy(lpStr, T2W(theApp.m_lf.lfFaceName));
}

/////////////////////////////////////////////////////////////////////////////
// CButtonDialog overridables

BOOL CButtonDialog::OnCommand(WPARAM wParam, LPARAM /*lParam*/)
{
	if (wParam == IDCANCEL && m_nCancel != -1)
	{
		EndDialog(m_nCancel);
		return TRUE;
	}
	if (::GetDlgItem(m_hWnd, (int)wParam) == NULL)
		return FALSE;
	EndDialog((int)(wParam-m_nBaseID));
	return TRUE;
}

INT_PTR CButtonDialog::DoModal()
{
	ASSERT(m_strArray.GetSize() != 0);
	if (m_strArray.GetSize() == 0)
		return (m_nCancel != -1) ? m_nCancel : 0;

	// compute size of header
	// Fixed portions of DLG template header = sizeof(DLGTEMPLATE);
    // One null byte for menu name and one for class name = 2
	// Caption text plus NULL = m_strCaption.GetLength()+1
	int nSize = sizeof(DLGTEMPLATE);
	nSize += (2 + m_strCaption.GetLength()+1+lstrlen(theApp.m_lf.lfFaceName)+1)*2 +sizeof(WORD);
	m_hDlgTmp = GlobalAlloc(GPTR, nSize);
	if (m_hDlgTmp == NULL)
		return IDCANCEL;
	LPDLGTEMPLATE lpDlgTmp = (LPDLGTEMPLATE)GlobalLock(m_hDlgTmp);
	FillInHeader(lpDlgTmp);
	GlobalUnlock(m_hDlgTmp);
	InitModalIndirect(m_hDlgTmp);	

	return CCSDialog::DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CButtonDialog implementation

void CButtonDialog::PositionControls()
{
	CSize sizeBase = GetBaseUnits();
	int nButtonHeight = (sizeBase.cy*14)/8;
	int nHeight = 0;
	int nSep,nLeftMargin,nRightMargin,nTopMargin,nBottomMargin;
    int nButtonAdj;
    int nWidth = 0;
    CRect rectText;

	// a) 5/8 screen Width
	// b) Caption
	// c) nLeftMargin ICON nSep TEXT nRightMargin
	// d) nLeftMargin Button1 nSep Button2 ... nRightMargin
	// client width is max(b,d, min(c,a))

	CSize sizeIcon(GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON));
	nSep = sizeIcon.cx/2;
	nLeftMargin = nSep;
	nRightMargin = nSep;
	nTopMargin = nSep;
	nBottomMargin = nSep;
	
	CClientDC dc(this);
	CFont* pOldFont = dc.SelectObject(&m_font);
	
	nButtonAdj = dc.GetTextExtent(_T("XXX"),3).cx; // padding on buttons
	
	int nScreenWidth58 = dc.GetDeviceCaps(HORZRES)*5/8;
	int nCaptionWidth = dc.GetTextExtent(m_strCaption, m_strCaption.
		GetLength()).cx;
	CSize sizeText = dc.GetTextExtent(m_strText,m_strText.GetLength());
	int nTextIconWidth = nLeftMargin+sizeIcon.cx+nSep+sizeText.cx+nRightMargin;
	int nButtons = (int)m_strArray.GetSize();
	int nButtonsWidth = nLeftMargin+nRightMargin+(nButtons-1)*nSep;
	for (int i=0;i<nButtons;i++)
	{
		nButtonsWidth +=
			dc.GetTextExtent(m_strArray[i],m_strArray[i].GetLength()).cx+
			nButtonAdj*2;
	}
	
	nWidth = min(nTextIconWidth,nScreenWidth58);
	nWidth = max(nWidth, nCaptionWidth);
	nWidth = max(nWidth, nButtonsWidth);

	m_staticIcon.SetWindowPos(NULL, nLeftMargin, nTopMargin, sizeIcon.cx,
		sizeIcon.cy, SWP_NOZORDER);

	if (sizeText.cx > nWidth-nLeftMargin-nRightMargin-sizeIcon.cx-nSep)
	{
		sizeText.cx = nWidth-nLeftMargin-nRightMargin-sizeIcon.cx-nSep;
//		int nTextWidth = nWidth-nLeftMargin-nRightMargin-sizeIcon.cx-nSep;
//		rectText.SetRect(0, 0, nTextWidth, 32767);
		rectText.SetRect(0, 0, sizeText.cx, 32767);
		/* Ask DrawText for the right cy */
		sizeText.cy = dc.DrawText(m_strText, m_strText.GetLength(), &rectText,
			DT_CALCRECT | DT_WORDBREAK | DT_EXPANDTABS | DT_NOPREFIX);
	}
	
	m_staticText.SetWindowPos(NULL, nSep+sizeIcon.cx+nSep, nTopMargin,
		sizeText.cx, sizeText.cy, SWP_NOZORDER);
	
	sizeText.cy = max(sizeText.cy, sizeIcon.cy); // at least icon height
	nHeight = nTopMargin + sizeText.cy + nSep + nButtonHeight + nBottomMargin;

	CRect rect;
	rect.left = (nWidth - (nButtonsWidth - nLeftMargin - nRightMargin))/2;
	rect.top = nTopMargin + sizeText.cy + nSep;
	rect.bottom = rect.top + nButtonHeight;

	for (i=0;i<m_strArray.GetSize();i++)
	{
		rect.right = rect.left + dc.GetTextExtent(m_strArray[i],m_strArray[i].GetLength()).cx +
			2*nButtonAdj;
		m_pButtons[i].MoveWindow(&rect);
		rect.left = rect.right + nSep;
	}

	rect.SetRect(0,0,nWidth,nHeight);
	CalcWindowRect(&rect);
	SetWindowPos(NULL, (dc.GetDeviceCaps(HORZRES)-rect.Width())/2,
		(dc.GetDeviceCaps(VERTRES)-rect.Height())/2, rect.Width(), rect.Height(),
		SWP_NOZORDER|SWP_NOACTIVATE);
	if(m_nCancel == -1) // no cancel button
	{
//		CMenu* pMenu = GetSystemMenu(FALSE);
//		if (pMenu != NULL)
//			pMenu->DeleteMenu(SC_CLOSE, MF_BYCOMMAND);
	}
	dc.SelectObject(pOldFont);
}

CSize CButtonDialog::GetBaseUnits()
{
	CDisplayIC dc;
	CFont* pFont = dc.SelectObject(&m_font);
	TEXTMETRIC tm;
	VERIFY(dc.GetTextMetrics(&tm));
	dc.SelectObject(pFont);
	return CSize(tm.tmAveCharWidth, tm.tmHeight);
}

LPCTSTR CButtonDialog::GetIconID(WORD wFlags)
{
	LPCTSTR lpszIcon = NULL;
	wFlags &= MB_ICONMASK;
	if (wFlags == MB_ICONHAND)
		lpszIcon = IDI_HAND;
	else if (wFlags == MB_ICONQUESTION)
		lpszIcon = IDI_QUESTION;
	else if (wFlags == MB_ICONEXCLAMATION)
		lpszIcon = IDI_EXCLAMATION;
	else if (wFlags == MB_ICONASTERISK)
		lpszIcon = IDI_ASTERISK;
	return lpszIcon;
}	

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\afxrich2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXRICH2.H

// CRichEdit2View
_AFXRICH2_INLINE CRichEdit2Ctrl& CRichEdit2View::GetRichEditCtrl() const
	{ return *(CRichEdit2Ctrl*)this; }
int _AFXRICH2_INLINE CRichEdit2View::GetPrintWidth() const
	{ return m_sizePaper.cx - m_rectMargin.left - m_rectMargin.right;}
CRect _AFXRICH2_INLINE CRichEdit2View::GetPrintRect() const
	{ return CRect(m_rectMargin.left, m_rectMargin.top, m_sizePaper.cx - m_rectMargin.right, m_sizePaper.cy - m_rectMargin.bottom); }
CRect _AFXRICH2_INLINE CRichEdit2View::GetPageRect() const
	{ return CRect(CPoint(0,0), m_sizePaper); }
void _AFXRICH2_INLINE CRichEdit2View::SetPaperSize(CSize sizePaper)
	{ m_sizePaper = sizePaper; }
CSize _AFXRICH2_INLINE CRichEdit2View::GetPaperSize() const
	{ return m_sizePaper; }
void _AFXRICH2_INLINE CRichEdit2View::SetMargins(const CRect& rectMargin)
	{ m_rectMargin = rectMargin; }
CRect _AFXRICH2_INLINE CRichEdit2View::GetMargins() const
	{ return m_rectMargin; }

_AFXRICH2_INLINE long CRichEdit2View::GetTextLength() const
	{ return GetRichEditCtrl().GetTextLength(); }
_AFXRICH2_INLINE CRichEdit2Doc* CRichEdit2View::GetDocument() const
{
	ASSERT(m_pDocument != NULL);
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CRichEdit2Doc)));
	return (CRichEdit2Doc*)m_pDocument;
}
_AFXRICH2_INLINE int CRichEdit2Doc::GetStreamFormat() const
	{ return m_bRTF ? SF_RTF : SF_TEXT; }
_AFXRICH2_INLINE BOOL CRichEdit2Doc::IsUnicode() const
    { return m_bUnicode; }
_AFXRICH2_INLINE void CRichEdit2Doc::InvalidateObjectCache()
	{ m_bUpdateObjectCache = TRUE; }

_AFXRICH2_INLINE void CRichEdit2CntrItem::Mark(BOOL b)
	{ m_bMark = b; }
_AFXRICH2_INLINE BOOL CRichEdit2CntrItem::IsMarked()
	{ return m_bMark||m_bLock; }
_AFXRICH2_INLINE CRichEdit2Doc* CRichEdit2CntrItem::GetDocument()
	{ return (CRichEdit2Doc*)COleClientItem::GetDocument(); }
_AFXRICH2_INLINE CRichEdit2View* CRichEdit2CntrItem::GetActiveView()
	{ return (CRichEdit2View*)COleClientItem::GetActiveView(); }

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\buttondi.h ===
// buttondi.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CButtonDialog dialog

class CButtonDialog : public CCSDialog
{
// Construction
public:
	CButtonDialog(LPCTSTR lpszText, LPCTSTR lpszCaption, LPCTSTR lpszButtons,
		WORD wStyle, DWORD* pHelpIDs = NULL, CWnd* pParentWnd = NULL);
	~CButtonDialog();

// Attributes
	CFont m_font;
// Operations
	static INT_PTR DisplayMessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption,
		LPCTSTR lpszButtons, WORD wStyle, int nDef = 0, int nCancel = -1,
		DWORD* pHelpIDs = NULL, CWnd* pParentWnd = NULL);

	void AddButton(CString& strButton) { m_strArray.Add(strButton);}
	void AddButtons(LPCTSTR lpszButton);
	void SetCancel(int nCancel)
		{ ASSERT(nCancel < m_strArray.GetSize()); m_nCancel = nCancel;}
	void SetDefault(int nDef)
		{ ASSERT(nDef < m_strArray.GetSize()); m_nDefButton = nDef;}
	void FillInHeader(LPDLGTEMPLATE lpDlgTmp);

// Overridables
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual INT_PTR DoModal();

// Implementation
protected:
	virtual const DWORD* GetHelpIDs() {return m_pHelpIDs;}
	DWORD* m_pHelpIDs;
	int m_nDefButton;
	int m_nCancel;
	HGLOBAL m_hDlgTmp;
	UINT m_nBaseID;
	WORD m_wStyle;
	CButton* m_pButtons;
	CStatic m_staticIcon;
	CStatic m_staticText;
	CString m_strCaption;
	CString m_strText;
	CStringArray m_strArray;
	CSize GetBaseUnits();
	LPCTSTR GetIconID(WORD wFlags);
	void PositionControls();

	// Generated message map functions
	//{{AFX_MSG(CButtonDialog)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\afxrich2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRICH2_H__
#define __AFXRICH2_H__

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif
#ifndef __AFXDLGS_H__
	#include <afxdlgs.h>
    #include <afxdlgs2.h>
#endif
#ifndef __AFXOLE_H__
	#include <afxole.h>
#endif
#ifndef _RICHEDIT_
	#include <richedit.h>
#endif
#ifndef _RICHOLE_
	#include <richole.h>
	#define _RICHOLE_
#endif
#ifndef __AFXCMN2_H__
	#include <afxcmn2.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXRICH - RichEdit2 classes

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CCtrlView
					class CRichEdit2View;// rich text editor view

		//CDocument
			//COleDocument
				class CRichEdit2Doc;
		//CDocItem
			//COleClientItem
				class CRichEdit2CntrItem;

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View

class _AFX_RICHEDIT2_STATE;  // private to implementation

class CRichEdit2View : public CCtrlView
{
	DECLARE_DYNCREATE(CRichEdit2View)

// Construction
public:
	CRichEdit2View();

// Attributes
public:
	enum WordWrapType
	{
		WrapNone = 0,
		WrapToWindow = 1,
		WrapToTargetDevice = 2
	};
	int m_nWordWrap;
	int m_nBulletIndent;

	void SetPaperSize(CSize sizePaper);
	CSize GetPaperSize() const;
	void SetMargins(const CRect& rectMargin);
	CRect GetMargins() const;
	int GetPrintWidth() const;
	CRect GetPrintRect() const;
	CRect GetPageRect() const;

	//formatting
	CHARFORMAT& GetCharFormatSelection();
	PARAFORMAT& GetParaFormatSelection();
	void SetCharFormat(CHARFORMAT cf);
	void SetParaFormat(PARAFORMAT& pf);
	CRichEdit2CntrItem* GetSelectedItem() const;
	CRichEdit2CntrItem* GetInPlaceActiveItem() const;

	// CEdit control access
	CRichEdit2Ctrl& GetRichEditCtrl() const;
	CRichEdit2Doc* GetDocument() const;

	// other attributes
	long GetTextLength() const;
	static BOOL AFX_CDECL IsRichEdit2Format(CLIPFORMAT cf);
	BOOL CanPaste() const;

// Operations
public:
	void AdjustDialogPosition(CDialog* pDlg);
	HRESULT InsertItem(CRichEdit2CntrItem* pItem);
	void InsertFileAsObject(LPCTSTR lpszFileName);
	BOOL FindText(LPCTSTR lpszFind, BOOL bCase = TRUE, BOOL bWord = TRUE);
	BOOL FindTextSimple(LPCTSTR lpszFind, BOOL bCase = TRUE,
		BOOL bWord = TRUE);
	long PrintInsideRect(CDC* pDC, RECT& rectLayout, long nIndexStart,
		long nIndexStop, BOOL bOutput);
	long PrintPage(CDC* pDC, long nIndexStart, long nIndexStop);
	void DoPaste(COleDataObject& dataobj, CLIPFORMAT cf,
		HMETAFILEPICT hMetaPict);

// Helpers
	void OnCharEffect(DWORD dwMask, DWORD dwEffect);
	void OnUpdateCharEffect(CCmdUI* pCmdUI, DWORD dwMask, DWORD dwEffect) ;
	void OnParaAlign(WORD wAlign);
	void OnUpdateParaAlign(CCmdUI* pCmdUI, WORD wAlign);

// Overrideables
protected:
	virtual BOOL IsSelected(const CObject* pDocItem) const;
	virtual void OnInitialUpdate();
	virtual void OnFindNext(LPCTSTR lpszFind, BOOL bNext, BOOL bCase, BOOL bWord);
	virtual void OnReplaceSel(LPCTSTR lpszFind, BOOL bNext, BOOL bCase,
		BOOL bWord, LPCTSTR lpszReplace);
	virtual void OnReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace,
		BOOL bCase, BOOL bWord);
	virtual void OnTextNotFound(LPCTSTR lpszFind);
	virtual void OnPrinterChanged(const CDC& dcPrinter);
	virtual void WrapChanged();

// Advanced
	virtual BOOL OnPasteNativeObject(LPSTORAGE lpStg);
	virtual HMENU GetContextMenu(WORD, LPOLEOBJECT, CHARRANGE* );
	virtual HRESULT GetClipboardData(CHARRANGE* lpchrg, DWORD dwReco,
		LPDATAOBJECT lpRichDataObj, LPDATAOBJECT* lplpdataobj);
	virtual HRESULT QueryAcceptData(LPDATAOBJECT, CLIPFORMAT*, DWORD,
		BOOL, HGLOBAL);

// Implementation
public:
	LPRICHEDITOLE m_lpRichEditOle;
	CDC m_dcTarget;
	long m_lInitialSearchPos;
	UINT m_nPasteType;
	BOOL m_bFirstSearch;

	void TextNotFound(LPCTSTR lpszFind);
	BOOL FindText(_AFX_RICHEDIT2_STATE* pEditState);
	BOOL FindTextSimple(_AFX_RICHEDIT2_STATE* pEditState);
	long FindAndSelect(DWORD dwFlags, FINDTEXTEX& ft);
	void Stream(CArchive& ar, BOOL bSelection);
	HRESULT GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
		LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo);
	HRESULT ShowContainerUI(BOOL b);
	static DWORD CALLBACK EditStreamCallBack(DWORD_PTR dwCookie,
		LPBYTE pbBuff, LONG cb, LONG *pcb);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
	virtual void DeleteContents();
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);

	static AFX_DATA ULONG lMaxSize; // maximum number of characters supported

protected:
	CRect m_rectMargin;
	CSize m_sizePaper;
	CDWordArray m_aPageStart;    // array of starting pages
	PARAFORMAT m_paraformat;
	CHARFORMAT m_charformat;
	BOOL m_bSyncCharFormat;
	BOOL m_bSyncParaFormat;

	// construction
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	// printing support
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo = NULL);
	BOOL PaginateTo(CDC* pDC, CPrintInfo* pInfo);

	// find & replace support
	void OnEditFindReplace(BOOL bFindOnly);
	BOOL SameAsSelected(LPCTSTR lpszCompare, BOOL bCase, BOOL bWord);

	// special overrides for implementation

	//{{AFX_MSG(CRichEdit2View)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnUpdateNeedSel(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedClip(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedText(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedFind(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnEditCopy();
	afx_msg void OnEditPaste();
	afx_msg void OnEditClear();
	afx_msg void OnEditUndo();
	afx_msg void OnEditSelectAll();
	afx_msg void OnEditFind();
	afx_msg void OnEditReplace();
	afx_msg void OnEditRepeat();
	afx_msg void OnDestroy();
	afx_msg void OnEditProperties();
	afx_msg void OnUpdateEditProperties(CCmdUI* pCmdUI);
	afx_msg void OnInsertObject();
	afx_msg void OnCancelEditCntr();
	afx_msg void OnCharBold();
	afx_msg void OnUpdateCharBold(CCmdUI* pCmdUI);
	afx_msg void OnCharItalic();
	afx_msg void OnUpdateCharItalic(CCmdUI* pCmdUI);
	afx_msg void OnCharUnderline();
	afx_msg void OnUpdateCharUnderline(CCmdUI* pCmdUI);
	afx_msg void OnParaCenter();
	afx_msg void OnUpdateParaCenter(CCmdUI* pCmdUI);
	afx_msg void OnParaLeft();
	afx_msg void OnUpdateParaLeft(CCmdUI* pCmdUI);
	afx_msg void OnParaRight();
	afx_msg void OnUpdateParaRight(CCmdUI* pCmdUI);
	afx_msg void OnBullet();
	afx_msg void OnUpdateBullet(CCmdUI* pCmdUI);
	afx_msg void OnFormatFont();
	afx_msg void OnColorPick(COLORREF cr);
	afx_msg void OnColorDefault();
	afx_msg void OnEditPasteSpecial();
	afx_msg void OnUpdateEditPasteSpecial(CCmdUI* pCmdUI);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnDropFiles(HDROP hDropInfo);
	afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
	//}}AFX_MSG
	afx_msg LRESULT OnFindReplaceCmd(WPARAM, LPARAM lParam);
	afx_msg void OnSelChange(NMHDR* pNMHDR, LRESULT* pResult);

	DECLARE_MESSAGE_MAP()

// Interface Map
public:
	BEGIN_INTERFACE_PART(RichEditOleCallback, IRichEditOleCallback)
		INIT_INTERFACE_PART(CRichEdit2View, RichEditOleCallback)
		STDMETHOD(GetNewStorage) (LPSTORAGE*);
		STDMETHOD(GetInPlaceContext) (LPOLEINPLACEFRAME*,
									  LPOLEINPLACEUIWINDOW*,
									  LPOLEINPLACEFRAMEINFO);
		STDMETHOD(ShowContainerUI) (BOOL);
		STDMETHOD(QueryInsertObject) (LPCLSID, LPSTORAGE, LONG);
		STDMETHOD(DeleteObject) (LPOLEOBJECT);
		STDMETHOD(QueryAcceptData) (LPDATAOBJECT, CLIPFORMAT*, DWORD,BOOL, HGLOBAL);
		STDMETHOD(ContextSensitiveHelp) (BOOL);
		STDMETHOD(GetClipboardData) (CHARRANGE*, DWORD, LPDATAOBJECT*);
		STDMETHOD(GetDragDropEffect) (BOOL, DWORD, LPDWORD);
		STDMETHOD(GetContextMenu) (WORD, LPOLEOBJECT, CHARRANGE*, HMENU*);
	END_INTERFACE_PART(RichEditOleCallback)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc

class CRichEdit2Doc : public COleServerDoc
{
protected: // create from serialization only
	CRichEdit2Doc();
	DECLARE_DYNAMIC(CRichEdit2Doc)

// Attributes
public:
	BOOL m_bRTF;        // TRUE when formatted, FALSE when plain text
    BOOL m_bUnicode;    // TRUE if the doc is Unicode

	virtual CRichEdit2CntrItem* CreateClientItem(REOBJECT* preo = NULL) const = 0;

	virtual CRichEdit2View* GetView() const;
	int GetStreamFormat() const;
    BOOL IsUnicode() const;

// Implementation
protected:
	virtual COleServerItem* OnGetEmbeddedItem();
	void MarkItemsClear() const;
	void DeleteUnmarkedItems() const;
	void UpdateObjectCache();
public:
	BOOL m_bUpdateObjectCache;
	virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU);
	virtual void SetTitle(LPCTSTR lpszTitle);
	virtual COleClientItem* GetPrimarySelectedItem(CView* pView);
	virtual void DeleteContents();
	virtual POSITION GetStartPosition() const;
	virtual void PreCloseFrame(CFrameWnd* pFrameWnd);
	virtual void UpdateModifiedFlag();
	virtual BOOL IsModified();
	virtual void SetModifiedFlag(BOOL bModified = TRUE);
	virtual COleClientItem* GetInPlaceActiveItem(CWnd* pWnd);
	CRichEdit2CntrItem* LookupItem(LPOLEOBJECT lpobj) const;
	void InvalidateObjectCache();
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2CntrItem

class CRichEdit2CntrItem : public COleClientItem
{
	DECLARE_SERIAL(CRichEdit2CntrItem)

// Constructors
public:
	CRichEdit2CntrItem(REOBJECT* preo = NULL, CRichEdit2Doc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Operations
	void SyncToRichEditObject(REOBJECT& reo);

// Implementation
public:
	~CRichEdit2CntrItem();
	LPOLECLIENTSITE m_lpClientSite;
	BOOL m_bMark;
	BOOL m_bLock;   // lock it during creation to avoid deletion
	void Mark(BOOL b);
	BOOL IsMarked();
	CRichEdit2Doc* GetDocument();
	CRichEdit2View* GetActiveView();
	HRESULT ShowContainerUI(BOOL b);
	HRESULT GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
		LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo);
	virtual LPOLECLIENTSITE GetClientSite();
	virtual BOOL ConvertTo(REFCLSID clsidNew);
	virtual BOOL ActivateAs(LPCTSTR lpszUserType, REFCLSID clsidOld,
		REFCLSID clsidNew);
	virtual void SetDrawAspect(DVASPECT nDrawAspect);
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual BOOL CanActivate();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXRICH_INLINE inline
#include <afxrich2.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXRICH2_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\chicdial.cpp ===
// chicdial.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "fixhelp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCSDialog dialog

CCSDialog::CCSDialog(UINT nIDTemplate, CWnd* pParentWnd)
	: CDialog(nIDTemplate, pParentWnd)
{
}

CCSDialog::CCSDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd)
	: CDialog(lpszTemplateName, pParentWnd)
{
}

CCSDialog::CCSDialog() : CDialog()
{
}

BEGIN_MESSAGE_MAP(CCSDialog, CDialog)
	//{{AFX_MSG_MAP(CCSDialog)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnHelpContextMenu)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCSDialog message handlers

LONG CCSDialog::OnHelp(WPARAM, LPARAM lParam)
{
	::WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, AfxGetApp()->m_pszHelpFilePath,
		HELP_WM_HELP, (DWORD_PTR)GetHelpIDs());
	return 0;
}

LONG CCSDialog::OnHelpContextMenu(WPARAM wParam, LPARAM)
{
	::WinHelp((HWND)wParam, AfxGetApp()->m_pszHelpFilePath,
		HELP_CONTEXTMENU, (DWORD_PTR)GetHelpIDs());
	return 0;
}

BOOL CCSDialog::OnInitDialog()
{
   CDialog::OnInitDialog();
   ModifyStyleEx(0, WS_EX_CONTEXTHELP);
   FixHelp(this, FALSE) ;
   return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
// CCSPropertyPage

CCSPropertyPage::CCSPropertyPage(UINT nIDTemplate, UINT nIDCaption)
	: CPropertyPage(nIDTemplate, nIDCaption)
{
    m_psp.dwFlags &= ~PSP_HASHELP;
}

CCSPropertyPage::CCSPropertyPage(LPCTSTR lpszTemplateName,
	UINT nIDCaption) : CPropertyPage(lpszTemplateName, nIDCaption)
{
    m_psp.dwFlags &= ~PSP_HASHELP;
}

BEGIN_MESSAGE_MAP(CCSPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CCSPropertyPage)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnHelpContextMenu)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCSPropertyPage message handlers

LONG CCSPropertyPage::OnHelp(WPARAM, LPARAM lParam)
{
	::WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, AfxGetApp()->m_pszHelpFilePath,
		HELP_WM_HELP, (DWORD_PTR)GetHelpIDs());
	return 0;
}

LONG CCSPropertyPage::OnHelpContextMenu(WPARAM wParam, LPARAM)
{
	::WinHelp((HWND)wParam, AfxGetApp()->m_pszHelpFilePath,
		HELP_CONTEXTMENU, (DWORD_PTR)GetHelpIDs());
	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CCSPropertySheet

BEGIN_MESSAGE_MAP(CCSPropertySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CCSPropertySheet)
	//}}AFX_MSG_MAP
   ON_WM_NCCREATE()
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnHelpContextMenu)
END_MESSAGE_MAP()

CCSPropertySheet::CCSPropertySheet(UINT nIDCaption, CWnd *pParentWnd,
	UINT iSelectPage) : CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
    m_psh.dwFlags &= ~PSH_HASHELP;
}

CCSPropertySheet::CCSPropertySheet(LPCTSTR pszCaption, CWnd *pParentWnd,
	UINT iSelectPage) : CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
    m_psh.dwFlags &= ~PSH_HASHELP;
}

/////////////////////////////////////////////////////////////////////////////
// CCSPropertySheet message handlers

LONG CCSPropertySheet::OnHelp(WPARAM wParam, LPARAM lParam)
{
	GetActivePage()->SendMessage(WM_HELP, wParam, lParam);
	return 0;
}

LONG CCSPropertySheet::OnHelpContextMenu(WPARAM wParam, LPARAM lParam)
{
	GetActivePage()->SendMessage(WM_CONTEXTMENU, wParam, lParam);
	return 0;
}

BOOL CCSPropertySheet::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.dwExStyle |= WS_EX_CONTEXTHELP;
	return CPropertySheet::PreCreateWindow(cs);
}

BOOL CCSPropertySheet::OnNcCreate(LPCREATESTRUCT)
{
   return (BOOL)Default() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\cntritem.cpp ===
// cntritem.cpp : implementation of the CWordPadCntrItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"

#include "wordpdoc.h"
#include "wordpvw.h"
#include "cntritem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWordPadCntrItem implementation

IMPLEMENT_SERIAL(CWordPadCntrItem, CRichEdit2CntrItem, 0)

CWordPadCntrItem::CWordPadCntrItem(REOBJECT *preo, CWordPadDoc* pContainer)
	: CRichEdit2CntrItem(preo, pContainer)
{
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadCntrItem diagnostics

#ifdef _DEBUG
void CWordPadCntrItem::AssertValid() const
{
	CRichEdit2CntrItem::AssertValid();
}

void CWordPadCntrItem::Dump(CDumpContext& dc) const
{
	CRichEdit2CntrItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\colorlis.h ===
// colorlis.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CColorMenu window

class CColorMenu : public CMenu
{
    // The following structure is used for accessibility.  Accessibility tools
    // use it to get a descriptive string out of an owner-draw menu.  This
    // stuff will probably be put in a system header someday.

#define MSAA_MENU_SIG 0xAA0DF00DL

    // Menu's dwItemData should point to one of these structs:
    // (or can point to an app-defined struct containing this as the first 
    // member)
    typedef struct tagMSAAMENUINFO {
        DWORD   dwMSAASignature; // Must be MSAA_MENU_SIG
        DWORD   cchWText;        // Length of text in chars
        LPWSTR  pszWText;        // NUL-terminated text, in Unicode
    } MSAAMENUINFO, *LPMSAAMENUINFO;

    // Private struct to add the color index in

    struct MenuInfo
    {
        MSAAMENUINFO    msaa;
        int             index;
    };

// Construction
public:
	CColorMenu();

// Attributes
public:
    static MenuInfo m_menuInfo[17];
 
	static COLORREF GetColor(UINT id);

// Operations
public:

// Implementation
public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);

};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\colorlis.cpp ===
// colorlis.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "colorlis.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CColorMenu

CColorMenu::MenuInfo CColorMenu::m_menuInfo[] = 
{
    {{MSAA_MENU_SIG, 0, NULL}, 0},    //black
    {{MSAA_MENU_SIG, 0, NULL}, 1},    //dark red
    {{MSAA_MENU_SIG, 0, NULL}, 2},    //dark green
    {{MSAA_MENU_SIG, 0, NULL}, 3},    //light brown
    {{MSAA_MENU_SIG, 0, NULL}, 4},    //dark blue
    {{MSAA_MENU_SIG, 0, NULL}, 5},    //purple
    {{MSAA_MENU_SIG, 0, NULL}, 6},    //dark cyan
    {{MSAA_MENU_SIG, 0, NULL}, 12},   //gray
    {{MSAA_MENU_SIG, 0, NULL}, 7},    //light gray
    {{MSAA_MENU_SIG, 0, NULL}, 13},   //red
    {{MSAA_MENU_SIG, 0, NULL}, 14},   //green
    {{MSAA_MENU_SIG, 0, NULL}, 15},   //yellow
    {{MSAA_MENU_SIG, 0, NULL}, 16},   //blue
    {{MSAA_MENU_SIG, 0, NULL}, 17},   //magenta
    {{MSAA_MENU_SIG, 0, NULL}, 18},   //cyan
    {{MSAA_MENU_SIG, 0, NULL}, 19},   //white
    {{MSAA_MENU_SIG, 0, NULL}, 0}     //automatic
};


CColorMenu::CColorMenu()
{
    VERIFY(CreatePopupMenu());
    ASSERT(GetMenuItemCount()==0);

    CString menutext;

    for (int i = 0; i < 17; i++)
    {
        LPWSTR menutextW = new WCHAR[64];

#ifndef UNICODE
        char    menutext[64];
#else
        LPWSTR  menutext = menutextW;
#endif

        ::LoadString(
                AfxGetInstanceHandle(),
                ID_COLOR0 + i,
                menutext,
                64);

#ifndef UNICODE
        // Can't use A2W because it allocates the destination with alloca
        MultiByteToWideChar(CP_ACP, 0, menutext, -1, menutextW, 64);
#endif // !UNICODE

        m_menuInfo[i].msaa.pszWText = menutextW;
        m_menuInfo[i].msaa.cchWText = wcslen(menutextW);

        VERIFY(AppendMenu(MF_OWNERDRAW, ID_COLOR0+i, (LPCTSTR)&m_menuInfo[i]));
    }
}

COLORREF CColorMenu::GetColor(UINT id)
{
    ASSERT(id >= ID_COLOR0);
    ASSERT(id <= ID_COLOR16);
    if (id == ID_COLOR16) // autocolor
        return ::GetSysColor(COLOR_WINDOWTEXT);
    else
    {
        CPalette* pPal = CPalette::FromHandle( (HPALETTE) GetStockObject(DEFAULT_PALETTE));
        ASSERT(pPal != NULL);
        PALETTEENTRY pe;
        if (pPal->GetPaletteEntries(m_menuInfo[id-ID_COLOR0].index, 1, &pe) == 0)
            return ::GetSysColor(COLOR_WINDOWTEXT);
        else
            return RGB(pe.peRed,pe.peGreen,pe.peBlue);
    }
}

void CColorMenu::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
    ASSERT(lpDIS->CtlType == ODT_MENU);
    UINT id = (UINT)(WORD)lpDIS->itemID;
    ASSERT(id >= ID_COLOR0);
    ASSERT(id <= ID_COLOR16);
    CDC dc;
    dc.Attach(lpDIS->hDC);

    CRect rc(lpDIS->rcItem);
    ASSERT(rc.Width() < 500);
    if (lpDIS->itemState & ODS_FOCUS)
        dc.DrawFocusRect(&rc);

    COLORREF cr = (lpDIS->itemState & ODS_SELECTED) ?
        ::GetSysColor(COLOR_HIGHLIGHT) :
        dc.GetBkColor();

    CBrush brushFill(cr);
    cr = dc.GetTextColor();

    if (lpDIS->itemState & ODS_SELECTED)
        dc.SetTextColor(::GetSysColor(COLOR_HIGHLIGHTTEXT));

    int nBkMode = dc.SetBkMode(TRANSPARENT);
    dc.FillRect(&rc, &brushFill);

    rc.left += 50;
    CString strColor;
    strColor.LoadString(id);
    dc.TextOut(rc.left,rc.top,strColor,strColor.GetLength());
    rc.left -= 45;
    rc.top += 2;
    rc.bottom -= 2;
    rc.right = rc.left + 40;
    CBrush brush(GetColor(id));
    CBrush* pOldBrush = dc.SelectObject(&brush);
    dc.Rectangle(rc);

    dc.SelectObject(pOldBrush);
    dc.SetTextColor(cr);
    dc.SetBkMode(nBkMode);
    
    dc.Detach();
}

void CColorMenu::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
    ASSERT(lpMIS->CtlType == ODT_MENU);
    UINT id = (UINT)(WORD)lpMIS->itemID;
    ASSERT(id >= ID_COLOR0);
    ASSERT(id <= ID_COLOR16);
    CDisplayIC dc;
    CString strColor;
    strColor.LoadString(id);
    CSize sizeText = dc.GetTextExtent(strColor,strColor.GetLength());
    ASSERT(sizeText.cx < 500);
    lpMIS->itemWidth = sizeText.cx + 50;
    lpMIS->itemHeight = sizeText.cy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\cntritem.h ===
// cntritem.h : interface of the CWordPadCntrItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CWordPadDoc;
class CWordPadView;

class CWordPadCntrItem : public CRichEdit2CntrItem
{
	DECLARE_SERIAL(CWordPadCntrItem)

// Constructors
public:
	CWordPadCntrItem(REOBJECT* preo = NULL, CWordPadDoc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Attributes
public:
	CWordPadDoc* GetDocument()
		{ return (CWordPadDoc*)COleClientItem::GetDocument(); }
	CWordPadView* GetActiveView()
		{ return (CWordPadView*)COleClientItem::GetActiveView(); }

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWordPadCntrItem)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\chicdial.h ===
// chicdial.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CCSDialog dialog

class CCSDialog : public CDialog
{
// Construction
public:
	CCSDialog();
	CCSDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
	CCSDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);

// Implementation
protected:
	virtual const DWORD* GetHelpIDs() = 0;

	// Generated message map functions
	//{{AFX_MSG(CCSDialog)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	afx_msg LONG OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LONG OnHelpContextMenu(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};

class CCSPropertyPage : public CPropertyPage
{
// Construction
public:
	CCSPropertyPage(UINT nIDTemplate, UINT nIDCaption = 0);
	CCSPropertyPage(LPCTSTR lpszTemplateName, UINT nIDCaption = 0);

// Implementation
protected:
	virtual const DWORD* GetHelpIDs() = 0;

	// Generated message map functions
	//{{AFX_MSG(CCSPropertyPage)
	//}}AFX_MSG
	afx_msg LONG OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LONG OnHelpContextMenu(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};

class CCSPropertySheet : public CPropertySheet
{
// Construction
public:
	CCSPropertySheet(UINT nIDCaption, CWnd *pParentWnd = NULL,
		UINT iSelectPage = 0);
	CCSPropertySheet(LPCTSTR pszCaption, CWnd *pParentWnd = NULL,
		UINT iSelectPage = 0);
// Implementation
protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	// Generated message map functions
	//{{AFX_MSG(CCSPropertySheet)
	//}}AFX_MSG
	afx_msg LONG OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LONG OnHelpContextMenu(WPARAM wParam, LPARAM lParam);
   afx_msg BOOL OnNcCreate(LPCREATESTRUCT);
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\ddxm.cpp ===
// ddxm.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ddxm.h"
#include "wordpad.h"
#include "resource.h"

// this routine prints a floatingpoint number with 2 digits after the decimal
void PASCAL DDX_Twips(CDataExchange* pDX, int nIDC, int& value)
{
	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	TCHAR szT[64];

	if (pDX->m_bSaveAndValidate)
	{
		::GetWindowText(hWndCtrl, szT, sizeof(szT)/sizeof(szT[0]));
		if (szT[0] != NULL) // not empty
		{
			if (!theApp.ParseMeasurement(szT, value))
			{
				AfxMessageBox(IDS_INVALID_MEASUREMENT,MB_OK|MB_ICONINFORMATION);
				pDX->Fail();            // throws exception
			}
			theApp.PrintTwips(szT, value, 2);
			theApp.ParseMeasurement(szT, value);
		}
		else // empty
			value = INT_MAX;
	}
	else
	{
		// convert from twips to default units
		if (value != INT_MAX)
		{
			theApp.PrintTwips(szT, value, 2);
			SetWindowText(hWndCtrl, szT);
		}
	}
}

void PASCAL DDV_MinMaxTwips(CDataExchange* pDX, int value, int minVal, int maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
	{
		// "The measurement must be between %1 and %2."
		if (!pDX->m_bSaveAndValidate)
		{
			TRACE0("Warning: initial dialog data is out of range.\n");
			return;     // don't stop now
		}
		TCHAR szMin[32];
		TCHAR szMax[32];
		theApp.PrintTwips(szMin, minVal, 2);
		theApp.PrintTwips(szMax, maxVal, 2);
		CString prompt;
		AfxFormatString2(prompt, IDS_MEASUREMENT_RANGE, szMin, szMax);
		AfxMessageBox(prompt, MB_ICONEXCLAMATION, AFX_IDS_APP_TITLE);
		prompt.Empty(); // exception prep
		pDX->Fail();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\ddxm.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include <limits.h>
void PASCAL DDX_Twips(CDataExchange* pDX, int nIDC, int& value);
void PASCAL DDV_MinMaxTwips(CDataExchange* pDX, int value, int minVal, int maxVal);
#define DDXM_BLANK INT_MAX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\datedial.cpp ===
// datedial.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "datedial.h"
#include "helpids.h"
#include <winnls.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

SYSTEMTIME CDateDialog::m_time;
LCID CDateDialog::m_id;
CListBox* CDateDialog::m_pListBox = NULL;
PARAFORMAT CDateDialog::m_pf;

/////////////////////////////////////////////////////////////////////////////
// CDateDialog dialog

const DWORD CDateDialog::m_nHelpIDs[] =
{
	IDC_DATEDIALOG_LIST, IDH_WORDPAD_TIMEDATE,
	IDC_STATIC_HEADING, IDH_WORDPAD_TIMEDATE,
	0, 0
};

CDateDialog::CDateDialog(CWnd* pParent , PARAFORMAT& pf)
	: CCSDialog(CDateDialog::IDD, pParent)
{
	m_pf = pf;
	//{{AFX_DATA_INIT(CDateDialog)
	m_strSel = _T("");
	//}}AFX_DATA_INIT
}


void CDateDialog::DoDataExchange(CDataExchange* pDX)
{
	CCSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDateDialog)
	DDX_Control(pDX, IDC_DATEDIALOG_LIST, m_listBox);
	DDX_LBString(pDX, IDC_DATEDIALOG_LIST, m_strSel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDateDialog, CCSDialog)
	//{{AFX_MSG_MAP(CDateDialog)
	ON_LBN_DBLCLK(IDC_DATEDIALOG_LIST, OnDblclkDatedialogList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDateDialog message handlers

BOOL CDateDialog::OnInitDialog()
{
	CCSDialog::OnInitDialog();

	m_pListBox = &m_listBox; // set static member
	GetLocalTime(&m_time);
	m_id = GetUserDefaultLCID();

	// if we have Arabic/Hebrew locale
	if ((PRIMARYLANGID(LANGIDFROMLCID(m_id))== LANG_ARABIC) || 
		(PRIMARYLANGID(LANGIDFROMLCID(m_id))== LANG_HEBREW))
	{
		if(
		  (m_pf.wEffects & PFE_RTLPARA) &&
		  !(GetWindowLongPtr(m_pListBox->m_hWnd,GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
		  )
		{
			::SetWindowLongPtr (m_pListBox->m_hWnd , GWL_EXSTYLE , 
			   ::GetWindowLongPtr (m_pListBox->m_hWnd , GWL_EXSTYLE)|
			     WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR);
		}	
	}	
	
	EnumDateFormats(DateFmtEnumProc, m_id, DATE_SHORTDATE);
	EnumDateFormats(DateFmtEnumProc, m_id, DATE_LONGDATE);
	EnumTimeFormats(TimeFmtEnumProc, m_id, 0);

	m_pListBox = NULL;
	m_listBox.SetCurSel(0);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


// The following masks are defined in WinNls.h under #ifdef WINVER>=0x0500. so 
// even we included the header file, still we don't see it. I defined it as
// follows.

#ifndef DATE_LTRREADING 
#define DATE_LTRREADING 0x00000010
#endif //!DATE_LTRREADING 

#ifndef DATE_RTLREADING 
#define DATE_RTLREADING 0x00000020
#endif //!DATE_RTLREADING 

BOOL CALLBACK CDateDialog::DateFmtEnumProc(LPTSTR lpszFormatString)
{
	ASSERT(m_pListBox != NULL);

	TCHAR buffer[256];
    TCHAR *buf = buffer;
	DWORD dwFlags = 0;

	// if we have Arabic/Hebrew locale
	if ((PRIMARYLANGID(LANGIDFROMLCID(m_id))== LANG_ARABIC) || 
		(PRIMARYLANGID(LANGIDFROMLCID(m_id))== LANG_HEBREW))
	{
		if (m_pf.wEffects & PFE_RTLPARA)
			dwFlags |= DATE_RTLREADING;
		else
			dwFlags |= DATE_LTRREADING;
	}	

	VERIFY(GetDateFormat(m_id, dwFlags, &m_time, lpszFormatString, buf, 256));

    // Strip leading blanks

    while (_istspace(*buf))
        ++buf;

#ifndef _CHICAGO_
	if ((PRIMARYLANGID(LANGIDFROMLCID(m_id))== LANG_ARABIC) || 
		(PRIMARYLANGID(LANGIDFROMLCID(m_id))== LANG_HEBREW))
	{
		if (m_pf.wEffects & PFE_RTLPARA)
        	lstrcat(buf, TEXT("\x200F")); // Unicode RLM
		else
        	lstrcat(buf, TEXT("\x200E")); // Unicode LRM
	}	
#endif // !_CHICAGO_
	
	// we can end up with same format because a format with leading
	// zeroes may be the same as one without when a number is big enough
	// e.g. 09/10/94 9/10/94 are different but 10/10/94 and 10/10/94 are
	// the same
	if (m_pListBox->FindStringExact(-1,buf) == CB_ERR)
		m_pListBox->AddString(buf);
	return TRUE;
}

BOOL CALLBACK CDateDialog::TimeFmtEnumProc(LPTSTR lpszFormatString)
{
	ASSERT(m_pListBox != NULL);

	TCHAR buffer[256];
    TCHAR *buf = buffer;

	VERIFY(GetTimeFormat(m_id, 0, &m_time, lpszFormatString, buf, 256));

    // Strip leading blanks

    while (_istspace(*buf))
        ++buf;

	// we can end up with same format because a format with leading
	// zeroes may be the same as one without when a number is big enough
	// e.g. 09/10/94 9/10/94 are different but 10/10/94 and 10/10/94 are
	// the same
	if (m_pListBox->FindStringExact(-1,buf) == CB_ERR)
		m_pListBox->AddString(buf);
	return TRUE;
}

void CDateDialog::OnDblclkDatedialogList()
{
	OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\datedial.h ===
// datedial.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CDateDialog dialog

class CDateDialog : public CCSDialog
{
// Construction
public:
	CDateDialog(CWnd* pParent , PARAFORMAT& pf); // standard constructor

// Attributes
	static PARAFORMAT m_pf;
	static SYSTEMTIME m_time;
	static LCID m_id;
	static CListBox* m_pListBox;
	static BOOL CALLBACK DateFmtEnumProc(LPTSTR lpszFormatString);
	static BOOL CALLBACK TimeFmtEnumProc(LPTSTR lpszFormatString);

// Dialog Data
	//{{AFX_DATA(CDateDialog)
	enum { IDD = IDD_DATEDIALOG };
	CListBox	m_listBox;
	CString	m_strSel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDateDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}

	// Generated message map functions
	//{{AFX_MSG(CDateDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkDatedialogList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\dlgprnt2.cpp ===
// Copyright (C) 1992-1999 Microsoft Corporation
//
// This file is a snapshot of the version in MFC.  It contains fixes for dialog
// initialization that are not yet in the main version.

#include <afx.h>
#include <afxwin.h>
#include <afxdisp.h>
#include <afxole.h>
#include <afxpriv.h>


#include "afxprntx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW


INT_PTR CALLBACK AfxDlgProc(HWND, UINT, WPARAM, LPARAM);

/////////////////////////////////////////////////////////////////////////////
// Private class to support new NT5 printing user interface

//
//  IPrintDialogCallback interface id used by PrintDlgEx.
//
//  {5852A2C3-6530-11D1-B6A3-0000F8757BF9}
//
extern "C" const __declspec(selectany) IID IID_IPrintDialogCallback =
        {0x5852a2c3, 0x6530, 0x11d1, {0xb6, 0xa3, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9}};

BEGIN_INTERFACE_MAP(C_PrintDialogEx, CPrintDialog)
   INTERFACE_PART(C_PrintDialogEx, IID_IPrintDialogCallback, PrintDialogCallback)
END_INTERFACE_MAP()

C_PrintDialogEx::C_PrintDialogEx(BOOL bPrintSetupOnly,
        DWORD dwFlags, CWnd* pParentWnd)
        : CPrintDialog(bPrintSetupOnly, dwFlags, pParentWnd)
{
        memset(&m_pdex, 0, sizeof(m_pdex));
        m_pdex.lStructSize = sizeof(m_pdex);
        m_pdex.Flags = dwFlags;
}

INT_PTR C_PrintDialogEx::DoModal()
{
        ASSERT_VALID(this);

        m_pd.hwndOwner = PreModal();
        AfxUnhookWindowCreate();

        // expand m_pd data into the PRINTDLGEX structure

        m_pdex.hwndOwner = m_pd.hwndOwner;
        m_pdex.hDevMode = m_pd.hDevMode;
        m_pdex.hDevNames = m_pd.hDevNames;
        m_pdex.hDC = m_pd.hDC;
//        m_pdex.Flags = (m_pd.Flags & ~(PD_ENABLEPRINTHOOK | PD_ENABLESETUPHOOK | PD_PRINTSETUP));

        m_pdex.nMinPage = m_pd.nMinPage;
        m_pdex.nMaxPage = m_pd.nMaxPage;
        m_pdex.hInstance = m_pd.hInstance;
        m_pdex.nStartPage = START_PAGE_GENERAL;
        m_pdex.nCopies = m_pd.nCopies;
        m_pdex.lpCallback = &m_xPrintDialogCallback;

        // initialize page ranges

        PRINTPAGERANGE ourPageRange;

        if (m_pdex.Flags & PD_NOPAGENUMS)
        {
                m_pdex.lpPageRanges = NULL;
                m_pdex.nPageRanges = 0;
                m_pdex.nMaxPageRanges = 0;
        }
        else
        {
                ourPageRange.nFromPage = m_pd.nFromPage;
                ourPageRange.nToPage   = m_pd.nToPage;
                m_pdex.nPageRanges = 1;
                m_pdex.nMaxPageRanges = 1;
                m_pdex.lpPageRanges = &ourPageRange;
        }

        HMODULE hCommDlg = GetModuleHandleA("COMDLG32.DLL");
        HRESULT (STDAPICALLTYPE* pfn)(LPPRINTDLGEX);
#ifdef UNICODE
        pfn = (HRESULT (STDAPICALLTYPE*)(LPPRINTDLGEX))
                                GetProcAddress(hCommDlg, "PrintDlgExW");
#else
        pfn = (HRESULT (STDAPICALLTYPE*)(LPPRINTDLGEX))
                                GetProcAddress(hCommDlg, "PrintDlgExA");
#endif

        HRESULT hResult = E_NOTIMPL;
        if (pfn != NULL)
        {
                _AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
                ASSERT(pThreadState->m_pAlternateWndInit == NULL);

//                pThreadState->m_pAlternateWndInit = this;

                hResult = pfn(&m_pdex);
                if (SUCCEEDED(hResult))
                        ASSERT(pThreadState->m_pAlternateWndInit == NULL);
                pThreadState->m_pAlternateWndInit = NULL;
        }

        // pull data back...

        PostModal();

        if (!(m_pdex.Flags & PD_NOPAGENUMS))
        {
                m_pd.nToPage = (WORD) m_pdex.lpPageRanges->nToPage;
                m_pd.nFromPage = (WORD) m_pdex.lpPageRanges->nFromPage;
                m_pd.nMinPage = (WORD) m_pdex.nMinPage;
                m_pd.nMaxPage = (WORD) m_pdex.nMaxPage;
        }

        m_pd.hDevMode = m_pdex.hDevMode;
        m_pd.hDevNames = m_pdex.hDevNames;
        m_pd.hDC = m_pdex.hDC;
        m_pd.nCopies = (WORD)m_pdex.nCopies;
        // calculate return code
        int nResult = IDCANCEL;
        if (SUCCEEDED(hResult))
        {
                if (m_pdex.dwResultAction == PD_RESULT_PRINT)
                        nResult = IDOK;
        }
        return nResult;
}


STDMETHODIMP_(ULONG) C_PrintDialogEx::XPrintDialogCallback::AddRef()
{
        METHOD_PROLOGUE_EX_(C_PrintDialogEx, PrintDialogCallback)
        return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) C_PrintDialogEx::XPrintDialogCallback::Release()
{
        METHOD_PROLOGUE_EX_(C_PrintDialogEx, PrintDialogCallback)
        return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP C_PrintDialogEx::XPrintDialogCallback::QueryInterface(
        REFIID iid, LPVOID* ppvObj)
{
        METHOD_PROLOGUE_EX_(C_PrintDialogEx, PrintDialogCallback)
        return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP C_PrintDialogEx::XPrintDialogCallback::InitDone()
{
        METHOD_PROLOGUE_EX(C_PrintDialogEx, PrintDialogCallback)
        return pThis->OnInitDone();
}

STDMETHODIMP C_PrintDialogEx::XPrintDialogCallback::SelectionChange()
{
        METHOD_PROLOGUE_EX(C_PrintDialogEx, PrintDialogCallback)
        return pThis->OnSelectionChange();
}

STDMETHODIMP C_PrintDialogEx::XPrintDialogCallback::HandleMessage(HWND hDlg,
        UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
        METHOD_PROLOGUE_EX(C_PrintDialogEx, PrintDialogCallback)
        return pThis->OnHandleMessage(hDlg, uMsg, wParam, lParam, pResult);
}

HRESULT C_PrintDialogEx::OnInitDone()
{
        return S_FALSE;
}

HRESULT C_PrintDialogEx::OnSelectionChange()
{
        return S_FALSE;
}

HRESULT C_PrintDialogEx::OnHandleMessage(HWND hDlg, UINT uMsg,
        WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
//        UNUSED_ALWAYS(hDlg);
        HRESULT hResult = S_FALSE;
/*
        _AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
        if (pThreadState->m_pAlternateWndInit != NULL)
        {
                ASSERT_KINDOF(C_PrintDialogEx, pThreadState->m_pAlternateWndInit);
                pThreadState->m_pAlternateWndInit->SubclassWindow(hDlg);
                pThreadState->m_pAlternateWndInit = NULL;
        }
        ASSERT(pThreadState->m_pAlternateWndInit == NULL);
*/
        if (uMsg == WM_INITDIALOG)
        {
                SubclassWindow(hDlg);
                *pResult = AfxDlgProc(hDlg, uMsg, wParam, lParam);
                hResult = S_FALSE;
        }

        return hResult;
}

IMPLEMENT_DYNAMIC(C_PrintDialogEx, CPrintDialog)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\dlgcomm.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "stdafx2.h"
#include <dlgs.h>

#ifdef AFX_AUX_SEG
#pragma code_seg(AFX_AUX_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

static const UINT nMsgLBSELCHANGE = ::RegisterWindowMessage(LBSELCHSTRING);
static const UINT nMsgSHAREVI = ::RegisterWindowMessage(SHAREVISTRING);
static const UINT nMsgFILEOK = ::RegisterWindowMessage(FILEOKSTRING);
static const UINT nMsgCOLOROK = ::RegisterWindowMessage(COLOROKSTRING);
static const UINT nMsgHELP = ::RegisterWindowMessage(HELPMSGSTRING);

UINT_PTR CALLBACK
_AfxCommDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	if (hWnd == NULL)
		return 0;
/*
	_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
	if (pThreadState->m_pAlternateWndInit != NULL)
	{
		ASSERT_KINDOF(CFileDialog,pThreadState->m_pAlternateWndInit);
		pThreadState->m_pAlternateWndInit->SubclassWindow(hWnd);
		pThreadState->m_pAlternateWndInit = NULL;
	}
	ASSERT(pThreadState->m_pAlternateWndInit == NULL);
*/
	if (message == WM_INITDIALOG)
		return (UINT)AfxDlgProc(hWnd, message, wParam, lParam);

	if (message == nMsgHELP ||
	   (message == WM_COMMAND && LOWORD(wParam) == pshHelp))
	{
		// just translate the message into the AFX standard help command.
		SendMessage(hWnd, WM_COMMAND, ID_HELP, 0);
		return 1;
	}

	if (message < 0xC000)
	{
		// not a ::RegisterWindowMessage message
		return 0;
	}

	// assume it is already wired up to a permanent one
	CDialog* pDlg = (CDialog*)CWnd::FromHandlePermanent(hWnd);
	ASSERT(pDlg != NULL);
	ASSERT_KINDOF(CDialog, pDlg);

	if (pDlg->IsKindOf(RUNTIME_CLASS(CFileDialog)))
	{
		// If we're exploring then we are not interested in the Registered messages
		if (((CFileDialog*)pDlg)->m_ofn.Flags & OFN_EXPLORER)
			return 0;
	}

	// RegisterWindowMessage - does not copy to lastState buffer, so
	// CWnd::GetCurrentMessage and CWnd::Default will NOT work
	// while in these handlers

	// Dispatch special commdlg messages through our virtual callbacks
	if (message == nMsgSHAREVI)
	{
		ASSERT_KINDOF(CFileDialog, pDlg);
		return ((CFileDialog*)pDlg)->OnShareViolation((LPCTSTR)lParam);
	}
	else if (message == nMsgFILEOK)
	{
		ASSERT_KINDOF(CFileDialog, pDlg);

		if (afxData.bWin4)
			((CFileDialog*)pDlg)->m_pofnTemp = (OPENFILENAME*)lParam;

		BOOL bResult = ((CFileDialog*)pDlg)->OnFileNameOK();

		((CFileDialog*)pDlg)->m_pofnTemp = NULL;

		return bResult;
	}
	else if (message == nMsgLBSELCHANGE)
	{
		ASSERT_KINDOF(CFileDialog, pDlg);
		((CFileDialog*)pDlg)->OnLBSelChangedNotify((UINT)wParam, LOWORD(lParam),
				HIWORD(lParam));
		return 0;
	}
	else if (message == nMsgCOLOROK)
	{
		ASSERT_KINDOF(CColorDialog, pDlg);
		return ((CColorDialog*)pDlg)->OnColorOK();
	}
/*
//
// _afxNMsgSETRGB causes problems with the build.   Since it's not used
// for anything anyway, don't use it.
//

	else if (message == _afxNMsgSETRGB)
	{
		// nothing to do here, since this is a SendMessage
		return 0;
	}
*/
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\doctype.h ===
// doctype.h : header file
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

#define RD_WINWORD2     0
#define RD_WINWORD6     1
#define RD_WORD97       2
#define RD_WORDPAD      3
#define RD_WRITE        4
#define RD_RICHTEXT     5
#define RD_TEXT         6
#define RD_OEMTEXT      7
#define RD_UNICODETEXT  8
#define RD_ALL          9
#define RD_EMBEDDED    10
#define RD_FEWINWORD5  11
#define NUM_DOC_TYPES  12

extern int RD_DEFAULT;
#define RD_NATIVE RD_RICHTEXT

typedef BOOL (*PISFORMATFUNC)(LPCSTR pszConverter, LPCSTR pszPathName);
inline BOOL IsTextType(int nType) 
{
    return ((nType==RD_TEXT) || (nType==RD_OEMTEXT) || (nType==RD_UNICODETEXT));
}

struct DocType
{
public:
	int nID;
	int idStr;
	BOOL bRead;
	BOOL bWrite;
	BOOL bDup;
	LPTSTR pszConverterName;
	CString GetString(int nID);
};

#define DOCTYPE_DOCTYPE 0
#define DOCTYPE_DESC 1
#define DOCTYPE_EXT 2
#define DOCTYPE_PROGID 3

#define DECLARE_DOCTYPE(name, b1, b2, b3, p) \
{RD_##name, IDS_##name##_DOC, b1, b2, b3, p}
#define DECLARE_DOCTYPE_SYN(actname, name, b1, b2, b3, p) \
{RD_##actname, IDS_##name##_DOC, b1, b2, b3, p}
#define DECLARE_DOCTYPE_NULL(name, b1, b2, b3, p) \
{RD_##name, NULL, b1, b2, b3, p}

extern DocType doctypes[NUM_DOC_TYPES];

int GetDocTypeFromName(
        LPCTSTR         pszPathName, 
        CFileException& fe, 
        bool            defaultToText = true);

#define NO_DEFAULT_TO_TEXT false

void ScanForConverters();
int GetIndexFromType(int nType, BOOL bOpen);
int GetTypeFromIndex(int nType, BOOL bOpen);
CString GetExtFromType(int nDocType);
CString GetFileTypes(BOOL bOpen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\dlgfnt.cpp ===
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "stdafx2.h"

#ifdef AFX_AUX_SEG
#pragma code_seg(AFX_AUX_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Choose Font dialog

CFontDialog2::CFontDialog2(LPLOGFONT lplfInitial, DWORD dwFlags, CDC* pdcPrinter,
	CWnd* pParentWnd) : CCommonDialog(pParentWnd)
{
	memset(&m_cf, 0, sizeof(m_cf));
	memset(&m_lf, 0, sizeof(m_lf));
	memset(&m_szStyleName, 0, sizeof(m_szStyleName));

	m_nIDHelp = AFX_IDD_FONT;

	m_cf.lStructSize = sizeof(m_cf);
	m_cf.lpszStyle = (LPTSTR)&m_szStyleName;
	m_cf.Flags = dwFlags | CF_ENABLEHOOK;
	if (!afxData.bWin4 && AfxHelpEnabled())
		m_cf.Flags |= CF_SHOWHELP;
	m_cf.lpfnHook = _AfxCommDlgProc;

	if (lplfInitial)
	{
		m_cf.lpLogFont = lplfInitial;
		m_cf.Flags |= CF_INITTOLOGFONTSTRUCT;
		memcpy(&m_lf, m_cf.lpLogFont, sizeof(m_lf));
	}
	else
	{
		m_cf.lpLogFont = &m_lf;
	}

	if (pdcPrinter)
	{
		ASSERT(pdcPrinter->m_hDC != NULL);
		m_cf.hDC = pdcPrinter->m_hDC;
		m_cf.Flags |= CF_PRINTERFONTS;
	}
}

CFontDialog2::CFontDialog2(const CHARFORMAT& charformat, DWORD dwFlags,
	CDC* pdcPrinter, CWnd* pParentWnd) : CCommonDialog(pParentWnd)
{
	memset(&m_cf, 0, sizeof(m_cf));
	memset(&m_lf, 0, sizeof(m_lf));
	memset(&m_szStyleName, 0, sizeof(m_szStyleName));

	m_nIDHelp = AFX_IDD_FONT;

	m_cf.lStructSize = sizeof(m_cf);
	m_cf.lpszStyle = (LPTSTR)&m_szStyleName;
	m_cf.Flags = dwFlags | CF_ENABLEHOOK | CF_INITTOLOGFONTSTRUCT;
	m_cf.Flags |= FillInLogFont(charformat);
	if (!afxData.bWin4 && AfxHelpEnabled())
		m_cf.Flags |= CF_SHOWHELP;
	m_cf.lpfnHook = _AfxCommDlgProc;

	m_cf.lpLogFont = &m_lf;

	if (pdcPrinter)
	{
		ASSERT(pdcPrinter->m_hDC != NULL);
		m_cf.hDC = pdcPrinter->m_hDC;
		m_cf.Flags |= CF_PRINTERFONTS;
	}
	if (charformat.dwMask & CFM_COLOR)
		m_cf.rgbColors = charformat.crTextColor;
}

INT_PTR CFontDialog2::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_cf.Flags & CF_ENABLEHOOK);
	ASSERT(m_cf.lpfnHook != NULL); // can still be a user hook

	m_cf.hwndOwner = PreModal();
	int nResult = ::ChooseFont(&m_cf);
	PostModal();

	if (nResult == IDOK)
	{
		// copy logical font from user's initialization buffer (if needed)
		memcpy(&m_lf, m_cf.lpLogFont, sizeof(m_lf));
		return IDOK;
	}
	return nResult ? nResult : IDCANCEL;
}

void CFontDialog2::GetCurrentFont(LPLOGFONT lplf)
{
	ASSERT(lplf != NULL);

	if (m_hWnd != NULL)
		SendMessage(WM_CHOOSEFONT_GETLOGFONT, 0, (DWORD_PTR)lplf);
	else
		*lplf = m_lf;
}

////////////////////////////////////////////////////////////////////////////
// CFontDialog2 CHARFORMAT helpers

DWORD CFontDialog2::FillInLogFont(const CHARFORMAT& cf)
{
	USES_CONVERSION;
	DWORD dwFlags = 0;
	if (cf.dwMask & CFM_SIZE)
	{
		CDC dc;
		dc.CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
		LONG yPerInch = dc.GetDeviceCaps(LOGPIXELSY);
		m_lf.lfHeight = -(int) ((cf.yHeight * yPerInch) / 1440);
	}
	else
		m_lf.lfHeight = 0;

	m_lf.lfWidth = 0;
	m_lf.lfEscapement = 0;
	m_lf.lfOrientation = 0;

	if ((cf.dwMask & (CFM_ITALIC|CFM_BOLD)) == (CFM_ITALIC|CFM_BOLD))
	{
		m_lf.lfWeight = (cf.dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;
		m_lf.lfItalic = (BYTE)((cf.dwEffects & CFE_ITALIC) ? TRUE : FALSE);
	}
	else
	{
		dwFlags |= CF_NOSTYLESEL;
		m_lf.lfWeight = FW_DONTCARE;
		m_lf.lfItalic = FALSE;
	}

	if ((cf.dwMask & (CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR)) ==
		(CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR))
	{
		dwFlags |= CF_EFFECTS;
		m_lf.lfUnderline = (BYTE)((cf.dwEffects & CFE_UNDERLINE) ? TRUE : FALSE);
		m_lf.lfStrikeOut = (BYTE)((cf.dwEffects & CFE_STRIKEOUT) ? TRUE : FALSE);
	}
	else
	{
		m_lf.lfUnderline = (BYTE)FALSE;
		m_lf.lfStrikeOut = (BYTE)FALSE;
	}

	if (cf.dwMask & CFM_CHARSET)
		m_lf.lfCharSet = cf.bCharSet;
	else
		dwFlags |= CF_NOSCRIPTSEL;
	m_lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
	m_lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	m_lf.lfQuality = DEFAULT_QUALITY;
	if (cf.dwMask & CFM_FACE)
	{
		m_lf.lfPitchAndFamily = cf.bPitchAndFamily;
		lstrcpy(m_lf.lfFaceName, cf.szFaceName);
	}
	else
	{
		m_lf.lfPitchAndFamily = DEFAULT_PITCH|FF_DONTCARE;
		m_lf.lfFaceName[0] = (TCHAR)0;
	}
	return dwFlags;
}

void CFontDialog2::GetCharFormat(CHARFORMAT& cf) const
{
	USES_CONVERSION;
	cf.dwEffects = 0;
	cf.dwMask = 0;
	if ((m_cf.Flags & CF_NOSTYLESEL) == 0)
	{
		cf.dwMask |= CFM_BOLD | CFM_ITALIC;
		cf.dwEffects |= (IsBold()) ? CFE_BOLD : 0;
		cf.dwEffects |= (IsItalic()) ? CFE_ITALIC : 0;
	}
	if ((m_cf.Flags & CF_NOSIZESEL) == 0)
	{
		cf.dwMask |= CFM_SIZE;
		//GetSize() returns in tenths of points so mulitply by 2 to get twips
		cf.yHeight = GetSize()*2;
	}

	if ((m_cf.Flags & CF_NOFACESEL) == 0)
	{
		cf.dwMask |= CFM_FACE;
		cf.bPitchAndFamily = m_cf.lpLogFont->lfPitchAndFamily;
		lstrcpy(cf.szFaceName, GetFaceName());
	}

	if (m_cf.Flags & CF_EFFECTS)
	{
		cf.dwMask |= CFM_UNDERLINE | CFM_STRIKEOUT | CFM_COLOR;
		cf.dwEffects |= (IsUnderline()) ? CFE_UNDERLINE : 0;
		cf.dwEffects |= (IsStrikeOut()) ? CFE_STRIKEOUT : 0;
		cf.crTextColor = GetColor();
	}
	if ((m_cf.Flags & CF_NOSCRIPTSEL) == 0)
	{
		cf.bCharSet = m_cf.lpLogFont->lfCharSet;
		cf.dwMask |= CFM_CHARSET;
	}
	cf.yOffset = 0;
}

////////////////////////////////////////////////////////////////////////////
// CFontDialog2 diagnostics

#ifdef _DEBUG
void CFontDialog2::Dump(CDumpContext& dc) const
{
	CDialog::Dump(dc);

	dc << "m_cf.hwndOwner = " << (UINT)m_cf.hwndOwner;
	dc << "\nm_cf.hDC = " << (UINT)m_cf.hDC;
	dc << "\nm_cf.iPointSize = " << m_cf.iPointSize;
	dc << "\nm_cf.Flags = " << (LPVOID)m_cf.Flags;
	dc << "\nm_cf.lpszStyle = " << m_cf.lpszStyle;
	dc << "\nm_cf.nSizeMin = " << m_cf.nSizeMin;
	dc << "\nm_cf.nSizeMax = " << m_cf.nSizeMax;
	dc << "\nm_cf.nFontType = " << m_cf.nFontType;
	dc << "\nm_cf.rgbColors = " << (LPVOID)m_cf.rgbColors;

	if (m_cf.lpfnHook == _AfxCommDlgProc)
		dc << "\nhook function set to standard MFC hook function";
	else
		dc << "\nhook function set to non-standard hook function";

	dc << "\n";
}
#endif //_DEBUG

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_DYNAMIC(CFontDialog2, CDialog)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\doctype.cpp ===
// doctype.cpp
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "resource.h"
#include "strings.h"

#include "multconv.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static const BYTE byteRTFPrefix[5] = {'{', '\\', 'r', 't', 'f'};
static const BYTE byteWord2Prefix[4] = {0xDB, 0xA5, 0x2D, 0x00};
static const BYTE byteCompFilePrefix[8] = {0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1};
static const BYTE byteWrite1Prefix[2] = {0x31, 0xBE};
static const BYTE byteWrite2Prefix[2] = {0x32, 0xBE};
static const BYTE byteWord5JPrefix[2] = {0x94, 0xA6};
static const BYTE byteWord5KPrefix[2] = {0x95, 0xA6};
static const BYTE byteWord5TPrefix[2] = {0x96, 0xA6};

//
// On Win64 the converters live in the same directory as Wordpad.
// On Win32 things are more complicated.  For Win2000 and Whistler they live
// in a location pointed to by the registry
//

#ifdef _WIN64

TCHAR szWordConverter[MAX_PATH] = TEXT("mswrd664.wpc");
TCHAR szWriteConverter[MAX_PATH] = TEXT("write64.wpc");
TCHAR szWord97Converter[MAX_PATH] = TEXT("mswrd864.wpc");

#define CONVERTERS_IN_WORDPAD_DIRECTORY

#else   // WIN32
//
// Registry paths to converter information.  Note that the array sizes must be
// at least MAX_PATH because the contents of the array will be replaced with
// the filesystem path in ScanForConverters.
//

#define CONVERTER_PATH(x) TEXT("Software\\Microsoft\\Shared Tools\\")   \
                            TEXT("Text Converters\\Import\\") TEXT(x)

TCHAR szWordConverter[MAX_PATH] = CONVERTER_PATH("MSWord6.wpc");
TCHAR szWriteConverter[MAX_PATH] = CONVERTER_PATH("MSWinWrite.wpc");
TCHAR szWord97Converter[MAX_PATH] = CONVERTER_PATH("MSWord8");

#undef CONVERTER_PATH

#endif // WIN32

int RD_DEFAULT = RD_RICHTEXT;

/////////////////////////////////////////////////////////////////////////////

static BOOL IsConverterFormat(LPCTSTR pszConverter, LPCTSTR pszPathName);

DocType doctypes[NUM_DOC_TYPES] =
{
    DECLARE_DOCTYPE(WINWORD2, FALSE, FALSE, FALSE, NULL),
    DECLARE_DOCTYPE(WINWORD6, TRUE, FALSE, FALSE, szWordConverter),
    DECLARE_DOCTYPE(WORD97, TRUE, FALSE, FALSE, szWord97Converter),
    DECLARE_DOCTYPE_SYN(WORDPAD, RICHTEXT, TRUE, TRUE, TRUE, NULL),
    DECLARE_DOCTYPE(WRITE, TRUE, FALSE, FALSE, szWriteConverter),
    DECLARE_DOCTYPE(RICHTEXT, TRUE, TRUE, FALSE, NULL),
    DECLARE_DOCTYPE(TEXT, TRUE, TRUE, FALSE, NULL),
    DECLARE_DOCTYPE(OEMTEXT, TRUE, TRUE, FALSE, NULL),
    DECLARE_DOCTYPE(UNICODETEXT, TRUE, TRUE, FALSE, NULL),
    DECLARE_DOCTYPE(ALL, TRUE, FALSE, FALSE, NULL),
    DECLARE_DOCTYPE_NULL(EMBEDDED, FALSE, FALSE, FALSE, NULL)
};

CString DocType::GetString(int nID)
{
	ASSERT(idStr != NULL);
	CString str;
	VERIFY(str.LoadString(idStr));
	CString strSub;
	AfxExtractSubString(strSub, str, nID);
	return strSub;
}

static BOOL IsConverterFormat(LPCTSTR pszConverter, LPCTSTR pszPathName)
{
	CConverter conv(pszConverter);
	return conv.IsFormatCorrect(pszPathName);
}

static BOOL IsLeadMatch(CFile& file, const BYTE* pb, UINT nCount)
{
	// check for match at beginning of file
	BOOL b = FALSE;
	BYTE* buf = new BYTE[nCount];
	
	TRY
	{
		file.SeekToBegin();
		memset(buf, 0, nCount);
		file.Read(buf, nCount);
		if (memcmp(buf, pb, nCount) == 0)
			b = TRUE;
	}
	END_TRY

	delete [] buf;
	return b;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDocTypeFromName
//
//  Synopsis:   Give a filename, determine what sort of document it is
//  
//  Parameters: [pszPathName]   -- The filename
//              [fe]            -- Exception that caused file.open to fail
//              [defaultToText] -- See notes below
//
//  Returns:    The file type or -1 for unknown/error
//
//  Notes:      The converters don't support Unicode but the filenames do.
//              This causes problems because even though the initial check
//              for file existance will succeed the converter will be unable
//              to load the file.  We get around this by trying to load the
//              file a second time using the shortname.  However, the behavior
//              if we can't load the file as it's native type is to load it as
//              a text file.  [defaultToText] is used to suppress this on the
//              first try so we know to try again.
//
//----------------------------------------------------------------------------

int GetDocTypeFromName(
        LPCTSTR pszPathName, 
        CFileException& fe, 
        bool defaultToText)
{
	CFile file;
	ASSERT(pszPathName != NULL);
	
	ScanForConverters();

	if (!file.Open(pszPathName, CFile::modeRead | CFile::shareDenyWrite, &fe))
		return -1;

	CFileStatus _stat;
	VERIFY(file.GetStatus(_stat));

	if (_stat.m_size == 0) // file is empty
	{
		CString ext = CString(pszPathName).Right(4);
		if (ext[0] != '.')
			return RD_TEXT;
		if (lstrcmpi(ext, _T(".doc"))==0)
			return RD_WORDPAD;
		if (lstrcmpi(ext, _T(".rtf"))==0)
			return RD_RICHTEXT;
		return RD_TEXT;
	}

	// RTF
	if (IsLeadMatch(file, byteRTFPrefix, sizeof(byteRTFPrefix)))
		return RD_RICHTEXT;

	// WORD 2
	if (IsLeadMatch(file, byteWord2Prefix, sizeof(byteWord2Prefix)))
		return RD_WINWORD2;
    
    // FarEast Word5, which is based on US Word 2
    if (IsLeadMatch(file, byteWord5JPrefix, sizeof(byteWord5JPrefix)) ||
        IsLeadMatch(file, byteWord5KPrefix, sizeof(byteWord5KPrefix)) ||
        IsLeadMatch(file, byteWord5TPrefix, sizeof(byteWord5TPrefix)))
    {
        return RD_FEWINWORD5;
    }
    
	// write file can start with 31BE or 32BE depending on whether it has
	// OLE objects in it or not
	if (IsLeadMatch(file, byteWrite1Prefix, sizeof(byteWrite1Prefix)) ||
		IsLeadMatch(file, byteWrite2Prefix, sizeof(byteWrite2Prefix)))
	{
		file.Close();
		if (IsConverterFormat(szWriteConverter, pszPathName))
			return RD_WRITE;
		else if (defaultToText)
			return RD_TEXT;
        else 
            return -1;
	}

	// test for compound file
	if (IsLeadMatch(file, byteCompFilePrefix, sizeof(byteCompFilePrefix)))
	{
		file.Close();

		if (IsConverterFormat(szWordConverter, pszPathName))
        {
            return RD_WINWORD6;
        }
		else if (IsConverterFormat(szWord97Converter, pszPathName))
        {
			return RD_WORD97;
        }
        else if (defaultToText)
        {
		    return RD_TEXT;
        }
        
        return -1;
	}

    //
    // If we get here we know the file exists but it is NOT any of the above
    // types.  Therefore it is either a text file or we need to open it as
    // a text file.  Either way we are justified in returning RD_TEXT
    // regardless of the defaultToText setting.
    //

    return RD_TEXT;
}

//+--------------------------------------------------------------------------
//
//  Function:   ScanForConverters
//
//  Synopsis:   Check for any text converters
//
//  Parameters: None
//  
//  Returns:    void
//
//  Notes:      This routine will update the entries in the global doctypes
//              structure.  It should be called before trying to use the
//              converters.  The code will only run once, even if it is called
//              multiple times.
//
//              The doctypes structure is expected to be initialized with the
//              registry path to the converter.  This path is replaced with 
//              the filesystem path or NULL if an error occurs.
//
//---------------------------------------------------------------------------

void ScanForConverters()
{
#ifdef _DEBUG
#define TRACE_ERROR(error, api, string)                                     \
        {if (ERROR_SUCCESS != error)                                        \
                TRACE(                                                      \
                    TEXT("Wordpad: error 0x%08x from %s looking for")       \
                                    TEXT("\r\n\t%s\r\n"),                   \
                    error,                                                  \
                    api,                                                    \
                    string);                                                \
        }
#else // !_DEBUG
#define TRACE_ERROR(error, api, string)
#endif // !_DEBUG

    static BOOL bScanned = FALSE;

    if (bScanned)
        return;
    
    TCHAR   szExpandedPath[MAX_PATH];
    DWORD   error = ERROR_SUCCESS;

    for (int i = 0; i < NUM_DOC_TYPES; i++)
    {
		//
		// If this type is a duplicate of some other type don't try to search
		// for the converter twice
		//

		if (doctypes[i].bDup)
			continue;

        LPCTSTR pszConverterKey = doctypes[i].pszConverterName;

        if (NULL != pszConverterKey)
        {
#ifndef CONVERTERS_IN_WORDPAD_DIRECTORY

            TCHAR   szConverterPath[MAX_PATH];
            DWORD   cbConverterPath = sizeof(szConverterPath);
            HKEY    keyConverter;

            error = RegOpenKey(
                            HKEY_LOCAL_MACHINE, 
                            pszConverterKey, 
                            &keyConverter);
    
            TRACE_ERROR(error, TEXT("RegOpenKey"), pszConverterKey);

            if (ERROR_SUCCESS == error)
            {                                
                error = RegQueryValueEx(
                                    keyConverter,
                                    TEXT("Path"),
                                    NULL,
                                    NULL,
                                    (LPBYTE) szConverterPath,
                                    &cbConverterPath);

                TRACE_ERROR(error, TEXT("RegQueryValueEx"), TEXT("Path"));

                RegCloseKey(keyConverter);

                if (ERROR_SUCCESS == error)
                {
                    if (0 == ExpandEnvironmentStrings(
                                        szConverterPath,
                                        szExpandedPath,
                                        MAX_PATH))
                    {
                        error = GetLastError();
                        TRACE_ERROR(
                                error,
                                TEXT("ExpandEnvironmentStrings"),
                                szConverterPath);
                    }
                }


#else

            int     chars = GetModuleFileName(NULL, szExpandedPath, sizeof(szExpandedPath));
            LPTSTR  pszConverterName = NULL;

            if (0 != chars)
                pszConverterName = _tcsrchr(szExpandedPath, '\\');

            if (NULL != pszConverterName)
            {
                _tcscpy(pszConverterName + 1, doctypes[i].pszConverterName);

#endif

                                    
                if (ERROR_SUCCESS == error)
                {
                    //
                    // The FILE_ATTRIBUTE_DIRECTORY bit will also be set if an
                    // error occurs - like file not found.
                    //

                    error = GetFileAttributes(szExpandedPath)
                                & FILE_ATTRIBUTE_DIRECTORY;

                    TRACE_ERROR(
                        error, 
                        TEXT("GetFileAttribytes"), 
                        szExpandedPath);
                }
            }

            if (ERROR_SUCCESS == error)
                _tcscpy(doctypes[i].pszConverterName, szExpandedPath);   
            else
                doctypes[i].pszConverterName = NULL;
        }
    }

    bScanned = TRUE;
}

CString GetExtFromType(int nDocType)
{
	ScanForConverters();

	CString str = doctypes[nDocType].GetString(DOCTYPE_EXT);
	if (!str.IsEmpty())
	{
		ASSERT(str.GetLength() == 5); // "*.ext"
		ASSERT(str[1] == '.');
		return str.Right(str.GetLength()-1);
	}
	return str;
}

// returns an RD_* from an index into the openfile dialog types
int GetTypeFromIndex(int nIndex, BOOL bOpen)
{
	ScanForConverters();

    //
    // Word97 is excluded from the list of open file types in GetFileTypes.
    // Make up for it here.
    //

    if (bOpen)
        ++nIndex;

	int nCnt = 0;
	for (int i=0;i<NUM_DOC_TYPES;i++)
	{
		if (!doctypes[i].bDup &&
			(bOpen ? doctypes[i].bRead : doctypes[i].bWrite))
		{
			if (nCnt == nIndex)
				return i;
			nCnt++;
		}
	}
	ASSERT(FALSE);
	return -1;
}

// returns an index into the openfile dialog types for the RD_* type
int GetIndexFromType(int nType, BOOL bOpen)
{
	ScanForConverters();

	int nCnt = 0;
	for (int i=0;i<NUM_DOC_TYPES;i++)
	{
		if (!doctypes[i].bDup &&
			(bOpen ? doctypes[i].bRead : doctypes[i].bWrite))
		{
			if (i == nType)
				return nCnt;
			nCnt++;
		}
	}
	return -1;
}

CString GetFileTypes(BOOL bOpen)
{
	ScanForConverters();

	CString str;
	for (int i=0;i<NUM_DOC_TYPES;i++)
	{
		if (bOpen && doctypes[i].bRead 
			&& !doctypes[i].bDup 
			&& !(RD_WORD97 == doctypes[i].nID))
		{
			str += doctypes[i].GetString(DOCTYPE_DESC);
			str += (TCHAR)NULL;
			str += doctypes[i].GetString(DOCTYPE_EXT);
			str += (TCHAR)NULL;
		}
		else if (!bOpen && doctypes[i].bWrite && !doctypes[i].bDup)
		{
			str += doctypes[i].GetString(DOCTYPE_DOCTYPE);
			str += (TCHAR)NULL;
			str += doctypes[i].GetString(DOCTYPE_EXT);
			str += (TCHAR)NULL;
		}
	}
	return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\docopt.cpp ===
// docopt.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "docopt.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDocOptPage property page

const DWORD CDocOptPage::m_nHelpIDs[] = 
{
	IDC_BOX, (DWORD) -1,
	IDC_WRAP_NONE, IDH_WORDPAD_WRAP_NO,
	IDC_WRAP_WINDOW, IDH_WORDPAD_WRAP_WINDOW,
	IDC_WRAP_RULER, IDH_WORDPAD_WRAP_RULER,
	IDC_BOXT, (DWORD) -1,
	IDC_CHECK_TOOLBAR, IDH_WORDPAD_CHECK_TOOLBAR,
	IDC_CHECK_FORMATBAR, IDH_WORDPAD_CHECK_FORMATBAR,
	IDC_CHECK_STATUSBAR, IDH_WORDPAD_CHECK_STATUSBAR,
	IDC_CHECK_RULERBAR, IDH_WORDPAD_CHECK_RULERBAR,
    AFX_IDC_TAB_CONTROL, (DWORD) -1,
	0, 0
};

CDocOptPage::CDocOptPage() : CCSPropertyPage(CDocOptPage::IDD)
{
	//{{AFX_DATA_INIT(CDocOptPage)
	m_nWordWrap = -1;
	m_bFormatBar = FALSE;
	m_bRulerBar = FALSE;
	m_bStatusBar = FALSE;
	m_bToolBar = FALSE;
	//}}AFX_DATA_INIT
}

CDocOptPage::CDocOptPage(UINT nIDCaption) : 
	CCSPropertyPage(CDocOptPage::IDD, nIDCaption)
{
	m_nWordWrap = -1;
	m_bFormatBar = FALSE;
	m_bRulerBar = FALSE;
	m_bStatusBar = FALSE;
	m_bToolBar = FALSE;
}

CDocOptPage::~CDocOptPage()
{
}

void CDocOptPage::DoDataExchange(CDataExchange* pDX)
{
	CCSPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDocOptPage)
	DDX_Radio(pDX, IDC_WRAP_NONE, m_nWordWrap);
	DDX_Check(pDX, IDC_CHECK_FORMATBAR, m_bFormatBar);
	DDX_Check(pDX, IDC_CHECK_RULERBAR, m_bRulerBar);
	DDX_Check(pDX, IDC_CHECK_STATUSBAR, m_bStatusBar);
	DDX_Check(pDX, IDC_CHECK_TOOLBAR, m_bToolBar);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDocOptPage, CCSPropertyPage)
	//{{AFX_MSG_MAP(CDocOptPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDocOptPage message handlers

/////////////////////////////////////////////////////////////////////////////
// CEmbeddedOptPage property page

CEmbeddedOptPage::CEmbeddedOptPage() : CDocOptPage(IDS_EMBEDDED_OPTIONS)
{
}

BOOL CEmbeddedOptPage::OnInitDialog()
{
	BOOL b = CDocOptPage::OnInitDialog();
	GetDlgItem(IDC_CHECK_STATUSBAR)->ShowWindow(SW_HIDE);
	return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\fixhelp.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

extern BOOL g_fDisableStandardHelp ;

extern HHOOK g_HelpFixHook ;

void FixHelp(CWnd* pWnd, BOOL fFixWndProc);

void SetHelpFixHook(void) ;

void RemoveHelpFixHook(void) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\docopt.h ===
// docopt.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CDocOptPage dialog

class CDocOptPage : public CCSPropertyPage
{
// Construction
public:
	CDocOptPage();
	CDocOptPage(UINT nIDCaption);
	~CDocOptPage();

// Dialog Data
	//{{AFX_DATA(CDocOptPage)
	enum { IDD = IDD_OPTIONS_WRAP };
	int		m_nWordWrap;
	BOOL	m_bFormatBar;
	BOOL	m_bRulerBar;
	BOOL	m_bStatusBar;
	BOOL	m_bToolBar;
	//}}AFX_DATA


// Overrides
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDocOptPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDocOptPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CEmbeddedOptPage : public CDocOptPage
{
// Construction
public:
	CEmbeddedOptPage();
// Overrides
	BOOL OnInitDialog();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\filenewd.cpp ===
// filenewd.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "filenewd.h"
#include "filedlg.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

DWORD const CFileNewDialog::m_nHelpIDs[] = 
{
	IDC_DATEDIALOG_LIST, IDH_WORDPAD_FILENEW_DOC,
    IDC_STATIC_HEADING, IDH_WORDPAD_FILENEW_DOC,
	0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CFileNewDialog dialog

CFileNewDialog::CFileNewDialog(CWnd* pParent /*=NULL*/)
	: CCSDialog(CFileNewDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFileNewDialog)
	m_nSel = -1;
	//}}AFX_DATA_INIT
}


void CFileNewDialog::DoDataExchange(CDataExchange* pDX)
{
	CCSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFileNewDialog)
	DDX_Control(pDX, IDC_DATEDIALOG_LIST, m_listbox);
	DDX_LBIndex(pDX, IDC_DATEDIALOG_LIST, m_nSel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFileNewDialog, CCSDialog)
	//{{AFX_MSG_MAP(CFileNewDialog)
	ON_LBN_DBLCLK(IDC_DATEDIALOG_LIST, OnDblclkDatedialogList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFileNewDialog message handlers

BOOL CFileNewDialog::OnInitDialog() 
{
	CCSDialog::OnInitDialog();

    static const struct
    {
        int     rdType;
        int     idsType;
    }
    FileTypes[] = 
    {
        {RD_RICHTEXT,    IDS_RTF_DOCUMENT},
        {RD_TEXT,        IDS_TEXT_DOCUMENT},
        {RD_UNICODETEXT, IDS_UNICODETEXT_DOCUMENT}
    };
 
	CString str;
    int     i;
    int     defType = CWordpadFileDialog::GetDefaultFileType();
    int     iSelected = 0;

    for (i = 0; i < sizeof(FileTypes)/sizeof(FileTypes[0]); i++)
    {
	    VERIFY(str.LoadString(FileTypes[i].idsType));
	    m_listbox.AddString(str);

        if (FileTypes[i].rdType == defType)
            iSelected = i; 
    }
    
	m_listbox.SetCurSel(iSelected);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CFileNewDialog::OnDblclkDatedialogList() 
{
	OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\fixhelp.cpp ===
// fixhelp.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "fixhelp.h"

BOOL g_fDisableStandardHelp = FALSE ;

HHOOK g_HelpFixHook = NULL;

LRESULT CALLBACK HelpFixControlProc(
    HWND  hwnd,
    UINT  uMsg,
    WPARAM wParam,
    LPARAM  lParam);

LRESULT CALLBACK HelpFixDialogProc(
    HWND  hwnd,
    UINT  uMsg,
    WPARAM wParam,
    LPARAM  lParam);

LRESULT CALLBACK HelpFixHook(
    int code,
    WPARAM wParam,
    LPARAM lParam) ;

class CWordPadCWnd : public CWnd
{
public:

	LRESULT CallDWP(UINT nMsg, WPARAM wParam, LPARAM lParam)
   {
	    return DefWindowProc(nMsg, wParam, lParam) ;
   }
} ;

void FixHelp(CWnd* pWnd, BOOL fFixWndProc)
{
    //
    // Subclass the main window proc if we are supposed to
	// and if MFC has alread subclassed it
    //

    if (fFixWndProc)
    {
        if (GetWindowLongPtr(pWnd->m_hWnd, GWLP_WNDPROC) == (LONG_PTR)AfxWndProc)
	     {
              SetWindowLongPtr(pWnd->m_hWnd, GWLP_WNDPROC,
                               (LONG_PTR)HelpFixDialogProc);
	     }
    }

	//
    // Search all child windows.  If their window proc
    // is AfxWndProc, then subclass with our window proc
	//

    CWnd* pWndChild = pWnd->GetWindow(GW_CHILD);
    while(pWndChild != NULL)
    {
        if (GetWindowLongPtr(pWndChild->GetSafeHwnd(), GWLP_WNDPROC) == (LONG_PTR)AfxWndProc)
        {
            SetWindowLongPtr(pWndChild->GetSafeHwnd(), GWLP_WNDPROC,
                              (LONG_PTR)HelpFixControlProc);
        }
        pWndChild = pWndChild->GetWindow(GW_HWNDNEXT);
    }
}

LRESULT CALLBACK HelpFixControlProc(
    HWND  hwnd,
	UINT  uMsg,
	WPARAM wParam,
    LPARAM  lParam)
{
    if (uMsg == WM_HELP)
    {
		//
        // bypass MFC's handler, message will be sent to
		// parent of the control
		//

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return AfxWndProc(hwnd,uMsg,wParam,lParam);
}

LRESULT CALLBACK HelpFixDialogProc(
    HWND  hwnd,
	UINT  uMsg,
	WPARAM wParam,
    LPARAM  lParam)
{
    if (uMsg == WM_HELP)
    {
		CWordPadCWnd* pWnd = (CWordPadCWnd *) CWnd::FromHandlePermanent(hwnd) ;

		//
        // bypass MFC's handler, message will be sent to window proc for
		// the dialog box
		//

		if (NULL != pWnd)
		{
            return pWnd->CallDWP(uMsg, wParam, lParam) ;
		}
    }
    return AfxWndProc(hwnd,uMsg,wParam,lParam);
}


void SetHelpFixHook(void)
{
   g_HelpFixHook = ::SetWindowsHookEx(
                        WH_CALLWNDPROC,
                        (HOOKPROC) HelpFixHook,
                        NULL,
                        ::GetCurrentThreadId());
}

void RemoveHelpFixHook(void)
{
    if (NULL != g_HelpFixHook)
        ::UnhookWindowsHookEx(g_HelpFixHook);

    g_HelpFixHook = NULL;
}

LRESULT CALLBACK HelpFixHook(
    int code,
    WPARAM wParam,
    LPARAM lParam)
{
    if (code < 0)
    {
        return ::CallNextHookEx(
                   g_HelpFixHook,
                   code,
                   wParam,
                   lParam) ;
    }

    CWPSTRUCT *pcwps = (CWPSTRUCT *) lParam ;

    if (pcwps->message == WM_INITDIALOG)
    {
        CWnd *pWnd = CWnd::FromHandlePermanent(pcwps->hwnd) ;

        if (pWnd != NULL)
        {
            FixHelp(pWnd, TRUE) ;
        }
    }

    return ::CallNextHookEx(
                g_HelpFixHook,
                code,
                wParam,
                lParam) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\filedlg.h ===
// filedlg.h : header file
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.
//
// This file is to support an extended file save dialog with a
// "Use this format by default" checkbox

//
// The shell guys insist that Wordpad call GetOpenFileName with the newest
// OPENFILENAME structure but MFC doesn't support it.  MFC also needs to be
// built with _WIN32_WINNT set to 0x0400 so Wordpad can't even see the new
// structure.  Since the shell guys won't change the way they define the
// structure so that Wordpad can see both versions, it has to be snapshotted
// here.
//

#if !defined(_WIN64)
#include <pshpack1.h>   // Must byte pack to match definition in commdlg.h
#endif

typedef struct tagOFN500A {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCSTR       lpstrFilter;
   LPSTR        lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPSTR        lpstrFile;
   DWORD        nMaxFile;
   LPSTR        lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCSTR       lpstrInitialDir;
   LPCSTR       lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCSTR       lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
   struct IMoniker **rgpMonikers;
   DWORD        cMonikers;
   DWORD        FlagsEx;
} OPENFILENAME500A, *LPOPENFILENAME500A;
typedef struct tagOFN500W {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCWSTR      lpstrFilter;
   LPWSTR       lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPWSTR       lpstrFile;
   DWORD        nMaxFile;
   LPWSTR       lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCWSTR      lpstrInitialDir;
   LPCWSTR      lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCWSTR      lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
   struct IMoniker **rgpMonikers;
   DWORD        cMonikers;
   DWORD        FlagsEx;
} OPENFILENAME500W, *LPOPENFILENAME500W;
#ifdef UNICODE
typedef OPENFILENAME500W OPENFILENAME500;
typedef LPOPENFILENAME500W LPOPENFILENAME500;
#else
typedef OPENFILENAME500A OPENFILENAME500;
typedef LPOPENFILENAME500A LPOPENFILENAME500;
#endif // UNICODE

#if !defined(_WIN64)
#include <poppack.h>
#endif

class CWordpadFileDialog : public CFileDialog
{
    DECLARE_DYNAMIC(CWordpadFileDialog);

public:

    CWordpadFileDialog(BOOL bOpenFileDialog);

    int GetFileType()                           {return m_doctype;}

    static void SetDefaultFileType(int doctype)
    {
        m_defaultDoctype = doctype;
        RD_DEFAULT = doctype;
    }
    static int  GetDefaultFileType()            {return m_defaultDoctype;}

    virtual INT_PTR DoModal();

protected:

            int     m_doctype;
    static  int     m_defaultDoctype;

    LPOFNHOOKPROC   m_original_hook;

    OPENFILENAME500 m_openfilename;

    static const DWORD m_nHelpIDs[];
    virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}

    static UINT_PTR CALLBACK FileDialogHookProc(HWND, UINT, WPARAM, LPARAM);

    virtual BOOL OnFileNameOK();
    virtual void OnTypeChange();
    virtual void OnInitDone();

    // Generated message map functions
    //{{AFX_MSG(CWordpadFileDialog)
    afx_msg void OnDefaultFormatClicked();
    //}}AFX_MSG
    afx_msg LONG OnHelp(WPARAM wParam, LPARAM lParam);
    afx_msg LONG OnHelpContextMenu(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\filenewd.h ===
// filenewd.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CFileNewDialog dialog

class CFileNewDialog : public CCSDialog
{
// Construction
public:
	CFileNewDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CFileNewDialog)
	enum { IDD = IDD_FILENEWDIALOG };
	CListBox	m_listbox;
	int		m_nSel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileNewDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}

	// Generated message map functions
	//{{AFX_MSG(CFileNewDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkDatedialogList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\filedlg.cpp ===
// filedlg.cpp : header file
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.
//
// This file is to support an extended file save dialog with a
// "Use this format by default" checkbox

#include "stdafx.h"
#include "wordpad.h"
#include "filedlg.h"
#include "ddxm.h"
#include "helpids.h"
#include <dlgs.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


DWORD const CWordpadFileDialog::m_nHelpIDs[] =
{
    IDC_DEFAULT_FORMAT, IDH_WORDPAD_DEFAULT_FORMAT,
    0, 0
};


int                  CWordpadFileDialog::m_defaultDoctype = RD_DEFAULT;



BEGIN_MESSAGE_MAP(CWordpadFileDialog, CFileDialog)
    //{{AFX_MSG_MAP(CWordpadFileDialog)
    ON_BN_CLICKED(IDC_DEFAULT_FORMAT, OnDefaultFormatClicked)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnHelpContextMenu)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

IMPLEMENT_DYNAMIC(CWordpadFileDialog, CFileDialog)




CWordpadFileDialog::CWordpadFileDialog(BOOL bOpenFileDialog)
      : CFileDialog(bOpenFileDialog)
{
    m_ofn.Flags |= OFN_ENABLESIZING;

    if (!m_bOpenFileDialog)
    {
        m_ofn.Flags |= OFN_ENABLETEMPLATE;
        m_ofn.lpTemplateName = TEXT("DefaultFormatDialog");
    }

    m_doctype = GetDefaultFileType();
}



void CWordpadFileDialog::OnDefaultFormatClicked()
{
    if (m_bOpenFileDialog)
        return;

    m_doctype = GetTypeFromIndex(
                        m_openfilename.nFilterIndex - 1, 
                        m_bOpenFileDialog);

    GetDlgItem(IDC_DEFAULT_FORMAT)->EnableWindow(FALSE);

    // Move the focus to the filename combobox.
    GetParent()->GetDlgItem(cmb13)->SetFocus();
}



BOOL CWordpadFileDialog::OnFileNameOK()
{
    BOOL ret = CFileDialog::OnFileNameOK();

    if (!m_bOpenFileDialog)
    {
        // returns 0 if ok, 1 if not ok...
        if (0 == ret)
            SetDefaultFileType(m_doctype);
    }

    return ret;
}



void CWordpadFileDialog::OnTypeChange()
{
    CFileDialog::OnTypeChange();

    if (m_bOpenFileDialog)
        return;

    int type = GetTypeFromIndex(
                        m_openfilename.nFilterIndex - 1, 
                        m_bOpenFileDialog);

    CWnd *checkbox = GetDlgItem(IDC_DEFAULT_FORMAT);

    checkbox->SendMessage(
                        BM_SETCHECK,
                        (type == m_doctype)
                                ? BST_CHECKED
                                : BST_UNCHECKED,
                        0);

    checkbox->EnableWindow(!(type == m_doctype));

    // 
    // Change the extension of the filename presented to the user to match
    // the new type
    //

    // If the user has "Hide extensions of known types" set all this is moot
    SHELLFLAGSTATE flags;
    SHGetSettings(&flags, SSF_SHOWEXTENSIONS);
    if (!flags.fShowExtensions)
        return;

    CString filespec;

    CommDlg_OpenSave_GetSpec(
            GetParent()->GetSafeHwnd(), 
            filespec.GetBufferSetLength(MAX_PATH), 
            MAX_PATH);
    filespec.ReleaseBuffer();

    if (filespec.IsEmpty())
        return;

    CString extension = GetExtFromType(type);
    int     extstart  = filespec.ReverseFind(TEXT('.'));

    if (-1 == extstart)
        extstart = filespec.GetLength();

    if (filespec.Mid(extstart) == extension)
        return;

    filespec = filespec.Mid(0, extstart) + extension;

    CommDlg_OpenSave_SetControlText(
            GetParent()->GetSafeHwnd(),
            edt1,
            (LPCTSTR) filespec);
}



void CWordpadFileDialog::OnInitDone()
{
    CFileDialog::OnInitDone();

    if (m_bOpenFileDialog)
        return;

    OnTypeChange();
}



LONG CWordpadFileDialog::OnHelp(WPARAM, LPARAM lParam)
{
        ::WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                AfxGetApp()->m_pszHelpFilePath,
                HELP_WM_HELP, (DWORD_PTR)GetHelpIDs());
        return 0;
}

LONG CWordpadFileDialog::OnHelpContextMenu(WPARAM wParam, LPARAM)
{
        ::WinHelp((HWND)wParam, AfxGetApp()->m_pszHelpFilePath,
                HELP_CONTEXTMENU, (DWORD_PTR)GetHelpIDs());
        return 0;
}


//
// MFC assumes that when a common dialog is created, the first message that
// gets sent to it's common message handing procedure will be to that window.
// This isn't always true and although it attempts to handle this doesn't get
// it right every time.  Fix it, at least for file dialogs, by making a 
// private message procedure that does the necessary initialization and then
// calls the original
//

UINT_PTR CALLBACK CWordpadFileDialog::FileDialogHookProc(
        HWND   hWnd,
        UINT   message,
        WPARAM wParam,
        LPARAM lParam)
{
    CWordpadFileDialog *_this;

    if (WM_INITDIALOG == message)
    {
        _this = (CWordpadFileDialog *) ((OPENFILENAME *) lParam)->lCustData;
        _this->SubclassWindow(hWnd);
    }
                     
    _this = (CWordpadFileDialog *) CWnd::FromHandlePermanent(hWnd);

    if (NULL != _this)
        return (_this->m_original_hook)(hWnd, message, wParam, lParam);
    else
        return 0;
}


INT_PTR CWordpadFileDialog::DoModal()
{
    ASSERT_VALID(this);
    ASSERT(m_ofn.Flags & OFN_ENABLEHOOK);
    ASSERT(m_ofn.lpfnHook != NULL); // can still be a user hook
#ifdef _MAC
    ASSERT((m_ofn.Flags & OFN_ALLOWMULTISELECT) == 0);
#endif

    // WINBUG: This is a special case for the file open/save dialog,
    //  which sometimes pumps while it is coming up but before it has
    //  disabled the main window.
    HWND hWndFocus = ::GetFocus();
    BOOL bEnableParent = FALSE;
    m_ofn.hwndOwner = PreModal();
    AfxUnhookWindowCreate();
    if (m_ofn.hwndOwner != NULL && ::IsWindowEnabled(m_ofn.hwndOwner))
    {
        bEnableParent = TRUE;
        ::EnableWindow(m_ofn.hwndOwner, FALSE);
    }

    _AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
    ASSERT(pThreadState->m_pAlternateWndInit == NULL);

    m_original_hook = m_ofn.lpfnHook;
    m_ofn.lpfnHook = FileDialogHookProc;
    m_ofn.lCustData = (LPARAM) this;

    ZeroMemory(&m_openfilename, sizeof(m_openfilename));
    CopyMemory(&m_openfilename, &m_ofn, sizeof(m_ofn));
    m_openfilename.lStructSize = sizeof(m_openfilename);

    int nResult;
    if (m_bOpenFileDialog)
        nResult = ::GetOpenFileName((OPENFILENAME*) &m_openfilename);
    else
        nResult = ::GetSaveFileName((OPENFILENAME*) &m_openfilename);

    CopyMemory(&m_ofn, &m_openfilename, sizeof(m_ofn));
    m_ofn.lStructSize = sizeof(m_ofn);

    m_ofn.lpfnHook = m_original_hook;

    if (nResult)
        ASSERT(pThreadState->m_pAlternateWndInit == NULL);
    pThreadState->m_pAlternateWndInit = NULL;

    // WINBUG: Second part of special case for file open/save dialog.
    if (bEnableParent)
        ::EnableWindow(m_ofn.hwndOwner, TRUE);
    if (::IsWindow(hWndFocus))
        ::SetFocus(hWndFocus);

    PostModal();
    return nResult ? nResult : IDCANCEL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\formatpa.cpp ===
// formatpa.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "formatpa.h"
#include "ddxm.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

const DWORD CFormatParaDlg::m_nHelpIDs[] = 
{
	IDC_EDIT_LEFT, IDH_WORDPAD_INDENT_LEFT,
	IDC_EDIT_RIGHT, IDH_WORDPAD_INDENT_RIGHT,
	IDC_EDIT_FIRST_LINE, IDH_WORDPAD_INDENT_FIRST,
	IDC_BOX, (DWORD) -1,
	IDC_COMBO_ALIGNMENT, IDH_WORDPAD_ALIGN,
	IDC_TEXT_ALIGNMENT, IDH_WORDPAD_ALIGN,
	0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CFormatParaDlg dialog

CFormatParaDlg::CFormatParaDlg(PARAFORMAT& pf, CWnd* pParent /*=NULL*/)
	: CCSDialog(CFormatParaDlg::IDD, pParent)
{
	m_pf = pf;
	if (m_pf.dwMask & PFM_ALIGNMENT)
	{
		if (m_pf.wAlignment & PFA_LEFT && m_pf.wAlignment & PFA_RIGHT)
			m_nAlignment = 2;
		else
			m_nAlignment = (m_pf.wAlignment & PFA_LEFT) ? 0 : 1;
	}
	else
		m_nAlignment = -1;
	//{{AFX_DATA_INIT(CFormatParaDlg)
	m_nFirst = 0;
	m_nLeft = 0;
	m_nRight = 0;
	//}}AFX_DATA_INIT
}

void CFormatParaDlg::DoDataExchange(CDataExchange* pDX)
{
	CCSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFormatParaDlg)
	DDX_CBIndex(pDX, IDC_COMBO_ALIGNMENT, m_nAlignment);
	DDX_Twips(pDX, IDC_EDIT_FIRST_LINE, m_nFirst);
	DDV_MinMaxTwips(pDX, m_nFirst, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_LEFT, m_nLeft);
	DDV_MinMaxTwips(pDX, m_nLeft, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_RIGHT, m_nRight);
	DDV_MinMaxTwips(pDX, m_nRight, -31680, 31680);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFormatParaDlg, CCSDialog)
	//{{AFX_MSG_MAP(CFormatParaDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFormatParaDlg message handlers

void CFormatParaDlg::OnOK()
{
	CCSDialog::OnOK();
	m_pf.dwMask = 0;
	if (m_nAlignment >= 0)
	{
		ASSERT(m_nAlignment < 3);
		m_pf.dwMask |= PFM_ALIGNMENT;
		m_pf.wAlignment = (WORD)((m_nAlignment == 0) ? PFA_LEFT : 
			(m_nAlignment == 1) ? PFA_RIGHT : PFA_CENTER);
	}

	//in case we have RTL Reading order, we need to reverse the sides indent.
	if ( m_pf.wEffects & PFE_RTLPARA )
	{
		if (m_nLeft != DDXM_BLANK)
			m_pf.dwMask |= PFM_RIGHTINDENT;
		if (m_nRight != DDXM_BLANK && m_nFirst != DDXM_BLANK)
			m_pf.dwMask |= PFM_STARTINDENT;
		if (m_nFirst != DDXM_BLANK)
			m_pf.dwMask |= PFM_OFFSET;

		m_pf.dxRightIndent = m_nLeft;
		m_pf.dxOffset = -m_nFirst;
		m_pf.dxStartIndent = m_nRight + m_nFirst;
	}
	else
	{
		if (m_nRight != DDXM_BLANK)
			m_pf.dwMask |= PFM_RIGHTINDENT;
		if (m_nLeft != DDXM_BLANK && m_nFirst != DDXM_BLANK)
			m_pf.dwMask |= PFM_STARTINDENT;
		if (m_nFirst != DDXM_BLANK)
			m_pf.dwMask |= PFM_OFFSET;

		m_pf.dxRightIndent = m_nRight;
		m_pf.dxOffset = -m_nFirst;
		m_pf.dxStartIndent = m_nLeft + m_nFirst;
	}	
}

BOOL CFormatParaDlg::OnInitDialog() 
{
	CComboBox* pBox = (CComboBox*)GetDlgItem(IDC_COMBO_ALIGNMENT);
	CString str;
	str.LoadString(IDS_LEFT);
	pBox->AddString(str);
	str.LoadString(IDS_RIGHT);
	pBox->AddString(str);
	str.LoadString(IDS_CENTER);
	pBox->AddString(str);

	if (m_nWordWrap == 0)
	{
		GetDlgItem(IDC_COMBO_ALIGNMENT)->EnableWindow(FALSE);
		GetDlgItem(IDC_TEXT_ALIGNMENT)->EnableWindow(FALSE);
	}

	if ( m_pf.wEffects & PFE_RTLPARA )
	{
		m_nLeft = (m_pf.dwMask & PFM_RIGHTINDENT) ? m_pf.dxRightIndent : DDXM_BLANK;
		if (m_pf.dwMask & PFM_OFFSET)
		{
			m_nFirst = -m_pf.dxOffset;
			m_nRight = (m_pf.dwMask & PFM_STARTINDENT) ? 
				m_pf.dxStartIndent + m_pf.dxOffset : DDXM_BLANK;
		}
		else
			m_nRight = m_nFirst = DDXM_BLANK;
	}
	else
	{

		m_nRight = (m_pf.dwMask & PFM_RIGHTINDENT) ? m_pf.dxRightIndent : DDXM_BLANK;
		if (m_pf.dwMask & PFM_OFFSET)
		{
			m_nFirst = -m_pf.dxOffset;
			m_nLeft = (m_pf.dwMask & PFM_STARTINDENT) ? 
				m_pf.dxStartIndent + m_pf.dxOffset : DDXM_BLANK;
		}
		else
			m_nLeft = m_nFirst = DDXM_BLANK;
	}
	
	CCSDialog::OnInitDialog();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\formatba.cpp ===
// formatba.cpp : implementation file
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

#include "stdafx.h"

#include "wordpad.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "formatba.h"
#include "strings.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// reserve lobyte for charset
#define PRINTER_FONT 0x0100
#define TT_FONT 0x0200
#define DEVICE_FONT 0x0400
#define PS_OPENTYPE_FONT  0x800
#define TT_OPENTYPE_FONT  0x1000
#define TYPE1_FONT  0x2000

#define BMW 16
#define BMH 15

static int nFontSizes[] =
    {8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72};
int CLocalComboBox::m_nFontHeight = 0;

class CFontDesc
{
public:
    CFontDesc(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet,
        BYTE nPitchAndFamily, DWORD dwFlags);
    CString m_strName;
    CString m_strScript;
    BYTE m_nCharSet;
    BYTE m_nPitchAndFamily;
    DWORD m_dwFlags;
};

CFontDesc::CFontDesc(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet,
    BYTE nPitchAndFamily, DWORD dwFlags)
{
    m_strName = lpszName;
    m_strScript = lpszScript;
    m_nCharSet = nCharSet;
    m_nPitchAndFamily = nPitchAndFamily;
    m_dwFlags = dwFlags;
}

BEGIN_MESSAGE_MAP(CFormatBar, CToolBar)
    //{{AFX_MSG_MAP(CFormatBar)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    ON_CBN_DROPDOWN(IDC_FONTSIZE, OnFontSizeDropDown)
    ON_CBN_DROPDOWN(IDC_SCRIPT, OnScriptDropDown)
    ON_CBN_KILLFOCUS(IDC_FONTNAME, OnFontNameKillFocus)
    ON_CBN_KILLFOCUS(IDC_FONTSIZE, OnFontSizeKillFocus)
    ON_CBN_KILLFOCUS(IDC_SCRIPT, OnScriptKillFocus)
    ON_CBN_SETFOCUS(IDC_FONTNAME, OnComboSetFocus)
    ON_CBN_SETFOCUS(IDC_FONTSIZE, OnComboSetFocus)
    ON_CBN_SETFOCUS(IDC_SCRIPT, OnComboSetFocus)
    ON_CBN_CLOSEUP(IDC_FONTNAME, OnComboCloseUp)
    ON_CBN_CLOSEUP(IDC_FONTSIZE, OnComboCloseUp)
    ON_CBN_CLOSEUP(IDC_SCRIPT, OnComboCloseUp)
    ON_REGISTERED_MESSAGE(CWordPadApp::m_nPrinterChangedMsg, OnPrinterChanged)
    // Global help commands
END_MESSAGE_MAP()

static CSize GetBaseUnits(CFont* pFont)
{
    ASSERT(pFont != NULL);
    ASSERT(pFont->GetSafeHandle() != NULL);
    pFont = theApp.m_dcScreen.SelectObject(pFont);
    TEXTMETRIC tm;
    VERIFY(theApp.m_dcScreen.GetTextMetrics(&tm));

    theApp.m_dcScreen.SelectObject(pFont);
    return CSize(tm.tmAveCharWidth, tm.tmHeight);
}

CFormatBar::CFormatBar()
{
    CFont fnt;
    fnt.Attach(GetStockObject(theApp.m_nDefFont));
    m_szBaseUnits = GetBaseUnits(&fnt);
    CLocalComboBox::m_nFontHeight = m_szBaseUnits.cy;
}

void CFormatBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
    CToolBar::OnUpdateCmdUI(pTarget, bDisableIfNoHndler);
    // don't update combo boxes if any of them have the focus
    if (!m_comboFontName.HasFocus()
        && !m_comboFontSize.HasFocus()
        && !m_comboScript.HasFocus())
    {
        SyncToView();
    }
}

void CFormatBar::SyncToView()
{
    USES_CONVERSION;
    // get the current font from the view and update
    CHARHDR fh;
    CHARFORMAT& cf = fh.cf;
    fh.hwndFrom = m_hWnd;
    fh.idFrom = GetDlgCtrlID();
    fh.code = FN_GETFORMAT;
    VERIFY(GetOwner()->SendMessage(WM_NOTIFY, fh.idFrom, (LPARAM)&fh));

    if (cf.dwMask & CFM_FACE)
        m_comboFontName.SetTheText(cf.szFaceName, TRUE);
    else
        m_comboFontName.SetTheText(TEXT(""));

    CString charsetname = TEXT("");
    if (cf.dwMask & CFM_CHARSET)
    {
        for (int i = 0; i < m_comboFontName.m_arrayFontDesc.GetSize(); i++)
        {
            CFontDesc *pDesc = (CFontDesc *) m_comboFontName.m_arrayFontDesc[i];

            if (pDesc->m_strName == cf.szFaceName
                && pDesc->m_nCharSet == cf.bCharSet)
            {
                charsetname = pDesc->m_strScript;
                break;
            }
        }
    }
    m_comboScript.SetTheText(charsetname);

    static bool init_script_history = true;

    if (init_script_history && TEXT('\0') != charsetname[0])
    {
        OnScriptDropDown();
        m_comboScript.PickScript();
        init_script_history = false;
    }

    // SetTwipSize only updates if different
    // -1 means selection is not a single point size
    m_comboFontSize.SetTwipSize( (cf.dwMask & CFM_SIZE) ? cf.yHeight : -1);
}

BYTE CScriptComboBox::PickScript()
{
    CString scriptname;
    int     scriptindex;

    GetTheText(scriptname);
    scriptindex = FindStringExact(-1, scriptname);

    if (CB_ERR == scriptindex)
    {
        int  i = m_history_index;

        do
        {
            scriptindex = FindStringExact(-1, m_script_history[i]);

            if (CB_ERR != scriptindex)
                break;

            i = (i + HistorySize - 1) % HistorySize;
        }
        while (i != m_history_index);

        if (CB_ERR == scriptindex)
        {
            if (1 != GetCount())
            {
                SetCurSel(-1);
                return DEFAULT_CHARSET;
            }

            scriptindex = 0;
        }

        SetCurSel(scriptindex);
        GetTheText(scriptname);
    }

    if (m_script_history[m_history_index] != scriptname)
    {
        m_history_index = (m_history_index + 1) % HistorySize;
        m_script_history[m_history_index] = scriptname;
    }

    return (BYTE) GetItemData(scriptindex);
}

void CFormatBar::OnFontSizeDropDown()
{
    CString str;
    m_comboFontName.GetTheText(str);
    LPCTSTR lpszName = NULL;
    BOOL bPrinterFont= FALSE;
    int nIndex = m_comboFontName.FindStringExact(-1, str);
    if (nIndex != CB_ERR)
    {
        CFontDesc* pDesc = (CFontDesc*)m_comboFontName.GetItemData(nIndex);
        ASSERT(pDesc != NULL);
        bPrinterFont = pDesc->m_dwFlags & PRINTER_FONT;
        lpszName = pDesc->m_strName;
    }

    int nSize = m_comboFontSize.GetTwipSize();
    if (nSize == -2) // error
    {
        AfxMessageBox(IDS_INVALID_NUMBER, MB_OK|MB_ICONINFORMATION);
        nSize = m_comboFontSize.m_nTwipsLast;
    }
    else if ((nSize >= 0 && nSize < 20) || nSize > 32760)
    {
        AfxMessageBox(IDS_INVALID_FONTSIZE, MB_OK|MB_ICONINFORMATION);
        nSize = m_comboFontSize.m_nTwipsLast;
    }

    if (bPrinterFont)
        m_comboFontSize.EnumFontSizes(m_dcPrinter, lpszName);
    else
        m_comboFontSize.EnumFontSizes(theApp.m_dcScreen, lpszName);
    m_comboFontSize.SetTwipSize(nSize);
}

void CFormatBar::OnScriptDropDown()
{
    CString fontname;
    CString scriptname;
    m_comboFontName.GetTheText(fontname);
    m_comboScript.GetTheText(scriptname);

    m_comboScript.ResetContent();
    m_comboScript.SetTheText(scriptname);

    for (int i = 0; i < m_comboFontName.m_arrayFontDesc.GetSize(); i++)
    {
        CFontDesc* pDesc = (CFontDesc*)m_comboFontName.m_arrayFontDesc[i];

        if (pDesc->m_strName == fontname)
        {
            // HACKHACK: GDI enumerates symbol type fonts multiple times.
            //           remove the duplicated charsets (ntbug:198753)

            if (CB_ERR == m_comboScript.FindStringExact(-1, pDesc->m_strScript))
            {
                int nIndex = m_comboScript.AddString(pDesc->m_strScript);
                m_comboScript.SetItemData(nIndex, pDesc->m_nCharSet);
            }
        }
    }
}

void CFormatBar::OnComboCloseUp()
{
    NotifyOwner(NM_RETURN);
}

void CFormatBar::OnComboSetFocus()
{
    NotifyOwner(NM_SETFOCUS);
}

void CFormatBar::OnFontNameKillFocus()
{
    USES_CONVERSION;
    // get the current font from the view and update
    NotifyOwner(NM_KILLFOCUS);

    CCharFormat cf;
    cf.szFaceName[0] = NULL;

    // this will retrieve the font entered in the edit control
    // it tries to match the font to something already present in the combo box
    // this effectively ignores case of a font the user enters
    // if a user enters arial, this will cause it to become Arial
    CString str;
    m_comboFontName.GetTheText(str);    // returns "arial"
    m_comboFontName.SetTheText(str);    // selects "Arial"
    m_comboFontName.GetTheText(str);    // returns "Arial"

    // if font name box is not empty
    if (str[0] != NULL)
    {
        cf.dwMask = CFM_FACE;
        int nIndex = m_comboFontName.FindStringExact(-1, str);
        if (nIndex != CB_ERR)
        {
            CFontDesc* pDesc = (CFontDesc*)m_comboFontName.GetItemData(nIndex);
            ASSERT(pDesc != NULL);
            ASSERT(pDesc->m_strName.GetLength() < LF_FACESIZE);
            lstrcpyn(cf.szFaceName, pDesc->m_strName, LF_FACESIZE);
            cf.bPitchAndFamily = pDesc->m_nPitchAndFamily;
        }
        else // unknown font
        {
            ASSERT(str.GetLength() < LF_FACESIZE);
            lstrcpyn(cf.szFaceName, str, LF_FACESIZE);
            cf.bPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
        }

        OnScriptDropDown();
        cf.bCharSet = m_comboScript.PickScript();
        cf.dwMask |= CFM_CHARSET;
        SetCharFormat(cf);
    }
}

void CFormatBar::OnFontSizeKillFocus()
{
    NotifyOwner(NM_KILLFOCUS);
    int nSize = m_comboFontSize.GetTwipSize();
    if (nSize == -2)
    {
        AfxMessageBox(IDS_INVALID_NUMBER, MB_OK|MB_ICONINFORMATION);
        nSize = m_comboFontSize.m_nTwipsLast;
    }
    else if ((nSize >= 0 && nSize < 20) || nSize > 32760)
    {
        AfxMessageBox(IDS_INVALID_FONTSIZE, MB_OK|MB_ICONINFORMATION);
        nSize = m_comboFontSize.m_nTwipsLast;
    }
    else if (nSize > 0)
    {
        CCharFormat cf;
        cf.dwMask = CFM_SIZE;
        cf.yHeight = nSize;
        SetCharFormat(cf);
    }
}

void CFormatBar::OnScriptKillFocus()
{
    NotifyOwner(NM_KILLFOCUS);

    CString str;
    m_comboScript.GetTheText(str);
    m_comboScript.SetTheText(str);
    m_comboScript.GetTheText(str);

    if (str[0] != NULL)
    {
        CCharFormat cf;
        cf.dwMask = CFM_CHARSET;
        cf.bCharSet = m_comboScript.PickScript();
        SetCharFormat(cf);
    }
}

LONG CFormatBar::OnPrinterChanged(UINT, LONG)
{
    theApp.CreatePrinterDC(m_dcPrinter);
    m_comboFontName.EnumFontFamiliesEx(m_dcPrinter);
    return 0;
}

int CFormatBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CToolBar::OnCreate(lpCreateStruct) == -1)
        return -1;

    theApp.m_listPrinterNotify.AddTail(m_hWnd);

    CRect rect(0,0, LF_FACESIZE*m_szBaseUnits.cx, 200);
    if (!m_comboFontName.Create(WS_TABSTOP|WS_VISIBLE|WS_TABSTOP|
        WS_VSCROLL|CBS_DROPDOWN|CBS_SORT|CBS_AUTOHSCROLL|CBS_HASSTRINGS|
        CBS_OWNERDRAWFIXED, rect, this, IDC_FONTNAME))
    {
        TRACE0("Failed to create fontname combo-box\n");
        return -1;
    }
    m_comboFontName.LimitText(LF_FACESIZE);

    rect.SetRect(0, 0, 10*m_szBaseUnits.cx, 200);
    if (!m_comboFontSize.Create(WS_TABSTOP|WS_VISIBLE|WS_TABSTOP|
        WS_VSCROLL|CBS_DROPDOWN, rect, this, IDC_FONTSIZE))
    {
        TRACE0("Failed to create fontsize combo-box\n");
        return -1;
    }

    rect.SetRect(0, 0, 3*LF_FACESIZE*m_szBaseUnits.cx/4, 200);
    if (!m_comboScript.Create(WS_TABSTOP|WS_VISIBLE|WS_TABSTOP|
        WS_VSCROLL|CBS_DROPDOWN|CBS_SORT|CBS_AUTOHSCROLL|CBS_HASSTRINGS,
        rect, this, IDC_SCRIPT))
    {
        TRACE0("Failed to create script combo-box\n");
        return -1;
    }

    m_comboFontSize.LimitText(4);
    m_comboFontName.EnumFontFamiliesEx(m_dcPrinter);

    return 0;
}

void CFormatBar::OnDestroy()
{
    CToolBar::OnDestroy();
    POSITION pos = theApp.m_listPrinterNotify.Find(m_hWnd);
    ASSERT(pos != NULL);
    theApp.m_listPrinterNotify.RemoveAt(pos);
}

void CFormatBar::PositionCombos()
{
    CRect rect;
    // make font name box same size as font size box
    // this is necessary since font name box is owner draw
    m_comboFontName.SetItemHeight(-1, m_comboFontSize.GetItemHeight(-1));

    m_comboFontName.GetWindowRect(&rect);
    int nHeight = rect.Height();

    m_comboFontName.GetWindowRect(&rect);
    SetButtonInfo(0, IDC_FONTNAME, TBBS_SEPARATOR, rect.Width());
    GetItemRect(0, &rect); // FontName ComboBox
    m_comboFontName.SetWindowPos(NULL, rect.left,
        ((rect.Height() - nHeight) / 2) + rect.top, 0, 0,
        SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    m_comboFontSize.GetWindowRect(&rect);
    SetButtonInfo(2, IDC_FONTSIZE, TBBS_SEPARATOR, rect.Width());
    GetItemRect(2, &rect); // FontSize ComboBox
    m_comboFontSize.SetWindowPos(NULL, rect.left,
        ((rect.Height() - nHeight) / 2) + rect.top, 0, 0,
        SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    m_comboScript.GetWindowRect(&rect);
    SetButtonInfo(4, IDC_SCRIPT, TBBS_SEPARATOR, rect.Width());
    GetItemRect(4, &rect); // Script ComboBox
    m_comboScript.SetWindowPos(NULL, rect.left,
        ((rect.Height() - nHeight) / 2) + rect.top, 0, 0,
        SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
}

/////////////////////////////////////////////////////////////////////////////
// CFontComboBox

BEGIN_MESSAGE_MAP(CFontComboBox, CLocalComboBox)
    //{{AFX_MSG_MAP(CFontComboBox)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    // Global help commands
END_MESSAGE_MAP()

CFontComboBox::CFontComboBox()
{
    VERIFY(m_bmFontType.LoadBitmap(IDB_FONTTYPE));
}

void CFontComboBox::OnDestroy()
{
    // destroy all the CFontDesc's
    EmptyContents();
    CLocalComboBox::OnDestroy();
}

void CFontComboBox::EmptyContents()
{
    // destroy all the CFontDesc's
    int nCount = GetCount();
    for (int i=0;i<nCount;i++)
    {
        delete (CFontDesc*)GetItemData(i);
        SetItemData(i, NULL);
    }
}

void CFontComboBox::EnumFontFamiliesEx(CDC& dc, BYTE nCharSet)
{
    CString str;
    GetTheText(str);

    EmptyContents();
    ResetContent();
    m_arrayFontDesc.RemoveAll();

    LOGFONT lf;
    memset(&lf, 0, sizeof(LOGFONT));
    lf.lfCharSet = nCharSet;

    if (dc.m_hDC != NULL)
    {
        ::EnumFontFamiliesEx(dc.m_hDC, &lf,
                (FONTENUMPROC) EnumFamPrinterCallBackEx, (LPARAM) this, NULL);
    }
    else
    {
        HDC hDC = theApp.m_dcScreen.m_hDC;
        ASSERT(hDC != NULL);

        ::EnumFontFamiliesEx(hDC, &lf,
                (FONTENUMPROC) EnumFamScreenCallBackEx, (LPARAM) this, NULL);
    }

    // Add the fonts to the dropdown.  Don't add fonts that differ only by
    // charset.

    int nCount = (int)m_arrayFontDesc.GetSize();

    for (int i = 0; i < nCount; i++)
    {
        CFontDesc *pDesc = (CFontDesc*) m_arrayFontDesc[i];

        for (int j = i - 1; j >= 0; --j)
        {
            CFontDesc *otherfont = (CFontDesc*) m_arrayFontDesc[j];

            if (pDesc->m_strName == otherfont->m_strName
                && pDesc->m_dwFlags == otherfont->m_dwFlags)
            {
                break;
            }
        }

        if (j < 0)
        {
            int nIndex = AddString(pDesc->m_strName);
            ASSERT(nIndex >= 0);
            if (nIndex >= 0)
                SetItemData(nIndex, (DWORD_PTR)pDesc);
        }
    }

    SetTheText(str);
}

void CFontComboBox::AddFont(ENUMLOGFONT* pelf, DWORD dwType, LPCTSTR lpszScript)
{
    LOGFONT& lf = pelf->elfLogFont;

    if (lf.lfCharSet == MAC_CHARSET) // don't put in MAC fonts, commdlg doesn't either
        return;

    CFontDesc* pDesc = new CFontDesc(lf.lfFaceName, lpszScript,
        lf.lfCharSet, lf.lfPitchAndFamily, dwType);
    m_arrayFontDesc.Add(pDesc);
}

VOID   vGetFontType(NEWTEXTMETRICEX* lpntm, int FontType, DWORD* pdwData)
{
    DWORD  ntmFlags = lpntm->ntmTm.ntmFlags;

    if (ntmFlags & NTM_PS_OPENTYPE)
    {
        *pdwData |= PS_OPENTYPE_FONT;
    }
    else if (ntmFlags & NTM_TYPE1)
    {
        *pdwData |= TYPE1_FONT;
    }
    else
    {
        if (FontType & TRUETYPE_FONTTYPE)
        {
            if (ntmFlags & NTM_TT_OPENTYPE)
                *pdwData |= TT_OPENTYPE_FONT;
            else
                *pdwData |= TT_FONT;
        }
        else if (FontType & DEVICE_FONTTYPE)
            *pdwData |= DEVICE_FONT;
    }
}

BOOL CALLBACK AFX_EXPORT CFontComboBox::EnumFamScreenCallBackEx(ENUMLOGFONTEX* pelf,
    NEWTEXTMETRICEX* lpntm, int FontType, LPVOID pThis)
{
    // don't put in non-printer raster fonts
    if (FontType & RASTER_FONTTYPE)
        return 1;

    DWORD dwData = 0;

    vGetFontType(lpntm, FontType, &dwData);
    ((CFontComboBox *)pThis)->AddFont((ENUMLOGFONT*)pelf, dwData, CString(pelf->elfScript));
    return 1;
}

BOOL CALLBACK AFX_EXPORT CFontComboBox::EnumFamPrinterCallBackEx(ENUMLOGFONTEX* pelf,
    NEWTEXTMETRICEX* lpntm, int FontType, LPVOID pThis)
{
    DWORD dwData = PRINTER_FONT;

    vGetFontType(lpntm, FontType, &dwData);
    ((CFontComboBox *)pThis)->AddFont((ENUMLOGFONT*)pelf, dwData, CString(pelf->elfScript));
    return 1;
}

void CFontComboBox::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
    ASSERT(lpDIS->CtlType == ODT_COMBOBOX);
    int id = (int)(WORD)lpDIS->itemID;

    CDC *pDC = CDC::FromHandle(lpDIS->hDC);
    CRect rc(lpDIS->rcItem);
    if (lpDIS->itemState & ODS_FOCUS)
        pDC->DrawFocusRect(rc);
    int nIndexDC = pDC->SaveDC();

    CBrush brushFill;
    if (lpDIS->itemState & ODS_SELECTED)
    {
        brushFill.CreateSolidBrush(::GetSysColor(COLOR_HIGHLIGHT));
        pDC->SetTextColor(::GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
        brushFill.CreateSolidBrush(pDC->GetBkColor());
    pDC->SetBkMode(TRANSPARENT);
    pDC->FillRect(rc, &brushFill);

    CFontDesc* pDesc= (CFontDesc*)lpDIS->itemData;
    ASSERT(pDesc != NULL);
    DWORD dwData = pDesc->m_dwFlags;
    if (dwData) // truetype or device flag set by SetItemData
    {
        CDC dc;
        dc.CreateCompatibleDC(pDC);
        CBitmap* pBitmap = dc.SelectObject(&m_bmFontType);
        int xSrc;

        if (dwData & TT_FONT)
            xSrc = 1;
        else if (dwData & TT_OPENTYPE_FONT)
            xSrc = 2;
        else if (dwData & PS_OPENTYPE_FONT)
            xSrc = 3;
        else if (dwData & TYPE1_FONT)
            xSrc = 4;
        else // DEVICE_FONT
            xSrc = 0;

        pDC->BitBlt(rc.left, rc.top, BMW, BMH, &dc, xSrc*BMW, 0, SRCAND);
        dc.SelectObject(pBitmap);
    }

    rc.left += BMW + 6;
    CString strText;
    GetLBText(id, strText);
    pDC->TextOut(rc.left,rc.top,strText,strText.GetLength());

    pDC->RestoreDC(nIndexDC);
}

void CFontComboBox::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
    ASSERT(lpMIS->CtlType == ODT_COMBOBOX);
    ASSERT(m_nFontHeight > 0);
    CRect rc;

    GetWindowRect(&rc);
    lpMIS->itemWidth = rc.Width();
    lpMIS->itemHeight = max(BMH, m_nFontHeight);
}

int CFontComboBox::CompareItem(LPCOMPAREITEMSTRUCT lpCIS)
{
    ASSERT(lpCIS->CtlType == ODT_COMBOBOX);
    int id1 = (int)(WORD)lpCIS->itemID1;
    int id2 = (int)(WORD)lpCIS->itemID2;
    CString str1,str2;
    if (id1 == -1)
        return -1;
    if (id2 == -1)
        return 1;
    GetLBText(id1, str1);
    GetLBText(id2, str2);
    return str1.Collate(str2);
}

/////////////////////////////////////////////////////////////////////////////
// CSizeComboBox

CSizeComboBox::CSizeComboBox()
{
    m_nTwipsLast = 0;
}

void CSizeComboBox::EnumFontSizes(CDC& dc, LPCTSTR pFontName)
{
    ResetContent();
    if (pFontName == NULL)
        return;
    if (pFontName[0] == NULL)
        return;

    ASSERT(dc.m_hDC != NULL);
    m_nLogVert = dc.GetDeviceCaps(LOGPIXELSY);

    ::EnumFontFamilies(dc.m_hDC, pFontName,
        (FONTENUMPROC) EnumSizeCallBack, (LPARAM) this);
}

void CSizeComboBox::TwipsToPointString(LPTSTR lpszBuf, int nTwips)
{
    ASSERT(lpszBuf != NULL);
    lpszBuf[0] = NULL;
    if (nTwips >= 0)
    {
        // round to nearest half point
        nTwips = (nTwips+5)/10;
        if ((nTwips%2) == 0)
            _stprintf(lpszBuf, _T("%ld"), nTwips/2);
        else
            _stprintf(lpszBuf, _T("%.1f"), (float)nTwips/2.F);
    }
}

void CSizeComboBox::SetTwipSize(int nTwips)
{
    if (nTwips != GetTwipSize())
    {
        TCHAR buf[10];
        TwipsToPointString(buf, nTwips);
        SetTheText(buf, TRUE);
    }
    m_nTwipsLast = nTwips;
}

int CSizeComboBox::GetTwipSize()
{
    // return values
    // -2 -- error
    // -1 -- edit box empty
    // >=0 -- font size in twips
    CString str;
    GetTheText(str);
    LPCTSTR lpszText = str;

    while (*lpszText == ' ' || *lpszText == '\t')
        lpszText++;

    if (lpszText[0] == NULL)
        return -1; // no text in control

    double d = _tcstod(lpszText, (LPTSTR*)&lpszText);
    while (*lpszText == ' ' || *lpszText == '\t')
        lpszText++;

    if (*lpszText != NULL)
        return -2;   // not terminated properly

    return (d<0.) ? 0 : (int)(d*20.);
}

BOOL CALLBACK AFX_EXPORT CSizeComboBox::EnumSizeCallBack(LOGFONT FAR* /*lplf*/,
        LPNEWTEXTMETRIC lpntm, int FontType, LPVOID lpv)
{
    CSizeComboBox* pThis = (CSizeComboBox*)lpv;
    ASSERT(pThis != NULL);
    TCHAR buf[10];
    if (
        (FontType & TRUETYPE_FONTTYPE) ||
        !( (FontType & TRUETYPE_FONTTYPE) || (FontType & RASTER_FONTTYPE) )
        ) // if truetype or vector font
    {
        // this occurs when there is a truetype and nontruetype version of a font
        if (pThis->GetCount() != 0)
            pThis->ResetContent();

        for (int i = 0; i < 16; i++)
        {
            wsprintf(buf, _T("%d"), nFontSizes[i]);
            pThis->AddString(buf);
        }
        return FALSE; // don't call me again
    }
    // calc character height in pixels
    pThis->InsertSize(MulDiv(lpntm->tmHeight-lpntm->tmInternalLeading,
        1440, pThis->m_nLogVert));
    return TRUE; // call me again
}

void CSizeComboBox::InsertSize(int nSize)
{
    ASSERT(nSize > 0);
    DWORD dwSize = (DWORD)nSize;
    TCHAR buf[10];
    TwipsToPointString(buf, nSize);
    if (FindStringExact(-1, buf) == CB_ERR)
    {
        int nIndex = -1;
        int nPos = 0;
        DWORD_PTR dw;
        while ((dw = GetItemData(nPos)) != CB_ERR)
        {
            if (dw > dwSize)
            {
                nIndex = nPos;
                break;
            }
            nPos++;
        }
        nIndex = InsertString(nIndex, buf);
        ASSERT(nIndex != CB_ERR);
        if (nIndex != CB_ERR)
            SetItemData(nIndex, dwSize);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CLocalComboBox

BEGIN_MESSAGE_MAP(CLocalComboBox, CComboBox)
    //{{AFX_MSG_MAP(CLocalComboBox)
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
    // Global help commands
END_MESSAGE_MAP()

void CLocalComboBox::GetTheText(CString& str)
{
    int nIndex = GetCurSel();
    if (nIndex == CB_ERR)
        GetWindowText(str);
    else
        GetLBText(nIndex, str);
}

void CLocalComboBox::SetTheText(LPCTSTR lpszText,BOOL bMatchExact)
{
    int idx = (bMatchExact) ? FindStringExact(-1,lpszText) :
        FindString(-1, lpszText);
    SetCurSel( (idx==CB_ERR) ? -1 : idx);
    if (idx == CB_ERR)
        SetWindowText(lpszText);
}

BOOL CLocalComboBox::LimitText(int nMaxChars)
{
    BOOL b = CComboBox::LimitText(nMaxChars);
    if (b)
        m_nLimitText = nMaxChars;
    return b;
}

int CLocalComboBox::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CComboBox::OnCreate(lpCreateStruct) == -1)
        return -1;
    SendMessage(WM_SETFONT, (WPARAM)GetStockObject(theApp.m_nDefFont));
    return 0;
}

BOOL CLocalComboBox::PreTranslateMessage(MSG* pMsg)
{
    if (pMsg->message == WM_KEYDOWN)
    {
        CFormatBar* pBar = (CFormatBar*)GetParent();
        switch (pMsg->wParam)
        {
        case VK_ESCAPE:
            pBar->SyncToView();
            pBar->NotifyOwner(NM_RETURN);
            return TRUE;
        case VK_RETURN:
            pBar->NotifyOwner(NM_RETURN);
            return TRUE;
        case VK_TAB:
            pBar->GetNextDlgTabItem(this)->SetFocus();
            return TRUE;
        case VK_UP:
        case VK_DOWN:
            if ((GetKeyState(VK_MENU) >= 0) && (GetKeyState(VK_CONTROL) >=0) &&
                !GetDroppedState())
            {
                ShowDropDown();
                return TRUE;
            }
        }
    }

    //
    // Unless we catch the 'CatchKeys' keys here, MFC will wander around
    // trying to figure out what to do with them and eventually realize
    // that they are accellerators for the frame window and dispatch them
    // there.  We want them sent to the combobox's edit controls.
    //

    if (WM_KEYDOWN == pMsg->message || WM_SYSKEYDOWN == pMsg->message)
    {
        static const struct
        {
            int     modifier;
            WPARAM  virtkey;
        }
        CatchKeys[] =
        {
            {VK_CONTROL, 'C'},          // control-C copy
            {VK_CONTROL, 'V'},          // control-V paste
            {VK_MENU,    VK_BACK},      // alt-back undo
            {VK_SHIFT,   VK_DELETE},    // shift-delete cut
            {VK_CONTROL, VK_INSERT},    // control-insert copy
            {VK_SHIFT,   VK_INSERT},    // shift-insert paste
            {VK_CONTROL, 'X'},          // control-X cut
            {VK_CONTROL, 'Z'}           // control-Z undo
        };

        for (int i = 0; i < sizeof(CatchKeys)/sizeof(CatchKeys[0]); i++)
        {
            if (pMsg->wParam == CatchKeys[i].virtkey)
            {
                if (GetKeyState(CatchKeys[i].modifier) < 0)
                {
                    ::TranslateMessage(pMsg);
                    ::DispatchMessage(pMsg);
                    return TRUE;
                }
            }
        }
    }

    return CComboBox::PreTranslateMessage(pMsg);
}

void CFormatBar::NotifyOwner(UINT nCode)
{
    NMHDR nm;
    nm.hwndFrom = m_hWnd;
    nm.idFrom = GetDlgCtrlID();
    nm.code = nCode;
    GetOwner()->SendMessage(WM_NOTIFY, nm.idFrom, (LPARAM)&nm);
}

void CFormatBar::SetCharFormat(CCharFormat& cf)
{
    CHARHDR fnm;
    fnm.hwndFrom = m_hWnd;
    fnm.idFrom = GetDlgCtrlID();
    fnm.code = FN_SETFORMAT;
    fnm.cf = cf;
    VERIFY(GetOwner()->SendMessage(WM_NOTIFY, fnm.idFrom, (LPARAM)&fnm));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\formatba.h ===
// formatba.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __FORMATBA_H__
#define __FORMATBA_H__

class CWordPadView;

/*
typedef struct tagNMHDR
{
    HWND  hwndFrom;
    UINT  idFrom;
    UINT  code;         // NM_ code
}   NMHDR;
*/

struct CHARHDR : public tagNMHDR
{
	CHARFORMAT cf;
	CHARHDR() {cf.cbSize = sizeof(CHARFORMAT);}
};

#define FN_SETFORMAT	0x1000
#define FN_GETFORMAT	0x1001

/////////////////////////////////////////////////////////////////////////////
// CLocalComboBox

class CLocalComboBox : public CComboBox
{
public:

//Attributes
	CPtrArray m_arrayFontDesc;
	static int m_nFontHeight;
	int m_nLimitText;
	BOOL HasFocus()
	{
		HWND hWnd = ::GetFocus();
		return (NULL != hWnd) && (hWnd == m_hWnd || ::IsChild(m_hWnd, hWnd));
	}
	void GetTheText(CString& str);
	void SetTheText(LPCTSTR lpszText,BOOL bMatchExact = FALSE);

//Operations
	BOOL LimitText(int nMaxChars);

// Implementation
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	// Generated message map functions
	//{{AFX_MSG(CLocalComboBox)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CFontComboBox : public CLocalComboBox
{
public:
	CFontComboBox();

//Attributes
	CBitmap m_bmFontType;

//Operations
	void EnumFontFamiliesEx(CDC& dc, BYTE nCharSet = DEFAULT_CHARSET);
	void AddFont(ENUMLOGFONT* pelf, DWORD dwType, LPCTSTR lpszScript = NULL);
	void EmptyContents();

	static BOOL CALLBACK AFX_EXPORT EnumFamScreenCallBackEx(
		ENUMLOGFONTEX* pelf, NEWTEXTMETRICEX* /*lpntm*/, int FontType, 
		LPVOID pThis);
	static BOOL CALLBACK AFX_EXPORT EnumFamPrinterCallBackEx(
		ENUMLOGFONTEX* pelf, NEWTEXTMETRICEX* /*lpntm*/, int FontType, 
		LPVOID pThis);

//Overridables
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCIS);
	// Generated message map functions
	//{{AFX_MSG(CFontComboBox)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CSizeComboBox : public CLocalComboBox
{
public:
	CSizeComboBox();

//Attributes
	int m_nLogVert;
	int m_nTwipsLast;
public:
	void EnumFontSizes(CDC& dc, LPCTSTR pFontName);
	static BOOL FAR PASCAL EnumSizeCallBack(LOGFONT FAR* lplf, 
		LPNEWTEXTMETRIC lpntm,int FontType, LPVOID lpv);
	void TwipsToPointString(LPTSTR lpszBuf, int nTwips);
	void SetTwipSize(int nSize);
	int GetTwipSize();
	void InsertSize(int nSize);
};

class CScriptComboBox : public CLocalComboBox
{
    enum {HistorySize = 4};

public:

    CScriptComboBox() {m_history_index = 0;}

    BYTE PickScript();

private:

    //
    // HACKHACK: All this history stuff is to help make choosing a script for
    // a font easier.  There doesn't seem to be anyway to get a "good" script
    // for a given font/locale so what we do is save the last serveral scripts
    // and hope that the font the user just switched to supports one of them.
    //

    CString m_script_history[HistorySize];
    int     m_history_index;
};

/////////////////////////////////////////////////////////////////////////////
// CFormatBar dialog
class CFormatBar : public CToolBar
{
// Construction
public:
	CFormatBar();

// Operations
public:
	void PositionCombos();
	void SyncToView();

// Attributes
public:
    CDC             m_dcPrinter;
    CSize           m_szBaseUnits;
    CFontComboBox   m_comboFontName;
    CSizeComboBox   m_comboFontSize;
    CScriptComboBox m_comboScript;

// Implementation
public:
	void NotifyOwner(UINT nCode);

protected:
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	void SetCharFormat(CCharFormat& cf);

	// Generated message map functions
	//{{AFX_MSG(CFormatBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	afx_msg void OnFontNameKillFocus();
	afx_msg void OnFontSizeKillFocus();
	afx_msg void OnScriptKillFocus();
	afx_msg void OnFontSizeDropDown();
	afx_msg void OnScriptDropDown();
	afx_msg void OnComboCloseUp();
	afx_msg void OnComboSetFocus();
	afx_msg LONG OnPrinterChanged(UINT, LONG); //handles registered message
	DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\formatta.cpp ===
// formatta.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "formatta.h"
#include "ddxm.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

const DWORD CFormatTabDlg::m_nHelpIDs[] =
{
	IDC_BUTTON_SET, IDH_WORDPAD_TABSET,
	IDC_BUTTON_CLEAR, IDH_WORDPAD_TABCLEAR,
	IDC_BUTTON_CLEARALL, IDH_WORDPAD_TAB_CLEARALL,
	IDC_COMBO1, IDH_WORDPAD_TABSTOPS,
	IDC_BOX, (DWORD) -1,
	0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CFormatTabDlg dialog

CFormatTabDlg::CFormatTabDlg(PARAFORMAT& pf, CWnd* pParent /*=NULL*/)
	: CCSDialog(CFormatTabDlg::IDD, pParent)
{
	m_pf = pf;
	m_tabarray = new LONG[MAX_TAB_STOPS];
	m_nCount = 0;
	if (m_pf.dwMask & PFM_TABSTOPS)
	{
		m_nCount = m_pf.cTabCount;
		ASSERT(m_pf.cTabCount <= MAX_TAB_STOPS);
		for (int i=0;i<m_pf.cTabCount;i++)
			m_tabarray[i] = m_pf.rgxTabs[i];
	}
	
	//{{AFX_DATA_INIT(CFormatTabDlg)
	//}}AFX_DATA_INIT
}

CFormatTabDlg::~CFormatTabDlg()
{
	delete [] m_tabarray;
}

void CFormatTabDlg::DoDataExchange(CDataExchange* pDX)
{
	CCSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFormatTabDlg)
	DDX_Control(pDX, IDC_BUTTON_CLEARALL, m_buttonClearAll);
	DDX_Control(pDX, IDC_BUTTON_SET, m_buttonSet);
	DDX_Control(pDX, IDC_BUTTON_CLEAR, m_buttonClear);
	DDX_Control(pDX, IDC_COMBO1, m_comboBox);
	//}}AFX_DATA_MAP
	if (!pDX->m_bSaveAndValidate)
		UpdateListBox();
}

BEGIN_MESSAGE_MAP(CFormatTabDlg, CCSDialog)
	//{{AFX_MSG_MAP(CFormatTabDlg)
	ON_BN_CLICKED(IDC_BUTTON_CLEAR, OnClickedClear)
	ON_BN_CLICKED(IDC_BUTTON_CLEARALL, OnClickedClearAll)
	ON_BN_CLICKED(IDC_BUTTON_SET, OnClickedSet)
	ON_CBN_EDITCHANGE(IDC_COMBO1, OnEditChange)
	ON_CBN_SELCHANGE(IDC_COMBO1, OnSelchange)
	ON_MESSAGE(WM_HELP, OnHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFormatTabDlg message handlers

void CFormatTabDlg::OnClickedClear()
{
	int nTab;
	int nSel = m_comboBox.GetCurSel();
	if (nSel == CB_ERR)
	{
		CDataExchange dx(this, TRUE);
		DDX_Twips(&dx, IDC_COMBO1, nTab);
		DDV_MinMaxTwips(&dx, nTab, 0, 31680);
		if (nTab != DDXM_BLANK)
		{
				if (RemoveTabFromArray(nTab))
					UpdateListBox();
		}
	}
	else
	{
		ASSERT(nSel < m_nCount);
		RemoveTabFromArrayByIndex(nSel);
		UpdateListBox();
	}
	UpdateButtons();
	SetEditFocus();
}

void CFormatTabDlg::OnClickedClearAll()
{
	m_nCount = 0;
	m_comboBox.ResetContent();
	UpdateButtons();
	SetEditFocus();
}

void CFormatTabDlg::OnClickedSet()
{
	Set();
	UpdateButtons();
	SetEditFocus();
}

BOOL CFormatTabDlg::Set()
{
	int nTab = 0;
	CDataExchange dx(this, TRUE);
	DDX_Twips(&dx, IDC_COMBO1, nTab);
	DDV_MinMaxTwips(&dx, nTab, 0, 31680);
	if (nTab != DDXM_BLANK)
	{
		if (m_nCount == MAX_TAB_STOPS)
		{
			AfxMessageBox(IDS_NOMORETABS);
			m_comboBox.Clear();
			return FALSE;
		}
		if (AddTabToArray(nTab))
			UpdateListBox();
		return TRUE;
	}
	return FALSE;
}

void CFormatTabDlg::SetEditFocus()
{
	m_comboBox.SetFocus();
	m_comboBox.SetEditSel(0,-1);
}

BOOL CFormatTabDlg::RemoveTabFromArray(LONG lTab)
{
	int i;
	for (i=0;i<m_nCount;i++)
	{
		if (m_tabarray[i] == lTab)
		{
			RemoveTabFromArrayByIndex(i);
			return TRUE;
		}
	}
	return FALSE;
}

void CFormatTabDlg::RemoveTabFromArrayByIndex(int nIndex)
{
	memmove(&m_tabarray[nIndex], &m_tabarray[nIndex+1],
		(m_nCount-nIndex-1)*sizeof(LONG));
	m_nCount--;
}

BOOL CFormatTabDlg::AddTabToArray(LONG lTab)
{
	int i;
	BOOL bInsert = FALSE;
	LONG lTemp;
	for (i=0;i<m_nCount;i++)
	{
		if (!bInsert && lTab < m_tabarray[i])
			bInsert = TRUE;
		else if (lTab == m_tabarray[i]) // we don't want repeats
			return FALSE;
		if (bInsert)
		{
			lTemp = m_tabarray[i];
			m_tabarray[i] = lTab;
			lTab = lTemp;
		}
	}
	m_tabarray[m_nCount++] = lTab;
	return TRUE;
}

void CFormatTabDlg::UpdateListBox()
{
	int i;
	TCHAR szT[64];
	ASSERT(m_nCount >= 0);
	m_comboBox.ResetContent();
	for (i=0;i<m_nCount;i++)
	{
		theApp.PrintTwips(szT, m_tabarray[i], 2);
		m_comboBox.AddString(szT);
	}
}

void CFormatTabDlg::OnOK()
{
	if (m_buttonSet.IsWindowEnabled())
	{
		if (!Set())
			return;
	}
	CCSDialog::OnOK();
	m_pf.cTabCount = (SHORT) m_nCount;
	for (int i=0;i<m_nCount;i++)
		m_pf.rgxTabs[i] = m_tabarray[i];
	m_pf.dwMask = PFM_TABSTOPS;
}

void CFormatTabDlg::OnEditChange()
{
	UpdateButtons();
}

void CFormatTabDlg::UpdateButton(CButton& button, BOOL b)
{
	if (b != button.IsWindowEnabled())
		button.EnableWindow(b);
}

void CFormatTabDlg::UpdateButtons()
{
	UpdateButton(m_buttonClearAll, m_nCount > 0);
	BOOL bHasText = (m_comboBox.GetWindowTextLength() > 0);
	UpdateButton(m_buttonSet, bHasText);
	UpdateButton(m_buttonClear, bHasText);
	WORD wID = LOWORD(GetDefID());
	if (bHasText && wID != IDC_BUTTON_SET)
		SetDefID(IDC_BUTTON_SET);
	else if (!bHasText && wID != IDOK)
		SetDefID(IDOK);
}

BOOL CFormatTabDlg::OnInitDialog()
{
	CCSDialog::OnInitDialog();
	UpdateButtons();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CFormatTabDlg::OnSelchange()
{
	UpdateButton(m_buttonClearAll, m_nCount > 0);
	// force these since if the edit control is empty and
	// an item in the box is clicked on, the edit control will
	// not be filled in first
	UpdateButton(m_buttonSet, TRUE);
	UpdateButton(m_buttonClear, TRUE);
	WORD wID = LOWORD(GetDefID());
	if (wID != IDC_BUTTON_SET)
		SetDefID(IDC_BUTTON_SET);
}


LONG CFormatTabDlg::OnHelp(WPARAM, LPARAM lParam)
{
	LPHELPINFO phi = (LPHELPINFO) lParam ;
	HWND hWndCombo = ::GetDlgItem(m_hWnd, IDC_COMBO1) ;

	HWND hWndItem = (HWND) phi->hItemHandle ;

	if (::GetParent(hWndItem) == hWndCombo)
    {
		hWndItem = hWndCombo ;
    }

	::WinHelp(hWndItem, AfxGetApp()->m_pszHelpFilePath,
		HELP_WM_HELP, (DWORD_PTR)GetHelpIDs());

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\helpids.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#define IDH_WORDPAD_TIMEDATE		1001

#define IDH_WORDPAD_ALIGN			1003
#define IDH_WORDPAD_TABSET			1004
#define IDH_WORDPAD_TABCLEAR		1005
#define IDH_WORDPAD_TAB_CLEARALL	1006
#define IDH_WORDPAD_TABSTOPS		1007
#define IDH_WORDPAD_TEXTFILE		1008
#define IDH_WORDPAD_FORMATTED		1009

#define IDH_WORDPAD_WORD6FILE		1017
#define IDH_WORDPAD_FILENEW_DOC		1018
#define IDH_WORDPAD_OPTIONS_AUTOWORDSEL	1019

#define IDH_WORDPAD_INDENT_LEFT		1020
#define IDH_WORDPAD_INDENT_RIGHT	1021
#define IDH_WORDPAD_INDENT_FIRST	1022

#define IDH_WORDPAD_WRAP_NO			1023
#define IDH_WORDPAD_WRAP_WINDOW		1024
#define IDH_WORDPAD_WRAP_RULER		1025

#define IDH_WORDPAD_INCHES			1027
#define IDH_WORDPAD_CENTIMETERS		1028
#define IDH_WORDPAD_POINTS			1029
#define IDH_WORDPAD_PICAS			1030

#define IDH_WORDPAD_CHECK_TOOLBAR	1031
#define IDH_WORDPAD_CHECK_FORMATBAR	1032
#define IDH_WORDPAD_CHECK_STATUSBAR	1033
#define IDH_WORDPAD_CHECK_RULERBAR	1034

#define IDH_WORDPAD_TOPMARGIN		1035
#define IDH_WORDPAD_BOTTOMMARGIN	1036
#define IDH_WORDPAD_LEFTMARGIN 		1037
#define IDH_WORDPAD_RIGHTMARGIN		1038

#define IDH_WORDPAD_DEFAULT_FORMAT  1039
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\ipframe.cpp ===
// ipframe.cpp : implementation of the CInPlaceFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "formatba.h"
#include "ruler.h"
#include "ipframe.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "colorlis.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame

IMPLEMENT_DYNCREATE(CInPlaceFrame, COleIPFrameWnd)

BEGIN_MESSAGE_MAP(CInPlaceFrame, COleIPFrameWnd)
	//{{AFX_MSG_MAP(CInPlaceFrame)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_COMMAND(ID_HELP, OnHelpFinder)
	ON_COMMAND(ID_CHAR_COLOR, OnCharColor)
	ON_COMMAND(ID_HELP_INDEX, OnHelpFinder)
	ON_COMMAND(ID_PEN_TOGGLE, OnPenToggle)
	//}}AFX_MSG_MAP
	ON_UPDATE_COMMAND_UI(ID_VIEW_TOOLBAR, OnUpdateControlBarMenu)
	ON_COMMAND_EX(ID_VIEW_TOOLBAR, OnBarCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_FORMATBAR, OnUpdateControlBarMenu)
	ON_COMMAND_EX(ID_VIEW_FORMATBAR, OnBarCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_RULER, OnUpdateControlBarMenu)
	ON_COMMAND_EX(ID_VIEW_RULER, OnBarCheck)
	ON_MESSAGE(WM_SIZECHILD, OnResizeChild)
	ON_MESSAGE(WPM_BARSTATE, OnBarState)
	ON_COMMAND(ID_DEFAULT_HELP, OnHelpFinder)
//	ON_COMMAND(ID_CONTEXT_HELP, COleIPFrameWnd::OnContextHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars

static UINT BASED_CODE toolButtons[] =
{
	// same order as in the bitmap 'itoolbar.bmp'
	ID_EDIT_CUT,
	ID_EDIT_COPY,
	ID_EDIT_PASTE,

		ID_SEPARATOR,
	ID_PEN_TOGGLE,
	ID_PEN_PERIOD,
	ID_PEN_SPACE,
	ID_PEN_BACKSPACE,
	ID_PEN_NEWLINE,
	ID_PEN_LENS
};

#define NUM_PEN_ITEMS 7
#define NUM_PEN_TOGGLE 5

static UINT BASED_CODE format[] =
{
	// same order as in the bitmap 'format.bmp'
		ID_SEPARATOR, // font name combo box
		ID_SEPARATOR,
		ID_SEPARATOR, // font size combo box
		ID_SEPARATOR,
        ID_SEPARATOR, // font script combo box
        ID_SEPARATOR,
	ID_CHAR_BOLD,
	ID_CHAR_ITALIC,
	ID_CHAR_UNDERLINE,
	ID_CHAR_COLOR,
		ID_SEPARATOR,
	ID_PARA_LEFT,
	ID_PARA_CENTER,
	ID_PARA_RIGHT,
		ID_SEPARATOR,
	ID_INSERT_BULLET,
};

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame construction/destruction

int CInPlaceFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleIPFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// CResizeBar implements in-place resizing.
	if (!m_wndResizeBar.Create(this))
	{
		TRACE0("Failed to create resize bar\n");
		return -1;      // fail to create
	}

	if (!CreateRulerBar(this))
		return FALSE;

	// By default, it is a good idea to register a drop-target that does
	//  nothing with your frame window.  This prevents drops from
	//  "falling through" to a container that supports drag-drop.
	m_dropTarget.Register(this);

	return 0;
}

// OnCreateControlBars is called by the framework to create control bars on the
//  container application's windows.  pWndFrame is the top level frame window of
//  the container and is always non-NULL.  pWndDoc is the doc level frame window
//  and will be NULL when the container is an SDI application.  A server
//  application can place MFC control bars on either window.
BOOL CInPlaceFrame::OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* /*pWndDoc*/)
{
	if (!CreateToolBar(pWndFrame))
		return FALSE;

	if (!CreateFormatBar(pWndFrame))
		return FALSE;

	// set owner to this window, so messages are delivered to correct app
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	m_wndFormatBar.EnableDocking(CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM);
	pWndFrame->EnableDocking(CBRS_ALIGN_ANY);
	pWndFrame->DockControlBar(&m_wndToolBar);
	pWndFrame->DockControlBar(&m_wndFormatBar);

	m_wndToolBar.SetOwner(this);
	m_wndFormatBar.SetOwner(this);
	m_wndRulerBar.SetOwner(this);
	OnBarState(1, RD_EMBEDDED); //load bar state
	return TRUE;
}

BOOL CInPlaceFrame::CreateToolBar(CWnd* pWndFrame)
{
	// Create toolbar on client's frame window
	ASSERT(m_wndToolBar.m_hWnd == NULL);
	int nPen = GetSystemMetrics(SM_PENWINDOWS) ? NUM_PEN_TOGGLE : 
		NUM_PEN_ITEMS;
	UINT nID = theApp.m_bLargeIcons ? 
		IDR_SRVR_INPLACE_BIG : IDR_SRVR_INPLACE;
	if (!m_wndToolBar.Create(pWndFrame, WS_CHILD|WS_VISIBLE|CBRS_TOP|
			CBRS_TOOLTIPS|CBRS_FLYBY|CBRS_SIZE_DYNAMIC)||
		!m_wndToolBar.LoadBitmap(nID) ||
		!m_wndToolBar.SetButtons(toolButtons, 
			sizeof(toolButtons)/sizeof(UINT) - nPen))
	{
		TRACE0("Failed to create toolbar\n");
		return FALSE;      // fail to create
	}
	if (theApp.m_bLargeIcons)
		m_wndToolBar.SetSizes(CSize(31,30), CSize(24,24));
	else
		m_wndToolBar.SetSizes(CSize(23,22), CSize(16,16));
	CString str;
	str.LoadString(IDS_TITLE_TOOLBAR);
	m_wndToolBar.SetWindowText(str);
	return TRUE;
}

BOOL CInPlaceFrame::CreateFormatBar(CWnd* pWndFrame)
{
	ASSERT(m_wndFormatBar.m_hWnd == NULL);
	m_wndFormatBar.m_hWndOwner = m_hWnd;
	UINT nID = theApp.m_bLargeIcons ? IDB_FORMATBAR_BIG : IDB_FORMATBAR;
	if (!m_wndFormatBar.Create(pWndFrame, WS_CHILD|WS_VISIBLE|CBRS_TOP|
		CBRS_TOOLTIPS|CBRS_FLYBY|CBRS_HIDE_INPLACE|CBRS_SIZE_DYNAMIC, ID_VIEW_FORMATBAR) ||
		!m_wndFormatBar.LoadBitmap(nID) ||
		!m_wndFormatBar.SetButtons(format, 
			sizeof(format)/sizeof(UINT)))
	{
		TRACE0("Failed to create FormatBar\n");
		return FALSE;      // fail to create
	}

	if (theApp.m_bLargeIcons)
		m_wndFormatBar.SetSizes(CSize(31,30), CSize(24,24));
	else
		m_wndFormatBar.SetSizes(CSize(23,22), CSize(16,16));
	CString str;
	str.LoadString(IDS_TITLE_FORMATBAR);
	m_wndFormatBar.SetWindowText(str);
	m_wndFormatBar.PositionCombos();
	return TRUE;
}

CInPlaceFrame::CreateRulerBar(CWnd* pWndFrame)
{
	if (!m_wndRulerBar.Create(pWndFrame, 
		WS_CHILD|WS_VISIBLE|CBRS_ALIGN_TOP|CBRS_HIDE_INPLACE, ID_VIEW_RULER))
	{
		TRACE0("Failed to create ruler\n");
		return FALSE;      // fail to create
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame Operations

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame diagnostics

#ifdef _DEBUG
void CInPlaceFrame::AssertValid() const
{
	COleIPFrameWnd::AssertValid();
}

void CInPlaceFrame::Dump(CDumpContext& dc) const
{
	COleIPFrameWnd::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame commands

void CInPlaceFrame::OnDestroy()
{
	m_wndToolBar.DestroyWindow();
	m_wndFormatBar.DestroyWindow();
	COleIPFrameWnd::OnDestroy();
}

void CInPlaceFrame::RepositionFrame(LPCRECT lpPosRect, LPCRECT lpClipRect)
{
	CRect rectNew = lpPosRect;
	rectNew.left -= HORZ_TEXTOFFSET;
	rectNew.top -= VERT_TEXTOFFSET;
	m_wndResizeBar.BringWindowToTop();
	COleIPFrameWnd::RepositionFrame(&rectNew, lpClipRect);
	CWnd* pWnd = GetActiveView();
	if (pWnd != NULL)
		pWnd->BringWindowToTop();
	m_wndRulerBar.BringWindowToTop();
}

void CInPlaceFrame::RecalcLayout(BOOL bNotify)
{
	if (m_wndResizeBar.m_hWnd != NULL)
		m_wndResizeBar.BringWindowToTop();
	COleIPFrameWnd::RecalcLayout(bNotify);
	CWnd* pWnd = GetActiveView();
	if (pWnd != NULL)
		pWnd->BringWindowToTop();
	if (m_wndRulerBar.m_hWnd != NULL)
		m_wndRulerBar.BringWindowToTop();

	// at least 12 pt region plus ruler if it exists
	CDisplayIC dc;
	CSize size;
	size.cy = MulDiv(12, dc.GetDeviceCaps(LOGPIXELSY), 72)+1;
	size.cx = dc.GetDeviceCaps(LOGPIXELSX)/4; // 1/4"
	size.cx += HORZ_TEXTOFFSET; //adjust for offset
	size.cy += VERT_TEXTOFFSET;
	if (m_wndRulerBar.m_hWnd != NULL && m_wndRulerBar.IsVisible())
	{
		CRect rect;
		m_wndRulerBar.GetWindowRect(&rect);
		size.cy += rect.Height();
	}
	m_wndResizeBar.SetMinSize(size);
}

void CInPlaceFrame::CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType)
{
	COleIPFrameWnd::CalcWindowRect(lpClientRect, nAdjustType);
}

LRESULT CInPlaceFrame::OnResizeChild(WPARAM /*wParam*/, LPARAM lParam)
{
	// notify the container that the rectangle has changed!
	CWordPadDoc* pDoc = (CWordPadDoc*)GetActiveDocument();
	if (pDoc == NULL)
		return 0;

	ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CWordPadDoc)));

	// get new rect and parent
	CRect rectNew;
	rectNew.CopyRect((LPCRECT)lParam);
	CWnd* pParentWnd = GetParent();
	ASSERT_VALID(pParentWnd);

	// convert rectNew relative to pParentWnd
	ClientToScreen(&rectNew);
	pParentWnd->ScreenToClient(&rectNew);

	if (m_wndRulerBar.GetStyle()&WS_VISIBLE)
	{
		CRect rect;
		m_wndRulerBar.GetWindowRect(&rect);
		rectNew.top += rect.Height();
	}
	rectNew.left += HORZ_TEXTOFFSET;
	rectNew.top += VERT_TEXTOFFSET;

	// adjust the new rectangle for the current control bars
	CWnd* pLeftOver = GetDlgItem(AFX_IDW_PANE_FIRST);
	ASSERT(pLeftOver != NULL);
	CRect rectCur = m_rectPos;
	pLeftOver->CalcWindowRect(&rectCur, CWnd::adjustOutside);
	rectNew.left += m_rectPos.left - rectCur.left;
	rectNew.top += m_rectPos.top - rectCur.top;
	rectNew.right -= rectCur.right - m_rectPos.right;
	rectNew.bottom -= rectCur.bottom - m_rectPos.bottom;
	OnRequestPositionChange(rectNew);

	return 0;
}

LONG CInPlaceFrame::OnBarState(UINT wParam, LONG lParam)
{
	if (lParam == -1)
		return 0L;
	if (wParam == 0)
	{
		GetDockState(theApp.GetDockState(RD_EMBEDDED));
		ASSERT(m_pMainFrame != NULL);
		m_pMainFrame->GetDockState(theApp.GetDockState(RD_EMBEDDED, FALSE));
	}
	else
	{
		SetDockState(theApp.GetDockState(RD_EMBEDDED));
		m_pMainFrame->SetDockState(theApp.GetDockState(RD_EMBEDDED, FALSE));
	}
	return 0L;
}

void CInPlaceFrame::OnHelpFinder() 
{
    ::HtmlHelpA( ::GetDesktopWindow(), "wordpad.chm", HH_DISPLAY_TOPIC, 0L );
}

void CInPlaceFrame::OnCharColor() 
{
	CColorMenu colorMenu;
	CRect rc;
	int index = m_wndFormatBar.CommandToIndex(ID_CHAR_COLOR);
	m_wndFormatBar.GetItemRect(index, &rc);
	m_wndFormatBar.ClientToScreen(rc);
	colorMenu.TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON,rc.left,rc.bottom, this);
}

void CInPlaceFrame::OnPenToggle() 
{
	static int nPen = 0;
	m_wndToolBar.SetButtons(toolButtons, sizeof(toolButtons)/sizeof(UINT) - nPen);
	nPen = (nPen == 0) ? NUM_PEN_TOGGLE : 0;
	m_wndToolBar.Invalidate();
	m_wndToolBar.GetParentFrame()->RecalcLayout();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\key.h ===
// key.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CKey 

class CKey
{
public:
	CKey() {m_hKey = NULL;}
	~CKey() {Close();}

// Attributes
public:
	HKEY m_hKey;
	BOOL SetStringValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
	BOOL GetStringValue(CString& str, LPCTSTR lpszValueName = NULL);

// Operations
public:
	BOOL Create(HKEY hKey, LPCTSTR lpszKeyName);
	BOOL Open(HKEY hKey, LPCTSTR lpszKeyName);
	void Close();

// Overrides

// Implementation
protected:
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\formatpa.h ===
// formatpa.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CFormatParaDlg dialog

class CFormatParaDlg : public CCSDialog
{
// Construction
public:
	CFormatParaDlg(PARAFORMAT& pf, CWnd* pParent = NULL);   // standard constructor
	PARAFORMAT m_pf;

// Attributes
	int m_nWordWrap;

// Dialog Data
	//{{AFX_DATA(CFormatParaDlg)
	enum { IDD = IDD_FORMAT_PARA };
	int     m_nAlignment;
	int		m_nFirst;
	int		m_nLeft;
	int		m_nRight;
	//}}AFX_DATA

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnOK();

	// Generated message map functions
	//{{AFX_MSG(CFormatParaDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\formatta.h ===
// formatta.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CFormatTabDlg dialog

class CFormatTabDlg : public CCSDialog
{
// Construction
public:
	CFormatTabDlg(PARAFORMAT& pf, CWnd* pParent = NULL);    // standard constructor
	~CFormatTabDlg();
	PARAFORMAT m_pf;
	LONG* m_tabarray;
	int m_nCount;

// Dialog Data
	//{{AFX_DATA(CFormatTabDlg)
	enum { IDD = IDD_FORMAT_TAB };
	CButton	m_buttonClearAll;
	CButton	m_buttonSet;
	CButton	m_buttonClear;
	CComboBox	m_comboBox;
	//}}AFX_DATA

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}
	void UpdateButton(CButton& button, BOOL b);
	void UpdateButtons();
	BOOL Set();
	BOOL AddTabToArray(LONG lTab);
	BOOL RemoveTabFromArray(LONG lTab);
	void RemoveTabFromArrayByIndex(int nIndex);
	void UpdateListBox();
	void SetEditFocus();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnOK();

	// Generated message map functions
	//{{AFX_MSG(CFormatTabDlg)
	afx_msg void OnClickedClear();
	afx_msg void OnClickedClearAll();
	afx_msg void OnClickedSet();
	afx_msg void OnEditChange();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchange();
	afx_msg LONG OnHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\ipframe.h ===
// ipframe.h : interface of the CInPlaceFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CWordPadResizeBar : public COleResizeBar
{
public: 
	void SetMinSize(CSize size) {m_tracker.m_sizeMin = size;}
};

class CInPlaceFrame : public COleIPFrameWnd
{
	DECLARE_DYNCREATE(CInPlaceFrame)
public:
	CInPlaceFrame() {};

// Attributes
public:
	CToolBar m_wndToolBar;
	CFormatBar m_wndFormatBar;
	CRulerBar m_wndRulerBar;
	CWordPadResizeBar m_wndResizeBar;
	COleDropTarget m_dropTarget;

// Operations
public:
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual void CalcWindowRect(LPRECT lpClientRect, 
		UINT nAdjustType = adjustBorder);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInPlaceFrame)
	public:
	virtual BOOL OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc);
	virtual void RepositionFrame(LPCRECT lpPosRect, LPCRECT lpClipRect);
	//}}AFX_VIRTUAL

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	BOOL CreateToolBar(CWnd* pWndFrame);
	BOOL CreateFormatBar(CWnd* pWndFrame);
	BOOL CreateRulerBar(CWnd* pWndFrame);

// Generated message map functions
protected:
	//{{AFX_MSG(CInPlaceFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnHelpFinder();
	afx_msg void OnCharColor();
	afx_msg void OnPenToggle();
	//}}AFX_MSG
	LRESULT OnResizeChild(WPARAM wParam, LPARAM lParam);
	afx_msg LONG OnBarState(UINT wParam, LONG lParam);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\key.cpp ===
// key.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "key.h"
#include <winreg.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CKey

void CKey::Close()
{
	if (m_hKey != NULL)
	{

#if defined(_DEBUG)
		LONG lRes = RegCloseKey(m_hKey);
		ASSERT(lRes == ERROR_SUCCESS);
#else
		RegCloseKey(m_hKey);
#endif

		m_hKey = NULL;
	}
}

BOOL CKey::Create(HKEY hKey, LPCTSTR lpszKeyName)
{
	ASSERT(hKey != NULL);
	return (RegCreateKey(hKey, lpszKeyName, &m_hKey) == ERROR_SUCCESS);
}

BOOL CKey::Open(HKEY hKey, LPCTSTR lpszKeyName)
{
	ASSERT(hKey != NULL);
	return (RegOpenKey(hKey, lpszKeyName, &m_hKey) == ERROR_SUCCESS);
}

BOOL CKey::SetStringValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	ASSERT(m_hKey != NULL);
	return (RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
		(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR)) == ERROR_SUCCESS);
}

BOOL CKey::GetStringValue(CString& str, LPCTSTR lpszValueName)
{
	ASSERT(m_hKey != NULL);
	str.Empty();
	DWORD dw = 0;
	DWORD dwType = 0;
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		NULL, &dw);
	if (lRes == ERROR_SUCCESS)
	{
		ASSERT(dwType == REG_SZ);
		LPTSTR lpsz = str.GetBufferSetLength(dw);
		lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType, (BYTE*)lpsz, &dw);
		ASSERT(lRes == ERROR_SUCCESS);
		str.ReleaseBuffer();
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\listdlg.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CListDlg : public CDialog
{
public:
	//{{AFX_DATA(CListDlg)
	enum { IDD = IDD_LISTDIALOG };
	//}}AFX_DATA
	CListDlg::CListDlg(UINT idStrDlgTitle, UINT idStrListTitle, 
		const CStringList& listItems, int nDefSel=0);
	CString m_strDlgTitle,m_strListTitle;
	const CStringList& m_listItems;
	int m_nSelection;

protected:
	BOOL OnInitDialog();
	//{{AFX_MSG(CListDlg)
	afx_msg void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\mainfrm.cpp ===
// mainfrm.cpp : implementation of the CMainFrame class
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

#include "stdafx.h"

#include "wordpad.h"
#include "mainfrm.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "strings.h"
#include "colorlis.h"
#include "filedlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_WM_SYSCOLORCHANGE()
    ON_WM_SIZE()
    ON_WM_MOVE()
    ON_COMMAND(ID_HELP, OnHelpFinder)
    ON_WM_DROPFILES()
    ON_COMMAND(ID_CHAR_COLOR, OnCharColor)
    ON_COMMAND(ID_PEN_TOGGLE, OnPenToggle)
    ON_WM_FONTCHANGE()
    ON_WM_QUERYNEWPALETTE()
    ON_WM_PALETTECHANGED()
    ON_WM_DEVMODECHANGE()
    ON_COMMAND(ID_HELP_INDEX, OnHelpFinder)
    //}}AFX_MSG_MAP
    // Global help commands
//  ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnHelpFinder)
    ON_UPDATE_COMMAND_UI(ID_VIEW_FORMATBAR, OnUpdateControlBarMenu)
    ON_UPDATE_COMMAND_UI(ID_VIEW_RULER, OnUpdateControlBarMenu)
    ON_MESSAGE(WPM_BARSTATE, OnBarState)
    ON_REGISTERED_MESSAGE(CWordPadApp::m_nOpenMsg, OnOpenMsg)
    ON_COMMAND_EX(ID_VIEW_STATUS_BAR, OnBarCheck)
    ON_COMMAND_EX(ID_VIEW_TOOLBAR, OnBarCheck)
    ON_COMMAND_EX(ID_VIEW_FORMATBAR, OnBarCheck)
    ON_COMMAND_EX(ID_VIEW_RULER, OnBarCheck)
   ON_REGISTERED_MESSAGE(CWordPadApp::m_nOLEHelpMsg, OnOLEHelpMsg)

    ON_MESSAGE_VOID(WM_IDLEUPDATECMDUI, OnIdleUpdateCmdUI)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars

// toolbar buttons - IDs are command buttons
static UINT BASED_CODE toolbar[] =
{
    // same order as in the bitmap 'toolbar.bmp'
    // (int nBitmap, int nCommand, BYTE byteState, BYTE byteStyle, DWORD dw, int nString)
    ID_FILE_NEW,
    ID_FILE_OPEN,
    ID_FILE_SAVE,
ID_SEPARATOR,
    ID_FILE_PRINT_DIRECT,
    ID_FILE_PRINT_PREVIEW,
ID_SEPARATOR,
    ID_EDIT_FIND,
ID_SEPARATOR,
    ID_EDIT_CUT,
    ID_EDIT_COPY,
    ID_EDIT_PASTE,
    ID_EDIT_UNDO,
ID_SEPARATOR,
    ID_INSERT_DATE_TIME,
ID_SEPARATOR,
    ID_PEN_TOGGLE,
    ID_PEN_PERIOD,
    ID_PEN_SPACE,
    ID_PEN_BACKSPACE,
    ID_PEN_NEWLINE,
    ID_PEN_LENS
};

#define NUM_PEN_ITEMS 7
#define NUM_PEN_TOGGLE 5

static UINT BASED_CODE format[] =
{
    // same order as in the bitmap 'format.bmp'
        ID_SEPARATOR, // font name combo box
        ID_SEPARATOR,
        ID_SEPARATOR, // font size combo box
        ID_SEPARATOR,
        ID_SEPARATOR, // font script combo box
        ID_SEPARATOR,
    ID_CHAR_BOLD,
    ID_CHAR_ITALIC,
    ID_CHAR_UNDERLINE,
    ID_CHAR_COLOR,
        ID_SEPARATOR,
    ID_PARA_LEFT,
    ID_PARA_CENTER,
    ID_PARA_RIGHT,
        ID_SEPARATOR,
    ID_INSERT_BULLET,
};

static UINT BASED_CODE indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    m_hIconDoc = theApp.LoadIcon(IDI_ICON_DOC);
    m_hIconText = theApp.LoadIcon(IDI_ICON_TEXT);
    m_hIconWrite = theApp.LoadIcon(IDI_ICON_WRITE);

    m_inupdate = false;
    m_reset = false;
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    WNDCLASS wndcls;

    BOOL bRes = CFrameWnd::PreCreateWindow(cs);
    HINSTANCE hInst = AfxGetInstanceHandle();

    // see if the class already exists
    if (!::GetClassInfo(hInst, szWordPadClass, &wndcls))
    {
        // get default stuff
        ::GetClassInfo(hInst, cs.lpszClass, &wndcls);
        wndcls.style &= ~(CS_HREDRAW|CS_VREDRAW);
        // register a new class
        wndcls.lpszClassName = szWordPadClass;
        wndcls.hIcon = ::LoadIcon(hInst, MAKEINTRESOURCE(IDR_MAINFRAME));
        ASSERT(wndcls.hIcon != NULL);
        if (!AfxRegisterClass(&wndcls))
            AfxThrowResourceException();
    }
    cs.lpszClass = szWordPadClass;
    CRect rect = theApp.m_rectInitialFrame;
    if (rect.Width() > 0 && rect.Height() > 0)
    {
        // make sure window will be visible
        CDisplayIC dc;
        CRect rectDisplay(0, 0, dc.GetDeviceCaps(HORZRES),
            dc.GetDeviceCaps(VERTRES));
        if (rectDisplay.PtInRect(rect.TopLeft()) &&
            rectDisplay.PtInRect(rect.BottomRight()))
        {
            cs.x = rect.left;
            cs.y = rect.top;
            cs.cx = rect.Width();
            cs.cy = rect.Height();
        }
    }
    return bRes;
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!CreateToolBar())
        return -1;

    if (!CreateFormatBar())
        return -1;

    if (!CreateStatusBar())
        return -1;

    EnableDocking(CBRS_ALIGN_ANY);

    if (!CreateRulerBar())
        return -1;

    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    m_wndFormatBar.EnableDocking(CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM);
    DockControlBar(&m_wndToolBar);
    DockControlBar(&m_wndFormatBar);

    CWnd* pView = GetDlgItem(AFX_IDW_PANE_FIRST);
    if (pView != NULL)  
    {
        pView->SetWindowPos(&wndBottom, 0, 0, 0, 0,
            SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE);
    }

    return 0;
}

BOOL CMainFrame::CreateToolBar()
{
    int nPen = GetSystemMetrics(SM_PENWINDOWS) ? NUM_PEN_TOGGLE :
        NUM_PEN_ITEMS;
    UINT nID = theApp.m_bLargeIcons ? IDR_MAINFRAME1_BIG :
        IDR_MAINFRAME1;

    // If we have Large Icons then we should specify the correct Image size for
    // the toolbar before calling LoadBitmap because the number of buttons in the
    // toolbar calculated inside MFC (AddReplaceBitmap in BarTool.cpp) as Bitmap width
    // divided by ImageSize.cx. and this conflict with mirroring support if you have
    // incorrect number of buttons .
    if (theApp.m_bLargeIcons)
        m_wndToolBar.SetSizes(CSize(31,30), CSize(24,24));
        
    if (!m_wndToolBar.Create(this,
        WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_TOOLTIPS|CBRS_FLYBY|CBRS_SIZE_DYNAMIC)||
        !m_wndToolBar.LoadBitmap(nID) ||
        !m_wndToolBar.SetButtons(toolbar, sizeof(toolbar)/sizeof(UINT) - nPen))
    {
        TRACE0("Failed to create toolbar\n");
        return FALSE;      // fail to create
    }
    if (theApp.m_bLargeIcons)
        m_wndToolBar.SetSizes(CSize(31,30), CSize(24,24));
    else
        m_wndToolBar.SetSizes(CSize(23,22), CSize(16,16));
    CString str;
    str.LoadString(IDS_TITLE_TOOLBAR);
    m_wndToolBar.SetWindowText(str);
    return TRUE;
}

BOOL CMainFrame::CreateFormatBar()
{
    UINT nID = theApp.m_bLargeIcons ? IDB_FORMATBAR_BIG : IDB_FORMATBAR;

    // If we have Large Icons then we should specify the correct Image size for
    // the toolbar before calling LoadBitmap because the number of buttons in the
    // toolbar calculated inside MFC (AddReplaceBitmap in BarTool.cpp) as Bitmap width
    // divided by ImageSize.cx. and this conflict with mirroring support if you have
    // incorrect number of buttons .
    if (theApp.m_bLargeIcons)
        m_wndFormatBar.SetSizes(CSize(31,30), CSize(24,24));
        
    if (!m_wndFormatBar.Create(this,
        WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_TOOLTIPS|CBRS_FLYBY|CBRS_HIDE_INPLACE|CBRS_SIZE_DYNAMIC,
        ID_VIEW_FORMATBAR) ||
        !m_wndFormatBar.LoadBitmap(nID) ||
        !m_wndFormatBar.SetButtons(format, sizeof(format)/sizeof(UINT)))
    {
        TRACE0("Failed to create FormatBar\n");
        return FALSE;      // fail to create
    }

    if (theApp.m_bLargeIcons)
        m_wndFormatBar.SetSizes(CSize(31,30), CSize(24,24));
    else
        m_wndFormatBar.SetSizes(CSize(23,22), CSize(16,16));
    CString str;
    str.LoadString(IDS_TITLE_FORMATBAR);
    m_wndFormatBar.SetWindowText(str);
    m_wndFormatBar.PositionCombos();
    return TRUE;
}

BOOL CMainFrame::CreateRulerBar()
{
    if (!m_wndRulerBar.Create(this,
        WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_HIDE_INPLACE, ID_VIEW_RULER))
    {
        TRACE0("Failed to create ruler\n");
        return FALSE;      // fail to create
    }
    return TRUE;
}

BOOL CMainFrame::CreateStatusBar()
{
    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return FALSE;      // fail to create
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame Operations

HICON CMainFrame::GetIcon(int nDocType)
{
    switch (nDocType)
    {
        case RD_WINWORD6:
        case RD_WORDPAD:
        case RD_EMBEDDED:
        case RD_RICHTEXT:
            return m_hIconDoc;
        case RD_TEXT:
        case RD_OEMTEXT:
            return m_hIconText;
        case RD_WRITE:
            return m_hIconWrite;
    }
    return m_hIconDoc;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnFontChange()
{
    m_wndFormatBar.SendMessage(CWordPadApp::m_nPrinterChangedMsg);
}

void CMainFrame::OnDevModeChange(LPTSTR lpDeviceName)
{
    theApp.NotifyPrinterChanged();
    CFrameWnd::OnDevModeChange(lpDeviceName); //sends message to descendants
}

void CMainFrame::OnSysColorChange()
{
    CFrameWnd::OnSysColorChange();
    m_wndRulerBar.SendMessage(WM_SYSCOLORCHANGE);
}

void CMainFrame::ActivateFrame(int nCmdShow)
{
    WINDOWPLACEMENT wp ;

    wp.length = sizeof(WINDOWPLACEMENT) ;

    if (GetWindowPlacement(&wp))
    {
        memcpy(&wp.rcNormalPosition, &theApp.m_rectInitialFrame, sizeof(RECT)) ;

        if (-1 != nCmdShow)
            wp.showCmd = nCmdShow;
        
        SetWindowPlacement(&wp) ;
    }
    
    CFrameWnd::ActivateFrame(nCmdShow);
    // make sure and display the toolbar, ruler, etc while loading a document.
    OnIdleUpdateCmdUI();
    UpdateWindow();
}

void CMainFrame::OnSize(UINT nType, int cx, int cy)
{
    CFrameWnd::OnSize(nType, cx, cy);
    theApp.m_bMaximized = (nType == SIZE_MAXIMIZED);
    if (nType == SIZE_RESTORED)
        GetWindowRect(theApp.m_rectInitialFrame);
}

BOOL CMainFrame::OnBarCheck(UINT barID)
{
    CDocOptions::CBarState &state = theApp.GetDocOptions().GetBarState();
    CControlBar            *bar = GetControlBar(barID);
    BOOL                    bVisible = !(bar->GetStyle() & WS_VISIBLE);

    switch (barID)
    {
    case ID_VIEW_STATUS_BAR: state.m_bStatusBar = bVisible;   break;
    case ID_VIEW_FORMATBAR:  state.m_bFormatBar = bVisible;   break;
    case ID_VIEW_RULER:      state.m_bRulerBar = bVisible;    break;
    case ID_VIEW_TOOLBAR:    state.m_bToolBar = bVisible;     break;
    }

    return CFrameWnd::OnBarCheck(barID);
}

LONG CMainFrame::OnBarState(UINT wParam, LONG lParam)
{
    if (lParam == -1)
        return 0L;
    ASSERT(lParam != RD_EMBEDDED);
    if (wParam == 0)
    {
        CDockState& ds = theApp.GetDockState(lParam);
        ds.Clear(); // empty out the dock state
        GetDockState(ds);
    }
    else
    {
        if (IsTextType(lParam))
        {
            // in text mode hide the ruler and format bar so that it is the default
            CControlBar* pBar = GetControlBar(ID_VIEW_FORMATBAR);
            if (pBar != NULL)
                pBar->ShowWindow(SW_HIDE);
            pBar = GetControlBar(ID_VIEW_RULER);
            if (pBar != NULL)
                pBar->ShowWindow(SW_HIDE);
        }
        HICON hIcon = GetIcon((int)lParam);
        SendMessage(WM_SETICON, TRUE, (LPARAM)hIcon);
        SetDockState(theApp.GetDockState(lParam));
    }
    return 0L;
}

void CMainFrame::OnMove(int x, int y)
{
    CFrameWnd::OnMove(x, y);
    WINDOWPLACEMENT wp;
    wp.length = sizeof(wp);
    GetWindowPlacement(&wp);
    theApp.m_rectInitialFrame = wp.rcNormalPosition;
    CView* pView = GetActiveView();
    if (pView != NULL)
        pView->SendMessage(WM_MOVE);
}

LONG CMainFrame::OnOpenMsg(UINT, LONG lParam)
{
    TCHAR szAtomName[256];
    szAtomName[0] = NULL;
    GlobalGetAtomName((ATOM)lParam, szAtomName, 256);
    CWordPadDoc* pDoc = (CWordPadDoc*)GetActiveDocument();
    if (szAtomName[0] != NULL && pDoc != NULL)
    {
        if (lstrcmpi(szAtomName, pDoc->GetPathName()) == 0)
            return TRUE;
    }
    return FALSE;
}

LONG CMainFrame::OnOLEHelpMsg(UINT, LONG)
{
    CWnd* pMainWnd = AfxGetMainWnd();
    ASSERT_VALID(pMainWnd);

    // return global app help mode state to FALSE (backward compatibility)
    m_bHelpMode = FALSE;
    pMainWnd->PostMessage(WM_KICKIDLE); // trigger idle update

    ::HtmlHelpA( ::GetDesktopWindow(), "wordpad.chm", HH_DISPLAY_TOPIC, 0L );

   return TRUE ;
}

void CMainFrame::OnHelpFinder()
{
    ::HtmlHelpA( ::GetDesktopWindow(), "wordpad.chm", HH_DISPLAY_TOPIC, 0L );
}

void CMainFrame::OnDropFiles(HDROP hDropInfo)
{
    TCHAR szFileName[_MAX_PATH];
    ::DragQueryFile(hDropInfo, 0, szFileName, _MAX_PATH);
    ::DragFinish(hDropInfo);
    theApp.OpenDocumentFile(szFileName);
}

void CMainFrame::OnCharColor()
{
    CColorMenu colorMenu;
    CRect rc;
    int index = m_wndFormatBar.CommandToIndex(ID_CHAR_COLOR);
    m_wndFormatBar.GetItemRect(index, &rc);
    m_wndFormatBar.ClientToScreen(rc);
    colorMenu.TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON,rc.left,rc.bottom, this);
}

void CMainFrame::OnPenToggle()
{
    static int nPen = 0;
    m_wndToolBar.SetButtons(toolbar, sizeof(toolbar)/sizeof(UINT) - nPen);
    nPen = (nPen == 0) ? NUM_PEN_TOGGLE : 0;
    m_wndToolBar.Invalidate();
    m_wndToolBar.GetParentFrame()->RecalcLayout();
}

BOOL CMainFrame::OnQueryNewPalette()
{
    CView* pView = GetActiveView();
    if (pView != NULL)
        return pView->SendMessage(WM_QUERYNEWPALETTE) != 0;
    return FALSE;
}

void CMainFrame::OnPaletteChanged(CWnd* pFocusWnd)
{
    CView* pView = GetActiveView();
    if (pView != NULL)
        pView->SendMessage(WM_PALETTECHANGED, (WPARAM)pFocusWnd->GetSafeHwnd());
}

//
// HACKHACK: MFC has a bug where m_nIdleFlags gets clobbered if the flags are
//           updated during idle processing (MFC4.2).  Workaround it by
//           forcing idleMenu and idleLayout after idle processing if 
//           DelayUpdateFrameMenu gets called during idle processing.
//

void CMainFrame::OnIdleUpdateCmdUI()
{
    m_inupdate = true;
    CFrameWnd::OnIdleUpdateCmdUI();

    if (m_reset)
    {
        m_nIdleFlags |= idleMenu | idleLayout;
        m_reset = false;
    }

    m_inupdate = false;
}

void CMainFrame::DelayUpdateFrameMenu(HMENU hMenuAlt)
{
    if (m_inupdate)
        m_reset = true;

    CFrameWnd::DelayUpdateFrameMenu(hMenuAlt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\mswd6_32.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef MSWD6_32_H
#define MSWD6_32_H

typedef unsigned long (pascal *PFN_RTF_CALLBACK)(int, int);

extern "C" int pascal InitConverter32(HANDLE, char *);
extern "C" HANDLE pascal RegisterApp32(unsigned long, void *);
extern "C" int pascal IsFormatCorrect32(HANDLE, HANDLE);
extern "C" int pascal ForeignToRtf32(HANDLE, void *, HANDLE, HANDLE, HANDLE, PFN_RTF_CALLBACK);
extern "C" int pascal RtfToForeign32(HANDLE, LPSTORAGE, HANDLE, HANDLE, PFN_RTF_CALLBACK);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\mainfrm.h ===
// mainfrm.h : interface of the CMainFrame class
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

#include "formatba.h"
#include "ruler.h"

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:
    HICON m_hIconDoc;
    HICON m_hIconText;
    HICON m_hIconWrite;
    HICON GetIcon(int nDocType);

// Operations
public:

// Overrides
    BOOL OnBarCheck(UINT barID);

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    public:
    virtual void ActivateFrame(int nCmdShow = -1);
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

public:
    CToolBar    m_wndToolBar;
    CStatusBar  m_wndStatusBar;
    CFormatBar  m_wndFormatBar;
    CRulerBar   m_wndRulerBar;
protected:  // control bar embedded members
    BOOL CreateToolBar();
    BOOL CreateFormatBar();
    BOOL CreateStatusBar();
    BOOL CreateRulerBar();
// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSysColorChange();
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnMove(int x, int y);
    afx_msg void OnHelpFinder();
    afx_msg void OnDropFiles(HDROP hDropInfo);
    afx_msg void OnCharColor();
    afx_msg void OnPenToggle();
    afx_msg void OnFontChange();
    afx_msg BOOL OnQueryNewPalette();
    afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
    afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
    //}}AFX_MSG
    afx_msg LONG OnBarState(UINT wParam, LONG lParam);
    afx_msg LONG OnOpenMsg(UINT wParam, LONG lParam);
   afx_msg LONG OnOLEHelpMsg(UINT wParam, LONG lParam);
    DECLARE_MESSAGE_MAP()

    virtual void DelayUpdateFrameMenu(HMENU hMenuAlt);
    afx_msg void OnIdleUpdateCmdUI();
    bool    m_inupdate;
    bool    m_reset;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\listdlg.cpp ===
// listdlg.cpp : Defines the class behaviors for the application.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "resource.h"
#include "listdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CListDlg, CDialog)
	//{{AFX_MSG_MAP(CListDlg)
	ON_LBN_DBLCLK(IDC_LISTDIALOG_LIST, OnOK)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CListDlg::CListDlg(UINT idStrDlgTitle, UINT idStrListTitle, 
	const CStringList& listItems, int nDefSel) : CDialog(CListDlg::IDD),
	m_listItems(listItems)
{
	VERIFY(m_strDlgTitle.LoadString(idStrDlgTitle));
	VERIFY(m_strListTitle.LoadString(idStrListTitle));
	m_nSelection = nDefSel;
}

BOOL CListDlg::OnInitDialog()
{
	SetWindowText(m_strDlgTitle);
// fix this
	SetDlgItemText(IDC_STATIC_HEADING, m_strListTitle);
	CListBox* pListBox = (CListBox*)GetDlgItem(IDC_LISTDIALOG_LIST);
	ASSERT(pListBox != NULL);
	// fill with document templates in list

	POSITION pos = m_listItems.GetHeadPosition();
	while (pos != NULL)
	{
		 if ( pListBox->AddString(m_listItems.GetNext(pos)) == -1)
		 	return FALSE;
	}
	pListBox->SetCurSel(m_nSelection);

	return CDialog::OnInitDialog();
}

void CListDlg::OnOK()
{
	CListBox* pListBox = (CListBox*)GetDlgItem(IDC_LISTDIALOG_LIST);
	ASSERT(pListBox != NULL);
	m_nSelection = pListBox->GetCurSel();
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\multconv.cpp ===
// convert.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "multconv.h"
#include "mswd6_32.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef CONVERTERS
CConverter* CConverter::m_pThis = NULL;
#endif

#define BUFFSIZE 4096

CTrackFile::CTrackFile(CFrameWnd* pWnd) : CFile()
{
    m_nLastPercent = -1;
    m_dwLength = 0;
    m_pFrameWnd = pWnd;
    VERIFY(m_strComplete.LoadString(IDS_COMPLETE));
    VERIFY(m_strWait.LoadString(IDS_PLEASE_WAIT));
    VERIFY(m_strSaving.LoadString(IDS_SAVING));
//  OutputPercent(0);
}

CTrackFile::~CTrackFile()
{
    OutputPercent(100);
    if (m_pFrameWnd != NULL)
        m_pFrameWnd->SetMessageText(AFX_IDS_IDLEMESSAGE);
}

UINT CTrackFile::Read(void FAR* lpBuf, UINT nCount)
{
    UINT n = CFile::Read(lpBuf, nCount);
    if (m_dwLength != 0)
        OutputPercent((int)((GetPosition()*100)/m_dwLength));
    return n;
}

void CTrackFile::Write(const void FAR* lpBuf, UINT nCount)
{
    CFile::Write(lpBuf, nCount);
    OutputString(m_strSaving);
//  if (m_dwLength != 0)
//      OutputPercent((int)((GetPosition()*100)/m_dwLength));
}

void CTrackFile::OutputString(LPCTSTR lpsz)
{
    if (m_pFrameWnd != NULL)
    {
        m_pFrameWnd->SetMessageText(lpsz);
        CWnd* pBarWnd = m_pFrameWnd->GetMessageBar();
        if (pBarWnd != NULL)
            pBarWnd->UpdateWindow();
    }
}

void CTrackFile::OutputPercent(int nPercentComplete)
{
    if (m_pFrameWnd != NULL && m_nLastPercent != nPercentComplete)
    {
        m_nLastPercent = nPercentComplete;
        TCHAR buf[64];
        int n = nPercentComplete;
        wsprintf(buf, (n==100) ? m_strWait : m_strComplete, n);
        OutputString(buf);
    }
}

COEMFile::COEMFile(CFrameWnd* pWnd) : CTrackFile(pWnd)
{
}

UINT COEMFile::Read(void FAR* lpBuf, UINT nCount)
{
    UINT n = CTrackFile::Read(lpBuf, nCount);
    OemToCharBuffA((const char*)lpBuf, (char*)lpBuf, n);
    return n;
}

void COEMFile::Write(const void FAR* lpBuf, UINT nCount)
{
    CharToOemBuffA((const char*)lpBuf, (char*)lpBuf, nCount);
    CTrackFile::Write(lpBuf, nCount);
}

#ifdef CONVERTERS

HGLOBAL CConverter::StringToHGLOBAL(LPCSTR pstr)
{
    HGLOBAL hMem = NULL;
    if (pstr != NULL)
    {
        hMem = GlobalAlloc(GHND, (lstrlenA(pstr)*2)+1);
        if (NULL == hMem)
            AfxThrowMemoryException();
        char* p = (char*) GlobalLock(hMem);
        if (p != NULL)
            lstrcpyA(p, pstr);
        GlobalUnlock(hMem);
    }
    return hMem;
}

CConverter::CConverter(LPCTSTR pszLibName, CFrameWnd* pWnd) : CTrackFile(pWnd)
{
    USES_CONVERSION;
    m_hBuff = NULL;
    m_pBuf = NULL;
    m_nBytesAvail = 0;
    m_nBytesWritten = 0;
    m_nPercent = 0;
    m_hEventFile = NULL;
    m_hEventConv = NULL;
    m_bDone = TRUE;
    m_bConvErr = FALSE;
    m_hFileName = NULL;
    m_bUseOEM = TRUE;

    #ifndef _X86_

    //Prevent known alignment exception problems in write converter
    //from crashing the app on some RISC machines

    m_uPrevErrMode = SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT);

    #endif

    m_hLibCnv = LoadLibrary(pszLibName);

    if (NULL != m_hLibCnv)
    {
        LoadFunctions();
        ASSERT(m_pInitConverter != NULL);
        if (m_pInitConverter != NULL)
        {
         //
         // For the current converters, you have to pass a *static*
         // string to InitConverter32
         //

            VERIFY(m_pInitConverter(AfxGetMainWnd()->GetSafeHwnd(), "WORDPAD"));
        }

        if (m_pRegisterApp != NULL)
        {
            NegotiateForNonOEM();
        }
    }
}

CConverter::~CConverter()
{
    if (!m_bDone) // converter thread hasn't exited
    {
        m_bDone = TRUE;

        if (!m_bForeignToRtf)
            WaitForConverter();

        m_nBytesAvail = 0;
        VERIFY(ResetEvent(m_hEventFile));
        m_nBytesAvail = 0;
        SetEvent(m_hEventConv);
        WaitForConverter();// wait for DoConversion exit
        VERIFY(ResetEvent(m_hEventFile));
    }

    if (m_hEventFile != NULL)
        VERIFY(CloseHandle(m_hEventFile));
    if (m_hEventConv != NULL)
        VERIFY(CloseHandle(m_hEventConv));
    if (m_hLibCnv != NULL)
        FreeLibrary(m_hLibCnv);
    if (m_hFileName != NULL)
        GlobalFree(m_hFileName);

    #ifndef _X86_

    //Reset error mode to what it was before we changed it in
    //the constructor

    SetErrorMode(m_uPrevErrMode);

    #endif
}

void CConverter::WaitForConverter()
{
    // while event not signalled -- process messages
    while (MsgWaitForMultipleObjects(1, &m_hEventFile, FALSE, INFINITE,
        QS_SENDMESSAGE) != WAIT_OBJECT_0)
    {
        MSG msg;
        while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
}

void CConverter::WaitForBuffer()
{
    // while event not signalled -- process messages
    while (MsgWaitForMultipleObjects(1, &m_hEventConv, FALSE, INFINITE,
        QS_SENDMESSAGE) != WAIT_OBJECT_0)
    {
        MSG msg;
        while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
}

UINT AFX_CDECL CConverter::ConverterThread(LPVOID)  // AFX_CDECL added by t-stefb
{
    ASSERT(m_pThis != NULL);

#if defined(_DEBUG)
    HRESULT hRes = OleInitialize(NULL);
    ASSERT(hRes == S_OK || hRes == S_FALSE);
#else
    OleInitialize(NULL);
#endif

    m_pThis->DoConversion();
    OleUninitialize();

    return 0;
}

BOOL CConverter::IsFormatCorrect(LPCTSTR pszFileName)
{
    USES_CONVERSION;
    int nRet;
    if (m_hLibCnv == NULL || m_pIsFormatCorrect == NULL)
        return FALSE;

    char buf[_MAX_PATH];
    strcpy(buf, T2CA(pszFileName));

    if (m_bUseOEM)
        CharToOemA(buf, buf);

    HGLOBAL hFileName = StringToHGLOBAL(buf);
    HGLOBAL hDesc = GlobalAlloc(GHND, 256);
    if (NULL == hDesc)
        AfxThrowMemoryException();
    nRet = m_pIsFormatCorrect(hFileName, hDesc);
    GlobalFree(hDesc);
    GlobalFree(hFileName);
    return (nRet == 1) ? TRUE : FALSE;
}

// static callback function
int CALLBACK CConverter::WriteOutStatic(int cch, int nPercentComplete)
{
    ASSERT(m_pThis != NULL);
    return m_pThis->WriteOut(cch, nPercentComplete);
}

int CALLBACK CConverter::WriteOut(int cch, int nPercentComplete)
{
    ASSERT(m_hBuff != NULL);
    m_nPercent = nPercentComplete;
    if (m_hBuff == NULL)
        return -9;

    //
    // If m_bDone is TRUE that means the richedit control has stopped
    // streaming in text and is trying to destroy the CConverter object but
    // the converter still has more data to give
    //

    if (m_bDone)
    {
        ASSERT(!"Richedit control stopped streaming prematurely");
        AfxMessageBox(IDS_CONVERTER_ABORTED);
        return -9;
    }

    if (cch != 0)
    {
        WaitForBuffer();
        VERIFY(ResetEvent(m_hEventConv));
        m_nBytesAvail = cch;
        SetEvent(m_hEventFile);
        WaitForBuffer();
    }
    return 0; //everything OK
}

int CALLBACK CConverter::ReadInStatic(int /*flags*/, int nPercentComplete)
{
    ASSERT(m_pThis != NULL);
    return m_pThis->ReadIn(nPercentComplete);
}

int CALLBACK CConverter::ReadIn(int /*nPercentComplete*/)
{
    ASSERT(m_hBuff != NULL);
    if (m_hBuff == NULL)
        return -8;

    SetEvent(m_hEventFile);
    WaitForBuffer();
    VERIFY(ResetEvent(m_hEventConv));

    return m_nBytesAvail;
}

BOOL CConverter::DoConversion()
{
    USES_CONVERSION;
    m_nLastPercent = -1;
//  m_dwLength = 0; // prevent Read/Write from displaying
    m_nPercent = 0;

    ASSERT(m_hBuff != NULL);
    ASSERT(m_pThis != NULL);
    HGLOBAL hDesc = StringToHGLOBAL("");
    HGLOBAL hSubset = StringToHGLOBAL("");

    int nRet = -1;
    if (m_bForeignToRtf && NULL != m_pForeignToRtf)
    {
        ASSERT(m_pForeignToRtf != NULL);
        ASSERT(m_hFileName != NULL);
        nRet = m_pForeignToRtf(m_hFileName, NULL, m_hBuff, hDesc, hSubset,
            (LPFNOUT)WriteOutStatic);
        // wait for next CConverter::Read to come through
        WaitForBuffer();
        VERIFY(ResetEvent(m_hEventConv));
    }
    else if (!m_bForeignToRtf && NULL != m_pRtfToForeign)
    {
        ASSERT(m_pRtfToForeign != NULL);
        ASSERT(m_hFileName != NULL);
        nRet = m_pRtfToForeign(m_hFileName, NULL, m_hBuff, hDesc,
            (LPFNIN)ReadInStatic);
        // don't need to wait for m_hEventConv
    }

    GlobalFree(hDesc);
    GlobalFree(hSubset);
    if (m_pBuf != NULL)
        GlobalUnlock(m_hBuff);
    GlobalFree(m_hBuff);

    if (nRet != 0)
        m_bConvErr = TRUE;

    m_bDone = TRUE;
    m_nPercent = 100;
    m_nLastPercent = -1;

    SetEvent(m_hEventFile);

    return (nRet == 0);
}

void CConverter::LoadFunctions()
{
    m_pInitConverter = (PINITCONVERTER)GetProcAddress(m_hLibCnv, "InitConverter32");
    m_pIsFormatCorrect = (PISFORMATCORRECT)GetProcAddress(m_hLibCnv, "IsFormatCorrect32");
    m_pForeignToRtf = (PFOREIGNTORTF)GetProcAddress(m_hLibCnv, "ForeignToRtf32");
    m_pRtfToForeign = (PRTFTOFOREIGN)GetProcAddress(m_hLibCnv, "RtfToForeign32");
    m_pRegisterApp = (PREGISTERAPP) GetProcAddress(m_hLibCnv, "RegisterApp");
}
#endif

///////////////////////////////////////////////////////////////////////////////

BOOL CConverter::Open(LPCTSTR pszFileName, UINT nOpenFlags,
    CFileException* pException)
{
    USES_CONVERSION;

    // The converters only speak ansi

    char buf[_MAX_PATH];
    buf[_MAX_PATH - 1] = '\0';
    strncpy(buf, T2CA(pszFileName), _MAX_PATH);

    // Make sure we don't overflow the buffer on DBCS strings
    if ('\0' != buf[_MAX_PATH - 1])
        return FALSE;

    if (m_bUseOEM)
        CharToOemA(buf, buf);

    // let's make sure we could do what is wanted directly even though we aren't
    m_bCloseOnDelete = FALSE;
    m_hFile = (UINT)hFileNull;

    BOOL bOpen = CFile::Open(A2CT(buf), nOpenFlags, pException);
    CFile::Close();
    if (!bOpen)
        return FALSE;

    m_bForeignToRtf = !(nOpenFlags & (CFile::modeReadWrite | CFile::modeWrite));

    // check for reading empty file
    if (m_bForeignToRtf)
    {
        CFileStatus _stat;
        if (CFile::GetStatus(A2CT(buf), _stat) && _stat.m_size == 0)
            return TRUE;
    }

    //set security attributes to inherit handle
    SECURITY_ATTRIBUTES sa = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};
    //create the events
    m_hEventFile = CreateEvent(&sa, TRUE, FALSE, NULL);
    m_hEventConv = CreateEvent(&sa, TRUE, FALSE, NULL);
    //create the converter thread and create the events

    ASSERT(m_hFileName == NULL);
    m_hFileName = StringToHGLOBAL(buf);

    m_pThis = this;
    m_bDone = FALSE;
    m_hBuff = GlobalAlloc(GHND, BUFFSIZE);
    ASSERT(m_hBuff != NULL);

    AfxBeginThread(ConverterThread, this, THREAD_PRIORITY_NORMAL, 0, 0, &sa);

    return TRUE;
}

// m_hEventConv -- the main thread signals this event when ready for more data
// m_hEventFile -- the converter signals this event when data is ready

UINT CConverter::Read(void FAR* lpBuf, UINT nCount)
{
    ASSERT(m_bForeignToRtf);
    if (m_bDone)
        return 0;
    // if converter is done
    int cch = nCount;
    BYTE* pBuf = (BYTE*)lpBuf;
    while (cch != 0)
    {
        if (m_nBytesAvail == 0)
        {
            if (m_pBuf != NULL)
                GlobalUnlock(m_hBuff);
            m_pBuf = NULL;
            SetEvent(m_hEventConv);
            WaitForConverter();
            VERIFY(ResetEvent(m_hEventFile));
            if (m_bConvErr)
                AfxThrowFileException(CFileException::generic);
            if (m_bDone)
                return nCount - cch;
            m_pBuf = (BYTE*)GlobalLock(m_hBuff);
            ASSERT(m_pBuf != NULL);
        }
        int nBytes = min(cch, m_nBytesAvail);
        memcpy(pBuf, m_pBuf, nBytes);
        pBuf += nBytes;
        m_pBuf += nBytes;
        m_nBytesAvail -= nBytes;
        cch -= nBytes;
        OutputPercent(m_nPercent);
    }
    return nCount - cch;
}

void CConverter::Write(const void FAR* lpBuf, UINT nCount)
{
    ASSERT(!m_bForeignToRtf);

    m_nBytesWritten += nCount;
    while (nCount != 0)
    {
        WaitForConverter();
        VERIFY(ResetEvent(m_hEventFile));
        if (m_bConvErr)
            AfxThrowFileException(CFileException::generic);
        m_nBytesAvail = min(nCount, BUFFSIZE);
        nCount -= m_nBytesAvail;
        BYTE* pBuf = (BYTE*)GlobalLock(m_hBuff);
        ASSERT(pBuf != NULL);
        memcpy(pBuf, lpBuf, m_nBytesAvail);
        GlobalUnlock(m_hBuff);
        SetEvent(m_hEventConv);
    }
    OutputString(m_strSaving);
}

LONG CConverter::Seek(LONG lOff, UINT nFrom)
{
    if (lOff != 0 && nFrom != current)
        AfxThrowNotSupportedException();
    return 0;
}

DWORD CConverter::GetPosition() const
{
    return 0;
}

void CConverter::Flush()
{
}

void CConverter::Close()
{
    if (!m_bDone) // converter thread hasn't exited
    {
        m_bDone = TRUE;

        if (!m_bForeignToRtf)
            WaitForConverter();

        m_nBytesAvail = 0;
        VERIFY(ResetEvent(m_hEventFile));
        m_nBytesAvail = 0;
        SetEvent(m_hEventConv);
        WaitForConverter();// wait for DoConversion exit
        VERIFY(ResetEvent(m_hEventFile));
    }

    if (m_bConvErr)
        AfxThrowFileException(CFileException::generic);
}

void CConverter::Abort()
{
}

DWORD CConverter::GetLength() const
{
    ASSERT_VALID(this);
    return 1;
}

CFile* CConverter::Duplicate() const
{
    AfxThrowNotSupportedException();
    return NULL;
}

void CConverter::LockRange(DWORD, DWORD)
{
    AfxThrowNotSupportedException();
}

void CConverter::UnlockRange(DWORD, DWORD)
{
    AfxThrowNotSupportedException();
}

void CConverter::SetLength(DWORD)
{
    AfxThrowNotSupportedException();
}



//+--------------------------------------------------------------------------
//
//  Method:     CConverter::NegotiateForNonOEM
//
//  Synopsis:   Try to tell the converter not to expect OEM filenames
//
//  Parameters: None
//
//  Returns:    void
//
//  Notes:      The converter's RegisterApp function will return a handle
//              containing it's preferences (what it supports).  The
//              data structure is a 16-bit size and then a sequence of
//              records.  For each record the first byte is the size, the
//              second is the "opcode", and then some variable-length opcode
//              specific data.  All sizes are inclusive.
//
//---------------------------------------------------------------------------

void CConverter::NegotiateForNonOEM()
{
    ASSERT(NULL != m_pRegisterApp);

    HGLOBAL     hPrefs;
    BYTE       *pPrefs;
    __int16     cbPrefs;

    //
    // Tell the converter we don't want to use OEM
    //

    hPrefs = (*m_pRegisterApp)(fRegAppSupportNonOem, NULL);

    if (NULL == hPrefs)
        return;

    pPrefs = (BYTE *) GlobalLock(hPrefs);

    if (NULL == pPrefs)
    {
        ASSERT(!"GlobalLock failed");
        GlobalFree(hPrefs);
        return;
    }

    //
    // Parse the returned structure looking for a RegAppOpcodeCharset opcode.
    // The argument for this opcode should be either ANSI_CHARSET or
    // OEM_CHARSET.  If its ANSI_CHARSET then we can talk Ansi otherwise were
    // stuck with OEM.
    //

    cbPrefs = (__int16) ((* (__int16 *) pPrefs) - sizeof(cbPrefs));
    pPrefs += sizeof(cbPrefs);

    while (cbPrefs > 0)
    {
        if (RegAppOpcodeCharset == pPrefs[1])
        {
            ASSERT(ANSI_CHARSET == pPrefs[2] || OEM_CHARSET == pPrefs[2]);

            m_bUseOEM = (OEM_CHARSET == pPrefs[2]);
            break;
        }
        else
        {
            if (pPrefs[0] <= 0)
            {
                ASSERT(!"RegisterApp is returning bogus data");
                break;
            }

            cbPrefs = (__int16) (cbPrefs - pPrefs[0]);
            pPrefs += pPrefs[0];
        }
    }

    GlobalUnlock(pPrefs);
    GlobalFree(hPrefs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\oleimpl3.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


/////////////////////////////////////////////////////////////////////////////
// OLE data (like AUX_DATA)

struct OLE_DATA
{
	// OLE 1.0 clipboard formats
	UINT    cfNative, cfOwnerLink, cfObjectLink;

	// OLE 2.0 clipboard formats
	UINT    cfEmbeddedObject, cfEmbedSource, cfLinkSource;
	UINT    cfObjectDescriptor, cfLinkSourceDescriptor;
	UINT    cfFileName, cfFileNameW;

	//RichEdit formats
	UINT    cfRichTextFormat;
	UINT    cfRichTextAndObjects;

	OLE_DATA();
};

extern OLE_DATA _oleData;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\multconv.h ===
// convert.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifdef CONVERTERS

/////////////////////////////////////////////////////////////////////////////
// CConverter

typedef int (CALLBACK *LPFNOUT)(int cch, int nPercentComplete);
typedef int (CALLBACK *LPFNIN)(int flags, int nPercentComplete);
typedef BOOL (FAR PASCAL *PINITCONVERTER)(HWND hWnd, LPCSTR lpszModuleName);
typedef BOOL (FAR PASCAL *PISFORMATCORRECT)(HANDLE ghszFile, HANDLE ghszClass);
typedef int (FAR PASCAL *PFOREIGNTORTF)(HANDLE ghszFile, LPVOID lpv, HANDLE ghBuff, 
	HANDLE ghszClass, HANDLE ghszSubset, LPFNOUT lpfnOut);
typedef int (FAR PASCAL *PRTFTOFOREIGN)(HANDLE ghszFile, LPVOID lpv, HANDLE ghBuff, 
	HANDLE ghszClass, LPFNIN lpfnIn);
typedef HGLOBAL (FAR PASCAL *PREGISTERAPP)(long lFlags, void *lpRegApp);


//
// Some defines taken from the converter group's convapi.h
//

#define fRegAppSupportNonOem    0x00000008  // supports non-Oem filenames
#define RegAppOpcodeCharset             0x03    // for REGAPPRET


#endif

/////////////////////////////////////////////////////////////////////////////
// CTrackFile
class CTrackFile : public CFile
{ 
public:
//Construction
	CTrackFile(CFrameWnd* pWnd);
	~CTrackFile();
	
//Attributes
	int m_nLastPercent;
	DWORD m_dwLength;
	CFrameWnd* m_pFrameWnd;
	CString m_strComplete;
	CString m_strWait;
	CString m_strSaving;
//Operations
	void OutputPercent(int nPercentComplete = 0);
	void OutputString(LPCTSTR lpsz);
	virtual UINT Read(void FAR* lpBuf, UINT nCount);
	virtual void Write(const void FAR* lpBuf, UINT nCount);
};

class COEMFile : public CTrackFile
{
public:
	COEMFile(CFrameWnd* pWnd);
	virtual UINT Read(void FAR* lpBuf, UINT nCount);
	virtual void Write(const void FAR* lpBuf, UINT nCount);
};

#ifdef CONVERTERS

class CConverter : public CTrackFile
{
public:
	CConverter(LPCTSTR pszLibName, CFrameWnd* pWnd = NULL);

public:
//Attributes
	int m_nPercent;
	BOOL m_bDone;
	BOOL m_bConvErr;
	virtual DWORD GetPosition() const;

// Operations
	BOOL IsFormatCorrect(LPCTSTR pszFileName);
	BOOL DoConversion();
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags,
		CFileException* pError = NULL);
	void WaitForConverter();
	void WaitForBuffer();

// Overridables
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual DWORD GetLength() const;

	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);

	virtual void Abort();
	virtual void Flush();
	virtual void Close();

// Unsupported
	virtual CFile* Duplicate() const;
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);
	virtual void SetLength(DWORD dwNewLen);

//Implementation
public:
	~CConverter();

protected:
	int         m_nBytesAvail;
	int         m_nBytesWritten;
	HANDLE      m_hEventFile;
	HANDLE      m_hEventConv;
	BOOL        m_bForeignToRtf;        // True to convert to RTF, else from
	HGLOBAL     m_hBuff;                // Buffer for converter data
	BYTE*       m_pBuf;                 // Pointer to m_hBuff data
	HGLOBAL     m_hFileName;            // File to convert
	HINSTANCE   m_hLibCnv;              // The converter dll
    BOOL        m_bUseOEM;              // TRUE to use OEM filenames

    // Entry points into the converter dll

	PINITCONVERTER      m_pInitConverter;
	PISFORMATCORRECT    m_pIsFormatCorrect;
	PFOREIGNTORTF       m_pForeignToRtf;
	PRTFTOFOREIGN       m_pRtfToForeign;
    PREGISTERAPP        m_pRegisterApp;

	int CALLBACK WriteOut(int cch, int nPercentComplete);
	int CALLBACK ReadIn(int nPercentComplete);
	static HGLOBAL StringToHGLOBAL(LPCSTR pstr);
	static int CALLBACK WriteOutStatic(int cch, int nPercentComplete);
	static int CALLBACK ReadInStatic(int flags, int nPercentComplete);
	static UINT AFX_CDECL ConverterThread(LPVOID pParam);
	static CConverter *m_pThis;

	void LoadFunctions();
    void NegotiateForNonOEM();

    #ifndef _X86_

    //We need to change the error mode when using the write converter
    //to fix some alignment problems caused by the write converter.  These
    //problems do not affect x86 platforms.

    UINT m_uPrevErrMode ;

    #endif
};

#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\oleinit.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "stdafx2.h"

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

#ifdef _MAC
AEEventHandlerUPP _afxPfnOleAuto;
#endif

/////////////////////////////////////////////////////////////////////////////
// OLE OLE_DATA init structure

OLE_DATA _oleData;

OLE_DATA::OLE_DATA()
{
	// OLE 1.0 Clipboard formats
	cfNative = ::RegisterClipboardFormat(_T("Native"));
	cfOwnerLink = ::RegisterClipboardFormat(_T("OwnerLink"));
	cfObjectLink = ::RegisterClipboardFormat(_T("ObjectLink"));

	// OLE 2.0 Clipboard formats
	cfEmbeddedObject = ::RegisterClipboardFormat(_T("Embedded Object"));
	cfEmbedSource = ::RegisterClipboardFormat(_T("Embed Source"));
	cfLinkSource = ::RegisterClipboardFormat(_T("Link Source"));
	cfObjectDescriptor = ::RegisterClipboardFormat(_T("Object Descriptor"));
	cfLinkSourceDescriptor = ::RegisterClipboardFormat(_T("Link Source Descriptor"));
	cfFileName = ::RegisterClipboardFormat(_T("FileName"));
	cfFileNameW = ::RegisterClipboardFormat(_T("FileNameW"));
	cfRichTextFormat = ::RegisterClipboardFormat(_T("Rich Text Format"));
	cfRichTextAndObjects = ::RegisterClipboardFormat(_T("RichEdit Text and Objects"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\options.h ===
// options.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CUnit
{
public:
	int m_nTPU;
	int m_nSmallDiv;	// small divisions - small line displayed
	int m_nMediumDiv;	// medium divisions - large line displayed
	int m_nLargeDiv;	// large divisions - numbers displayed
	int m_nMinMove;		// minimum tracking movements
	UINT m_nAbbrevID;
	BOOL m_bSpaceAbbrev; // put space before abbreviation
	CString m_strAbbrev;// cm, pt, pi, ", in, inch, inches

	CUnit() {}
	CUnit(int nTPU, int nSmallDiv, int nMediumDiv, int nLargeDiv, 
		int nMinMove, UINT nAbbrevID, BOOL bSpaceAbbrev);
	const CUnit& operator=(const CUnit& unit);
};

class CDocOptions
{
public:
	CDocOptions(int nDefWrap) {m_nDefWrap = nDefWrap;}
	CDockState m_ds1;
	CDockState m_ds2;

	int m_nWordWrap;
	int m_nDefWrap;

    struct CBarState
    {
        BOOL m_bRulerBar;
        BOOL m_bStatusBar;
        BOOL m_bToolBar;
        BOOL m_bFormatBar;
    }
    m_barstate[2];

	void SaveOptions(LPCTSTR lpsz);
	void LoadOptions(LPCTSTR lpsz);
	void SaveDockState(CDockState& ds, LPCTSTR lpszProfileName, 
		LPCTSTR lpszLayout);
	void LoadDockState(CDockState& ds, LPCTSTR lpszProfileName, 
		LPCTSTR lpszLayout);
	CDockState& GetDockState(BOOL bPrimary) {return (bPrimary) ? m_ds1 : m_ds2;}
    CBarState & GetBarState(BOOL bPrimary = TRUE) {return bPrimary ? m_barstate[0] : m_barstate[1];}
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\options.cpp ===
// options.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "strings.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDocOptions


void CDocOptions::SaveDockState(CDockState& ds, LPCTSTR lpszProfileName, LPCTSTR lpszLayout)
{
	CMemFile file;
	CArchive ar(&file, CArchive::store);
	ds.Serialize(ar);
	ar.Close();
	int nSize = file.GetLength();
	ASSERT(nSize < 4096);
	BYTE* p = new BYTE[nSize];
	file.SeekToBegin();
	file.Read(p, nSize);
	theApp.WriteProfileBinary(lpszProfileName, lpszLayout, p, nSize);
	delete [] p;
}

void CDocOptions::SaveOptions(LPCTSTR lpszProfileName)
{
	SaveDockState(m_ds1, lpszProfileName, szLayout1);
	SaveDockState(m_ds2, lpszProfileName, szLayout2);
	theApp.WriteProfileInt(lpszProfileName, szWrap, m_nWordWrap);

    int barstate[2] = {0, 0};

    for (int i = 0; i < 2; i++)
    {
        barstate[i] = barstate[i] | (m_barstate[i].m_bRulerBar  ? 0x1 : 0);
        barstate[i] = barstate[i] | (m_barstate[i].m_bStatusBar ? 0x2 : 0);
        barstate[i] = barstate[i] | (m_barstate[i].m_bToolBar   ? 0x4 : 0);
        barstate[i] = barstate[i] | (m_barstate[i].m_bFormatBar ? 0x8 : 0);
    }

    theApp.WriteProfileInt(lpszProfileName, TEXT("BarState0"), barstate[0]);
    theApp.WriteProfileInt(lpszProfileName, TEXT("BarState1"), barstate[1]);
}

void CDocOptions::LoadDockState(CDockState& ds, LPCTSTR lpszProfileName, LPCTSTR lpszLayout)
{
	BYTE* p;
	UINT nLen = 0;
	if (theApp.GetProfileBinary(lpszProfileName, lpszLayout, &p, &nLen))
	{
		ASSERT(nLen < 4096);

      //
      // APPCOMPAT: If this value is not reasonable, then we have likely run into
      // a registry corruption problem with wordpad that seems to appear only once
      // every 2-3 months.  If the registry is corrupted, then we need to fix
      // it or wordpad will get into a weird state.
      //

      if (nLen >= 4096)
      {
          delete p ;

          HKEY hKeyApp = theApp.GetAppRegistryKey() ;

          if ((HKEY) 0 != hKeyApp)
          {
              RegDeleteKey(hKeyApp, lpszProfileName) ;
              RegCloseKey(hKeyApp) ;
          }
      }
      else
      {
		    CMemFile file;
		    file.Write(p, nLen);
		    file.SeekToBegin();
		    CArchive ar(&file, CArchive::load);
		    ds.Serialize(ar);
		    ar.Close();
		    delete p;
      }
	}
}

void CDocOptions::LoadOptions(LPCTSTR lpszProfileName)
{
	LoadDockState(m_ds1, lpszProfileName, szLayout1);
	LoadDockState(m_ds2, lpszProfileName, szLayout2);
	m_nWordWrap = theApp.GetProfileInt(lpszProfileName, szWrap, m_nDefWrap);


    for (int bar = 0; bar < 2; bar++)
    {
        CDockState& ds = (bar == 0) ? m_ds1 : m_ds2;
        CBarState& barstate = m_barstate[bar];

        int defaultstate = (lpszProfileName == szTextSection) ? 0x6 : 0xf;
        int state;

        if (0 == bar)
        {
            state = theApp.GetProfileInt(lpszProfileName, TEXT("BarState0"), defaultstate);
        }
        else
        {
            state = theApp.GetProfileInt(lpszProfileName, TEXT("BarState1"), defaultstate);
        }

        barstate.m_bRulerBar =  (state & 0x1) != 0;
        barstate.m_bStatusBar = (state & 0x2) != 0;
        barstate.m_bToolBar =   (state & 0x4) != 0;
        barstate.m_bFormatBar = (state & 0x8) != 0;

        //
        // The following code is used to setup the barstate from the dock state.
        // It is really only here to support upgrading from NT 4 or Win95 to
        // NT 5 or Memphis.  It can problably be removed for NT 6.
        //

        for (int i = 0;i < ds.m_arrBarInfo.GetSize(); i++)
	    {
		    CControlBarInfo* pInfo = (CControlBarInfo*)ds.m_arrBarInfo[i];
		    ASSERT(pInfo != NULL);
		    switch (pInfo->m_nBarID)
		    {
			    case ID_VIEW_FORMATBAR:
                    barstate.m_bFormatBar = pInfo->m_bVisible;
				    break;
			    case ID_VIEW_RULER:
                    barstate.m_bRulerBar = pInfo->m_bVisible;
				    break;
			    case ID_VIEW_TOOLBAR:
                    barstate.m_bToolBar = pInfo->m_bVisible;;
				    break;
			    case ID_VIEW_STATUS_BAR:
                    barstate.m_bStatusBar = pInfo->m_bVisible;;
				    break;
		    }
	    }
    }
    
}

/////////////////////////////////////////////////////////////////////////////
// CUnit

const CUnit& CUnit::operator=(const CUnit& unit)
{
	m_nTPU = unit.m_nTPU;
	m_nSmallDiv = unit.m_nSmallDiv;
	m_nMediumDiv = unit.m_nMediumDiv;
	m_nLargeDiv = unit.m_nLargeDiv;
	m_nMinMove = unit.m_nMinMove;
	m_nAbbrevID = unit.m_nAbbrevID;
	m_bSpaceAbbrev = unit.m_bSpaceAbbrev;
	m_strAbbrev = unit.m_strAbbrev;
	return *this;
}

CUnit::CUnit(int nTPU, int nSmallDiv, int nMediumDiv, int nLargeDiv,
		int nMinMove, UINT nAbbrevID, BOOL bSpaceAbbrev)
{
	m_nTPU = nTPU;
	m_nSmallDiv = nSmallDiv;
	m_nMediumDiv = nMediumDiv;
	m_nLargeDiv = nLargeDiv;
	m_nMinMove = nMinMove;
	m_nAbbrevID = nAbbrevID;
	m_bSpaceAbbrev = bSpaceAbbrev;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\optionsh.cpp ===
// optionsh.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "unitspag.h"
#include "docopt.h"
#include "optionsh.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COptionSheet

COptionSheet::COptionSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	: CCSPropertySheet(nIDCaption, pParentWnd, iSelectPage),
	pageText(IDS_TEXT_OPTIONS), pageRTF(IDS_RTF_OPTIONS),
	pageWord(IDS_WORD6_OPTIONS), pageWrite(IDS_WRITE_OPTIONS),
	pageEmbedded()
{
	units.m_nUnits = theApp.GetUnits();
	units.m_bWordSel = theApp.m_bWordSel;
	pageText.m_nWordWrap = theApp.GetDocOptions(RD_TEXT).m_nWordWrap;
	pageRTF.m_nWordWrap = theApp.GetDocOptions(RD_RICHTEXT).m_nWordWrap;
	pageWord.m_nWordWrap = theApp.GetDocOptions(RD_WINWORD6).m_nWordWrap;
	pageWrite.m_nWordWrap = theApp.GetDocOptions(RD_WRITE).m_nWordWrap;
	pageEmbedded.m_nWordWrap = theApp.GetDocOptions(RD_EMBEDDED).m_nWordWrap;
	SetPageButtons(pageText, theApp.GetDocOptions(RD_TEXT));
	SetPageButtons(pageRTF, theApp.GetDocOptions(RD_RICHTEXT));
	SetPageButtons(pageWord, theApp.GetDocOptions(RD_WINWORD6));
	SetPageButtons(pageWrite, theApp.GetDocOptions(RD_WRITE));
	SetPageButtons(pageEmbedded, theApp.GetDocOptions(RD_EMBEDDED));
	SetPageButtons(pageEmbedded, theApp.GetDocOptions(RD_EMBEDDED), FALSE);
	AddPage(&units);
	AddPage(&pageText);
	AddPage(&pageRTF);
	AddPage(&pageWord);
	AddPage(&pageWrite);
	AddPage(&pageEmbedded);
}

void COptionSheet::SetPageButtons(CDocOptPage& page, CDocOptions& options, BOOL bPrimary)
{
    CDocOptions::CBarState& barstate = options.GetBarState(bPrimary);

    page.m_bFormatBar = barstate.m_bFormatBar;
    page.m_bRulerBar  = barstate.m_bRulerBar;
    page.m_bToolBar   = barstate.m_bToolBar;
    page.m_bStatusBar = barstate.m_bStatusBar;
}

void COptionSheet::SetState(CDocOptPage& page, CDocOptions& options, BOOL bPrimary)
{
    CDocOptions::CBarState& barstate = options.GetBarState(bPrimary);
    CDockState&             ds = options.GetDockState(bPrimary);

    barstate.m_bFormatBar = page.m_bFormatBar;
    barstate.m_bRulerBar  = page.m_bRulerBar;
    barstate.m_bToolBar   = page.m_bToolBar;
    barstate.m_bStatusBar = page.m_bStatusBar;

    for (int i = 0;i < ds.m_arrBarInfo.GetSize(); i++)
	{
		CControlBarInfo* pInfo = (CControlBarInfo*)ds.m_arrBarInfo[i];
		ASSERT(pInfo != NULL);
		switch (pInfo->m_nBarID)
		{
			case ID_VIEW_FORMATBAR:
				pInfo->m_bVisible = page.m_bFormatBar;
				break;
			case ID_VIEW_RULER:
				pInfo->m_bVisible = page.m_bRulerBar;
				break;
			case ID_VIEW_TOOLBAR:
				pInfo->m_bVisible = page.m_bToolBar;
				break;
			case ID_VIEW_STATUS_BAR:
				pInfo->m_bVisible = page.m_bStatusBar;
				break;
		}
	}
}

const DWORD m_nHelpIDs[] =
{
    AFX_IDC_TAB_CONTROL, (DWORD) -1,
    0, 0
};

LONG COptionSheet::OnHelp(WPARAM, LPARAM lParam)
{
    ::WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                AfxGetApp()->m_pszHelpFilePath,
                HELP_WM_HELP, (DWORD_PTR) m_nHelpIDs);
    return 0;
}

LONG COptionSheet::OnHelpContextMenu(WPARAM wParam, LPARAM)
{
    ::WinHelp((HWND)wParam, AfxGetApp()->m_pszHelpFilePath,
              HELP_CONTEXTMENU, (DWORD_PTR) m_nHelpIDs);
    return 0;
}

BEGIN_MESSAGE_MAP(COptionSheet, CCSPropertySheet)
	//{{AFX_MSG_MAP(COptionSheet)
	ON_WM_CREATE()
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnHelpContextMenu)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// COptionSheet message handlers

INT_PTR COptionSheet::DoModal()
{
   //
   // Turn apply button off
   //

   m_psh.dwFlags |= PSH_NOAPPLYNOW ;

	INT_PTR nRes = CCSPropertySheet::DoModal();
	if (nRes == IDOK)
	{
		SetState(pageText, theApp.GetDocOptions(RD_TEXT));
		SetState(pageRTF, theApp.GetDocOptions(RD_RICHTEXT));
		SetState(pageWord, theApp.GetDocOptions(RD_WINWORD6));
		SetState(pageWrite, theApp.GetDocOptions(RD_WRITE));
		SetState(pageEmbedded, theApp.GetDocOptions(RD_EMBEDDED));
		SetState(pageEmbedded, theApp.GetDocOptions(RD_EMBEDDED), FALSE);
		theApp.SetUnits(units.m_nUnits);
		theApp.m_bWordSel = units.m_bWordSel;
		theApp.GetDocOptions(RD_TEXT).m_nWordWrap = pageText.m_nWordWrap;
		theApp.GetDocOptions(RD_RICHTEXT).m_nWordWrap = pageRTF.m_nWordWrap;
		theApp.GetDocOptions(RD_WINWORD6).m_nWordWrap = pageWord.m_nWordWrap;
		theApp.GetDocOptions(RD_WRITE).m_nWordWrap = pageWrite.m_nWordWrap;
		theApp.GetDocOptions(RD_EMBEDDED).m_nWordWrap = pageEmbedded.m_nWordWrap;
	}
	return nRes;
}

/////////////////////////////////////////////////////////////////////////////
// COptionSheet message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\pageset.cpp ===
// pageset.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "resource.h"
#include "pageset.h"
#include "ruler.h"
#include "ddxm.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPageSetupDlg dialog

const DWORD CPageSetupDlg::m_nHelpIDs[] = 
{
	IDC_EDIT_TM, IDH_WORDPAD_TOPMARGIN,
	IDC_EDIT_BM, IDH_WORDPAD_BOTTOMMARGIN,
	IDC_EDIT_LM, IDH_WORDPAD_LEFTMARGIN,
	IDC_EDIT_RM, IDH_WORDPAD_RIGHTMARGIN,
	IDC_BOX, (DWORD) -1,
	0, 0
};

CPageSetupDlg::CPageSetupDlg(CWnd* pParent /*=NULL*/)
	: CCSDialog(CPageSetupDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPageSetupDlg)
	m_nTopMargin = 0;
	m_nRightMargin = 0;
	m_nLeftMargin = 0;
	m_nBottomMargin = 0;
	//}}AFX_DATA_INIT
}

void CPageSetupDlg::DoDataExchange(CDataExchange* pDX)
{
	CCSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPageSetupDlg)
	DDX_Twips(pDX, IDC_EDIT_TM, m_nTopMargin);
	DDV_MinMaxTwips(pDX, m_nTopMargin, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_RM, m_nRightMargin);
	DDV_MinMaxTwips(pDX, m_nRightMargin, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_LM, m_nLeftMargin);
	DDV_MinMaxTwips(pDX, m_nLeftMargin, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_BM, m_nBottomMargin);
	DDV_MinMaxTwips(pDX, m_nBottomMargin, -31680, 31680);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPageSetupDlg, CCSDialog)
	//{{AFX_MSG_MAP(CPageSetupDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPageSetupDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\optionsh.h ===
// optionsh.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// COptionSheet

class COptionSheet : public CCSPropertySheet
{
// Construction
public:
	COptionSheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:
	CUnitsPage units;
	CDocOptPage pageText;
	CDocOptPage pageRTF;
	CDocOptPage pageWord;
	CDocOptPage pageWrite;
	CEmbeddedOptPage pageEmbedded;

// Operations
public:
	INT_PTR DoModal();
	void SetPageButtons(CDocOptPage& page, CDocOptions& options, BOOL bPrimary = TRUE);
	void SetState(CDocOptPage& page, CDocOptions& optiosn, BOOL bPrimary = TRUE);

// Overrides
    virtual LONG OnHelp(WPARAM, LPARAM lParam);
    virtual LONG OnHelpContextMenu(WPARAM, LPARAM lParam);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COptionSheet)
	//}}AFX_VIRTUAL

// Implementation
public:

	// Generated message map functions
protected:
	//{{AFX_MSG(COptionSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\ruler.h ===
// riched.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __RULER_H__
#define __RULER_H__

class CWordPadView;
class CWordPadDoc;
class CRulerBar;

// ruler items include left margin, right margin, indent, and tabs

// horz positions in twips -- necessary to avoid rounding errors
// vertical position in pixels
class CRulerItem
{
public:
    CRulerItem(UINT nBitmapID = 0);
    ~CRulerItem();
    virtual BOOL HitTestPix(CPoint pt) { return GetHitRectPix().PtInRect(pt); }
    virtual void Draw(CDC& dc);
    virtual void SetHorzPosTwips(int nXPos);
    virtual void TrackHorzPosTwips(int nXPos, BOOL bOnRuler = TRUE);
    virtual void SetVertPos(int nYPos) { m_nYPosPix = nYPos; }
    virtual void SetAlignment(int nAlign) {m_nAlignment = nAlign;}
    virtual void SetRuler(CRulerBar* pRuler) {m_pRuler = pRuler;}
    virtual void SetBounds(int nMin, int nMax) { m_nMin = nMin; m_nMax = nMax; }
    int GetMin() { return m_nMin;}
    int GetMax() { return m_nMax;}
    void Invalidate();
    int GetVertPosPix() { return m_nYPosPix;}
    int GetHorzPosTwips() { return m_nXPosTwips;}
    int GetHorzPosPix();
    CRect GetHitRectPix();
    void DrawFocusLine();
    void SetTrack(BOOL b);

    HBITMAP m_hbm;
    HBITMAP m_hbmMask;
    CSize m_size;   // size of item in pixels

// Operations
    BOOL LoadMaskedBitmap(LPCTSTR lpszResourceName);

protected:
    int m_nYPosPix;
    int m_nXPosTwips;
    int m_nAlignment;
    BOOL m_bTrack;
    CRulerBar* m_pRuler;
    CRect m_rcTrack;
    CDC* m_pDC; // dc used for drawing tracking line
    int m_nMin, m_nMax;
};

class CComboRulerItem : public CRulerItem
{ 
public:
    CComboRulerItem(UINT nBitmapID1, UINT nBitmapID2, CRulerItem& item);
    virtual BOOL HitTestPix(CPoint pt);
    virtual void Draw(CDC& dc);
    virtual void SetHorzPosTwips(int nXPos);
    virtual void TrackHorzPosTwips(int nXPos, BOOL bOnRuler = TRUE);
    virtual void SetVertPos(int nYPos);
    virtual void SetAlignment(int nAlign);
    virtual void SetRuler(CRulerBar* pRuler);
    virtual void SetBounds(int nMin, int nMax);
    int GetMin();
    int GetMax();
protected:
    CRulerItem m_secondary;
    CRulerItem& m_link;
    BOOL m_bHitPrimary;
};

class CTabRulerItem : public CRulerItem
{
public:
    CTabRulerItem() { SetAlignment(TA_LEFT); }
    virtual void Draw(CDC& dc) {if (GetHorzPosTwips() != 0) CRulerItem::Draw(dc);}
    virtual void TrackHorzPosTwips(int nXPos, BOOL bOnRuler = TRUE);
    virtual BOOL HitTestPix(CPoint pt) { return (GetHorzPosTwips() != 0) ? CRulerItem::HitTestPix(pt) : FALSE;}
};

/////////////////////////////////////////////////////////////////////////////
// CRulerBar

class CRulerBar : public CControlBar
{
// Construction
public:
    CRulerBar();
    ~CRulerBar();

// Operations
public:
    virtual BOOL Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID);
protected:
    void Update(const PARAFORMAT& pf);
    void Update(CSize sizePaper, const CRect& rectMargins);

// Attributes
public:
    BOOL m_bDeferInProgress;
    CUnit m_unit;
    CRulerItem* m_pSelItem;
    CFont fnt;
    CSize GetBaseUnits();
    CComboRulerItem m_leftmargin;
    CRulerItem m_indent;
    CRulerItem m_rightmargin;
    CRulerItem m_tabItem;
    CTabRulerItem m_pTabItems[MAX_TAB_STOPS];
    CSize m_sizePaper;
    CRect m_rectMargin;
    int PrintWidth() {return m_sizePaper.cx - m_rectMargin.left - 
        m_rectMargin.right;}
    int m_nTabs;
    int m_logx;
    int m_nLinePos;
    int m_nScroll; // in pixels

    CPen penFocusLine;
    CPen penBtnHighLight;
    CPen penBtnShadow;
    CPen penWindowFrame;
    CPen penBtnText;
    CPen penBtnFace;
    CPen penWindowText;
    CPen penWindow;
    CBrush brushWindow;
    CBrush brushBtnFace;

// Implementation
public:
    virtual void DoPaint(CDC* pDC);
    virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
    void ClientToRuler(CPoint& pt) {pt.Offset(-m_cxLeftBorder+m_nScroll, -m_cyTopBorder);}
    void ClientToRuler(CRect& rect) {rect.OffsetRect(-m_cxLeftBorder+m_nScroll, -m_cyTopBorder);}
    void RulerToClient(CPoint& pt) {pt.Offset(m_cxLeftBorder-m_nScroll, m_cyTopBorder);}
    void RulerToClient(CRect& rect) {rect.OffsetRect(m_cxLeftBorder-m_nScroll, m_cyTopBorder);}

    int XTwipsToClient(int nT) {return MulDiv(nT, m_logx, 1440) + m_cxLeftBorder - m_nScroll;}
    int XClientToTwips(int nC) {return MulDiv(nC - m_cxLeftBorder + m_nScroll, 1440, m_logx);}

    int XTwipsToRuler(int nT) {return MulDiv(nT, m_logx, 1440);}
    int XRulerToTwips(int nR) {return MulDiv(nR, 1440, m_logx);}

    int XRulerToClient(int nR) {return nR + m_cxLeftBorder - m_nScroll;}
    int XClientToRuler(int nC) {return nC - m_cxLeftBorder + m_nScroll;}

protected:
    virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
    void CreateGDIObjects();
    void DrawFace(CDC& dc);
    void DrawTickMarks(CDC& dC);
    void DrawNumbers(CDC& dc, int nInc, int nTPU);
    void DrawDiv(CDC& dc, int nInc, int nLargeDiv, int nLength);
    void DrawTabs(CDC& dc);
    void FillInParaFormat(PARAFORMAT& pf);
    void SortTabs();
    void SetMarginBounds();
    CRulerItem* GetFreeTab();
    CView* GetView()
    {
        ASSERT(GetParent() != NULL);
        return ((CFrameWnd*)GetParent())->GetActiveView();
    }
    CDocument* GetDocument() { return GetView()->GetDocument(); }

    CTabRulerItem* GetHitTabPix(CPoint pt);

    // Generated message map functions
    //{{AFX_MSG(CRulerBar)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnSysColorChange();
    afx_msg void OnWindowPosChanging(WINDOWPOS FAR* lpwndpos);
    afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
    afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
    //}}AFX_MSG
    afx_msg LRESULT OnSizeParent(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
    
    friend class CRulerItem;
};

inline int CRulerItem::GetHorzPosPix()
    { return m_pRuler->XTwipsToRuler(m_nXPosTwips); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\ruler.cpp ===
// ruler.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "ruler.h"
#include "wordpvw.h"
#include "wordpdoc.h"
#include "strings.h"
#include <memory.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define HEIGHT 17
#define RULERBARHEIGHT 17


CRulerItem::CRulerItem(UINT nBitmapID)
{
    m_nAlignment = TA_CENTER;
    m_pDC = NULL;
    m_bTrack = FALSE;
    m_hbm = NULL;
    m_hbmMask = NULL;
    if (nBitmapID != 0)
    {
        m_hbmMask = ::LoadBitmap(
            AfxFindResourceHandle(MAKEINTRESOURCE(nBitmapID+1), RT_BITMAP), 
            MAKEINTRESOURCE(nBitmapID+1));
        ASSERT(m_hbmMask != NULL);
        VERIFY(LoadMaskedBitmap(MAKEINTRESOURCE(nBitmapID)));
        BITMAP bm;
        ::GetObject(m_hbm, sizeof(BITMAP), &bm);
        m_size = CSize(bm.bmWidth, bm.bmHeight);
    }
}

CRulerItem::~CRulerItem()
{
    if (m_hbm != NULL)
        ::DeleteObject(m_hbm);
    if (m_hbmMask != NULL)
        ::DeleteObject(m_hbmMask);
}

BOOL CRulerItem::LoadMaskedBitmap(LPCTSTR lpszResourceName)
{
    ASSERT(lpszResourceName != NULL);

    if (m_hbm != NULL)
        ::DeleteObject(m_hbm);

    HINSTANCE hInst = AfxFindResourceHandle(lpszResourceName, RT_BITMAP);
    HRSRC hRsrc = ::FindResource(hInst, lpszResourceName, RT_BITMAP);
    if (hRsrc == NULL)
        return FALSE;

    m_hbm = AfxLoadSysColorBitmap(hInst, hRsrc);
    return (m_hbm != NULL);
}

void CRulerItem::SetHorzPosTwips(int nXPos)
{
    if (GetHorzPosTwips() != nXPos)
    {
        if (m_bTrack)
            DrawFocusLine();
        Invalidate();
        m_nXPosTwips = nXPos;
        Invalidate();
        if (m_bTrack)
            DrawFocusLine();
    }
}

void CRulerItem::TrackHorzPosTwips(int nXPos, BOOL /*bOnRuler*/)
{
    int nMin = GetMin();
    int nMax = GetMax();
    if (nXPos < nMin)
        nXPos = nMin;
    if (nXPos > nMax)
        nXPos = nMax;
    SetHorzPosTwips(nXPos);
}

void CRulerItem::DrawFocusLine()
{
    if (GetHorzPosTwips() != 0)
    {
        m_rcTrack.left = m_rcTrack.right = GetHorzPosPix();
        ASSERT(m_pDC != NULL);
        int nLeft = m_pRuler->XRulerToClient(m_rcTrack.left);
        m_pDC->MoveTo(nLeft, m_rcTrack.top);
        m_pDC->LineTo(nLeft, m_rcTrack.bottom);
    }
}

void CRulerItem::SetTrack(BOOL b)
{
    m_bTrack = b;
    
    if (m_pDC != NULL) // just in case we lost focus Capture somewhere
    {
        DrawFocusLine();
        m_pDC->RestoreDC(-1);
        delete m_pDC ;
        m_pDC = NULL;
    }
    if (m_bTrack)
    {
        CWordPadView* pView = (CWordPadView*)m_pRuler->GetView();
        ASSERT(pView != NULL);
        pView->GetClientRect(&m_rcTrack);
        m_pDC = new CWindowDC(pView);
        m_pDC->SaveDC();
        m_pDC->SelectObject(&m_pRuler->penFocusLine);
        m_pDC->SetROP2(R2_XORPEN);
        DrawFocusLine();
    }
}

void CRulerItem::Invalidate()
{
    CRect rc = GetHitRectPix();
    m_pRuler->RulerToClient(rc.TopLeft());
    m_pRuler->RulerToClient(rc.BottomRight());
    m_pRuler->InvalidateRect(rc);
}

CRect CRulerItem::GetHitRectPix()
{
    int nx = GetHorzPosPix();
    return CRect( 
        CPoint( 
            (m_nAlignment == TA_CENTER) ? (nx - m_size.cx/2) :
            (m_nAlignment == TA_LEFT) ? nx : nx - m_size.cx
            , m_nYPosPix
            ), 
        m_size);
}

void CRulerItem::Draw(CDC& dc)
{
    CDC dcBitmap;
    dcBitmap.CreateCompatibleDC(&dc);
    CPoint pt(GetHorzPosPix(), GetVertPosPix());

    HGDIOBJ hbm = ::SelectObject(dcBitmap.m_hDC, m_hbmMask);

    // do mask part
    if (m_nAlignment == TA_CENTER)
        dc.BitBlt(pt.x - m_size.cx/2, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCAND);
    else if (m_nAlignment == TA_LEFT)
        dc.BitBlt(pt.x, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCAND);
    else // TA_RIGHT
        dc.BitBlt(pt.x - m_size.cx, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCAND);
    
    // do image part
    ::SelectObject(dcBitmap.m_hDC, m_hbm);

    if (m_nAlignment == TA_CENTER)
        dc.BitBlt(pt.x - m_size.cx/2, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCINVERT);
    else if (m_nAlignment == TA_LEFT)
        dc.BitBlt(pt.x, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCINVERT);
    else // TA_RIGHT
        dc.BitBlt(pt.x - m_size.cx, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCINVERT);

    ::SelectObject(dcBitmap.m_hDC, hbm);
}

CComboRulerItem::CComboRulerItem(UINT nBitmapID1, UINT nBitmapID2, CRulerItem& item)
    : CRulerItem(nBitmapID1), m_secondary(nBitmapID2) , m_link(item)
{
    m_bHitPrimary = TRUE;
}

BOOL CComboRulerItem::HitTestPix(CPoint pt)
{
    m_bHitPrimary = FALSE;
    if (CRulerItem::GetHitRectPix().PtInRect(pt))
        m_bHitPrimary = TRUE;
    else 
        return m_secondary.HitTestPix(pt);
    return TRUE;
}

void CComboRulerItem::Draw(CDC& dc)
{
    CRulerItem::Draw(dc);
    m_secondary.Draw(dc);
}

void CComboRulerItem::SetHorzPosTwips(int nXPos)
{
    if (m_bHitPrimary) // only change linked items by delta
        m_link.SetHorzPosTwips(m_link.GetHorzPosTwips() + nXPos - GetHorzPosTwips());
    CRulerItem::SetHorzPosTwips(nXPos);
    m_secondary.SetHorzPosTwips(nXPos);
}

void CComboRulerItem::TrackHorzPosTwips(int nXPos, BOOL /*bOnRuler*/)
{
    int nMin = GetMin();
    int nMax = GetMax();
    if (nXPos < nMin)
        nXPos = nMin;
    if (nXPos > nMax)
        nXPos = nMax;
    SetHorzPosTwips(nXPos);
}

void CComboRulerItem::SetVertPos(int nYPos)
{
    m_secondary.SetVertPos(nYPos);
    nYPos += m_secondary.GetHitRectPix().Height();
    CRulerItem::SetVertPos(nYPos);
}

void CComboRulerItem::SetAlignment(int nAlign)
{
    CRulerItem::SetAlignment(nAlign);
    m_secondary.SetAlignment(nAlign);
}

void CComboRulerItem::SetRuler(CRulerBar* pRuler)
{
    m_pRuler = pRuler;
    m_secondary.SetRuler(pRuler);
}

void CComboRulerItem::SetBounds(int nMin, int nMax)
{
    CRulerItem::SetBounds(nMin, nMax);
    m_secondary.SetBounds(nMin, nMax);
}

int CComboRulerItem::GetMin()
{
    if (m_bHitPrimary)
    {
        int nPDist = GetHorzPosTwips() - CRulerItem::GetMin();
        int nLDist = m_link.GetHorzPosTwips() - m_link.GetMin();
        return GetHorzPosTwips() - min(nPDist, nLDist);
    }
    else
        return CRulerItem::GetMin();
}

int CComboRulerItem::GetMax()
{
    if (m_bHitPrimary)
    {
        int nPDist = CRulerItem::GetMax() - GetHorzPosTwips();
        int nLDist = m_link.GetMax() - m_link.GetHorzPosTwips();
        int nMinDist = (nPDist < nLDist) ? nPDist : nLDist;
        return GetHorzPosTwips() + nMinDist;
    }
    else
        return CRulerItem::GetMax();
}

void CTabRulerItem::TrackHorzPosTwips(int nXPos, BOOL bOnRuler)
{
    if (bOnRuler)
        CRulerItem::TrackHorzPosTwips(nXPos, bOnRuler);
    else
        CRulerItem::TrackHorzPosTwips(0, bOnRuler);
}


BEGIN_MESSAGE_MAP(CRulerBar, CControlBar)
    //{{AFX_MSG_MAP(CRulerBar)
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    ON_WM_SYSCOLORCHANGE()
    ON_WM_WINDOWPOSCHANGING()
    ON_WM_SHOWWINDOW()
    ON_WM_WINDOWPOSCHANGED()
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_SIZEPARENT, OnSizeParent)
    // Global help commands
END_MESSAGE_MAP()

CRulerBar::CRulerBar() : 
    m_leftmargin(IDB_RULER_BLOCK, IDB_RULER_UP, m_indent), 
    m_indent(IDB_RULER_DOWN), 
    m_rightmargin(IDB_RULER_UP),
    m_tabItem(IDB_RULER_TAB)
{
    m_bDeferInProgress = FALSE;
    m_leftmargin.SetRuler(this);
    m_indent.SetRuler(this);
    m_rightmargin.SetRuler(this);

    // all of the tab stops share handles
    for (int i=0;i<MAX_TAB_STOPS;i++)
    {
        m_pTabItems[i].m_hbm = m_tabItem.m_hbm;
        m_pTabItems[i].m_hbmMask = m_tabItem.m_hbmMask;
        m_pTabItems[i].m_size = m_tabItem.m_size;
    }

    m_unit.m_nTPU = 0;
    m_nScroll = 0;

    LOGFONT lf;
    memcpy(&lf, &theApp.m_lf, sizeof(LOGFONT));
    lstrcpy(lf.lfFaceName, TEXT("MS Shell Dlg"));
    lf.lfWidth = 0;
    VERIFY(fnt.CreateFontIndirect(&lf));

    m_nTabs = 0;
    m_leftmargin.SetVertPos(9);
    m_indent.SetVertPos(-1);
    m_rightmargin.SetVertPos(9);

    m_cxLeftBorder = 0;
    m_cyTopBorder = 4;
    m_cyBottomBorder = 6;
    
    m_pSelItem = NULL;

    m_logx = theApp.m_dcScreen.GetDeviceCaps(LOGPIXELSX);

    CreateGDIObjects();
}

CRulerBar::~CRulerBar()
{
    // set handles to NULL to avoid deleting twice
    for (int i=0;i<MAX_TAB_STOPS;i++)
    {
        m_pTabItems[i].m_hbm = NULL;
        m_pTabItems[i].m_hbmMask = NULL;
    }
}

void CRulerBar::CreateGDIObjects()
{
    penFocusLine.DeleteObject();
    penBtnHighLight.DeleteObject();
    penBtnShadow.DeleteObject();
    penWindowFrame.DeleteObject();
    penBtnText.DeleteObject();
    penBtnFace.DeleteObject();
    penWindowText.DeleteObject();
    penWindow.DeleteObject();
    brushWindow.DeleteObject();
    brushBtnFace.DeleteObject();

    penFocusLine.CreatePen(PS_DOT, 1,GetSysColor(COLOR_WINDOWTEXT));
    penBtnHighLight.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNHIGHLIGHT));
    penBtnShadow.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNSHADOW));
    penWindowFrame.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOWFRAME));
    penBtnText.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNTEXT));
    penBtnFace.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNFACE));
    penWindowText.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOWTEXT));
    penWindow.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOW));
    brushWindow.CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    brushBtnFace.CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
}

void CRulerBar::OnUpdateCmdUI(CFrameWnd* /*pTarget*/, BOOL /*bDisableIfNoHndler*/)
{
    ASSERT_VALID(this);
    //Get the page size and see if changed -- from document
    //get margins and tabs and see if changed -- from view
    if (m_pSelItem == NULL) // only update if not in middle of dragging
    {
        CWordPadView* pView = (CWordPadView*)GetView();
        ASSERT(pView != NULL);
        Update(pView->GetPaperSize(), pView->GetMargins());
        Update(pView->GetParaFormatSelection());
        CRect rect;
        pView->GetRichEditCtrl().GetRect(&rect);
        CPoint pt = rect.TopLeft();
        pView->ClientToScreen(&pt);
        ScreenToClient(&pt);
        if (m_cxLeftBorder != pt.x)
        {
            m_cxLeftBorder = pt.x;
            Invalidate();
        }

        int nScroll = 0;

        if (pView->GetStyle() & WS_HSCROLL)
            nScroll = pView->GetScrollPos(SB_HORZ);

        if (nScroll != m_nScroll)
        {
            m_nScroll = nScroll;
            Invalidate();
        }
    }
}

CSize CRulerBar::GetBaseUnits()
{
    ASSERT(fnt.GetSafeHandle() != NULL);
    CFont* pFont = theApp.m_dcScreen.SelectObject(&fnt);
    TEXTMETRIC tm;
    VERIFY(theApp.m_dcScreen.GetTextMetrics(&tm) == TRUE);
    theApp.m_dcScreen.SelectObject(pFont);
//  return CSize(tm.tmAveCharWidth, tm.tmHeight+tm.tmDescent);
    return CSize(tm.tmAveCharWidth, tm.tmHeight);
}

BOOL CRulerBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
    ASSERT_VALID(pParentWnd);   // must have a parent

    dwStyle |= WS_CLIPSIBLINGS;
    // force WS_CLIPSIBLINGS (avoids SetWindowPos bugs)
    m_dwStyle = (UINT)dwStyle;

    // create the HWND
    CRect rect;
    rect.SetRectEmpty();
    LPCTSTR lpszClass = AfxRegisterWndClass(0, ::LoadCursor(NULL, IDC_ARROW),
        (HBRUSH)(COLOR_BTNFACE+1), NULL);

    if (!CWnd::Create(lpszClass, NULL, dwStyle, rect, pParentWnd, nID))
        return FALSE;
    // NOTE: Parent must resize itself for control bar to be resized

    // Turn off mirroring style for the ruler to make it appear over RichEdit
    // formatting area especially RichEdit control will never be mirrored.
    ::SetWindowLongPtr(m_hWnd , GWL_EXSTYLE ,  
          ::GetWindowLongPtr(m_hWnd , GWL_EXSTYLE ) & ~WS_EX_LAYOUTRTL);

    int i;
    int nMax = 100;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        m_pTabItems[i].SetRuler(this);
        m_pTabItems[i].SetVertPos(8);
        m_pTabItems[i].SetHorzPosTwips(0);
        m_pTabItems[i].SetBounds(0, nMax);
    }
    return TRUE;
}

CSize CRulerBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
    ASSERT(bHorz);
    CSize m_size = CControlBar::CalcFixedLayout(bStretch, bHorz);
    CRect rectSize;
    rectSize.SetRectEmpty();
    CalcInsideRect(rectSize, bHorz);       // will be negative size
    m_size.cy = RULERBARHEIGHT - rectSize.Height();
    return m_size;
}

void CRulerBar::Update(const PARAFORMAT& pf)
{
    ASSERT(pf.cTabCount <= MAX_TAB_STOPS);

    m_leftmargin.SetHorzPosTwips((int)(pf.dxStartIndent + pf.dxOffset));
    m_indent.SetHorzPosTwips((int)pf.dxStartIndent);
    m_rightmargin.SetHorzPosTwips(PrintWidth() - (int) pf.dxRightIndent);

    int i = 0;
    for (i=0;i<pf.cTabCount;i++)
        m_pTabItems[i].SetHorzPosTwips((int)pf.rgxTabs[i]);
    for ( ;i<MAX_TAB_STOPS; i++)
        m_pTabItems[i].SetHorzPosTwips(0);
}

void CRulerBar::Update(CSize sizePaper, const CRect& rectMargins)
{
    if ((sizePaper != m_sizePaper) || (rectMargins != m_rectMargin))
    {
        m_sizePaper = sizePaper;
        m_rectMargin = rectMargins;
        Invalidate();
    }
    if (m_unit.m_nTPU != theApp.GetTPU())
    {
        m_unit = theApp.GetUnit();
        Invalidate();
    }
}

void CRulerBar::FillInParaFormat(PARAFORMAT& pf)
{
    pf.dwMask = PFM_STARTINDENT | PFM_RIGHTINDENT | PFM_OFFSET | PFM_TABSTOPS;
    pf.dxStartIndent = m_indent.GetHorzPosTwips();
    pf.dxOffset = m_leftmargin.GetHorzPosTwips() - pf.dxStartIndent;
    pf.dxRightIndent = PrintWidth() - m_rightmargin.GetHorzPosTwips();
    pf.cTabCount = 0L;
    SortTabs();
    int i, nPos = 0;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        // get rid of zeroes and multiples
        // i.e. if we have 0,0,0,1,2,3,4,4,5
        // we will get tabs at 1,2,3,4,5
        if (nPos != m_pTabItems[i].GetHorzPosTwips())
        {
            nPos = m_pTabItems[i].GetHorzPosTwips();
            pf.rgxTabs[pf.cTabCount++] = nPos;
        }
    }
}

// simple bubble sort is adequate for small number of tabs
void CRulerBar::SortTabs()
{
    int i,j, nPos;
    for (i=0;i<MAX_TAB_STOPS - 1;i++)
    {
        for (j=i+1; j < MAX_TAB_STOPS;j++)
        {
            if (m_pTabItems[j].GetHorzPosTwips() < m_pTabItems[i].GetHorzPosTwips())
            {
                nPos = m_pTabItems[j].GetHorzPosTwips();
                m_pTabItems[j].SetHorzPosTwips(m_pTabItems[i].GetHorzPosTwips());
                m_pTabItems[i].SetHorzPosTwips(nPos);
            }
        }
    }
}

void CRulerBar::DoPaint(CDC* pDC)
{
    CControlBar::DoPaint(pDC); // CControlBar::DoPaint -- draws border
    if (m_unit.m_nTPU != 0)
    {
        pDC->SaveDC();
        // offset coordinate system
        CPoint pointOffset(0,0);
        RulerToClient(pointOffset);
        pDC->SetViewportOrg(pointOffset);

        DrawFace(*pDC);
        DrawTickMarks(*pDC);

        DrawTabs(*pDC);
        m_leftmargin.Draw(*pDC);
        m_indent.Draw(*pDC);
        m_rightmargin.Draw(*pDC);   

        pDC->RestoreDC(-1);
    }
    // Do not call CControlBar::OnPaint() for painting messages
}

void CRulerBar::DrawTabs(CDC& dc)
{
    int i;
    int nPos = 0;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        if (m_pTabItems[i].GetHorzPosTwips() > nPos)
            nPos = (m_pTabItems[i].GetHorzPosTwips());
        m_pTabItems[i].Draw(dc);
    }
    int nPageWidth = PrintWidth();
    nPos = nPos - nPos%720 + 720;
    dc.SelectObject(&penBtnShadow);
    for ( ; nPos < nPageWidth; nPos += 720)
    {
        int nx = XTwipsToRuler(nPos);
        dc.MoveTo(nx, HEIGHT - 1);
        dc.LineTo(nx, HEIGHT + 1);
    }
}

void CRulerBar::DrawFace(CDC& dc)
{
    int nPageWidth = XTwipsToRuler(PrintWidth());
    int nPageEdge = XTwipsToRuler(PrintWidth() + m_rectMargin.right);

    dc.SaveDC();

    dc.SelectObject(&penBtnShadow);
    dc.MoveTo(0,0);
    dc.LineTo(nPageEdge - 1, 0);
    dc.LineTo(nPageEdge - 1, HEIGHT - 2);
    dc.LineTo(nPageWidth - 1, HEIGHT - 2);
    dc.LineTo(nPageWidth - 1, 1);
    dc.LineTo(nPageWidth, 1);
    dc.LineTo(nPageWidth, HEIGHT -2);
    
    dc.SelectObject(&penBtnHighLight);
    dc.MoveTo(nPageWidth, HEIGHT - 1);
    dc.LineTo(nPageEdge, HEIGHT -1);
    dc.MoveTo(nPageWidth + 1, HEIGHT - 3);
    dc.LineTo(nPageWidth + 1, 1);
    dc.LineTo(nPageEdge - 1, 1);
    
    dc.SelectObject(&penWindow);
    dc.MoveTo(0, HEIGHT - 1);
    dc.LineTo(nPageWidth, HEIGHT -1);

    dc.SelectObject(&penBtnFace);
    dc.MoveTo(1, HEIGHT - 2);
    dc.LineTo(nPageWidth - 1, HEIGHT - 2);
    
    dc.SelectObject(&penWindowFrame);
    dc.MoveTo(0, HEIGHT - 2);
    dc.LineTo(0, 1);
    dc.LineTo(nPageWidth - 1, 1);
    
    dc.FillRect(CRect(1, 2, nPageWidth - 1, HEIGHT-2), &brushWindow);
    dc.FillRect(CRect(nPageWidth + 2, 2, nPageEdge - 1, HEIGHT-2), &brushBtnFace);

    CRect rcClient;
    GetClientRect(&rcClient);
    ClientToRuler(rcClient);
    rcClient.top = HEIGHT;
    rcClient.bottom = HEIGHT + 8;
    rcClient.right -= 2;

    DrawEdge(dc, &rcClient, EDGE_RAISED, BF_BOTTOM | BF_MIDDLE);
    
    //
    // Small fixup to account for the fact that the left border needs to merge
    // with the window below the ruler.
    //

    dc.SetPixel(rcClient.left, rcClient.bottom-1, GetSysColor(COLOR_3DSHADOW));

    dc.RestoreDC(-1);
}

void CRulerBar::DrawTickMarks(CDC& dc)
{
    dc.SaveDC();

    dc.SelectObject(&penWindowText);
    dc.SelectObject(&fnt);
    dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
    dc.SetBkMode(TRANSPARENT);

    DrawDiv(dc, m_unit.m_nSmallDiv, m_unit.m_nLargeDiv, 2);
    DrawDiv(dc, m_unit.m_nMediumDiv, m_unit.m_nLargeDiv, 5);
    DrawNumbers(dc, m_unit.m_nLargeDiv, m_unit.m_nTPU);
    
    dc.RestoreDC(-1);
}

void CRulerBar::DrawNumbers(CDC& dc, int nInc, int nTPU)
{
    int nPageWidth = PrintWidth();
    int nPageEdge = nPageWidth + m_rectMargin.right;
    TCHAR buf[10];

    int nTwips, nPixel, nLen;

    for (nTwips = nInc; nTwips < nPageEdge; nTwips += nInc)
    {
        if (nTwips == nPageWidth)
            continue;
        nPixel = XTwipsToRuler(nTwips);
        wsprintf(buf, _T("%d"), nTwips/nTPU);
        nLen = lstrlen(buf);
        CSize sz = dc.GetTextExtent(buf, nLen);
        dc.ExtTextOut(nPixel - sz.cx/2, HEIGHT/2 - sz.cy/2, 0, NULL, buf, nLen, NULL);
    }
}

void CRulerBar::DrawDiv(CDC& dc, int nInc, int nLargeDiv, int nLength)
{
    int nPageWidth = PrintWidth();
    int nPageEdge = nPageWidth + m_rectMargin.right;

    int nTwips, nPixel;

    for (nTwips = nInc; nTwips < nPageEdge; nTwips += nInc)
    {
        if (nTwips == nPageWidth || nTwips%nLargeDiv == 0)
            continue;
        nPixel = XTwipsToRuler(nTwips);
        dc.MoveTo(nPixel, HEIGHT/2 - nLength/2);
        dc.LineTo(nPixel, HEIGHT/2 - nLength/2 + nLength);
    }
}

void CRulerBar::OnLButtonDown(UINT nFlags, CPoint point)
{
    CPoint pt = point;
    ClientToRuler(pt);
    
    m_pSelItem = NULL;
    if (m_leftmargin.HitTestPix(pt))
        m_pSelItem = &m_leftmargin;
    else if (m_indent.HitTestPix(pt))
        m_pSelItem = &m_indent;
    else if (m_rightmargin.HitTestPix(pt))
        m_pSelItem = &m_rightmargin;
    else
        m_pSelItem = GetHitTabPix(pt);
    if (m_pSelItem == NULL)
        m_pSelItem = GetFreeTab();
    if (m_pSelItem == NULL)
        return;
    SetCapture();

    m_pSelItem->SetTrack(TRUE);
    SetMarginBounds();
    OnMouseMove(nFlags, point);
}

void CRulerBar::SetMarginBounds()
{
    m_leftmargin.SetBounds(0, m_rightmargin.GetHorzPosTwips());
    m_indent.SetBounds(0, m_rightmargin.GetHorzPosTwips());

    int nMin = (m_leftmargin.GetHorzPosTwips() > m_indent.GetHorzPosTwips()) ? 
        m_leftmargin.GetHorzPosTwips() : m_indent.GetHorzPosTwips();
    int nMax = PrintWidth() + m_rectMargin.right;
    m_rightmargin.SetBounds(nMin, nMax);
    
    // tabs can go from zero to the right page edge
    for (int i=0;i<MAX_TAB_STOPS;i++)
        m_pTabItems[i].SetBounds(0, nMax);
}

CRulerItem* CRulerBar::GetFreeTab()
{
    int i;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        if (m_pTabItems[i].GetHorzPosTwips() == 0)
            return &m_pTabItems[i];
    }
    return NULL;
}

CTabRulerItem* CRulerBar::GetHitTabPix(CPoint point)
{
    int i;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        if (m_pTabItems[i].HitTestPix(point))
            return &m_pTabItems[i];
    }
    return NULL;
}

void CRulerBar::OnLButtonUp(UINT nFlags, CPoint point)
{
    if (::GetCapture() != m_hWnd)
        return;
    OnMouseMove(nFlags, point);
    m_pSelItem->SetTrack(FALSE);
    ReleaseCapture();
    CWordPadView* pView = (CWordPadView*)GetView();
    ASSERT(pView != NULL);
    PARAFORMAT& pf = pView->GetParaFormatSelection();
    FillInParaFormat(pf);
    pView->SetParaFormat(pf);
    m_pSelItem = NULL;
}

void CRulerBar::OnMouseMove(UINT nFlags, CPoint point)
{
    CControlBar::OnMouseMove(nFlags, point);
// use ::GetCapture to avoid creating temporaries
    if (::GetCapture() != m_hWnd)
        return;
    ASSERT(m_pSelItem != NULL);
    CRect rc(0,0, XTwipsToRuler(PrintWidth() + m_rectMargin.right), HEIGHT);
    RulerToClient(rc);
    BOOL bOnRuler = rc.PtInRect(point);

// snap to minimum movement
    point.x = XClientToTwips(point.x);
    point.x += m_unit.m_nMinMove/2;
    point.x -= point.x%m_unit.m_nMinMove;

    m_pSelItem->TrackHorzPosTwips(point.x, bOnRuler);
    UpdateWindow();
}

void CRulerBar::OnSysColorChange()
{
    CControlBar::OnSysColorChange();
    CreateGDIObjects();
    Invalidate();   
}

void CRulerBar::OnWindowPosChanging(WINDOWPOS FAR* lpwndpos) 
{
    CControlBar::OnWindowPosChanging(lpwndpos);
    CRect rect;
    GetClientRect(rect);
    int minx = min(rect.Width(), lpwndpos->cx);
    int maxx = max(rect.Width(), lpwndpos->cx);
    rect.SetRect(minx-2, rect.bottom - 6, minx, rect.bottom);
    InvalidateRect(rect);
    rect.SetRect(maxx-2, rect.bottom - 6, maxx, rect.bottom);
    InvalidateRect(rect);
}

void CRulerBar::OnShowWindow(BOOL bShow, UINT nStatus) 
{
    CControlBar::OnShowWindow(bShow, nStatus);
    m_bDeferInProgress = FALSE; 
}

void CRulerBar::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos) 
{
    CControlBar::OnWindowPosChanged(lpwndpos);
    m_bDeferInProgress = FALSE; 
}

LRESULT CRulerBar::OnSizeParent(WPARAM wParam, LPARAM lParam)
{
    BOOL bVis = GetStyle() & WS_VISIBLE;
    if ((bVis && (m_nStateFlags & delayHide)) ||
        (!bVis && (m_nStateFlags & delayShow)))
    {
        m_bDeferInProgress = TRUE;
    }
    return CControlBar::OnSizeParent(wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\pageset.h ===
// pageset.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CPageSetupDlg dialog

class CPageSetupDlg : public CCSDialog
{
// Construction
public:
	CPageSetupDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CPageSetupDlg)
	enum { IDD = IDD_PAGE_SETUP_DIALOG };
	int		m_nTopMargin;
	int		m_nRightMargin;
	int		m_nLeftMargin;
	int		m_nBottomMargin;
	//}}AFX_DATA

// Implementation
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	// Generated message map functions
	//{{AFX_MSG(CPageSetupDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\srvritem.cpp ===
// srvritem.cpp : implementation of the CWordPadSrvrItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "srvritem.h"
#include <limits.h>

IMPLEMENT_DYNAMIC(CEmbeddedItem, COleServerItem)

extern CLIPFORMAT cfRTF;

CEmbeddedItem::CEmbeddedItem(CWordPadDoc* pContainerDoc, int nBeg, int nEnd)
	: COleServerItem(pContainerDoc, TRUE)
{
	ASSERT(pContainerDoc != NULL);
	ASSERT_VALID(pContainerDoc);
	m_nBeg = nBeg;
	m_nEnd = nEnd;
}

CWordPadView* CEmbeddedItem::GetView() const
{
	CDocument* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	POSITION pos = pDoc->GetFirstViewPosition();
	if (pos == NULL)
		return NULL;

	CWordPadView* pView = (CWordPadView*)pDoc->GetNextView(pos);
	ASSERT_VALID(pView);
	ASSERT(pView->IsKindOf(RUNTIME_CLASS(CWordPadView)));
	return pView;
}

void CEmbeddedItem::Serialize(CArchive& ar)
{
	if (m_lpRichDataObj != NULL)
	{
		ASSERT(ar.IsStoring());
		FORMATETC etc = {NULL, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
		etc.cfFormat = (CLIPFORMAT)cfRTF;
		STGMEDIUM stg;
		if (SUCCEEDED(m_lpRichDataObj->GetData(&etc, &stg)))
		{
			LPBYTE p = (LPBYTE)GlobalLock(stg.hGlobal);
			if (p != NULL)
			{
				ar.Write(p, (DWORD)GlobalSize(stg.hGlobal));
				GlobalUnlock(stg.hGlobal);
			}
			ASSERT(stg.tymed == TYMED_HGLOBAL);
			ReleaseStgMedium(&stg);
		}
	}
	else
		GetDocument()->Serialize(ar);
}

BOOL CEmbeddedItem::OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize)
{
	if (dwDrawAspect != DVASPECT_CONTENT)
		return COleServerItem::OnGetExtent(dwDrawAspect, rSize);

	CClientDC dc(NULL);
	return OnDrawEx(&dc, rSize, FALSE);
}

BOOL CEmbeddedItem::OnDraw(CDC* pDC, CSize& rSize)
{
	return OnDrawEx(pDC, rSize, TRUE);
}

BOOL CEmbeddedItem::OnDrawEx(CDC* pDC, CSize& rSize, BOOL bOutput)
{
	CDisplayIC dc;
	CWordPadView* pView = GetView();
	if (pView == NULL)
		return FALSE;
	ASSERT_VALID(pView);

	int nWrap = pView->m_nWordWrap;

	CRect rect;//rect in twips
	rect.left = rect.top = 0;
	rect.bottom = 32767; // bottomless

	rect.right = 32767;
	if (nWrap == 0) // no word wrap
		rect.right = 32767;
	else if (nWrap == 1) // wrap to window
	{
		CRect rectClient;
		pView->GetClientRect(&rectClient);
		rect.right = rectClient.right - HORZ_TEXTOFFSET;
		rect.right = MulDiv(rect.right, 1440, dc.GetDeviceCaps(LOGPIXELSX));
	}
	else if (nWrap == 2) // wrap to ruler
		rect.right = pView->GetPrintWidth();

	// first just determine the correct extents of the text
	pDC->SetBkMode(TRANSPARENT);
	
	if (pView->PrintInsideRect(pDC, rect, m_nBeg, m_nEnd, FALSE) == 0)
	{
		// default to 12pts high and 4" wide if no text
		rect.bottom = rect.top+12*20+1; // 12 pts high
		rect.right = rect.left+ 4*1440;
	}
	rect.bottom+=3*(1440/dc.GetDeviceCaps(LOGPIXELSX)); // three pixels

	// then, really output the text
	CRect rectOut = rect; // don't pass rect because it will get clobbered
	if (bOutput)
		pView->PrintInsideRect(pDC, rectOut, m_nBeg, m_nEnd, TRUE);
	ASSERT(rectOut.right == rect.right);

	// adjust for border (rect.left is already adjusted)
	if (pView->GetStyle() & WS_HSCROLL)
		++rect.bottom;  // account for border on scroll bar!

	// return HIMETRIC size
	rSize = rect.Size();
	rSize.cx = MulDiv(rSize.cx, 2540, 1440); // convert twips to HIMETRIC
	rSize.cy = MulDiv(rSize.cy, 2540, 1440); // convert twips to HIMETRIC
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wordpad.rc
//
#define IDR_SRVR_INPLACE                4
#define IDR_SRVR_EMBEDDED               5
#define IDR_CNTR_INPLACE                6
#define IDP_OLE_INIT_FAILED             100
#define IDP_FAILED_TO_CREATE            102
#define IDS_INVALID_MEASUREMENT         103
#define IDS_PLEASE_WAIT                 104
#define IDS_COMPLETE                    105
#define IDS_SAVE_UNSUPPORTED            106
#define IDS_CLOSE_TEXT                  107
#define IDS_RICHED_LOAD_FAIL            108
#define IDC_COMBO_ALIGNMENT             111
#define IDS_DEFAULTTEXTFONT             111
#define IDS_SAVE_FORMAT_TEXT            112
#define IDS_SAVE_FORMAT                 113
#define IDS_SAVING                      113
#define IDS_CLIP_RTF                    114
#define IDS_FORMATTING                  115
#define IDS_LEFT                        116
#define IDS_CENTER                      117
#define IDS_RIGHT                       118
#define IDS_NOWRAP                      119
#define IDS_MEASUREMENT_RANGE           119
#define IDS_WRAPTOWINDOW                120
#define IDS_INVALID_NUMBER              120
#define IDS_WRAPTORULER                 121
#define IDS_INVALID_FONTSIZE            121
#define IDS_INCHES                      122
#define IDS_CENTIMETERS                 123
#define IDS_POINTS                      124
#define IDS_PICAS                       125
#define IDR_MAINFRAME                   128
#define IDS_TEXT_DOC                    129
#define IDS_RICHTEXT_DOC                130
#define IDB_BITMAP_TT                   130
#define IDS_WRITE_DOC                   131
#define IDB_RULER_BLOCK                 131
#define IDS_ALL_DOC                     132
#define IDB_RULER_BLOCKM                132
#define IDS_WINWORD6_DOC                133
#define IDB_RULER_DOWN                  133
#define IDS_WINWORD2_DOC                134
#define IDB_RULER_DOWNM                 134
#define IDB_RULER_TAB                   135
#define IDB_RULER_TABM                  136
#define IDS_FILE_EXISTS                 136
#define IDB_RULER_UP                    137
#define IDS_MAPILOAD_FAILED             137
#define IDS_OEMTEXT_DOC                 137
#define IDB_RULER_UPM                   138
#define IDS_CLIP_TEXT                   138
#define IDB_FORMATBAR                   139
#define IDS_CLIP_FILENAME               139
#define IDR_MAINFRAME1                  140
#define IDB_FORMATBAR_BIG               141
#define IDR_COLOR_MENU                  142
#define IDR_MAINFRAME_BIG               142
#define IDD_FORMAT_PARA                 143
#define IDR_MAINFRAME1_BIG              143
#define IDR_SRVR_INPLACE_BIG            144
#define IDD_FORMAT_TAB                  145
#define IDD_LISTDIALOG                  147
#define IDD_OPTIONS                     148
#define IDS_DT1                         149
#define IDD_PAGE_SETUP_DIALOG           150
#define IDS_DT2                         150
#define IDR_MENU1                       151
#define IDS_DT3                         151
#define IDD_DATEDIALOG                  151
#define IDS_DT4                         152
#define IDR_TEXT_POPUP                  152
#define IDS_DT5                         153
#define IDS_DT6                         154
#define IDI_ICON_DOC                    154
#define IDS_DT7                         155
#define IDI_ICON_WRITE                  155
#define IDS_DT8                         156
#define IDS_DT9                         157
#define IDD_SPLASH                      157
#define IDS_DT10                        158
#define IDD_OPTIONS_UNITS               158
#define IDS_DT11                        159
#define IDD_OPTIONS_WRAP                159
#define IDS_DT12                        160
#define IDD_OPTIONS_MARGINS             160
#define IDD_FILENEWDIALOG               160
#define IDS_DT13                        161
#define IDB_BITMAP48                    162
#define IDB_BITMAP_PRINTER              163
#define IDS_FINISHED_SEARCH             164
#define IDC_FONTNAME                    165
#define IDI_ICON_TEXT                   165
#define IDC_FONTSIZE                    166
#define IDS_TITLE_FORMATBAR             167
#define IDB_PRINTER                     167
#define IDB_FONTTYPE                    167
#define IDS_TITLE_TOOLBAR               168
#define IDS_INCH1_ABBREV                169
#define IDS_INCH2_ABBREV                170
#define IDS_INCH3_ABBREV                171
#define IDS_INCH4_ABBREV                172
#define IDS_CM_ABBREV                   173
#define IDS_POINT_ABBREV                174
#define IDS_PICA_ABBREV                 175
#define IDS_NOMORETABS                  176
#define IDS_MAPI_FAIL                   177
#define IDS_ERRSPACE                    178
#define IDS_CANT_LOAD                   179
#define IDS_TOOMANYFILES                180
#define IDS_DIRFULL                     181
#define IDS_SHAREVIOLATION              182
#define IDS_TEXT_OPTIONS                183
#define IDS_RTF_OPTIONS                 184
#define IDS_WORD6_OPTIONS               185
#define IDS_OPTIONS                     186
#define IDS_WRITE_OPTIONS               187
#define IDS_EMBEDDED_OPTIONS            188
#define IDS_TEXT_DOCUMENT               189
#define IDS_RTF_DOCUMENT                190
#define IDS_WORD6_DOCUMENT              191
#define IDS_WRITEPROTECT                192
#define IDS_UNICODETEXT_DOC             193
#define IDS_UNICODETEXT_DOCUMENT        194
#define IDS_CONVERTER_ABORTED           195
#define IDS_WORD97_DOC                  196
#define IDS_FEWINWORD5_DOC              198
#define IDS_INCH1_NOLOC                 199
#define IDS_INCH2_NOLOC                 200
#define IDS_INCH3_NOLOC                 201
#define IDS_INCH4_NOLOC                 202
#define IDS_CM_NOLOC                    203
#define IDS_POINT_NOLOC                 204
#define IDS_PICA_NOLOC                  205
#define IDS_FILENAME_TO_LONG            206
#define IDC_SCRIPT                      207
#define IDS_WRI_DOC                     208
#define IDS_WORDPAD_DOCUMENT            209
#define IDC_EDIT_LEFT                   1000
#define IDC_EDIT_RIGHT                  1001
#define IDC_EDIT_FIRST_LINE             1002
#define IDC_BUTTON_SET                  1005
#define IDC_EDIT_BM                     1005
#define IDC_BUTTON_CLEAR                1006
#define IDC_EDIT_LM                     1006
#define IDC_BUTTON_CLEARALL             1007
#define IDC_EDIT_RM                     1007
#define IDC_STATIC_HEADING              1009
#define IDC_COMBO_WRAP                  1011
#define IDC_COMBO_UNITS                 1012
#define IDC_EDIT_TM                     1016
#define IDC_TEXT_ALIGNMENT              1017
#define IDC_LISTDIALOG_LIST             1018
#define IDC_DATEDIALOG_LIST             1018
#define IDC_COMBO1                      1019
#define IDC_TEXT_WRAP                   1020
#define IDC_TEXT_UNITS                  1021
#define IDC_BOX                         1022
#define IDC_BIGICON                     1023
#define IDC_UNITS_IN                    1024
#define IDC_UNITS_CM                    1025
#define IDC_WRAP_RULER                  1025
#define IDC_UNITS_PT                    1026
#define IDC_WRAP_WINDOW                 1026
#define IDC_UNITS_PI                    1027
#define IDC_WRAP_NONE                   1027
#define IDC_CHECK_TOOLBAR               1028
#define IDC_CHECK_FORMATBAR             1029
#define IDC_WORDSEL                     1029
#define IDC_CHECK_RULERBAR              1030
#define IDC_CHECK_STATUSBAR             1031
#define IDC_BOXT                        1032
#define IDC_DEFAULT_FORMAT              1033
#define IDC_ALWAYS_RTF                  1034
#define ID_CANCEL_EDIT_CNTR             32768
#define ID_CANCEL_EDIT_SRVR             32769
#define ID_PAGE_SETUP                   32771
#define ID_VIEW_OPTIONS                 32776
#define ID_INSERT_BULLET                32777
#define ID_INSERT_DATE_TIME             32778
#define ID_FORMAT_PARAGRAPH             32780
#define ID_FORMAT_TABS                  32781
#define ID_COLOR0                       32782
#define ID_COLOR1                       32783
#define ID_COLOR2                       32784
#define ID_COLOR3                       32785
#define ID_COLOR4                       32786
#define ID_COLOR5                       32787
#define ID_COLOR6                       32788
#define ID_COLOR7                       32789
#define ID_COLOR8                       32790
#define ID_COLOR9                       32791
#define ID_COLOR10                      32792
#define ID_COLOR11                      32793
#define ID_COLOR12                      32794
#define ID_COLOR13                      32795
#define ID_COLOR14                      32796
#define ID_COLOR15                      32797
#define ID_COLOR16                      32798
#define ID_CHAR_BOLD                    32799
#define ID_CHAR_ITALIC                  32800
#define ID_CHAR_COLOR                   32801
#define ID_CHAR_UNDERLINE               32802
#define ID_PARA_LEFT                    32803
#define ID_PARA_CENTER                  32804
#define ID_PARA_RIGHT                   32805
#define ID_PEN_PERIOD                   32807
#define ID_PEN_SPACE                    32808
#define ID_PEN_BACKSPACE                32809
#define ID_PEN_NEWLINE                  32810
#define ID_OLE_VERB_POPUP               32811
#define ID_PEN_TOGGLE                   32812
#define ID_PEN_LENS                     32813
#define ID_PEN_TAB                      32814
#define ID_VIEW_FORMATBAR               59396
#define ID_VIEW_RULER                   59397
#define ID_DELAYED_INVALIDATE           59398
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\srvritem.h ===
// srvritem.h : interface of the CWordPadSrvrItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CWordPadDoc;
class CWordPadView;

class CEmbeddedItem : public COleServerItem
{
	DECLARE_DYNAMIC(CEmbeddedItem)

// Constructors
public:
	CEmbeddedItem(CWordPadDoc* pContainerDoc, int nBeg = 0, int nEnd = -1);

// Attributes
	int m_nBeg;
	int m_nEnd;
	LPDATAOBJECT m_lpRichDataObj;
	CWordPadDoc* GetDocument() const
		{ return (CWordPadDoc*) COleServerItem::GetDocument(); }
	CWordPadView* GetView() const;

// Implementation
public:
	BOOL OnDrawEx(CDC* pDC, CSize& rSize, BOOL bOutput);
	virtual BOOL OnDraw(CDC* pDC, CSize& rSize);
	virtual BOOL OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize);

protected:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wordpad.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef _UNICODE
#define VC_EXTRALEAN            // use stripped down Win32 headers
#endif

#define CONVERTERS

#include <afxwin.h>         // MFC core and standard components

//
// MFC 4.2 hardcodes _RICHEDIT_VER to 0x0100 in afxwin.h.  This prevents
// richedit.h from enabling any richedit 2.0 features.
//

#ifdef _RICHEDIT_VER
#if _RICHEDIT_VER < 0x0200
#undef _RICHEDIT_VER
#define _RICHEDIT_VER 0x0200
#endif
#endif

#include <objbase.h>
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxcmn.h>
//#include <afxrich.h>
#include <afxpriv.h>

//
// Private headers for richedit2 support until MFC gets native support
//

#ifndef _AFX_ENABLE_INLINES
#define _AFX_ENABLE_INLINES
#endif

#define _AFXCMN2_INLINE     inline
#define _AFXDLGS2_INLINE    inline
#define _AFXRICH2_INLINE    inline

#include <afxdlgs2.h>
#include <afxcmn2.h>
#include <afxrich2.h>



#define HORZ_TEXTOFFSET 15
#define VERT_TEXTOFFSET 5

class CDisplayIC : public CDC
{
public:
	CDisplayIC() { CreateIC(_T("DISPLAY"), NULL, NULL, NULL); }
};

struct CCharFormat : public CHARFORMAT  // re20 requires this line; added by t-stefb
//struct CCharFormat : public _charformat
{
	CCharFormat() {cbSize = sizeof(CHARFORMAT);}  // re20 requires this line; added by t-stefb
//	CCharFormat() {cbSize = sizeof(_charformat);}
	BOOL operator==(CCharFormat& cf);
};

struct CParaFormat : public _paraformat
{
	CParaFormat() {cbSize = sizeof(_paraformat);}
	BOOL operator==(PARAFORMAT& pf);
};

#include "doctype.h"
#include "chicdial.h"

#include <htmlhelp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\strings.cpp ===
// strings.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "strings.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

const TCHAR szWordPadClass[] = _T("WordPadClass");
const TCHAR szLayout1[] = _T("Layout2");
const TCHAR szLayout2[] = _T("LayoutAux2");
const TCHAR szRegKey[] = _T("Microsoft\\Windows\\CurrentVersion\\Applets");

const TCHAR szTextSection[] = _T("Text");
const TCHAR szRTFSection[] = _T("RTF");
const TCHAR szWordSection[] = _T("Word6");
const TCHAR szWriteSection[] =_T("Write");
const TCHAR szIPSection[] = _T("IP");
const TCHAR szWrap[] = _T("Wrap");
const TCHAR szPageMargin[] = _T("PageMargin");

const TCHAR szSection[] = _T("Options");
const TCHAR szWordSel[] = _T("WordSel");
const TCHAR szUnits[] = _T("Units");
const TCHAR szFrameRect[] = _T("FrameRect");
const TCHAR szMaximized[] = _T("Maximized");

const TCHAR szSumInfo[] = _T("\005SummaryInformation");
const TCHAR szContents[] = _T("Contents");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\unitspag.h ===
// unitspag.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CUnitsPage dialog

class CUnitsPage : public CCSPropertyPage
{
// Construction
public:
	CUnitsPage();   // standard constructor

// Dialog Data
	//{{AFX_DATA(CUnitsPage)
	enum { IDD = IDD_OPTIONS_UNITS };
	int		m_nUnits;
	BOOL	m_bWordSel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CUnitsPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}

	// Generated message map functions
	//{{AFX_MSG(CUnitsPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\winctrl2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "stdafx2.h"

#ifdef AFX_CMNCTL_SEG
#pragma code_seg(AFX_CMNCTL_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CRichEdit

CRichEdit2Ctrl::~CRichEdit2Ctrl()
{
	DestroyWindow();
}


#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_DYNAMIC(CRichEdit2Ctrl, CWnd)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\viewrich.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "stdafx2.h"

// See Win98 HACKHACK below
#ifdef _CHICAGO_
#include <initguid.h>
#include <tom.h>
#pragma comment (lib, "oleaut32.lib")
#endif // _CHICAGO_

// Hack multimon to work with NT4 headers but NT5 libs
#if _WIN32_WINNT < 0x0500
#include <multimon.h>
#undef GetSystemMetrics
#undef MonitorFromWindow
#undef MonitorFromRect
#undef MonitorFromPoint
#undef GetMonitorInfo
#undef EnumDisplayMonitors
#undef EnumDisplayDevices
extern "C"
{
WINUSERAPI
HMONITOR
WINAPI
MonitorFromWindow( IN HWND hwnd, IN DWORD dwFlags);
WINUSERAPI BOOL WINAPI GetMonitorInfoA( IN HMONITOR hMonitor, OUT LPMONITORINFO lpmi);
WINUSERAPI BOOL WINAPI GetMonitorInfoW( IN HMONITOR hMonitor, OUT LPMONITORINFO lpmi);
#ifdef UNICODE
#define GetMonitorInfo  GetMonitorInfoW
#else
#define GetMonitorInfo  GetMonitorInfoA
#endif // !UNICODE
}
#endif

#ifdef AFX_CORE4_SEG
#pragma code_seg(AFX_CORE4_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CRe2Object

class CRe2Object : public _reobject
{
public:
    CRe2Object();
    CRe2Object(CRichEdit2CntrItem* pItem);
    ~CRe2Object();
};

CRe2Object::CRe2Object()
{
    cbStruct = sizeof(REOBJECT);
    poleobj = NULL;
    pstg = NULL;
    polesite = NULL;
}

CRe2Object::CRe2Object(CRichEdit2CntrItem* pItem)
{
    ASSERT(pItem != NULL);
    cbStruct = sizeof(REOBJECT);

    pItem->GetClassID(&clsid);
    poleobj = pItem->m_lpObject;
    pstg = pItem->m_lpStorage;
    polesite = pItem->m_lpClientSite;
    ASSERT(poleobj != NULL);
    ASSERT(pstg != NULL);
    ASSERT(polesite != NULL);
    poleobj->AddRef();
    pstg->AddRef();
    polesite->AddRef();

    sizel.cx = sizel.cy = 0; // let richedit determine initial size
    dvaspect = pItem->GetDrawAspect();
    dwFlags = REO_RESIZABLE;
    dwUser = 0;
}

CRe2Object::~CRe2Object()
{
    if (poleobj != NULL)
        poleobj->Release();
    if (pstg != NULL)
        pstg->Release();
    if (polesite != NULL)
        polesite->Release();
}


//+-------------------------------------------------------------------------
//
//  HACKHACK:
//
//  The Richedit2 control is Unicode internally so it needs to convert
//  strings from Ansi to Unicode when it recieves a EM_FINDTEXTEX message.
//  Unfortunately it seems to set the code page for the conversion based
//  on the current keyboard layout.  This breaks in the following scenario:
//
//  Start Wordpad on FE Win98 and type some DBCS chars.  Pull up the find
//  dialog and enter one of the DBCS chars that you typed before.  Set the
//  keyboard layout to US and try to find the character - it will fail.
//  Now set it to non-US and try the find - it will work.
//
//  The hack is to do the conversion ourselves using the system default
//  codepage and then do the find using the TOM interfaces.
//
//  Richedit3 is supposed to be smarter about this whole issue and hopefully
//  this hack can be removed then.
//
//--------------------------------------------------------------------------

#ifdef _CHICAGO_
long CRichEdit2Ctrl::FindText(DWORD dwFlags, FINDTEXTEX* pFindText) const
{
    long            index = -1;
    ITextRange     *range = NULL;
    HRESULT         hr = S_OK;
    UINT            cchFind = _tcslen(pFindText->lpstrText) + 1;
    LPWSTR          lpwszFind = NULL;
    long            length;

    //
    // Get the base richedit ole interface
    //

    IUnknown *unk = GetIRichEditOle();

    if (NULL == unk)
        hr = E_NOINTERFACE;

    //
    // Get a range object
    //

    if (S_OK == hr)
    {
        ITextDocument *doc;

        hr = unk->QueryInterface(IID_ITextDocument, (void **) &doc);

        if (S_OK == hr)
        {
            hr = doc->Range(
                        pFindText->chrg.cpMin,
                        pFindText->chrg.cpMax,
                        &range);

            doc->Release();
        }

        unk->Release();
    }

    //
    // Convert the text-to-find to Unicode using the system default code page
    //

    if (S_OK == hr)
    {
        try
        {
             lpwszFind = (LPWSTR) alloca(cchFind * sizeof(WCHAR));
        }
        catch (...)
        {
            hr = E_OUTOFMEMORY; // alloca failed
        }

        if (S_OK == hr)
        {
            int error = MultiByteToWideChar(
                                CP_ACP,
                                MB_ERR_INVALID_CHARS,
                                pFindText->lpstrText,
                                -1,
                                lpwszFind,
                                cchFind);

            if (0 != error)
                lpwszFind = SysAllocString(lpwszFind);
            else
                hr = E_FAIL;

            if (S_OK == hr && NULL == lpwszFind)
                hr = E_OUTOFMEMORY;
        }
    }

    //
    // Try to find the text
    //

    if (S_OK == hr)
    {
        long flags = 0;

        flags |= (dwFlags & FR_MATCHCASE) ? tomMatchCase : 0;
        flags |= (dwFlags & FR_WHOLEWORD) ? tomMatchWord : 0;

        hr = range->FindText((BSTR) lpwszFind, 0, flags, &length);

        SysFreeString(lpwszFind);

        if (S_OK == hr)
        {
            hr = range->GetIndex(tomCharacter, &index);

            if (S_OK == hr)
            {
                // GetIndex returns 1-based indices, EM_FINDTEXTEX returns
                // 0-based indices.

                --index;
                pFindText->chrgText.cpMin = index;
                pFindText->chrgText.cpMax = index + length;
            }
        }
    }

    if (NULL != range)
        range->Release();

    //
    // If all else fails, fall back to EM_FINDTEXTEX
    //

    if (S_OK != hr)
        index = (long)::SendMessage(
                            m_hWnd,
                            EM_FINDTEXTEX,
                            dwFlags,
                            (LPARAM)pFindText);

    return index;
}
#endif // _CHICAGO



/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View

static const UINT nMsgFindReplace = ::RegisterWindowMessage(FINDMSGSTRING);

BEGIN_MESSAGE_MAP(CRichEdit2View, CCtrlView)
    //{{AFX_MSG_MAP(CRichEdit2View)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateNeedSel)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateNeedClip)
    ON_UPDATE_COMMAND_UI(ID_EDIT_FIND, OnUpdateNeedText)
    ON_UPDATE_COMMAND_UI(ID_EDIT_REPEAT, OnUpdateNeedFind)
    ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_SPECIAL, OnUpdateEditPasteSpecial)
    ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_PROPERTIES, OnUpdateEditProperties)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateNeedSel)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR, OnUpdateNeedSel)
    ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, OnUpdateNeedText)
    ON_UPDATE_COMMAND_UI(ID_EDIT_REPLACE, OnUpdateNeedText)
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_COMMAND(ID_EDIT_CLEAR, OnEditClear)
    ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
    ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
    ON_COMMAND(ID_EDIT_FIND, OnEditFind)
    ON_COMMAND(ID_EDIT_REPLACE, OnEditReplace)
    ON_COMMAND(ID_EDIT_REPEAT, OnEditRepeat)
    ON_COMMAND(ID_EDIT_PASTE_SPECIAL, OnEditPasteSpecial)
    ON_COMMAND(ID_OLE_EDIT_PROPERTIES, OnEditProperties)
    ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
    ON_COMMAND(ID_FORMAT_FONT, OnFormatFont)
    ON_WM_SIZE()
    ON_WM_CREATE()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    ON_NOTIFY_REFLECT(EN_SELCHANGE, OnSelChange)
    ON_REGISTERED_MESSAGE(nMsgFindReplace, OnFindReplaceCmd)
END_MESSAGE_MAP()

// richedit buffer limit -- let's set it at 16M
AFX_DATADEF ULONG CRichEdit2View::lMaxSize = 0xffffff;

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View construction/destruction

CRichEdit2View::CRichEdit2View() : CCtrlView(MSFTEDIT_CLASS, AFX_WS_DEFAULT_VIEW |
    WS_HSCROLL | WS_VSCROLL | ES_AUTOHSCROLL | ES_AUTOVSCROLL |
    ES_MULTILINE | ES_NOHIDESEL | ES_SAVESEL | ES_SELECTIONBAR)
{
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    m_lpRichEditOle = NULL;
    m_nBulletIndent = 720; // 1/2 inch
    m_nWordWrap = WrapToWindow;
    m_nPasteType = 0;
    SetPaperSize(CSize(8*1440+720, 11*1440));
    SetMargins(CRect(0,0,0,0));
    m_charformat.cbSize = sizeof(CHARFORMAT);
    m_paraformat.cbSize = sizeof(PARAFORMAT);
}

BOOL CRichEdit2View::PreCreateWindow(CREATESTRUCT& cs)
{
    _AFX_RICHEDIT2_STATE* pState = AfxGetRichEdit2State();
    if (pState->m_hInstRichEdit == NULL)
#ifndef _MAC
        pState->m_hInstRichEdit = LoadLibraryA("MSFTEDIT.DLL");
        if (!pState->m_hInstRichEdit)
            pState->m_hInstRichEdit = LoadLibraryA("RICHED20.DLL");
#else
        pState->m_hInstRichEdit = RELoadLibrary();
#endif
    ASSERT(pState->m_hInstRichEdit != NULL);
    CCtrlView::PreCreateWindow(cs);
    cs.lpszName = &afxChNil;

    cs.cx = cs.cy = 100; // necessary to avoid bug with ES_SELECTIONBAR and zero for cx and cy
    cs.style |= WS_CLIPSIBLINGS;

    return TRUE;
}

int CRichEdit2View::OnCreate(LPCREATESTRUCT lpcs)
{
    if (CCtrlView::OnCreate(lpcs) != 0)
        return -1;
    GetRichEditCtrl().LimitText(lMaxSize);
    GetRichEditCtrl().SetEventMask(ENM_SELCHANGE | ENM_CHANGE | ENM_SCROLL);
    VERIFY(GetRichEditCtrl().SetOLECallback(&m_xRichEditOleCallback));
    m_lpRichEditOle = GetRichEditCtrl().GetIRichEditOle();
    DragAcceptFiles();
    GetRichEditCtrl().SetOptions(ECOOP_OR, ECO_AUTOWORDSELECTION);
    WrapChanged();
    ASSERT(m_lpRichEditOle != NULL);

    DWORD_PTR dwOptions = GetRichEditCtrl().SendMessage(EM_GETLANGOPTIONS, 0, 0);
    dwOptions &= ~IMF_DUALFONT;
    GetRichEditCtrl().SendMessage(EM_SETLANGOPTIONS, 0, dwOptions);

    dwOptions = (SES_USECTF | SES_CTFALLOWEMBED | SES_CTFALLOWSMARTTAG | SES_CTFALLOWPROOFING);
    GetRichEditCtrl().SendMessage(EM_SETEDITSTYLE, dwOptions, dwOptions);

    return 0;
}

void CRichEdit2View::OnInitialUpdate()
{
    CCtrlView::OnInitialUpdate();
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View document like functions

void CRichEdit2View::DeleteContents()
{
    ASSERT_VALID(this);
    ASSERT(m_hWnd != NULL);
    SetWindowText(_T(""));
    GetRichEditCtrl().EmptyUndoBuffer();
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    ASSERT_VALID(this);
}

void CRichEdit2View::WrapChanged()
{
    CWaitCursor wait;
    CRichEdit2Ctrl& ctrl = GetRichEditCtrl();
    if (m_nWordWrap == WrapNone)
        ctrl.SetTargetDevice(NULL, 1);
    else if (m_nWordWrap == WrapToWindow)
        ctrl.SetTargetDevice(NULL, 0);
    else if (m_nWordWrap == WrapToTargetDevice) // wrap to ruler
    {
        AfxGetApp()->CreatePrinterDC(m_dcTarget);
        if (m_dcTarget.m_hDC == NULL)
            m_dcTarget.CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
        ctrl.SetTargetDevice(m_dcTarget, GetPrintWidth());
    }
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View serialization support

class _afxRichEditCookie
{
public:
    CArchive& m_ar;
    DWORD m_dwError;
    _afxRichEditCookie(CArchive& ar) : m_ar(ar) {m_dwError=0;}
};

void CRichEdit2View::Serialize(CArchive& ar)
    // Read and write CRichEdit2View object to archive, with length prefix.
{
    ASSERT_VALID(this);
    ASSERT(m_hWnd != NULL);
    Stream(ar, FALSE);
    ASSERT_VALID(this);
}

void CRichEdit2View::Stream(CArchive& ar, BOOL bSelection)
{
    EDITSTREAM es = {0, 0, EditStreamCallBack};
    _afxRichEditCookie cookie(ar);
    es.dwCookie = (DWORD_PTR)&cookie;
    int nFormat = GetDocument()->GetStreamFormat();

    if (bSelection)
        nFormat |= SFF_SELECTION;
    if (GetDocument()->IsUnicode())
        nFormat |= SF_UNICODE;

    if (ar.IsStoring())
        GetRichEditCtrl().StreamOut(nFormat, es);
    else
    {
        GetRichEditCtrl().StreamIn(nFormat, es);
        Invalidate();
    }
    if (cookie.m_dwError != 0)
        AfxThrowFileException(cookie.m_dwError);
}

// return 0 for no error, otherwise return error code
DWORD CALLBACK CRichEdit2View::EditStreamCallBack(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)
{
    _afxRichEditCookie* pCookie = (_afxRichEditCookie*)dwCookie;
    CArchive& ar = pCookie->m_ar;
    ar.Flush();
    DWORD dw = 0;
    *pcb = cb;
    TRY
    {
        if (ar.IsStoring())
            ar.GetFile()->WriteHuge(pbBuff, cb);
        else
            *pcb = ar.GetFile()->ReadHuge(pbBuff, cb);
    }
    CATCH(CFileException, e)
    {
        *pcb = 0;
        pCookie->m_dwError = (DWORD)e->m_cause;
        dw = 1;
        DELETE_EXCEPTION(e);
    }
    AND_CATCH_ALL(e)
    {
        *pcb = 0;
        pCookie->m_dwError = (DWORD)CFileException::generic;
        dw = 1;
        DELETE_EXCEPTION(e);
    }
    END_CATCH_ALL
    return dw;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View Printing support

void CRichEdit2View::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo*)
{
    ASSERT_VALID(this);
//  ASSERT_VALID(pDC);
    // initialize page start vector
    ASSERT(m_aPageStart.GetSize() == 0);
    m_aPageStart.Add(0);
    ASSERT(m_aPageStart.GetSize() > 0);
    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache

    ASSERT_VALID(this);
}

BOOL CRichEdit2View::PaginateTo(CDC* pDC, CPrintInfo* pInfo)
    // attempts pagination to pInfo->m_nCurPage, TRUE == success
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);

    CRect rectSave = pInfo->m_rectDraw;
    UINT nPageSave = pInfo->m_nCurPage;
    ASSERT(nPageSave > 1);
    ASSERT(nPageSave >= (UINT)m_aPageStart.GetSize());
    VERIFY(pDC->SaveDC() != 0);
    pDC->IntersectClipRect(0, 0, 0, 0);
    pInfo->m_nCurPage = (UINT)m_aPageStart.GetSize();
    while (pInfo->m_nCurPage < nPageSave)
    {
        ASSERT(pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize());
        OnPrepareDC(pDC, pInfo);
        ASSERT(pInfo->m_bContinuePrinting);
        pInfo->m_rectDraw.SetRect(0, 0,
            pDC->GetDeviceCaps(HORZRES), pDC->GetDeviceCaps(VERTRES));
        pDC->DPtoLP(&pInfo->m_rectDraw);
        OnPrint(pDC, pInfo);
        if (pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize())
            break;
        ++pInfo->m_nCurPage;
    }
    BOOL bResult = pInfo->m_nCurPage == nPageSave;
    pDC->RestoreDC(-1);
    pInfo->m_nCurPage = nPageSave;
    pInfo->m_rectDraw = rectSave;
    ASSERT_VALID(this);
    return bResult;
}

void CRichEdit2View::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    ASSERT(pInfo != NULL);  // overriding OnPaint -- never get this.

    pDC->SetMapMode(MM_TEXT);

    if (pInfo->m_nCurPage > (UINT)m_aPageStart.GetSize() &&
        !PaginateTo(pDC, pInfo))
    {
        // can't paginate to that page, thus cannot print it.
        pInfo->m_bContinuePrinting = FALSE;
    }
    ASSERT_VALID(this);
}

long CRichEdit2View::PrintPage(CDC* pDC, long nIndexStart, long nIndexStop)
    // worker function for laying out text in a rectangle.
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    FORMATRANGE fr;

    // offset by printing offset
    pDC->SetViewportOrg(-pDC->GetDeviceCaps(PHYSICALOFFSETX),
        -pDC->GetDeviceCaps(PHYSICALOFFSETY));
    // adjust DC because richedit doesn't do things like MFC
    if (::GetDeviceCaps(pDC->m_hDC, TECHNOLOGY) != DT_METAFILE && pDC->m_hAttribDC != NULL)
    {
        ::ScaleWindowExtEx(pDC->m_hDC,
            ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSX),
            ::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSX),
            ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSY),
            ::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSY), NULL);
    }

    fr.hdcTarget = pDC->m_hAttribDC;
    fr.hdc = pDC->m_hDC;
    fr.rcPage = GetPageRect();
    fr.rc = GetPrintRect();

    fr.chrg.cpMin = nIndexStart;
    fr.chrg.cpMax = nIndexStop;
    long lRes = GetRichEditCtrl().FormatRange(&fr,TRUE);

    return lRes;
}

long CRichEdit2View::PrintInsideRect(CDC* pDC, RECT& rectLayout,
    long nIndexStart, long nIndexStop, BOOL bOutput)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    FORMATRANGE fr;

    // adjust DC because richedit doesn't do things like MFC
    if (::GetDeviceCaps(pDC->m_hDC, TECHNOLOGY) != DT_METAFILE && pDC->m_hAttribDC != NULL)
    {
        ::ScaleWindowExtEx(pDC->m_hDC,
            ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSX),
            ::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSX),
            ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSY),
            ::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSY), NULL);
    }

    fr.hdcTarget = pDC->m_hAttribDC;
    fr.hdc = pDC->m_hDC;
    // convert rect to twips
    fr.rcPage = rectLayout;
    fr.rc = rectLayout;

    fr.chrg.cpMin = nIndexStart;
    fr.chrg.cpMax = nIndexStop;
    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache
    // if bOutput is FALSE, we only measure
    long lres = GetRichEditCtrl().FormatRange(&fr, bOutput);
    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache

    rectLayout = fr.rc;
    return lres;
}

void CRichEdit2View::OnPrint(CDC* pDC, CPrintInfo* pInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    ASSERT(pInfo != NULL);
    ASSERT(pInfo->m_bContinuePrinting);

    UINT nPage = pInfo->m_nCurPage;
    ASSERT(nPage <= (UINT)m_aPageStart.GetSize());
    long nIndex = (long) m_aPageStart[nPage-1];

    // print as much as possible in the current page.
    nIndex = PrintPage(pDC, nIndex, 0xFFFFFFFF);

    if (nIndex >= GetTextLength())
    {
        TRACE0("End of Document\n");
        pInfo->SetMaxPage(nPage);
    }

    // update pagination information for page just printed
    if (nPage == (UINT)m_aPageStart.GetSize())
    {
        if (nIndex < GetTextLength())
            m_aPageStart.Add(nIndex);
    }
    else
    {
        ASSERT(nPage+1 <= (UINT)m_aPageStart.GetSize());
        ASSERT(nIndex == (long)m_aPageStart[nPage+1-1]);
    }
}


void CRichEdit2View::OnEndPrinting(CDC*, CPrintInfo*)
{
    ASSERT_VALID(this);
    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache
    m_aPageStart.RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View::XRichEditOleCallback

BEGIN_INTERFACE_MAP(CRichEdit2View, CCtrlView)
    // we use IID_IUnknown because richedit doesn't define an IID
    INTERFACE_PART(CRichEdit2View, IID_IUnknown, RichEditOleCallback)
END_INTERFACE_MAP()

STDMETHODIMP_(ULONG) CRichEdit2View::XRichEditOleCallback::AddRef()
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)
    return (ULONG)pThis->InternalAddRef();
}

STDMETHODIMP_(ULONG) CRichEdit2View::XRichEditOleCallback::Release()
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)
    return (ULONG)pThis->InternalRelease();
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::QueryInterface(
    REFIID iid, LPVOID* ppvObj)
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)
    return (HRESULT)pThis->InternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetNewStorage(LPSTORAGE* ppstg)
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)

    // Create a flat storage and steal it from the client item
    // the client item is only used for creating the storage
    COleClientItem item;
    item.GetItemStorageFlat();
    *ppstg = item.m_lpStorage;
    HRESULT hRes = E_OUTOFMEMORY;
    if (item.m_lpStorage != NULL)
    {
        item.m_lpStorage = NULL;
        hRes = S_OK;
    }
    pThis->GetDocument()->InvalidateObjectCache();
    return hRes;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetInPlaceContext(
    LPOLEINPLACEFRAME* lplpFrame, LPOLEINPLACEUIWINDOW* lplpDoc,
    LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    return pThis->GetWindowContext(lplpFrame, lplpDoc, lpFrameInfo);
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::ShowContainerUI(BOOL fShow)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    return pThis->ShowContainerUI(fShow);
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::QueryInsertObject(
    LPCLSID /*lpclsid*/, LPSTORAGE /*pstg*/, LONG /*cp*/)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    pThis->GetDocument()->InvalidateObjectCache();
    return S_OK;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::DeleteObject(LPOLEOBJECT /*lpoleobj*/)
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)
    pThis->GetDocument()->InvalidateObjectCache();
    return S_OK;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::QueryAcceptData(
    LPDATAOBJECT lpdataobj, CLIPFORMAT* lpcfFormat, DWORD reco,
    BOOL fReally, HGLOBAL hMetaPict)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    return pThis->QueryAcceptData(lpdataobj, lpcfFormat, reco,
        fReally, hMetaPict);
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::ContextSensitiveHelp(BOOL /*fEnterMode*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetClipboardData(
    CHARRANGE* lpchrg, DWORD reco, LPDATAOBJECT* lplpdataobj)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    LPDATAOBJECT lpOrigDataObject = NULL;

    // get richedit's data object
    if (FAILED(pThis->m_lpRichEditOle->GetClipboardData(lpchrg, reco,
        &lpOrigDataObject)))
    {
        return E_NOTIMPL;
    }

    // allow changes
    HRESULT hRes = pThis->GetClipboardData(lpchrg, reco, lpOrigDataObject,
        lplpdataobj);

    // if changed then free original object
    if (SUCCEEDED(hRes))
    {
        if (lpOrigDataObject!=NULL)
            lpOrigDataObject->Release();
        return hRes;
    }
    else
    {
        // use richedit's data object
        *lplpdataobj = lpOrigDataObject;
        return S_OK;
    }
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetDragDropEffect(
    BOOL fDrag, DWORD grfKeyState, LPDWORD pdwEffect)
{
    if (!fDrag) // allowable dest effects
    {
        DWORD dwEffect;
        // check for force link
#ifndef _MAC
        if ((grfKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
#else
        if ((grfKeyState & (MK_OPTION|MK_SHIFT)) == (MK_OPTION|MK_SHIFT))
#endif
            dwEffect = DROPEFFECT_LINK;
        // check for force copy
#ifndef _MAC
        else if ((grfKeyState & MK_CONTROL) == MK_CONTROL)
#else
        else if ((grfKeyState & MK_OPTION) == MK_OPTION)
#endif
            dwEffect = DROPEFFECT_COPY;
        // check for force move
        else if ((grfKeyState & MK_ALT) == MK_ALT)
            dwEffect = DROPEFFECT_MOVE;
        // default -- recommended action is move
        else
            dwEffect = DROPEFFECT_MOVE;
        if (dwEffect & *pdwEffect) // make sure allowed type
            *pdwEffect = dwEffect;
    }
    return S_OK;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetContextMenu(
    WORD seltype, LPOLEOBJECT lpoleobj, CHARRANGE* lpchrg,
    HMENU* lphmenu)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    HMENU hMenu = pThis->GetContextMenu(seltype, lpoleobj, lpchrg);
    if (hMenu == NULL)
        return E_NOTIMPL;
    *lphmenu = hMenu;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View command helpers

void CRichEdit2View::OnCharEffect(DWORD dwMask, DWORD dwEffect)
{
    GetCharFormatSelection();
    if (m_charformat.dwMask & dwMask) // selection is all the same
        m_charformat.dwEffects ^= dwEffect;
    else
        m_charformat.dwEffects |= dwEffect;
    m_charformat.dwMask = dwMask;
    SetCharFormat(m_charformat);
}

void CRichEdit2View::OnUpdateCharEffect(CCmdUI* pCmdUI, DWORD dwMask, DWORD dwEffect)
{
    GetCharFormatSelection();
    pCmdUI->SetCheck((m_charformat.dwMask & dwMask) ?
        ((m_charformat.dwEffects & dwEffect) ? 1 : 0) : 2);
}

void CRichEdit2View::OnParaAlign(WORD wAlign)
{
    GetParaFormatSelection();
    m_paraformat.dwMask = PFM_ALIGNMENT;
    m_paraformat.wAlignment = wAlign;
    SetParaFormat(m_paraformat);
}

void CRichEdit2View::OnUpdateParaAlign(CCmdUI* pCmdUI, WORD wAlign)
{
    GetParaFormatSelection();
    // disable if no word wrap since alignment is meaningless
    pCmdUI->Enable( (m_nWordWrap == WrapNone) ?
        FALSE : TRUE);
    pCmdUI->SetCheck( (m_paraformat.dwMask & PFM_ALIGNMENT) ?
        ((m_paraformat.wAlignment == wAlign) ? 1 : 0) : 2);
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View commands

void CRichEdit2View::OnUpdateNeedSel(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    long nStartChar, nEndChar;
    GetRichEditCtrl().GetSel(nStartChar, nEndChar);
    pCmdUI->Enable(nStartChar != nEndChar);
    ASSERT_VALID(this);
}

void CRichEdit2View::OnUpdateNeedClip(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    pCmdUI->Enable(CanPaste());
}

void CRichEdit2View::OnUpdateNeedText(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    pCmdUI->Enable(GetTextLength() != 0);
}

void CRichEdit2View::OnUpdateNeedFind(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    pCmdUI->Enable(GetTextLength() != 0 &&
        !pEditState->strFind.IsEmpty());
}

void CRichEdit2View::OnUpdateEditUndo(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    pCmdUI->Enable(GetRichEditCtrl().CanUndo());
}

void CRichEdit2View::OnEditCut()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().Cut();
}

void CRichEdit2View::OnEditCopy()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().Copy();
}

void CRichEdit2View::OnEditPaste()
{
    ASSERT_VALID(this);
    m_nPasteType = 0;
    GetRichEditCtrl().Paste();
}

void CRichEdit2View::OnEditClear()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().Clear();
}

void CRichEdit2View::OnEditUndo()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().Undo();
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
}

void CRichEdit2View::OnEditSelectAll()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().SetSel(0, -1);
}

void CRichEdit2View::OnEditFind()
{
    ASSERT_VALID(this);
    OnEditFindReplace(TRUE);
}

void CRichEdit2View::OnEditReplace()
{
    ASSERT_VALID(this);
    OnEditFindReplace(FALSE);
}

void CRichEdit2View::OnEditRepeat()
{
    ASSERT_VALID(this);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    if (!FindText(pEditState))
        TextNotFound(pEditState->strFind);
}

void CRichEdit2View::OnCancelEditCntr()
{
    m_lpRichEditOle->InPlaceDeactivate();
}

void CRichEdit2View::OnInsertObject()
{
    // Invoke the standard Insert Object dialog box to obtain information
    COleInsertDialog dlg;
    if (dlg.DoModal() != IDOK)
        return;

    CWaitCursor wait;

    CRichEdit2CntrItem* pItem = NULL;
    TRY
    {
        // create item from dialog results
        pItem = GetDocument()->CreateClientItem();
        pItem->m_bLock = TRUE;
        if (!dlg.CreateItem(pItem))
        {
            pItem->m_bLock = FALSE;
            AfxThrowMemoryException();  // any exception will do
        }

        HRESULT hr = InsertItem(pItem);
        pItem->UpdateItemType();

        pItem->m_bLock = FALSE;

        if (hr != NOERROR)
            AfxThrowOleException(hr);

        // if insert new object -- initially show the object
        if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
            pItem->DoVerb(OLEIVERB_SHOW, this);
    }
    CATCH(CException, e)
    {
        if (pItem != NULL)
        {
            ASSERT_VALID(pItem);
            pItem->Delete();
        }
        AfxMessageBox(AFX_IDP_FAILED_TO_CREATE);
    }
    END_CATCH
}

void CRichEdit2View::OnSelChange(NMHDR* pNMHDR, LRESULT* pResult)
{
    ASSERT(pNMHDR->code == EN_SELCHANGE);
    UNUSED(pNMHDR); // not used in release builds

    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    *pResult = 0;
}

void CRichEdit2View::OnDestroy()
{
    if (m_lpRichEditOle != NULL)
        m_lpRichEditOle->Release();
    CCtrlView::OnDestroy();
}

void CRichEdit2View::OnEditProperties()
{
    ASSERT(m_lpRichEditOle != NULL);
    CRichEdit2CntrItem* pSelection = GetSelectedItem();
    // make sure item is in sync with richedit's item
    CRe2Object reo;
    m_lpRichEditOle->GetObject(REO_IOB_SELECTION, &reo, REO_GETOBJ_NO_INTERFACES);
    pSelection->SyncToRichEditObject(reo);

    //
    // HACKHACK:  Due to a mismatch between the NT build environment and MFC
    //            wrt to the setting of _WIN32_IE, Wordpad and MFC have 
    //            different views of how large a COlePropertiesDialog is.  The
    //            result is that MFC ends up wiping part of the stack in it's
    //            initialization code.  Hack some extra space until the
    //            mismatch is resolved.
    //
//    COlePropertiesDialog dlg(pSelection);
    struct Hack
    {
        COlePropertiesDialog dlg;
        BYTE                 space[128];
    
        Hack(CRichEdit2CntrItem *pSelection) : dlg(pSelection) {}
    }
    hack(pSelection);
    COlePropertiesDialog &dlg = hack.dlg;

    //
    // The Object Properties dialog doesn't display a help button even if
    // you tell it to.  The dialogs under it (e.g. Change Icon) will display
    // the help button though.  We never want a help button but MFC turns it
    // on by default.  If the Ole dialogs are fixed to not display the help
    // button then this can be removed.
    //
    dlg.m_op.dwFlags &= ~OPF_SHOWHELP;

    dlg.DoModal();
}

void CRichEdit2View::OnUpdateEditProperties(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(GetSelectedItem() != NULL);
}

void CRichEdit2View::OnCharBold()
{
    OnCharEffect(CFM_BOLD, CFE_BOLD);
}

void CRichEdit2View::OnUpdateCharBold(CCmdUI* pCmdUI)
{
    OnUpdateCharEffect(pCmdUI, CFM_BOLD, CFE_BOLD);
}

void CRichEdit2View::OnCharItalic()
{
    OnCharEffect(CFM_ITALIC, CFE_ITALIC);
}

void CRichEdit2View::OnUpdateCharItalic(CCmdUI* pCmdUI)
{
    OnUpdateCharEffect(pCmdUI, CFM_ITALIC, CFE_ITALIC);
}

void CRichEdit2View::OnCharUnderline()
{
    OnCharEffect(CFM_UNDERLINE, CFE_UNDERLINE);
}

void CRichEdit2View::OnUpdateCharUnderline(CCmdUI* pCmdUI)
{
    OnUpdateCharEffect(pCmdUI, CFM_UNDERLINE, CFE_UNDERLINE);
}

void CRichEdit2View::OnParaCenter()
{
    OnParaAlign(PFA_CENTER);
}

void CRichEdit2View::OnUpdateParaCenter(CCmdUI* pCmdUI)
{
    OnUpdateParaAlign(pCmdUI, PFA_CENTER);
}

void CRichEdit2View::OnParaLeft()
{
    OnParaAlign(PFA_LEFT);
}

void CRichEdit2View::OnUpdateParaLeft(CCmdUI* pCmdUI)
{
    OnUpdateParaAlign(pCmdUI, PFA_LEFT);
}

void CRichEdit2View::OnParaRight()
{
    OnParaAlign(PFA_RIGHT);
}

void CRichEdit2View::OnUpdateParaRight(CCmdUI* pCmdUI)
{
    OnUpdateParaAlign(pCmdUI, PFA_RIGHT);
}

void CRichEdit2View::OnBullet()
{
    GetParaFormatSelection();
    if (m_paraformat.dwMask & PFM_NUMBERING && m_paraformat.wNumbering == PFN_BULLET)
    {
        m_paraformat.wNumbering = 0;
        m_paraformat.dxOffset = 0;
        m_paraformat.dxStartIndent = 0;
        m_paraformat.dwMask = PFM_NUMBERING | PFM_STARTINDENT | PFM_OFFSET;
    }
    else
    {
        m_paraformat.wNumbering = PFN_BULLET;
        m_paraformat.dwMask = PFM_NUMBERING;
        if (m_paraformat.dxOffset == 0)
        {
            m_paraformat.dxOffset = m_nBulletIndent;
            m_paraformat.dwMask = PFM_NUMBERING | PFM_STARTINDENT | PFM_OFFSET;
        }
    }
    SetParaFormat(m_paraformat);
}

void CRichEdit2View::OnUpdateBullet(CCmdUI* pCmdUI)
{
    GetParaFormatSelection();
    pCmdUI->SetCheck( (m_paraformat.dwMask & PFM_NUMBERING) ? ((m_paraformat.wNumbering & PFN_BULLET) ? 1 : 0) : 2);
}

void CRichEdit2View::OnFormatFont()
{
    GetCharFormatSelection();
    CFontDialog2 dlg(m_charformat, CF_BOTH|CF_NOOEMFONTS);
    if (dlg.DoModal() == IDOK)
    {
        dlg.GetCharFormat(m_charformat);
        SetCharFormat(m_charformat);
    }
}

void CRichEdit2View::OnColorPick(COLORREF cr)
{
    GetCharFormatSelection();
    m_charformat.dwMask = CFM_COLOR;
    m_charformat.dwEffects = NULL;
    m_charformat.crTextColor = cr;
    SetCharFormat(m_charformat);
}

void CRichEdit2View::OnColorDefault()
{
    GetCharFormatSelection();
    m_charformat.dwMask = CFM_COLOR;
    m_charformat.dwEffects = CFE_AUTOCOLOR;
    SetCharFormat(m_charformat);
}

void CRichEdit2View::OnEditPasteSpecial()
{
    COlePasteSpecialDialog dlg;
    dlg.AddStandardFormats();
    dlg.AddFormat(_oleData.cfRichTextFormat, TYMED_HGLOBAL, AFX_IDS_RTF_FORMAT, FALSE, FALSE);
    dlg.AddFormat(CF_TEXT, TYMED_HGLOBAL, AFX_IDS_TEXT_FORMAT, FALSE, FALSE);

    if (dlg.DoModal() != IDOK)
        return;

    DVASPECT dv = dlg.GetDrawAspect();
    HMETAFILE hMF = (HMETAFILE)dlg.GetIconicMetafile();
    CLIPFORMAT cf =
        dlg.m_ps.arrPasteEntries[dlg.m_ps.nSelectedIndex].fmtetc.cfFormat;

    CWaitCursor wait;
    SetCapture();

    // we set the target type so that QueryAcceptData know what to paste
    m_nPasteType = dlg.GetSelectionType();
    GetRichEditCtrl().PasteSpecial(cf, dv, hMF);
    m_nPasteType = 0;

    ReleaseCapture();
}

void CRichEdit2View::OnUpdateEditPasteSpecial(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(CanPaste());
}

void CRichEdit2View::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if (nChar == VK_F10 && GetKeyState(VK_SHIFT) < 0)
    {
        CRect rect;
        GetClientRect(rect);
        CPoint pt = rect.CenterPoint();
        SendMessage(WM_CONTEXTMENU, (WPARAM)m_hWnd, MAKELPARAM(pt.x, pt.y));
    }
    else
        CCtrlView::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CRichEdit2View::OnDropFiles(HDROP hDropInfo)
{
    TCHAR szFileName[_MAX_PATH];
    UINT nFileCount = ::DragQueryFile(hDropInfo, 0xFFFFFFFF, NULL, 0);
    ASSERT(nFileCount != 0);
    CHARRANGE cr;

    GetRichEditCtrl().GetSel(cr);
    int nMin = cr.cpMin;
    for (UINT i=0;i<nFileCount;i++)
    {
        ::DragQueryFile(hDropInfo, i, szFileName, _MAX_PATH);
        InsertFileAsObject(szFileName);
        GetRichEditCtrl().GetSel(cr);
        cr.cpMin = cr.cpMax;
        GetRichEditCtrl().SetSel(cr);
        UpdateWindow();
    }
    cr.cpMin = nMin;
    GetRichEditCtrl().SetSel(cr);
    ::DragFinish(hDropInfo);
}

void CRichEdit2View::OnDevModeChange(LPTSTR /*lpDeviceName*/)
{
    // WM_DEVMODECHANGE forwarded by the main window of the app
    CDC dc;
    AfxGetApp()->CreatePrinterDC(dc);
    OnPrinterChanged(dc);
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View attributes

BOOL AFX_CDECL CRichEdit2View::IsRichEdit2Format(CLIPFORMAT cf)
{
    return ((cf == _oleData.cfRichTextFormat)     ||
            (cf == _oleData.cfRichTextAndObjects) ||
            (cf == CF_TEXT)                       ||
            (cf == CF_UNICODETEXT));
}

BOOL CRichEdit2View::CanPaste() const
{
    return (CountClipboardFormats() != 0) &&
        (IsClipboardFormatAvailable(CF_TEXT) ||
        IsClipboardFormatAvailable(_oleData.cfRichTextFormat) ||
        IsClipboardFormatAvailable(_oleData.cfEmbedSource) ||
        IsClipboardFormatAvailable(_oleData.cfEmbeddedObject) ||
        IsClipboardFormatAvailable(_oleData.cfFileName) ||
        IsClipboardFormatAvailable(_oleData.cfFileNameW) ||
        IsClipboardFormatAvailable(CF_METAFILEPICT) ||
        IsClipboardFormatAvailable(CF_DIB) ||
        IsClipboardFormatAvailable(CF_BITMAP) ||
        GetRichEditCtrl().CanPaste());
}

CHARFORMAT& CRichEdit2View::GetCharFormatSelection()
{
    if (m_bSyncCharFormat)
    {
        GetRichEditCtrl().GetSelectionCharFormat(m_charformat);
        m_bSyncCharFormat = FALSE;
    }
    return m_charformat;
}

PARAFORMAT& CRichEdit2View::GetParaFormatSelection()
{
    if (m_bSyncParaFormat)
    {
        GetRichEditCtrl().GetParaFormat(m_paraformat);
        m_bSyncParaFormat = FALSE;
    }
    return m_paraformat;
}

void CRichEdit2View::SetCharFormat(CHARFORMAT cf)
{
    CWaitCursor wait;
    GetRichEditCtrl().SetSelectionCharFormat(cf);
    m_bSyncCharFormat = TRUE;
}

void CRichEdit2View::SetParaFormat(PARAFORMAT& pf)
{
    CWaitCursor wait;
    GetRichEditCtrl().SetParaFormat(pf);
    m_bSyncParaFormat = TRUE;
}

CRichEdit2CntrItem* CRichEdit2View::GetSelectedItem() const
{
    ASSERT(m_lpRichEditOle != NULL);
    CRichEdit2Doc* pDoc = GetDocument();
    CRichEdit2CntrItem* pItem = NULL;

    CRe2Object reo;
    HRESULT hr = m_lpRichEditOle->GetObject(REO_IOB_SELECTION, &reo,
        REO_GETOBJ_ALL_INTERFACES);
    //reo's interfaces are all in UNICODE
    if (GetScode(hr) == S_OK)
    {
        pItem = pDoc->LookupItem(reo.poleobj);
        if (pItem == NULL)
            pItem = pDoc->CreateClientItem(&reo);
        ASSERT(pItem != NULL);
    }
    return pItem;
}

CRichEdit2CntrItem* CRichEdit2View::GetInPlaceActiveItem() const
{
    ASSERT(m_lpRichEditOle != NULL);
    CRichEdit2Doc* pDoc = GetDocument();
    CRichEdit2CntrItem* pItem = NULL;

    CRe2Object reo;
    HRESULT hr = m_lpRichEditOle->GetObject(REO_IOB_SELECTION, &reo,
        REO_GETOBJ_ALL_INTERFACES);
    //reo's interfaces are all in UNICODE
    if (GetScode(hr) == S_OK && (reo.dwFlags & REO_INPLACEACTIVE))
    {
        pItem = pDoc->LookupItem(reo.poleobj);
        if (pItem == NULL)
            pItem = pDoc->CreateClientItem(&reo);
        ASSERT(pItem != NULL);
    }
    return pItem;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View operations
HRESULT CRichEdit2View::InsertItem(CRichEdit2CntrItem* pItem)
{
    ASSERT(m_lpRichEditOle != NULL);
    CRe2Object reo(pItem);
    reo.cp = REO_CP_SELECTION;

    HRESULT hr = m_lpRichEditOle->InsertObject(&reo);

    CHARRANGE cr;
    GetRichEditCtrl().GetSel(cr);
    cr.cpMin = cr.cpMax -1;
    GetRichEditCtrl().SetSel(cr);
    return hr;
}

void CRichEdit2View::InsertFileAsObject(LPCTSTR lpszFileName)
{
    CString str = lpszFileName;
    CWaitCursor wait;
    CRichEdit2CntrItem* pItem = NULL;
    TRY
    {
        // create item from dialog results
        pItem = GetDocument()->CreateClientItem();
        pItem->m_bLock = TRUE;
        if (!pItem->CreateFromFile(str))
            AfxThrowMemoryException();  // any exception will do
        pItem->UpdateLink();
        InsertItem(pItem);
        pItem->m_bLock = FALSE;
    }
    CATCH(CException, e)
    {
        if (pItem != NULL)
        {
            pItem->m_bLock = FALSE;
            ASSERT_VALID(pItem);
            pItem->Delete();
        }
    }
    END_CATCH
}

//
// CRichEditView::DoPaste doesn't return an error but we need it to...
//
HRESULT g_hrPaste;

void CRichEdit2View::DoPaste(COleDataObject& dataobj, CLIPFORMAT cf, HMETAFILEPICT hMetaPict)
{
    CWaitCursor wait;

    g_hrPaste = S_FALSE;

    CRichEdit2CntrItem* pItem = NULL;
    TRY
    {
        // create item from dialog results
        pItem = GetDocument()->CreateClientItem();
        pItem->m_bLock = TRUE;

        if (m_nPasteType == COlePasteSpecialDialog::pasteLink)      // paste link
        {
            if (!pItem->CreateLinkFromData(&dataobj))
                AfxThrowMemoryException();  // any exception will do
        }
        else if (m_nPasteType == COlePasteSpecialDialog::pasteNormal)
        {
            if (!pItem->CreateFromData(&dataobj))
                AfxThrowMemoryException();      // any exception will do
        }
        else if (m_nPasteType == COlePasteSpecialDialog::pasteStatic)
        {
            if (!pItem->CreateStaticFromData(&dataobj))
                AfxThrowMemoryException();      // any exception will do
        }
        else
        {
            // paste embedded
            if (!pItem->CreateFromData(&dataobj) &&
                !pItem->CreateStaticFromData(&dataobj))
            {
                AfxThrowMemoryException();      // any exception will do
            }
        }

        if (cf == 0)
        {
            // copy the current iconic representation
            FORMATETC fmtetc;
            fmtetc.cfFormat = CF_METAFILEPICT;
            fmtetc.dwAspect = DVASPECT_ICON;
            fmtetc.ptd = NULL;
            fmtetc.tymed = TYMED_MFPICT;
            fmtetc.lindex = 1;
            HGLOBAL hObj = dataobj.GetGlobalData(CF_METAFILEPICT, &fmtetc);
            if (hObj != NULL)
            {
                pItem->SetIconicMetafile(hObj);
                // the following code is an easy way to free a metafile pict
                STGMEDIUM stgMed;
                memset(&stgMed, 0, sizeof(stgMed));
                stgMed.tymed = TYMED_MFPICT;
                stgMed.hGlobal = hObj;
                ReleaseStgMedium(&stgMed);
            }

            // set the current drawing aspect
            hObj = dataobj.GetGlobalData((CLIPFORMAT)_oleData.cfObjectDescriptor);
            if (hObj != NULL)
            {
                ASSERT(hObj != NULL);
                // got CF_OBJECTDESCRIPTOR ok.  Lock it down and extract size.
                LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(hObj);
                ASSERT(pObjDesc != NULL);
                ((COleClientItem*)pItem)->SetDrawAspect((DVASPECT)pObjDesc->dwDrawAspect);
                GlobalUnlock(hObj);
                GlobalFree(hObj);
            }
        }
        else
        {
            if (hMetaPict != NULL)
            {
                pItem->SetIconicMetafile(hMetaPict);
                ((COleClientItem*)pItem)->SetDrawAspect(DVASPECT_ICON);
            }
            else
                ((COleClientItem*)pItem)->SetDrawAspect(DVASPECT_CONTENT);
        }

/////////
        HRESULT hr = InsertItem(pItem);
        pItem->UpdateItemType();

        pItem->m_bLock = FALSE;

        if (hr != NOERROR)
            AfxThrowOleException(hr);

    }
    CATCH(CException, e)
    {
        if (pItem != NULL)
        {
            pItem->m_bLock = FALSE;
            ASSERT_VALID(pItem);
            pItem->Delete();
        }
        g_hrPaste = E_FAIL;
    }
    END_CATCH
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View virtuals

void CRichEdit2View::OnPrinterChanged(const CDC& dcPrinter)
{
    // this is typically called by the view when it gets a WM_DEVMODECHANGE
    // also called during page setup
    CSize size;
    if (dcPrinter.m_hDC != NULL)
    {
        // this will fill in the page size
        size.cx = MulDiv(dcPrinter.GetDeviceCaps(PHYSICALWIDTH), 1440,
            dcPrinter.GetDeviceCaps(LOGPIXELSX));
        size.cy = MulDiv(dcPrinter.GetDeviceCaps(PHYSICALHEIGHT), 1440,
            dcPrinter.GetDeviceCaps(LOGPIXELSY));
    }
    else
        size = CSize(8*1440+720, 11*1440); // 8.5" by 11"
    if (GetPaperSize() != size)
    {
        SetPaperSize(size);
        if (m_nWordWrap == WrapToTargetDevice) //wrap to ruler
            WrapChanged();
    }
}

BOOL CRichEdit2View::OnPasteNativeObject(LPSTORAGE)
{
    // use this function to pull out native data from an embedded object
    // one would typically do this by create a COleStreamFile and attaching it
    // to an archive
    return FALSE;
}

HMENU CRichEdit2View::GetContextMenu(WORD, LPOLEOBJECT, CHARRANGE* )
{
    return NULL;
}

HRESULT CRichEdit2View::GetClipboardData(CHARRANGE* /*lpchrg*/, DWORD /*reco*/,
    LPDATAOBJECT /*lpRichDataObj*/, LPDATAOBJECT* /*lplpdataobj*/)
{
    return E_NOTIMPL;
}

HRESULT CRichEdit2View::QueryAcceptData(LPDATAOBJECT lpdataobj,
    CLIPFORMAT* lpcfFormat, DWORD /*dwReco*/, BOOL bReally, HGLOBAL hMetaPict)
{
    ASSERT(lpcfFormat != NULL);
    if (!bReally) // not actually pasting
        return S_OK;
    // if direct pasting a particular native format allow it
    if (IsRichEdit2Format(*lpcfFormat))
        return S_OK;

    COleDataObject dataobj;
    dataobj.Attach(lpdataobj, FALSE);
    // if format is 0, then force particular formats if available
    if (*lpcfFormat == 0 && (m_nPasteType == 0))
    {
        if (dataobj.IsDataAvailable((CLIPFORMAT)_oleData.cfRichTextAndObjects)) // native avail, let richedit do as it wants
            return S_OK;
        else if (dataobj.IsDataAvailable((CLIPFORMAT)_oleData.cfRichTextFormat))
        {
            *lpcfFormat = (CLIPFORMAT)_oleData.cfRichTextFormat;
            return S_OK;
        }
        else if (dataobj.IsDataAvailable(CF_UNICODETEXT))
        {
            *lpcfFormat = CF_UNICODETEXT;
            return S_OK;
        }
        else if (dataobj.IsDataAvailable(CF_TEXT))
        {
            *lpcfFormat = CF_TEXT;
            return S_OK;
        }
    }
    // paste OLE formats

    DoPaste(dataobj, *lpcfFormat, hMetaPict);
    return g_hrPaste;
}

HRESULT CRichEdit2View::GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
    LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    CRichEdit2CntrItem* pItem = GetSelectedItem();
    if (pItem == NULL)
        return E_FAIL;
    pItem->m_pView = this;
    HRESULT hr = pItem->GetWindowContext(lplpFrame, lplpDoc, lpFrameInfo);
    pItem->m_pView = NULL;
    return hr;
}

HRESULT CRichEdit2View::ShowContainerUI(BOOL b)
{
    CRichEdit2CntrItem* pItem = GetSelectedItem();
    if (pItem == NULL)
        return E_FAIL;
    if (b)
        pItem->m_pView = this;
    HRESULT hr = pItem->ShowContainerUI(b);
    if (FAILED(hr) || !b)
        pItem->m_pView = NULL;
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View Find & Replace

void CRichEdit2View::AdjustDialogPosition(CDialog* pDlg)
{
    ASSERT(pDlg != NULL);

    long lStart, lEnd;
    GetRichEditCtrl().GetSel(lStart, lEnd);
    CPoint point = GetRichEditCtrl().GetCharPos(lStart);
    ClientToScreen(&point);
    CRect rectDlg;
    pDlg->GetWindowRect(&rectDlg);
    if (rectDlg.PtInRect(point))
    {
        if (point.y > rectDlg.Height())
            rectDlg.OffsetRect(0, point.y - rectDlg.bottom - 20);
        else
        {
            HMONITOR hMonitor = MonitorFromWindow(*pDlg, MONITOR_DEFAULTTONEAREST);
            MONITORINFO monitorInfo;
            monitorInfo.cbSize = sizeof(monitorInfo);
            GetMonitorInfo(hMonitor, &monitorInfo);

            int nVertExt = monitorInfo.rcMonitor.bottom
                           - monitorInfo.rcMonitor.top;
            if (point.y + rectDlg.Height() < nVertExt)
                rectDlg.OffsetRect(0, 40 + point.y - rectDlg.top);
        }
        pDlg->MoveWindow(&rectDlg);
    }
}

void CRichEdit2View::OnEditFindReplace(BOOL bFindOnly)
{
    ASSERT_VALID(this);
    m_bFirstSearch = TRUE;
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    if (pEditState->pFindReplaceDlg != NULL)
    {
        if (pEditState->bFindOnly == bFindOnly)
        {
            pEditState->pFindReplaceDlg->SetActiveWindow();
            pEditState->pFindReplaceDlg->ShowWindow(SW_SHOW);
            return;
        }
        else
        {
            ASSERT(pEditState->bFindOnly != bFindOnly);
            pEditState->pFindReplaceDlg->SendMessage(WM_CLOSE);
            ASSERT(pEditState->pFindReplaceDlg == NULL);
            ASSERT_VALID(this);
        }
    }
    CString strFind = GetRichEditCtrl().GetSelText();
    // if selection is empty or spans multiple lines use old find text
    if (strFind.IsEmpty() || (strFind.FindOneOf(_T("\n\r")) != -1))
        strFind = pEditState->strFind;
    CString strReplace = pEditState->strReplace;
    pEditState->pFindReplaceDlg = new CFindReplaceDialog;
    ASSERT(pEditState->pFindReplaceDlg != NULL);
    DWORD dwFlags = NULL;
    if (pEditState->bNext)
        dwFlags |= FR_DOWN;
    if (pEditState->bCase)
        dwFlags |= FR_MATCHCASE;
    if (pEditState->bWord)
        dwFlags |= FR_WHOLEWORD;
    // hide stuff that RichEdit doesn't support
    dwFlags |= FR_HIDEUPDOWN;
    if (!pEditState->pFindReplaceDlg->Create(bFindOnly, strFind,
        strReplace, dwFlags, this))
    {
        pEditState->pFindReplaceDlg = NULL;
        ASSERT_VALID(this);
        return;
    }
    ASSERT(pEditState->pFindReplaceDlg != NULL);
    pEditState->bFindOnly = bFindOnly;
    pEditState->pFindReplaceDlg->SetActiveWindow();
    pEditState->pFindReplaceDlg->ShowWindow(SW_SHOW);
    ASSERT_VALID(this);
}

void CRichEdit2View::OnFindNext(LPCTSTR lpszFind, BOOL bNext, BOOL bCase, BOOL bWord)
{
    ASSERT_VALID(this);

    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    pEditState->strFind = lpszFind;
    pEditState->bCase = bCase;
    pEditState->bWord = bWord;
    pEditState->bNext = bNext;

    if (!FindText(pEditState))
        TextNotFound(pEditState->strFind);
    else
        AdjustDialogPosition(pEditState->pFindReplaceDlg);
    ASSERT_VALID(this);
}

void CRichEdit2View::OnReplaceSel(LPCTSTR lpszFind, BOOL bNext, BOOL bCase,
    BOOL bWord, LPCTSTR lpszReplace)
{
    ASSERT_VALID(this);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    pEditState->strFind = lpszFind;
    pEditState->strReplace = lpszReplace;
    pEditState->bCase = bCase;
    pEditState->bWord = bWord;
    pEditState->bNext = bNext;

    if (!SameAsSelected(pEditState->strFind, pEditState->bCase, pEditState->bWord))
    {
        if (!FindText(pEditState))
            TextNotFound(pEditState->strFind);
        else
            AdjustDialogPosition(pEditState->pFindReplaceDlg);
        return;
    }

    long start;
    long end;
    long length1;
    long length2;

    GetRichEditCtrl().GetSel(start, end);
    length1 = end - start;

    GetRichEditCtrl().ReplaceSel(pEditState->strReplace, TRUE);
    if (!FindText(pEditState))
    {
        TextNotFound(pEditState->strFind);
    }
    else
    {
        GetRichEditCtrl().GetSel(start, end);
        length2 = end - start;

        if (m_lInitialSearchPos < 0)
            m_lInitialSearchPos += (length2 - length1);

        AdjustDialogPosition(pEditState->pFindReplaceDlg);
    }
    ASSERT_VALID(this);
}

void CRichEdit2View::OnReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace, BOOL bCase, BOOL bWord)
{
    ASSERT_VALID(this);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    pEditState->strFind = lpszFind;
    pEditState->strReplace = lpszReplace;
    pEditState->bCase = bCase;
    pEditState->bWord = bWord;
    pEditState->bNext = TRUE;

    CWaitCursor wait;
    // no selection or different than what looking for
    if (!SameAsSelected(pEditState->strFind, pEditState->bCase, pEditState->bWord))
    {
        if (!FindText(pEditState))
        {
            TextNotFound(pEditState->strFind);
            return;
        }
    }

    GetRichEditCtrl().HideSelection(TRUE, FALSE);
    do
    {
        GetRichEditCtrl().ReplaceSel(pEditState->strReplace, TRUE);
    } while (FindTextSimple(pEditState));
    TextNotFound(pEditState->strFind);
    GetRichEditCtrl().HideSelection(FALSE, FALSE);

    ASSERT_VALID(this);
}

LRESULT CRichEdit2View::OnFindReplaceCmd(WPARAM, LPARAM lParam)
{
    ASSERT_VALID(this);
    CFindReplaceDialog* pDialog = CFindReplaceDialog::GetNotifier(lParam);
    ASSERT(pDialog != NULL);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    ASSERT(pDialog == pEditState->pFindReplaceDlg);
    if (pDialog->IsTerminating())
        pEditState->pFindReplaceDlg = NULL;
    else if (pDialog->FindNext())
    {
        OnFindNext(pDialog->GetFindString(), pDialog->SearchDown(),
            pDialog->MatchCase(), pDialog->MatchWholeWord());
    }
    else if (pDialog->ReplaceCurrent())
    {
        ASSERT(!pEditState->bFindOnly);
        OnReplaceSel(pDialog->GetFindString(),
            pDialog->SearchDown(), pDialog->MatchCase(), pDialog->MatchWholeWord(),
            pDialog->GetReplaceString());
    }
    else if (pDialog->ReplaceAll())
    {
        ASSERT(!pEditState->bFindOnly);
        OnReplaceAll(pDialog->GetFindString(), pDialog->GetReplaceString(),
            pDialog->MatchCase(), pDialog->MatchWholeWord());
    }
    ASSERT_VALID(this);
    return 0;
}

BOOL CRichEdit2View::SameAsSelected(LPCTSTR lpszCompare, BOOL bCase, BOOL /*bWord*/)
{
    CString strSelect = GetRichEditCtrl().GetSelText();
    return (bCase && lstrcmp(lpszCompare, strSelect) == 0) ||
        (!bCase && lstrcmpi(lpszCompare, strSelect) == 0);
}

BOOL CRichEdit2View::FindText(_AFX_RICHEDIT2_STATE* pEditState)
{
    ASSERT(pEditState != NULL);
    return FindText(pEditState->strFind, pEditState->bCase, pEditState->bWord);
}

BOOL CRichEdit2View::FindText(LPCTSTR lpszFind, BOOL bCase, BOOL bWord)
{
    ASSERT_VALID(this);
    CWaitCursor wait;
    return FindTextSimple(lpszFind, bCase, bWord);
}

BOOL CRichEdit2View::FindTextSimple(_AFX_RICHEDIT2_STATE* pEditState)
{
    ASSERT(pEditState != NULL);
    return FindTextSimple(pEditState->strFind, pEditState->bCase, pEditState->bWord);
}

BOOL CRichEdit2View::FindTextSimple(LPCTSTR lpszFind, BOOL bCase, BOOL bWord)
{
    USES_CONVERSION;
    ASSERT(lpszFind != NULL);
    FINDTEXTEX  ft;
    long        cchText;

    GETTEXTLENGTHEX textlen;

    textlen.flags = GTL_NUMCHARS;
#ifdef UNICODE
    textlen.codepage = 1200;            // Unicode code page
#else
    textlen.codepage = CP_ACP;
#endif

    cchText = (long)GetRichEditCtrl().SendMessage(
                                    EM_GETTEXTLENGTHEX,
                                    (WPARAM) &textlen,
                                    0);

    GetRichEditCtrl().GetSel(ft.chrg);

    if (m_bFirstSearch)
    {
        m_lInitialSearchPos = ft.chrg.cpMin;
        m_bFirstSearch = FALSE;
    }
    //REVIEW: Is this cast safe?
    ft.lpstrText = (LPTSTR)lpszFind;
    if (ft.chrg.cpMin != ft.chrg.cpMax) // i.e. there is a selection
        ft.chrg.cpMin++;

    DWORD dwFlags = bCase ? FR_MATCHCASE : 0;
    dwFlags |= bWord ? FR_WHOLEWORD : 0;
    dwFlags |= FR_DOWN;

    ft.chrg.cpMax = cchText;

    long index = GetRichEditCtrl().FindText(dwFlags, &ft);

    if (-1 == index && m_lInitialSearchPos > 0)
    {
        //
        // m_lInitialSearchPos pulls double duty as the point at which we
        // started searching and a flag which says if we've wrapped back
        // to the beginning of the text during a search.  If it's negative
        // (biased by the number of characters) then we've already wrapped
        //

        m_lInitialSearchPos = m_lInitialSearchPos - cchText;

        ft.chrg.cpMin = 0;
        ft.chrg.cpMax = cchText;
        index = GetRichEditCtrl().FindText(dwFlags, &ft);
    }

    if (-1 != index && m_lInitialSearchPos < 0)
        if (index >= (m_lInitialSearchPos + cchText) )
            index = -1;

    if (-1 != index)
        GetRichEditCtrl().SetSel(ft.chrgText);

    return (-1 != index);
}

long CRichEdit2View::FindAndSelect(DWORD dwFlags, FINDTEXTEX& ft)
{
    long index = GetRichEditCtrl().FindText(dwFlags, &ft);
    if (index != -1) // i.e. we found something
        GetRichEditCtrl().SetSel(ft.chrgText);
    return index;
}

void CRichEdit2View::TextNotFound(LPCTSTR lpszFind)
{
    ASSERT_VALID(this);
    m_bFirstSearch = TRUE;
    OnTextNotFound(lpszFind);
}

void CRichEdit2View::OnTextNotFound(LPCTSTR)
{
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View diagnostics

#ifdef _DEBUG
void CRichEdit2View::AssertValid() const
{
    CCtrlView::AssertValid();
    ASSERT_VALID(&m_aPageStart);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    if (pEditState->pFindReplaceDlg != NULL)
        ASSERT_VALID(pEditState->pFindReplaceDlg);
}

void CRichEdit2View::Dump(CDumpContext& dc) const
{
    CCtrlView::Dump(dc);
    AFX_DUMP1(dc, "\nm_aPageStart ", &m_aPageStart);
    AFX_DUMP0(dc, "\n Static Member Data:");
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    if (pEditState->pFindReplaceDlg != NULL)
    {
        AFX_DUMP1(dc, "\npFindReplaceDlg = ",
            (void*)pEditState->pFindReplaceDlg);
        AFX_DUMP1(dc, "\nbFindOnly = ", pEditState->bFindOnly);
    }
    AFX_DUMP1(dc, "\nstrFind = ", pEditState->strFind);
    AFX_DUMP1(dc, "\nstrReplace = ", pEditState->strReplace);
    AFX_DUMP1(dc, "\nbCase = ", pEditState->bCase);
    AFX_DUMP1(dc, "\nbWord = ", pEditState->bWord);
    AFX_DUMP1(dc, "\nbNext = ", pEditState->bNext);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

BOOL CRichEdit2View::IsSelected(const CObject* pDocItem) const
{
    return (pDocItem == GetSelectedItem());
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc

CRichEdit2Doc::CRichEdit2Doc()
{
    m_bRTF = TRUE;
    m_bUnicode = FALSE;
    m_bUpdateObjectCache = FALSE;
    ASSERT_VALID(this);
}

CRichEdit2View* CRichEdit2Doc::GetView() const
{
    // find the first view - if there are no views
    // we must return NULL

    POSITION pos = GetFirstViewPosition();
    if (pos == NULL)
        return NULL;

    // find the first view that is a CRichEdit2View

    CView* pView;
    while (pos != NULL)
    {
        pView = GetNextView(pos);
        if (pView->IsKindOf(RUNTIME_CLASS(CRichEdit2View)))
            return (CRichEdit2View*) pView;
    }

    // can't find one--return NULL

    return NULL;
}

BOOL CRichEdit2Doc::IsModified()
{
    return GetView()->GetRichEditCtrl().GetModify();
}

void CRichEdit2Doc::SetModifiedFlag(BOOL bModified)
{
    GetView()->GetRichEditCtrl().SetModify(bModified);
    ASSERT(!!GetView()->GetRichEditCtrl().GetModify() == !!bModified);
}

COleClientItem* CRichEdit2Doc::GetInPlaceActiveItem(CWnd* pWnd)
{
    ASSERT_KINDOF(CRichEdit2View, pWnd);
    CRichEdit2View* pView = (CRichEdit2View*)pWnd;
    return pView->GetInPlaceActiveItem();
}

void CRichEdit2Doc::SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU)
{
    // we call CDocument and not COleServerDoc because we don't want to do the
    // SetHostNames stuff here.  The richedit will do it. And we tell the richedit
    // in SetTitle
    CDocument::SetPathName(lpszPathName, bAddToMRU);
}

void CRichEdit2Doc::SetTitle(LPCTSTR lpszTitle)
{
    USES_CONVERSION;
    COleServerDoc::SetTitle(lpszTitle);
    CRichEdit2View *pView = GetView();
    ASSERT(pView != NULL);
    ASSERT(pView->m_lpRichEditOle != NULL);
    pView->m_lpRichEditOle->SetHostNames(T2CA(AfxGetAppName()),
        T2CA(lpszTitle));
}

CRichEdit2CntrItem* CRichEdit2Doc::LookupItem(LPOLEOBJECT lpobj) const
{
    POSITION pos = COleServerDoc::GetStartPosition();
    CRichEdit2CntrItem* pItem;
    while (pos != NULL)
    {
        pItem = (CRichEdit2CntrItem*) COleServerDoc::GetNextItem(pos);
        // delete item is right type and not under construction
        if (pItem->IsKindOf(RUNTIME_CLASS(CRichEdit2CntrItem)) &&
            pItem->m_lpObject == lpobj)
        {
            return pItem;
        }
    }
    return NULL;
}

CRichEdit2CntrItem* CRichEdit2Doc::CreateClientItem(REOBJECT* preo) const
{
    // cast away constness of this
    return new CRichEdit2CntrItem(preo, (CRichEdit2Doc*)this);
    // a derived class typically needs  to return its own item of a class
    // derived from CRichEdit2CntrItem
}

void CRichEdit2Doc::MarkItemsClear() const
{
    POSITION pos = COleServerDoc::GetStartPosition();
    CRichEdit2CntrItem* pItem;
    while (pos != NULL)
    {
        pItem = (CRichEdit2CntrItem*) COleServerDoc::GetNextItem(pos);
        // Mark item as not in use unless under construction (i.e. m_lpObject == NULL)
        if (pItem->IsKindOf(RUNTIME_CLASS(CRichEdit2CntrItem)))
            pItem->Mark( (pItem->m_lpObject == NULL) ? TRUE : FALSE);
    }
}

void CRichEdit2Doc::DeleteUnmarkedItems() const
{
    POSITION pos = COleServerDoc::GetStartPosition();
    CRichEdit2CntrItem* pItem;
    while (pos != NULL)
    {
        pItem = (CRichEdit2CntrItem*) COleServerDoc::GetNextItem(pos);
        // Mark item as not in use unless under construction (i.e. m_lpObject == NULL)
        if (pItem->IsKindOf(RUNTIME_CLASS(CRichEdit2CntrItem)) && !pItem->IsMarked())
            delete pItem;
    }
}

POSITION CRichEdit2Doc::GetStartPosition() const
{
    if (m_bUpdateObjectCache)
        ((CRichEdit2Doc*)this)->UpdateObjectCache(); //cast away const
    return COleServerDoc::GetStartPosition();
}

void CRichEdit2Doc::UpdateObjectCache()
{
    CRichEdit2View* pView = GetView();
    CRichEdit2CntrItem* pItem;
    if (pView != NULL)
    {
        ASSERT(pView->m_lpRichEditOle != NULL);
        MarkItemsClear();
        long i,nCount = pView->m_lpRichEditOle->GetObjectCount();
        for (i=0;i<nCount;i++)
        {
            CRe2Object reo; // needs to be in here so destructor called to release interfaces
            HRESULT hr = pView->m_lpRichEditOle->GetObject(i, &reo, REO_GETOBJ_ALL_INTERFACES);
            //reo interfaces are UNICODE
            ASSERT(SUCCEEDED(hr));
            if (GetScode(hr) == S_OK)
            {
                pItem = LookupItem(reo.poleobj);
                if (pItem == NULL)
                {
                    pItem = ((CRichEdit2Doc*)this)->CreateClientItem(&reo);
                    pItem->UpdateItemType();
                }
                ASSERT(pItem != NULL);
                pItem->Mark(TRUE);
            }
        }
        DeleteUnmarkedItems();
    }
    m_bUpdateObjectCache = FALSE;
}
/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc Attributes

COleClientItem* CRichEdit2Doc::GetPrimarySelectedItem(CView* pView)
{
    ASSERT(pView->IsKindOf(RUNTIME_CLASS(CRichEdit2View)));
    return ((CRichEdit2View*)pView)->GetSelectedItem();
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc Operations

void CRichEdit2Doc::DeleteContents()
{
    COleServerDoc::DeleteContents();
    CWaitCursor wait;
    CRichEdit2View *pView = GetView();
    if (pView != NULL)
    {
        pView->DeleteContents();
        pView->GetRichEditCtrl().SetModify(FALSE);
        ASSERT(pView->GetRichEditCtrl().GetModify() == FALSE);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc serialization

void CRichEdit2Doc::Serialize(CArchive& ar)
{
    CRichEdit2View *pView = GetView();
    if (pView != NULL)
        pView->Serialize(ar);
    // we don't call the base class COleServerDoc::Serialize
    // because we don't want the client items serialized
    // the client items are handled directly by the RichEdit control
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc diagnostics

#ifdef _DEBUG
void CRichEdit2Doc::AssertValid() const
{
    COleServerDoc::AssertValid();
}

void CRichEdit2Doc::Dump(CDumpContext& dc) const
{
    COleServerDoc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc commands

void CRichEdit2Doc::PreCloseFrame(CFrameWnd* pFrameArg)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pFrameArg);

    // turn off redraw so the user doesn't see the deactivation happening
    BOOL bSetRedraw = FALSE;
    if (pFrameArg->GetStyle() & WS_VISIBLE)
    {
        pFrameArg->SendMessage(WM_SETREDRAW, (WPARAM)FALSE);
        bSetRedraw = TRUE;
    }

    // deactivate any inplace active items on this frame
    GetView()->m_lpRichEditOle->InPlaceDeactivate();

    POSITION pos = GetStartPosition();
    CRichEdit2CntrItem* pItem;
    while (pos != NULL)
    {
        pItem = (CRichEdit2CntrItem*) GetNextClientItem(pos);
        if (pItem == NULL)
            break;
        ASSERT(pItem->IsKindOf(RUNTIME_CLASS(CRichEdit2CntrItem)));
        pItem->Close();
    }

    // turn redraw back on
    if (bSetRedraw)
        pFrameArg->SendMessage(WM_SETREDRAW, (WPARAM)TRUE);
}

void CRichEdit2Doc::UpdateModifiedFlag()
{
    // don't do anything here
    // let the richedit handle all of this
}

COleServerItem* CRichEdit2Doc::OnGetEmbeddedItem()
{
    ASSERT(FALSE);
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2CntrItem implementation

CRichEdit2CntrItem::CRichEdit2CntrItem(REOBJECT *preo, CRichEdit2Doc* pContainer)
    : COleClientItem(pContainer)
{
    m_bMark = FALSE;
    m_bLock = FALSE;
    if (preo != NULL)
    {
        ASSERT(preo->poleobj != NULL);
        ASSERT(preo->pstg != NULL);
        ASSERT(preo->polesite != NULL);
        m_lpObject = preo->poleobj;
        m_lpStorage = preo->pstg;
        m_lpClientSite = preo->polesite;
        m_lpObject->AddRef();
        m_lpStorage->AddRef();
        m_lpClientSite->AddRef();
    }
    else
    {
        m_lpObject = NULL;
        m_lpStorage = NULL;
        m_lpClientSite = NULL;
    }
}

CRichEdit2CntrItem::~CRichEdit2CntrItem()
{
    if (m_lpClientSite != NULL)
        m_lpClientSite->Release();
}

void CRichEdit2CntrItem::OnDeactivateUI(BOOL bUndoable)
{
    CView* pView = GetActiveView();
    if (pView != NULL)
    {
        ASSERT(pView->GetParentFrame() != NULL);
        pView->GetParentFrame()->SendMessage(WM_SETMESSAGESTRING,
            (WPARAM)AFX_IDS_IDLEMESSAGE);
    }
    COleClientItem::OnDeactivateUI(bUndoable);
}

HRESULT CRichEdit2CntrItem::ShowContainerUI(BOOL b)
{
    if (!CanActivate())
        return E_NOTIMPL;
    if (b)
    {
        OnDeactivateUI(FALSE);
        OnDeactivate();
    }
    else
    {
        OnActivate();
        OnActivateUI();
    }
    return S_OK;
}

BOOL CRichEdit2CntrItem::OnChangeItemPosition(const CRect& /*rectPos*/)
{
    ASSERT_VALID(this);

    // richedit handles this
    return FALSE;
}

BOOL CRichEdit2CntrItem::CanActivate()
{
    // Editing in-place while the server itself is being edited in-place
    //  does not work and is not supported.  So, disable in-place
    //  activation in this case.
    COleServerDoc* pDoc = DYNAMIC_DOWNCAST(COleServerDoc, GetDocument());
    if (pDoc != NULL && pDoc->IsInPlaceActive())
        return FALSE;

    // otherwise, rely on default behavior
    return COleClientItem::CanActivate();
}

HRESULT CRichEdit2CntrItem::GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
    LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    CRect rc1,rc2;
    if (!CanActivate())
        return E_NOTIMPL;
    return m_xOleIPSite.GetWindowContext(lplpFrame, lplpDoc, &rc1, &rc2, lpFrameInfo);
}

BOOL CRichEdit2CntrItem::ConvertTo(REFCLSID clsidNew)
{
    USES_CONVERSION;
    LPRICHEDITOLE preole = GetDocument()->GetView()->m_lpRichEditOle;
    LPOLESTR lpOleStr;
    OleRegGetUserType(clsidNew, USERCLASSTYPE_FULL, &lpOleStr);
    LPCTSTR lpsz = OLE2CT(lpOleStr);
    HRESULT hRes = preole->ConvertObject(REO_IOB_SELECTION, clsidNew, T2CA(lpsz));
    CoTaskMemFree(lpOleStr);
    return (SUCCEEDED(hRes));
}

BOOL CRichEdit2CntrItem::ActivateAs(LPCTSTR, REFCLSID clsidOld,
    REFCLSID clsidNew)
{
    LPRICHEDITOLE preole = GetDocument()->GetView()->m_lpRichEditOle;
    HRESULT hRes = preole->ActivateAs(clsidOld, clsidNew);
    return (SUCCEEDED(hRes));
}

void CRichEdit2CntrItem::SetDrawAspect(DVASPECT nDrawAspect)
{
    LPRICHEDITOLE preole = GetDocument()->GetView()->m_lpRichEditOle;
    preole->SetDvaspect(REO_IOB_SELECTION, nDrawAspect);
    COleClientItem::SetDrawAspect(nDrawAspect);
}

void CRichEdit2CntrItem::SyncToRichEditObject(REOBJECT& reo)
{
    COleClientItem::SetDrawAspect((DVASPECT)reo.dvaspect);
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2CntrItem diagnostics

#ifdef _DEBUG
void CRichEdit2CntrItem::AssertValid() const
{
    COleClientItem::AssertValid();
}

void CRichEdit2CntrItem::Dump(CDumpContext& dc) const
{
    COleClientItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////

LPOLECLIENTSITE CRichEdit2CntrItem::GetClientSite()
{
    if (m_lpClientSite == NULL)
    {
        CRichEdit2Doc* pDoc = DYNAMIC_DOWNCAST(CRichEdit2Doc, GetDocument());
        CRichEdit2View* pView = DYNAMIC_DOWNCAST(CRichEdit2View, pDoc->GetView());
        ASSERT(pView->m_lpRichEditOle != NULL);
        HRESULT hr = pView->m_lpRichEditOle->GetClientSite(&m_lpClientSite);
        if (hr != S_OK)
            AfxThrowOleException(hr);
    }
    ASSERT(m_lpClientSite != NULL);
    return m_lpClientSite;
}

/////////////////////////////////////////////////////////////////////////////

#ifndef _AFX_ENABLE_INLINES

static const char _szAfxWinInl[] = "afxrich2.inl";
#undef THIS_FILE
#define THIS_FILE _szAfxWinInl
#define _AFXRICH_INLINE
#include "afxrich2.inl"

#endif //_AFX_ENABLE_INLINES

/////////////////////////////////////////////////////////////////////////////

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_SERIAL(CRichEdit2CntrItem, COleClientItem, 0)
IMPLEMENT_DYNAMIC(CRichEdit2Doc, COleServerDoc)
IMPLEMENT_DYNCREATE(CRichEdit2View, CCtrlView)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\stdafx2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// STDAFX.H is the header that includes the standard includes that are used
//  for most of the project.  These are compiled into a pre-compiled header

// turn off warnings for /W4 (just for MFC implementation)
#ifndef ALL_WARNINGS
#pragma warning(disable: 4073)  // disable warning about using init_seg
#ifdef _MAC
#pragma warning(disable: 4121)  // disable (incorrect?) warning about packing of MachineLocation in OSUtils.h
#endif
#endif

// MFC inline constructors (including compiler generated) can get deep
#pragma inline_depth(16)

// override default values for data import/export when building MFC DLLs
#ifdef _AFX_CORE_IMPL
	#define AFX_CORE_DATA   AFX_DATA_EXPORT
	#define AFX_CORE_DATADEF
#endif

#ifdef _AFX_OLE_IMPL
	#define AFX_OLE_DATA    AFX_DATA_EXPORT
	#define AFX_OLE_DATADEF
#endif

#ifdef _AFX_DB_IMPL
	#define AFX_DB_DATA     AFX_DATA_EXPORT
	#define AFX_DB_DATADEF
#endif

#ifdef _AFX_NET_IMPL
	#define AFX_NET_DATA    AFX_DATA_EXPORT
	#define AFX_NET_DATADEF
#endif

#ifndef _AFX_NOFORCE_LIBS
#define _AFX_NOFORCE_LIBS
#endif

#define _AFX_FULLTYPEINFO
#define VC_EXTRALEAN
#define NO_ANSIUNI_ONLY

// include these first so that protected structures in winwlm.h are declared
#ifdef _MAC
#define SystemSevenOrLater 1
#include <macname1.h>
#include <Types.h>
#include <QuickDraw.h>
#include <AppleEvents.h>
#include <macname2.h>
#endif

// core headers
#include "afx.h"
#include "afxplex_.h"
#include "afxcoll.h"

// public headers
#include "afxwin.h"

//
// MFC 4.2 hardcodes _RICHEDIT_VER to 0x0100 in afxwin.h.  This prevents
// richedit.h from enabling any richedit 2.0 features.
//

#ifdef _RICHEDIT_VER
#if _RICHEDIT_VER < 0x0200
#undef _RICHEDIT_VER
#define _RICHEDIT_VER 0x0200
#endif
#endif

#ifndef _AFX_ENABLE_INLINES
#define _AFX_ENABLE_INLINES
#endif

#define _AFXCMN2_INLINE     inline 
#define _AFXDLGS2_INLINE    inline
#define _AFXRICH2_INLINE    inline

#include "afxdlgs.h"
#include "afxdlgs2.h"
#include "afxext.h"
#ifndef _AFX_NO_OLE_SUPPORT
	#ifndef _OLE2_H_
		#include <ole2.h>
	#endif

#include <winspool.h>

#ifdef _MAC
	// include OLE dialog/helper APIs
	#include <ole2ui.h>
#else
	// include OLE dialog/helper APIs
	#ifndef _OLEDLG_H_
		#include <oledlg.h>
	#endif
#endif

	#include <winreg.h>
		#include "afxcom_.h"
//	#include "oleimpl.h"
	#include "afxole.h"
#ifndef _MAC
	#include "afxdocob.h"
#endif

#ifndef _AFX_NO_DAO_SUPPORT
	#include "afxdao.h"
#endif

	#include "afxodlgs.h"
#endif

#ifndef _AFX_NO_OCX_SUPPORT
	#include "afxctl.h"
#endif
#ifndef _AFX_NO_DB_SUPPORT
	#include "afxdb.h"
#endif
#ifndef _AFX_NO_SYNC_SUPPORT
	#include "afxmt.h"
#endif
#ifndef _AFX_NO_INET_SUPPORT
	#include "afxinet.h"
#endif

// private headers as well
#include "afxpriv.h"
#include "afximpl2.h"
//#include "winhand_.h"
#ifndef _AFX_NO_OLE_SUPPORT
	#include "oleimpl3.h"
#endif
#ifndef _AFX_NO_OCX_SUPPORT
//	#include "ctlimpl.h"
#endif
#ifndef _AFX_NO_DB_SUPPORT
//	#include "dbimpl.h"
#endif
#ifndef _AFX_NO_DAO_SUPPORT
//	#include "daoimpl.h"
#endif
#ifndef _AFX_NO_SOCKET_SUPPORT
	#ifndef _WINSOCKAPI_
//		#include <winsock.h>
	#endif
//	#include "sockimpl.h"
//	#include "afxsock.h"
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
//	#include "commimpl.h"
	#include "afxcmn.h"
	#include "afxcview.h"
#endif
	#include "afxrich2.h"

#include <winreg.h>
#include <winnls.h>
#include <stddef.h>
#include <limits.h>
#include <malloc.h>
#include <new.h>
#ifndef _AFX_OLD_EXCEPTIONS
#include <eh.h>     // for set_terminate
#endif

#undef AfxWndProc

// implementation uses _AFX_PACKING as well
#ifdef _AFX_PACKING
#ifndef ALL_WARNINGS
#pragma warning(disable: 4103)
#endif
#pragma pack(_AFX_PACKING)
#endif

// special exception handling just for MFC library implementation
#ifndef _AFX_OLD_EXCEPTIONS

// MFC does not rely on auto-delete semantics of the TRY..CATCH macros,
//  therefore those macros are mapped to something closer to the native
//  C++ exception handling mechanism when building MFC itself.

#undef TRY
#define TRY { try {

#undef CATCH
#define CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); UNUSED(e);

#undef AND_CATCH
#define AND_CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); UNUSED(e);

#undef CATCH_ALL
#define CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); UNUSED(e);

#undef AND_CATCH_ALL
#define AND_CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); UNUSED(e);

#undef END_TRY
#define END_TRY } catch (CException* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); e->Delete(); } }

#undef THROW_LAST
#define THROW_LAST() throw

// Because of the above definitions of TRY...CATCH it is necessary to
//  explicitly delete exception objects at the catch site.

#define DELETE_EXCEPTION(e) do { e->Delete(); } while (0)
#define NO_CPP_EXCEPTION(expr)

#else   //!_AFX_OLD_EXCEPTIONS

// In this case, the TRY..CATCH macros provide auto-delete semantics, so
//  it is not necessary to explicitly delete exception objects at the catch site.

#define DELETE_EXCEPTION(e)
#define NO_CPP_EXCEPTION(expr) expr

#endif  //_AFX_OLD_EXCEPTIONS


#include <afxcmn2.h>
#include <afxrich2.h>

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\unitspag.cpp ===
// unitspag.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "unitspag.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CUnitsPage dialog

const DWORD CUnitsPage::m_nHelpIDs[] = 
{
	IDC_BOX, (DWORD) -1,
	IDC_UNITS_IN, IDH_WORDPAD_INCHES,
	IDC_UNITS_CM, IDH_WORDPAD_CENTIMETERS,
	IDC_UNITS_PT, IDH_WORDPAD_POINTS,
	IDC_UNITS_PI, IDH_WORDPAD_PICAS,
	IDC_WORDSEL, IDH_WORDPAD_OPTIONS_AUTOWORDSEL,
 	0, 0
};

CUnitsPage::CUnitsPage() : CCSPropertyPage(CUnitsPage::IDD)
{
	//{{AFX_DATA_INIT(CUnitsPage)
	m_nUnits = -1;
	m_bWordSel = FALSE;
	//}}AFX_DATA_INIT
}


void CUnitsPage::DoDataExchange(CDataExchange* pDX)
{
	CCSPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CUnitsPage)
	DDX_Radio(pDX, IDC_UNITS_IN, m_nUnits);
	DDX_Check(pDX, IDC_WORDSEL, m_bWordSel);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CUnitsPage, CCSPropertyPage)
	//{{AFX_MSG_MAP(CUnitsPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CUnitsPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\strings.h ===
// strings.h : defines all extern const strings
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

extern const TCHAR szWordPadClass[];
extern const TCHAR szLayout1[];
extern const TCHAR szLayout2[];
extern const TCHAR szRegKey[];

extern const TCHAR szTextSection[];
extern const TCHAR szRTFSection[];
extern const TCHAR szWordSection[];
extern const TCHAR szWriteSection[];
extern const TCHAR szIPSection[];
extern const TCHAR szWrap[];
extern const TCHAR szPageMargin[];

extern const TCHAR szSection[];
extern const TCHAR szWordSel[];
extern const TCHAR szUnits[];
extern const TCHAR szFrameRect[];
extern const TCHAR szMaximized[];
extern const TCHAR szDeleteTemp[];

extern const TCHAR szSumInfo[];
extern const TCHAR szContents[];

extern TCHAR szWordConverter[];
extern TCHAR szWriteConverter[];
extern TCHAR szWord97Converter[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\winctrl4.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include "stdafx2.h"

#ifdef AFX_CMNCTL_SEG
#pragma code_seg(AFX_CMNCTL_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// _AFX_RICHEDIT2_STATE

_AFX_RICHEDIT2_STATE::~_AFX_RICHEDIT2_STATE()
{
	if (m_hInstRichEdit != NULL)
#ifndef _MAC
		::FreeLibrary(m_hInstRichEdit);
#else
		REFreeLibrary(m_hInstRichEdit);
#endif
}

_AFX_RICHEDIT2_STATE* AFX_CDECL AfxGetRichEdit2State()
{
	return _afxRichEdit2State.GetData();
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2

BOOL CRichEdit2Ctrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	_AFX_RICHEDIT2_STATE* pState = _afxRichEdit2State;
	if (pState->m_hInstRichEdit == NULL)
	{
#ifndef _MAC
		pState->m_hInstRichEdit = LoadLibraryA("RICHED20.DLL");
#else
#ifndef _AFXDLL
		// Ordinarily the __gForceREInit reference would be produced by richedit.h, but
		// MFC builds with _WLM_NOFORCE_LIBS, which prevents richedit.h from generating
		// the reference.
		pState->m_hInstRichEdit = ((HINSTANCE)__gForceREInit), RELoadLibrary();
#else
		pState->m_hInstRichEdit = RELoadLibrary();
#endif
#endif
		if (pState->m_hInstRichEdit == NULL)
			return FALSE;
	}

	CWnd* pWnd = this;

	return pWnd->Create(_T("RICHEDIT"), NULL, dwStyle, rect, pParentWnd, nID);
}

int CRichEdit2Ctrl::GetLine(int nIndex, LPTSTR lpszBuffer) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex,
		(LPARAM)lpszBuffer);
}

int CRichEdit2Ctrl::LineIndex(int nLine /* = -1 */) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0);
}

int CRichEdit2Ctrl::LineLength(int nLine /* = -1 */) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0);
}

void CRichEdit2Ctrl::LineScroll(int nLines, int nChars /* = 0 */)
{
	ASSERT(::IsWindow(m_hWnd));
	::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines);
}

void CRichEdit2Ctrl::SetSel(long nStartChar, long nEndChar)
{
	ASSERT(::IsWindow(m_hWnd));
	CHARRANGE cr;
	cr.cpMin = nStartChar;
	cr.cpMax = nEndChar;
	::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr);
}

BOOL CRichEdit2Ctrl::CanPaste(UINT nFormat) const
{
	ASSERT(::IsWindow(m_hWnd));
	COleMessageFilter* pFilter = AfxOleGetMessageFilter();
	if (pFilter != NULL)
		pFilter->BeginBusyState();
	BOOL b = (BOOL)::SendMessage(m_hWnd, EM_CANPASTE, nFormat, 0L);
	if (pFilter != NULL)
		pFilter->EndBusyState();
	return b;
}

void CRichEdit2Ctrl::PasteSpecial(UINT nClipFormat, DWORD dvAspect, HMETAFILE hMF)
{
	ASSERT(::IsWindow(m_hWnd));
	REPASTESPECIAL reps;
	reps.dwAspect = dvAspect;
	reps.dwParam = (DWORD_PTR)hMF;
	::SendMessage(m_hWnd, EM_PASTESPECIAL, nClipFormat, (LPARAM)&reps);
}

int CRichEdit2Ctrl::GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const
{
	ASSERT(::IsWindow(m_hWnd));
	*(LPINT)lpszBuffer = nMaxLength;
	return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
}

void CRichEdit2Ctrl::GetSel(long& nStartChar, long& nEndChar) const
{
	ASSERT(::IsWindow(m_hWnd));
	CHARRANGE cr;
	::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
	nStartChar = cr.cpMin;
	nEndChar = cr.cpMax;
}

CString CRichEdit2Ctrl::GetSelText() const
{
	ASSERT(::IsWindow(m_hWnd));

	CHARRANGE cr;
    LPTSTR    lpsz;

	cr.cpMin = cr.cpMax = 0;
	::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);

    try
    {
        // Need to use sizeof(WCHAR) to include DBCS characters
	    lpsz = (TCHAR*)_alloca((cr.cpMax - cr.cpMin + 1)*sizeof(WCHAR));

        // lpsz[0] = NULL;

        //
        // APPCOMPAT: The Ansi richedit2 control does not zero terminate the
        //         returned string if the current selection contains nothing
        //         but DBCS characters.
        //

        ZeroMemory(lpsz, (cr.cpMax - cr.cpMin + 1)*sizeof(WCHAR));

	    ::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpsz);
    }
    catch(...)
    {
        //
        // If _alloca fails it will throw an exception.  It's ok to return a
        // constant string here because it will immediately get copied into
        // a CString.
        //

        ASSERT(!"Out of stack space");

        lpsz = TEXT("");
    }

	return lpsz;
}

IRichEditOle* CRichEdit2Ctrl::GetIRichEditOle() const
{
	ASSERT(::IsWindow(m_hWnd));
	IRichEditOle *pRichItem = NULL;
	::SendMessage(m_hWnd, EM_GETOLEINTERFACE, 0, (LPARAM)&pRichItem);
	return pRichItem;
}

BOOL CRichEdit2Ctrl::SetDefaultCharFormat(CHARFORMAT &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
}

BOOL CRichEdit2Ctrl::SetSelectionCharFormat(CHARFORMAT &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
}

BOOL CRichEdit2Ctrl::SetWordCharFormat(CHARFORMAT &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION|SCF_WORD, (LPARAM)&cf);
}

DWORD CRichEdit2Ctrl::GetDefaultCharFormat(CHARFORMAT &cf) const
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 0, (LPARAM)&cf);
}

DWORD CRichEdit2Ctrl::GetSelectionCharFormat(CHARFORMAT &cf) const
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 1, (LPARAM)&cf);
}

DWORD CRichEdit2Ctrl::GetParaFormat(PARAFORMAT &pf) const
{
	ASSERT(::IsWindow(m_hWnd));
	pf.cbSize = sizeof(PARAFORMAT);
	return (DWORD)::SendMessage(m_hWnd, EM_GETPARAFORMAT, 0, (LPARAM)&pf);
}

BOOL CRichEdit2Ctrl::SetParaFormat(PARAFORMAT &pf)
{
	ASSERT(::IsWindow(m_hWnd));
	pf.cbSize = sizeof(PARAFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETPARAFORMAT, 0, (LPARAM)&pf);
}

/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable: 4074)
#pragma init_seg(lib)

PROCESS_LOCAL(_AFX_RICHEDIT2_STATE, _afxRichEdit2State)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\wordpdoc.cpp ===
// wordpdoc.cpp : implementation of the CWordPadDoc class
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

#include "stdafx.h"

#include "wordpad.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "cntritem.h"
#include "srvritem.h"
#include "formatba.h"

#include "mainfrm.h"
#include "ipframe.h"
#include "buttondi.h"
#include "helpids.h"
#include "strings.h"
#include "unitspag.h"
#include "docopt.h"
#include "optionsh.h"

#include "multconv.h"

#include "fixhelp.h"

BOOL AskAboutFormatLoss(CWordPadDoc *pDoc) ;

//
// These defines are from ..\shell\userpri\uconvert.h
//

#define REVERSE_BYTE_ORDER_MARK   0xFFFE
#define BYTE_ORDER_MARK           0xFEFF

BOOL CheckForUnicodeTextFile(LPCTSTR lpszPathName) ;


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern BOOL AFXAPI AfxFullPath(LPTSTR lpszPathOut, LPCTSTR lpszFileIn);
extern UINT AFXAPI AfxGetFileTitle(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);

#ifndef OFN_EXPLORER
#define OFN_EXPLORER 0x00080000L
#endif


//
// This small class implements the "This is an unsupported save format" dialog.
// It's main purpose is to provide a place to hang the "always convert to RTF"
// checkbox.
//

class UnsupportedSaveFormatDialog : public CDialog
{
public:

    UnsupportedSaveFormatDialog()
        : CDialog(TEXT("UnsupportedSaveFormatDialog")),
          m_always_convert_to_rtf(false)
    {
    }

    BOOL ShouldAlwaysConvertToRTF() {return m_always_convert_to_rtf;}

protected:

    BOOL    m_always_convert_to_rtf;

    void DoDataExchange(CDataExchange *pDX)
    {
        CDialog::DoDataExchange(pDX);
        DDX_Check(pDX, IDC_ALWAYS_RTF, m_always_convert_to_rtf);
    }
};



/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc
IMPLEMENT_DYNCREATE(CWordPadDoc, CRichEdit2Doc)

BEGIN_MESSAGE_MAP(CWordPadDoc, CRichEdit2Doc)
    //{{AFX_MSG_MAP(CWordPadDoc)
    ON_COMMAND(ID_VIEW_OPTIONS, OnViewOptions)
    ON_UPDATE_COMMAND_UI(ID_OLE_VERB_POPUP, OnUpdateOleVerbPopup)
    ON_COMMAND(ID_FILE_SEND_MAIL, OnFileSendMail)
    ON_UPDATE_COMMAND_UI(ID_FILE_NEW, OnUpdateIfEmbedded)
    ON_UPDATE_COMMAND_UI(ID_FILE_OPEN, OnUpdateIfEmbedded)
    ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateIfEmbedded)
    ON_UPDATE_COMMAND_UI(ID_FILE_PRINT, OnUpdateIfEmbedded)
    ON_UPDATE_COMMAND_UI(ID_FILE_PRINT_DIRECT, OnUpdateIfEmbedded)
    ON_UPDATE_COMMAND_UI(ID_FILE_PRINT_PREVIEW, OnUpdateIfEmbedded)
    //}}AFX_MSG_MAP
    ON_UPDATE_COMMAND_UI(ID_FILE_SEND_MAIL, OnUpdateFileSendMail)
    ON_COMMAND(ID_OLE_EDIT_LINKS, OnEditLinks)
    ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, CRichEdit2Doc::OnUpdateObjectVerbMenu)
    ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, CRichEdit2Doc::OnUpdateObjectVerbMenu)
    ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, CRichEdit2Doc::OnUpdateEditLinksMenu)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc construction/destruction

CWordPadDoc::CWordPadDoc()
{
    m_nDocType = -1;
    m_nNewDocType = -1;
    m_short_filename = NULL;
}

BOOL CWordPadDoc::OnNewDocument()
{
    if (!CRichEdit2Doc::OnNewDocument())
        return FALSE;

    //correct type already set in theApp.m_nNewDocType;
    int nDocType = (IsEmbedded()) ? RD_EMBEDDED : theApp.m_nNewDocType;

    GetView()->SetDefaultFont(IsTextType(nDocType));
    SetDocType(nDocType);

    return TRUE;
}

void CWordPadDoc::ReportSaveLoadException(LPCTSTR lpszPathName,
    CException* e, BOOL bSaving, UINT nIDP)
{
    if (!m_bDeferErrors && e != NULL)
    {
        ASSERT_VALID(e);
        if (e->IsKindOf(RUNTIME_CLASS(CFileException)))
        {
            switch (((CFileException*)e)->m_cause)
            {
            case CFileException::fileNotFound:
            case CFileException::badPath:
                nIDP = AFX_IDP_FAILED_INVALID_PATH;
                break;
            case CFileException::diskFull:
                nIDP = AFX_IDP_FAILED_DISK_FULL;
                break;
            case CFileException::accessDenied:
                nIDP = AFX_IDP_FILE_ACCESS_DENIED;

                if (((CFileException*)e)->m_lOsError == ERROR_WRITE_PROTECT)
                    nIDP = IDS_WRITEPROTECT;
                break;
            case CFileException::tooManyOpenFiles:
                nIDP = IDS_TOOMANYFILES;
                break;
            case CFileException::directoryFull:
                nIDP = IDS_DIRFULL;
                break;
            case CFileException::sharingViolation:
                nIDP = IDS_SHAREVIOLATION;
                break;
            case CFileException::lockViolation:
            case CFileException::badSeek:
            case CFileException::generic:
            case CFileException::invalidFile:
            case CFileException::hardIO:
                nIDP = bSaving ? AFX_IDP_FAILED_IO_ERROR_WRITE :
                        AFX_IDP_FAILED_IO_ERROR_READ;
                break;
            default:
                break;
            }
            CString prompt;
            AfxFormatString1(prompt, nIDP, lpszPathName);
            AfxMessageBox(prompt, MB_ICONEXCLAMATION, nIDP);
            return;
        }
    }
    CRichEdit2Doc::ReportSaveLoadException(lpszPathName, e, bSaving, nIDP);
    return;
}


BOOL CheckForUnicodeTextFile(LPCTSTR lpszPathName)
{
    BOOL fRet = FALSE ;
    HANDLE hFile = (HANDLE) 0 ;
    WORD wBOM ;
    DWORD dwBytesRead = 0 ;
    BOOL bTmp ;

    if (lpszPathName == NULL)
    {
       return FALSE ;
    }

    hFile = CreateFile(
                lpszPathName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL) ;

    if (hFile == INVALID_HANDLE_VALUE)
    {
       return FALSE ;
    }

    bTmp = ReadFile(
               hFile,
               &wBOM,
               sizeof(WORD),
               &dwBytesRead,
               NULL) ;

    if (bTmp)
    {
        if (dwBytesRead == sizeof(WORD))
        {
            if ( (wBOM == BYTE_ORDER_MARK) ||
                 (wBOM == REVERSE_BYTE_ORDER_MARK) )
            {
                fRet = TRUE ;

            }
        }
    }

    CloseHandle(hFile) ;

    return fRet ;
}

BOOL CWordPadDoc::OnOpenDocument2(LPCTSTR lpszPathName, bool defaultToText)
{
    if (m_lpRootStg != NULL) // we are embedded
    {
        // we really want to use the converter on this storage
        m_nNewDocType = RD_EMBEDDED;
    }
    else
    {
        if (theApp.cmdInfo.m_bForceTextMode)
            m_nNewDocType = RD_TEXT;
        else
        {
            CFileException fe;
            m_nNewDocType = GetDocTypeFromName(lpszPathName, fe, defaultToText);
            if (m_nNewDocType == -1)
            {
                if (defaultToText)
                {
                    ReportSaveLoadException(lpszPathName, &fe, FALSE,
                        AFX_IDP_FAILED_TO_OPEN_DOC);
                }
                return FALSE;
            }

            if (RD_FEWINWORD5 == m_nNewDocType)
            {
                AfxMessageBox(IDS_FEWINWORD5_DOC, MB_OK, MB_ICONINFORMATION);
                return FALSE;
            }

            if (m_nNewDocType == RD_TEXT && theApp.m_bForceOEM)
                m_nNewDocType = RD_OEMTEXT;
        }
        ScanForConverters();
        if (!doctypes[m_nNewDocType].bRead)
        {
            CString str;
            CString strName = doctypes[m_nNewDocType].GetString(DOCTYPE_DOCTYPE);
            AfxFormatString1(str, IDS_CANT_LOAD, strName);
            AfxMessageBox(str, MB_OK|MB_ICONINFORMATION);
            return FALSE;
        }
    }

    if (RD_TEXT == m_nNewDocType)
    {
        if (CheckForUnicodeTextFile(lpszPathName))
            m_nNewDocType = RD_UNICODETEXT;
    }

    if (!CRichEdit2Doc::OnOpenDocument(lpszPathName))
        return FALSE;

    // Update any Ole links

    COleUpdateDialog(this).DoModal();

    return TRUE;
}

BOOL CWordPadDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
    if (OnOpenDocument2(lpszPathName, NO_DEFAULT_TO_TEXT))
    {
        delete [] m_short_filename;
        m_short_filename = NULL;
        return TRUE;
    }

    LPTSTR short_filename = new TCHAR[MAX_PATH];

    if (NULL == short_filename)
        AfxThrowMemoryException();

    if (0 == ::GetShortPathName(lpszPathName, short_filename, MAX_PATH))
    {
        delete [] short_filename;

        if (ERROR_FILE_NOT_FOUND == GetLastError())
        {
            CFileException fe(CFileException::fileNotFound);
            ReportSaveLoadException(lpszPathName, &fe, FALSE,
                                    AFX_IDP_FAILED_TO_OPEN_DOC);
            return FALSE;
        }

        AfxThrowFileException(
                    CFileException::generic, 
                    GetLastError(), 
                    lpszPathName);
    }

    if (OnOpenDocument2(short_filename))
    {
        delete [] m_short_filename;
        m_short_filename = short_filename;
        return TRUE;
    }

    delete [] short_filename;

    return FALSE;
}

void CWordPadDoc::Serialize(CArchive& ar)
{
    COleMessageFilter* pFilter = AfxOleGetMessageFilter();
    ASSERT(pFilter != NULL);
    pFilter->EnableBusyDialog(FALSE);

    if (ar.IsLoading())
        SetDocType(m_nNewDocType);

    //
    // Strip (or output) the byte order mark if this is a Unicode file
    //

    if (m_bUnicode)
    {
        if (ar.IsLoading())
        {
            WORD byte_order_mark;

            ar >> byte_order_mark;

            // No support for byte-reversed files

            ASSERT(BYTE_ORDER_MARK == byte_order_mark);
        }
        else
        {
            ar << (WORD) BYTE_ORDER_MARK;
        }
    }

    CRichEdit2Doc::Serialize(ar);
    pFilter->EnableBusyDialog(TRUE);
}



BOOL AskAboutFormatLoss(CWordPadDoc *pDoc)
{
    UNREFERENCED_PARAMETER(pDoc);
    return (IDYES == AfxMessageBox(IDS_SAVE_FORMAT_TEXT, MB_YESNO));
}

BOOL CWordPadDoc::DoSave(LPCTSTR pszPathName, BOOL bReplace /*=TRUE*/)
    // Save the document data to a file
    // pszPathName = path name where to save document file
    // if pszPathName is NULL then the user will be prompted (SaveAs)
    // note: pszPathName can be different than 'm_strPathName'
    // if 'bReplace' is TRUE will change file name if successful (SaveAs)
    // if 'bReplace' is FALSE will not change path name (SaveCopyAs)
{
    if (NULL != pszPathName)
        if (pszPathName == m_strPathName && NULL != m_short_filename)
            pszPathName = m_short_filename;   

    CString newName = pszPathName;
    int nOrigDocType = m_nDocType;  //saved in case of SaveCopyAs or failure
    int nDocType ;

    //  newName     bWrite  type    result
    //  empty       TRUE    -       SaveAs dialog
    //  empty       FALSE   -       SaveAs dialog
    //  notempty    TRUE    -       nothing
    //  notempty    FALSE   W6      warn (change to wordpad, save as, cancel)
    //  notempty    FALSE   other   warn (save as, cancel)

    BOOL bModified = IsModified();

    ScanForConverters();

    BOOL bSaveAs = FALSE;

    if (newName.IsEmpty())
    {
        bSaveAs = TRUE;
    }
    else if (!doctypes[m_nDocType].bWrite)
    {
        if (!theApp.ShouldAlwaysConvertToRTF())
        {
            UnsupportedSaveFormatDialog dialog;
        
            if (IDOK != dialog.DoModal())
                return FALSE;

            if (dialog.ShouldAlwaysConvertToRTF())
                theApp.SetAlwaysConvertToRTF();
        }

        m_nDocType = RD_RICHTEXT;
    }

    if (m_lpRootStg == NULL && IsTextType(m_nDocType) &&
        !bSaveAs && !GetView()->IsFormatText())
    {
        if (!AskAboutFormatLoss(this))
            bSaveAs = TRUE;
    }

    GetView()->GetParentFrame()->RecalcLayout();

    if (bSaveAs)
    {
      newName = m_strPathName;

        if (bReplace && newName.IsEmpty())
        {
            newName = m_strTitle;
            int iBad = newName.FindOneOf(_T(" #%;/\\"));    // dubious filename
            if (iBad != -1)
                newName.ReleaseBuffer(iBad);

            // append the default suffix if there is one
            newName += GetExtFromType(m_nDocType);
        }

        nDocType = m_nDocType;

promptloop:

        if (!theApp.PromptForFileName(newName,
            bReplace ? AFX_IDS_SAVEFILE : AFX_IDS_SAVEFILECOPY,
            OFN_HIDEREADONLY | OFN_PATHMUSTEXIST, FALSE, &nDocType))
        {
            SetDocType(nOrigDocType, TRUE);
            return FALSE;       // don't even try to save
        }
      else
      {
          //
          // If we are transitioning from non-text to text, we need
          // to warn the user if there is any formatting / graphics
          // that will be lost
          //

          if (IsTextType(nDocType))
          {
              if (m_lpRootStg == NULL && !GetView()->IsFormatText())
              {
                if (!AskAboutFormatLoss(this))
                    goto promptloop;
              }
          }
      }

        SetDocType(nDocType, TRUE);
    }

    BeginWaitCursor();

    if (!OnSaveDocument(newName))
    {
        //
        // The original code deleted the file if an error occurred, on the
        // assumption that if we tried to save a file and something went wrong
        // but there was a file there after the save, the file is probably
        // bogus.  This fails if there is an existing file that doesn't have
        // write access but does have delete access.  How can this happen?
        // The security UI does not remove delete access when you remove
        // write access.
        //

        // restore orginal document type
        SetDocType(nOrigDocType, TRUE);
        EndWaitCursor();
        return FALSE;
    }

    EndWaitCursor();
    if (bReplace)
    {
        int nType = m_nDocType;
        SetDocType(nOrigDocType, TRUE);
        SetDocType(nType);
        // Reset the title and change the document name
        if (NULL == m_short_filename 
            || 0 != newName.CompareNoCase(m_short_filename))
        {
            SetPathName(newName, TRUE);

            // If we saved to a new filename, reset the short name
            if (bSaveAs)
            {
                delete [] m_short_filename;
                m_short_filename = NULL;
            }
        }
    }
    else // SaveCopyAs
    {
        SetDocType(nOrigDocType, TRUE);
        SetModifiedFlag(bModified);
    }
    return TRUE;        // success
}


class COIPF : public COleIPFrameWnd
{
public:
    CFrameWnd* GetMainFrame() { return m_pMainFrame;}
    CFrameWnd* GetDocFrame() { return m_pDocFrame;}
};

void CWordPadDoc::OnDeactivateUI(BOOL bUndoable)
{
    if (GetView()->m_bDelayUpdateItems)
        UpdateAllItems(NULL);
    SaveState(m_nDocType);
    CRichEdit2Doc::OnDeactivateUI(bUndoable);
    COIPF* pFrame = (COIPF*)m_pInPlaceFrame;
    if (pFrame != NULL)
    {
        if (pFrame->GetMainFrame() != NULL)
            ForceDelayed(pFrame->GetMainFrame());
        if (pFrame->GetDocFrame() != NULL)
            ForceDelayed(pFrame->GetDocFrame());
    }
}

void CWordPadDoc::ForceDelayed(CFrameWnd* pFrameWnd)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pFrameWnd);

    POSITION pos = pFrameWnd->m_listControlBars.GetHeadPosition();
    while (pos != NULL)
    {
        // show/hide the next control bar
        CControlBar* pBar =
            (CControlBar*)pFrameWnd->m_listControlBars.GetNext(pos);

        BOOL bVis = pBar->GetStyle() & WS_VISIBLE;
        UINT swpFlags = 0;
        if ((pBar->m_nStateFlags & CControlBar::delayHide) && bVis)
            swpFlags = SWP_HIDEWINDOW;
        else if ((pBar->m_nStateFlags & CControlBar::delayShow) && !bVis)
            swpFlags = SWP_SHOWWINDOW;
        pBar->m_nStateFlags &= ~(CControlBar::delayShow|CControlBar::delayHide);
        if (swpFlags != 0)
        {
            pBar->SetWindowPos(NULL, 0, 0, 0, 0, swpFlags|
                SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc Attributes
CLSID CWordPadDoc::GetClassID()
{
    return (m_pFactory == NULL) ? CLSID_NULL : m_pFactory->GetClassID();
}

void CWordPadDoc::SetDocType(int nNewDocType, BOOL bNoOptionChange)
{
    ASSERT(nNewDocType != -1);
    if (nNewDocType == m_nDocType)
        return;

    m_bRTF = !IsTextType(nNewDocType);
    m_bUnicode = (nNewDocType == RD_UNICODETEXT);

    if (bNoOptionChange)
        m_nDocType = nNewDocType;
    else
    {
        SaveState(m_nDocType);
        m_nDocType = nNewDocType;
        RestoreState(m_nDocType);
    }
}

CWordPadView* CWordPadDoc::GetView()
{
    POSITION pos = GetFirstViewPosition();
    return (CWordPadView* )GetNextView( pos );
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc Operations

CFile* CWordPadDoc::GetFile(LPCTSTR pszPathName, UINT nOpenFlags, CFileException* pException)
{
    CTrackFile* pFile = NULL;
    CFrameWnd* pWnd = GetView()->GetParentFrame();
#ifdef CONVERTERS
    ScanForConverters();

    // if writing use current doc type otherwise use new doc type
    int nType = (nOpenFlags & CFile::modeReadWrite) ? m_nDocType : m_nNewDocType;
    // m_nNewDocType will be same as m_nDocType except when opening a new file
    if (doctypes[nType].pszConverterName != NULL)
        pFile = new CConverter(doctypes[nType].pszConverterName, pWnd);
    else
#endif
    if (nType == RD_OEMTEXT)
        pFile = new COEMFile(pWnd);
    else
        pFile = new CTrackFile(pWnd);
    if (!pFile->Open(pszPathName, nOpenFlags, pException))
    {
        delete pFile;
        return NULL;
    }
    if (nOpenFlags & (CFile::modeWrite | CFile::modeReadWrite))
        pFile->m_dwLength = 0; // can't estimate this
    else
        pFile->m_dwLength = pFile->GetLength();
    return pFile;
}

CRichEdit2CntrItem* CWordPadDoc::CreateClientItem(REOBJECT* preo) const
{
    // cast away constness of this
    return new CWordPadCntrItem(preo, (CWordPadDoc*)this);
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc server implementation

COleServerItem* CWordPadDoc::OnGetEmbeddedItem()
{
    // OnGetEmbeddedItem is called by the framework to get the COleServerItem
    //  that is associated with the document.  It is only called when necessary.

    CEmbeddedItem* pItem = new CEmbeddedItem(this);
    ASSERT_VALID(pItem);
    return pItem;
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc serialization

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc diagnostics

#ifdef _DEBUG
void CWordPadDoc::AssertValid() const
{
    CRichEdit2Doc::AssertValid();
}

void CWordPadDoc::Dump(CDumpContext& dc) const
{
    CRichEdit2Doc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc commands

int CWordPadDoc::MapType(int nType)
{
    if (nType == RD_OEMTEXT || nType == RD_UNICODETEXT)
        nType = RD_TEXT;
    else if (!IsInPlaceActive() && nType == RD_EMBEDDED)
        nType = RD_RICHTEXT;
    return nType;
}

void CWordPadDoc::OnViewOptions()
{
    int nType = MapType(m_nDocType);
    int nFirstPage = 3;
    if (nType == RD_TEXT)
        nFirstPage = 1;
    else if (nType == RD_RICHTEXT)
        nFirstPage = 2;
    else if (nType == RD_WRITE)
        nFirstPage = 4;
    else if (nType == RD_EMBEDDED)
        nFirstPage = 5;

    SaveState(nType);

    COptionSheet sheet(IDS_OPTIONS, NULL, nFirstPage);

    if (sheet.DoModal() == IDOK)
    {
        CWordPadView* pView = GetView();
        if (theApp.m_bWordSel)
            pView->GetRichEditCtrl().SetOptions(ECOOP_OR, ECO_AUTOWORDSELECTION);
        else
        {
            pView->GetRichEditCtrl().SetOptions(ECOOP_AND,
                ~(DWORD)ECO_AUTOWORDSELECTION);
        }
        RestoreState(nType);
    }
}

void CWordPadDoc::OnUpdateOleVerbPopup(CCmdUI* pCmdUI)
{
    pCmdUI->m_pParentMenu = pCmdUI->m_pMenu;
    CRichEdit2Doc::OnUpdateObjectVerbMenu(pCmdUI);
}

BOOL CWordPadDoc::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
    if (nCode == CN_COMMAND && nID == ID_OLE_VERB_POPUP)
        nID = ID_OLE_VERB_FIRST;    
    return CRichEdit2Doc::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

void CWordPadDoc::SaveState(int nType)
{
    if (nType == -1)
        return;
    nType = MapType(nType);
    CWordPadView* pView = GetView();
    if (pView != NULL)
    {
        CFrameWnd* pFrame = pView->GetParentFrame();
        ASSERT(pFrame != NULL);
        // save current state
        pFrame->SendMessage(WPM_BARSTATE, 0, nType);
        theApp.GetDocOptions(nType).m_nWordWrap = pView->m_nWordWrap;
    }
}

void CWordPadDoc::RestoreState(int nType)
{
    if (nType == -1)
        return;
    nType = MapType(nType);
    CWordPadView* pView = GetView();
    if (pView != NULL)
    {
        CFrameWnd* pFrame = pView->GetParentFrame();
        ASSERT(pFrame != NULL);
        // set new state
        pFrame->SendMessage(WPM_BARSTATE, 1, nType);
        int nWrapNew = theApp.GetDocOptions(nType).m_nWordWrap;
        if (pView->m_nWordWrap != nWrapNew)
        {
            pView->m_nWordWrap = nWrapNew;
            pView->WrapChanged();
        }
    }
}

void CWordPadDoc::OnCloseDocument()
{
    SaveState(m_nDocType);
    CRichEdit2Doc::OnCloseDocument();
}

void CWordPadDoc::PreCloseFrame(CFrameWnd* pFrameArg)
{
    CRichEdit2Doc::PreCloseFrame(pFrameArg);
    SaveState(m_nDocType);
}

void CWordPadDoc::OnFileSendMail()
{
    if (m_strTitle.Find('.') == -1)
    {
        // add the extension because the default extension will be wrong
        CString strOldTitle = m_strTitle;
        m_strTitle += GetExtFromType(m_nDocType);
        CRichEdit2Doc::OnFileSendMail();
        m_strTitle = strOldTitle;
    }
    else
        CRichEdit2Doc::OnFileSendMail();
}

void CWordPadDoc::OnUpdateIfEmbedded(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(!IsEmbedded());
}


void CWordPadDoc::OnEditLinks()
{
    g_fDisableStandardHelp = TRUE ;

    SetHelpFixHook() ;

    COleLinksDialog dlg(this, GetRoutingView_());
    dlg.m_el.dwFlags |= ELF_DISABLECANCELLINK;
    dlg.DoModal();

    RemoveHelpFixHook() ;

    g_fDisableStandardHelp = FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\wordpad.h ===
// wordpad.h : main header file for the WORDPAD application
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "options.h"
#include "afxtempl.h"
#include "msctf.h"

#define WPM_BARSTATE WM_USER

#define WORDPAD_HELP_FILE TEXT("WORDPAD.HLP")


// If MFC ever compiles with WINVER >= 0x500 then this cruft should be removed.
#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL    0x400000
#endif // WS_EX_LAYOUTRTL


/////////////////////////////////////////////////////////////////////////////
// CWordPadApp:
// See wordpad.cpp for the implementation of this class
//

class CWordPadCommandLineInfo : public CCommandLineInfo
{
public:
	CWordPadCommandLineInfo() {m_bForceTextMode = FALSE;}
	BOOL m_bForceTextMode;
	virtual void ParseParam(const char* pszParam,BOOL bFlag,BOOL bLast);
};

class CWordPadApp : public CWinApp
{
private:

    enum InitializationPhase
    {
        InitializationPending       = 0,
        InitializingPrinter         = 1,
        UpdatingPrinterRelatedUI    = 2,
        UpdatingRegistry            = 3,
        InitializationComplete      = 99
    };

public:
	CWordPadApp();
	~CWordPadApp();

//Attributes
	CWordPadCommandLineInfo cmdInfo;
	CDC m_dcScreen;
	LOGFONT m_lf;
	int m_nDefFont;
	static int m_nOpenMsg;
	static int m_nPrinterChangedMsg;
   static int m_nOLEHelpMsg;
	CRect m_rectPageMargin;
	CRect m_rectInitialFrame;
	BOOL m_bMaximized;
	BOOL m_bPromptForType;
	BOOL m_bWin4;
#ifndef _UNICODE
	BOOL m_bWin31;
#endif
	BOOL m_bLargeIcons;
	BOOL m_bForceTextMode;
	BOOL m_bWordSel;
	BOOL m_bForceOEM;
    BOOL m_always_convert_to_rtf;
	int m_nFilterIndex;
	int m_nNewDocType;
	CDocOptions m_optionsText;
	CDocOptions m_optionsRTF;
	CDocOptions m_optionsWord; //wrap to ruler
	CDocOptions m_optionsWrite; //wrap to ruler
	CDocOptions m_optionsIP;	//wrap to ruler
	CDocOptions m_optionsNull;
	CList<HWND, HWND> m_listPrinterNotify;

	BOOL IsDocOpen(LPCTSTR lpszFileName);

// Get
	int GetUnits() {return m_nUnits;}
	int GetTPU() { return GetTPU(m_nUnits);}
	int GetTPU(int n) { return m_units[n].m_nTPU;}
	LPCTSTR GetAbbrev() { return m_units[m_nUnits].m_strAbbrev;}
	LPCTSTR GetAbbrev(int n) { return m_units[n].m_strAbbrev;}
	const CUnit& GetUnit() {return m_units[m_nUnits];}
	CDockState& GetDockState(int nDocType, BOOL bPrimary = TRUE);
	CDocOptions& GetDocOptions(int nDocType);
    CDocOptions& GetDocOptions() {return GetDocOptions(m_nNewDocType);}
    BOOL ShouldAlwaysConvertToRTF() {return m_always_convert_to_rtf;}

// Set
	void SetUnits(int n) {ASSERT(n>=0 && n <m_nPrimaryNumUnits); m_nUnits = n;}
    void SetAlwaysConvertToRTF() {m_always_convert_to_rtf = TRUE;}

// Operations
	void RegisterFormats();
	static BOOL CALLBACK StaticEnumProc(HWND hWnd, LPARAM lParam);
	void UpdateRegistry();
	void NotifyPrinterChanged(BOOL bUpdatePrinterSelection = FALSE);
	BOOL PromptForFileName(CString& fileName, UINT nIDSTitle, DWORD dwFlags,
		BOOL bOpenFileDialog, int* pType = NULL);

	BOOL ParseMeasurement(TCHAR* buf, int& lVal);
	void PrintTwips(TCHAR* buf, int nValue, int nDecimal);
	void SaveOptions();
	void LoadOptions();
	void LoadAbbrevStrings();
	HGLOBAL CreateDevNames();
    void EnsurePrinterIsInitialized();

   HGLOBAL GetDevNames(void)
   {
       return m_hDevNames ;
   }

// Overrides
	BOOL IsIdleMessage(MSG* pMsg);
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWordPadApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	virtual BOOL OnDDECommand(LPTSTR lpszCommand);
	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
	COleTemplateServer m_server;
		// Server object for document creation

	//{{AFX_MSG(CWordPadApp)
	afx_msg void OnAppAbout();
	afx_msg void OnFileNew();
	afx_msg void OnFileOpen();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	int m_nUnits;
	static const int m_nPrimaryNumUnits;
	static const int m_nNumUnits;
	static CUnit m_units[];

// Initialization

    volatile InitializationPhase m_initialization_phase;
    CWinThread *                 m_pInitializationThread;
// Cicero process atoms
    ATOM m_atomEnableCTF;
    ATOM m_atomProcessCTF;

    static UINT AFX_CDECL DoDeferredInitialization(LPVOID pvWordPadApp);
};

/////////////////////////////////////////////////////////////////////////////

extern CWordPadApp theApp;
//inline CWordPadApp* GetWordPadApp() {return (CWordPadApp*)AfxGetApp();}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\wordpad.cpp ===
// wordpad.cpp : Defines the class behaviors for the application.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "wordpad.h"
#include "mainfrm.h"
#include "ipframe.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "strings.h"
#include "key.h"
#include "filenewd.h"
#include <locale.h>
#include <winnls.h>
#include <winreg.h>
#include "fixhelp.h"
#include "filedlg.h"

#if _WIN32_IE < 0x400
#undef _WIN32_IE
#define _WIN32_IE   0x0400
#endif
#include <shlobj.h>

#define szRichName    "RICHED20"
#define szNewRichName "MSFTEDIT.DLL"

extern BOOL AFXAPI AfxFullPath(LPTSTR lpszPathOut, LPCTSTR lpszFileIn);
static BOOL RegisterHelper(LPCTSTR* rglpszRegister, LPCTSTR* rglpszSymbols,
                           BOOL bReplace);

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CLIPFORMAT cfEmbeddedObject;
CLIPFORMAT cfRTF;
CLIPFORMAT cfRTO;

int CWordPadApp::m_nOpenMsg = RegisterWindowMessage(_T("WordPadOpenMessage"));
int CWordPadApp::m_nPrinterChangedMsg = RegisterWindowMessage(_T("WordPadPrinterChanged"));
int CWordPadApp::m_nOLEHelpMsg = RegisterWindowMessage(SZOLEUI_MSG_HELP);

CUnit CWordPadApp::m_units[] =
{
    //    TPU,  SmallDiv,MedDiv,LargeDiv,MinMove,szAbbrev,         bSpace
    CUnit(1440, 180,     720,   1440,    90,     IDS_INCH1_ABBREV, FALSE),//"
        CUnit(568,  142,     284,   568,     142,    IDS_CM_ABBREV,    TRUE),//cm's
        CUnit(20,   120,     720,   720,     100,    IDS_POINT_ABBREV, TRUE),//points
        CUnit(240,  240,     1440,  1440,    120,    IDS_PICA_ABBREV,  TRUE),//picas
        CUnit(1440, 180,     720,   1440,    90,     IDS_INCH2_ABBREV, FALSE),//in
        CUnit(1440, 180,     720,   1440,    90,     IDS_INCH3_ABBREV, FALSE),//inch
        CUnit(1440, 180,     720,   1440,    90,     IDS_INCH4_ABBREV, FALSE),//inches

        // Non-localized units

        CUnit(1440, 180,     720,   1440,    90,     IDS_INCH1_NOLOC,  FALSE),//"
        CUnit(1440, 180,     720,   1440,    90,     IDS_INCH2_NOLOC,  FALSE),//in
        CUnit(1440, 180,     720,   1440,    90,     IDS_INCH3_NOLOC,  FALSE),//inch
        CUnit(1440, 180,     720,   1440,    90,     IDS_INCH4_NOLOC,  FALSE),//inches
        CUnit(568,  142,     284,   568,     142,    IDS_CM_NOLOC,     TRUE),//cm's
        CUnit(20,   120,     720,   720,     100,    IDS_POINT_NOLOC,  TRUE),//points
        CUnit(240,  240,     1440,  1440,    120,    IDS_PICA_NOLOC,   TRUE)//picas
};

const int CWordPadApp::m_nPrimaryNumUnits = 4;
const int CWordPadApp::m_nNumUnits = sizeof(m_units) / sizeof(m_units[0]);


/////////////////////////////////////////////////////////////////////////////
// CWordPadApp

BEGIN_MESSAGE_MAP(CWordPadApp, CWinApp)
//{{AFX_MSG_MAP(CWordPadApp)
ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
ON_COMMAND(ID_FILE_NEW, OnFileNew)
ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CWordPadCommandLineInfo::ParseParam(const char* pszParam,BOOL bFlag,BOOL bLast)
{
    if (bFlag)
    {
        if (lstrcmpA(pszParam, "t") == 0)
        {
            m_bForceTextMode = TRUE;
            return;
        }
    }
    CCommandLineInfo::ParseParam(pszParam, bFlag, bLast);
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadApp construction

CWordPadApp::CWordPadApp()
      : m_optionsText(0),
        m_optionsRTF(1),
        m_optionsWord(2),
        m_optionsWrite(2),
        m_optionsIP(2),
        m_optionsNull(0),
        m_initialization_phase(InitializationPending),
        m_pInitializationThread(NULL),
        m_always_convert_to_rtf(FALSE)
{
    // _tsetlocale(LC_ALL, _T(""));
    setlocale(LC_ALL, "");     // change made by t-stefb

    DWORD dwVersion = ::GetVersion();
    m_bWin4 = (BYTE)dwVersion >= 4;
#ifndef _UNICODE
    m_bWin31 = (dwVersion > 0x80000000 && !m_bWin4);
#endif
    m_nDefFont = (m_bWin4) ? DEFAULT_GUI_FONT : ANSI_VAR_FONT;
    m_dcScreen.Attach(::GetDC(NULL));
    m_bLargeIcons = m_dcScreen.GetDeviceCaps(LOGPIXELSX) >= 120;
    m_bForceOEM = FALSE;
}

CWordPadApp::~CWordPadApp()
{
    if (m_atomEnableCTF)
        GlobalDeleteAtom(m_atomEnableCTF);
    if (m_atomProcessCTF)
        GlobalDeleteAtom(m_atomProcessCTF);
    
    if (m_dcScreen.m_hDC != NULL)
        ::ReleaseDC(NULL, m_dcScreen.Detach());

    delete m_pInitializationThread;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWordPadApp object

CWordPadApp theApp;

// Register the application's document templates.  Document templates
//  serve as the connection between documents, frame windows and views.
static CSingleDocTemplate DocTemplate(
                                      IDR_MAINFRAME,
                                      RUNTIME_CLASS(CWordPadDoc),
                                      RUNTIME_CLASS(CMainFrame),       // main SDI frame window
                                      RUNTIME_CLASS(CWordPadView));

// This identifier was generated to be statistically unique for your app.
// You may change it if you prefer to choose a specific identifier.
static const CLSID BASED_CODE clsid =
{ 0x73FDDC80L, 0xAEA9, 0x101A, { 0x98, 0xA7, 0x00, 0xAA, 0x00, 0x37, 0x49, 0x59} };

/////////////////////////////////////////////////////////////////////////////
// CWordPadApp initialization


BOOL CWordPadApp::InitInstance()
{
    ParseCommandLine(cmdInfo);

    if (::FindWindow(szWordPadClass, NULL) && IsDocOpen(cmdInfo.m_strFileName))
        return FALSE;

    SetRegistryKey(szRegKey);

    // The resistry stuff shouldn't be localized so just hardcode it

    if (NULL != m_pszProfileName)
        free((void *) m_pszProfileName);

    m_pszProfileName = _tcsdup(TEXT("Wordpad"));

    LoadOptions();

    Enable3dControls();
    if (!cmdInfo.m_bRunEmbedded)
    {
        switch (m_nCmdShow)
        {
        case SW_RESTORE:
        case SW_SHOW:
        case SW_SHOWDEFAULT:
        case SW_SHOWNA:
        case SW_SHOWNOACTIVATE:
        case SW_SHOWNORMAL:
        case SW_SHOWMAXIMIZED:
            if (m_bMaximized)
                m_nCmdShow = SW_SHOWMAXIMIZED;
            break;
        }
    }
    else
    {
        //Excel 4 will start OLE servers minimized
        m_nCmdShow = SW_SHOWNORMAL;
    }
    int nCmdShow = m_nCmdShow;

    LoadAbbrevStrings();

    m_pszHelpFilePath = _tcsdup(WORDPAD_HELP_FILE) ;

    // Initialize OLE libraries
    if (!AfxOleInit())
    {
        AfxMessageBox(IDP_OLE_INIT_FAILED);
        return FALSE;
    }
    RegisterFormats();

    // Initialize RichEdit control
    if (LoadLibrary(_T(szNewRichName)) == NULL &&
        LoadLibrary(_T(szRichName)) == NULL)
    {
        AfxMessageBox(IDS_RICHED_LOAD_FAIL, MB_OK|MB_ICONEXCLAMATION);
        return FALSE;
    }

    // initialize Cicero process ATOMs
    m_atomEnableCTF  = AddAtom(TF_ENABLE_PROCESS_ATOM);
    m_atomProcessCTF = AddAtom(TF_PROCESS_ATOM);
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    DocTemplate.SetContainerInfo(IDR_CNTR_INPLACE);
    DocTemplate.SetServerInfo(
        IDR_SRVR_EMBEDDED, IDR_SRVR_INPLACE,
        RUNTIME_CLASS(CInPlaceFrame));

    // Connect the COleTemplateServer to the document template.
    //  The COleTemplateServer creates new documents on behalf
    //  of requesting OLE containers by using information
    //  specified in the document template.
    m_server.ConnectTemplate(clsid, &DocTemplate, TRUE);


    //
    // Setup deferred initialization now so the printer can start
    // initializing in case we get a print or printto command at startup
    //

    m_pInitializationThread = AfxBeginThread(
        DoDeferredInitialization,
        this,
        THREAD_PRIORITY_IDLE,
        0,
        CREATE_SUSPENDED);

    if (NULL != m_pInitializationThread)
    {
        m_pInitializationThread->m_bAutoDelete = FALSE;
        m_pInitializationThread->ResumeThread();
    }

    // Check to see if launched as OLE server
    if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
    {
        // Register all OLE server (factories) as running.  This enables the
        //  OLE libraries to create objects from other applications.
        COleTemplateServer::RegisterAll();
        AfxOleSetUserCtrl(FALSE);

        // Application was run with /Embedding or /Automation.  Don't show the
        //  main window in this case.
        return TRUE;
    }

    // make sure the main window is showing
    m_bPromptForType = FALSE;
    OnFileNew();
    m_bPromptForType = TRUE;
    m_nCmdShow = -1;
    if (m_pMainWnd == NULL) // i.e. OnFileNew failed
        return FALSE;

    TRY
    {
        if (!cmdInfo.m_strFileName.IsEmpty())  // open an existing document
            m_nCmdShow = nCmdShow;
        // Dispatch commands specified on the command line
        if (cmdInfo.m_nShellCommand != CCommandLineInfo::FileNew &&
            !ProcessShellCommand(cmdInfo))
        {
            return FALSE;
        }
    }
    CATCH(CFileException, e)
    {
        CString error;
        AfxFormatString1(error, AFX_IDP_FAILED_TO_OPEN_DOC, cmdInfo.m_strFileName);
        AfxMessageBox(error, MB_ICONEXCLAMATION, AFX_IDP_FAILED_TO_OPEN_DOC);
        return FALSE;
    }
    END_CATCH

    // Enable File Manager drag/drop open
    m_pMainWnd->DragAcceptFiles();

    //
    // Set the current directory to "My Documents" so that will be the default
    // location for the first save/open
    //

    TCHAR szDefaultPath[MAX_PATH];

    if (SHGetSpecialFolderPath(NULL, szDefaultPath, CSIDL_PERSONAL, FALSE))
        SetCurrentDirectory(szDefaultPath);

    return TRUE;
}

BOOL CWordPadApp::IsDocOpen(LPCTSTR lpszFileName)
{
    if (lpszFileName[0] == NULL)
        return FALSE;
    TCHAR szPath[_MAX_PATH];
    AfxFullPath(szPath, lpszFileName);
    ATOM atom = GlobalAddAtom(szPath);
    ASSERT(atom != NULL);
    if (atom == NULL)
        return FALSE;
    EnumWindows(StaticEnumProc, (LPARAM)&atom);
    if (atom == NULL)
        return TRUE;
    DeleteAtom(atom);
    return FALSE;
}

BOOL CALLBACK CWordPadApp::StaticEnumProc(HWND hWnd, LPARAM lParam)
{
    TCHAR szClassName[30];
    GetClassName(hWnd, szClassName, 30);
    if (lstrcmp(szClassName, szWordPadClass) != 0)
        return TRUE;

    ATOM* pAtom = (ATOM*)lParam;
    ASSERT(pAtom != NULL);
    DWORD_PTR dw = 0;
    ::SendMessageTimeout(hWnd, m_nOpenMsg, NULL, (LPARAM)*pAtom,
        SMTO_ABORTIFHUNG, 500, &dw);
    if (dw)
    {
        ::SetForegroundWindow(hWnd);
        DeleteAtom(*pAtom);
        *pAtom = NULL;
        return FALSE;
    }
    return TRUE;
}

void CWordPadApp::RegisterFormats()
{
    cfEmbeddedObject = (CLIPFORMAT)::RegisterClipboardFormat(_T("Embedded Object"));
    cfRTF = (CLIPFORMAT)::RegisterClipboardFormat(CF_RTF);
    cfRTO = (CLIPFORMAT)::RegisterClipboardFormat(CF_RETEXTOBJ);
}

CDocOptions& CWordPadApp::GetDocOptions(int nDocType)
{
    switch (nDocType)
    {
    case RD_WINWORD6:
    case RD_WORDPAD:
    case RD_WORD97:
        return m_optionsWord;
    case RD_RICHTEXT:
        return m_optionsRTF;
    case RD_TEXT:
    case RD_OEMTEXT:
    case RD_UNICODETEXT:
        return m_optionsText;
    case RD_WRITE:
        return m_optionsWrite;
    case RD_EMBEDDED:
        return m_optionsIP;
    }
    ASSERT(FALSE);
    return m_optionsNull;
}

CDockState& CWordPadApp::GetDockState(int nDocType, BOOL bPrimary)
{
    return GetDocOptions(nDocType).GetDockState(bPrimary);
}

void CWordPadApp::SaveOptions()
{
    WriteProfileInt(szSection, szWordSel, m_bWordSel);
    WriteProfileInt(szSection, szUnits, GetUnits());
    WriteProfileInt(szSection, szMaximized, m_bMaximized);
    WriteProfileBinary(szSection, szFrameRect, (BYTE*)&m_rectInitialFrame,
        sizeof(CRect));
    WriteProfileBinary(szSection, szPageMargin, (BYTE*)&m_rectPageMargin,
        sizeof(CRect));
    m_optionsText.SaveOptions(szTextSection);
    m_optionsRTF.SaveOptions(szRTFSection);
    m_optionsWord.SaveOptions(szWordSection);
    m_optionsWrite.SaveOptions(szWriteSection);
    m_optionsIP.SaveOptions(szIPSection);
    WriteProfileInt(
            szSection,
            TEXT("DefaultFormat"),
            CWordpadFileDialog::GetDefaultFileType());

    if (ShouldAlwaysConvertToRTF())
        WriteProfileInt(szSection, TEXT("AlwaysConvertToRTF"), TRUE);
}

void CWordPadApp::LoadOptions()
{
    BYTE* pb = NULL;
    UINT nLen = 0;

    HKEY key;
    bool bNewInstall = true;
    if (ERROR_SUCCESS == RegOpenKey(GetAppRegistryKey(), szSection, &key))
    {
        bNewInstall = false;
        RegCloseKey(key);
    }

    HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    if (hFont == NULL)
        hFont = (HFONT)GetStockObject(ANSI_VAR_FONT);
    VERIFY(GetObject(hFont, sizeof(LOGFONT), &m_lf));

    m_bWordSel = GetProfileInt(szSection, szWordSel, TRUE);
    TCHAR buf[2];
    buf[0] = NULL;
    GetLocaleInfo(GetUserDefaultLCID(), LOCALE_IMEASURE, buf, 2);
    int nDefUnits = buf[0] == _T('1') ? 0 : 1;
    SetUnits(GetProfileInt(szSection, szUnits, nDefUnits));
    m_bMaximized = GetProfileInt(szSection, szMaximized, (int)FALSE);

    if (GetProfileBinary(szSection, szFrameRect, &pb, &nLen))
    {
        ASSERT(nLen == sizeof(CRect));
        memcpy(&m_rectInitialFrame, pb, sizeof(CRect));
        delete pb;
    }
    else
        m_rectInitialFrame.SetRect(0,0,0,0);


    CRect rectScreen(0, 0, GetSystemMetrics(SM_CXSCREEN),
        GetSystemMetrics(SM_CYSCREEN));
    CRect rectInt;
    rectInt.IntersectRect(&rectScreen, &m_rectInitialFrame);
    if (rectInt.Width() < 10 || rectInt.Height() < 10)
        m_rectInitialFrame.SetRect(0, 0, 0, 0);

    if (GetProfileBinary(szSection, szPageMargin, &pb, &nLen))
    {
        ASSERT(nLen == sizeof(CRect));
        memcpy(&m_rectPageMargin, pb, sizeof(CRect));
        delete pb;
    }
    else
        m_rectPageMargin.SetRect(1800, 1440, 1800, 1440);

    //
    // Set the default format to RTF for new installs, Word6 (or whatever) was
    // perviously selected for upgrades
    //

    int defformat = RD_NATIVE;

    if (!bNewInstall)
        defformat = GetProfileInt(szSection,TEXT("DefaultFormat"),RD_WORDPAD);

    CWordpadFileDialog::SetDefaultFileType(defformat);

    if (GetProfileInt(szSection, TEXT("AlwaysConvertToRTF"), FALSE))
        SetAlwaysConvertToRTF();

    m_nFilterIndex = GetIndexFromType(RD_DEFAULT, TRUE);

    m_optionsText.LoadOptions(szTextSection);
    m_optionsRTF.LoadOptions(szRTFSection);
    m_optionsWord.LoadOptions(szWordSection);
    m_optionsWrite.LoadOptions(szWriteSection);
    m_optionsIP.LoadOptions(szIPSection);
}

void CWordPadApp::LoadAbbrevStrings()
{
    for (int i=0;i<m_nNumUnits;i++)
        m_units[i].m_strAbbrev.LoadString(m_units[i].m_nAbbrevID);
}

BOOL CWordPadApp::ParseMeasurement(LPTSTR buf, int& lVal)
{
    TCHAR* pch;
    if (buf[0] == NULL)
        return FALSE;
    float f = (float)_tcstod(buf,&pch);

    // eat white space, if any
    while (_istspace(*pch))
        pch++;

    if (pch[0] == NULL) // default
    {
        lVal = (f < 0.f) ? (int)(f*GetTPU()-0.5f) : (int)(f*GetTPU()+0.5f);
        return TRUE;
    }
    for (int i=0;i<m_nNumUnits;i++)
    {
        if (lstrcmpi(pch, GetAbbrev(i)) == 0)
        {
            lVal = (f < 0.f) ? (int)(f*GetTPU(i)-0.5f) : (int)(f*GetTPU(i)+0.5f);
            return TRUE;
        }
    }
    return FALSE;
}

void CWordPadApp::PrintTwips(TCHAR* buf, int nValue, int nDec)
{
    ASSERT(nDec == 2);
    int div = GetTPU();
    int lval = nValue;
    BOOL bNeg = FALSE;

    int* pVal = (int *) alloca((nDec + 1) * sizeof(int));

    if (lval < 0)
    {
        bNeg = TRUE;
        lval = -lval;
    }

    for (int i=0;i<=nDec;i++)
    {
        pVal[i] = lval/div; //integer number
        lval -= pVal[i]*div;
        lval *= 10;
    }
    i--;
    if (lval >= div/2)
        pVal[i]++;

    while ((pVal[i] == 10) && (i != 0))
    {
        pVal[i] = 0;
        pVal[--i]++;
    }

    while (nDec && pVal[nDec] == 0)
        nDec--;

    _stprintf(buf, _T("%.*f"), nDec, (float)nValue/(float)div);

    if (m_units[m_nUnits].m_bSpaceAbbrev)
        lstrcat(buf, _T(" "));
    lstrcat(buf, GetAbbrev());
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadApp commands

void CWordPadApp::OnAppAbout()
{
    CString strTitle;
    VERIFY(strTitle.LoadString(AFX_IDS_APP_TITLE));
    ShellAbout(m_pMainWnd->GetSafeHwnd(), strTitle, _T(""), LoadIcon(IDR_MAINFRAME));
}

int CWordPadApp::ExitInstance()
{
    FreeLibrary(GetModuleHandle(_T(szRichName)));

    HMODULE hMod = GetModuleHandle(_T(szNewRichName));
    if (hMod)
        FreeLibrary(hMod);

    SaveOptions();

    return CWinApp::ExitInstance();
}

void CWordPadApp::OnFileNew()
{
    int nDocType = -1;
    if (!m_bPromptForType)
    {
        if (cmdInfo.m_bForceTextMode)
            nDocType = RD_TEXT;
        else if (!cmdInfo.m_strFileName.IsEmpty())
        {
            CFileException fe;
            nDocType = GetDocTypeFromName(cmdInfo.m_strFileName, fe);
        }
        if (nDocType == -1)
            nDocType = RD_DEFAULT;
    }
    else
    {
        CFileNewDialog dlg;
        if (dlg.DoModal() == IDCANCEL)
            return;

        nDocType = (dlg.m_nSel == 1) ? RD_TEXT :
                   (dlg.m_nSel == 2) ? RD_UNICODETEXT :
                   RD_RICHTEXT;

        if (nDocType != RD_TEXT)
            cmdInfo.m_bForceTextMode = FALSE;
    }
    m_nNewDocType = nDocType;
    DocTemplate.OpenDocumentFile(NULL);
    // if returns NULL, the user has already been alerted
}

// prompt for file name - used for open and save as
// static function called from app
BOOL CWordPadApp::PromptForFileName(CString& fileName, UINT nIDSTitle,
                                    DWORD dwFlags, BOOL bOpenFileDialog, int* pType)
{
    ScanForConverters();
    CWordpadFileDialog dlgFile(bOpenFileDialog);
    CString title;

    VERIFY(title.LoadString(nIDSTitle));

    dlgFile.m_ofn.Flags |= dwFlags;

    int nIndex = m_nFilterIndex;
    if (!bOpenFileDialog)
    {
        int nDocType = (pType != NULL) ? *pType : RD_DEFAULT;
        nIndex = GetIndexFromType(nDocType, bOpenFileDialog);
        if (nIndex == -1)
            nIndex = GetIndexFromType(RD_DEFAULT, bOpenFileDialog);
        if (nIndex == -1)
            nIndex = GetIndexFromType(RD_NATIVE, bOpenFileDialog);
        ASSERT(nIndex != -1);
        nIndex++;
    }
    dlgFile.m_ofn.nFilterIndex = nIndex;
    // strDefExt is necessary to hold onto the memory from GetExtFromType
    CString strDefExt = GetExtFromType(GetTypeFromIndex(nIndex-1, bOpenFileDialog));

    //
    // The open file dialog doesn't want the extension to start with '.' but
    // thats how GetExtFromType gives it to us.
    //

    dlgFile.m_ofn.lpstrDefExt = strDefExt;
    ASSERT(TEXT('.') == *dlgFile.m_ofn.lpstrDefExt);
    ++dlgFile.m_ofn.lpstrDefExt;

    CString strFilter = GetFileTypes(bOpenFileDialog);
    dlgFile.m_ofn.lpstrFilter = strFilter;
    dlgFile.m_ofn.lpstrTitle = title;
    dlgFile.m_ofn.lpstrFile = fileName.GetBuffer(_MAX_PATH);

    BOOL bRet;
    int  namelen;

    do
    {
        bRet = (dlgFile.DoModal() == IDOK) ? TRUE : FALSE;

        if (!bRet)
            break;

        // The converters only speak ansi so make sure the filename isn't to
        // long for DBCS.

#ifndef UNICODE
        namelen = strlen(fileName);
#else
        namelen = WideCharToMultiByte(CP_ACP, 0, fileName, -1, NULL, 0,NULL,NULL);
#endif

        if (namelen > MAX_PATH - 2)
        {
            CString   message;
            AfxFormatString1(message, IDS_FILENAME_TO_LONG, fileName);
            AfxMessageBox(message);
        }
    }
    while (namelen > MAX_PATH - 2);

    fileName.ReleaseBuffer();
    if (bRet)
    {
        if (bOpenFileDialog)
            m_nFilterIndex = dlgFile.m_ofn.nFilterIndex;
        if (pType != NULL)
        {
            int nIndex = (int)dlgFile.m_ofn.nFilterIndex - 1;
            ASSERT(nIndex >= 0);
            *pType = GetTypeFromIndex(nIndex, bOpenFileDialog);
        }
    }
    return bRet;
}

void CWordPadApp::OnFileOpen()
{
    // prompt the user (with all document templates)
    CString newName;
    int nType = RD_DEFAULT;
    if (!PromptForFileName(newName, AFX_IDS_OPENFILE,
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST, TRUE, &nType))
        return; // open cancelled

    if (nType == RD_OEMTEXT)
        m_bForceOEM = TRUE;
    OpenDocumentFile(newName);
    m_bForceOEM = FALSE;
    // if returns NULL, the user has already been alerted
}

BOOL CWordPadApp::OnDDECommand(LPTSTR /*lpszCommand*/)
{
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// DDE and ShellExecute support

//HKEY_CLASSES_ROOT\.RTF = rtffile
//HKEY_CLASSES_ROOT\rtffile =
//HKEY_CLASSES_ROOT\rtffile\CLSID = {73FDDC80-AEA9-101A-98A7-00AA00374959}
//HKEY_CLASSES_ROOT\rtffile\protocol\StdFileEditing\server = WORDPAD.EXE
//HKEY_CLASSES_ROOT\rtffile\protocol\StdFileEditing\verb\0 = &Edit
//HKEY_CLASSES_ROOT\rtffile\shell\open\command = WORDPAD.EXE %1
//HKEY_CLASSES_ROOT\rtffile\shell\print\command = WORDPAD.EXE /p %1

#define REGENTRY(key, value) _T(key) _T("\0\0") _T(value)
#define REGENTRYX(key, valuename, value) _T(key) _T("\0") _T(valuename) _T("\0") _T(value)

static const TCHAR sz00[] = REGENTRY("%2", "%5");
static const TCHAR sz01[] = REGENTRY("%2\\CLSID", "%1");
static const TCHAR sz02[] = REGENTRY("%2\\Insertable", "");
static const TCHAR sz03[] = REGENTRY("%2\\protocol\\StdFileEditing\\verb\\0", "&Edit");
static const TCHAR sz04[] = REGENTRY("%2\\protocol\\StdFileEditing\\server", "%3");
static const TCHAR sz05[] = REGENTRY("CLSID\\%1", "%5");
static const TCHAR sz06[] = REGENTRY("CLSID\\%1\\ProgID", "%2");
static const TCHAR sz07[] = REGENTRY("CLSID\\%1\\InprocHandler32", "ole32.dll");
static const TCHAR sz08[] = REGENTRY("CLSID\\%1\\LocalServer32", "%3");
static const TCHAR sz09[] = REGENTRY("CLSID\\%1\\Verb\\0", "&Edit,0,2");
static const TCHAR sz10[] = REGENTRY("CLSID\\%1\\Verb\\1", "&Open,0,2");
static const TCHAR sz11[] = REGENTRY("CLSID\\%1\\Insertable", "");
static const TCHAR sz12[] = REGENTRY("CLSID\\%1\\AuxUserType\\2", "%4");
static const TCHAR sz13[] = REGENTRY("CLSID\\%1\\AuxUserType\\3", "%6");
static const TCHAR sz14[] = REGENTRY("CLSID\\%1\\DefaultIcon", "%3,1");
static const TCHAR sz15[] = REGENTRY("CLSID\\%1\\MiscStatus", "0");
static const TCHAR sz16[] = REGENTRY("%2\\shell\\open\\command", "%3 \"%%1\"");
static const TCHAR sz17[] = REGENTRY("%2\\shell\\print\\command", "%3 /p \"%%1\"");
static const TCHAR sz18[] = REGENTRY("%7", "%2");
static const TCHAR sz19[] = REGENTRY("%2", ""); // like sz00 only no long type name
static const TCHAR sz20[] = REGENTRY("%2\\shell\\printto\\command", "%3 /pt \"%%1\" \"%%2\" \"%%3\" \"%%4\"");
static const TCHAR sz21[] = REGENTRY("%2\\DefaultIcon", "%3,%8");
static const TCHAR sz22[] = REGENTRYX("%7\\ShellNew", "NullFile", "true");
static const TCHAR sz23[] = REGENTRYX("%7\\ShellNew", "Data", "{\\rtf1}");

// %1 - class ID
// %2 - class name            WordPad.Document.1
// %3 - SFN executable path      C:\PROGRA~1\ACCESS~1\WORDPAD.EXE
// %4 - short type name       Document
// %5 - long type name        Microsoft WordPad Document
// %6 - long application name Microsoft WordPad
// %7 = extension          .rtf
// %8 = default icon       0,1,2,3
#define NUM_REG_ARGS 8

static const LPCTSTR rglpszWordPadRegister[] =
{sz00, sz02, sz03, sz05, sz09, sz10, sz11, sz15, NULL};

static const LPCTSTR rglpszWordPadOverwrite[] =
{sz01, sz04, sz06, sz07, sz08, sz12, sz13, sz14, sz16, sz17, sz20, NULL};

//static const LPCTSTR rglpszExtRegister[] =
//{sz00, sz18, NULL};

//static const LPCTSTR rglpszExtOverwrite[] =
//{sz01, sz16, sz17, sz21, NULL};

static const LPCTSTR rglpszWriExtRegister[] =
{sz18, NULL};
static const LPCTSTR rglpszWriRegister[] =
{sz00, sz01, sz16, sz17, sz20, sz21, NULL};

static const LPCTSTR rglpszRtfExtRegister[] =
{sz18, sz23, NULL};
static const LPCTSTR rglpszRtfRegister[] =
{sz00, sz01, sz16, sz17, sz20, sz21, NULL};

static const LPCTSTR rglpszTxtExtRegister[] =
{sz18, sz22, NULL};
static const LPCTSTR rglpszTxtRegister[] =
{sz00, sz01, sz16, sz17, sz20, sz21, NULL};

static const LPCTSTR rglpszDocExtRegister[] =
{sz18, sz22, NULL};
static const LPCTSTR rglpszDocRegister[] =
{sz00, sz01, sz16, sz17, sz20, sz21, NULL};

static void RegisterExt(LPCTSTR lpszExt, LPCTSTR lpszProgID, UINT nIDTypeName,
                        LPCTSTR* rglpszSymbols, LPCTSTR* rglpszExtRegister,
                        LPCTSTR* rglpszRegister, int nIcon)
{
    // don't overwrite anything with the extensions
    CString strWhole;
    VERIFY(strWhole.LoadString(nIDTypeName));
    CString str;
    AfxExtractSubString(str, strWhole, DOCTYPE_PROGID);

    rglpszSymbols[1] = lpszProgID;
    rglpszSymbols[4] = str;
    rglpszSymbols[6] = lpszExt;
    TCHAR buf[10];
    wsprintf(buf, _T("%d"), nIcon);
    rglpszSymbols[7] = buf;
    // check for .ext and progid
    CKey key;
    if (!key.Open(HKEY_CLASSES_ROOT, lpszExt)) // .ext doesn't exist
        RegisterHelper(rglpszExtRegister, rglpszSymbols, TRUE);
    key.Close();
    if (!key.Open(HKEY_CLASSES_ROOT, lpszProgID)) // ProgID doesn't exist (i.e. txtfile)
        RegisterHelper(rglpszRegister, rglpszSymbols, TRUE);
}

void CWordPadApp::UpdateRegistry()
{
    // If stuff is already initialized, don't overwrite it

    HKEY rtfkey;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, TEXT(".rtf"), &rtfkey))
    {
        // .rtf is already registered, assume the rest are as well
        RegCloseKey(rtfkey);
        return;
    }

    USES_CONVERSION;
    LPOLESTR lpszClassID = NULL;
    CDocTemplate* pDocTemplate = &DocTemplate;

    // get registration info from doc template string
    CString strServerName;
    CString strLocalServerName;
    CString strLocalShortName;

    if (!pDocTemplate->GetDocString(strServerName,
        CDocTemplate::regFileTypeId) || strServerName.IsEmpty())
    {
        TRACE0("Error: not enough information in DocTemplate to register OLE server.\n");
        return;
    }
    if (!pDocTemplate->GetDocString(strLocalServerName,
        CDocTemplate::regFileTypeName))
        strLocalServerName = strServerName;     // use non-localized name
    if (!pDocTemplate->GetDocString(strLocalShortName,
        CDocTemplate::fileNewName))
        strLocalShortName = strLocalServerName; // use long name

    ASSERT(strServerName.Find(' ') == -1);  // no spaces allowed

    ::StringFromCLSID(clsid, &lpszClassID);
    ASSERT (lpszClassID != NULL);

    // get path name to server
    TCHAR szLongPathName[_MAX_PATH];
    TCHAR szShortPathName[_MAX_PATH];
    ::GetModuleFileName(AfxGetInstanceHandle(), szLongPathName, _MAX_PATH);
    ::GetShortPathName(szLongPathName, szShortPathName, _MAX_PATH);

    LPCTSTR rglpszSymbols[NUM_REG_ARGS];
    rglpszSymbols[0] = OLE2CT(lpszClassID);
    rglpszSymbols[1] = strServerName;
    rglpszSymbols[2] = szShortPathName;
    rglpszSymbols[3] = strLocalShortName;
    rglpszSymbols[4] = strLocalServerName;
    rglpszSymbols[5] = m_pszAppName; // will usually be long, readable name
    rglpszSymbols[6] = NULL;

    if (RegisterHelper((LPCTSTR*)rglpszWordPadRegister, rglpszSymbols, FALSE))
        RegisterHelper((LPCTSTR*)rglpszWordPadOverwrite, rglpszSymbols, TRUE);

    // RegisterExt(_T(".txt"), _T("txtfile"), IDS_TEXT_DOC, rglpszSymbols,
    //    (LPCTSTR*)rglpszTxtExtRegister, (LPCTSTR*)rglpszTxtRegister, 3);
    RegisterExt(_T(".rtf"), _T("rtffile"), IDS_RICHTEXT_DOC, rglpszSymbols,
        (LPCTSTR*)rglpszRtfExtRegister, (LPCTSTR*)rglpszRtfRegister, 1);
    RegisterExt(_T(".wri"), _T("wrifile"), IDS_WRITE_DOC, rglpszSymbols,
        (LPCTSTR*)rglpszWriExtRegister, (LPCTSTR*)rglpszWriRegister, 2);
    RegisterExt(_T(".doc"), _T("WordPad.Document.1"), IDS_WINWORD6_DOC, rglpszSymbols,
        (LPCTSTR*)rglpszDocExtRegister, (LPCTSTR*)rglpszDocRegister, 1);

    // free memory for class ID
    ASSERT(lpszClassID != NULL);
    CoTaskMemFree(lpszClassID);
}

BOOL RegisterHelper(LPCTSTR* rglpszRegister, LPCTSTR* rglpszSymbols,
                    BOOL bReplace)
{
    ASSERT(rglpszRegister != NULL);
    ASSERT(rglpszSymbols != NULL);

    CString strKey;
    CString strValueName;
    CString strValue;

    // keeping a key open makes this go a bit faster
    CKey keyTemp;
    VERIFY(keyTemp.Create(HKEY_CLASSES_ROOT, _T("CLSID")));

    BOOL bResult = TRUE;
    while (*rglpszRegister != NULL)
    {
        LPCTSTR lpszKey = *rglpszRegister++;
        if (*lpszKey == '\0')
            continue;

        LPCTSTR lpszValueName = lpszKey + lstrlen(lpszKey) + 1;
        LPCTSTR lpszValue = lpszValueName + lstrlen(lpszValueName) + 1;

        strKey.ReleaseBuffer(
            FormatMessage(FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY, lpszKey, NULL,   NULL,
            strKey.GetBuffer(256), 256, (va_list*) rglpszSymbols));
        strValueName = lpszValueName;
        strValue.ReleaseBuffer(
            FormatMessage(FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY, lpszValue, NULL, NULL,
            strValue.GetBuffer(256), 256, (va_list*) rglpszSymbols));

        if (strKey.IsEmpty())
        {
            TRACE1("Warning: skipping empty key '%s'.\n", lpszKey);
            continue;
        }

        CKey key;
        VERIFY(key.Create(HKEY_CLASSES_ROOT, strKey));
        if (!bReplace)
        {
            CString str;
            if (key.GetStringValue(str, strValueName) && !str.IsEmpty())
                continue;
        }

        if (!key.SetStringValue(strValue, strValueName))
        {
            TRACE2("Error: failed setting key '%s' to value '%s'.\n",
                (LPCTSTR)strKey, (LPCTSTR)strValue);
            bResult = FALSE;
            break;
        }
    }

    return bResult;
}

void CWordPadApp::WinHelp(DWORD dwData, UINT nCmd)
{
    if (g_fDisableStandardHelp)
    {
        return ;
    }

    if ( (nCmd == HELP_FINDER) || (nCmd == HELP_CONTENTS) || (nCmd == HELP_INDEX) )
    {
        ::HtmlHelpA( ::GetDesktopWindow(), "wordpad.chm", HH_DISPLAY_TOPIC, 0L );   
        return;
    }
    CWinApp::WinHelp(dwData, nCmd);
}

BOOL CWordPadApp::PreTranslateMessage(MSG* pMsg)
{
    if (pMsg->message == WM_PAINT)
        return FALSE;
    // CWinApp::PreTranslateMessage does nothing but call base
    return CWinThread::PreTranslateMessage(pMsg);
}

void CWordPadApp::NotifyPrinterChanged(BOOL bUpdatePrinterSelection)
{
    if (bUpdatePrinterSelection)
        UpdatePrinterSelection(TRUE);

    POSITION pos = m_listPrinterNotify.GetHeadPosition();
    while (pos != NULL)
    {
        HWND hWnd = m_listPrinterNotify.GetNext(pos);
        ::SendMessage(hWnd, m_nPrinterChangedMsg, 0, 0);
    }
}

BOOL CWordPadApp::IsIdleMessage(MSG* pMsg)
{
    if (pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_NCMOUSEMOVE)
        return FALSE;
    return CWinApp::IsIdleMessage(pMsg);
}

#define DN_PADDINGCHARS 16

HGLOBAL CWordPadApp::CreateDevNames()
{
    HGLOBAL hDev = NULL;
    CString strDriverName;
    CString strPrinterName;
    CString strPortName;

    if (!cmdInfo.m_strPrinterName.IsEmpty())
    {
        strDriverName = cmdInfo.m_strDriverName;
        strPrinterName = cmdInfo.m_strPrinterName;
        strPortName = cmdInfo.m_strPortName;
    }
    else
    {
        PRINTDLG    printdlg;
        DEVNAMES   *devnames;

        if (!GetPrinterDeviceDefaults(&printdlg))
            return NULL;

        devnames = (DEVNAMES *) ::GlobalLock(printdlg.hDevNames);
        if (NULL == devnames)
            return NULL;

        strDriverName = (LPTSTR) ((BYTE *) devnames) + devnames->wDriverOffset;
        strPrinterName = (LPTSTR) ((BYTE *) devnames) + devnames->wDeviceOffset;
        strPortName = (LPTSTR) ((BYTE *) devnames) + devnames->wOutputOffset;

        ::GlobalUnlock(printdlg.hDevNames);
    }

    DWORD cbDevNames ;

    cbDevNames = strDriverName.GetLength() + 1 +
        strPrinterName.GetLength() + 1 +
        strPortName.GetLength() + 1 +
        DN_PADDINGCHARS ;

    cbDevNames *= sizeof(TCHAR) ;
    cbDevNames += sizeof(DEVNAMES) ;

    hDev = GlobalAlloc(GPTR, cbDevNames) ;

    if (NULL == hDev)
        return NULL;

    LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(hDev) ;

    lpDev->wDriverOffset = sizeof(DEVNAMES) / sizeof(TCHAR) ;
    lstrcpy((LPTSTR) lpDev + lpDev->wDriverOffset, strDriverName) ;

    lpDev->wDeviceOffset = (WORD) (lpDev->wDriverOffset
        + strDriverName.GetLength() + 1);
    lstrcpy((LPTSTR) lpDev + lpDev->wDeviceOffset, strPrinterName) ;

    lpDev->wOutputOffset = (WORD) (lpDev->wDeviceOffset
        + strPrinterName.GetLength() + 1);
    lstrcpy((LPTSTR) lpDev + lpDev->wOutputOffset, strPortName) ;

    lpDev->wDefault = 0;

    return hDev;
}

//+---------------------------------------------------------------------------
//
//  Method:     CWordPadApp::DoDeferredInitialization, static
//
//  Synopsis:   Thread entry point for low priority initialization
//
//  Parameters: [pvWordPadApp]          -- Pointer to to CWordPadApp
//
//  Returns:    Thread exit code
//
//---------------------------------------------------------------------------

UINT AFX_CDECL CWordPadApp::DoDeferredInitialization(LPVOID pvWordPadApp)
{
    ASSERT(NULL != pvWordPadApp);


    CWordPadApp *pWordPadApp = (CWordPadApp *) pvWordPadApp;

    pWordPadApp->m_initialization_phase = InitializingPrinter;
    pWordPadApp->m_hDevNames = pWordPadApp->CreateDevNames();

    pWordPadApp->m_initialization_phase = UpdatingPrinterRelatedUI;
    pWordPadApp->NotifyPrinterChanged( ((pWordPadApp->m_hDevNames) == NULL) );

    pWordPadApp->m_initialization_phase = UpdatingRegistry;
    pWordPadApp->UpdateRegistry();

    pWordPadApp->m_initialization_phase = InitializationComplete;

    return 0;
}

//+--------------------------------------------------------------------------
//
//  Method:     CWordPadApp::EnsurePrinterIsInitialized
//
//  Synopsis:   Make sure the printer is done initializing
//
//  Parameters: None
//
//  Returns:    void
//
//  Notes:      We'll only wait two minutes.  If the printer takes that long
//              to initialize printing probably is going to be flakey anyway.
//
//              The main purpose of doing printer initialization on a different
//              thread is so that it doesn't get in the way of doing real work.
//              On the other hand if printing is the real work we should try to
//              get things moving so bump it up from idle priority.
//
//---------------------------------------------------------------------------

void CWordPadApp::EnsurePrinterIsInitialized()
{
    int     nWaits = 0;
    BOOL    bBumpedPriority = FALSE;

    if (NULL == m_pInitializationThread)
    {
        ASSERT(NULL != m_pInitializationThread);
        bBumpedPriority = TRUE;
    }

    while (m_initialization_phase <= InitializingPrinter && nWaits < 1200)
    {
        if (!bBumpedPriority)
        {
            m_pInitializationThread->SetThreadPriority(
                THREAD_PRIORITY_ABOVE_NORMAL);
            bBumpedPriority = TRUE;
        }

        Sleep(100);
        ++nWaits;
    }

    if (bBumpedPriority)
        m_pInitializationThread->SetThreadPriority(THREAD_PRIORITY_IDLE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\wordpvw.h ===
// wordpvw.h : interface of the CWordPadView class
//
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


class CWordPadView : public CRichEdit2View
{
protected: // create from serialization only
    CWordPadView();
    DECLARE_DYNCREATE(CWordPadView)

// Attributes
public:
    static BOOL m_bIsMirrored;

    UINT_PTR m_uTimerID;
    BOOL m_bDelayUpdateItems;
    BOOL m_bInPrint;
    CParaFormat m_defParaFormat;

    CWordPadDoc* GetDocument();
    BOOL IsFormatText();

    virtual HMENU GetContextMenu(WORD seltype, LPOLEOBJECT lpoleobj,
        CHARRANGE* lpchrg);

// Operations
public:
    BOOL PasteNative(LPDATAOBJECT lpdataobj);
    void SetDefaultFont(BOOL bText);
    void SetUpdateTimer();
    void GetDefaultFont(CCharFormat& cf, BOOL bText);
    void DrawMargins(CDC* pDC);
    BOOL SelectPalette();
   HRESULT PasteHDROPFormat(HDROP hDrop) ;
   BOOL PaginateTo(CDC* pDC, CPrintInfo* pInfo) ;

    static void MirrorTheContainer(BOOL bMirror);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWordPadView)
    protected:
    virtual void CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType = adjustBorder);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* printInfo);
    virtual void CWordPadView::OnEndPrinting(CDC*dc, CPrintInfo*pInfo);
    virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);
    //}}AFX_VIRTUAL
    BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual HRESULT GetClipboardData(CHARRANGE* lpchrg, DWORD reco,
        LPDATAOBJECT lpRichDataObj, LPDATAOBJECT* lplpdataobj);
    virtual HRESULT QueryAcceptData(LPDATAOBJECT, CLIPFORMAT*, DWORD,
        BOOL, HGLOBAL);
public:
    virtual void WrapChanged();

// Implementation
public:
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

//
// Wrapper for the richedit callback interface so we can
// get around some MFC defaults
//

public:

    BEGIN_INTERFACE_PART(WordPadRichEditOleCallback, IRichEditOleCallback)
        INIT_INTERFACE_PART(CWordPadView, WordPadRichEditOleCallback)
        STDMETHOD(GetNewStorage) (LPSTORAGE*);
        STDMETHOD(GetInPlaceContext) (LPOLEINPLACEFRAME*,
                                      LPOLEINPLACEUIWINDOW*,
                                      LPOLEINPLACEFRAMEINFO);
        STDMETHOD(ShowContainerUI) (BOOL);
        STDMETHOD(QueryInsertObject) (LPCLSID, LPSTORAGE, LONG);
        STDMETHOD(DeleteObject) (LPOLEOBJECT);
        STDMETHOD(QueryAcceptData) (LPDATAOBJECT, CLIPFORMAT*, DWORD,BOOL, HGLOBAL);
        STDMETHOD(ContextSensitiveHelp) (BOOL);
        STDMETHOD(GetClipboardData) (CHARRANGE*, DWORD, LPDATAOBJECT*);
        STDMETHOD(GetDragDropEffect) (BOOL, DWORD, LPDWORD);
        STDMETHOD(GetContextMenu) (WORD, LPOLEOBJECT, CHARRANGE*, HMENU*);
    END_INTERFACE_PART(WordPadRichEditOleCallback)

    DECLARE_INTERFACE_MAP()


protected:
    BOOL m_bOnBar;

    CPrintDialog *m_oldprintdlg;

    // OLE Container support

    virtual void DeleteContents();
    virtual void OnTextNotFound(LPCTSTR);

// Generated message map functions
protected:
    afx_msg void OnCancelEditSrvr();
    //{{AFX_MSG(CWordPadView)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnPageSetup();
    afx_msg void OnInsertDateTime();
   afx_msg void OnInsertObject();
    afx_msg void OnFormatParagraph();
    afx_msg void OnFormatFont();
    afx_msg void OnFormatTabs();
   afx_msg void OnEditPasteSpecial();
   afx_msg void OnEditProperties();
    afx_msg void OnEditFind();
    afx_msg void OnEditReplace();
    afx_msg void OnTimer(UINT_PTR nIDEvent);
    afx_msg void OnDestroy();
    afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    afx_msg void OnPenBackspace();
    afx_msg void OnPenNewline();
    afx_msg void OnPenPeriod();
    afx_msg void OnPenSpace();
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnFilePrint();
    afx_msg void OnFilePrintPreview();
    afx_msg void OnPenLens();
    afx_msg void OnPenTab();
    afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
    afx_msg BOOL OnQueryNewPalette();
    afx_msg void OnWinIniChange(LPCTSTR lpszSection);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnDelayedInvalidate() ;
    //}}AFX_MSG
    afx_msg void OnEditChange();
    afx_msg void OnColorPick(UINT nID);
    afx_msg int OnMouseActivate(CWnd* pWnd, UINT nHitTest, UINT message);
    afx_msg LONG OnPrinterChangedMsg(UINT, LONG);
    afx_msg void OnGetCharFormat(NMHDR* pNMHDR, LRESULT* pRes);
    afx_msg void OnSetCharFormat(NMHDR* pNMHDR, LRESULT* pRes);
    afx_msg void OnBarSetFocus(NMHDR*, LRESULT*);
    afx_msg void OnBarKillFocus(NMHDR*, LRESULT*);
    afx_msg void OnBarReturn(NMHDR*, LRESULT* );
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in wordpvw.cpp
inline CWordPadDoc* CWordPadView::GetDocument()
   { return (CWordPadDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\afxcmn2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCMN2_H__
#define __AFXCMN2_H__

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifndef IMAGE_BITMAP
#define IMAGE_BITMAP 0
#endif


/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

	#ifndef _RICHEDIT_
		#include <richedit.h>
	#endif
	#ifdef __AFXOLE_H__  // only include richole if OLE support is included
		#ifndef _RICHOLE_
			#include <richole.h>
			#define _RICHOLE_
		#endif
	#else
		struct IRichEditOle;
		struct IRichEditOleCallback;
	#endif

/////////////////////////////////////////////////////////////////////////////
// AFXCMN2 - RichEdit2 Control Class

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd
			class CRichEdit2Ctrl;

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Ctrl

class CRichEdit2Ctrl : public CWnd
{
	DECLARE_DYNAMIC(CRichEdit2Ctrl)

// Constructors
public:
	CRichEdit2Ctrl();
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	BOOL CanUndo() const;
	int GetLineCount() const;
	BOOL GetModify() const;
	void SetModify(BOOL bModified = TRUE);
	void GetRect(LPRECT lpRect) const;
	CPoint GetCharPos(long lChar) const;
	void SetOptions(WORD wOp, DWORD dwFlags);

	// NOTE: first word in lpszBuffer must contain the size of the buffer!
	int GetLine(int nIndex, LPTSTR lpszBuffer) const;
	int GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const;

	BOOL CanPaste(UINT nFormat = 0) const;
	void GetSel(long& nStartChar, long& nEndChar) const;
	void GetSel(CHARRANGE &cr) const;
	void LimitText(long nChars = 0);
	long LineFromChar(long nIndex) const;
	void SetSel(long nStartChar, long nEndChar);
	void SetSel(CHARRANGE &cr);
	DWORD GetDefaultCharFormat(CHARFORMAT &cf) const;
	DWORD GetSelectionCharFormat(CHARFORMAT &cf) const;
	long GetEventMask() const;
	long GetLimitText() const;
	DWORD GetParaFormat(PARAFORMAT &pf) const;
	// richedit EM_GETSELTEXT is ANSI
	long GetSelText(LPSTR lpBuf) const;
	CString GetSelText() const;
	WORD GetSelectionType() const;
	COLORREF SetBackgroundColor(BOOL bSysColor, COLORREF cr);
	BOOL SetDefaultCharFormat(CHARFORMAT &cf);
	BOOL SetSelectionCharFormat(CHARFORMAT &cf);
	BOOL SetWordCharFormat(CHARFORMAT &cf);
	DWORD SetEventMask(DWORD dwEventMask);
	BOOL SetParaFormat(PARAFORMAT &pf);
	BOOL SetTargetDevice(HDC hDC, long lLineWidth);
	BOOL SetTargetDevice(CDC &dc, long lLineWidth);
	long GetTextLength() const;
	BOOL SetReadOnly(BOOL bReadOnly = TRUE);
	int GetFirstVisibleLine() const;

// Operations
	void EmptyUndoBuffer();

	int LineIndex(int nLine = -1) const;
	int LineLength(int nLine = -1) const;
	void LineScroll(int nLines, int nChars = 0);
	void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE);
	void SetRect(LPCRECT lpRect);

	BOOL DisplayBand(LPRECT pDisplayRect);
	long FindText(DWORD dwFlags, FINDTEXTEX* pFindText) const;
	long FormatRange(FORMATRANGE* pfr, BOOL bDisplay = TRUE);
	void HideSelection(BOOL bHide, BOOL bPerm);
	void PasteSpecial(UINT nClipFormat, DWORD dvAspect = 0, HMETAFILE hMF = 0);
	void RequestResize();
	long StreamIn(int nFormat, EDITSTREAM &es);
	long StreamOut(int nFormat, EDITSTREAM &es);

	// Clipboard operations
	BOOL Undo();
	void Clear();
	void Copy();
	void Cut();
	void Paste();

// OLE support
	IRichEditOle* GetIRichEditOle() const;
	BOOL SetOLECallback(IRichEditOleCallback* pCallback);

// Implementation
public:
	virtual ~CRichEdit2Ctrl();
};
/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXCMN_INLINE inline
#include <afxcmn2.inl>
#undef _AFXCMN_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXCMN2_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\wordpdoc.h ===
// wordpdoc.h : interface of the CWordPadDoc class
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

class CFormatBar;
class CWordPadSrvrItem;
class CWordPadView;

class CWordPadDoc : public CRichEdit2Doc
{
protected: // create from serialization only
	CWordPadDoc();
	DECLARE_DYNCREATE(CWordPadDoc)

// Attributes
public:
	int     m_nDocType;
	int     m_nNewDocType;
    LPTSTR  m_short_filename;

	void SetDocType(int nDocType, BOOL bNoOptionChange = FALSE);
	CWordPadView* GetView();
	CLSID GetClassID();
	LPCTSTR GetSection();

// Operations
public:
	void SaveState(int nType);
	void RestoreState(int nType);
	virtual CFile* GetFile(LPCTSTR pszPathName, UINT nOpenFlags, 
		CFileException* pException);
	virtual BOOL DoSave(LPCTSTR pszPathName, BOOL bReplace = TRUE);
	int MapType(int nType);
	void ForceDelayed(CFrameWnd* pFrameWnd);

// Overrides
	virtual CRichEdit2CntrItem* CreateClientItem(REOBJECT* preo) const;
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual void Serialize(CArchive& ar);
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWordPadDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	        BOOL OnOpenDocument2(LPCTSTR lpszPathName, bool defaultToText = true);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual void OnCloseDocument();
	virtual void ReportSaveLoadException(LPCTSTR lpszPathName, CException* e, BOOL bSaving, UINT nIDPDefault);
	protected:
	virtual COleServerItem* OnGetEmbeddedItem();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual void PreCloseFrame(CFrameWnd* pFrameArg);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CWordPadDoc)
	afx_msg void OnViewOptions();
	afx_msg void OnUpdateOleVerbPopup(CCmdUI* pCmdUI);
	afx_msg void OnFileSendMail();
	afx_msg void OnUpdateIfEmbedded(CCmdUI* pCmdUI);
	afx_msg void OnEditLinks();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\afxcmn2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCMN2.H

#ifdef _AFXCMN2_INLINE

_AFXCMN2_INLINE CRichEdit2Ctrl::CRichEdit2Ctrl()
	{ }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::CanUndo() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0); }
_AFXCMN2_INLINE int CRichEdit2Ctrl::GetLineCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0); }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::GetModify() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::SetModify(BOOL bModified /* = TRUE */)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0);}
_AFXCMN2_INLINE void CRichEdit2Ctrl::GetRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect); }
_AFXCMN2_INLINE CPoint CRichEdit2Ctrl::GetCharPos(long lChar) const
	{ ASSERT(::IsWindow(m_hWnd)); CPoint pt; ::SendMessage(m_hWnd, EM_POSFROMCHAR, (WPARAM)&pt, (LPARAM)lChar); return pt;}
_AFXCMN2_INLINE void CRichEdit2Ctrl::SetOptions(WORD wOp, DWORD dwFlags)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETOPTIONS, (WPARAM)wOp, (LPARAM)dwFlags); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::EmptyUndoBuffer()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo)
	{ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::SetRect(LPCRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect); }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::Undo()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::Clear()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CLEAR, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::Copy()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_COPY, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::Cut()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CUT, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::Paste()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PASTE, 0, 0); }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::SetReadOnly(BOOL bReadOnly /* = TRUE */ )
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L); }
_AFXCMN2_INLINE int CRichEdit2Ctrl::GetFirstVisibleLine() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L); }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::DisplayBand(LPRECT pDisplayRect)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_DISPLAYBAND, 0, (LPARAM)pDisplayRect); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::GetSel(CHARRANGE &cr) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr); }

_AFXCMN2_INLINE void CRichEdit2Ctrl::LimitText(long nChars)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXLIMITTEXT, 0, nChars); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::LineFromChar(long nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_EXLINEFROMCHAR, 0, nIndex); }

_AFXCMN2_INLINE void CRichEdit2Ctrl::SetSel(CHARRANGE &cr)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr); }

#ifndef _CHICAGO_
_AFXCMN2_INLINE long CRichEdit2Ctrl::FindText(DWORD dwFlags, FINDTEXTEX* pFindText) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_FINDTEXTEX, dwFlags, (LPARAM)pFindText); }
#endif // !_CHICAGO_

_AFXCMN2_INLINE long CRichEdit2Ctrl::FormatRange(FORMATRANGE* pfr, BOOL bDisplay)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_FORMATRANGE, (WPARAM)bDisplay, (LPARAM)pfr); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::GetEventMask() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETEVENTMASK, 0, 0L); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::GetLimitText() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0L); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::GetSelText(LPSTR lpBuf) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpBuf); }

_AFXCMN2_INLINE void CRichEdit2Ctrl::HideSelection(BOOL bHide, BOOL bPerm)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_HIDESELECTION, bHide, bPerm); }

_AFXCMN2_INLINE void CRichEdit2Ctrl::RequestResize()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REQUESTRESIZE, 0, 0L); }

_AFXCMN2_INLINE WORD CRichEdit2Ctrl::GetSelectionType() const
	{ ASSERT(::IsWindow(m_hWnd)); return (WORD)::SendMessage(m_hWnd, EM_SELECTIONTYPE, 0, 0L); }

_AFXCMN2_INLINE COLORREF CRichEdit2Ctrl::SetBackgroundColor(BOOL bSysColor, COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF)::SendMessage(m_hWnd, EM_SETBKGNDCOLOR, bSysColor, cr); }

_AFXCMN2_INLINE DWORD CRichEdit2Ctrl::SetEventMask(DWORD dwEventMask)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, EM_SETEVENTMASK, 0, dwEventMask); }

_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::SetOLECallback(IRichEditOleCallback* pCallback)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETOLECALLBACK, 0, (LPARAM)pCallback); }

_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::SetTargetDevice(HDC hDC, long lLineWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)hDC, lLineWidth); }

_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::SetTargetDevice(CDC &dc, long lLineWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)dc.m_hDC, lLineWidth); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::StreamIn(int nFormat, EDITSTREAM &es)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_STREAMIN, nFormat, (LPARAM)&es); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::StreamOut(int nFormat, EDITSTREAM &es)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_STREAMOUT, nFormat, (LPARAM)&es); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::GetTextLength() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, WM_GETTEXTLENGTH, NULL, NULL); }


#endif //_AFXCMN2_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\wordpvw.cpp ===
// wordpvw.cpp : implementation of the CWordPadView class
//
// Copyright (C) 1992-1999 Microsoft Corporation


#include "stdafx.h"
#include "wordpad.h"
#include "cntritem.h"
#include "srvritem.h"

#include "wordpdoc.h"
#include "wordpvw.h"
#include "formatta.h"
#include "datedial.h"
#include "formatpa.h"
#include "formatba.h"
#include "ruler.h"
#include "strings.h"
#include "colorlis.h"
#include "pageset.h"
#include <penwin.h>
#include "fixhelp.h"

#include <afxprntx.h>
#include "dlgprnt2.cpp"
#ifndef PD_CURRENTPAGE
#define PD_CURRENTPAGE                 0x00400000
#define PD_NOCURRENTPAGE               0x00800000
#endif

extern CLIPFORMAT cfEmbeddedObject;
extern CLIPFORMAT cfRTO;

BOOL g_fInternalDragDrop = FALSE ;
BOOL g_fRightButtonDrag = FALSE;

#ifdef _DEBUG
#undef THIS_FILE
#endif


BOOL CWordPadView::m_bIsMirrored = FALSE;


BOOL CCharFormat::operator==(CCharFormat& cf)
{
    return
        dwMask == cf.dwMask
        && dwEffects == cf.dwEffects
        && yHeight == cf.yHeight
        && yOffset == cf.yOffset
        && crTextColor == cf.crTextColor
        && bPitchAndFamily == cf.bPitchAndFamily
        && (lstrcmp(szFaceName, cf.szFaceName) == 0);
}

BOOL CParaFormat::operator==(PARAFORMAT& pf)
{
    if(
        dwMask != pf.dwMask
        || wNumbering != pf.wNumbering
        || wReserved != pf.wReserved
        || dxStartIndent != pf.dxStartIndent
        || dxRightIndent != pf.dxRightIndent
        || dxOffset != pf.dxOffset
        || cTabCount != pf.cTabCount
        )
    {
        return FALSE;
    }
    for (int i=0;i<pf.cTabCount;i++)
    {
        if (rgxTabs[i] != pf.rgxTabs[i])
            return FALSE;
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadView

IMPLEMENT_DYNCREATE(CWordPadView, CRichEdit2View)

//WM_WININICHANGE -- default printer might have changed
//WM_FONTCHANGE -- pool of fonts changed
//WM_DEVMODECHANGE -- printer settings changes

BEGIN_MESSAGE_MAP(CWordPadView, CRichEdit2View)
ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
ON_COMMAND(ID_CANCEL_EDIT_CNTR, OnCancelEditCntr)
ON_COMMAND(ID_CANCEL_EDIT_SRVR, OnCancelEditSrvr)
//{{AFX_MSG_MAP(CWordPadView)
ON_COMMAND(ID_PAGE_SETUP, OnPageSetup)
ON_COMMAND(ID_CHAR_BOLD, OnCharBold)
ON_UPDATE_COMMAND_UI(ID_CHAR_BOLD, OnUpdateCharBold)
ON_COMMAND(ID_CHAR_ITALIC, OnCharItalic)
ON_UPDATE_COMMAND_UI(ID_CHAR_ITALIC, OnUpdateCharItalic)
ON_COMMAND(ID_CHAR_UNDERLINE, OnCharUnderline)
ON_UPDATE_COMMAND_UI(ID_CHAR_UNDERLINE, OnUpdateCharUnderline)
ON_COMMAND(ID_PARA_CENTER, OnParaCenter)
ON_UPDATE_COMMAND_UI(ID_PARA_CENTER, OnUpdateParaCenter)
ON_COMMAND(ID_PARA_LEFT, OnParaLeft)
ON_UPDATE_COMMAND_UI(ID_PARA_LEFT, OnUpdateParaLeft)
ON_COMMAND(ID_PARA_RIGHT, OnParaRight)
ON_UPDATE_COMMAND_UI(ID_PARA_RIGHT, OnUpdateParaRight)
ON_WM_CREATE()
ON_COMMAND(ID_INSERT_DATE_TIME, OnInsertDateTime)
ON_COMMAND(ID_FORMAT_PARAGRAPH, OnFormatParagraph)
ON_COMMAND(ID_FORMAT_FONT, OnFormatFont)
ON_COMMAND(ID_EDIT_PASTE_SPECIAL, OnEditPasteSpecial)
ON_COMMAND(ID_OLE_EDIT_PROPERTIES, OnEditProperties)
ON_COMMAND(ID_EDIT_FIND, OnEditFind)
ON_COMMAND(ID_EDIT_REPLACE, OnEditReplace)
ON_COMMAND(ID_FORMAT_TABS, OnFormatTabs)
ON_COMMAND(ID_COLOR16, OnColorDefault)
ON_WM_TIMER()
ON_WM_DESTROY()
ON_WM_MEASUREITEM()
ON_COMMAND(ID_PEN_BACKSPACE, OnPenBackspace)
ON_COMMAND(ID_PEN_NEWLINE, OnPenNewline)
ON_COMMAND(ID_PEN_PERIOD, OnPenPeriod)
ON_COMMAND(ID_PEN_SPACE, OnPenSpace)
ON_WM_SIZE()
ON_WM_KEYDOWN()
ON_COMMAND(ID_FILE_PRINT, OnFilePrint)
ON_COMMAND(ID_FILE_PRINT_DIRECT, OnFilePrint)
ON_WM_DROPFILES()
ON_COMMAND(ID_PEN_LENS, OnPenLens)
ON_COMMAND(ID_PEN_TAB, OnPenTab)
ON_COMMAND(ID_DELAYED_INVALIDATE, OnDelayedInvalidate)
ON_WM_PALETTECHANGED()
ON_WM_QUERYNEWPALETTE()
ON_WM_WININICHANGE()
//}}AFX_MSG_MAP
// Standard printing commands
ON_COMMAND(ID_INSERT_BULLET, CRichEdit2View::OnBullet)
ON_UPDATE_COMMAND_UI(ID_INSERT_BULLET, CRichEdit2View::OnUpdateBullet)
ON_COMMAND(ID_FILE_PRINT_PREVIEW, OnFilePrintPreview)
ON_COMMAND_RANGE(ID_COLOR0, ID_COLOR16, OnColorPick)
ON_EN_CHANGE(AFX_IDW_PANE_FIRST, OnEditChange)
ON_WM_MOUSEACTIVATE()
ON_REGISTERED_MESSAGE(CWordPadApp::m_nPrinterChangedMsg, OnPrinterChangedMsg)
ON_NOTIFY(FN_GETFORMAT, ID_VIEW_FORMATBAR, OnGetCharFormat)
ON_NOTIFY(FN_SETFORMAT, ID_VIEW_FORMATBAR, OnSetCharFormat)
ON_NOTIFY(NM_SETFOCUS, ID_VIEW_FORMATBAR, OnBarSetFocus)
ON_NOTIFY(NM_KILLFOCUS, ID_VIEW_FORMATBAR, OnBarKillFocus)
ON_NOTIFY(NM_RETURN, ID_VIEW_FORMATBAR, OnBarReturn)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWordPadView construction/destruction

CWordPadView::CWordPadView()
{
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    m_uTimerID = 0;
    m_bDelayUpdateItems = FALSE;
    m_bOnBar = FALSE;
    m_bInPrint = FALSE;
    m_nPasteType = 0;
    m_rectMargin = theApp.m_rectPageMargin;
}

BOOL CWordPadView::PreCreateWindow(CREATESTRUCT& cs)
{
    BOOL bRes = CRichEdit2View::PreCreateWindow(cs);
    cs.style |= ES_SELECTIONBAR;
    return bRes;
}



/////////////////////////////////////////////////////////////////////////////
// CWordPadView attributes

BOOL CWordPadView::IsFormatText()
{
    // this function checks to see if any formatting is not default text
    BOOL bRes = FALSE;
    CHARRANGE cr;
    CCharFormat cf;
    CParaFormat pf;
    GetRichEditCtrl().GetSel(cr);
    GetRichEditCtrl().HideSelection(TRUE, FALSE);
    GetRichEditCtrl().SetSel(0,-1);

    if (!(GetRichEditCtrl().GetSelectionType() & (SEL_OBJECT|SEL_MULTIOBJECT)))
    {
        GetRichEditCtrl().GetSelectionCharFormat(cf);

        //
        // Richedit sometimes returns these masks which are not important to us
        //

        cf.dwMask &= ~(CFM_LINK | CFM_CHARSET) ;

        //
        // Richedit sometimes returns the wrong thing here.  This is not that
        // important for the CHARFORMAT comparison, but it fouls things up if
        // we don't work around it.
        //

        CCharFormat   defCF;
        GetDefaultFont(defCF, TRUE);

        cf.bPitchAndFamily = defCF.bPitchAndFamily ;

        if (cf == defCF)
        {
            GetRichEditCtrl().GetParaFormat(pf);

            // These get reset in SetDefaultFont so be symmetric.
            pf.dwMask &= ~ (PFM_RTLPARA | PFM_ALIGNMENT);

            if (pf == m_defParaFormat)
                bRes = TRUE;
        }
    }

    GetRichEditCtrl().SetSel(cr);
    GetRichEditCtrl().HideSelection(FALSE, FALSE);
    return bRes;
}

HMENU CWordPadView::GetContextMenu(WORD, LPOLEOBJECT, CHARRANGE* )
{
    CRichEdit2CntrItem* pItem = GetSelectedItem();
    if (pItem == NULL || !pItem->IsInPlaceActive())
    {
        CMenu menuText;
        menuText.LoadMenu(IDR_TEXT_POPUP);
        CMenu* pMenuPopup = menuText.GetSubMenu(0);
        menuText.RemoveMenu(0, MF_BYPOSITION);
        if (!GetSystemMetrics(SM_PENWINDOWS))
        {
            //delete pen specific stuff
            // remove Insert Keystrokes
            pMenuPopup->DeleteMenu(ID_PEN_LENS, MF_BYCOMMAND);
            int nIndex = pMenuPopup->GetMenuItemCount()-1; //index of last item
            // remove Edit Text...
            pMenuPopup->DeleteMenu(nIndex, MF_BYPOSITION);
            // remove separator
            pMenuPopup->DeleteMenu(nIndex-1, MF_BYPOSITION);
        }
        return pMenuPopup->Detach();
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadView operations
void CWordPadView::MirrorTheContainer(BOOL bMirror)
{
    // if WordPad not mirrored, then don't do anything
    LONG lExStyle;
    if (!m_bIsMirrored)
       return;
        
    CWnd *pWnd = AfxGetMainWnd() ;
    if (NULL == pWnd)
        return ;
    lExStyle = (LONG)::GetWindowLongPtr(pWnd->m_hWnd , GWL_EXSTYLE);
    if (bMirror)
       lExStyle |=  WS_EX_LAYOUTRTL;
    else
       lExStyle &= ~WS_EX_LAYOUTRTL;
   ::SetWindowLongPtr(pWnd->m_hWnd , GWL_EXSTYLE , lExStyle);
}

void CWordPadView::WrapChanged()
{
    CWaitCursor wait;
    CFrameWnd* pFrameWnd = GetParentFrame();
    ASSERT(pFrameWnd != NULL);
    pFrameWnd->SetMessageText(IDS_FORMATTING);
    CWnd* pBarWnd = pFrameWnd->GetMessageBar();
    if (pBarWnd != NULL)
        pBarWnd->UpdateWindow();

    CRichEdit2View::WrapChanged();

    pFrameWnd->SetMessageText(AFX_IDS_IDLEMESSAGE);
    if (pBarWnd != NULL)
        pBarWnd->UpdateWindow();
}

void CWordPadView::SetUpdateTimer()
{
    if (m_uTimerID != 0) // if outstanding timer kill it
        KillTimer(m_uTimerID);
    m_uTimerID = SetTimer(1, 1000, NULL); //set a timer for 1000 milliseconds
    if (m_uTimerID == 0) // no timer available so force update now
        GetDocument()->UpdateAllItems(NULL);
    else
        m_bDelayUpdateItems = TRUE;
}

void CWordPadView::DeleteContents()
{
    ASSERT_VALID(this);
    ASSERT(m_hWnd != NULL);
    CRichEdit2View::DeleteContents();
    SetDefaultFont(IsTextType(GetDocument()->m_nNewDocType));
}

void CWordPadView::SetDefaultFont(BOOL bText)
{
    ASSERT_VALID(this);
    ASSERT(m_hWnd != NULL);

    CCharFormat cf;

    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    // set the default character format -- the FALSE makes it the default
    GetDefaultFont(cf, bText);
    GetRichEditCtrl().SetSel(0,-1);
    GetRichEditCtrl().SetDefaultCharFormat(cf);
    GetRichEditCtrl().SetSelectionCharFormat(cf);

    //
    // Setting the charformat with a NULL font name automagically sets
    // the reading direction and alignment.  Don't muck with it.
    //

    m_defParaFormat.dwMask &= ~ (PFM_RTLPARA | PFM_ALIGNMENT);
    
    GetRichEditCtrl().SetParaFormat(m_defParaFormat);

    GetRichEditCtrl().SetSel(0,0);
    GetRichEditCtrl().EmptyUndoBuffer();
    GetRichEditCtrl().SetModify(FALSE);
    ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadView drawing

/////////////////////////////////////////////////////////////////////////////
// CWordPadView printing

void CWordPadView::OnBeginPrinting(CDC* pDC, CPrintInfo* printInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    // initialize page start vector
    ASSERT(m_aPageStart.GetSize() == 0);
    ASSERT(NULL != printInfo);
    ASSERT(NULL != printInfo->m_pPD);

    OnPrinterChanged(*pDC);

    //
    // Copy some flags from PRINTDLGEX to PRINTDLG that mfc doesn't
    //

    C_PrintDialogEx *pPDEx = (C_PrintDialogEx *) printInfo->m_pPD;
    pPDEx->m_pd.Flags |= pPDEx->m_pdex.Flags & PD_SELECTION;

    m_aPageStart.Add(0);
    ASSERT(m_aPageStart.GetSize() > 0);

    if (printInfo->m_pPD->PrintSelection())
    {
        CHARRANGE   range;

        GetRichEditCtrl().GetSel(range);
        m_aPageStart[0] = range.cpMin;
    }

    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache

    ASSERT_VALID(this);
}

void CWordPadView::OnPrint(CDC* pDC, CPrintInfo* pInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    ASSERT(pInfo != NULL);
    ASSERT(pInfo->m_bContinuePrinting);
    ASSERT(NULL != pInfo->m_pPD);

    UINT nPage              = pInfo->m_nCurPage;
    ASSERT(nPage <= (UINT)m_aPageStart.GetSize());

    long nIndex             = (long) m_aPageStart[nPage-1];
    BOOL bPrintSelection    = pInfo->m_pPD->PrintSelection();
    long nFinalCharIndex;

    if (bPrintSelection)
    {
        CHARRANGE range;

        GetRichEditCtrl().GetSel(range);

        nFinalCharIndex = range.cpMax;
    }
    else
    {
        GETTEXTLENGTHEX textlen;

        textlen.flags = GTL_DEFAULT;
#ifdef UNICODE
        textlen.codepage = 1200;            // Unicode code page
#else
        textlen.codepage = CP_ACP;
#endif

        nFinalCharIndex = (long)this->SendMessage(
            EM_GETTEXTLENGTHEX,
            (WPARAM) &textlen,
            0);
    }

    // print as much as possible in the current page.
    nIndex = PrintPage(pDC, nIndex, nFinalCharIndex);

    if (nIndex >= nFinalCharIndex)
    {
        TRACE0("End of Document\n");
        pInfo->SetMaxPage(nPage);
        pInfo->m_bContinuePrinting = FALSE;
    }

    // update pagination information for page just printed
    if (nPage == (UINT)m_aPageStart.GetSize())
    {
        if (nIndex < nFinalCharIndex)
            m_aPageStart.Add(nIndex);
    }
    else
    {
        ASSERT(nPage+1 <= (UINT)m_aPageStart.GetSize());
        ASSERT(nIndex == (long)m_aPageStart[nPage+1-1]);
    }

    if (pInfo != NULL && pInfo->m_bPreview)
        DrawMargins(pDC);
}

void CWordPadView::DrawMargins(CDC* pDC)
{
    if (pDC->m_hAttribDC != NULL)
    {
        CRect rect;
        rect.left = m_rectMargin.left;
        rect.right = m_sizePaper.cx - m_rectMargin.right;
        rect.top = m_rectMargin.top;
        rect.bottom = m_sizePaper.cy - m_rectMargin.bottom;
        //rect in twips
        int logx = ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSX);
        int logy = ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSY);
        rect.left = MulDiv(rect.left, logx, 1440);
        rect.right = MulDiv(rect.right, logx, 1440);
        rect.top = MulDiv(rect.top, logy, 1440);
        rect.bottom = MulDiv(rect.bottom, logy, 1440);
        CPen pen(PS_DOT, 0, pDC->GetTextColor());
        CPen* ppen = pDC->SelectObject(&pen);
        pDC->MoveTo(0, rect.top);
        pDC->LineTo(10000, rect.top);
        pDC->MoveTo(rect.left, 0);
        pDC->LineTo(rect.left, 10000);
        pDC->MoveTo(0, rect.bottom);
        pDC->LineTo(10000, rect.bottom);
        pDC->MoveTo(rect.right, 0);
        pDC->LineTo(rect.right, 10000);
        pDC->SelectObject(ppen);
    }
}

BOOL CWordPadView::OnPreparePrinting(CPrintInfo* pInfo)
{
    CWordPadApp *pApp = NULL ;

    //
    // Swap out the default print dialog with the new PrintDlgEx version.
    // Hopefully MFC will come up with a better way to do this sometime.
    //

    C_PrintDialogEx *pPDEx = new C_PrintDialogEx(FALSE, PD_RETURNDC | PD_ALLPAGES | PD_NOSELECTION | PD_NOCURRENTPAGE | PD_USEDEVMODECOPIESANDCOLLATE);

    if (NULL == pPDEx)
        return FALSE;

    m_oldprintdlg = pInfo->m_pPD;
    pInfo->m_pPD = pPDEx;
    pInfo->SetMinPage(1);
    pInfo->SetMaxPage(0xffff);

    pInfo->m_pPD->m_pd.nFromPage = 1;
    pInfo->m_pPD->m_pd.nToPage = 1;

    pApp = (CWordPadApp *) AfxGetApp() ;

    if (NULL != pApp)
    {
        if ( (pApp->cmdInfo.m_nShellCommand == CCommandLineInfo::FilePrintTo) ||
            (pApp->cmdInfo.m_nShellCommand == CCommandLineInfo::FilePrint) )
        {
            if (pInfo->m_pPD->m_pd.hDevNames == NULL)
            {
                HGLOBAL hDn = pApp->GetDevNames() ;

                if (hDn != NULL)
                {
                    pInfo->m_pPD->m_pd.hDevNames = hDn ;
                }
            }
        }
    }

    if (SEL_EMPTY != GetRichEditCtrl().GetSelectionType())
    {
        pInfo->m_pPD->m_pd.Flags = pInfo->m_pPD->m_pd.Flags & ~PD_NOSELECTION;
        pPDEx->m_pdex.Flags = pPDEx->m_pdex.Flags & ~PD_NOSELECTION;
    }

    return DoPreparePrinting(pInfo);
}

void CWordPadView::OnEndPrinting(CDC*dc, CPrintInfo*pInfo)
{
    ASSERT_VALID(this);

    //
    // Swap the original print dlg back
    //

    delete (C_PrintDialogEx *) pInfo->m_pPD;
    pInfo->m_pPD = m_oldprintdlg;
    m_oldprintdlg = NULL;

    CRichEdit2View::OnEndPrinting(dc, pInfo);
}

void CWordPadView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    ASSERT(pInfo != NULL);  // overriding OnPaint -- never get this.

    if (!pInfo->m_bContinuePrinting)
        return;

    pDC->SetMapMode(MM_TEXT);

    if (pInfo->m_nCurPage > (UINT)m_aPageStart.GetSize() &&
        !PaginateTo(pDC, pInfo))
    {
        // can't paginate to that page, thus cannot print it.
        pInfo->m_bContinuePrinting = FALSE;
    }
    ASSERT_VALID(this);
}

BOOL CWordPadView::PaginateTo(CDC* pDC, CPrintInfo* pInfo)
// attempts pagination to pInfo->m_nCurPage, TRUE == success
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);

    CRect rectSave = pInfo->m_rectDraw;
    UINT nPageSave = pInfo->m_nCurPage;
    ASSERT(nPageSave > 1);
    ASSERT(nPageSave >= (UINT)m_aPageStart.GetSize());
    pDC->IntersectClipRect(0, 0, 0, 0);
    pInfo->m_nCurPage = (UINT)m_aPageStart.GetSize();
    while (pInfo->m_nCurPage < nPageSave)
    {
        ASSERT(pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize());
        OnPrepareDC(pDC, pInfo);
        ASSERT(pInfo->m_bContinuePrinting);
        pInfo->m_rectDraw.SetRect(0, 0,
            pDC->GetDeviceCaps(HORZRES), pDC->GetDeviceCaps(VERTRES));
        pDC->DPtoLP(&pInfo->m_rectDraw);
        OnPrint(pDC, pInfo);
        if (pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize())
            break;
        ++pInfo->m_nCurPage;
    }
    BOOL bResult = pInfo->m_nCurPage == nPageSave;
    pInfo->m_nCurPage = nPageSave;
    pInfo->m_rectDraw = rectSave;
    pDC->SelectClipRgn(NULL) ;
    ASSERT_VALID(this);
    return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

inline int roundleast(int n)
{
    int mod = n%10;
    n -= mod;
    if (mod >= 5)
        n += 10;
    else if (mod <= -5)
        n -= 10;
    return n;
}

static void RoundRect(FAR UNALIGNED RECT *r1)
{
    r1->left = roundleast(r1->left);
    r1->right = roundleast(r1->right);
    r1->top = roundleast(r1->top);
    r1->bottom = roundleast(r1->bottom);
}

static void MulDivRect(FAR UNALIGNED RECT *r1, FAR UNALIGNED RECT * r2, int num, int div)
{
    r1->left = MulDiv(r2->left, num, div);
    r1->top = MulDiv(r2->top, num, div);
    r1->right = MulDiv(r2->right, num, div);
    r1->bottom = MulDiv(r2->bottom, num, div);
}

void CWordPadView::OnPageSetup()
{
    theApp.EnsurePrinterIsInitialized();

    CPageSetupDialog dlg;
    PAGESETUPDLG& psd = dlg.m_psd;
    BOOL bMetric = theApp.GetUnits() == 1; //centimeters
    BOOL fUpdateWrap = FALSE ;
    psd.Flags |= PSD_MARGINS | (bMetric ? PSD_INHUNDREDTHSOFMILLIMETERS :
    PSD_INTHOUSANDTHSOFINCHES);
    int nUnitsPerInch = bMetric ? 2540 : 1000;
    MulDivRect(&psd.rtMargin, m_rectMargin, nUnitsPerInch, 1440);
    RoundRect(&psd.rtMargin);
    // get the current device from the app
    PRINTDLG pd;
    pd.hDevNames = NULL;
    pd.hDevMode = NULL;
    theApp.GetPrinterDeviceDefaults(&pd);
    psd.hDevNames = pd.hDevNames;
    psd.hDevMode = pd.hDevMode;

    SetHelpFixHook() ;

    if (dlg.DoModal() == IDOK)
    {
        RoundRect(&psd.rtMargin);
        MulDivRect(m_rectMargin, &psd.rtMargin, 1440, nUnitsPerInch);
        theApp.m_rectPageMargin = m_rectMargin;

        //
        // SelectPrinter will free the existing devnames and devmodes if the
        // third parameter is TRUE.  We don't want to do that because the
        // print dialog frees them and allocates new ones.
        //

        theApp.SelectPrinter(psd.hDevNames, psd.hDevMode, FALSE);
        theApp.NotifyPrinterChanged();
        fUpdateWrap = TRUE ;
    }

    RemoveHelpFixHook() ;

    // PageSetupDlg failed
    if (CommDlgExtendedError() != 0)
    {
        CPageSetupDlg dlg;
        dlg.m_nBottomMargin = m_rectMargin.bottom;
        dlg.m_nLeftMargin = m_rectMargin.left;
        dlg.m_nRightMargin = m_rectMargin.right;
        dlg.m_nTopMargin = m_rectMargin.top;
        if (dlg.DoModal() == IDOK)
        {
            m_rectMargin.SetRect(dlg.m_nLeftMargin, dlg.m_nTopMargin,
                dlg.m_nRightMargin, dlg.m_nBottomMargin);
            // m_page will be changed at this point
            theApp.m_rectPageMargin = m_rectMargin;
            theApp.NotifyPrinterChanged();
            fUpdateWrap = TRUE ;
        }
    }

    if (fUpdateWrap)
    {
        CRichEdit2View::WrapChanged();
    }
}

/////////////////////////////////////////////////////////////////////////////
// OLE Server support

// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.  Here,
//  the server (not the container) causes the deactivation.
void CWordPadView::OnCancelEditSrvr()
{
    GetDocument()->OnDeactivateUI(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadView diagnostics

#ifdef _DEBUG
void CWordPadView::AssertValid() const
{
    CRichEdit2View::AssertValid();
}

void CWordPadView::Dump(CDumpContext& dc) const
{
    CRichEdit2View::Dump(dc);
}

CWordPadDoc* CWordPadView::GetDocument() // non-debug version is inline
{
    return (CWordPadDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWordPadView message helpers

/////////////////////////////////////////////////////////////////////////////
// CWordPadView message handlers

int CWordPadView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CRichEdit2View::OnCreate(lpCreateStruct) == -1)
        return -1;
    theApp.m_listPrinterNotify.AddTail(m_hWnd);

    if (theApp.m_bWordSel)
        GetRichEditCtrl().SetOptions(ECOOP_OR, ECO_AUTOWORDSELECTION);
    else
        GetRichEditCtrl().SetOptions(ECOOP_AND, ~(DWORD)ECO_AUTOWORDSELECTION);
    //      GetRichEditCtrl().SetOptions(ECOOP_OR, ECO_SELECTIONBAR);

    GetRichEditCtrl().GetParaFormat(m_defParaFormat);
    m_defParaFormat.cTabCount = 0;

    //
    // Insert our own wrapper interface callback here to get around MFC defaults
    //

    VERIFY(GetRichEditCtrl().SetOLECallback(&m_xWordPadRichEditOleCallback));

    
    if (::GetWindowLongPtr(::GetParent(m_hWnd) , GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
           m_bIsMirrored = TRUE;

    return 0;
}

void CWordPadView::GetDefaultFont(CCharFormat& cf, BOOL bText)
{
    USES_CONVERSION;
    CString strDefFont;
    if (bText)
        VERIFY(strDefFont.LoadString(IDS_DEFAULTTEXTFONT));
    ASSERT(cf.cbSize == sizeof(CHARFORMAT));
    cf.dwMask = CFM_BOLD|CFM_ITALIC|CFM_UNDERLINE|CFM_STRIKEOUT|CFM_SIZE|
        CFM_COLOR|CFM_OFFSET|CFM_PROTECTED;
    cf.dwEffects = CFE_AUTOCOLOR;
    cf.yHeight = 200; //10pt
    cf.yOffset = 0;
    cf.crTextColor = RGB(0, 0, 0);
    cf.bCharSet = 0;
    cf.bPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
    ASSERT(strDefFont.GetLength() < LF_FACESIZE);
    lstrcpyn(cf.szFaceName, strDefFont, LF_FACESIZE);
    cf.dwMask |= CFM_FACE;
}

void CWordPadView::OnInsertDateTime()
{
    // When changing the paragraph direction by Ctrl+Shift the m_bSyncParaFormat
    // will not reset. we reset it to force GetParaFormatSelection read current
    // paragraph direction by calling GetRichEditCtrl().GetParaFormat()
    m_bSyncParaFormat = TRUE;

    CDateDialog dlg(NULL , GetParaFormatSelection());
    if (dlg.DoModal() == IDOK)
    {
        GetRichEditCtrl().ReplaceSel(dlg.m_strSel, TRUE);
    }
}

void CWordPadView::OnFormatParagraph()
{
    CFormatParaDlg dlg(GetParaFormatSelection());
    dlg.m_nWordWrap = m_nWordWrap;
    if (dlg.DoModal() == IDOK)
        SetParaFormat(dlg.m_pf);
}

void CWordPadView::OnFormatTabs()
{
    CFormatTabDlg dlg(GetParaFormatSelection());
    if (dlg.DoModal() == IDOK)
        SetParaFormat(dlg.m_pf);
}

void CWordPadView::OnTextNotFound(LPCTSTR /* UNREF lpStr */)
{
    ASSERT_VALID(this);

    // HACKHACK:
    //
    // When AfxMessageBox is called MFC disables the find dialog and pops up
    // the message box.  After the user dismisses it, User tries to set the
    // focus back to the window that had it before the message box, however
    // this window is disabled so eventually what ends up happening is that
    // the find dialog, and not any control in it, has the focus.  This screws
    // up alt hotkeys for buttons and such.

    HWND h = ::GetFocus();
    AfxMessageBox(IDS_FINISHED_SEARCH,MB_OK|MB_ICONINFORMATION);
    ::SetFocus(h);
}

void CWordPadView::OnColorPick(UINT nID)
{
    CRichEdit2View::OnColorPick(CColorMenu::GetColor(nID));
}

void CWordPadView::OnTimer(UINT_PTR nIDEvent)
{
    if (m_uTimerID != nIDEvent) // not our timer
        CRichEdit2View::OnTimer(nIDEvent);
    else
    {
        KillTimer(m_uTimerID); // kill one-shot timer
        m_uTimerID = 0;
        if (m_bDelayUpdateItems)
            GetDocument()->UpdateAllItems(NULL);
        m_bDelayUpdateItems = FALSE;
    }
}

void CWordPadView::OnEditChange()
{
    SetUpdateTimer();
}

void CWordPadView::OnDestroy()
{
    POSITION pos = theApp.m_listPrinterNotify.Find(m_hWnd);
    ASSERT(pos != NULL);
    theApp.m_listPrinterNotify.RemoveAt(pos);

    if (m_uTimerID != 0) // if outstanding timer kill it
        OnTimer(m_uTimerID);
    ASSERT(m_uTimerID == 0);

    CRichEdit2View::OnDestroy();

    CWnd *pWnd = AfxGetMainWnd() ;

    if (NULL == pWnd)
    {
        return ;
    }

    pWnd = pWnd->GetTopLevelParent() ;

    if (NULL == pWnd)
    {
        return ;
    }

    ::WinHelp(pWnd->m_hWnd, WORDPAD_HELP_FILE, HELP_QUIT, 0) ;
}

void CWordPadView::CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType)
{
    CRichEdit2View::CalcWindowRect(lpClientRect, nAdjustType);

    if (theApp.m_bWin4 && nAdjustType != 0 && (GetStyle() & WS_VSCROLL))
        lpClientRect->right--;

    // if the ruler is visible then slide the view up under the ruler to avoid
    // showing the top border of the view
    if (GetExStyle() & WS_EX_CLIENTEDGE)
    {
        CFrameWnd* pFrame = GetParentFrame();
        if (pFrame != NULL)
        {
            CRulerBar* pBar = (CRulerBar*)pFrame->GetControlBar(ID_VIEW_RULER);
            if (pBar != NULL)
            {
                BOOL bVis = pBar->IsVisible();
                if (pBar->m_bDeferInProgress)
                    bVis = !bVis;
                if (bVis)
                    lpClientRect->top -= 2;
            }
        }
    }
}

void CWordPadView::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMIS)
{
    lpMIS->itemID = (UINT)(WORD)lpMIS->itemID;
    CRichEdit2View::OnMeasureItem(nIDCtl, lpMIS);
}

void CWordPadView::OnPenBackspace()
{
    SendMessage(WM_KEYDOWN, VK_BACK, 0);
    SendMessage(WM_KEYUP, VK_BACK, 0);
}

void CWordPadView::OnPenNewline()
{
    SendMessage(WM_CHAR, '\n', 0);
}

void CWordPadView::OnPenPeriod()
{
    SendMessage(WM_CHAR, '.', 0);
}

void CWordPadView::OnPenSpace()
{
    SendMessage(WM_CHAR, ' ', 0);
}

void CWordPadView::OnPenTab()
{
    SendMessage(WM_CHAR, VK_TAB, 0);
}

void CWordPadView::OnDelayedInvalidate()
{
    Invalidate() ;
}

void CWordPadView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if (nChar == VK_F10 && GetKeyState(VK_SHIFT) < 0)
    {
        long nStart, nEnd;
        GetRichEditCtrl().GetSel(nStart, nEnd);
        CPoint pt = GetRichEditCtrl().GetCharPos(nEnd);
        SendMessage(WM_CONTEXTMENU, (WPARAM)m_hWnd, MAKELPARAM(pt.x, pt.y));
    }

    CRichEdit2View::OnKeyDown(nChar, nRepCnt, nFlags);
}

HRESULT CWordPadView::GetClipboardData(CHARRANGE* lpchrg, DWORD /*reco*/,
                                       LPDATAOBJECT lpRichDataObj,     LPDATAOBJECT* lplpdataobj)
{
    CHARRANGE& cr = *lpchrg;

    if (NULL == lpRichDataObj)
        return E_INVALIDARG;

    if ((cr.cpMax - cr.cpMin == 1) &&
        GetRichEditCtrl().GetSelectionType() == SEL_OBJECT)
    {
        return E_NOTIMPL;
    }

    BeginWaitCursor();
    //create the data source
    COleDataSource* pDataSource = new COleDataSource;

    // put the formats into the data source
    LPENUMFORMATETC lpEnumFormatEtc;
    lpRichDataObj->EnumFormatEtc(DATADIR_GET, &lpEnumFormatEtc);
    if (lpEnumFormatEtc != NULL)
    {
        FORMATETC etc;
        while (lpEnumFormatEtc->Next(1, &etc, NULL) == S_OK)
        {
            STGMEDIUM stgMedium;
            lpRichDataObj->GetData(&etc, &stgMedium);
            pDataSource->CacheData(etc.cfFormat, &stgMedium, &etc);
        }
        lpEnumFormatEtc->Release();
    }

    CEmbeddedItem item(GetDocument(), cr.cpMin, cr.cpMax);
    item.m_lpRichDataObj = lpRichDataObj;
    // get wordpad formats
    item.GetClipboardData(pDataSource);

    // get the IDataObject from the data source
    *lplpdataobj =  (LPDATAOBJECT)pDataSource->GetInterface(&IID_IDataObject);

    EndWaitCursor();
    return S_OK;
}


HRESULT CWordPadView::PasteHDROPFormat(HDROP hDrop)
{
    HRESULT hr = S_OK ;
    UINT i ;
    TCHAR szFile[MAX_PATH + 1] ;
    CHARRANGE cr ;
    LONG tmp ;
    UINT cFiles ;

    cFiles = DragQueryFile(hDrop, (UINT) -1, NULL, 0) ;

    GetRichEditCtrl().GetSel(cr);

    tmp = cr.cpMin ;

    for (i=0; i<cFiles; i++)
    {
        ::DragQueryFile(hDrop, i, szFile, MAX_PATH) ;

        if (FILE_ATTRIBUTE_DIRECTORY == GetFileAttributes(szFile))
        {
            continue ;
        }

        //
        // Fix the selection state up so that multiple objects insert
        // at the right spot
        //

        cr.cpMin = cr.cpMax ;

        GetRichEditCtrl().SetSel(cr);

        //
        // Insert from file
        //

        InsertFileAsObject(szFile) ;
    }

    GetRichEditCtrl().SetSel(cr);

    return hr ;
}

HRESULT CWordPadView::QueryAcceptData(LPDATAOBJECT lpdataobj,
                                      CLIPFORMAT* lpcfFormat, DWORD reco, BOOL bReally,
                                      HGLOBAL hMetaPict)
{
    HRESULT hr = S_OK ;

    if (!bReally)
    {
        g_fRightButtonDrag = 0x8000 & GetAsyncKeyState(
            GetSystemMetrics(SM_SWAPBUTTON)
            ? VK_LBUTTON
            : VK_RBUTTON);
    }

    //
    // If we are doing an inproc drag-drop, we want our drop
    // effect to be DROPEFFECT_MOVE but if we are drag-dropping
    // from another application, we want our effect to be
    // DROPEFFECT_COPY -- in particular so that we don't delete
    // icons dragged from the explorer or text dragged from Word!
    //
    // The reason for this hack is that richedit doesn't supply
    // any mechanism for us to determine whether or not we are
    // both the drop source and the drop target.
    //

    if (!bReally)
    {
        LPUNKNOWN pUnk = NULL ;

        if (S_OK == lpdataobj->QueryInterface(
            IID_IProxyManager,
            (LPVOID *) &pUnk))
        {
            //
            // We got an IProxyManager pointer, so we are NOT doing an
            // inproc drag drop
            //

            pUnk->Release() ;

            g_fInternalDragDrop = FALSE ;
        }
        else
        {
            g_fInternalDragDrop = TRUE ;
        }
    }
    else
    {
        g_fInternalDragDrop = FALSE ;
    }

    //
    // Check for native data first
    //

    if (bReally && *lpcfFormat == 0 && (m_nPasteType == 0))
    {
        COleDataObject dataobj;
        dataobj.Attach(lpdataobj, FALSE);
        if (!dataobj.IsDataAvailable(cfRTO)) // native avail, let richedit do as it wants
        {
            if (dataobj.IsDataAvailable(cfEmbeddedObject))
            {
                if (PasteNative(lpdataobj))
                {
                    hr = S_FALSE ;

                    goto errRet ;
                }
            }
        }
    }

    //
    // We need to support HDROP format from the explorer
    // and the desktop
    //

    if (bReally)
    {
        FORMATETC fe ;

        fe.cfFormat = CF_HDROP ;
        fe.ptd = NULL ;
        fe.dwAspect = DVASPECT_CONTENT ;
        fe.lindex = -1 ;
        fe.tymed = TYMED_HGLOBAL ;

        if (S_OK == lpdataobj->QueryGetData(&fe))
        {
            STGMEDIUM sm ;

            sm.tymed = TYMED_NULL ;
            sm.hGlobal = (HGLOBAL) 0 ;
            sm.pUnkForRelease = NULL ;

            if (S_OK == lpdataobj->GetData(&fe, &sm))
            {
                //
                // If we have a single file in our HDROP data then
                // embed source might *also* be available in which case we
                // should just use the default richedit logic and
                // skip PasteHDROPFormat().  We should not ever get
                // embed source AND an HDROP data block containing
                // multiple files because OLE only supports one drop
                // source per drag-drop operation.  The default richedit
                // logic should handle all cases while dropping a single
                // file, we just have to special case things while dropping
                // multiple files.
                //

                if (DragQueryFile((HDROP) sm.hGlobal, (UINT) -1, NULL, 0) > 1)
                {
                    PasteHDROPFormat((HDROP) sm.hGlobal) ;
                    hr = S_FALSE ;
                }
                else
                {
                    hr = S_OK ;
                }

                ::ReleaseStgMedium(&sm) ;

                if (S_FALSE == hr)
                {
                    goto errRet ;
                }
            }
        }
    }

    //
    // If all else fails, let richedit give it a try
    //

    hr = CRichEdit2View::QueryAcceptData(lpdataobj, lpcfFormat, reco, bReally,
        hMetaPict);

errRet:

    if (bReally)
    {
        //
        // We post a message to ourselves here instead of just calling
        // ::Invalidate() because the richedit control doesn't always
        // repaint unless it is completely done with the data transfer operation.
        //

        PostMessage(WM_COMMAND, ID_DELAYED_INVALIDATE, 0) ;
    }

    return hr ;
}


BOOL CWordPadView::PasteNative(LPDATAOBJECT lpdataobj)
{
    // check data object for wordpad object
    // if true, pull out RTF directly

    FORMATETC etc = {NULL, NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE};
    etc.cfFormat = (CLIPFORMAT)cfEmbeddedObject;
    STGMEDIUM stgMedium = {TYMED_ISTORAGE, 0, NULL};

    // create an IStorage to transfer the data in
    LPLOCKBYTES lpLockBytes;
    if (FAILED(::CreateILockBytesOnHGlobal(NULL, TRUE, &lpLockBytes)))
        return FALSE;
    ASSERT(lpLockBytes != NULL);

    HRESULT hr = ::StgCreateDocfileOnILockBytes(lpLockBytes,
        STGM_SHARE_EXCLUSIVE|STGM_CREATE|STGM_READWRITE, 0, &stgMedium.pstg);
    lpLockBytes->Release(); //storage addref'd
    if (FAILED(hr))
        return FALSE;

    ASSERT(stgMedium.pstg != NULL);

    CLSID clsid;

    BOOL bRes = FALSE; //let richedit do what it wants

    if (SUCCEEDED(lpdataobj->GetDataHere(&etc, &stgMedium)) &&
        SUCCEEDED(ReadClassStg(stgMedium.pstg, &clsid)) &&
        clsid == GetDocument()->GetClassID())
    {
        //pull out RTF now
        // open Contents stream

        COleStreamFile file;
        CFileException fe;
        if (file.OpenStream(stgMedium.pstg, szContents,
            CFile::modeReadWrite|CFile::shareExclusive, &fe))
        {
            CRichEdit2Doc  *doc = GetDocument();
            BOOL            bRTF = doc->m_bRTF;
            BOOL            bUnicode = doc->m_bUnicode;

            // Force the "current" stream type to be rtf

            doc->m_bRTF = TRUE;
            doc->m_bUnicode = FALSE;

            // load it with CArchive (loads from Contents stream)
            CArchive loadArchive(&file, CArchive::load |
                CArchive::bNoFlushOnDelete);
            Stream(loadArchive, TRUE); //stream in selection

            // Restore the "current" stream type

            doc->m_bRTF = bRTF;
            doc->m_bUnicode = bUnicode;

            bRes = TRUE; // don't let richedit do anything
        }
    }
    ::ReleaseStgMedium(&stgMedium);
    return bRes;
}

// things to fix
// if format==0 we are doing a straight EM_PASTE
//      look for native formats
//              richedit specific -- allow richedit to handle (these will be first)
//              look for RTF, CF_TEXT.  If there paste special as these
//      Do standard OLE scenario

// if pasting a particular format (format != 0)
//      if richedit specific, allow through
//      if RTF, CF_TEXT. paste special
//      if OLE format, do standard OLE scenario


void CWordPadView::OnFilePrint()
{
    theApp.EnsurePrinterIsInitialized();

    // don't allow winini changes to occur while printing
    m_bInPrint = TRUE;

    SetHelpFixHook() ;

    CRichEdit2View::OnFilePrint();

    RemoveHelpFixHook() ;

    // printer may have changed
    theApp.NotifyPrinterChanged(); // this will cause a GetDocument()->PrinterChanged();
    m_bInPrint = FALSE;
}

void CWordPadView::OnFilePrintPreview()
{
    theApp.EnsurePrinterIsInitialized();

    CRichEdit2View::OnFilePrintPreview();
}

int CWordPadView::OnMouseActivate(CWnd* pWnd, UINT nHitTest, UINT message)
{
    if (m_bOnBar)
    {
        SetFocus();
        return MA_ACTIVATEANDEAT;
    }
    else
        return CRichEdit2View::OnMouseActivate(pWnd, nHitTest, message);
}

typedef BOOL (WINAPI *PCWPROC)(HWND, LPSTR, UINT, LPVOID, DWORD, DWORD);
void CWordPadView::OnPenLens()
{
    USES_CONVERSION;
    HINSTANCE hLib = LoadLibrary(_T("PENWIN32.DLL"));
    if (hLib == NULL)
        return;
    PCWPROC pCorrectWriting = (PCWPROC)GetProcAddress(hLib, "CorrectWriting");
    ASSERT(pCorrectWriting != NULL);
    if (pCorrectWriting != NULL)
    {
        CHARRANGE cr;
        GetRichEditCtrl().GetSel(cr);
        int nCnt = 2*(cr.cpMax-cr.cpMin);
        BOOL bSel = (nCnt != 0);
        nCnt = max(1024, nCnt);
        char* pBuf = new char[nCnt];
        pBuf[0] = NULL;
        if (bSel)
            GetRichEditCtrl().GetSelText(pBuf);
        if (pCorrectWriting(m_hWnd, pBuf, nCnt, 0, bSel ? 0 : CWR_INSERT, 0))
            GetRichEditCtrl().ReplaceSel(A2T(pBuf));
        delete [] pBuf;
    }
    FreeLibrary(hLib);
}

LONG CWordPadView::OnPrinterChangedMsg(UINT, LONG)
{
    CDC dc;
    AfxGetApp()->CreatePrinterDC(dc);
    OnPrinterChanged(dc);
    return 0;
}

static void ForwardPaletteChanged(HWND hWndParent, HWND hWndFocus)
{
    // this is a quick and dirty hack to send the WM_QUERYNEWPALETTE to a window that is interested
    HWND hWnd = NULL;
    for (hWnd = ::GetWindow(hWndParent, GW_CHILD); hWnd != NULL; hWnd = ::GetWindow(hWnd, GW_HWNDNEXT))
    {
        if (hWnd != hWndFocus)
        {
            ::SendMessage(hWnd, WM_PALETTECHANGED, (WPARAM)hWndFocus, 0L);
            ForwardPaletteChanged(hWnd, hWndFocus);
        }
    }
}

void CWordPadView::OnPaletteChanged(CWnd* pFocusWnd)
{
    ForwardPaletteChanged(m_hWnd, pFocusWnd->GetSafeHwnd());
    // allow the richedit control to realize its palette
    // remove this if if richedit fixes their code so that
    // they don't realize their palette into foreground
    if (::GetWindow(m_hWnd, GW_CHILD) == NULL)
        CRichEdit2View::OnPaletteChanged(pFocusWnd);
}

static BOOL FindQueryPalette(HWND hWndParent)
{
    // this is a quick and dirty hack to send the WM_QUERYNEWPALETTE to a window that is interested
    HWND hWnd = NULL;
    for (hWnd = ::GetWindow(hWndParent, GW_CHILD); hWnd != NULL; hWnd = ::GetWindow(hWnd, GW_HWNDNEXT))
    {
        if (::SendMessage(hWnd, WM_QUERYNEWPALETTE, 0, 0L))
            return TRUE;
        else if (FindQueryPalette(hWnd))
            return TRUE;
    }
    return FALSE;
}

BOOL CWordPadView::OnQueryNewPalette()
{
    if(FindQueryPalette(m_hWnd))
        return TRUE;
    return CRichEdit2View::OnQueryNewPalette();
}

void CWordPadView::OnWinIniChange(LPCTSTR lpszSection)
{
    CRichEdit2View::OnWinIniChange(lpszSection);
    //printer might have changed
    if (!m_bInPrint)
    {
        if (lstrcmpi(lpszSection, _T("windows")) == 0)
            theApp.NotifyPrinterChanged(TRUE); // force update to defaults
    }
}

void CWordPadView::OnSize(UINT nType, int cx, int cy)
{
    CRichEdit2View::OnSize(nType, cx, cy);
    CRect rect(HORZ_TEXTOFFSET, VERT_TEXTOFFSET, cx, cy);
    GetRichEditCtrl().SetRect(rect);
}

void CWordPadView::OnGetCharFormat(NMHDR* pNMHDR, LRESULT* pRes)
{
    ASSERT(pNMHDR != NULL);
    ASSERT(pRes != NULL);

    ((CHARHDR*)pNMHDR)->cf = GetCharFormatSelection();
    *pRes = 1;
}

void CWordPadView::OnSetCharFormat(NMHDR* pNMHDR, LRESULT* pRes)
{
    ASSERT(pNMHDR != NULL);
    ASSERT(pRes != NULL);
    SetCharFormat(((CHARHDR*)pNMHDR)->cf);
    *pRes = 1;
}

void CWordPadView::OnBarSetFocus(NMHDR*, LRESULT*)
{
    m_bOnBar = TRUE;
}

void CWordPadView::OnBarKillFocus(NMHDR*, LRESULT*)
{
    m_bOnBar = FALSE;
}

void CWordPadView::OnBarReturn(NMHDR*, LRESULT* )
{
    SetFocus();
}

void CWordPadView::OnFormatFont()
{
    SetHelpFixHook() ;

    CRichEdit2View::OnFormatFont() ;

    RemoveHelpFixHook() ;
}

void CWordPadView::OnInsertObject()
{
    g_fDisableStandardHelp = TRUE ;

    SetHelpFixHook() ;

    CRichEdit2View::OnInsertObject() ;

    RemoveHelpFixHook() ;

    g_fDisableStandardHelp = FALSE ;
}

void CWordPadView::OnEditPasteSpecial()
{
    g_fDisableStandardHelp = TRUE ;

    SetHelpFixHook() ;

    CRichEdit2View::OnEditPasteSpecial() ;

    RemoveHelpFixHook() ;

    g_fDisableStandardHelp = FALSE ;
}

void CWordPadView::OnEditFind()
{
    SetHelpFixHook() ;

    CRichEdit2View::OnEditFind() ;

    RemoveHelpFixHook() ;
}

void CWordPadView::OnEditReplace()
{
    SetHelpFixHook() ;

    CRichEdit2View::OnEditReplace() ;

    RemoveHelpFixHook() ;
}

void CWordPadView::OnEditProperties()
{
    g_fDisableStandardHelp = TRUE ;

    SetHelpFixHook() ;

    CRichEdit2View::OnEditProperties() ;

    RemoveHelpFixHook() ;

    g_fDisableStandardHelp = FALSE ;
}


/////////////////////////////////////////////////////////////////////////////
// CWordPadView::XRichEditOleCallback
//
// We implement this so we can override the defaults that MFC has set up.  For
// the most part, we just delegate to MFC.
//

BEGIN_INTERFACE_MAP(CWordPadView, CCtrlView)
// we use IID_IUnknown because richedit doesn't define an IID
INTERFACE_PART(CWordPadView, IID_IUnknown, WordPadRichEditOleCallback)
END_INTERFACE_MAP()

STDMETHODIMP_(ULONG) CWordPadView::XWordPadRichEditOleCallback::AddRef()
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.AddRef() ;
}

STDMETHODIMP_(ULONG) CWordPadView::XWordPadRichEditOleCallback::Release()
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.Release() ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::QueryInterface(
                                                                       REFIID iid, LPVOID* ppvObj)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.QueryInterface(iid, ppvObj) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetNewStorage(LPSTORAGE* ppstg)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.GetNewStorage(ppstg) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetInPlaceContext(
                                                                          LPOLEINPLACEFRAME* lplpFrame, LPOLEINPLACEUIWINDOW* lplpDoc,
                                                                          LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        // Turn off the mirroring so the server can do the caculation without any problem.
        // We turn it on again in ShowContainerUI
        MirrorTheContainer(FALSE);

        return pThis->m_xRichEditOleCallback.GetInPlaceContext(lplpFrame, lplpDoc, lpFrameInfo) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::ShowContainerUI(BOOL fShow)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        // Turn on the mirroring if object UI gonna deactivate.
        if (fShow)
            MirrorTheContainer(fShow);

        return pThis->m_xRichEditOleCallback.ShowContainerUI(fShow) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::QueryInsertObject(
                                                                          LPCLSID lpclsid, LPSTORAGE pstg, LONG cp)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.QueryInsertObject(lpclsid, pstg, cp) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::DeleteObject(LPOLEOBJECT lpoleobj)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.DeleteObject(lpoleobj) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::QueryAcceptData(
                                                                        LPDATAOBJECT lpdataobj, CLIPFORMAT* lpcfFormat, DWORD reco,
                                                                        BOOL fReally, HGLOBAL hMetaPict)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.QueryAcceptData(lpdataobj, lpcfFormat, reco,
        fReally, hMetaPict) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::ContextSensitiveHelp(BOOL fEnterMode)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.ContextSensitiveHelp(fEnterMode) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetClipboardData(
                                                                         CHARRANGE* lpchrg, DWORD reco, LPDATAOBJECT* lplpdataobj)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.GetClipboardData(lpchrg, reco, lplpdataobj) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetDragDropEffect(
                                                                          BOOL fDrag, DWORD grfKeyState, LPDWORD pdwEffect)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        if (!fDrag) // allowable dest effects
        {
            DWORD   dwEffect;

            // check for force link
#ifndef _MAC
            if ((grfKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
#else
                if ((grfKeyState & (MK_OPTION|MK_SHIFT)) == (MK_OPTION|MK_SHIFT))
#endif
                    dwEffect = DROPEFFECT_LINK;
                // check for force copy
#ifndef _MAC
                else if ((grfKeyState & MK_CONTROL) == MK_CONTROL)
#else
                    else if ((grfKeyState & MK_OPTION) == MK_OPTION)
#endif
                    dwEffect = DROPEFFECT_COPY;
                // check for force move
                else if ((grfKeyState & MK_ALT) == MK_ALT)
                    dwEffect = DROPEFFECT_MOVE;
                // default -- recommended action is 'copy' (overridden from MFC default)
                else
                {
                    if (g_fInternalDragDrop)
                    {
                        dwEffect = DROPEFFECT_MOVE ;
                    }
                    else
                    {
                        dwEffect = DROPEFFECT_COPY;
                    }
                }

                pThis->m_nPasteType = 0;

                if (dwEffect & *pdwEffect) // make sure allowed type
                {
                    *pdwEffect = dwEffect;

                    if (DROPEFFECT_LINK == dwEffect)
                        pThis->m_nPasteType = COlePasteSpecialDialog::pasteLink;
                }
        }
        return S_OK;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetContextMenu(
                                                                       WORD seltype, LPOLEOBJECT lpoleobj, CHARRANGE* lpchrg,
                                                                       HMENU* lphmenu)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        HRESULT hr;

    if (g_fRightButtonDrag)
        hr = E_FAIL;
    else
        hr = pThis->m_xRichEditOleCallback.GetContextMenu(
        seltype,
        lpoleobj,
        lpchrg,
        lphmenu);

    g_fRightButtonDrag = FALSE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\afxdlgs2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXDLGS2.H

#ifdef _AFXDLGS2_INLINE

_AFXDLGS2_INLINE CString CFontDialog2::GetFaceName() const
	{ return (LPCTSTR)m_cf.lpLogFont->lfFaceName; }
_AFXDLGS2_INLINE CString CFontDialog2::GetStyleName() const
	{ return m_cf.lpszStyle; }
_AFXDLGS2_INLINE int CFontDialog2::GetSize() const
	{ return m_cf.iPointSize; }
_AFXDLGS2_INLINE int CFontDialog2::GetWeight() const
	{ return (int)m_cf.lpLogFont->lfWeight; }
_AFXDLGS2_INLINE BOOL CFontDialog2::IsItalic() const
	{ return m_cf.lpLogFont->lfItalic ? TRUE : FALSE; }
_AFXDLGS2_INLINE BOOL CFontDialog2::IsStrikeOut() const
	{ return m_cf.lpLogFont->lfStrikeOut ? TRUE : FALSE; }
_AFXDLGS2_INLINE BOOL CFontDialog2::IsBold() const
	{ return m_cf.lpLogFont->lfWeight == FW_BOLD ? TRUE : FALSE; }
_AFXDLGS2_INLINE BOOL CFontDialog2::IsUnderline() const
	{ return m_cf.lpLogFont->lfUnderline ? TRUE : FALSE; }
_AFXDLGS2_INLINE COLORREF CFontDialog2::GetColor() const
	{ return m_cf.rgbColors; }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXDLGS2_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\afxrich2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXRICH2.H

// CRichEdit2View
_AFXRICH2_INLINE CRichEdit2Ctrl& CRichEdit2View::GetRichEditCtrl() const
	{ return *(CRichEdit2Ctrl*)this; }
int _AFXRICH2_INLINE CRichEdit2View::GetPrintWidth() const
	{ return m_sizePaper.cx - m_rectMargin.left - m_rectMargin.right;}
CRect _AFXRICH2_INLINE CRichEdit2View::GetPrintRect() const
	{ return CRect(m_rectMargin.left, m_rectMargin.top, m_sizePaper.cx - m_rectMargin.right, m_sizePaper.cy - m_rectMargin.bottom); }
CRect _AFXRICH2_INLINE CRichEdit2View::GetPageRect() const
	{ return CRect(CPoint(0,0), m_sizePaper); }
void _AFXRICH2_INLINE CRichEdit2View::SetPaperSize(CSize sizePaper)
	{ m_sizePaper = sizePaper; }
CSize _AFXRICH2_INLINE CRichEdit2View::GetPaperSize() const
	{ return m_sizePaper; }
void _AFXRICH2_INLINE CRichEdit2View::SetMargins(const CRect& rectMargin)
	{ m_rectMargin = rectMargin; }
CRect _AFXRICH2_INLINE CRichEdit2View::GetMargins() const
	{ return m_rectMargin; }

_AFXRICH2_INLINE long CRichEdit2View::GetTextLength() const
	{ return GetRichEditCtrl().GetTextLength(); }
_AFXRICH2_INLINE CRichEdit2Doc* CRichEdit2View::GetDocument() const
{
	ASSERT(m_pDocument != NULL);
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CRichEdit2Doc)));
	return (CRichEdit2Doc*)m_pDocument;
}
_AFXRICH2_INLINE int CRichEdit2Doc::GetStreamFormat() const
	{ return m_bRTF ? SF_RTF : SF_TEXT; }
_AFXRICH2_INLINE BOOL CRichEdit2Doc::IsUnicode() const
    { return m_bUnicode; }
_AFXRICH2_INLINE void CRichEdit2Doc::InvalidateObjectCache()
	{ m_bUpdateObjectCache = TRUE; }

_AFXRICH2_INLINE void CRichEdit2CntrItem::Mark(BOOL b)
	{ m_bMark = b; }
_AFXRICH2_INLINE BOOL CRichEdit2CntrItem::IsMarked()
	{ return m_bMark||m_bLock; }
_AFXRICH2_INLINE CRichEdit2Doc* CRichEdit2CntrItem::GetDocument()
	{ return (CRichEdit2Doc*)COleClientItem::GetDocument(); }
_AFXRICH2_INLINE CRichEdit2View* CRichEdit2CntrItem::GetActiveView()
	{ return (CRichEdit2View*)COleClientItem::GetActiveView(); }

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\core\ntloio.c ===
//
// %%File:      NTLOIO.C
//
// %%Unit:      CORE/Common Conversions Code
//
// %%Author:    SMueller
//
// Copyright (C) 1993, Microsoft Corp.
//
// This file contains NT (Win32) specific low-level I/O routines.
//
// We provide wrappers for standard Win32 APIs.
//
// The routines here should work in exes and dlls.  Ideally without
// ifdefs.
//
// ToDo:
// - Open needs to concern itself with binary mode
//

#include "conv.h"
DeclareFileName

#include "ntloio.h"


//
// Local functions
//

//
// Exported APIs
//

#if defined(USEFUNCS)
/*   F   I N I T   L O I O   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller

	Initialize the LoIO package.  Essential to call this routine before
	doing any other LoIO stuff.
-------------------------------------------------------------------------*/
GLOBALBOOL _FInitLoIO_NT(VOID)
{
	// nothing currently comes to mind
	return(fTrue);
}
#endif // USEFUNCS


#if defined(USEFUNCS)
/*  F   U N I N I T   L O I O   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller

	Uninitialize the LoIO package.  Good form to call this routine
	when done LoIO stuff.
-------------------------------------------------------------------------*/
GLOBALBOOL _FUninitLoIO_NT(VOID)
{
	// nothing currently comes to mind
	return(fTrue);
}
#endif // USEFUNCS


/*   F H   O P E N   F S   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller
 
	Opens a file and returns a file handle to it, creating it
	if it doesn't already exist and oflags specifies that we should.
	If file couldn't be opened, return FI_ERROR.
	Note that oflags is specified using convio canonical flags, as
	opposed to any Windows OF_* or Win32 FILE_* values.

	Consider: using FILE_FLAG_DELETE_ON_CLOSE to support our auto-delete
	functionality
-------------------------------------------------------------------------*/
GLOBALFH _FhOpenFs_NT(CHAR* szFileSpec, OFLAGS oflags)
{
	FH		fh;
	BOOL	fCreate;
	BOOL	fTruncate;
	BOOL	fFailExists;
	BOOL	fBinary;
	BOOL	fAppend;
	DWORD	permission;
	DWORD	createmode;
	DWORD	attributes;
	DWORD	sharemode;

	// extract useful info from oflags
	// we don't do much error checking since it's been done higher up
	fCreate = oflags & FI_CREATE;
	fTruncate = oflags & FI_TRUNCATE;
	fFailExists = oflags & FI_FAILEXISTS;
	fAppend = oflags & FI_APPEND;

	// The actual mapping encoded below
	//    fCreate  &&  fTruncate  && fFailExists    ->    CREATE_NEW
	//    fCreate  &&  fTruncate                    ->    CREATE_ALWAYS
	//    fCreate  &&                fFailExists    ->    CREATE_NEW
	//    fCreate                                   ->    OPEN_ALWAYS
	//                 fTruncate  && fFailExists    ->    failure
	//                 fTruncate                    ->    TRUNCATE_EXISTING
	//                               fFailExists    ->    failure
	//                   <none>                     ->    OPEN_EXISTING
	//
	if (fCreate && fFailExists)
		createmode = CREATE_NEW;
	else if (fCreate && fTruncate)
		createmode = CREATE_ALWAYS;
	else if (fCreate)
		createmode = OPEN_ALWAYS;
	else if (fFailExists)
		return (FH)FI_ERROR;
	else if (fTruncate)
		createmode = TRUNCATE_EXISTING;
	else // none
		createmode = OPEN_EXISTING;

	// hints to file system
	attributes = FILE_FLAG_SEQUENTIAL_SCAN;
	if (oflags & FI_TEMP)
		attributes |= FILE_ATTRIBUTE_TEMPORARY;

	// the only thing we potentially care about file type is whether
	// it's text or binary.
	if (oflags & FI_RTF || oflags & FI_TEXT)
	 	fBinary = fFalse;
	else if (oflags & FI_BINARY)
	 	fBinary = fTrue;
	else
		AssertSz(fFalse, "_FhOpenFs_NT: bogus logical file type");

	// mask out values we no longer care about
	oflags &= FI_READWRITE;

	// REVIEW smueller(jimw): Why not use a switch statement here?
	//  (since OFLAGS is short, an int type)?
	// extract the main mode and map to Windows value
	sharemode = 0;
	if (oflags == FI_READ)
		{
	 	permission = GENERIC_READ;
		sharemode = FILE_SHARE_READ;
		}
	else if (oflags == FI_WRITE)
	 	permission = GENERIC_WRITE;
	else if (oflags == FI_READWRITE)
	 	permission = GENERIC_READ | GENERIC_WRITE;
	else
		AssertSz(fFalse, "_FhOpenFs_NT: bogus open mode");

	fh = CreateFile(szFileSpec, permission, sharemode, (LPSECURITY_ATTRIBUTES)0,
	                createmode, attributes, (HANDLE)NULL);

	// if open succeeded, and caller wants, position file pointer at end
	if (fh == INVALID_HANDLE_VALUE)
		{
		Debug(DWORD err = GetLastError());
		return (FH)FI_ERROR;
		}

	if (fAppend)
		{
		SetFilePointer(fh, 0, NULL, FILE_END);
		}

	return fh;
}


#if defined(USEFUNCS)
/*   F   C L O S E   F H   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller
 
	Close a file handle.  Return success/failure.
	review: check for the existence of a return code.
-------------------------------------------------------------------------*/
GLOBALBOOL _FCloseFh_NT(FH fh, OFLAGS oflags)
{
	return CloseHandle(fh);
}
#endif // USEFUNCS


/*   C B   R E A D   F H   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller
 
	Read cb bytes from file fh into buffer at pb.  Return count of
	bytes actually read, or FI_ERROR.
-------------------------------------------------------------------------*/
GLOBALLONG _CbReadFh_NT(FH fh, VOID *pb, LONG cb)
{
	LONG cbr;
	return ReadFile(fh, pb, cb, &cbr, NULL) ? cbr : FI_ERROR;
}


/*   C B   W R I T E   F H   N T   */
/*-------------------------------------------------------------------------
	Owner: SMueller

	Write cb bytes from buffer at pb to file fh.  Return count of
	bytes actually written, or FI_ERROR.
-------------------------------------------------------------------------*/
GLOBALLONG _CbWriteFh_NT(FH fh, VOID *pb, LONG cb)
{
	LONG cbw;
	return WriteFile(fh, pb, cb, &cbw, NULL) ? cbw : FI_ERROR;
}


#if defined(USEFUNCS)
/*   F C   S E E K   F H   N T   */
/*-------------------------------------------------------------------------
	Owner: SMueller

	Seek from location so, fc bytes away on file fh.  Return new
	location or FI_ERROR.
-------------------------------------------------------------------------*/
GLOBALFC _FcSeekFh_NT(FH fh, FC fc, SHORT so)
{
	return(SetFilePointer(fh, fc, NULL, so));
}
#endif // USEFUNCS


#if defined(USEFUNCS)
/*   F C   C U R R   F H   N T   */
/*-------------------------------------------------------------------------
	Owner: SMueller

	Return current file position or FI_ERROR.
-------------------------------------------------------------------------*/
GLOBALFC _FcCurrFh_NT(FH fh)
{
	// find out where we are by moving nowhere from here
	return(SetFilePointer(fh, 0, NULL, FILE_CURRENT));
}
#endif // USEFUNCS


#if defined(USEFUNCS)
/*   F C   M A X   F H   N T   */
/*-------------------------------------------------------------------------
	Owner: SMueller

	Return maximum file position (i.e. size of file, i.e. offset of EOF)
	or FI_ERROR.
-------------------------------------------------------------------------*/
GLOBALFC _FcMaxFh_NT(FH fh)
{
	return(GetFileSize(fh, NULL));
}
#endif // USEFUNCS


/*   F C   S E T   M A X   F H   N T   */
/*-------------------------------------------------------------------------
	Owner: SMueller

	Set end of file to current position.  Return new file size or FI_ERROR.
-------------------------------------------------------------------------*/
GLOBALFC _FcSetMaxFh_NT(FH fh)
{
	FC fc;

	fc = SetFilePointer(fh, 0, NULL, FILE_CURRENT);  // get current position
	return (SetEndOfFile(fh) ? fc : FI_ERROR);
}


#if defined(USEFUNCS)
/*   F   D E L E T E   S Z   N T   */
/*-------------------------------------------------------------------------
	Owner: SMueller

	Delete an existing file.  Return success/failure.
-------------------------------------------------------------------------*/
GLOBALBOOL _FDeleteSz_NT(CHAR *szFileSpec)
{
	return DeleteFile(szFileSpec);
}
#endif // USEFUNCS


#if defined(USEFUNCS)
/*   F   R E N A M E   S Z   S Z   N T   */
/*-------------------------------------------------------------------------
	Owner: SMueller

	Rename an existing file.  Supports rename across directories.
	Return success/failure.
-------------------------------------------------------------------------*/
GLOBALBOOL _FRenameSzSz_NT(CHAR *szFileSpec, CHAR *szNewSpec)
{
	return MoveFile(szFileSpec, szNewSpec);
}
#endif // USEFUNCS


/*   F   G E T   C O N V E R T E R   D I R   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller
 
    Gets the FileSpec for the directory where the currently executing
	converter file lives.  Directory will always contain a trailing
	backslash.
-------------------------------------------------------------------------*/
GLOBALBOOL _FGetConverterDir_NT(CHAR ***phszDirectory)
{
	UINT lRet;
	CHAR *psz;
	INT cbsz;

	*phszDirectory = (CHAR**)HAllocAbort(MAXPATH + 1);
	psz = **phszDirectory;
	lRet = GetModuleFileName(hInstance, psz, MAXPATH);

	if (lRet == 0 || lRet >= MAXPATH)
		{
		FreeH(*phszDirectory);
		return fFalse;
		}
	FTruncateFileSpec(psz);

	// ensure there's a trailing backslash
	cbsz = CchSz(psz);
	if (psz[cbsz - 1] != '\\')
		{
		psz[cbsz] = '\\';
		psz[cbsz + 1] = '\0';
		}

	return fTrue;
}


/*   F   G E T   T E M P   D I R   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller
 
    Gets the FileSpec for the directory where temp files are to be stored.
	Directory will always contain a trailing backslash.
-------------------------------------------------------------------------*/
GLOBALBOOL _FGetTempDir_NT(CHAR ***phszDirectory)
{
	UINT lRet;
	CHAR *psz;
	INT cbsz;
    UINT nTest;
    char rgchTest[MAXPATH + 1];

	*phszDirectory = (CHAR**)HAllocAbort(MAXPATH + 1);
	psz = **phszDirectory;
	lRet = GetTempPath(MAXPATH, psz);

	if (lRet == 0 || lRet > MAXPATH)
		{
		FreeH(*phszDirectory);
		return fFalse;
		}

	// ensure there's a trailing backslash
	cbsz = CchSz(psz);
	if (psz[cbsz - 1] != '\\')
		{
		psz[cbsz] = '\\';
		psz[cbsz + 1] = '\0';
		}

    // Copied from the conv96 project -- MikeW
    
    // if we don't have a valid temp directory (because of fouled up %TEMP%
    // and %TMP%) ...
    if ((nTest = GetTempFileName(psz, "tst", 0, rgchTest)) == 0)
        {
        // ... use preferences (Windows) directory, which is probably not
        // fouled up, and writable.
        FreeH(*phszDirectory);
        return _FGetPrefsDir_NT(phszDirectory);
        }
    else
        {
        // clean up after GetTempFileName, which actually does create the temp
        // file, but at least does a reasonably good job of deciding quickly
        // that a directory doesn't exist or isn't writable
        DeleteFile(rgchTest);
        }

    return fTrue;
}


/*   F   G E T   P R E F S   D I R   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller
 
    Gets the FileSpec for the directory where preferences files are to
    be stored.  Directory will always contain a trailing backslash.
-------------------------------------------------------------------------*/
GLOBALBOOL _FGetPrefsDir_NT(CHAR ***phszDirectory)
{
	UINT lRet;
	CHAR *psz;
	INT cbsz;

	*phszDirectory = (CHAR**)HAllocAbort(MAXPATH + 1);
	psz = **phszDirectory;
	lRet = GetWindowsDirectory(psz, MAXPATH);

	if (lRet == 0 || lRet > MAXPATH)
		{
		FreeH(*phszDirectory);
		return fFalse;
		}

	// ensure there's a trailing backslash
	cbsz = CchSz(psz);
	if (psz[cbsz - 1] != '\\')
		{
		psz[cbsz] = '\\';
		psz[cbsz + 1] = '\0';
		}

	return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\afximpl2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// Auxiliary System/Screen metrics

struct AUX_DATA
{
        // system metrics
        int cxVScroll, cyHScroll;
        int cxIcon, cyIcon;

        int cxBorder2, cyBorder2;

        // device metrics for screen
        int cxPixelsPerInch, cyPixelsPerInch;

        // convenient system color
        HBRUSH hbrWindowFrame;
        HBRUSH hbrBtnFace;
#ifdef _MAC
        HBRUSH hbr3DLight;
#endif

        // color values of system colors used for CToolBar
        COLORREF clrBtnFace, clrBtnShadow, clrBtnHilite;
        COLORREF clrBtnText, clrWindowFrame;
#ifdef _MAC
        COLORREF clr3DLight;
#endif

        // standard cursors
        HCURSOR hcurWait;
        HCURSOR hcurArrow;
        HCURSOR hcurHelp;       // cursor used in Shift+F1 help

        // special GDI objects allocated on demand
        HFONT   hStatusFont;
        HFONT   hToolTipsFont;
        HBITMAP hbmMenuDot;

        // other system information
        UINT    nWinVer;        // Major.Minor version numbers
        BOOL    bWin32s;        // TRUE if Win32s (or Windows 95)
        BOOL    bWin4;          // TRUE if Windows 4.0
        BOOL    bNotWin4;       // TRUE if not Windows 4.0
        BOOL    bSmCaption;     // TRUE if WS_EX_SMCAPTION is supported
        BOOL    bMarked4;       // TRUE if marked as 4.0

#ifdef _MAC
        BOOL    bOleIgnoreSuspend;
#endif

// Implementation
        AUX_DATA();
        ~AUX_DATA();
        void UpdateSysColors();
        void UpdateSysMetrics();
};

extern AFX_DATA AUX_DATA afxData;

/////////////////////////////////////////////////////////////////////////////
// _AFX_EDIT_STATE

class _AFX_EDIT_STATE : public CNoTrackObject
{
public:
        _AFX_EDIT_STATE();
        virtual ~_AFX_EDIT_STATE();

        CFindReplaceDialog* pFindReplaceDlg; // find or replace dialog
        BOOL bFindOnly; // Is pFindReplace the find or replace?
        CString strFind;    // last find string
        CString strReplace; // last replace string
        BOOL bCase; // TRUE==case sensitive, FALSE==not
        int bNext;  // TRUE==search down, FALSE== search up
        BOOL bWord; // TRUE==match whole word, FALSE==not
};

#undef AFX_DATA
#define AFX_DATA

class _AFX_RICHEDIT2_STATE : public _AFX_EDIT_STATE
{
public:
	HINSTANCE m_hInstRichEdit;      // handle to richedit dll
	virtual ~_AFX_RICHEDIT2_STATE();
};

EXTERN_PROCESS_LOCAL(_AFX_RICHEDIT2_STATE, _afxRichEdit2State)

_AFX_RICHEDIT2_STATE* AFX_CDECL AfxGetRichEdit2State();


// dialog/commdlg hook procs
BOOL CALLBACK AfxDlgProc(HWND, UINT, WPARAM, LPARAM);
UINT CALLBACK _AfxCommDlgProc(HWND hWnd, UINT, WPARAM, LPARAM);

// support for standard dialogs
extern const UINT _afxNMsgSETRGB;
typedef UINT (CALLBACK* COMMDLGPROC)(HWND, UINT, UINT, LONG);

/////////////////////////////////////////////////////////////////////////////
// Special helpers

BOOL AFXAPI AfxHelpEnabled();  // determine if ID_HELP handler exists
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\core\convtype.h ===
#ifndef CONVTYPE_H
#define CONVTYPE_H

//
// %%File:      CONVTYPE.H
//
// %%Unit:      CORE/Common Conversions Code
//
// %%Author:    JohnPil
//
// Copyright (C) 1989-1993, Microsoft Corp.
//
// Global type definitions for conversions code.
//


typedef int bool;

#ifndef PASCAL
#define PASCAL pascal
#endif

#ifndef FAR
#ifdef PC
#define FAR _far
#else
#define FAR
#endif
#endif

#ifndef NEAR
#ifdef PC
#define NEAR _near
#else
#define NEAR
#endif
#endif

// Use __HUGE rather than HUGE or _HUGE as Excel mathpack defines both as externs
#ifndef __HUGE
#ifdef PC
#ifndef NT
#define __HUGE _huge
#else
#define __HUGE
#endif //NT
#else
#define __HUGE
#endif //PC
#endif //__HUGE

#ifndef STATIC
#define STATIC static
#endif

#ifndef EXTERN
#define EXTERN extern
#endif

//  ABSOLUTE SIZE
//  -------------
#ifndef VOID
#define VOID void
#endif

#ifndef BYTE
#define BYTE unsigned char				// 8-bit unsigned data
#define BYTE_MAX 255
#endif

#ifndef CHAR
#define CHAR char						// 8-bit data
#endif

typedef unsigned CHAR UCHAR;

typedef short int SHORT;
#define SHORT_MAX						32767
#define SHORT_MIN						-32767

#ifndef WORD
#define WORD unsigned short				// 16-bit unsigned data
#define WORD_MAX 65535
#endif

typedef WORD BF;						// bitfields are 16-bit unsigned

#ifndef LONG
#define LONG long						// 32-bit data
#endif

#ifndef DWORD
#define DWORD unsigned long				// 32-bit unsigned data
#endif

#ifndef FLOAT
#define FLOAT float						// fixed size absolute float
#endif

#ifndef DOUBLE
#ifndef NT_WORDPAD
#define DOUBLE double					// fixed size absolute double
#endif
#endif

//  VARIABLE SIZE
//  -------------
#ifndef INT
#define INT int							// Most efficient size for processing info
#endif

#ifndef UNSIGNED
#define UNSIGNED unsigned INT
#endif

#ifndef BOOL
#define BOOL INT						// Boolean data
#endif

#define FC              long
#define CP              long
#define PN              WORD
typedef unsigned char byte;

// things which are normally defined in windows.h for windows, but now on Mac
#ifdef MAC

#define LOWORD(l)           ((WORD)(DWORD)(l))
#define HIWORD(l)           ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

typedef char FAR *LPSTR;
typedef const char FAR *LPCSTR;
typedef WORD HWND;

#endif

// define platform-independent function type templates

#if defined(MAC)

typedef int (PASCAL * FARPROC) ();
typedef void FAR *LPVOID;	// These are already defined for PC in Windows.h
typedef void **HGLOBAL;		// but have to be defined for Mac.

#define LOCAL(type) type NEAR PASCAL
#define GLOBAL(type) type PASCAL

#elif defined(NT)

typedef int (WINAPI * FARPROC)();

#define LOCAL(type) type NEAR WINAPI
#define GLOBAL(type) type WINAPI

#elif defined(DOS)

typedef int (FAR PASCAL * FARPROC)();

#define LOCAL(type) type NEAR PASCAL
#define GLOBAL(type) type PASCAL

#else
#error Enforced Compilation Error
#endif


// define main function types

#define LOCALVOID 		LOCAL(VOID)
#define LOCALBOOL 		LOCAL(BOOL)
#define LOCALCH   		LOCAL(char)
#define LOCALBYTE 		LOCAL(BYTE)
#define LOCALINT  		LOCAL(INT)
#define LOCALUNS      	LOCAL(UNSIGNED)
#define LOCALSHORT		LOCAL(SHORT)
#define LOCALWORD       LOCAL(WORD)
#define LOCALLONG		LOCAL(LONG)
#define LOCALDWORD  	LOCAL(DWORD)
#define LOCALFC 		LOCAL(FC)
#define LOCALCP   		LOCAL(CP)
#define LOCALPVOID  	LOCAL(void *)
#define LOCALHVOID   	LOCAL(void **)
#define LOCALPCH  		LOCAL(char *)
#define LOCALSZ   		LOCAL(char *)
#define LOCALLPCH 		LOCAL(char FAR *)
#define LOCALUCHAR   	LOCAL(unsigned char)
#define LOCALPUCHAR  	LOCAL(unsigned char *)
#define LOCALFH			LOCAL(FH)

#define GLOBALVOID 		GLOBAL(VOID)
#define GLOBALBOOL 		GLOBAL(BOOL)
#define GLOBALCH   		GLOBAL(char)
#define GLOBALBYTE 		GLOBAL(BYTE)
#define GLOBALINT  		GLOBAL(INT)
#define GLOBALUNS      	GLOBAL(UNSIGNED)
#define GLOBALSHORT		GLOBAL(SHORT)
#define GLOBALWORD      GLOBAL(WORD)
#define GLOBALLONG		GLOBAL(LONG)
#define GLOBALDWORD  	GLOBAL(DWORD)
#define GLOBALFC 		GLOBAL(FC)
#define GLOBALCP   		GLOBAL(CP)
#define GLOBALPVOID  	GLOBAL(void *)
#define GLOBALHVOID   	GLOBAL(void **)
#define GLOBALPCH  		GLOBAL(char *)
#define GLOBALSZ   		GLOBAL(char *)
#define GLOBALLPCH  	GLOBAL(char FAR *)
#define GLOBALUCHAR   	GLOBAL(unsigned char)
#define GLOBALPUCHAR  	GLOBAL(unsigned char *)
#define GLOBALFH        GLOBAL(FH)
#define GLOBALFN        GLOBAL(FN)
#ifndef DOSSA
#define GLOBALHGLOBAL	GLOBAL(HGLOBAL)
#define GLOBALLPVOID	GLOBAL(LPVOID)
#endif

#define fTrue           1
#define fFalse          0

#ifndef NULL
#define NULL	0
#endif

#ifndef hgNil
#define hgNil ((HGLOBAL)NULL)
#endif

// maximum lengths of numbers->strings, used with SzFrom???? funcs.
#define cchMaxSzInt		7
#define cchMaxSzWord 	6
#define cchMaxSzLong	12
#define cchMaxSzDword	11

#endif // CONVTYPE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\buttondi.cpp ===
// buttondi.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "resource.h"
#include "buttondi.h"
#include "strings.h"
#include "wordpad.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifndef DS_CONTEXTHELP
#define DS_CONTEXTHELP 0x2000L
#endif

static const int nFontSize = 10;

/////////////////////////////////////////////////////////////////////////////
// CButtonDialog dialog

int CButtonDialog::DisplayMessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption,
	LPCTSTR lpszButtons, WORD wStyle, int nDef, int nCancel,
	DWORD* pHelpIDs, CWnd* pParentWnd)
{
	CButtonDialog dlg(lpszText, lpszCaption, lpszButtons, wStyle, pHelpIDs,
		pParentWnd);
	dlg.SetDefault(nDef);
	dlg.SetCancel(nCancel);
	return dlg.DoModal();
}

CButtonDialog::CButtonDialog(LPCTSTR lpszText, LPCTSTR lpszCaption,
	LPCTSTR lpszButtons, WORD wStyle, DWORD* pHelpIDs ,
	CWnd* pParentWnd) : CCSDialog()
{

	ASSERT(lpszText != NULL);
	ASSERT(lpszCaption != NULL);
	if (HIWORD(lpszText) == NULL)
		VERIFY(m_strText.LoadString(LOWORD((DWORD)lpszText)));
	else
		m_strText = lpszText;
	if (HIWORD(lpszCaption) == NULL)
		VERIFY(m_strCaption.LoadString(LOWORD((DWORD)lpszCaption)));
	else
		m_strCaption = lpszCaption;
	if (lpszButtons != NULL)
		AddButtons(lpszButtons);

	m_pParentWnd = pParentWnd;
	m_nDefButton = 0;
	m_nCancel = -1;
	m_pButtons = NULL;
	m_wStyle = wStyle;
	m_nBaseID = nFontSize; // don't use IDOK, IDCANCEL, etc
	m_hDlgTmp = NULL;

	LOGFONT lf;
	memcpy(&lf, &theApp.m_lf, sizeof(LOGFONT));
	lf.lfWeight = FW_NORMAL;
    lf.lfWidth = 0; 
	VERIFY(m_font.CreateFontIndirect(&lf));

	m_pHelpIDs = pHelpIDs;
}

CButtonDialog::~CButtonDialog()
{
	delete [] m_pButtons;
	if (m_hDlgTmp != NULL)
		GlobalFree(m_hDlgTmp);
}

BEGIN_MESSAGE_MAP(CButtonDialog, CCSDialog)
	//{{AFX_MSG_MAP(CButtonDialog)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CButtonDialog message handlers

int CButtonDialog::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (m_pHelpIDs != NULL)
	{
		for (int i=0;i<m_strArray.GetSize();i++)
			m_pHelpIDs[i*2] = i+m_nBaseID;
	}
	if (CCSDialog::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	SetWindowText(m_strCaption);
	m_pButtons = new CButton[m_strArray.GetSize()];

	CRect rect(0, 0, 10, 10);
	if (!m_staticIcon.Create(NULL,
		SS_ICON | WS_GROUP | WS_CHILD | WS_VISIBLE, rect, this))
	{
		return -1;
	}
	m_staticIcon.SetIcon(::LoadIcon(NULL, GetIconID(m_wStyle)));

	if (!m_staticText.Create(m_strText, SS_LEFT | SS_NOPREFIX | WS_GROUP |
		WS_CHILD | WS_VISIBLE, rect, this))
	{
		return -1;
	}
	m_staticText.SetFont(&m_font);
	
	for (int i=0;i<m_strArray.GetSize();i++)
	{
		if (!m_pButtons[i].Create(m_strArray[i], WS_TABSTOP | WS_CHILD |
			WS_VISIBLE | ((i == 0) ? WS_GROUP : 0) |
		    ((i == m_nDefButton) ? BS_DEFPUSHBUTTON : BS_PUSHBUTTON),
		    rect, this, i+m_nBaseID))
		{
			return -1;
		}
		m_pButtons[i].SetFont(&m_font);
	}
	PositionControls();
	return 0;
}

BOOL CButtonDialog::OnInitDialog()
{
	CCSDialog::OnInitDialog();
	if (m_pHelpIDs == NULL) // no context help
		ModifyStyleEx(WS_EX_CONTEXTHELP, 0); //remove

	m_pButtons[m_nDefButton].SetFocus();	
	return FALSE;  // return TRUE  unless you set the focus to a control
}

/////////////////////////////////////////////////////////////////////////////
// CButtonDialog operations

void CButtonDialog::AddButtons(LPCTSTR lpszButton)
{
	CString str, strButtons;
	int i=0;
	if (HIWORD(lpszButton) == NULL)
		strButtons.LoadString(LOWORD((DWORD)lpszButton));
	else
		strButtons = lpszButton;
	while (AfxExtractSubString(str, strButtons, i++, '\n'))
		AddButton(str);
}

#ifndef DS_3DLOOK
#define DS_3DLOOK 0x4
#endif

void CButtonDialog::FillInHeader(LPDLGTEMPLATE lpDlgTmp)
{
	USES_CONVERSION;
	lpDlgTmp->style = DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_VISIBLE |
		WS_CAPTION | WS_SYSMENU;
	if (theApp.m_bWin4)
		lpDlgTmp->style |= DS_CONTEXTHELP;
	lpDlgTmp->dwExtendedStyle = 0;
	lpDlgTmp->cdit = 0;
	lpDlgTmp->x = 0;
	lpDlgTmp->y = 0;
	lpDlgTmp->cx = 100;
	lpDlgTmp->cy = 100;
	
	LPWSTR lpStr = (LPWSTR)(lpDlgTmp + 1); /* Move ptr to the variable fields */

	*lpStr++ = 0;  /* No Menu resource for Message Box */
	*lpStr++ = 0;  /* No Class name for MessageBox */

	int nLen = m_strCaption.GetLength();
	wcscpy(lpStr, T2CW(m_strCaption));

	lpStr += nLen+1;
	WORD* pWord = (WORD*)lpStr;
	*pWord = 10; // 10 pt font
	pWord++;
	lpStr = (LPWSTR) pWord;

	wcscpy(lpStr, T2W(theApp.m_lf.lfFaceName));
}

/////////////////////////////////////////////////////////////////////////////
// CButtonDialog overridables

BOOL CButtonDialog::OnCommand(WPARAM wParam, LPARAM /*lParam*/)
{
	if (wParam == IDCANCEL && m_nCancel != -1)
	{
		EndDialog(m_nCancel);
		return TRUE;
	}
	if (::GetDlgItem(m_hWnd, wParam)==NULL)
		return FALSE;
	EndDialog(wParam-m_nBaseID);
	return TRUE;
}

int CButtonDialog::DoModal()
{
	ASSERT(m_strArray.GetSize() != 0);
	if (m_strArray.GetSize() == 0)
		return (m_nCancel != -1) ? m_nCancel : 0;

	// compute size of header
	// Fixed portions of DLG template header = sizeof(DLGTEMPLATE);
    // One null byte for menu name and one for class name = 2
	// Caption text plus NULL = m_strCaption.GetLength()+1
	int nSize = sizeof(DLGTEMPLATE);
	nSize += (2 + m_strCaption.GetLength()+1+lstrlen(theApp.m_lf.lfFaceName)+1)*2 +sizeof(WORD);
	m_hDlgTmp = GlobalAlloc(GPTR, nSize);
	if (m_hDlgTmp == NULL)
		return IDCANCEL;
	LPDLGTEMPLATE lpDlgTmp = (LPDLGTEMPLATE)GlobalLock(m_hDlgTmp);
	FillInHeader(lpDlgTmp);
	GlobalUnlock(m_hDlgTmp);
	InitModalIndirect(m_hDlgTmp);	

	return CCSDialog::DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CButtonDialog implementation

void CButtonDialog::PositionControls()
{
	CSize sizeBase = GetBaseUnits();
	int nButtonHeight = (sizeBase.cy*14)/8;
	int nHeight = 0;
	int nSep,nLeftMargin,nRightMargin,nTopMargin,nBottomMargin;
    int nButtonAdj;
    int nWidth = 0;
    CRect rectText;

	// a) 5/8 screen Width
	// b) Caption
	// c) nLeftMargin ICON nSep TEXT nRightMargin
	// d) nLeftMargin Button1 nSep Button2 ... nRightMargin
	// client width is max(b,d, min(c,a))

	CSize sizeIcon(GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON));
	nSep = sizeIcon.cx/2;
	nLeftMargin = nSep;
	nRightMargin = nSep;
	nTopMargin = nSep;
	nBottomMargin = nSep;
	
	CClientDC dc(this);
	CFont* pOldFont = dc.SelectObject(&m_font);
	
	nButtonAdj = dc.GetTextExtent(_T("XXX"),3).cx; // padding on buttons
	
	int nScreenWidth58 = dc.GetDeviceCaps(HORZRES)*5/8;
	int nCaptionWidth = dc.GetTextExtent(m_strCaption, m_strCaption.
		GetLength()).cx;
	CSize sizeText = dc.GetTextExtent(m_strText,m_strText.GetLength());
	int nTextIconWidth = nLeftMargin+sizeIcon.cx+nSep+sizeText.cx+nRightMargin;
	int nButtons = m_strArray.GetSize();
	int nButtonsWidth = nLeftMargin+nRightMargin+(nButtons-1)*nSep;
	for (int i=0;i<nButtons;i++)
	{
		nButtonsWidth +=
			dc.GetTextExtent(m_strArray[i],m_strArray[i].GetLength()).cx+
			nButtonAdj*2;
	}
	
	nWidth = min(nTextIconWidth,nScreenWidth58);
	nWidth = max(nWidth, nCaptionWidth);
	nWidth = max(nWidth, nButtonsWidth);

	m_staticIcon.SetWindowPos(NULL, nLeftMargin, nTopMargin, sizeIcon.cx,
		sizeIcon.cy, SWP_NOZORDER);

	if (sizeText.cx > nWidth-nLeftMargin-nRightMargin-sizeIcon.cx-nSep)
	{
		sizeText.cx = nWidth-nLeftMargin-nRightMargin-sizeIcon.cx-nSep;
//		int nTextWidth = nWidth-nLeftMargin-nRightMargin-sizeIcon.cx-nSep;
//		rectText.SetRect(0, 0, nTextWidth, 32767);
		rectText.SetRect(0, 0, sizeText.cx, 32767);
		/* Ask DrawText for the right cy */
		sizeText.cy = dc.DrawText(m_strText, m_strText.GetLength(), &rectText,
			DT_CALCRECT | DT_WORDBREAK | DT_EXPANDTABS | DT_NOPREFIX);
	}
	
	m_staticText.SetWindowPos(NULL, nSep+sizeIcon.cx+nSep, nTopMargin,
		sizeText.cx, sizeText.cy, SWP_NOZORDER);
	
	sizeText.cy = max(sizeText.cy, sizeIcon.cy); // at least icon height
	nHeight = nTopMargin + sizeText.cy + nSep + nButtonHeight + nBottomMargin;

	CRect rect;
	rect.left = (nWidth - (nButtonsWidth - nLeftMargin - nRightMargin))/2;
	rect.top = nTopMargin + sizeText.cy + nSep;
	rect.bottom = rect.top + nButtonHeight;

	for (i=0;i<m_strArray.GetSize();i++)
	{
		rect.right = rect.left + dc.GetTextExtent(m_strArray[i],m_strArray[i].GetLength()).cx +
			2*nButtonAdj;
		m_pButtons[i].MoveWindow(&rect);
		rect.left = rect.right + nSep;
	}

	rect.SetRect(0,0,nWidth,nHeight);
	CalcWindowRect(&rect);
	SetWindowPos(NULL, (dc.GetDeviceCaps(HORZRES)-rect.Width())/2,
		(dc.GetDeviceCaps(VERTRES)-rect.Height())/2, rect.Width(), rect.Height(),
		SWP_NOZORDER|SWP_NOACTIVATE);
	if(m_nCancel == -1) // no cancel button
	{
//		CMenu* pMenu = GetSystemMenu(FALSE);
//		if (pMenu != NULL)
//			pMenu->DeleteMenu(SC_CLOSE, MF_BYCOMMAND);
	}
	dc.SelectObject(pOldFont);
}

CSize CButtonDialog::GetBaseUnits()
{
	CDisplayIC dc;
	CFont* pFont = dc.SelectObject(&m_font);
	TEXTMETRIC tm;
	VERIFY(dc.GetTextMetrics(&tm));
	dc.SelectObject(pFont);
	return CSize(tm.tmAveCharWidth, tm.tmHeight);
}

LPCTSTR CButtonDialog::GetIconID(WORD wFlags)
{
	LPCTSTR lpszIcon = NULL;
	wFlags &= MB_ICONMASK;
	if (wFlags == MB_ICONHAND)
		lpszIcon = IDI_HAND;
	else if (wFlags == MB_ICONQUESTION)
		lpszIcon = IDI_QUESTION;
	else if (wFlags == MB_ICONEXCLAMATION)
		lpszIcon = IDI_EXCLAMATION;
	else if (wFlags == MB_ICONASTERISK)
		lpszIcon = IDI_ASTERISK;
	return lpszIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\afxrich2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRICH2_H__
#define __AFXRICH2_H__

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif
#ifndef __AFXDLGS_H__
	#include <afxdlgs.h>
    #include <afxdlgs2.h>
#endif
#ifndef __AFXOLE_H__
	#include <afxole.h>
#endif
#ifndef _RICHEDIT_
	#include <richedit.h>
#endif
#ifndef _RICHOLE_
	#include <richole.h>
	#define _RICHOLE_
#endif
#ifndef __AFXCMN2_H__
	#include <afxcmn2.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXRICH - RichEdit2 classes

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CCtrlView
					class CRichEdit2View;// rich text editor view

		//CDocument
			//COleDocument
				class CRichEdit2Doc;
		//CDocItem
			//COleClientItem
				class CRichEdit2CntrItem;

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View

class _AFX_RICHEDIT2_STATE;  // private to implementation

class CRichEdit2View : public CCtrlView
{
	DECLARE_DYNCREATE(CRichEdit2View)

// Construction
public:
	CRichEdit2View();

// Attributes
public:
	enum WordWrapType
	{
		WrapNone = 0,
		WrapToWindow = 1,
		WrapToTargetDevice = 2
	};
	int m_nWordWrap;
	int m_nBulletIndent;

	void SetPaperSize(CSize sizePaper);
	CSize GetPaperSize() const;
	void SetMargins(const CRect& rectMargin);
	CRect GetMargins() const;
	int GetPrintWidth() const;
	CRect GetPrintRect() const;
	CRect GetPageRect() const;

	//formatting
	CHARFORMAT& GetCharFormatSelection();
	PARAFORMAT& GetParaFormatSelection();
	void SetCharFormat(CHARFORMAT cf);
	void SetParaFormat(PARAFORMAT& pf);
	CRichEdit2CntrItem* GetSelectedItem() const;
	CRichEdit2CntrItem* GetInPlaceActiveItem() const;

	// CEdit control access
	CRichEdit2Ctrl& GetRichEditCtrl() const;
	CRichEdit2Doc* GetDocument() const;

	// other attributes
	long GetTextLength() const;
	static BOOL AFX_CDECL IsRichEdit2Format(CLIPFORMAT cf);
	BOOL CanPaste() const;

// Operations
public:
	void AdjustDialogPosition(CDialog* pDlg);
	HRESULT InsertItem(CRichEdit2CntrItem* pItem);
	void InsertFileAsObject(LPCTSTR lpszFileName);
	BOOL FindText(LPCTSTR lpszFind, BOOL bCase = TRUE, BOOL bWord = TRUE);
	BOOL FindTextSimple(LPCTSTR lpszFind, BOOL bCase = TRUE,
		BOOL bWord = TRUE);
	long PrintInsideRect(CDC* pDC, RECT& rectLayout, long nIndexStart,
		long nIndexStop, BOOL bOutput);
	long PrintPage(CDC* pDC, long nIndexStart, long nIndexStop);
	void DoPaste(COleDataObject& dataobj, CLIPFORMAT cf,
		HMETAFILEPICT hMetaPict);

// Helpers
	void OnCharEffect(DWORD dwMask, DWORD dwEffect);
	void OnUpdateCharEffect(CCmdUI* pCmdUI, DWORD dwMask, DWORD dwEffect) ;
	void OnParaAlign(WORD wAlign);
	void OnUpdateParaAlign(CCmdUI* pCmdUI, WORD wAlign);

// Overrideables
protected:
	virtual BOOL IsSelected(const CObject* pDocItem) const;
	virtual void OnInitialUpdate();
	virtual void OnFindNext(LPCTSTR lpszFind, BOOL bNext, BOOL bCase, BOOL bWord);
	virtual void OnReplaceSel(LPCTSTR lpszFind, BOOL bNext, BOOL bCase,
		BOOL bWord, LPCTSTR lpszReplace);
	virtual void OnReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace,
		BOOL bCase, BOOL bWord);
	virtual void OnTextNotFound(LPCTSTR lpszFind);
	virtual void OnPrinterChanged(const CDC& dcPrinter);
	virtual void WrapChanged();

// Advanced
	virtual BOOL OnPasteNativeObject(LPSTORAGE lpStg);
	virtual HMENU GetContextMenu(WORD, LPOLEOBJECT, CHARRANGE* );
	virtual HRESULT GetClipboardData(CHARRANGE* lpchrg, DWORD dwReco,
		LPDATAOBJECT lpRichDataObj, LPDATAOBJECT* lplpdataobj);
	virtual HRESULT QueryAcceptData(LPDATAOBJECT, CLIPFORMAT*, DWORD,
		BOOL, HGLOBAL);

// Implementation
public:
	LPRICHEDITOLE m_lpRichEditOle;
	CDC m_dcTarget;
	long m_lInitialSearchPos;
	UINT m_nPasteType;
	BOOL m_bFirstSearch;

	void TextNotFound(LPCTSTR lpszFind);
	BOOL FindText(_AFX_RICHEDIT2_STATE* pEditState);
	BOOL FindTextSimple(_AFX_RICHEDIT2_STATE* pEditState);
	long FindAndSelect(DWORD dwFlags, FINDTEXTEX& ft);
	void Stream(CArchive& ar, BOOL bSelection);
	HRESULT GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
		LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo);
	HRESULT ShowContainerUI(BOOL b);
	static DWORD CALLBACK EditStreamCallBack(DWORD dwCookie,
		LPBYTE pbBuff, LONG cb, LONG *pcb);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
	virtual void DeleteContents();
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);

	static AFX_DATA ULONG lMaxSize; // maximum number of characters supported

protected:
	CRect m_rectMargin;
	CSize m_sizePaper;
	CDWordArray m_aPageStart;    // array of starting pages
	PARAFORMAT m_paraformat;
	CHARFORMAT m_charformat;
	BOOL m_bSyncCharFormat;
	BOOL m_bSyncParaFormat;

	// construction
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	// printing support
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo = NULL);
	BOOL PaginateTo(CDC* pDC, CPrintInfo* pInfo);

	// find & replace support
	void OnEditFindReplace(BOOL bFindOnly);
	BOOL SameAsSelected(LPCTSTR lpszCompare, BOOL bCase, BOOL bWord);

	// special overrides for implementation

	//{{AFX_MSG(CRichEdit2View)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnUpdateNeedSel(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedClip(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedText(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedFind(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnEditCopy();
	afx_msg void OnEditPaste();
	afx_msg void OnEditClear();
	afx_msg void OnEditUndo();
	afx_msg void OnEditSelectAll();
	afx_msg void OnEditFind();
	afx_msg void OnEditReplace();
	afx_msg void OnEditRepeat();
	afx_msg void OnDestroy();
	afx_msg void OnEditProperties();
	afx_msg void OnUpdateEditProperties(CCmdUI* pCmdUI);
	afx_msg void OnInsertObject();
	afx_msg void OnCancelEditCntr();
	afx_msg void OnCharBold();
	afx_msg void OnUpdateCharBold(CCmdUI* pCmdUI);
	afx_msg void OnCharItalic();
	afx_msg void OnUpdateCharItalic(CCmdUI* pCmdUI);
	afx_msg void OnCharUnderline();
	afx_msg void OnUpdateCharUnderline(CCmdUI* pCmdUI);
	afx_msg void OnParaCenter();
	afx_msg void OnUpdateParaCenter(CCmdUI* pCmdUI);
	afx_msg void OnParaLeft();
	afx_msg void OnUpdateParaLeft(CCmdUI* pCmdUI);
	afx_msg void OnParaRight();
	afx_msg void OnUpdateParaRight(CCmdUI* pCmdUI);
	afx_msg void OnBullet();
	afx_msg void OnUpdateBullet(CCmdUI* pCmdUI);
	afx_msg void OnFormatFont();
	afx_msg void OnColorPick(COLORREF cr);
	afx_msg void OnColorDefault();
	afx_msg void OnEditPasteSpecial();
	afx_msg void OnUpdateEditPasteSpecial(CCmdUI* pCmdUI);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnDropFiles(HDROP hDropInfo);
	afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
	//}}AFX_MSG
	afx_msg LRESULT OnFindReplaceCmd(WPARAM, LPARAM lParam);
	afx_msg void OnSelChange(NMHDR* pNMHDR, LRESULT* pResult);

	DECLARE_MESSAGE_MAP()

// Interface Map
public:
	BEGIN_INTERFACE_PART(RichEditOleCallback, IRichEditOleCallback)
		INIT_INTERFACE_PART(CRichEdit2View, RichEditOleCallback)
		STDMETHOD(GetNewStorage) (LPSTORAGE*);
		STDMETHOD(GetInPlaceContext) (LPOLEINPLACEFRAME*,
									  LPOLEINPLACEUIWINDOW*,
									  LPOLEINPLACEFRAMEINFO);
		STDMETHOD(ShowContainerUI) (BOOL);
		STDMETHOD(QueryInsertObject) (LPCLSID, LPSTORAGE, LONG);
		STDMETHOD(DeleteObject) (LPOLEOBJECT);
		STDMETHOD(QueryAcceptData) (LPDATAOBJECT, CLIPFORMAT*, DWORD,BOOL, HGLOBAL);
		STDMETHOD(ContextSensitiveHelp) (BOOL);
		STDMETHOD(GetClipboardData) (CHARRANGE*, DWORD, LPDATAOBJECT*);
		STDMETHOD(GetDragDropEffect) (BOOL, DWORD, LPDWORD);
		STDMETHOD(GetContextMenu) (WORD, LPOLEOBJECT, CHARRANGE*, HMENU*);
	END_INTERFACE_PART(RichEditOleCallback)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc

class CRichEdit2Doc : public COleServerDoc
{
protected: // create from serialization only
	CRichEdit2Doc();
	DECLARE_DYNAMIC(CRichEdit2Doc)

// Attributes
public:
	BOOL m_bRTF;        // TRUE when formatted, FALSE when plain text
    BOOL m_bUnicode;    // TRUE if the doc is Unicode

	virtual CRichEdit2CntrItem* CreateClientItem(REOBJECT* preo = NULL) const = 0;

	virtual CRichEdit2View* GetView() const;
	int GetStreamFormat() const;
    BOOL IsUnicode() const;

// Implementation
protected:
	virtual COleServerItem* OnGetEmbeddedItem();
	void MarkItemsClear() const;
	void DeleteUnmarkedItems() const;
	void UpdateObjectCache();
public:
	BOOL m_bUpdateObjectCache;
	virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU);
	virtual void SetTitle(LPCTSTR lpszTitle);
	virtual COleClientItem* GetPrimarySelectedItem(CView* pView);
	virtual void DeleteContents();
	virtual POSITION GetStartPosition() const;
	virtual void PreCloseFrame(CFrameWnd* pFrameWnd);
	virtual void UpdateModifiedFlag();
	virtual BOOL IsModified();
	virtual void SetModifiedFlag(BOOL bModified = TRUE);
	virtual COleClientItem* GetInPlaceActiveItem(CWnd* pWnd);
	CRichEdit2CntrItem* LookupItem(LPOLEOBJECT lpobj) const;
	void InvalidateObjectCache();
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2CntrItem

class CRichEdit2CntrItem : public COleClientItem
{
	DECLARE_SERIAL(CRichEdit2CntrItem)

// Constructors
public:
	CRichEdit2CntrItem(REOBJECT* preo = NULL, CRichEdit2Doc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Operations
	void SyncToRichEditObject(REOBJECT& reo);

// Implementation
public:
	~CRichEdit2CntrItem();
	LPOLECLIENTSITE m_lpClientSite;
	BOOL m_bMark;
	BOOL m_bLock;   // lock it during creation to avoid deletion
	void Mark(BOOL b);
	BOOL IsMarked();
	CRichEdit2Doc* GetDocument();
	CRichEdit2View* GetActiveView();
	HRESULT ShowContainerUI(BOOL b);
	HRESULT GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
		LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo);
	virtual LPOLECLIENTSITE GetClientSite();
	virtual BOOL ConvertTo(REFCLSID clsidNew);
	virtual BOOL ActivateAs(LPCTSTR lpszUserType, REFCLSID clsidOld,
		REFCLSID clsidNew);
	virtual void SetDrawAspect(DVASPECT nDrawAspect);
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual BOOL CanActivate();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXRICH_INLINE inline
#include <afxrich2.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXRICH2_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\cntritem.cpp ===
// cntritem.cpp : implementation of the CWordPadCntrItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"

#include "wordpdoc.h"
#include "wordpvw.h"
#include "cntritem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWordPadCntrItem implementation

IMPLEMENT_SERIAL(CWordPadCntrItem, CRichEdit2CntrItem, 0)

CWordPadCntrItem::CWordPadCntrItem(REOBJECT *preo, CWordPadDoc* pContainer)
	: CRichEdit2CntrItem(preo, pContainer)
{
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadCntrItem diagnostics

#ifdef _DEBUG
void CWordPadCntrItem::AssertValid() const
{
	CRichEdit2CntrItem::AssertValid();
}

void CWordPadCntrItem::Dump(CDumpContext& dc) const
{
	CRichEdit2CntrItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\cntritem.h ===
// cntritem.h : interface of the CWordPadCntrItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CWordPadDoc;
class CWordPadView;

class CWordPadCntrItem : public CRichEdit2CntrItem
{
	DECLARE_SERIAL(CWordPadCntrItem)

// Constructors
public:
	CWordPadCntrItem(REOBJECT* preo = NULL, CWordPadDoc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Attributes
public:
	CWordPadDoc* GetDocument()
		{ return (CWordPadDoc*)COleClientItem::GetDocument(); }
	CWordPadView* GetActiveView()
		{ return (CWordPadView*)COleClientItem::GetActiveView(); }

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWordPadCntrItem)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\chicdial.cpp ===
// chicdial.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "fixhelp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCSDialog dialog

CCSDialog::CCSDialog(UINT nIDTemplate, CWnd* pParentWnd)
	: CDialog(nIDTemplate, pParentWnd)
{
}

CCSDialog::CCSDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd)
	: CDialog(lpszTemplateName, pParentWnd)
{
}

CCSDialog::CCSDialog() : CDialog()
{
}

BEGIN_MESSAGE_MAP(CCSDialog, CDialog)
	//{{AFX_MSG_MAP(CCSDialog)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnHelpContextMenu)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCSDialog message handlers

LONG CCSDialog::OnHelp(UINT, LONG lParam)
{
	::WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, AfxGetApp()->m_pszHelpFilePath,
		HELP_WM_HELP, (DWORD)(LPVOID)GetHelpIDs());
	return 0;
}

LONG CCSDialog::OnHelpContextMenu(UINT wParam, LONG)
{
	::WinHelp((HWND)wParam, AfxGetApp()->m_pszHelpFilePath,
		HELP_CONTEXTMENU, (DWORD)(LPVOID)GetHelpIDs());
	return 0;
}

BOOL CCSDialog::OnInitDialog()
{
   CDialog::OnInitDialog();
   ModifyStyleEx(0, WS_EX_CONTEXTHELP);
   FixHelp(this, FALSE) ;
   return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
// CCSPropertyPage

CCSPropertyPage::CCSPropertyPage(UINT nIDTemplate, UINT nIDCaption)
	: CPropertyPage(nIDTemplate, nIDCaption)
{
}

CCSPropertyPage::CCSPropertyPage(LPCTSTR lpszTemplateName,
	UINT nIDCaption) : CPropertyPage(lpszTemplateName, nIDCaption)
{
}

BEGIN_MESSAGE_MAP(CCSPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CCSPropertyPage)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnHelpContextMenu)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCSPropertyPage message handlers

LONG CCSPropertyPage::OnHelp(UINT, LONG lParam)
{
	::WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, AfxGetApp()->m_pszHelpFilePath,
		HELP_WM_HELP, (DWORD)(LPVOID)GetHelpIDs());
	return 0;
}

LONG CCSPropertyPage::OnHelpContextMenu(UINT wParam, LONG)
{
	::WinHelp((HWND)wParam, AfxGetApp()->m_pszHelpFilePath,
		HELP_CONTEXTMENU, (DWORD)(LPVOID)GetHelpIDs());
	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CCSPropertySheet

BEGIN_MESSAGE_MAP(CCSPropertySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CCSPropertySheet)
	//}}AFX_MSG_MAP
   ON_WM_NCCREATE()
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnHelpContextMenu)
END_MESSAGE_MAP()

CCSPropertySheet::CCSPropertySheet(UINT nIDCaption, CWnd *pParentWnd,
	UINT iSelectPage) : CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CCSPropertySheet::CCSPropertySheet(LPCTSTR pszCaption, CWnd *pParentWnd,
	UINT iSelectPage) : CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
}

/////////////////////////////////////////////////////////////////////////////
// CCSPropertySheet message handlers

LONG CCSPropertySheet::OnHelp(UINT wParam, LONG lParam)
{
	GetActivePage()->SendMessage(WM_HELP, wParam, lParam);
	return 0;
}

LONG CCSPropertySheet::OnHelpContextMenu(UINT wParam, LONG lParam)
{
	GetActivePage()->SendMessage(WM_CONTEXTMENU, wParam, lParam);
	return 0;
}

BOOL CCSPropertySheet::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.dwExStyle |= WS_EX_CONTEXTHELP;
	return CPropertySheet::PreCreateWindow(cs);
}

BOOL CCSPropertySheet::OnNcCreate(LPCREATESTRUCT)
{
   return (BOOL)Default() ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\afxdlgs2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDLGS2_H__
#define __AFXDLGS2_H__

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#ifndef _INC_COMMDLG
	#include <commdlg.h>    // common dialog APIs
#endif

	#ifndef _RICHEDIT_
		#include <richedit.h>
	#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifndef _AFX_NOFORCE_LIBS
#ifndef _MAC

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#else //!_MAC

/////////////////////////////////////////////////////////////////////////////
// Mac libraries

#endif //_MAC
#endif //!_AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXDLGS - MFC Standard dialogs

// Classes declared in this file

	// CDialog
		//class CCommonDialog;  // implementation base class

			class CFontDialog2;    // Font chooser dialog

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
// CFontDialog2 - used to select a font

class CFontDialog2 : public CCommonDialog
{
	DECLARE_DYNAMIC(CFontDialog2)

public:
// Attributes
	// font choosing parameter block
	CHOOSEFONT m_cf;

// Constructors
	CFontDialog2(LPLOGFONT lplfInitial = NULL,
		DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
		CDC* pdcPrinter = NULL,
		CWnd* pParentWnd = NULL);
	CFontDialog2(const CHARFORMAT& charformat,
		DWORD dwFlags = CF_SCREENFONTS,
		CDC* pdcPrinter = NULL,
		CWnd* pParentWnd = NULL);
// Operations
	virtual int DoModal();

	// Get the selected font (works during DoModal displayed or after)
	void GetCurrentFont(LPLOGFONT lplf);

	// Helpers for parsing information after successful return
	CString GetFaceName() const;  // return the face name of the font
	CString GetStyleName() const; // return the style name of the font
	int GetSize() const;          // return the pt size of the font
	COLORREF GetColor() const;    // return the color of the font
	int GetWeight() const;        // return the chosen font weight
	BOOL IsStrikeOut() const;     // return TRUE if strikeout
	BOOL IsUnderline() const;     // return TRUE if underline
	BOOL IsBold() const;          // return TRUE if bold font
	BOOL IsItalic() const;        // return TRUE if italic font
	void GetCharFormat(CHARFORMAT& cf) const;

// Implementation
	LOGFONT m_lf; // default LOGFONT to store the info
	DWORD FillInLogFont(const CHARFORMAT& cf);

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	TCHAR m_szStyleName[64]; // contains style name after return
};


#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXDLGS_INLINE inline
#include <afxdlgs2.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXDLGS2_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\ddxm.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include <limits.h>
void PASCAL DDX_Twips(CDataExchange* pDX, int nIDC, int& value);
void PASCAL DDV_MinMaxTwips(CDataExchange* pDX, int value, int minVal, int maxVal);
#define DDXM_BLANK INT_MAX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\buttondi.h ===
// buttondi.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CButtonDialog dialog

class CButtonDialog : public CCSDialog
{
// Construction
public:
	CButtonDialog(LPCTSTR lpszText, LPCTSTR lpszCaption, LPCTSTR lpszButtons, 
		WORD wStyle, DWORD* pHelpIDs = NULL, CWnd* pParentWnd = NULL);
	~CButtonDialog();

// Attributes
	CFont m_font;
// Operations
	static int DisplayMessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption, 
		LPCTSTR lpszButtons, WORD wStyle, int nDef = 0, int nCancel = -1, 
		DWORD* pHelpIDs = NULL, CWnd* pParentWnd = NULL);

	void AddButton(CString& strButton) { m_strArray.Add(strButton);}
	void AddButtons(LPCTSTR lpszButton);
	void SetCancel(int nCancel)
		{ ASSERT(nCancel < m_strArray.GetSize()); m_nCancel = nCancel;}
	void SetDefault(int nDef)
		{ ASSERT(nDef < m_strArray.GetSize()); m_nDefButton = nDef;}
	void FillInHeader(LPDLGTEMPLATE lpDlgTmp);

// Overridables
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual int DoModal();

// Implementation
protected:
	virtual const DWORD* GetHelpIDs() {return m_pHelpIDs;}
	DWORD* m_pHelpIDs;
	int m_nDefButton;
	int m_nCancel;
	HGLOBAL m_hDlgTmp;
	UINT m_nBaseID;
	WORD m_wStyle;
	CButton* m_pButtons;
	CStatic m_staticIcon;
	CStatic m_staticText;
	CString m_strCaption;
	CString m_strText;
	CStringArray m_strArray;
	CSize GetBaseUnits();
	LPCTSTR GetIconID(WORD wFlags);
	void PositionControls();

	// Generated message map functions
	//{{AFX_MSG(CButtonDialog)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\ddxm.cpp ===
// ddxm.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ddxm.h"
#include "wordpad.h"
#include "resource.h"

// this routine prints a floatingpoint number with 2 digits after the decimal
void PASCAL DDX_Twips(CDataExchange* pDX, int nIDC, int& value)
{
	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	TCHAR szT[64];

	if (pDX->m_bSaveAndValidate)
	{
		::GetWindowText(hWndCtrl, szT, sizeof(szT));
		if (szT[0] != NULL) // not empty
		{
			if (!theApp.ParseMeasurement(szT, value))
			{
				AfxMessageBox(IDS_INVALID_MEASUREMENT,MB_OK|MB_ICONINFORMATION);
				pDX->Fail();            // throws exception
			}
			theApp.PrintTwips(szT, value, 2);
			theApp.ParseMeasurement(szT, value);
		}
		else // empty
			value = INT_MAX;
	}
	else
	{
		// convert from twips to default units
		if (value != INT_MAX)
		{
			theApp.PrintTwips(szT, value, 2);
			SetWindowText(hWndCtrl, szT);
		}
	}
}

void PASCAL DDV_MinMaxTwips(CDataExchange* pDX, int value, int minVal, int maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
	{
		// "The measurement must be between %1 and %2."
		if (!pDX->m_bSaveAndValidate)
		{
			TRACE0("Warning: initial dialog data is out of range.\n");
			return;     // don't stop now
		}
		TCHAR szMin[32];
		TCHAR szMax[32];
		theApp.PrintTwips(szMin, minVal, 2);
		theApp.PrintTwips(szMax, maxVal, 2);
		CString prompt;
		AfxFormatString2(prompt, IDS_MEASUREMENT_RANGE, szMin, szMax);
		AfxMessageBox(prompt, MB_ICONEXCLAMATION, AFX_IDS_APP_TITLE);
		prompt.Empty(); // exception prep
		pDX->Fail();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\datedial.cpp ===
// datedial.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "datedial.h"
#include "helpids.h"
#include <winnls.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

SYSTEMTIME CDateDialog::m_time;
LCID CDateDialog::m_id;
CListBox* CDateDialog::m_pListBox = NULL;

/////////////////////////////////////////////////////////////////////////////
// CDateDialog dialog

const DWORD CDateDialog::m_nHelpIDs[] =
{
	IDC_DATEDIALOG_LIST, IDH_WORDPAD_TIMEDATE,
	IDC_STATIC_HEADING, IDH_WORDPAD_TIMEDATE,
	0, 0
};

CDateDialog::CDateDialog(CWnd* pParent /*=NULL*/)
	: CCSDialog(CDateDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDateDialog)
	m_strSel = _T("");
	//}}AFX_DATA_INIT
}


void CDateDialog::DoDataExchange(CDataExchange* pDX)
{
	CCSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDateDialog)
	DDX_Control(pDX, IDC_DATEDIALOG_LIST, m_listBox);
	DDX_LBString(pDX, IDC_DATEDIALOG_LIST, m_strSel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDateDialog, CCSDialog)
	//{{AFX_MSG_MAP(CDateDialog)
	ON_LBN_DBLCLK(IDC_DATEDIALOG_LIST, OnDblclkDatedialogList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDateDialog message handlers

BOOL CDateDialog::OnInitDialog()
{
	CCSDialog::OnInitDialog();

	m_pListBox = &m_listBox; // set static member
	GetLocalTime(&m_time);
	m_id = GetUserDefaultLCID();
	
	EnumDateFormats(DateFmtEnumProc, m_id, DATE_SHORTDATE);
	EnumDateFormats(DateFmtEnumProc, m_id, DATE_LONGDATE);
	EnumTimeFormats(TimeFmtEnumProc, m_id, 0);

	m_pListBox = NULL;
	m_listBox.SetCurSel(0);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CALLBACK CDateDialog::DateFmtEnumProc(LPTSTR lpszFormatString)
{
	ASSERT(m_pListBox != NULL);

	TCHAR buffer[256];
    TCHAR *buf = buffer;

	VERIFY(GetDateFormat(m_id, 0, &m_time, lpszFormatString, buf, 256));

    // Strip leading blanks

    while (_istspace(*buf))
        ++buf;

	// we can end up with same format because a format with leading
	// zeroes may be the same as one without when a number is big enough
	// e.g. 09/10/94 9/10/94 are different but 10/10/94 and 10/10/94 are
	// the same
	if (m_pListBox->FindStringExact(-1,buf) == CB_ERR)
		m_pListBox->AddString(buf);
	return TRUE;
}

BOOL CALLBACK CDateDialog::TimeFmtEnumProc(LPTSTR lpszFormatString)
{
	ASSERT(m_pListBox != NULL);

	TCHAR buffer[256];
    TCHAR *buf = buffer;

	VERIFY(GetTimeFormat(m_id, 0, &m_time, lpszFormatString, buf, 256));

    // Strip leading blanks

    while (_istspace(*buf))
        ++buf;

	// we can end up with same format because a format with leading
	// zeroes may be the same as one without when a number is big enough
	// e.g. 09/10/94 9/10/94 are different but 10/10/94 and 10/10/94 are
	// the same
	if (m_pListBox->FindStringExact(-1,buf) == CB_ERR)
		m_pListBox->AddString(buf);
	return TRUE;
}

void CDateDialog::OnDblclkDatedialogList()
{
	OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\docopt.h ===
// docopt.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CDocOptPage dialog

class CDocOptPage : public CCSPropertyPage
{
// Construction
public:
	CDocOptPage();
	CDocOptPage(UINT nIDCaption);
	~CDocOptPage();

// Dialog Data
	//{{AFX_DATA(CDocOptPage)
	enum { IDD = IDD_OPTIONS_WRAP };
	int		m_nWordWrap;
	BOOL	m_bFormatBar;
	BOOL	m_bRulerBar;
	BOOL	m_bStatusBar;
	BOOL	m_bToolBar;
	//}}AFX_DATA


// Overrides
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDocOptPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDocOptPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CEmbeddedOptPage : public CDocOptPage
{
// Construction
public:
	CEmbeddedOptPage();
// Overrides
	BOOL OnInitDialog();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\colorlis.cpp ===
// colorlis.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "colorlis.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CColorMenu

/*
int BASED_CODE CColorMenu::indexMap[17] = {
	0, 		//black
	19, 	//white
	13, 	//red
	14, 	//green
	16, 	//blue
	15, 	//yellow
	17, 	//magenta
	18, 	//cyan
	1, 		//dark red
	2, 		//dark green
	4, 		//dark blue
	3, 		//light brown
	5, 		//purple
	6, 		//dark cyan
	7, 		//light gray
	12, 	//gray
	0};		//automatic
*/

int BASED_CODE CColorMenu::indexMap[17] = {
	0, 		//black
	1, 		//dark red
	2, 		//dark green
	3, 		//light brown
	4, 		//dark blue
	5, 		//purple
	6, 		//dark cyan
	12, 	//gray
	7, 		//light gray
	13, 	//red
	14, 	//green
	15, 	//yellow
	16, 	//blue
	17, 	//magenta
	18, 	//cyan
	19, 	//white
	0};		//automatic

CColorMenu::CColorMenu()
{
	VERIFY(CreatePopupMenu());
	ASSERT(GetMenuItemCount()==0);
	for (int i=0; i<=16;i++)
		VERIFY(AppendMenu(MF_OWNERDRAW, ID_COLOR0+i, (LPCTSTR)(ID_COLOR0+i)));
}

COLORREF CColorMenu::GetColor(UINT id)
{
	ASSERT(id >= ID_COLOR0);
	ASSERT(id <= ID_COLOR16);
	if (id == ID_COLOR16) // autocolor
		return ::GetSysColor(COLOR_WINDOWTEXT);
	else
	{
		CPalette* pPal = CPalette::FromHandle( (HPALETTE) GetStockObject(DEFAULT_PALETTE));
		ASSERT(pPal != NULL);
		PALETTEENTRY pe;
		if (pPal->GetPaletteEntries(indexMap[id-ID_COLOR0], 1, &pe) == 0)
			return ::GetSysColor(COLOR_WINDOWTEXT);
		else
			return RGB(pe.peRed,pe.peGreen,pe.peBlue);
//		return PALETTEINDEX(CColorMenu::indexMap[id-ID_COLOR0]);
	}
}

void CColorMenu::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	ASSERT(lpDIS->CtlType == ODT_MENU);
	UINT id = (UINT)(WORD)lpDIS->itemID;
	ASSERT(id == lpDIS->itemData);
	ASSERT(id >= ID_COLOR0);
	ASSERT(id <= ID_COLOR16);
	CDC dc;
	dc.Attach(lpDIS->hDC);

	CRect rc(lpDIS->rcItem);
	ASSERT(rc.Width() < 500);
	if (lpDIS->itemState & ODS_FOCUS)
		dc.DrawFocusRect(&rc);

	COLORREF cr = (lpDIS->itemState & ODS_SELECTED) ? 
		::GetSysColor(COLOR_HIGHLIGHT) :
		dc.GetBkColor();

	CBrush brushFill(cr);
	cr = dc.GetTextColor();

	if (lpDIS->itemState & ODS_SELECTED)
		dc.SetTextColor(::GetSysColor(COLOR_HIGHLIGHTTEXT));

	int nBkMode = dc.SetBkMode(TRANSPARENT);
	dc.FillRect(&rc, &brushFill);

	rc.left += 50;
	CString strColor;
	strColor.LoadString(id);
	dc.TextOut(rc.left,rc.top,strColor,strColor.GetLength());
	rc.left -= 45;
	rc.top += 2;
	rc.bottom -= 2;
	rc.right = rc.left + 40;
	CBrush brush(GetColor(id));
	CBrush* pOldBrush = dc.SelectObject(&brush);
	dc.Rectangle(rc);

	dc.SelectObject(pOldBrush);
	dc.SetTextColor(cr);
	dc.SetBkMode(nBkMode);
	
	dc.Detach();
}

void CColorMenu::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
	ASSERT(lpMIS->CtlType == ODT_MENU);
	UINT id = (UINT)(WORD)lpMIS->itemID;
	ASSERT(id == lpMIS->itemData);
	ASSERT(id >= ID_COLOR0);
	ASSERT(id <= ID_COLOR16);
	CDisplayIC dc;
	CString strColor;
	strColor.LoadString(id);
	CSize sizeText = dc.GetTextExtent(strColor,strColor.GetLength());
	ASSERT(sizeText.cx < 500);
	lpMIS->itemWidth = sizeText.cx + 50;
	lpMIS->itemHeight = sizeText.cy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\datedial.h ===
// datedial.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CDateDialog dialog

class CDateDialog : public CCSDialog
{
// Construction
public:
	CDateDialog(CWnd* pParent = NULL);   // standard constructor

// Attributes
	static SYSTEMTIME m_time;
	static LCID m_id;
	static CListBox* m_pListBox;
	static BOOL CALLBACK DateFmtEnumProc(LPTSTR lpszFormatString);
	static BOOL CALLBACK TimeFmtEnumProc(LPTSTR lpszFormatString);

// Dialog Data
	//{{AFX_DATA(CDateDialog)
	enum { IDD = IDD_DATEDIALOG };
	CListBox	m_listBox;
	CString	m_strSel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDateDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}

	// Generated message map functions
	//{{AFX_MSG(CDateDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkDatedialogList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\dlgcomm.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "stdafx2.h"
#include <dlgs.h>

#ifdef AFX_AUX_SEG
#pragma code_seg(AFX_AUX_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

static const UINT nMsgLBSELCHANGE = ::RegisterWindowMessage(LBSELCHSTRING);
static const UINT nMsgSHAREVI = ::RegisterWindowMessage(SHAREVISTRING);
static const UINT nMsgFILEOK = ::RegisterWindowMessage(FILEOKSTRING);
static const UINT nMsgCOLOROK = ::RegisterWindowMessage(COLOROKSTRING);
static const UINT nMsgHELP = ::RegisterWindowMessage(HELPMSGSTRING);

UINT CALLBACK
_AfxCommDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	if (hWnd == NULL)
		return 0;
/*
	_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
	if (pThreadState->m_pAlternateWndInit != NULL)
	{
		ASSERT_KINDOF(CFileDialog,pThreadState->m_pAlternateWndInit);
		pThreadState->m_pAlternateWndInit->SubclassWindow(hWnd);
		pThreadState->m_pAlternateWndInit = NULL;
	}
	ASSERT(pThreadState->m_pAlternateWndInit == NULL);
*/
	if (message == WM_INITDIALOG)
		return (UINT)AfxDlgProc(hWnd, message, wParam, lParam);

	if (message == nMsgHELP ||
	   (message == WM_COMMAND && LOWORD(wParam) == pshHelp))
	{
		// just translate the message into the AFX standard help command.
		SendMessage(hWnd, WM_COMMAND, ID_HELP, 0);
		return 1;
	}

	if (message < 0xC000)
	{
		// not a ::RegisterWindowMessage message
		return 0;
	}

	// assume it is already wired up to a permanent one
	CDialog* pDlg = (CDialog*)CWnd::FromHandlePermanent(hWnd);
	ASSERT(pDlg != NULL);
	ASSERT_KINDOF(CDialog, pDlg);

	if (pDlg->IsKindOf(RUNTIME_CLASS(CFileDialog)))
	{
		// If we're exploring then we are not interested in the Registered messages
		if (((CFileDialog*)pDlg)->m_ofn.Flags & OFN_EXPLORER)
			return 0;
	}

	// RegisterWindowMessage - does not copy to lastState buffer, so
	// CWnd::GetCurrentMessage and CWnd::Default will NOT work
	// while in these handlers

	// Dispatch special commdlg messages through our virtual callbacks
	if (message == nMsgSHAREVI)
	{
		ASSERT_KINDOF(CFileDialog, pDlg);
		return ((CFileDialog*)pDlg)->OnShareViolation((LPCTSTR)lParam);
	}
	else if (message == nMsgFILEOK)
	{
		ASSERT_KINDOF(CFileDialog, pDlg);

		if (afxData.bWin4)
			((CFileDialog*)pDlg)->m_pofnTemp = (OPENFILENAME*)lParam;

		BOOL bResult = ((CFileDialog*)pDlg)->OnFileNameOK();

		((CFileDialog*)pDlg)->m_pofnTemp = NULL;

		return bResult;
	}
	else if (message == nMsgLBSELCHANGE)
	{
		ASSERT_KINDOF(CFileDialog, pDlg);
		((CFileDialog*)pDlg)->OnLBSelChangedNotify(wParam, LOWORD(lParam),
				HIWORD(lParam));
		return 0;
	}
	else if (message == nMsgCOLOROK)
	{
		ASSERT_KINDOF(CColorDialog, pDlg);
		return ((CColorDialog*)pDlg)->OnColorOK();
	}
/*
//
// _afxNMsgSETRGB causes problems with the build.   Since it's not used 
// for anything anyway, don't use it.
//

	else if (message == _afxNMsgSETRGB)
	{
		// nothing to do here, since this is a SendMessage
		return 0;
	}
*/
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\chicdial.h ===
// chicdial.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CCSDialog dialog

class CCSDialog : public CDialog
{
// Construction
public:
	CCSDialog();
	CCSDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
	CCSDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);

// Implementation
protected:
	virtual const DWORD* GetHelpIDs() = 0;

	// Generated message map functions
	//{{AFX_MSG(CCSDialog)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	afx_msg LONG OnHelp(UINT wParam, LONG lParam);
	afx_msg LONG OnHelpContextMenu(UINT wParam, LONG lParam);
	DECLARE_MESSAGE_MAP()
};

class CCSPropertyPage : public CPropertyPage
{
// Construction
public:
	CCSPropertyPage(UINT nIDTemplate, UINT nIDCaption = 0);
	CCSPropertyPage(LPCTSTR lpszTemplateName, UINT nIDCaption = 0);

// Implementation
protected:
	virtual const DWORD* GetHelpIDs() = 0;

	// Generated message map functions
	//{{AFX_MSG(CCSPropertyPage)
	//}}AFX_MSG
	afx_msg LONG OnHelp(UINT wParam, LONG lParam);
	afx_msg LONG OnHelpContextMenu(UINT wParam, LONG lParam);
	DECLARE_MESSAGE_MAP()
};

class CCSPropertySheet : public CPropertySheet
{
// Construction
public:
	CCSPropertySheet(UINT nIDCaption, CWnd *pParentWnd = NULL,
		UINT iSelectPage = 0);
	CCSPropertySheet(LPCTSTR pszCaption, CWnd *pParentWnd = NULL,
		UINT iSelectPage = 0);
// Implementation
protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	// Generated message map functions
	//{{AFX_MSG(CCSPropertySheet)
	//}}AFX_MSG
	afx_msg LONG OnHelp(UINT wParam, LONG lParam);
	afx_msg LONG OnHelpContextMenu(UINT wParam, LONG lParam);
   afx_msg BOOL OnNcCreate(LPCREATESTRUCT);
	DECLARE_MESSAGE_MAP()
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\filenewd.h ===
// filenewd.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CFileNewDialog dialog

class CFileNewDialog : public CCSDialog
{
// Construction
public:
	CFileNewDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CFileNewDialog)
	enum { IDD = IDD_FILENEWDIALOG };
	CListBox	m_listbox;
	int		m_nSel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileNewDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}

	// Generated message map functions
	//{{AFX_MSG(CFileNewDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkDatedialogList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\colorlis.h ===
// colorlis.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CColorMenu window

class CColorMenu : public CMenu
{
// Construction
public:
	CColorMenu();

// Attributes
public:
	static int BASED_CODE indexMap[17];
	static COLORREF GetColor(UINT id);

// Operations
public:

// Implementation
public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);

};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\fixhelp.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

extern BOOL g_fDisableStandardHelp ;

extern HHOOK g_HelpFixHook ;

void FixHelp(CWnd* pWnd, BOOL fFixWndProc);

void SetHelpFixHook(void) ;

void RemoveHelpFixHook(void) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\dlgfnt.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "stdafx2.h"

#ifdef AFX_AUX_SEG
#pragma code_seg(AFX_AUX_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Choose Font dialog

CFontDialog2::CFontDialog2(LPLOGFONT lplfInitial, DWORD dwFlags, CDC* pdcPrinter,
	CWnd* pParentWnd) : CCommonDialog(pParentWnd)
{
	memset(&m_cf, 0, sizeof(m_cf));
	memset(&m_lf, 0, sizeof(m_lf));
	memset(&m_szStyleName, 0, sizeof(m_szStyleName));

	m_nIDHelp = AFX_IDD_FONT;

	m_cf.lStructSize = sizeof(m_cf);
	m_cf.lpszStyle = (LPTSTR)&m_szStyleName;
	m_cf.Flags = dwFlags | CF_ENABLEHOOK | CF_NOVERTFONTS;
	if (!afxData.bWin4 && AfxHelpEnabled())
		m_cf.Flags |= CF_SHOWHELP;
	m_cf.lpfnHook = (COMMDLGPROC)_AfxCommDlgProc;

	if (lplfInitial)
	{
		m_cf.lpLogFont = lplfInitial;
		m_cf.Flags |= CF_INITTOLOGFONTSTRUCT;
		memcpy(&m_lf, m_cf.lpLogFont, sizeof(m_lf));
	}
	else
	{
		m_cf.lpLogFont = &m_lf;
	}

	if (pdcPrinter)
	{
		ASSERT(pdcPrinter->m_hDC != NULL);
		m_cf.hDC = pdcPrinter->m_hDC;
		m_cf.Flags |= CF_PRINTERFONTS;
	}
}

CFontDialog2::CFontDialog2(const CHARFORMAT& charformat, DWORD dwFlags,
	CDC* pdcPrinter, CWnd* pParentWnd) : CCommonDialog(pParentWnd)
{
	memset(&m_cf, 0, sizeof(m_cf));
	memset(&m_lf, 0, sizeof(m_lf));
	memset(&m_szStyleName, 0, sizeof(m_szStyleName));

	m_nIDHelp = AFX_IDD_FONT;

	m_cf.lStructSize = sizeof(m_cf);
	m_cf.lpszStyle = (LPTSTR)&m_szStyleName;
	m_cf.Flags = dwFlags | CF_ENABLEHOOK | CF_INITTOLOGFONTSTRUCT
                                         | CF_NOVERTFONTS;
	m_cf.Flags |= FillInLogFont(charformat);
	if (!afxData.bWin4 && AfxHelpEnabled())
		m_cf.Flags |= CF_SHOWHELP;
	m_cf.lpfnHook = (COMMDLGPROC)_AfxCommDlgProc;

	m_cf.lpLogFont = &m_lf;

	if (pdcPrinter)
	{
		ASSERT(pdcPrinter->m_hDC != NULL);
		m_cf.hDC = pdcPrinter->m_hDC;
		m_cf.Flags |= CF_PRINTERFONTS;
	}
	if (charformat.dwMask & CFM_COLOR)
		m_cf.rgbColors = charformat.crTextColor;
}

int CFontDialog2::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_cf.Flags & CF_ENABLEHOOK);
	ASSERT(m_cf.lpfnHook != NULL); // can still be a user hook

	m_cf.hwndOwner = PreModal();
	int nResult = ::ChooseFont(&m_cf);
	PostModal();

	if (nResult == IDOK)
	{
		// copy logical font from user's initialization buffer (if needed)
		memcpy(&m_lf, m_cf.lpLogFont, sizeof(m_lf));
		return IDOK;
	}
	return nResult ? nResult : IDCANCEL;
}

void CFontDialog2::GetCurrentFont(LPLOGFONT lplf)
{
	ASSERT(lplf != NULL);

	if (m_hWnd != NULL)
		SendMessage(WM_CHOOSEFONT_GETLOGFONT, 0, (DWORD)(LPVOID)lplf);
	else
		*lplf = m_lf;
}

////////////////////////////////////////////////////////////////////////////
// CFontDialog2 CHARFORMAT helpers

DWORD CFontDialog2::FillInLogFont(const CHARFORMAT& cf)
{
	USES_CONVERSION;
	DWORD dwFlags = 0;
	if (cf.dwMask & CFM_SIZE)
	{
		CDC dc;
		dc.CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
		LONG yPerInch = dc.GetDeviceCaps(LOGPIXELSY);
		m_lf.lfHeight = -(int) ((cf.yHeight * yPerInch) / 1440);
	}
	else
		m_lf.lfHeight = 0;

	m_lf.lfWidth = 0;
	m_lf.lfEscapement = 0;
	m_lf.lfOrientation = 0;

	if ((cf.dwMask & (CFM_ITALIC|CFM_BOLD)) == (CFM_ITALIC|CFM_BOLD))
	{
		m_lf.lfWeight = (cf.dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;
		m_lf.lfItalic = (BYTE)((cf.dwEffects & CFE_ITALIC) ? TRUE : FALSE);
	}
	else
	{
		dwFlags |= CF_NOSTYLESEL;
		m_lf.lfWeight = FW_DONTCARE;
		m_lf.lfItalic = FALSE;
	}

	if ((cf.dwMask & (CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR)) ==
		(CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR))
	{
		dwFlags |= CF_EFFECTS;
		m_lf.lfUnderline = (BYTE)((cf.dwEffects & CFE_UNDERLINE) ? TRUE : FALSE);
		m_lf.lfStrikeOut = (BYTE)((cf.dwEffects & CFE_STRIKEOUT) ? TRUE : FALSE);
	}
	else
	{
		m_lf.lfUnderline = (BYTE)FALSE;
		m_lf.lfStrikeOut = (BYTE)FALSE;
	}

	if (cf.dwMask & CFM_CHARSET)
		m_lf.lfCharSet = cf.bCharSet;
	else
		dwFlags |= CF_NOSCRIPTSEL;
	m_lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
	m_lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	m_lf.lfQuality = DEFAULT_QUALITY;
	if (cf.dwMask & CFM_FACE)
	{
		m_lf.lfPitchAndFamily = cf.bPitchAndFamily;
		lstrcpy(m_lf.lfFaceName, cf.szFaceName);
	}
	else
	{
		m_lf.lfPitchAndFamily = DEFAULT_PITCH|FF_DONTCARE;
		m_lf.lfFaceName[0] = (TCHAR)0;
	}
	return dwFlags;
}

void CFontDialog2::GetCharFormat(CHARFORMAT& cf) const
{
	USES_CONVERSION;
	cf.dwEffects = 0;
	cf.dwMask = 0;
	if ((m_cf.Flags & CF_NOSTYLESEL) == 0)
	{
		cf.dwMask |= CFM_BOLD | CFM_ITALIC;
		cf.dwEffects |= (IsBold()) ? CFE_BOLD : 0;
		cf.dwEffects |= (IsItalic()) ? CFE_ITALIC : 0;
	}
	if ((m_cf.Flags & CF_NOSIZESEL) == 0)
	{
		cf.dwMask |= CFM_SIZE;
		//GetSize() returns in tenths of points so mulitply by 2 to get twips
		cf.yHeight = GetSize()*2;
	}

	if ((m_cf.Flags & CF_NOFACESEL) == 0)
	{
		cf.dwMask |= CFM_FACE;
		cf.bPitchAndFamily = m_cf.lpLogFont->lfPitchAndFamily;
		lstrcpy(cf.szFaceName, GetFaceName());
	}

	if (m_cf.Flags & CF_EFFECTS)
	{
		cf.dwMask |= CFM_UNDERLINE | CFM_STRIKEOUT | CFM_COLOR;
		cf.dwEffects |= (IsUnderline()) ? CFE_UNDERLINE : 0;
		cf.dwEffects |= (IsStrikeOut()) ? CFE_STRIKEOUT : 0;
		cf.crTextColor = GetColor();
	}
	if ((m_cf.Flags & CF_NOSCRIPTSEL) == 0)
	{
		cf.bCharSet = m_cf.lpLogFont->lfCharSet;
		cf.dwMask |= CFM_CHARSET;
	}
	cf.yOffset = 0;
}

////////////////////////////////////////////////////////////////////////////
// CFontDialog2 diagnostics

#ifdef _DEBUG
void CFontDialog2::Dump(CDumpContext& dc) const
{
	CDialog::Dump(dc);

	dc << "m_cf.hwndOwner = " << (UINT)m_cf.hwndOwner;
	dc << "\nm_cf.hDC = " << (UINT)m_cf.hDC;
	dc << "\nm_cf.iPointSize = " << m_cf.iPointSize;
	dc << "\nm_cf.Flags = " << (LPVOID)m_cf.Flags;
	dc << "\nm_cf.lpszStyle = " << m_cf.lpszStyle;
	dc << "\nm_cf.nSizeMin = " << m_cf.nSizeMin;
	dc << "\nm_cf.nSizeMax = " << m_cf.nSizeMax;
	dc << "\nm_cf.nFontType = " << m_cf.nFontType;
	dc << "\nm_cf.rgbColors = " << (LPVOID)m_cf.rgbColors;

	if (m_cf.lpfnHook == (COMMDLGPROC)_AfxCommDlgProc)
		dc << "\nhook function set to standard MFC hook function";
	else
		dc << "\nhook function set to non-standard hook function";

	dc << "\n";
}
#endif //_DEBUG

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_DYNAMIC(CFontDialog2, CDialog)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\docopt.cpp ===
// docopt.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "docopt.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDocOptPage property page

const DWORD CDocOptPage::m_nHelpIDs[] = 
{
	IDC_BOX, IDH_COMM_GROUPBOX,
	IDC_WRAP_NONE, IDH_WORDPAD_WRAP_NO,
	IDC_WRAP_WINDOW, IDH_WORDPAD_WRAP_WINDOW,
	IDC_WRAP_RULER, IDH_WORDPAD_WRAP_RULER,
	IDC_BOXT, IDH_COMM_GROUPBOX,
	IDC_CHECK_TOOLBAR, IDH_WORDPAD_CHECK_TOOLBAR,
	IDC_CHECK_FORMATBAR, IDH_WORDPAD_CHECK_FORMATBAR,
	IDC_CHECK_STATUSBAR, IDH_WORDPAD_CHECK_STATUSBAR,
	IDC_CHECK_RULERBAR, IDH_WORDPAD_CHECK_RULERBAR,
	0, 0
};

CDocOptPage::CDocOptPage() : CCSPropertyPage(CDocOptPage::IDD)
{
	//{{AFX_DATA_INIT(CDocOptPage)
	m_nWordWrap = -1;
	m_bFormatBar = FALSE;
	m_bRulerBar = FALSE;
	m_bStatusBar = FALSE;
	m_bToolBar = FALSE;
	//}}AFX_DATA_INIT
}

CDocOptPage::CDocOptPage(UINT nIDCaption) : 
	CCSPropertyPage(CDocOptPage::IDD, nIDCaption)
{
	m_nWordWrap = -1;
	m_bFormatBar = FALSE;
	m_bRulerBar = FALSE;
	m_bStatusBar = FALSE;
	m_bToolBar = FALSE;
}

CDocOptPage::~CDocOptPage()
{
}

void CDocOptPage::DoDataExchange(CDataExchange* pDX)
{
	CCSPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDocOptPage)
	DDX_Radio(pDX, IDC_WRAP_NONE, m_nWordWrap);
	DDX_Check(pDX, IDC_CHECK_FORMATBAR, m_bFormatBar);
	DDX_Check(pDX, IDC_CHECK_RULERBAR, m_bRulerBar);
	DDX_Check(pDX, IDC_CHECK_STATUSBAR, m_bStatusBar);
	DDX_Check(pDX, IDC_CHECK_TOOLBAR, m_bToolBar);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDocOptPage, CCSPropertyPage)
	//{{AFX_MSG_MAP(CDocOptPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDocOptPage message handlers

/////////////////////////////////////////////////////////////////////////////
// CEmbeddedOptPage property page

CEmbeddedOptPage::CEmbeddedOptPage() : CDocOptPage(IDS_EMBEDDED_OPTIONS)
{
}

BOOL CEmbeddedOptPage::OnInitDialog()
{
	BOOL b = CDocOptPage::OnInitDialog();
	GetDlgItem(IDC_CHECK_STATUSBAR)->ShowWindow(SW_HIDE);
	return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\formatpa.h ===
// formatpa.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CFormatParaDlg dialog

class CFormatParaDlg : public CCSDialog
{
// Construction
public:
	CFormatParaDlg(PARAFORMAT& pf, CWnd* pParent = NULL);   // standard constructor
	PARAFORMAT m_pf;

// Attributes
	int m_nWordWrap;

// Dialog Data
	//{{AFX_DATA(CFormatParaDlg)
	enum { IDD = IDD_FORMAT_PARA };
	int     m_nAlignment;
	int		m_nFirst;
	int		m_nLeft;
	int		m_nRight;
	//}}AFX_DATA

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnOK();

	// Generated message map functions
	//{{AFX_MSG(CFormatParaDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\doctype.h ===
// doctype.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#define RD_WINWORD2     0
#define RD_WINWORD6     1
#define RD_WORD97       2
#define RD_WORDPAD      3
#define RD_WRITE        4
#define RD_RICHTEXT     5
#define RD_TEXT         6
#define RD_OEMTEXT      7
#define RD_UNICODETEXT  8
#define RD_ALL          9
#define RD_EMBEDDED    10
#define RD_FEWINWORD5  11
#define NUM_DOC_TYPES  12

#define RD_DEFAULT RD_WORDPAD
#define RD_NATIVE RD_RICHTEXT

typedef BOOL (*PISFORMATFUNC)(LPCSTR pszConverter, LPCSTR pszPathName);
inline BOOL IsTextType(int nType) 
{
    return ((nType==RD_TEXT) || (nType==RD_OEMTEXT) || (nType==RD_UNICODETEXT));
}

struct DocType
{
public:
	int nID;
	int idStr;
	BOOL bRead;
	BOOL bWrite;
	BOOL bDup;
	LPTSTR pszConverterName;
	CString GetString(int nID);
};

#define DOCTYPE_DOCTYPE 0
#define DOCTYPE_DESC 1
#define DOCTYPE_EXT 2
#define DOCTYPE_PROGID 3

#define DECLARE_DOCTYPE(name, b1, b2, b3, p) \
{RD_##name, IDS_##name##_DOC, b1, b2, b3, p}
#define DECLARE_DOCTYPE_SYN(actname, name, b1, b2, b3, p) \
{RD_##actname, IDS_##name##_DOC, b1, b2, b3, p}
#define DECLARE_DOCTYPE_NULL(name, b1, b2, b3, p) \
{RD_##name, NULL, b1, b2, b3, p}

extern DocType doctypes[NUM_DOC_TYPES];
extern int GetDocTypeFromName(LPCTSTR pszPathName, CFileException& fe);
extern void ScanForConverters();
int GetIndexFromType(int nType, BOOL bOpen);
int GetTypeFromIndex(int nType, BOOL bOpen);
CString GetExtFromType(int nDocType);
CString GetFileTypes(BOOL bOpen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\doctype.cpp ===
// doctype.cpp
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "resource.h"
#include "strings.h"

#include "multconv.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static const BYTE byteRTFPrefix[5] = {'{', '\\', 'r', 't', 'f'};
static const BYTE byteWord2Prefix[4] = {0xDB, 0xA5, 0x2D, 0x00};
static const BYTE byteCompFilePrefix[8] = {0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1};
static const BYTE byteWrite1Prefix[2] = {0x31, 0xBE};
static const BYTE byteWrite2Prefix[2] = {0x32, 0xBE};
static const BYTE byteWord5JPrefix[2] = {0x94, 0xA6};
static const BYTE byteWord5KPrefix[2] = {0x95, 0xA6};
static const BYTE byteWord5TPrefix[2] = {0x96, 0xA6};

//
// Registry paths to converter information.  Note that the array sizes must be
// at least MAX_PATH because the contents of the array will be replaced with
// the filesystem path in ScanForConverters.
//

#define CONVERTER_PATH(x) TEXT("Software\\Microsoft\\Shared Tools\\")   \
                            TEXT("Text Converters\\Import\\") TEXT(x)

TCHAR szWordConverter[MAX_PATH] = CONVERTER_PATH("MSWord6.wpc");
TCHAR szWriteConverter[MAX_PATH] = CONVERTER_PATH("MSWinWrite.wpc");
TCHAR szWord97Converter[MAX_PATH] = CONVERTER_PATH("MSWord8");

#undef CONVERTER_PATH

/////////////////////////////////////////////////////////////////////////////

static BOOL IsConverterFormat(LPCTSTR pszConverter, LPCTSTR pszPathName);
static BOOL IsWord6(LPCTSTR pszPathName);

DocType doctypes[NUM_DOC_TYPES] =
{
    DECLARE_DOCTYPE(WINWORD2, FALSE, FALSE, FALSE, NULL),
    DECLARE_DOCTYPE(WINWORD6, TRUE, FALSE, TRUE, szWordConverter),
    DECLARE_DOCTYPE(WORD97, TRUE, FALSE, FALSE, szWord97Converter),
    DECLARE_DOCTYPE_SYN(WORDPAD, WINWORD6, TRUE, TRUE, FALSE, szWordConverter),
    DECLARE_DOCTYPE(WRITE, TRUE, FALSE, FALSE, szWriteConverter),
    DECLARE_DOCTYPE(RICHTEXT, TRUE, TRUE, FALSE, NULL),
    DECLARE_DOCTYPE(TEXT, TRUE, TRUE, FALSE, NULL),
    DECLARE_DOCTYPE(OEMTEXT, TRUE, TRUE, FALSE, NULL),
    DECLARE_DOCTYPE(UNICODETEXT, TRUE, TRUE, FALSE, NULL),
    DECLARE_DOCTYPE(ALL, TRUE, FALSE, FALSE, NULL),
    DECLARE_DOCTYPE_NULL(EMBEDDED, FALSE, FALSE, FALSE, NULL)
};

CString DocType::GetString(int nID)
{
	ASSERT(idStr != NULL);
	CString str;
	VERIFY(str.LoadString(idStr));
	CString strSub;
	AfxExtractSubString(strSub, str, nID);
	return strSub;
}

static BOOL IsConverterFormat(LPCTSTR pszConverter, LPCTSTR pszPathName)
{
	CConverter conv(pszConverter);
	return conv.IsFormatCorrect(pszPathName);
}

static BOOL IsLeadMatch(CFile& file, const BYTE* pb, UINT nCount)
{
	// check for match at beginning of file
	BOOL b = FALSE;
	BYTE* buf = new BYTE[nCount];
	
	TRY
	{
		file.SeekToBegin();
		memset(buf, 0, nCount);
		file.Read(buf, nCount);
		if (memcmp(buf, pb, nCount) == 0)
			b = TRUE;
	}
	END_TRY

	delete [] buf;
	return b;
}

static BOOL IsWord6(LPCTSTR pszPathName)
{
        USES_CONVERSION;
        BOOL bRes = FALSE;
        // see who created it
        LPSTORAGE lpStorage;
        SCODE sc = StgOpenStorage(T2COLE(pszPathName), NULL,
                STGM_READ|STGM_SHARE_EXCLUSIVE, 0, 0, &lpStorage);
        if (sc == NOERROR)
        {
                LPSTREAM lpStream;
                sc = lpStorage->OpenStream(T2COLE(szSumInfo), NULL,
                        STGM_READ|STGM_SHARE_EXCLUSIVE, NULL, &lpStream);
                if (sc == NOERROR)
                {
                        lpStream->Release();
                        bRes = TRUE;
                }
                lpStorage->Release();
        }
        return bRes;
}

int GetDocTypeFromName(LPCTSTR pszPathName, CFileException& fe)
{
	CFile file;
	ASSERT(pszPathName != NULL);
	
	ScanForConverters();

	if (!file.Open(pszPathName, CFile::modeRead | CFile::shareDenyWrite, &fe))
		return -1;

	CFileStatus _stat;
	VERIFY(file.GetStatus(_stat));

	if (_stat.m_size == 0) // file is empty
	{
		CString ext = CString(pszPathName).Right(4);
		if (ext[0] != '.')
			return RD_TEXT;
		if (lstrcmpi(ext, _T(".doc"))==0)
			return RD_WORDPAD;
		if (lstrcmpi(ext, _T(".rtf"))==0)
			return RD_RICHTEXT;
		return RD_TEXT;
	}

	// RTF
	if (IsLeadMatch(file, byteRTFPrefix, sizeof(byteRTFPrefix)))
		return RD_RICHTEXT;

	// WORD 2
	if (IsLeadMatch(file, byteWord2Prefix, sizeof(byteWord2Prefix)))
		return RD_WINWORD2;
    
    // FarEast Word5, which is based on US Word 2
    if (IsLeadMatch(file, byteWord5JPrefix, sizeof(byteWord5JPrefix)) ||
        IsLeadMatch(file, byteWord5KPrefix, sizeof(byteWord5KPrefix)) ||
        IsLeadMatch(file, byteWord5TPrefix, sizeof(byteWord5TPrefix)))
    {
        return RD_FEWINWORD5;
    }
    
	// write file can start with 31BE or 32BE depending on whether it has
	// OLE objects in it or not
	if (IsLeadMatch(file, byteWrite1Prefix, sizeof(byteWrite1Prefix)) ||
		IsLeadMatch(file, byteWrite2Prefix, sizeof(byteWrite2Prefix)))
	{
		file.Close();
		if (IsConverterFormat(szWriteConverter, pszPathName))
			return RD_WRITE;
		else
			return RD_TEXT;
	}

	// test for compound file
	if (IsLeadMatch(file, byteCompFilePrefix, sizeof(byteCompFilePrefix)))
	{
		file.Close();

		if (IsConverterFormat(szWordConverter, pszPathName))
        {
            if (IsWord6(pszPathName))
                return RD_WINWORD6;
            else
                return RD_WORDPAD;
        }
		else if (IsConverterFormat(szWord97Converter, pszPathName))
        {
			return RD_WORD97;
        }

		return RD_TEXT;
	}

	return RD_TEXT;
}

//+--------------------------------------------------------------------------
//
//  Function:   ScanForConverters
//
//  Synopsis:   Check for any text converters
//
//  Parameters: None
//  
//  Returns:    void
//
//  Notes:      This routine will update the entries in the global doctypes
//              structure.  It should be called before trying to use the
//              converters.  The code will only run once, even if it is called
//              multiple times.
//
//              The doctypes structure is expected to be initialized with the
//              registry path to the converter.  This path is replaced with 
//              the filesystem path or NULL if an error occurs.
//
//---------------------------------------------------------------------------

void ScanForConverters()
{
#ifdef _DEBUG
#define TRACE_ERROR(error, api, string)                                     \
        {if (ERROR_SUCCESS != error)                                        \
                TRACE(                                                      \
                    TEXT("Wordpad: error 0x%08x from %s looking for")       \
                                    TEXT("\r\n\t%s\r\n"),                   \
                    error,                                                  \
                    api,                                                    \
                    string);                                                \
        }
#else // !_DEBUG
#define TRACE_ERROR(error, api, string)
#endif // !_DEBUG

    static BOOL bScanned = FALSE;

    if (bScanned)
        return;
    
    TCHAR   szConverterPath[MAX_PATH];
    TCHAR   szExpandedPath[MAX_PATH];
    DWORD   error;

    for (int i = 0; i < NUM_DOC_TYPES; i++)
    {
		//
		// If this type is a duplicate of some other type don't try to search
		// for the converter twice
		//

		if (doctypes[i].bDup)
			continue;

        LPCTSTR pszConverterKey = doctypes[i].pszConverterName;
        DWORD   cbConverterPath = sizeof(szConverterPath);
        HKEY    keyConverter;

        if (NULL != pszConverterKey)
        {
            error = RegOpenKey(
                            HKEY_LOCAL_MACHINE, 
                            pszConverterKey, 
                            &keyConverter);
    
            TRACE_ERROR(error, TEXT("RegOpenKey"), pszConverterKey);

            if (ERROR_SUCCESS == error)
            {                                
                error = RegQueryValueEx(
                                    keyConverter,
                                    TEXT("Path"),
                                    NULL,
                                    NULL,
                                    (LPBYTE) szConverterPath,
                                    &cbConverterPath);

                TRACE_ERROR(error, TEXT("RegQueryValueEx"), TEXT("Path"));

                RegCloseKey(keyConverter);

                if (ERROR_SUCCESS == error)
                {
                    if (0 == ExpandEnvironmentStrings(
                                        szConverterPath,
                                        szExpandedPath,
                                        MAX_PATH))
                    {
                        error = GetLastError();
                        TRACE_ERROR(
                                error, 
                                TEXT("ExpandEnvironmentStrings"),
                                szConverterPath);
                    }
                }
                                    
                if (ERROR_SUCCESS == error)
                {
                    //
                    // The FILE_ATTRIBUTE_DIRECTORY bit will also be set if an
                    // error occurs - like file not found.
                    //

                    error = GetFileAttributes(szExpandedPath)
                                & FILE_ATTRIBUTE_DIRECTORY;

                    TRACE_ERROR(
                        error, 
                        TEXT("GetFileAttribytes"), 
                        szExpandedPath);
                }
            }

            if (ERROR_SUCCESS == error)
                _tcscpy(doctypes[i].pszConverterName, szExpandedPath);   
            else
                doctypes[i].pszConverterName = NULL;
        }
    }

    bScanned = TRUE;
}

CString GetExtFromType(int nDocType)
{
	ScanForConverters();

	CString str = doctypes[nDocType].GetString(DOCTYPE_EXT);
	if (!str.IsEmpty())
	{
		ASSERT(str.GetLength() == 5); // "*.ext"
		ASSERT(str[1] == '.');
		return str.Right(str.GetLength()-1);
	}
	return str;
}

// returns an RD_* from an index into the openfile dialog types
int GetTypeFromIndex(int nIndex, BOOL bOpen)
{
	ScanForConverters();

    //
    // Word97 is excluded from the list of open file types in GetFileTypes.
    // Make up for it here.
    //

    if (bOpen)
        ++nIndex;

	int nCnt = 0;
	for (int i=0;i<NUM_DOC_TYPES;i++)
	{
		if (!doctypes[i].bDup &&
			(bOpen ? doctypes[i].bRead : doctypes[i].bWrite))
		{
			if (nCnt == nIndex)
				return i;
			nCnt++;
		}
	}
	ASSERT(FALSE);
	return -1;
}

// returns an index into the openfile dialog types for the RD_* type
int GetIndexFromType(int nType, BOOL bOpen)
{
	ScanForConverters();

	int nCnt = 0;
	for (int i=0;i<NUM_DOC_TYPES;i++)
	{
		if (!doctypes[i].bDup &&
			(bOpen ? doctypes[i].bRead : doctypes[i].bWrite))
		{
			if (i == nType)
				return nCnt;
			nCnt++;
		}
	}
	return -1;
}

CString GetFileTypes(BOOL bOpen)
{
	ScanForConverters();

	CString str;
	for (int i=0;i<NUM_DOC_TYPES;i++)
	{
		if (bOpen && doctypes[i].bRead 
			&& !doctypes[i].bDup 
			&& !(RD_WORD97 == doctypes[i].nID))
		{
			str += doctypes[i].GetString(DOCTYPE_DESC);
			str += (TCHAR)NULL;
			str += doctypes[i].GetString(DOCTYPE_EXT);
			str += (TCHAR)NULL;
		}
		else if (!bOpen && doctypes[i].bWrite && !doctypes[i].bDup)
		{
			str += doctypes[i].GetString(DOCTYPE_DOCTYPE);
			str += (TCHAR)NULL;
			str += doctypes[i].GetString(DOCTYPE_EXT);
			str += (TCHAR)NULL;
		}
	}
	return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\fixhelp.cpp ===
// fixhelp.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "fixhelp.h"

BOOL g_fDisableStandardHelp = FALSE ;

HHOOK g_HelpFixHook = (HHOOK) 0 ;

LRESULT CALLBACK HelpFixControlProc(
    HWND  hwnd,
    UINT  uMsg,
    WPARAM wParam,
    LPARAM  lParam);

LRESULT CALLBACK HelpFixDialogProc(
    HWND  hwnd,
    UINT  uMsg,
    WPARAM wParam,
    LPARAM  lParam);

LRESULT CALLBACK HelpFixHook(
    int code,
    WPARAM wParam,
    LPARAM lParam) ;

class CWordPadCWnd : public CWnd
{
public:

	LRESULT CallDWP(UINT nMsg, WPARAM wParam, LPARAM lParam)
   {
	    return DefWindowProc(nMsg, wParam, lParam) ;
   }
} ;

void FixHelp(CWnd* pWnd, BOOL fFixWndProc)
{
    //
    // Subclass the main window proc if we are supposed to
	// and if MFC has alread subclassed it
    //

    if (fFixWndProc)
    {
        if (GetWindowLong(pWnd->m_hWnd, GWL_WNDPROC) == (LONG)AfxWndProc)
	     {
              SetWindowLong(pWnd->m_hWnd, GWL_WNDPROC,
                               (LONG)HelpFixDialogProc);
	     }
    }

	//
    // Search all child windows.  If their window proc
    // is AfxWndProc, then subclass with our window proc
	//

    CWnd* pWndChild = pWnd->GetWindow(GW_CHILD);
    while(pWndChild != NULL)
    {
        if (GetWindowLong(pWndChild->GetSafeHwnd(), GWL_WNDPROC) == (LONG)AfxWndProc)
        {
            SetWindowLong(pWndChild->GetSafeHwnd(), GWL_WNDPROC,
                              (LONG)HelpFixControlProc);
        }
        pWndChild = pWndChild->GetWindow(GW_HWNDNEXT);
    }
}

LRESULT CALLBACK HelpFixControlProc(
    HWND  hwnd,
	UINT  uMsg,
	WPARAM wParam,
    LPARAM  lParam)
{
    if (uMsg == WM_HELP)
    {
		//
        // bypass MFC's handler, message will be sent to
		// parent of the control
		//

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return AfxWndProc(hwnd,uMsg,wParam,lParam);
}

LRESULT CALLBACK HelpFixDialogProc(
    HWND  hwnd,
	UINT  uMsg,
	WPARAM wParam,
    LPARAM  lParam)
{
    if (uMsg == WM_HELP)
    {
		CWordPadCWnd* pWnd = (CWordPadCWnd *) CWnd::FromHandlePermanent(hwnd) ;

		//
        // bypass MFC's handler, message will be sent to window proc for
		// the dialog box
		//

		if (NULL != pWnd)
		{
            return pWnd->CallDWP(uMsg, wParam, lParam) ;
		}
    }
    return AfxWndProc(hwnd,uMsg,wParam,lParam);
}


void SetHelpFixHook(void)
{
   g_HelpFixHook = ::SetWindowsHookEx(
                        WH_CALLWNDPROC,
                        (HOOKPROC) HelpFixHook,
                        NULL,
                        ::GetCurrentThreadId());
}

void RemoveHelpFixHook(void)
{
    ::UnhookWindowsHookEx(g_HelpFixHook) ;

    g_HelpFixHook = (HHOOK) 0 ;
}

LRESULT CALLBACK HelpFixHook(
    int code,
    WPARAM wParam,
    LPARAM lParam)
{
    if (code < 0)
    {
        return ::CallNextHookEx(
                   g_HelpFixHook,
                   code,
                   wParam,
                   lParam) ;
    }

    CWPSTRUCT *pcwps = (CWPSTRUCT *) lParam ;

    if (pcwps->message == WM_INITDIALOG)
    {
        CWnd *pWnd = CWnd::FromHandlePermanent(pcwps->hwnd) ;

        if (pWnd != NULL)
        {
            FixHelp(pWnd, TRUE) ;
        }
    }

    return ::CallNextHookEx(
                g_HelpFixHook,
                code,
                wParam,
                lParam) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\filenewd.cpp ===
// filenewd.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "filenewd.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

DWORD const CFileNewDialog::m_nHelpIDs[] = 
{
	IDC_DATEDIALOG_LIST, IDH_WORDPAD_FILENEW_DOC,
    IDC_STATIC_HEADING, IDH_WORDPAD_FILENEW_DOC,
	0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CFileNewDialog dialog

CFileNewDialog::CFileNewDialog(CWnd* pParent /*=NULL*/)
	: CCSDialog(CFileNewDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFileNewDialog)
	m_nSel = -1;
	//}}AFX_DATA_INIT
}


void CFileNewDialog::DoDataExchange(CDataExchange* pDX)
{
	CCSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFileNewDialog)
	DDX_Control(pDX, IDC_DATEDIALOG_LIST, m_listbox);
	DDX_LBIndex(pDX, IDC_DATEDIALOG_LIST, m_nSel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFileNewDialog, CCSDialog)
	//{{AFX_MSG_MAP(CFileNewDialog)
	ON_LBN_DBLCLK(IDC_DATEDIALOG_LIST, OnDblclkDatedialogList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFileNewDialog message handlers

BOOL CFileNewDialog::OnInitDialog() 
{
	CCSDialog::OnInitDialog();

	CString str;
	VERIFY(str.LoadString(IDS_WORD6_DOCUMENT));
	m_listbox.AddString(str);
	VERIFY(str.LoadString(IDS_RTF_DOCUMENT));
	m_listbox.AddString(str);
	VERIFY(str.LoadString(IDS_TEXT_DOCUMENT));
	m_listbox.AddString(str);
	VERIFY(str.LoadString(IDS_UNICODETEXT_DOCUMENT));
	m_listbox.AddString(str);
	m_listbox.SetCurSel(0);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CFileNewDialog::OnDblclkDatedialogList() 
{
	OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\formatba.h ===
// formatba.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __FORMATBA_H__
#define __FORMATBA_H__

class CWordPadView;

/*
typedef struct tagNMHDR
{
    HWND  hwndFrom;
    UINT  idFrom;
    UINT  code;         // NM_ code
}   NMHDR;
*/

struct CHARHDR : public tagNMHDR
{
	CHARFORMAT cf;
	CHARHDR() {cf.cbSize = sizeof(CHARFORMAT);}
};

#define FN_SETFORMAT	0x1000
#define FN_GETFORMAT	0x1001

/////////////////////////////////////////////////////////////////////////////
// CLocalComboBox

class CLocalComboBox : public CComboBox
{
public:

//Attributes
	CPtrArray m_arrayFontDesc;
	static int m_nFontHeight;
	int m_nLimitText;
	BOOL HasFocus()
	{
		HWND hWnd = ::GetFocus();
		return (hWnd == m_hWnd || ::IsChild(m_hWnd, hWnd));
	}
	void GetTheText(CString& str);
	void SetTheText(LPCTSTR lpszText,BOOL bMatchExact = FALSE);

//Operations
	BOOL LimitText(int nMaxChars);

// Implementation
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	// Generated message map functions
	//{{AFX_MSG(CLocalComboBox)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CFontComboBox : public CLocalComboBox
{
public:
	CFontComboBox();

//Attributes
	CBitmap m_bmFontType;

//Operations
	void EnumFontFamiliesEx(CDC& dc, BYTE nCharSet = DEFAULT_CHARSET);
	void AddFont(ENUMLOGFONT* pelf, DWORD dwType, LPCTSTR lpszScript = NULL);
	void MatchFont(LPCTSTR lpszName, BYTE nCharSet);
	void EmptyContents();

	static BOOL CALLBACK AFX_EXPORT EnumFamScreenCallBack(
		ENUMLOGFONT* pelf, NEWTEXTMETRICEX* /*lpntm*/, int FontType, 
		LPVOID pThis);
	static BOOL CALLBACK AFX_EXPORT EnumFamPrinterCallBack(
		ENUMLOGFONT* pelf, NEWTEXTMETRICEX* /*lpntm*/, int FontType, 
		LPVOID pThis);
	static BOOL CALLBACK AFX_EXPORT EnumFamScreenCallBackEx(
		ENUMLOGFONTEX* pelf, NEWTEXTMETRICEX* /*lpntm*/, int FontType, 
		LPVOID pThis);
	static BOOL CALLBACK AFX_EXPORT EnumFamPrinterCallBackEx(
		ENUMLOGFONTEX* pelf, NEWTEXTMETRICEX* /*lpntm*/, int FontType, 
		LPVOID pThis);

//Overridables
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCIS);
	// Generated message map functions
	//{{AFX_MSG(CFontComboBox)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CSizeComboBox : public CLocalComboBox
{
public:
	CSizeComboBox();

//Attributes
	int m_nLogVert;
	int m_nTwipsLast;
public:
	void EnumFontSizes(CDC& dc, LPCTSTR pFontName);
	static BOOL FAR PASCAL EnumSizeCallBack(LOGFONT FAR* lplf, 
		LPNEWTEXTMETRIC lpntm,int FontType, LPVOID lpv);
	void TwipsToPointString(LPTSTR lpszBuf, int nTwips);
	void SetTwipSize(int nSize);
	int GetTwipSize();
	void InsertSize(int nSize);
};

/////////////////////////////////////////////////////////////////////////////
// CFormatBar dialog
class CFormatBar : public CToolBar
{
// Construction
public:
	CFormatBar();

// Operations
public:
	void PositionCombos();
	void SyncToView();

// Attributes
public:
	CDC m_dcPrinter;
	CSize m_szBaseUnits;
	CFontComboBox m_comboFontName;
	CSizeComboBox m_comboFontSize;

// Implementation
public:
	void NotifyOwner(UINT nCode);

protected:
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	void SetCharFormat(CCharFormat& cf);

	// Generated message map functions
	//{{AFX_MSG(CFormatBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	afx_msg void OnFontNameKillFocus();
	afx_msg void OnFontSizeKillFocus();
	afx_msg void OnFontSizeDropDown();
	afx_msg void OnComboCloseUp();
	afx_msg void OnComboSetFocus();
	afx_msg LONG OnPrinterChanged(UINT, LONG); //handles registered message
	DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\ipframe.h ===
// ipframe.h : interface of the CInPlaceFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CWordPadResizeBar : public COleResizeBar
{
public: 
	void SetMinSize(CSize size) {m_tracker.m_sizeMin = size;}
};

class CInPlaceFrame : public COleIPFrameWnd
{
	DECLARE_DYNCREATE(CInPlaceFrame)
public:
	CInPlaceFrame() {};

// Attributes
public:
	CToolBar m_wndToolBar;
	CFormatBar m_wndFormatBar;
	CRulerBar m_wndRulerBar;
	CWordPadResizeBar m_wndResizeBar;
	COleDropTarget m_dropTarget;

// Operations
public:
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual void CalcWindowRect(LPRECT lpClientRect, 
		UINT nAdjustType = adjustBorder);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInPlaceFrame)
	public:
	virtual BOOL OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc);
	virtual void RepositionFrame(LPCRECT lpPosRect, LPCRECT lpClipRect);
	//}}AFX_VIRTUAL

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	BOOL CreateToolBar(CWnd* pWndFrame);
	BOOL CreateFormatBar(CWnd* pWndFrame);
	BOOL CreateRulerBar(CWnd* pWndFrame);

// Generated message map functions
protected:
	//{{AFX_MSG(CInPlaceFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnHelpFinder();
	afx_msg void OnCharColor();
	afx_msg void OnPenToggle();
	//}}AFX_MSG
	LRESULT OnResizeChild(WPARAM wParam, LPARAM lParam);
	afx_msg LONG OnBarState(UINT wParam, LONG lParam);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\formatpa.cpp ===
// formatpa.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "formatpa.h"
#include "ddxm.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

const DWORD CFormatParaDlg::m_nHelpIDs[] = 
{
	IDC_EDIT_LEFT, IDH_WORDPAD_INDENT_LEFT,
	IDC_EDIT_RIGHT, IDH_WORDPAD_INDENT_RIGHT,
	IDC_EDIT_FIRST_LINE, IDH_WORDPAD_INDENT_FIRST,
	IDC_BOX, IDH_COMM_GROUPBOX,
	IDC_COMBO_ALIGNMENT, IDH_WORDPAD_ALIGN,
	IDC_TEXT_ALIGNMENT, IDH_WORDPAD_ALIGN,
	0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CFormatParaDlg dialog

CFormatParaDlg::CFormatParaDlg(PARAFORMAT& pf, CWnd* pParent /*=NULL*/)
	: CCSDialog(CFormatParaDlg::IDD, pParent)
{
	m_pf = pf;
	if (m_pf.dwMask & PFM_ALIGNMENT)
	{
		if (m_pf.wAlignment & PFA_LEFT && m_pf.wAlignment & PFA_RIGHT)
			m_nAlignment = 2;
		else
			m_nAlignment = (m_pf.wAlignment & PFA_LEFT) ? 0 : 1;
	}
	else
		m_nAlignment = -1;
	//{{AFX_DATA_INIT(CFormatParaDlg)
	m_nFirst = 0;
	m_nLeft = 0;
	m_nRight = 0;
	//}}AFX_DATA_INIT
}

void CFormatParaDlg::DoDataExchange(CDataExchange* pDX)
{
	CCSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFormatParaDlg)
	DDX_CBIndex(pDX, IDC_COMBO_ALIGNMENT, m_nAlignment);
	DDX_Twips(pDX, IDC_EDIT_FIRST_LINE, m_nFirst);
	DDV_MinMaxTwips(pDX, m_nFirst, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_LEFT, m_nLeft);
	DDV_MinMaxTwips(pDX, m_nLeft, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_RIGHT, m_nRight);
	DDV_MinMaxTwips(pDX, m_nRight, -31680, 31680);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFormatParaDlg, CCSDialog)
	//{{AFX_MSG_MAP(CFormatParaDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFormatParaDlg message handlers

void CFormatParaDlg::OnOK()
{
	CCSDialog::OnOK();
	m_pf.dwMask = 0;
	if (m_nAlignment >= 0)
	{
		ASSERT(m_nAlignment < 3);
		m_pf.dwMask |= PFM_ALIGNMENT;
		m_pf.wAlignment = (WORD)((m_nAlignment == 0) ? PFA_LEFT : 
			(m_nAlignment == 1) ? PFA_RIGHT : PFA_CENTER);
	}
	if (m_nRight != DDXM_BLANK)
		m_pf.dwMask |= PFM_RIGHTINDENT;
	if (m_nLeft != DDXM_BLANK && m_nFirst != DDXM_BLANK)
		m_pf.dwMask |= PFM_STARTINDENT;
	if (m_nFirst != DDXM_BLANK)
		m_pf.dwMask |= PFM_OFFSET;

	m_pf.dxRightIndent = m_nRight;
	m_pf.dxOffset = -m_nFirst;
	m_pf.dxStartIndent = m_nLeft + m_nFirst;
}

BOOL CFormatParaDlg::OnInitDialog() 
{
	CComboBox* pBox = (CComboBox*)GetDlgItem(IDC_COMBO_ALIGNMENT);
	CString str;
	str.LoadString(IDS_LEFT);
	pBox->AddString(str);
	str.LoadString(IDS_RIGHT);
	pBox->AddString(str);
	str.LoadString(IDS_CENTER);
	pBox->AddString(str);

	if (m_nWordWrap == 0)
	{
		GetDlgItem(IDC_COMBO_ALIGNMENT)->EnableWindow(FALSE);
		GetDlgItem(IDC_TEXT_ALIGNMENT)->EnableWindow(FALSE);
	}

	m_nRight = (m_pf.dwMask & PFM_RIGHTINDENT) ? m_pf.dxRightIndent : DDXM_BLANK;
	if (m_pf.dwMask & PFM_OFFSET)
	{
		m_nFirst = -m_pf.dxOffset;
		m_nLeft = (m_pf.dwMask & PFM_STARTINDENT) ? 
			m_pf.dxStartIndent + m_pf.dxOffset : DDXM_BLANK;
	}
	else
		m_nLeft = m_nFirst = DDXM_BLANK;
	
	CCSDialog::OnInitDialog();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\formatba.cpp ===
// formatba.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "wordpad.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "formatba.h"
#include "strings.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// reserve lobyte for charset
#define PRINTER_FONT 0x0100
#define TT_FONT	0x0200
#define DEVICE_FONT 0x0400

#define BMW 16
#define BMH 15

static int nFontSizes[] =
	{8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72};
int CLocalComboBox::m_nFontHeight = 0;

class CFontDesc
{
public:
	CFontDesc(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet,
		BYTE nPitchAndFamily, DWORD dwFlags);
	CString m_strName;
	CString m_strScript;
	BYTE m_nCharSet;
	BYTE m_nPitchAndFamily;
	DWORD m_dwFlags;
};

CFontDesc::CFontDesc(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet,
	BYTE nPitchAndFamily, DWORD dwFlags)
{
	m_strName = lpszName;
	m_strScript = lpszScript;
	m_nCharSet = nCharSet;
	m_nPitchAndFamily = nPitchAndFamily;
	m_dwFlags = dwFlags;
}

BEGIN_MESSAGE_MAP(CFormatBar, CToolBar)
	//{{AFX_MSG_MAP(CFormatBar)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	ON_CBN_DROPDOWN(IDC_FONTSIZE, OnFontSizeDropDown)
	ON_CBN_KILLFOCUS(IDC_FONTNAME, OnFontNameKillFocus)
	ON_CBN_KILLFOCUS(IDC_FONTSIZE, OnFontSizeKillFocus)
	ON_CBN_SETFOCUS(IDC_FONTNAME, OnComboSetFocus)
	ON_CBN_SETFOCUS(IDC_FONTSIZE, OnComboSetFocus)
	ON_CBN_CLOSEUP(IDC_FONTNAME, OnComboCloseUp)
	ON_CBN_CLOSEUP(IDC_FONTSIZE, OnComboCloseUp)
	ON_REGISTERED_MESSAGE(CWordPadApp::m_nPrinterChangedMsg, OnPrinterChanged)
	// Global help commands
END_MESSAGE_MAP()

static CSize GetBaseUnits(CFont* pFont)
{
	ASSERT(pFont != NULL);
	ASSERT(pFont->GetSafeHandle() != NULL);
	pFont = theApp.m_dcScreen.SelectObject(pFont);
	TEXTMETRIC tm;
	VERIFY(theApp.m_dcScreen.GetTextMetrics(&tm));

	theApp.m_dcScreen.SelectObject(pFont);
//	return CSize(tm.tmAveCharWidth, tm.tmHeight+tm.tmDescent);
	return CSize(tm.tmAveCharWidth, tm.tmHeight);
}

CFormatBar::CFormatBar()
{
	CFont fnt;
  	fnt.Attach(GetStockObject(theApp.m_nDefFont));
	m_szBaseUnits = GetBaseUnits(&fnt);
	CLocalComboBox::m_nFontHeight = m_szBaseUnits.cy;
}

void CFormatBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	CToolBar::OnUpdateCmdUI(pTarget, bDisableIfNoHndler);
	// don't update combo boxes if either one has the focus
	if (!m_comboFontName.HasFocus() && !m_comboFontSize.HasFocus())
		SyncToView();
}

void CFormatBar::SyncToView()
{
	USES_CONVERSION;
	// get the current font from the view and update
	CHARHDR fh;
	CHARFORMAT& cf = fh.cf;
	fh.hwndFrom = m_hWnd;
	fh.idFrom = GetDlgCtrlID();
	fh.code = FN_GETFORMAT;
	VERIFY(GetOwner()->SendMessage(WM_NOTIFY, fh.idFrom, (LPARAM)&fh));

	// the selection must be same font and charset to display correctly
	if ((cf.dwMask & (CFM_FACE|CFM_CHARSET)) == (CFM_FACE|CFM_CHARSET))
		m_comboFontName.MatchFont(cf.szFaceName, cf.bCharSet);
	else
		m_comboFontName.SetTheText(_T(""));

	// SetTwipSize only updates if different
	// -1 means selection is not a single point size
	m_comboFontSize.SetTwipSize( (cf.dwMask & CFM_SIZE) ? cf.yHeight : -1);
}

void CFormatBar::OnFontSizeDropDown()
{
	CString str;
	m_comboFontName.GetTheText(str);
	LPCTSTR lpszName = NULL;
	BOOL bPrinterFont;
	int nIndex = m_comboFontName.FindStringExact(-1, str);
	if (nIndex != CB_ERR)
	{
		CFontDesc* pDesc = (CFontDesc*)m_comboFontName.GetItemData(nIndex);
		ASSERT(pDesc != NULL);
		bPrinterFont = pDesc->m_dwFlags & PRINTER_FONT;
		lpszName = pDesc->m_strName;
	}

	int nSize = m_comboFontSize.GetTwipSize();
	if (nSize == -2) // error
	{
		AfxMessageBox(IDS_INVALID_NUMBER, MB_OK|MB_ICONINFORMATION);
		nSize = m_comboFontSize.m_nTwipsLast;
	}
	else if ((nSize >= 0 && nSize < 20) || nSize > 32760)
	{
		AfxMessageBox(IDS_INVALID_FONTSIZE, MB_OK|MB_ICONINFORMATION);
		nSize = m_comboFontSize.m_nTwipsLast;
	}

	if (bPrinterFont)
		m_comboFontSize.EnumFontSizes(m_dcPrinter, lpszName);
	else
		m_comboFontSize.EnumFontSizes(theApp.m_dcScreen, lpszName);
	m_comboFontSize.SetTwipSize(nSize);
}

void CFormatBar::OnComboCloseUp()
{
	NotifyOwner(NM_RETURN);
}

void CFormatBar::OnComboSetFocus()
{
	NotifyOwner(NM_SETFOCUS);
}

void CFormatBar::OnFontNameKillFocus()
{
	USES_CONVERSION;
	// get the current font from the view and update
	NotifyOwner(NM_KILLFOCUS);

	CCharFormat cf;
	cf.szFaceName[0] = NULL;

	// this will retrieve the font entered in the edit control
	// it tries to match the font to something already present in the combo box
	// this effectively ignores case of a font the user enters
	// if a user enters arial, this will cause it to become Arial
	CString str;
	m_comboFontName.GetTheText(str);	// returns "arial"
	m_comboFontName.SetTheText(str);					// selects "Arial"
	m_comboFontName.GetTheText(str);	// returns "Arial"

	// if font name box is not empty
	if (str[0] != NULL)
	{
		cf.dwMask = CFM_FACE | CFM_CHARSET;
		int nIndex = m_comboFontName.FindStringExact(-1, str);
		if (nIndex != CB_ERR)
		{
			CFontDesc* pDesc = (CFontDesc*)m_comboFontName.GetItemData(nIndex);
			ASSERT(pDesc != NULL);
			ASSERT(pDesc->m_strName.GetLength() < LF_FACESIZE);
			lstrcpyn(cf.szFaceName, pDesc->m_strName, LF_FACESIZE);
			cf.bCharSet = pDesc->m_nCharSet;
			cf.bPitchAndFamily = pDesc->m_nPitchAndFamily;
		}
		else // unknown font
		{
			ASSERT(str.GetLength() < LF_FACESIZE);
			lstrcpyn(cf.szFaceName, str, LF_FACESIZE);
			cf.bCharSet = DEFAULT_CHARSET;
			cf.bPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
		}
		SetCharFormat(cf);
	}
}

void CFormatBar::OnFontSizeKillFocus()
{
	NotifyOwner(NM_KILLFOCUS);
	int nSize = m_comboFontSize.GetTwipSize();
	if (nSize == -2)
	{
		AfxMessageBox(IDS_INVALID_NUMBER, MB_OK|MB_ICONINFORMATION);
		nSize = m_comboFontSize.m_nTwipsLast;
	}
	else if ((nSize >= 0 && nSize < 20) || nSize > 32760)
	{
		AfxMessageBox(IDS_INVALID_FONTSIZE, MB_OK|MB_ICONINFORMATION);
		nSize = m_comboFontSize.m_nTwipsLast;
	}
	else if (nSize > 0)
	{
		CCharFormat cf;
		cf.dwMask = CFM_SIZE;
		cf.yHeight = nSize;
		SetCharFormat(cf);
	}
}

LONG CFormatBar::OnPrinterChanged(UINT, LONG)
{
	theApp.CreatePrinterDC(m_dcPrinter);
	m_comboFontName.EnumFontFamiliesEx(m_dcPrinter);
	return 0;
}

int CFormatBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CToolBar::OnCreate(lpCreateStruct) == -1)
		return -1;

	theApp.m_listPrinterNotify.AddTail(m_hWnd);
	
	CRect rect(0,0, (3*LF_FACESIZE*m_szBaseUnits.cx)/2, 200);
	if (!m_comboFontName.Create(WS_TABSTOP|WS_VISIBLE|WS_TABSTOP|
		WS_VSCROLL|CBS_DROPDOWN|CBS_SORT|CBS_AUTOHSCROLL|CBS_HASSTRINGS|
		CBS_OWNERDRAWFIXED, rect, this, IDC_FONTNAME))
	{
		TRACE0("Failed to create fontname combo-box\n");
		return -1;
	}
	m_comboFontName.LimitText(LF_FACESIZE);

	rect.SetRect(0, 0, 10*m_szBaseUnits.cx, 200);
	if (!m_comboFontSize.Create(WS_TABSTOP|WS_VISIBLE|WS_TABSTOP|
		WS_VSCROLL|CBS_DROPDOWN, rect, this, IDC_FONTSIZE))
	{
		TRACE0("Failed to create fontsize combo-box\n");
		return -1;
	}

	m_comboFontSize.LimitText(4);
	m_comboFontName.EnumFontFamiliesEx(m_dcPrinter);
	
	return 0;
}

void CFormatBar::OnDestroy()
{
	CToolBar::OnDestroy();
	POSITION pos = theApp.m_listPrinterNotify.Find(m_hWnd);
	ASSERT(pos != NULL);
	theApp.m_listPrinterNotify.RemoveAt(pos);
}

void CFormatBar::PositionCombos()
{
	CRect rect;
	// make font name box same size as font size box
	// this is necessary since font name box is owner draw
	m_comboFontName.SetItemHeight(-1, m_comboFontSize.GetItemHeight(-1));

	m_comboFontName.GetWindowRect(&rect);
	int nHeight = rect.Height();

	m_comboFontName.GetWindowRect(&rect);
	SetButtonInfo(0, IDC_FONTNAME, TBBS_SEPARATOR, rect.Width());
	GetItemRect(0, &rect); // FontName ComboBox
	m_comboFontName.SetWindowPos(NULL, rect.left,
		((rect.Height() - nHeight) / 2) + rect.top, 0, 0,
		SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

	m_comboFontSize.GetWindowRect(&rect);
	SetButtonInfo(2, IDC_FONTSIZE, TBBS_SEPARATOR, rect.Width());
	GetItemRect(2, &rect); // FontSize ComboBox
	m_comboFontSize.SetWindowPos(NULL, rect.left,
		((rect.Height() - nHeight) / 2) + rect.top, 0, 0,
		SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
}

/////////////////////////////////////////////////////////////////////////////
// CFontComboBox

BEGIN_MESSAGE_MAP(CFontComboBox, CLocalComboBox)
	//{{AFX_MSG_MAP(CFontComboBox)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	// Global help commands
END_MESSAGE_MAP()

CFontComboBox::CFontComboBox()
{
	VERIFY(m_bmFontType.LoadBitmap(IDB_FONTTYPE));
}

void CFontComboBox::OnDestroy()
{
	// destroy all the CFontDesc's
	EmptyContents();
	CLocalComboBox::OnDestroy();
}

void CFontComboBox::EmptyContents()
{
	// destroy all the CFontDesc's
	int nCount = GetCount();
	for (int i=0;i<nCount;i++)
		delete (CFontDesc*)GetItemData(i);
}

void CFontComboBox::EnumFontFamiliesEx(CDC& dc, BYTE nCharSet)
{
	CMapStringToPtr map;
	CString str;
	GetTheText(str);

	EmptyContents();
	ResetContent();
	LOGFONT lf;
	memset(&lf, 0, sizeof(LOGFONT));
	lf.lfCharSet = nCharSet;

	if (dc.m_hDC != NULL)
	{
		if (theApp.m_bWin4)
		{
			::EnumFontFamiliesEx(dc.m_hDC, &lf,
				(FONTENUMPROC) EnumFamPrinterCallBackEx, (LPARAM) this, NULL);
		}
		else
		{
			::EnumFontFamilies(dc.m_hDC, NULL,
				(FONTENUMPROC) EnumFamPrinterCallBack, (LPARAM) this);
		}
	}
	else
	{
		HDC hDC = theApp.m_dcScreen.m_hDC;
		ASSERT(hDC != NULL);
		if (theApp.m_bWin4)
		{
			::EnumFontFamiliesEx(hDC, &lf,
				(FONTENUMPROC) EnumFamScreenCallBackEx, (LPARAM) this, NULL);
		}
		else
		{
			::EnumFontFamilies(hDC, NULL,
				(FONTENUMPROC) EnumFamScreenCallBack, (LPARAM) this);
		}
	}
	// now walk through the fonts and remove (charset) from fonts with only one

	int nCount = m_arrayFontDesc.GetSize();
	// walk through fonts adding names to string map
	// first time add value 0, after that add value 1
	for (int i = 0; i<nCount;i++)
	{
		CFontDesc* pDesc = (CFontDesc*)m_arrayFontDesc[i];
		void* pv = NULL;
		if (map.Lookup(pDesc->m_strName, pv)) // found it
		{
			if (pv == NULL) // only one entry so far
			{
				map.RemoveKey(pDesc->m_strName);
				map.SetAt(pDesc->m_strName, (void*)1);
			}
		}
		else // not found
			map.SetAt(pDesc->m_strName, (void*)0);
	}

	for (i = 0; i<nCount;i++)
	{
		CFontDesc* pDesc = (CFontDesc*)m_arrayFontDesc[i];
		CString str = pDesc->m_strName;
		void* pv = NULL;
		VERIFY(map.Lookup(str, pv));
		if (pv != NULL && !pDesc->m_strScript.IsEmpty())
		{
			str += " (";
			str += pDesc->m_strScript;
			str += ")";
		}

		int nIndex = AddString(str);
		ASSERT(nIndex >=0);
		if (nIndex >=0) //no error
			SetItemData(nIndex, (DWORD)pDesc);
	}

	SetTheText(str);
	m_arrayFontDesc.RemoveAll();
}

void CFontComboBox::AddFont(ENUMLOGFONT* pelf, DWORD dwType, LPCTSTR lpszScript)
{
	LOGFONT& lf = pelf->elfLogFont;
	if (lf.lfCharSet == MAC_CHARSET) // don't put in MAC fonts, commdlg doesn't either
		return;
	// Don't display vertical font for FE platform
	if ((GetSystemMetrics(SM_DBCSENABLED)) && (lf.lfFaceName[0] == '@'))
		return;
	// don't put in non-printer raster fonts
	CFontDesc* pDesc = new CFontDesc(lf.lfFaceName, lpszScript,
		lf.lfCharSet, lf.lfPitchAndFamily, dwType);
	m_arrayFontDesc.Add(pDesc);
}

BOOL CALLBACK AFX_EXPORT CFontComboBox::EnumFamScreenCallBack(ENUMLOGFONT* pelf,
	NEWTEXTMETRICEX* /*lpntm*/, int FontType, LPVOID pThis)
{
	// don't put in non-printer raster fonts
	if (FontType & RASTER_FONTTYPE)
		return 1;
	DWORD dwData = (FontType & TRUETYPE_FONTTYPE) ? TT_FONT : 0;
	((CFontComboBox *)pThis)->AddFont(pelf, dwData);
	return 1;
}

BOOL CALLBACK AFX_EXPORT CFontComboBox::EnumFamPrinterCallBack(ENUMLOGFONT* pelf,
	NEWTEXTMETRICEX* /*lpntm*/, int FontType, LPVOID pThis)
{
	DWORD dwData = PRINTER_FONT;
	if (FontType & TRUETYPE_FONTTYPE)
		dwData |= TT_FONT;
	else if (FontType & DEVICE_FONTTYPE)
		dwData |= DEVICE_FONT;
	((CFontComboBox *)pThis)->AddFont(pelf, dwData);
	return 1;
}

BOOL CALLBACK AFX_EXPORT CFontComboBox::EnumFamScreenCallBackEx(ENUMLOGFONTEX* pelf,
	NEWTEXTMETRICEX* /*lpntm*/, int FontType, LPVOID pThis)
{
	// don't put in non-printer raster fonts
	if (FontType & RASTER_FONTTYPE)
		return 1;
	DWORD dwData = (FontType & TRUETYPE_FONTTYPE) ? TT_FONT : 0;
	((CFontComboBox *)pThis)->AddFont((ENUMLOGFONT*)pelf, dwData, CString(pelf->elfScript));
	return 1;
}

BOOL CALLBACK AFX_EXPORT CFontComboBox::EnumFamPrinterCallBackEx(ENUMLOGFONTEX* pelf,
	NEWTEXTMETRICEX* /*lpntm*/, int FontType, LPVOID pThis)
{
	DWORD dwData = PRINTER_FONT;
	if (FontType & TRUETYPE_FONTTYPE)
		dwData |= TT_FONT;
	else if (FontType & DEVICE_FONTTYPE)
		dwData |= DEVICE_FONT;
	((CFontComboBox *)pThis)->AddFont((ENUMLOGFONT*)pelf, dwData, CString(pelf->elfScript));
	return 1;
}

void CFontComboBox::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	ASSERT(lpDIS->CtlType == ODT_COMBOBOX);
	int id = (int)(WORD)lpDIS->itemID;

	CDC *pDC = CDC::FromHandle(lpDIS->hDC);
	CRect rc(lpDIS->rcItem);
	if (lpDIS->itemState & ODS_FOCUS)
		pDC->DrawFocusRect(rc);
	int nIndexDC = pDC->SaveDC();

	CBrush brushFill;
	if (lpDIS->itemState & ODS_SELECTED)
	{
		brushFill.CreateSolidBrush(::GetSysColor(COLOR_HIGHLIGHT));
		pDC->SetTextColor(::GetSysColor(COLOR_HIGHLIGHTTEXT));
	}
	else
		brushFill.CreateSolidBrush(pDC->GetBkColor());
	pDC->SetBkMode(TRANSPARENT);
	pDC->FillRect(rc, &brushFill);

	CFontDesc* pDesc= (CFontDesc*)lpDIS->itemData;
	ASSERT(pDesc != NULL);
	DWORD dwData = pDesc->m_dwFlags;
	if (dwData & (TT_FONT|DEVICE_FONT)) // truetype or device flag set by SetItemData
	{
		CDC dc;
		dc.CreateCompatibleDC(pDC);
		CBitmap* pBitmap = dc.SelectObject(&m_bmFontType);
		if (dwData & TT_FONT)
			pDC->BitBlt(rc.left, rc.top, BMW, BMH, &dc, BMW, 0, SRCAND);
		else // DEVICE_FONT
			pDC->BitBlt(rc.left, rc.top, BMW, BMH, &dc, 0, 0, SRCAND);
		dc.SelectObject(pBitmap);
	}
	
	rc.left += BMW + 6;
	CString strText;
	GetLBText(id, strText);
	pDC->TextOut(rc.left,rc.top,strText,strText.GetLength());

	pDC->RestoreDC(nIndexDC);
}

void CFontComboBox::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
	ASSERT(lpMIS->CtlType == ODT_COMBOBOX);
	ASSERT(m_nFontHeight > 0);
	CRect rc;
	
	GetWindowRect(&rc);
	lpMIS->itemWidth = rc.Width();
	lpMIS->itemHeight = max(BMH, m_nFontHeight);
}

int CFontComboBox::CompareItem(LPCOMPAREITEMSTRUCT lpCIS)
{
	ASSERT(lpCIS->CtlType == ODT_COMBOBOX);
	int id1 = (int)(WORD)lpCIS->itemID1;
	int id2 = (int)(WORD)lpCIS->itemID2;
	CString str1,str2;
	if (id1 == -1)
		return -1;
	if (id2 == -1)
		return 1;
	GetLBText(id1, str1);
	GetLBText(id2, str2);
	return str1.Collate(str2);
}

// find a font with the face name and charset
void CFontComboBox::MatchFont(LPCTSTR lpszName, BYTE nCharSet)
{
	int nFirstIndex = FindString(-1, lpszName);
	if (nFirstIndex != CB_ERR)
	{
		int nIndex = nFirstIndex;
		do
		{
			CFontDesc* pDesc = (CFontDesc*)GetItemData(nIndex);
			ASSERT(pDesc != NULL);
			// check the actual font name to avoid matching Courier western
			// to Courier New western
			if ((nCharSet == DEFAULT_CHARSET || pDesc->m_nCharSet == nCharSet) &&
				lstrcmp(lpszName, pDesc->m_strName)==0)
			{
				//got a match
				if (GetCurSel() != nIndex)
					SetCurSel(nIndex);
				return;
			}
			nIndex = FindString(nIndex, lpszName);
		} while (nIndex != nFirstIndex);
		// loop until found or back to first item again
	}
	//enter font name
	SetTheText(lpszName, TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// CSizeComboBox

CSizeComboBox::CSizeComboBox()
{
	m_nTwipsLast = 0;
}

void CSizeComboBox::EnumFontSizes(CDC& dc, LPCTSTR pFontName)
{
	ResetContent();
	if (pFontName == NULL)
		return;
	if (pFontName[0] == NULL)
		return;
	
	ASSERT(dc.m_hDC != NULL);
	m_nLogVert = dc.GetDeviceCaps(LOGPIXELSY);

	::EnumFontFamilies(dc.m_hDC, pFontName,
		(FONTENUMPROC) EnumSizeCallBack, (LPARAM) this);
}

void CSizeComboBox::TwipsToPointString(LPTSTR lpszBuf, int nTwips)
{
	ASSERT(lpszBuf != NULL);
	lpszBuf[0] = NULL;
	if (nTwips >= 0)
	{
		// round to nearest half point
		nTwips = (nTwips+5)/10;
		if ((nTwips%2) == 0)
			_stprintf(lpszBuf, _T("%ld"), nTwips/2);
		else
			_stprintf(lpszBuf, _T("%.1f"), (float)nTwips/2.F);
	}
}

void CSizeComboBox::SetTwipSize(int nTwips)
{
	if (nTwips != GetTwipSize())
	{
		TCHAR buf[10];
		TwipsToPointString(buf, nTwips);
		SetTheText(buf, TRUE);
	}
	m_nTwipsLast = nTwips;
}

int CSizeComboBox::GetTwipSize()
{
	// return values
	// -2 -- error
	// -1 -- edit box empty
	// >=0 -- font size in twips
	CString str;
	GetTheText(str);
	LPCTSTR lpszText = str;

	while (*lpszText == ' ' || *lpszText == '\t')
		lpszText++;

	if (lpszText[0] == NULL)
		return -1; // no text in control

	double d = _tcstod(lpszText, (LPTSTR*)&lpszText);
	while (*lpszText == ' ' || *lpszText == '\t')
		lpszText++;

	if (*lpszText != NULL)
		return -2;   // not terminated properly

	return (d<0.) ? 0 : (int)(d*20.);
}

BOOL CALLBACK AFX_EXPORT CSizeComboBox::EnumSizeCallBack(LOGFONT FAR* /*lplf*/,
		LPNEWTEXTMETRIC lpntm, int FontType, LPVOID lpv)
{
	CSizeComboBox* pThis = (CSizeComboBox*)lpv;
	ASSERT(pThis != NULL);
	TCHAR buf[10];
	if (
		(FontType & TRUETYPE_FONTTYPE) ||
		!( (FontType & TRUETYPE_FONTTYPE) || (FontType & RASTER_FONTTYPE) )
		) // if truetype or vector font
	{
		// this occurs when there is a truetype and nontruetype version of a font
		if (pThis->GetCount() != 0)
			pThis->ResetContent();
					
		for (int i = 0; i < 16; i++)
		{
			wsprintf(buf, _T("%d"), nFontSizes[i]);
			pThis->AddString(buf);
		}
		return FALSE; // don't call me again
	}
	// calc character height in pixels
	pThis->InsertSize(MulDiv(lpntm->tmHeight-lpntm->tmInternalLeading,
		1440, pThis->m_nLogVert));
	return TRUE; // call me again
}

void CSizeComboBox::InsertSize(int nSize)
{
	ASSERT(nSize > 0);
	DWORD dwSize = (DWORD)nSize;
	TCHAR buf[10];
	TwipsToPointString(buf, nSize);
	if (FindStringExact(-1, buf) == CB_ERR)
	{
		int nIndex = -1;
		int nPos = 0;
		DWORD dw;
		while ((dw = GetItemData(nPos)) != CB_ERR)
		{
			if (dw > dwSize)
			{
				nIndex = nPos;
				break;
			}
			nPos++;
		}
		nIndex = InsertString(nIndex, buf);
		ASSERT(nIndex != CB_ERR);
		if (nIndex != CB_ERR)
			SetItemData(nIndex, dwSize);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CLocalComboBox

BEGIN_MESSAGE_MAP(CLocalComboBox, CComboBox)
	//{{AFX_MSG_MAP(CLocalComboBox)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	// Global help commands
END_MESSAGE_MAP()

void CLocalComboBox::GetTheText(CString& str)
{
	int nIndex = GetCurSel();
	if (nIndex == CB_ERR)
		GetWindowText(str);
	else
		GetLBText(nIndex, str);
}

void CLocalComboBox::SetTheText(LPCTSTR lpszText,BOOL bMatchExact)
{
	int idx = (bMatchExact) ? FindStringExact(-1,lpszText) :
		FindString(-1, lpszText);
	SetCurSel( (idx==CB_ERR) ? -1 : idx);
	if (idx == CB_ERR)
		SetWindowText(lpszText);
}

BOOL CLocalComboBox::LimitText(int nMaxChars)
{
	BOOL b = CComboBox::LimitText(nMaxChars);
	if (b)
		m_nLimitText = nMaxChars;
	return b;
}

int CLocalComboBox::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CComboBox::OnCreate(lpCreateStruct) == -1)
		return -1;
  	SendMessage(WM_SETFONT, (WPARAM)GetStockObject(theApp.m_nDefFont));
	return 0;
}

BOOL CLocalComboBox::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN)
	{
		CFormatBar* pBar = (CFormatBar*)GetParent();
		switch (pMsg->wParam)
		{
		case VK_ESCAPE:
			pBar->SyncToView();
			pBar->NotifyOwner(NM_RETURN);
			return TRUE;
		case VK_RETURN:
			pBar->NotifyOwner(NM_RETURN);
			return TRUE;
		case VK_TAB:
			pBar->GetNextDlgTabItem(this)->SetFocus();
			return TRUE;
		case VK_UP:
		case VK_DOWN:
			if ((GetKeyState(VK_MENU) >= 0) && (GetKeyState(VK_CONTROL) >=0) &&
				!GetDroppedState())
			{
				ShowDropDown();
				return TRUE;
			}
		}
	}
	return CComboBox::PreTranslateMessage(pMsg);
}

void CFormatBar::NotifyOwner(UINT nCode)
{
	NMHDR nm;
	nm.hwndFrom = m_hWnd;
	nm.idFrom = GetDlgCtrlID();
	nm.code = nCode;
	GetOwner()->SendMessage(WM_NOTIFY, nm.idFrom, (LPARAM)&nm);
}

void CFormatBar::SetCharFormat(CCharFormat& cf)
{
	CHARHDR fnm;
	fnm.hwndFrom = m_hWnd;
	fnm.idFrom = GetDlgCtrlID();
	fnm.code = FN_SETFORMAT;
	fnm.cf = cf;
	VERIFY(GetOwner()->SendMessage(WM_NOTIFY, fnm.idFrom, (LPARAM)&fnm));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\key.h ===
// key.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CKey 

class CKey
{
public:
	CKey() {m_hKey = NULL;}
	~CKey() {Close();}

// Attributes
public:
	HKEY m_hKey;
	BOOL SetStringValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
	BOOL GetStringValue(CString& str, LPCTSTR lpszValueName = NULL);

// Operations
public:
	BOOL Create(HKEY hKey, LPCTSTR lpszKeyName);
	BOOL Open(HKEY hKey, LPCTSTR lpszKeyName);
	void Close();

// Overrides

// Implementation
protected:
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\helpids.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#define IDH_WORDPAD_TIMEDATE		1001

#define IDH_WORDPAD_ALIGN			1003
#define IDH_WORDPAD_TABSET			1004
#define IDH_WORDPAD_TABCLEAR		1005
#define IDH_WORDPAD_TAB_CLEARALL	1006
#define IDH_WORDPAD_TABSTOPS		1007
#define IDH_WORDPAD_TEXTFILE		1008
#define IDH_WORDPAD_FORMATTED		1009

#define IDH_WORDPAD_WORD6FILE		1017
#define IDH_WORDPAD_FILENEW_DOC		1018
#define IDH_WORDPAD_OPTIONS_AUTOWORDSEL	1019

#define IDH_WORDPAD_INDENT_LEFT		1020
#define IDH_WORDPAD_INDENT_RIGHT	1021
#define IDH_WORDPAD_INDENT_FIRST	1022

#define IDH_WORDPAD_WRAP_NO			1023
#define IDH_WORDPAD_WRAP_WINDOW		1024
#define IDH_WORDPAD_WRAP_RULER		1025

#define IDH_COMM_GROUPBOX			1026

#define IDH_WORDPAD_INCHES			1027
#define IDH_WORDPAD_CENTIMETERS		1028
#define IDH_WORDPAD_POINTS			1029
#define IDH_WORDPAD_PICAS			1030

#define IDH_WORDPAD_CHECK_TOOLBAR	1031
#define IDH_WORDPAD_CHECK_FORMATBAR	1032
#define IDH_WORDPAD_CHECK_STATUSBAR	1033
#define IDH_WORDPAD_CHECK_RULERBAR	1034

#define IDH_WORDPAD_TOPMARGIN		1035
#define IDH_WORDPAD_BOTTOMMARGIN	1036
#define IDH_WORDPAD_LEFTMARGIN 		1037
#define IDH_WORDPAD_RIGHTMARGIN		1038
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\listdlg.cpp ===
// listdlg.cpp : Defines the class behaviors for the application.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "resource.h"
#include "listdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CListDlg, CDialog)
	//{{AFX_MSG_MAP(CListDlg)
	ON_LBN_DBLCLK(IDC_LISTDIALOG_LIST, OnOK)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CListDlg::CListDlg(UINT idStrDlgTitle, UINT idStrListTitle, 
	const CStringList& listItems, int nDefSel) : CDialog(CListDlg::IDD),
	m_listItems(listItems)
{
	VERIFY(m_strDlgTitle.LoadString(idStrDlgTitle));
	VERIFY(m_strListTitle.LoadString(idStrListTitle));
	m_nSelection = nDefSel;
}

BOOL CListDlg::OnInitDialog()
{
	SetWindowText(m_strDlgTitle);
// fix this
	SetDlgItemText(IDC_STATIC_HEADING, m_strListTitle);
	CListBox* pListBox = (CListBox*)GetDlgItem(IDC_LISTDIALOG_LIST);
	ASSERT(pListBox != NULL);
	// fill with document templates in list

	POSITION pos = m_listItems.GetHeadPosition();
	while (pos != NULL)
	{
		 if ( pListBox->AddString(m_listItems.GetNext(pos)) == -1)
		 	return FALSE;
	}
	pListBox->SetCurSel(m_nSelection);

	return CDialog::OnInitDialog();
}

void CListDlg::OnOK()
{
	CListBox* pListBox = (CListBox*)GetDlgItem(IDC_LISTDIALOG_LIST);
	ASSERT(pListBox != NULL);
	m_nSelection = pListBox->GetCurSel();
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\listdlg.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CListDlg : public CDialog
{
public:
	//{{AFX_DATA(CListDlg)
	enum { IDD = IDD_LISTDIALOG };
	//}}AFX_DATA
	CListDlg::CListDlg(UINT idStrDlgTitle, UINT idStrListTitle, 
		const CStringList& listItems, int nDefSel=0);
	CString m_strDlgTitle,m_strListTitle;
	const CStringList& m_listItems;
	int m_nSelection;

protected:
	BOOL OnInitDialog();
	//{{AFX_MSG(CListDlg)
	afx_msg void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\formatta.cpp ===
// formatta.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "formatta.h"
#include "ddxm.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

const DWORD CFormatTabDlg::m_nHelpIDs[] =
{
	IDC_BUTTON_SET, IDH_WORDPAD_TABSET,
	IDC_BUTTON_CLEAR, IDH_WORDPAD_TABCLEAR,
	IDC_BUTTON_CLEARALL, IDH_WORDPAD_TAB_CLEARALL,
	IDC_COMBO1, IDH_WORDPAD_TABSTOPS,
	IDC_BOX, IDH_COMM_GROUPBOX,
	0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CFormatTabDlg dialog

CFormatTabDlg::CFormatTabDlg(PARAFORMAT& pf, CWnd* pParent /*=NULL*/)
	: CCSDialog(CFormatTabDlg::IDD, pParent)
{
	m_pf = pf;
	m_tabarray = new LONG[MAX_TAB_STOPS];
	m_nCount = 0;
	if (m_pf.dwMask & PFM_TABSTOPS)
	{
		m_nCount = m_pf.cTabCount;
		ASSERT(m_pf.cTabCount <= MAX_TAB_STOPS);
		for (int i=0;i<m_pf.cTabCount;i++)
			m_tabarray[i] = m_pf.rgxTabs[i];
	}
	
	//{{AFX_DATA_INIT(CFormatTabDlg)
	//}}AFX_DATA_INIT
}

CFormatTabDlg::~CFormatTabDlg()
{
	delete [] m_tabarray;
}

void CFormatTabDlg::DoDataExchange(CDataExchange* pDX)
{
	CCSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFormatTabDlg)
	DDX_Control(pDX, IDC_BUTTON_CLEARALL, m_buttonClearAll);
	DDX_Control(pDX, IDC_BUTTON_SET, m_buttonSet);
	DDX_Control(pDX, IDC_BUTTON_CLEAR, m_buttonClear);
	DDX_Control(pDX, IDC_COMBO1, m_comboBox);
	//}}AFX_DATA_MAP
	if (!pDX->m_bSaveAndValidate)
		UpdateListBox();
}

BEGIN_MESSAGE_MAP(CFormatTabDlg, CCSDialog)
	//{{AFX_MSG_MAP(CFormatTabDlg)
	ON_BN_CLICKED(IDC_BUTTON_CLEAR, OnClickedClear)
	ON_BN_CLICKED(IDC_BUTTON_CLEARALL, OnClickedClearAll)
	ON_BN_CLICKED(IDC_BUTTON_SET, OnClickedSet)
	ON_CBN_EDITCHANGE(IDC_COMBO1, OnEditChange)
	ON_CBN_SELCHANGE(IDC_COMBO1, OnSelchange)
	ON_MESSAGE(WM_HELP, OnHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFormatTabDlg message handlers

void CFormatTabDlg::OnClickedClear()
{
	int nTab;
	int nSel = m_comboBox.GetCurSel();
	if (nSel == CB_ERR)
	{
		CDataExchange dx(this, TRUE);
		DDX_Twips(&dx, IDC_COMBO1, nTab);
		DDV_MinMaxTwips(&dx, nTab, 0, 31680);
		if (nTab != DDXM_BLANK)
		{
				if (RemoveTabFromArray(nTab))
					UpdateListBox();
		}
	}
	else
	{
		ASSERT(nSel < m_nCount);
		RemoveTabFromArrayByIndex(nSel);
		UpdateListBox();
	}
	UpdateButtons();
	SetEditFocus();
}

void CFormatTabDlg::OnClickedClearAll()
{
	m_nCount = 0;
	m_comboBox.ResetContent();
	UpdateButtons();
	SetEditFocus();
}

void CFormatTabDlg::OnClickedSet()
{
	Set();
	UpdateButtons();
	SetEditFocus();
}

BOOL CFormatTabDlg::Set()
{
	int nTab;
	CDataExchange dx(this, TRUE);
	DDX_Twips(&dx, IDC_COMBO1, nTab);
	DDV_MinMaxTwips(&dx, nTab, 0, 31680);
	if (nTab != DDXM_BLANK)
	{
		if (m_nCount == MAX_TAB_STOPS)
		{
			AfxMessageBox(IDS_NOMORETABS);
			m_comboBox.Clear();
			return FALSE;
		}
		if (AddTabToArray(nTab))
			UpdateListBox();
		return TRUE;
	}
	return FALSE;
}

void CFormatTabDlg::SetEditFocus()
{
	m_comboBox.SetFocus();
	m_comboBox.SetEditSel(0,-1);
}

BOOL CFormatTabDlg::RemoveTabFromArray(LONG lTab)
{
	int i;
	for (i=0;i<m_nCount;i++)
	{
		if (m_tabarray[i] == lTab)
		{
			RemoveTabFromArrayByIndex(i);
			return TRUE;
		}
	}
	return FALSE;
}

void CFormatTabDlg::RemoveTabFromArrayByIndex(int nIndex)
{
	memmove(&m_tabarray[nIndex], &m_tabarray[nIndex+1],
		(m_nCount-nIndex-1)*sizeof(LONG));
	m_nCount--;
}

BOOL CFormatTabDlg::AddTabToArray(LONG lTab)
{
	int i;
	BOOL bInsert = FALSE;
	LONG lTemp;
	for (i=0;i<m_nCount;i++)
	{
		if (!bInsert && lTab < m_tabarray[i])
			bInsert = TRUE;
		else if (lTab == m_tabarray[i]) // we don't want repeats
			return FALSE;
		if (bInsert)
		{
			lTemp = m_tabarray[i];
			m_tabarray[i] = lTab;
			lTab = lTemp;
		}
	}
	m_tabarray[m_nCount++] = lTab;
	return TRUE;
}

void CFormatTabDlg::UpdateListBox()
{
	int i;
	TCHAR szT[64];
	ASSERT(m_nCount >= 0);
	m_comboBox.ResetContent();
	for (i=0;i<m_nCount;i++)
	{
		theApp.PrintTwips(szT, m_tabarray[i], 2);
		m_comboBox.AddString(szT);
	}
}

void CFormatTabDlg::OnOK()
{
	if (m_buttonSet.IsWindowEnabled())
	{
		if (!Set())
			return;
	}
	CCSDialog::OnOK();
	m_pf.cTabCount = (SHORT) m_nCount;
	for (int i=0;i<m_nCount;i++)
		m_pf.rgxTabs[i] = m_tabarray[i];
	m_pf.dwMask = PFM_TABSTOPS;
}

void CFormatTabDlg::OnEditChange()
{
	UpdateButtons();
}

void CFormatTabDlg::UpdateButton(CButton& button, BOOL b)
{
	if (b != button.IsWindowEnabled())
		button.EnableWindow(b);
}

void CFormatTabDlg::UpdateButtons()
{
	UpdateButton(m_buttonClearAll, m_nCount > 0);
	BOOL bHasText = (m_comboBox.GetWindowTextLength() > 0);
	UpdateButton(m_buttonSet, bHasText);
	UpdateButton(m_buttonClear, bHasText);
	WORD wID = LOWORD(GetDefID());
	if (bHasText && wID != IDC_BUTTON_SET)
		SetDefID(IDC_BUTTON_SET);
	else if (!bHasText && wID != IDOK)
		SetDefID(IDOK);
}

BOOL CFormatTabDlg::OnInitDialog()
{
	CCSDialog::OnInitDialog();
	UpdateButtons();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CFormatTabDlg::OnSelchange()
{
	UpdateButton(m_buttonClearAll, m_nCount > 0);
	// force these since if the edit control is empty and
	// an item in the box is clicked on, the edit control will
	// not be filled in first
	UpdateButton(m_buttonSet, TRUE);
	UpdateButton(m_buttonClear, TRUE);
	WORD wID = LOWORD(GetDefID());
	if (wID != IDC_BUTTON_SET)
		SetDefID(IDC_BUTTON_SET);
}


LONG CFormatTabDlg::OnHelp(UINT, LONG lParam)
{
	LPHELPINFO phi = (LPHELPINFO) lParam ;
	HWND hWndCombo = ::GetDlgItem(m_hWnd, IDC_COMBO1) ;

	HWND hWndItem = (HWND) phi->hItemHandle ;

	if (::GetParent(hWndItem) == hWndCombo)
    {
		hWndItem = hWndCombo ;
    }

	::WinHelp(hWndItem, AfxGetApp()->m_pszHelpFilePath,
		HELP_WM_HELP, (DWORD)(LPVOID)GetHelpIDs());

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\formatta.h ===
// formatta.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CFormatTabDlg dialog

class CFormatTabDlg : public CCSDialog
{
// Construction
public:
	CFormatTabDlg(PARAFORMAT& pf, CWnd* pParent = NULL);    // standard constructor
	~CFormatTabDlg();
	PARAFORMAT m_pf;
	LONG* m_tabarray;
	int m_nCount;

// Dialog Data
	//{{AFX_DATA(CFormatTabDlg)
	enum { IDD = IDD_FORMAT_TAB };
	CButton	m_buttonClearAll;
	CButton	m_buttonSet;
	CButton	m_buttonClear;
	CComboBox	m_comboBox;
	//}}AFX_DATA

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}
	void UpdateButton(CButton& button, BOOL b);
	void UpdateButtons();
	BOOL Set();
	BOOL AddTabToArray(LONG lTab);
	BOOL RemoveTabFromArray(LONG lTab);
	void RemoveTabFromArrayByIndex(int nIndex);
	void UpdateListBox();
	void SetEditFocus();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnOK();

	// Generated message map functions
	//{{AFX_MSG(CFormatTabDlg)
	afx_msg void OnClickedClear();
	afx_msg void OnClickedClearAll();
	afx_msg void OnClickedSet();
	afx_msg void OnEditChange();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchange();
	afx_msg LONG OnHelp(UINT wParam, LONG lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\mswd6_32.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef MSWD6_32_H
#define MSWD6_32_H

typedef unsigned long (pascal *PFN_RTF_CALLBACK)(int, int);

extern "C" int pascal InitConverter32(HANDLE, char *);
extern "C" HANDLE pascal RegisterApp32(unsigned long, void *);
extern "C" int pascal IsFormatCorrect32(HANDLE, HANDLE);
extern "C" int pascal ForeignToRtf32(HANDLE, void *, HANDLE, HANDLE, HANDLE, PFN_RTF_CALLBACK);
extern "C" int pascal RtfToForeign32(HANDLE, LPSTORAGE, HANDLE, HANDLE, PFN_RTF_CALLBACK);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\oleimpl3.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


/////////////////////////////////////////////////////////////////////////////
// OLE data (like AUX_DATA)

struct OLE_DATA
{
	// OLE 1.0 clipboard formats
	UINT    cfNative, cfOwnerLink, cfObjectLink;

	// OLE 2.0 clipboard formats
	UINT    cfEmbeddedObject, cfEmbedSource, cfLinkSource;
	UINT    cfObjectDescriptor, cfLinkSourceDescriptor;
	UINT    cfFileName, cfFileNameW;

	//RichEdit formats
	UINT    cfRichTextFormat;
	UINT    cfRichTextAndObjects;

	OLE_DATA();
};

extern OLE_DATA _oleData;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\multconv.h ===
// convert.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifdef CONVERTERS

/////////////////////////////////////////////////////////////////////////////
// CConverter

typedef int (CALLBACK *LPFNOUT)(int cch, int nPercentComplete);
typedef int (CALLBACK *LPFNIN)(int flags, int nPercentComplete);
typedef BOOL (FAR PASCAL *PINITCONVERTER)(HWND hWnd, LPCSTR lpszModuleName);
typedef BOOL (FAR PASCAL *PISFORMATCORRECT)(HANDLE ghszFile, HANDLE ghszClass);
typedef int (FAR PASCAL *PFOREIGNTORTF)(HANDLE ghszFile, LPVOID lpv, HANDLE ghBuff, 
	HANDLE ghszClass, HANDLE ghszSubset, LPFNOUT lpfnOut);
typedef int (FAR PASCAL *PRTFTOFOREIGN)(HANDLE ghszFile, LPVOID lpv, HANDLE ghBuff, 
	HANDLE ghszClass, LPFNIN lpfnIn);
typedef HGLOBAL (FAR PASCAL *PREGISTERAPP)(long lFlags, void *lpRegApp);


//
// Some defines taken from the converter group's convapi.h
//

#define fRegAppSupportNonOem    0x00000008  // supports non-Oem filenames
#define RegAppOpcodeCharset             0x03    // for REGAPPRET


#endif

/////////////////////////////////////////////////////////////////////////////
// CTrackFile
class CTrackFile : public CFile
{ 
public:
//Construction
	CTrackFile(CFrameWnd* pWnd);
	~CTrackFile();
	
//Attributes
	int m_nLastPercent;
	DWORD m_dwLength;
	CFrameWnd* m_pFrameWnd;
	CString m_strComplete;
	CString m_strWait;
	CString m_strSaving;
//Operations
	void OutputPercent(int nPercentComplete = 0);
	void OutputString(LPCTSTR lpsz);
	virtual UINT Read(void FAR* lpBuf, UINT nCount);
	virtual void Write(const void FAR* lpBuf, UINT nCount);
};

class COEMFile : public CTrackFile
{
public:
	COEMFile(CFrameWnd* pWnd);
	virtual UINT Read(void FAR* lpBuf, UINT nCount);
	virtual void Write(const void FAR* lpBuf, UINT nCount);
};

#ifdef CONVERTERS

class CConverter : public CTrackFile
{
public:
	CConverter(LPCTSTR pszLibName, CFrameWnd* pWnd = NULL);

public:
//Attributes
	int m_nPercent;
	BOOL m_bDone;
	BOOL m_bConvErr;
	virtual DWORD GetPosition() const;

// Operations
	BOOL IsFormatCorrect(LPCTSTR pszFileName);
	BOOL DoConversion();
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags,
		CFileException* pError = NULL);
	void WaitForConverter();
	void WaitForBuffer();

// Overridables
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual DWORD GetLength() const;

	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);

	virtual void Abort();
	virtual void Flush();
	virtual void Close();

// Unsupported
	virtual CFile* Duplicate() const;
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);
	virtual void SetLength(DWORD dwNewLen);

//Implementation
public:
	~CConverter();

protected:
	int         m_nBytesAvail;
	int         m_nBytesWritten;
	HANDLE      m_hEventFile;
	HANDLE      m_hEventConv;
	BOOL        m_bForeignToRtf;        // True to convert to RTF, else from
	HGLOBAL     m_hBuff;                // Buffer for converter data
	BYTE*       m_pBuf;                 // Pointer to m_hBuff data
	HGLOBAL     m_hFileName;            // File to convert
	HINSTANCE   m_hLibCnv;              // The converter dll
    BOOL        m_bUseOEM;              // TRUE to use OEM filenames

    // Entry points into the converter dll

	PINITCONVERTER      m_pInitConverter;
	PISFORMATCORRECT    m_pIsFormatCorrect;
	PFOREIGNTORTF       m_pForeignToRtf;
	PRTFTOFOREIGN       m_pRtfToForeign;
    PREGISTERAPP        m_pRegisterApp;

	int CALLBACK WriteOut(int cch, int nPercentComplete);
	int CALLBACK ReadIn(int nPercentComplete);
	static HGLOBAL StringToHGLOBAL(LPCSTR pstr);
	static int CALLBACK WriteOutStatic(int cch, int nPercentComplete);
	static int CALLBACK ReadInStatic(int flags, int nPercentComplete);
	static UINT AFX_CDECL ConverterThread(LPVOID pParam);
	static CConverter *m_pThis;

	void LoadFunctions();
    void NegotiateForNonOEM();

    #ifndef _X86_

    //We need to change the error mode when using the write converter
    //to fix some alignment problems caused by the write converter.  These
    //problems do not affect x86 platforms.

    UINT m_uPrevErrMode ;

    #endif
};

#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\oleinit.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "stdafx2.h"

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

#ifdef _MAC
AEEventHandlerUPP _afxPfnOleAuto;
#endif

/////////////////////////////////////////////////////////////////////////////
// OLE OLE_DATA init structure

OLE_DATA _oleData;

OLE_DATA::OLE_DATA()
{
	// OLE 1.0 Clipboard formats
	cfNative = ::RegisterClipboardFormat(_T("Native"));
	cfOwnerLink = ::RegisterClipboardFormat(_T("OwnerLink"));
	cfObjectLink = ::RegisterClipboardFormat(_T("ObjectLink"));

	// OLE 2.0 Clipboard formats
	cfEmbeddedObject = ::RegisterClipboardFormat(_T("Embedded Object"));
	cfEmbedSource = ::RegisterClipboardFormat(_T("Embed Source"));
	cfLinkSource = ::RegisterClipboardFormat(_T("Link Source"));
	cfObjectDescriptor = ::RegisterClipboardFormat(_T("Object Descriptor"));
	cfLinkSourceDescriptor = ::RegisterClipboardFormat(_T("Link Source Descriptor"));
	cfFileName = ::RegisterClipboardFormat(_T("FileName"));
	cfFileNameW = ::RegisterClipboardFormat(_T("FileNameW"));
	cfRichTextFormat = ::RegisterClipboardFormat(_T("Rich Text Format"));
	cfRichTextAndObjects = ::RegisterClipboardFormat(_T("RichEdit Text and Objects"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\options.cpp ===
// options.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "strings.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDocOptions


void CDocOptions::SaveDockState(CDockState& ds, LPCTSTR lpszProfileName, LPCTSTR lpszLayout)
{
	CMemFile file;
	CArchive ar(&file, CArchive::store);
	ds.Serialize(ar);
	ar.Close();
	int nSize = file.GetLength();
	ASSERT(nSize < 4096);
	BYTE* p = new BYTE[nSize];
	file.SeekToBegin();
	file.Read(p, nSize);
	theApp.WriteProfileBinary(lpszProfileName, lpszLayout, p, nSize);
	delete [] p;
}

void CDocOptions::SaveOptions(LPCTSTR lpszProfileName)
{
	SaveDockState(m_ds1, lpszProfileName, szLayout1);
	SaveDockState(m_ds2, lpszProfileName, szLayout2);
	theApp.WriteProfileInt(lpszProfileName, szWrap, m_nWordWrap);

    int barstate[2] = {0, 0};

    for (int i = 0; i < 2; i++)
    {
        barstate[i] = barstate[i] | (m_barstate[i].m_bRulerBar  ? 0x1 : 0);
        barstate[i] = barstate[i] | (m_barstate[i].m_bStatusBar ? 0x2 : 0);
        barstate[i] = barstate[i] | (m_barstate[i].m_bToolBar   ? 0x4 : 0);
        barstate[i] = barstate[i] | (m_barstate[i].m_bFormatBar ? 0x8 : 0);
    }

    theApp.WriteProfileInt(lpszProfileName, TEXT("BarState0"), barstate[0]);
    theApp.WriteProfileInt(lpszProfileName, TEXT("BarState1"), barstate[1]);
}

void CDocOptions::LoadDockState(CDockState& ds, LPCTSTR lpszProfileName, LPCTSTR lpszLayout)
{
	BYTE* p;
	UINT nLen = 0;
	if (theApp.GetProfileBinary(lpszProfileName, lpszLayout, &p, &nLen))
	{
		ASSERT(nLen < 4096);

      //
      // APPCOMPAT: If this value is not reasonable, then we have likely run into
      // a registry corruption problem with wordpad that seems to appear only once
      // every 2-3 months.  If the registry is corrupted, then we need to fix
      // it or wordpad will get into a weird state.
      //

      if (nLen >= 4096)
      {
          delete p ;

          HKEY hKeyApp = theApp.GetAppRegistryKey() ;

          if ((HKEY) 0 != hKeyApp)
          {
              RegDeleteKey(hKeyApp, lpszProfileName) ;
              RegCloseKey(hKeyApp) ;
          }
      }
      else
      {
		    CMemFile file;
		    file.Write(p, nLen);
		    file.SeekToBegin();
		    CArchive ar(&file, CArchive::load);
		    ds.Serialize(ar);
		    ar.Close();
		    delete p;
      }
	}
}

void CDocOptions::LoadOptions(LPCTSTR lpszProfileName)
{
	LoadDockState(m_ds1, lpszProfileName, szLayout1);
	LoadDockState(m_ds2, lpszProfileName, szLayout2);
	m_nWordWrap = theApp.GetProfileInt(lpszProfileName, szWrap, m_nDefWrap);


    for (int bar = 0; bar < 2; bar++)
    {
        CDockState& ds = (bar == 0) ? m_ds1 : m_ds2;
        CBarState& barstate = m_barstate[bar];

        int defaultstate = (lpszProfileName == szTextSection) ? 0x6 : 0xf;
        int state;

        if (0 == bar)
        {
            state = theApp.GetProfileInt(lpszProfileName, TEXT("BarState0"), defaultstate);
        }
        else
        {
            state = theApp.GetProfileInt(lpszProfileName, TEXT("BarState1"), defaultstate);
        }

        barstate.m_bRulerBar =  (state & 0x1) != 0;
        barstate.m_bStatusBar = (state & 0x2) != 0;
        barstate.m_bToolBar =   (state & 0x4) != 0;
        barstate.m_bFormatBar = (state & 0x8) != 0;

        //
        // The following code is used to setup the barstate from the dock state.
        // It is really only here to support upgrading from NT 4 or Win95 to
        // NT 5 or Memphis.  It can problably be removed for NT 6.
        //

        for (int i = 0;i < ds.m_arrBarInfo.GetSize(); i++)
	    {
		    CControlBarInfo* pInfo = (CControlBarInfo*)ds.m_arrBarInfo[i];
		    ASSERT(pInfo != NULL);
		    switch (pInfo->m_nBarID)
		    {
			    case ID_VIEW_FORMATBAR:
                    barstate.m_bFormatBar = pInfo->m_bVisible;
				    break;
			    case ID_VIEW_RULER:
                    barstate.m_bRulerBar = pInfo->m_bVisible;
				    break;
			    case ID_VIEW_TOOLBAR:
                    barstate.m_bToolBar = pInfo->m_bVisible;;
				    break;
			    case ID_VIEW_STATUS_BAR:
                    barstate.m_bStatusBar = pInfo->m_bVisible;;
				    break;
		    }
	    }
    }
    
}

/////////////////////////////////////////////////////////////////////////////
// CUnit

const CUnit& CUnit::operator=(const CUnit& unit)
{
	m_nTPU = unit.m_nTPU;
	m_nSmallDiv = unit.m_nSmallDiv;
	m_nMediumDiv = unit.m_nMediumDiv;
	m_nLargeDiv = unit.m_nLargeDiv;
	m_nMinMove = unit.m_nMinMove;
	m_nAbbrevID = unit.m_nAbbrevID;
	m_bSpaceAbbrev = unit.m_bSpaceAbbrev;
	m_strAbbrev = unit.m_strAbbrev;
	return *this;
}

CUnit::CUnit(int nTPU, int nSmallDiv, int nMediumDiv, int nLargeDiv,
		int nMinMove, UINT nAbbrevID, BOOL bSpaceAbbrev)
{
	m_nTPU = nTPU;
	m_nSmallDiv = nSmallDiv;
	m_nMediumDiv = nMediumDiv;
	m_nLargeDiv = nLargeDiv;
	m_nMinMove = nMinMove;
	m_nAbbrevID = nAbbrevID;
	m_bSpaceAbbrev = bSpaceAbbrev;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\ipframe.cpp ===
// ipframe.cpp : implementation of the CInPlaceFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "formatba.h"
#include "ruler.h"
#include "ipframe.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "colorlis.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame

IMPLEMENT_DYNCREATE(CInPlaceFrame, COleIPFrameWnd)

BEGIN_MESSAGE_MAP(CInPlaceFrame, COleIPFrameWnd)
	//{{AFX_MSG_MAP(CInPlaceFrame)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_COMMAND(ID_HELP, OnHelpFinder)
	ON_COMMAND(ID_CHAR_COLOR, OnCharColor)
	ON_COMMAND(ID_HELP_INDEX, OnHelpFinder)
	ON_COMMAND(ID_PEN_TOGGLE, OnPenToggle)
	//}}AFX_MSG_MAP
	ON_UPDATE_COMMAND_UI(ID_VIEW_TOOLBAR, OnUpdateControlBarMenu)
	ON_COMMAND_EX(ID_VIEW_TOOLBAR, OnBarCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_FORMATBAR, OnUpdateControlBarMenu)
	ON_COMMAND_EX(ID_VIEW_FORMATBAR, OnBarCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_RULER, OnUpdateControlBarMenu)
	ON_COMMAND_EX(ID_VIEW_RULER, OnBarCheck)
	ON_MESSAGE(WM_SIZECHILD, OnResizeChild)
	ON_MESSAGE(WPM_BARSTATE, OnBarState)
	ON_COMMAND(ID_DEFAULT_HELP, OnHelpFinder)
//	ON_COMMAND(ID_CONTEXT_HELP, COleIPFrameWnd::OnContextHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars

static UINT BASED_CODE toolButtons[] =
{
	// same order as in the bitmap 'itoolbar.bmp'
	ID_EDIT_CUT,
	ID_EDIT_COPY,
	ID_EDIT_PASTE,

		ID_SEPARATOR,
	ID_PEN_TOGGLE,
	ID_PEN_PERIOD,
	ID_PEN_SPACE,
	ID_PEN_BACKSPACE,
	ID_PEN_NEWLINE,
	ID_PEN_LENS
};

#define NUM_PEN_ITEMS 7
#define NUM_PEN_TOGGLE 5

static UINT BASED_CODE format[] =
{
	// same order as in the bitmap 'format.bmp'
		ID_SEPARATOR, // font name combo box
		ID_SEPARATOR,
		ID_SEPARATOR, // font size combo box
		ID_SEPARATOR,
	ID_CHAR_BOLD,
	ID_CHAR_ITALIC,
	ID_CHAR_UNDERLINE,
	ID_CHAR_COLOR,
		ID_SEPARATOR,
	ID_PARA_LEFT,
	ID_PARA_CENTER,
	ID_PARA_RIGHT,
		ID_SEPARATOR,
	ID_INSERT_BULLET,
};

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame construction/destruction

int CInPlaceFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleIPFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// CResizeBar implements in-place resizing.
	if (!m_wndResizeBar.Create(this))
	{
		TRACE0("Failed to create resize bar\n");
		return -1;      // fail to create
	}

	if (!CreateRulerBar(this))
		return FALSE;

	// By default, it is a good idea to register a drop-target that does
	//  nothing with your frame window.  This prevents drops from
	//  "falling through" to a container that supports drag-drop.
	m_dropTarget.Register(this);

	return 0;
}

// OnCreateControlBars is called by the framework to create control bars on the
//  container application's windows.  pWndFrame is the top level frame window of
//  the container and is always non-NULL.  pWndDoc is the doc level frame window
//  and will be NULL when the container is an SDI application.  A server
//  application can place MFC control bars on either window.
BOOL CInPlaceFrame::OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* /*pWndDoc*/)
{
	if (!CreateToolBar(pWndFrame))
		return FALSE;

	if (!CreateFormatBar(pWndFrame))
		return FALSE;

	// set owner to this window, so messages are delivered to correct app
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	m_wndFormatBar.EnableDocking(CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM);
	pWndFrame->EnableDocking(CBRS_ALIGN_ANY);
	pWndFrame->DockControlBar(&m_wndToolBar);
	pWndFrame->DockControlBar(&m_wndFormatBar);

	m_wndToolBar.SetOwner(this);
	m_wndFormatBar.SetOwner(this);
	m_wndRulerBar.SetOwner(this);
	OnBarState(1, RD_EMBEDDED); //load bar state
	return TRUE;
}

BOOL CInPlaceFrame::CreateToolBar(CWnd* pWndFrame)
{
	// Create toolbar on client's frame window
	ASSERT(m_wndToolBar.m_hWnd == NULL);
	int nPen = GetSystemMetrics(SM_PENWINDOWS) ? NUM_PEN_TOGGLE : 
		NUM_PEN_ITEMS;
	UINT nID = theApp.m_bLargeIcons ? 
		IDR_SRVR_INPLACE_BIG : IDR_SRVR_INPLACE;
	if (!m_wndToolBar.Create(pWndFrame, WS_CHILD|WS_VISIBLE|CBRS_TOP|
			CBRS_TOOLTIPS|CBRS_FLYBY|CBRS_SIZE_DYNAMIC)||
		!m_wndToolBar.LoadBitmap(nID) ||
		!m_wndToolBar.SetButtons(toolButtons, 
			sizeof(toolButtons)/sizeof(UINT) - nPen))
	{
		TRACE0("Failed to create toolbar\n");
		return FALSE;      // fail to create
	}
	if (theApp.m_bLargeIcons)
		m_wndToolBar.SetSizes(CSize(31,30), CSize(24,24));
	else
		m_wndToolBar.SetSizes(CSize(23,22), CSize(16,16));
	CString str;
	str.LoadString(IDS_TITLE_TOOLBAR);
	m_wndToolBar.SetWindowText(str);
	return TRUE;
}

BOOL CInPlaceFrame::CreateFormatBar(CWnd* pWndFrame)
{
	ASSERT(m_wndFormatBar.m_hWnd == NULL);
	m_wndFormatBar.m_hWndOwner = m_hWnd;
	UINT nID = theApp.m_bLargeIcons ? IDB_FORMATBAR_BIG : IDB_FORMATBAR;
	if (!m_wndFormatBar.Create(pWndFrame, WS_CHILD|WS_VISIBLE|CBRS_TOP|
		CBRS_TOOLTIPS|CBRS_FLYBY|CBRS_HIDE_INPLACE|CBRS_SIZE_DYNAMIC, ID_VIEW_FORMATBAR) ||
		!m_wndFormatBar.LoadBitmap(nID) ||
		!m_wndFormatBar.SetButtons(format, 
			sizeof(format)/sizeof(UINT)))
	{
		TRACE0("Failed to create FormatBar\n");
		return FALSE;      // fail to create
	}

	if (theApp.m_bLargeIcons)
		m_wndFormatBar.SetSizes(CSize(31,30), CSize(24,24));
	else
		m_wndFormatBar.SetSizes(CSize(23,22), CSize(16,16));
	CString str;
	str.LoadString(IDS_TITLE_FORMATBAR);
	m_wndFormatBar.SetWindowText(str);
	m_wndFormatBar.PositionCombos();
	return TRUE;
}

CInPlaceFrame::CreateRulerBar(CWnd* pWndFrame)
{
	if (!m_wndRulerBar.Create(pWndFrame, 
		WS_CHILD|WS_VISIBLE|CBRS_ALIGN_TOP|CBRS_HIDE_INPLACE, ID_VIEW_RULER))
	{
		TRACE0("Failed to create ruler\n");
		return FALSE;      // fail to create
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame Operations

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame diagnostics

#ifdef _DEBUG
void CInPlaceFrame::AssertValid() const
{
	COleIPFrameWnd::AssertValid();
}

void CInPlaceFrame::Dump(CDumpContext& dc) const
{
	COleIPFrameWnd::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame commands

void CInPlaceFrame::OnDestroy()
{
	m_wndToolBar.DestroyWindow();
	m_wndFormatBar.DestroyWindow();
	COleIPFrameWnd::OnDestroy();
}

void CInPlaceFrame::RepositionFrame(LPCRECT lpPosRect, LPCRECT lpClipRect)
{
	CRect rectNew = lpPosRect;
	rectNew.left -= HORZ_TEXTOFFSET;
	rectNew.top -= VERT_TEXTOFFSET;
	m_wndResizeBar.BringWindowToTop();
	COleIPFrameWnd::RepositionFrame(&rectNew, lpClipRect);
	CWnd* pWnd = GetActiveView();
	if (pWnd != NULL)
		pWnd->BringWindowToTop();
	m_wndRulerBar.BringWindowToTop();
}

void CInPlaceFrame::RecalcLayout(BOOL bNotify)
{
	if (m_wndResizeBar.m_hWnd != NULL)
		m_wndResizeBar.BringWindowToTop();
	COleIPFrameWnd::RecalcLayout(bNotify);
	CWnd* pWnd = GetActiveView();
	if (pWnd != NULL)
		pWnd->BringWindowToTop();
	if (m_wndRulerBar.m_hWnd != NULL)
		m_wndRulerBar.BringWindowToTop();

	// at least 12 pt region plus ruler if it exists
	CDisplayIC dc;
	CSize size;
	size.cy = MulDiv(12, dc.GetDeviceCaps(LOGPIXELSY), 72)+1;
	size.cx = dc.GetDeviceCaps(LOGPIXELSX)/4; // 1/4"
	size.cx += HORZ_TEXTOFFSET; //adjust for offset
	size.cy += VERT_TEXTOFFSET;
	if (m_wndRulerBar.m_hWnd != NULL && m_wndRulerBar.IsVisible())
	{
		CRect rect;
		m_wndRulerBar.GetWindowRect(&rect);
		size.cy += rect.Height();
	}
	m_wndResizeBar.SetMinSize(size);
}

void CInPlaceFrame::CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType)
{
	COleIPFrameWnd::CalcWindowRect(lpClientRect, nAdjustType);
}

LRESULT CInPlaceFrame::OnResizeChild(WPARAM /*wParam*/, LPARAM lParam)
{
	// notify the container that the rectangle has changed!
	CWordPadDoc* pDoc = (CWordPadDoc*)GetActiveDocument();
	if (pDoc == NULL)
		return 0;

	ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CWordPadDoc)));

	// get new rect and parent
	CRect rectNew;
	rectNew.CopyRect((LPCRECT)lParam);
	CWnd* pParentWnd = GetParent();
	ASSERT_VALID(pParentWnd);

	// convert rectNew relative to pParentWnd
	ClientToScreen(&rectNew);
	pParentWnd->ScreenToClient(&rectNew);

	if (m_wndRulerBar.GetStyle()&WS_VISIBLE)
	{
		CRect rect;
		m_wndRulerBar.GetWindowRect(&rect);
		rectNew.top += rect.Height();
	}
	rectNew.left += HORZ_TEXTOFFSET;
	rectNew.top += VERT_TEXTOFFSET;

	// adjust the new rectangle for the current control bars
	CWnd* pLeftOver = GetDlgItem(AFX_IDW_PANE_FIRST);
	ASSERT(pLeftOver != NULL);
	CRect rectCur = m_rectPos;
	pLeftOver->CalcWindowRect(&rectCur, CWnd::adjustOutside);
	rectNew.left += m_rectPos.left - rectCur.left;
	rectNew.top += m_rectPos.top - rectCur.top;
	rectNew.right -= rectCur.right - m_rectPos.right;
	rectNew.bottom -= rectCur.bottom - m_rectPos.bottom;
	OnRequestPositionChange(rectNew);

	return 0;
}

LONG CInPlaceFrame::OnBarState(UINT wParam, LONG lParam)
{
	if (lParam == -1)
		return 0L;
	if (wParam == 0)
	{
		GetDockState(theApp.GetDockState(RD_EMBEDDED));
		ASSERT(m_pMainFrame != NULL);
		m_pMainFrame->GetDockState(theApp.GetDockState(RD_EMBEDDED, FALSE));
	}
	else
	{
		SetDockState(theApp.GetDockState(RD_EMBEDDED));
		m_pMainFrame->SetDockState(theApp.GetDockState(RD_EMBEDDED, FALSE));
	}
	return 0L;
}

void CInPlaceFrame::OnHelpFinder() 
{
    theApp.WinHelp(0, HELP_FINDER);
}

void CInPlaceFrame::OnCharColor() 
{
	CColorMenu colorMenu;
	CRect rc;
	int index = m_wndFormatBar.CommandToIndex(ID_CHAR_COLOR);
	m_wndFormatBar.GetItemRect(index, &rc);
	m_wndFormatBar.ClientToScreen(rc);
	colorMenu.TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON,rc.left,rc.bottom, this);
}

void CInPlaceFrame::OnPenToggle() 
{
	static int nPen = 0;
	m_wndToolBar.SetButtons(toolButtons, sizeof(toolButtons)/sizeof(UINT) - nPen);
	nPen = (nPen == 0) ? NUM_PEN_TOGGLE : 0;
	m_wndToolBar.Invalidate();
	m_wndToolBar.GetParentFrame()->RecalcLayout();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\key.cpp ===
// key.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "key.h"
#include <winreg.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CKey

void CKey::Close()
{
	if (m_hKey != NULL)
	{
		LONG lRes = RegCloseKey(m_hKey);
		ASSERT(lRes == ERROR_SUCCESS);
		m_hKey = NULL;
	}
}

BOOL CKey::Create(HKEY hKey, LPCTSTR lpszKeyName)
{
	ASSERT(hKey != NULL);
	return (RegCreateKey(hKey, lpszKeyName, &m_hKey) == ERROR_SUCCESS);
}

BOOL CKey::Open(HKEY hKey, LPCTSTR lpszKeyName)
{
	ASSERT(hKey != NULL);
	return (RegOpenKey(hKey, lpszKeyName, &m_hKey) == ERROR_SUCCESS);
}

BOOL CKey::SetStringValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	ASSERT(m_hKey != NULL);
	return (RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ, 
		(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR)) == ERROR_SUCCESS);
}

BOOL CKey::GetStringValue(CString& str, LPCTSTR lpszValueName)
{
	ASSERT(m_hKey != NULL);
	str.Empty();
	DWORD dw = 0;
	DWORD dwType = 0;
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType, 
		NULL, &dw);
	if (lRes == ERROR_SUCCESS)
	{
		ASSERT(dwType == REG_SZ);
		LPTSTR lpsz = str.GetBufferSetLength(dw);
		lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType, (BYTE*)lpsz, &dw);
		ASSERT(lRes == ERROR_SUCCESS);
		str.ReleaseBuffer();
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\pageset.h ===
// pageset.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CPageSetupDlg dialog

class CPageSetupDlg : public CCSDialog
{
// Construction
public:
	CPageSetupDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CPageSetupDlg)
	enum { IDD = IDD_PAGE_SETUP_DIALOG };
	int		m_nTopMargin;
	int		m_nRightMargin;
	int		m_nLeftMargin;
	int		m_nBottomMargin;
	//}}AFX_DATA

// Implementation
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	// Generated message map functions
	//{{AFX_MSG(CPageSetupDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\mainfrm.cpp ===
// mainfrm.cpp : implementation of the CMainFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "wordpad.h"
#include "mainfrm.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "strings.h"
#include "colorlis.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_SIZE()
	ON_WM_MOVE()
	ON_COMMAND(ID_HELP, OnHelpFinder)
	ON_WM_DROPFILES()
	ON_COMMAND(ID_CHAR_COLOR, OnCharColor)
	ON_COMMAND(ID_PEN_TOGGLE, OnPenToggle)
	ON_WM_FONTCHANGE()
	ON_WM_QUERYNEWPALETTE()
	ON_WM_PALETTECHANGED()
	ON_WM_DEVMODECHANGE()
	ON_COMMAND(ID_HELP_INDEX, OnHelpFinder)
	//}}AFX_MSG_MAP
	// Global help commands
//	ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
	ON_COMMAND(ID_DEFAULT_HELP, OnHelpFinder)
	ON_UPDATE_COMMAND_UI(ID_VIEW_FORMATBAR, OnUpdateControlBarMenu)
	ON_UPDATE_COMMAND_UI(ID_VIEW_RULER, OnUpdateControlBarMenu)
	ON_MESSAGE(WPM_BARSTATE, OnBarState)
	ON_REGISTERED_MESSAGE(CWordPadApp::m_nOpenMsg, OnOpenMsg)
	ON_COMMAND_EX(ID_VIEW_STATUS_BAR, OnBarCheck)
	ON_COMMAND_EX(ID_VIEW_TOOLBAR, OnBarCheck)
	ON_COMMAND_EX(ID_VIEW_FORMATBAR, OnBarCheck)
	ON_COMMAND_EX(ID_VIEW_RULER, OnBarCheck)
   ON_REGISTERED_MESSAGE(CWordPadApp::m_nOLEHelpMsg, OnOLEHelpMsg)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars

// toolbar buttons - IDs are command buttons
static UINT BASED_CODE toolbar[] =
{
	// same order as in the bitmap 'toolbar.bmp'
	// (int nBitmap, int nCommand, BYTE byteState, BYTE byteStyle, DWORD dw, int nString)
	ID_FILE_NEW,
	ID_FILE_OPEN,
	ID_FILE_SAVE,
ID_SEPARATOR,
	ID_FILE_PRINT_DIRECT,
	ID_FILE_PRINT_PREVIEW,
ID_SEPARATOR,
	ID_EDIT_FIND,
ID_SEPARATOR,
	ID_EDIT_CUT,
	ID_EDIT_COPY,
	ID_EDIT_PASTE,
	ID_EDIT_UNDO,
ID_SEPARATOR,
	ID_INSERT_DATE_TIME,
ID_SEPARATOR,
	ID_PEN_TOGGLE,
	ID_PEN_PERIOD,
	ID_PEN_SPACE,
	ID_PEN_BACKSPACE,
	ID_PEN_NEWLINE,
	ID_PEN_LENS
};

#define NUM_PEN_ITEMS 7
#define NUM_PEN_TOGGLE 5

static UINT BASED_CODE format[] =
{
	// same order as in the bitmap 'format.bmp'
		ID_SEPARATOR, // font name combo box
		ID_SEPARATOR,
		ID_SEPARATOR, // font size combo box
		ID_SEPARATOR,
	ID_CHAR_BOLD,
	ID_CHAR_ITALIC,
	ID_CHAR_UNDERLINE,
	ID_CHAR_COLOR,
		ID_SEPARATOR,
	ID_PARA_LEFT,
	ID_PARA_CENTER,
	ID_PARA_RIGHT,
		ID_SEPARATOR,
	ID_INSERT_BULLET,
};

static UINT BASED_CODE indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	m_hIconDoc = theApp.LoadIcon(IDI_ICON_DOC);
	m_hIconText = theApp.LoadIcon(IDI_ICON_TEXT);
	m_hIconWrite = theApp.LoadIcon(IDI_ICON_WRITE);
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	WNDCLASS wndcls;

	BOOL bRes = CFrameWnd::PreCreateWindow(cs);
	HINSTANCE hInst = AfxGetInstanceHandle();

	// see if the class already exists
	if (!::GetClassInfo(hInst, szWordPadClass, &wndcls))
	{
		// get default stuff
		::GetClassInfo(hInst, cs.lpszClass, &wndcls);
		wndcls.style &= ~(CS_HREDRAW|CS_VREDRAW);
		// register a new class
		wndcls.lpszClassName = szWordPadClass;
		wndcls.hIcon = ::LoadIcon(hInst, MAKEINTRESOURCE(IDR_MAINFRAME));
		ASSERT(wndcls.hIcon != NULL);
		if (!AfxRegisterClass(&wndcls))
			AfxThrowResourceException();
	}
	cs.lpszClass = szWordPadClass;
	CRect rect = theApp.m_rectInitialFrame;
	if (rect.Width() > 0 && rect.Height() > 0)
	{
		// make sure window will be visible
		CDisplayIC dc;
		CRect rectDisplay(0, 0, dc.GetDeviceCaps(HORZRES),
			dc.GetDeviceCaps(VERTRES));
		if (rectDisplay.PtInRect(rect.TopLeft()) &&
			rectDisplay.PtInRect(rect.BottomRight()))
		{
			cs.x = rect.left;
			cs.y = rect.top;
			cs.cx = rect.Width();
			cs.cy = rect.Height();
		}
	}
	return bRes;
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!CreateToolBar())
		return -1;

	if (!CreateFormatBar())
		return -1;

	if (!CreateStatusBar())
		return -1;

	EnableDocking(CBRS_ALIGN_ANY);

	if (!CreateRulerBar())
		return -1;

	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	m_wndFormatBar.EnableDocking(CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM);
	DockControlBar(&m_wndToolBar);
	DockControlBar(&m_wndFormatBar);

	CWnd* pView = GetDlgItem(AFX_IDW_PANE_FIRST);
	if (pView != NULL)	
	{
		pView->SetWindowPos(&wndBottom, 0, 0, 0, 0,
			SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE);
	}

	return 0;
}

BOOL CMainFrame::CreateToolBar()
{
	int nPen = GetSystemMetrics(SM_PENWINDOWS) ? NUM_PEN_TOGGLE :
		NUM_PEN_ITEMS;
	UINT nID = theApp.m_bLargeIcons ? IDR_MAINFRAME1_BIG :
		IDR_MAINFRAME1;
	if (!m_wndToolBar.Create(this,
		WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_TOOLTIPS|CBRS_FLYBY|CBRS_SIZE_DYNAMIC)||
		!m_wndToolBar.LoadBitmap(nID) ||
		!m_wndToolBar.SetButtons(toolbar, sizeof(toolbar)/sizeof(UINT) - nPen))
	{
		TRACE0("Failed to create toolbar\n");
		return FALSE;      // fail to create
	}
	if (theApp.m_bLargeIcons)
		m_wndToolBar.SetSizes(CSize(31,30), CSize(24,24));
	else
		m_wndToolBar.SetSizes(CSize(23,22), CSize(16,16));
	CString str;
	str.LoadString(IDS_TITLE_TOOLBAR);
	m_wndToolBar.SetWindowText(str);
	return TRUE;
}

BOOL CMainFrame::CreateFormatBar()
{
	UINT nID = theApp.m_bLargeIcons ? IDB_FORMATBAR_BIG : IDB_FORMATBAR;
	if (!m_wndFormatBar.Create(this,
		WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_TOOLTIPS|CBRS_FLYBY|CBRS_HIDE_INPLACE|CBRS_SIZE_DYNAMIC,
		ID_VIEW_FORMATBAR) ||
		!m_wndFormatBar.LoadBitmap(nID) ||
		!m_wndFormatBar.SetButtons(format, sizeof(format)/sizeof(UINT)))
	{
		TRACE0("Failed to create FormatBar\n");
		return FALSE;      // fail to create
	}

	if (theApp.m_bLargeIcons)
		m_wndFormatBar.SetSizes(CSize(31,30), CSize(24,24));
	else
		m_wndFormatBar.SetSizes(CSize(23,22), CSize(16,16));
	CString str;
	str.LoadString(IDS_TITLE_FORMATBAR);
	m_wndFormatBar.SetWindowText(str);
	m_wndFormatBar.PositionCombos();
	return TRUE;
}

BOOL CMainFrame::CreateRulerBar()
{
	if (!m_wndRulerBar.Create(this,
		WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_HIDE_INPLACE, ID_VIEW_RULER))
	{
		TRACE0("Failed to create ruler\n");
		return FALSE;      // fail to create
	}
	return TRUE;
}

BOOL CMainFrame::CreateStatusBar()
{
	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return FALSE;      // fail to create
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame Operations

HICON CMainFrame::GetIcon(int nDocType)
{
	switch (nDocType)
	{
		case RD_WINWORD6:
		case RD_WORDPAD:
		case RD_EMBEDDED:
		case RD_RICHTEXT:
			return m_hIconDoc;
		case RD_TEXT:
		case RD_OEMTEXT:
			return m_hIconText;
		case RD_WRITE:
			return m_hIconWrite;
	}
	return m_hIconDoc;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnFontChange()
{
	m_wndFormatBar.SendMessage(CWordPadApp::m_nPrinterChangedMsg);
}

void CMainFrame::OnDevModeChange(LPTSTR lpDeviceName)
{
	theApp.NotifyPrinterChanged();
	CFrameWnd::OnDevModeChange(lpDeviceName); //sends message to descendants
}

void CMainFrame::OnSysColorChange()
{
	CFrameWnd::OnSysColorChange();
	m_wndRulerBar.SendMessage(WM_SYSCOLORCHANGE);
}

void CMainFrame::ActivateFrame(int nCmdShow)
{
   WINDOWPLACEMENT wp ;

   wp.length = sizeof(WINDOWPLACEMENT) ;

   if (GetWindowPlacement(&wp))
   {
       memcpy(&wp.rcNormalPosition, &theApp.m_rectInitialFrame, sizeof(RECT)) ;
       SetWindowPlacement(&wp) ;
   }

	CFrameWnd::ActivateFrame(nCmdShow);
	// make sure and display the toolbar, ruler, etc while loading a document.
	OnIdleUpdateCmdUI();
	UpdateWindow();
}

void CMainFrame::OnSize(UINT nType, int cx, int cy)
{
	CFrameWnd::OnSize(nType, cx, cy);
	theApp.m_bMaximized = (nType == SIZE_MAXIMIZED);
	if (nType == SIZE_RESTORED)
		GetWindowRect(theApp.m_rectInitialFrame);
}

LONG CMainFrame::OnBarState(UINT wParam, LONG lParam)
{
	if (lParam == -1)
		return 0L;
	ASSERT(lParam != RD_EMBEDDED);
	if (wParam == 0)
	{
		CDockState& ds = theApp.GetDockState(lParam);
		ds.Clear(); // empty out the dock state
		GetDockState(ds);
	}
	else
	{
		if (IsTextType(lParam))
		{
			// in text mode hide the ruler and format bar so that it is the default
			CControlBar* pBar = GetControlBar(ID_VIEW_FORMATBAR);
			if (pBar != NULL)
				pBar->ShowWindow(SW_HIDE);
			pBar = GetControlBar(ID_VIEW_RULER);
			if (pBar != NULL)
				pBar->ShowWindow(SW_HIDE);
		}
		HICON hIcon = GetIcon((int)lParam);
		SendMessage(WM_SETICON, TRUE, (LPARAM)hIcon);
		SetDockState(theApp.GetDockState(lParam));
	}
	return 0L;
}

void CMainFrame::OnMove(int x, int y)
{
	CFrameWnd::OnMove(x, y);
	WINDOWPLACEMENT wp;
	wp.length = sizeof(wp);
	GetWindowPlacement(&wp);
	theApp.m_rectInitialFrame = wp.rcNormalPosition;
	CView* pView = GetActiveView();
	if (pView != NULL)
		pView->SendMessage(WM_MOVE);
}

LONG CMainFrame::OnOpenMsg(UINT, LONG lParam)
{
	TCHAR szAtomName[256];
	szAtomName[0] = NULL;
	GlobalGetAtomName((ATOM)lParam, szAtomName, 256);
	CWordPadDoc* pDoc = (CWordPadDoc*)GetActiveDocument();
	if (szAtomName[0] != NULL && pDoc != NULL)
	{
		if (lstrcmpi(szAtomName, pDoc->GetPathName()) == 0)
			return TRUE;
	}
	return FALSE;
}

LONG CMainFrame::OnOLEHelpMsg(UINT, LONG)
{
	CWnd* pMainWnd = AfxGetMainWnd();
	ASSERT_VALID(pMainWnd);

	// return global app help mode state to FALSE (backward compatibility)
	m_bHelpMode = FALSE;
	pMainWnd->PostMessage(WM_KICKIDLE); // trigger idle update

    pMainWnd->WinHelp(0, HELP_FINDER);

   return TRUE ;
}

void CMainFrame::OnHelpFinder()
{
    theApp.WinHelp(0, HELP_FINDER);
}

void CMainFrame::OnDropFiles(HDROP hDropInfo)
{
	TCHAR szFileName[_MAX_PATH];
	::DragQueryFile(hDropInfo, 0, szFileName, _MAX_PATH);
	::DragFinish(hDropInfo);
	theApp.OpenDocumentFile(szFileName);
}

void CMainFrame::OnCharColor()
{
	CColorMenu colorMenu;
	CRect rc;
	int index = m_wndFormatBar.CommandToIndex(ID_CHAR_COLOR);
	m_wndFormatBar.GetItemRect(index, &rc);
	m_wndFormatBar.ClientToScreen(rc);
	colorMenu.TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON,rc.left,rc.bottom, this);
}

void CMainFrame::OnPenToggle()
{
	static int nPen = 0;
	m_wndToolBar.SetButtons(toolbar, sizeof(toolbar)/sizeof(UINT) - nPen);
	nPen = (nPen == 0) ? NUM_PEN_TOGGLE : 0;
	m_wndToolBar.Invalidate();
	m_wndToolBar.GetParentFrame()->RecalcLayout();
}

BOOL CMainFrame::OnQueryNewPalette()
{
	CView* pView = GetActiveView();
	if (pView != NULL)
		return pView->SendMessage(WM_QUERYNEWPALETTE);
	return FALSE;
}

void CMainFrame::OnPaletteChanged(CWnd* pFocusWnd)
{
	CView* pView = GetActiveView();
	if (pView != NULL)
		pView->SendMessage(WM_PALETTECHANGED, (WPARAM)pFocusWnd->GetSafeHwnd());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\multconv.cpp ===
// convert.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "multconv.h"
#include "mswd6_32.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef CONVERTERS
CConverter* CConverter::m_pThis = NULL;
#endif

#define BUFFSIZE 4096

CTrackFile::CTrackFile(CFrameWnd* pWnd) : CFile()
{
    m_nLastPercent = -1;
    m_dwLength = 0;
    m_pFrameWnd = pWnd;
    VERIFY(m_strComplete.LoadString(IDS_COMPLETE));
    VERIFY(m_strWait.LoadString(IDS_PLEASE_WAIT));
    VERIFY(m_strSaving.LoadString(IDS_SAVING));
//  OutputPercent(0);
}

CTrackFile::~CTrackFile()
{
    OutputPercent(100);
    if (m_pFrameWnd != NULL)
        m_pFrameWnd->SetMessageText(AFX_IDS_IDLEMESSAGE);
}

UINT CTrackFile::Read(void FAR* lpBuf, UINT nCount)
{
    UINT n = CFile::Read(lpBuf, nCount);
    if (m_dwLength != 0)
        OutputPercent((int)((GetPosition()*100)/m_dwLength));
    return n;
}

void CTrackFile::Write(const void FAR* lpBuf, UINT nCount)
{
    CFile::Write(lpBuf, nCount);
    OutputString(m_strSaving);
//  if (m_dwLength != 0)
//      OutputPercent((int)((GetPosition()*100)/m_dwLength));
}

void CTrackFile::OutputString(LPCTSTR lpsz)
{
    if (m_pFrameWnd != NULL)
    {
        m_pFrameWnd->SetMessageText(lpsz);
        CWnd* pBarWnd = m_pFrameWnd->GetMessageBar();
        if (pBarWnd != NULL)
            pBarWnd->UpdateWindow();
    }
}

void CTrackFile::OutputPercent(int nPercentComplete)
{
    if (m_pFrameWnd != NULL && m_nLastPercent != nPercentComplete)
    {
        m_nLastPercent = nPercentComplete;
        TCHAR buf[64];
        int n = nPercentComplete;
        wsprintf(buf, (n==100) ? m_strWait : m_strComplete, n);
        OutputString(buf);
    }
}

COEMFile::COEMFile(CFrameWnd* pWnd) : CTrackFile(pWnd)
{
}

UINT COEMFile::Read(void FAR* lpBuf, UINT nCount)
{
    UINT n = CTrackFile::Read(lpBuf, nCount);
    OemToCharBuffA((const char*)lpBuf, (char*)lpBuf, n);
    return n;
}

void COEMFile::Write(const void FAR* lpBuf, UINT nCount)
{
    CharToOemBuffA((const char*)lpBuf, (char*)lpBuf, nCount);
    CTrackFile::Write(lpBuf, nCount);
}

#ifdef CONVERTERS

HGLOBAL CConverter::StringToHGLOBAL(LPCSTR pstr)
{
    HGLOBAL hMem = NULL;
    if (pstr != NULL)
    {
        hMem = GlobalAlloc(GHND, (lstrlenA(pstr)*2)+1);
        char* p = (char*) GlobalLock(hMem);
        ASSERT(p != NULL);
        if (p != NULL)
            lstrcpyA(p, pstr);
        GlobalUnlock(hMem);
    }
    return hMem;
}

CConverter::CConverter(LPCTSTR pszLibName, CFrameWnd* pWnd) : CTrackFile(pWnd)
{
    USES_CONVERSION;
    m_hBuff = NULL;
    m_pBuf = NULL;
    m_nBytesAvail = 0;
    m_nBytesWritten = 0;
    m_nPercent = 0;
    m_hEventFile = NULL;
    m_hEventConv = NULL;
    m_bDone = TRUE;
    m_bConvErr = FALSE;
    m_hFileName = NULL;
    m_bUseOEM = TRUE;

    OFSTRUCT ofs;

    #ifndef _X86_

    //Prevent known alignment exception problems in write converter
    //from crashing the app on some RISC machines

    m_uPrevErrMode = SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT);

    #endif

    m_hLibCnv = LoadLibrary(pszLibName);

    if (NULL != m_hLibCnv)
    {
        LoadFunctions();
        ASSERT(m_pInitConverter != NULL);
        if (m_pInitConverter != NULL)
        {
         //
         // For the current converters, you have to pass a *static*
         // string to InitConverter32
         //

            VERIFY(m_pInitConverter(AfxGetMainWnd()->GetSafeHwnd(), "WORDPAD"));
        }

        if (m_pRegisterApp != NULL)
        {
            NegotiateForNonOEM();
        }
    }
}

CConverter::~CConverter()
{
    if (!m_bDone) // converter thread hasn't exited
    {
        m_bDone = TRUE;

        if (!m_bForeignToRtf)
            WaitForConverter();

        m_nBytesAvail = 0;
        VERIFY(ResetEvent(m_hEventFile));
        m_nBytesAvail = 0;
        SetEvent(m_hEventConv);
        WaitForConverter();// wait for DoConversion exit
        VERIFY(ResetEvent(m_hEventFile));
    }

    if (m_hEventFile != NULL)
        VERIFY(CloseHandle(m_hEventFile));
    if (m_hEventConv != NULL)
        VERIFY(CloseHandle(m_hEventConv));
    if (m_hLibCnv != NULL)
        FreeLibrary(m_hLibCnv);
    if (m_hFileName != NULL)
        GlobalFree(m_hFileName);

    #ifndef _X86_

    //Reset error mode to what it was before we changed it in
    //the constructor

    SetErrorMode(m_uPrevErrMode);

    #endif
}

void CConverter::WaitForConverter()
{
    // while event not signalled -- process messages
    while (MsgWaitForMultipleObjects(1, &m_hEventFile, FALSE, INFINITE,
        QS_SENDMESSAGE) != WAIT_OBJECT_0)
    {
        MSG msg;
        PeekMessage(&msg, 0, 0, 0, PM_NOREMOVE);
    }
}

void CConverter::WaitForBuffer()
{
    // while event not signalled -- process messages
    while (MsgWaitForMultipleObjects(1, &m_hEventConv, FALSE, INFINITE,
        QS_SENDMESSAGE) != WAIT_OBJECT_0)
    {
        MSG msg;
        PeekMessage(&msg, 0, 0, 0, PM_NOREMOVE);
    }
}

UINT AFX_CDECL CConverter::ConverterThread(LPVOID)  // AFX_CDECL added by t-stefb
{
    ASSERT(m_pThis != NULL);

    HRESULT hRes = OleInitialize(NULL);
    ASSERT(hRes == S_OK || hRes == S_FALSE);
    m_pThis->DoConversion();
    OleUninitialize();

    return 0;
}

BOOL CConverter::IsFormatCorrect(LPCTSTR pszFileName)
{
    USES_CONVERSION;
    int nRet;
    if (m_hLibCnv == NULL || m_pIsFormatCorrect == NULL)
        return FALSE;

    char buf[_MAX_PATH];
    strcpy(buf, T2CA(pszFileName));

    if (m_bUseOEM)
        CharToOemA(buf, buf);

    HGLOBAL hFileName = StringToHGLOBAL(buf);
    HGLOBAL hDesc = GlobalAlloc(GHND, 256);
    ASSERT(hDesc != NULL);
    nRet = m_pIsFormatCorrect(hFileName, hDesc);
    GlobalFree(hDesc);
    GlobalFree(hFileName);
    return (nRet == 1) ? TRUE : FALSE;
}

// static callback function
int CALLBACK CConverter::WriteOutStatic(int cch, int nPercentComplete)
{
    ASSERT(m_pThis != NULL);
    return m_pThis->WriteOut(cch, nPercentComplete);
}

int CALLBACK CConverter::WriteOut(int cch, int nPercentComplete)
{
    ASSERT(m_hBuff != NULL);
    m_nPercent = nPercentComplete;
    if (m_hBuff == NULL)
        return -9;

    //
    // If m_bDone is TRUE that means the richedit control has stopped
    // streaming in text and is trying to destroy the CConverter object but
    // the converter still has more data to give
    //

    if (m_bDone)
    {
        ASSERT(!"Richedit control stopped streaming prematurely");
        AfxMessageBox(IDS_CONVERTER_ABORTED);
        return -9;
    }

    if (cch != 0)
    {
        WaitForBuffer();
        VERIFY(ResetEvent(m_hEventConv));
        m_nBytesAvail = cch;
        SetEvent(m_hEventFile);
        WaitForBuffer();
    }
    return 0; //everything OK
}

int CALLBACK CConverter::ReadInStatic(int /*flags*/, int nPercentComplete)
{
    ASSERT(m_pThis != NULL);
    return m_pThis->ReadIn(nPercentComplete);
}

int CALLBACK CConverter::ReadIn(int /*nPercentComplete*/)
{
    ASSERT(m_hBuff != NULL);
    if (m_hBuff == NULL)
        return -8;

    SetEvent(m_hEventFile);
    WaitForBuffer();
    VERIFY(ResetEvent(m_hEventConv));

    return m_nBytesAvail;
}

BOOL CConverter::DoConversion()
{
    USES_CONVERSION;
    m_nLastPercent = -1;
//  m_dwLength = 0; // prevent Read/Write from displaying
    m_nPercent = 0;

    ASSERT(m_hBuff != NULL);
    ASSERT(m_pThis != NULL);
    HGLOBAL hDesc = StringToHGLOBAL("");
    HGLOBAL hSubset = StringToHGLOBAL("");

    int nRet = -1;
    if (m_bForeignToRtf && NULL != m_pForeignToRtf)
    {
        ASSERT(m_pForeignToRtf != NULL);
        ASSERT(m_hFileName != NULL);
        nRet = m_pForeignToRtf(m_hFileName, NULL, m_hBuff, hDesc, hSubset,
            (LPFNOUT)WriteOutStatic);
        // wait for next CConverter::Read to come through
        WaitForBuffer();
        VERIFY(ResetEvent(m_hEventConv));
    }
    else if (!m_bForeignToRtf && NULL != m_pRtfToForeign)
    {
        ASSERT(m_pRtfToForeign != NULL);
        ASSERT(m_hFileName != NULL);
        nRet = m_pRtfToForeign(m_hFileName, NULL, m_hBuff, hDesc,
            (LPFNIN)ReadInStatic);
        // don't need to wait for m_hEventConv
    }

    GlobalFree(hDesc);
    GlobalFree(hSubset);
    if (m_pBuf != NULL)
        GlobalUnlock(m_hBuff);
    GlobalFree(m_hBuff);

    if (nRet != 0)
        m_bConvErr = TRUE;

    m_bDone = TRUE;
    m_nPercent = 100;
    m_nLastPercent = -1;

    SetEvent(m_hEventFile);

    return (nRet == 0);
}

void CConverter::LoadFunctions()
{
    m_pInitConverter = (PINITCONVERTER)GetProcAddress(m_hLibCnv, "InitConverter32");
    m_pIsFormatCorrect = (PISFORMATCORRECT)GetProcAddress(m_hLibCnv, "IsFormatCorrect32");
    m_pForeignToRtf = (PFOREIGNTORTF)GetProcAddress(m_hLibCnv, "ForeignToRtf32");
    m_pRtfToForeign = (PRTFTOFOREIGN)GetProcAddress(m_hLibCnv, "RtfToForeign32");
    m_pRegisterApp = (PREGISTERAPP) GetProcAddress(m_hLibCnv, "RegisterApp");
}
#endif

///////////////////////////////////////////////////////////////////////////////

BOOL CConverter::Open(LPCTSTR pszFileName, UINT nOpenFlags,
    CFileException* pException)
{
    USES_CONVERSION;

    char buf[_MAX_PATH * 2];    // * 2 for DBCS
    strncpy(buf, T2CA(pszFileName), _MAX_PATH * 2);

    // let's make sure we could do what is wanted directly even though we aren't
    m_bCloseOnDelete = FALSE;
    m_hFile = (UINT)hFileNull;

    BOOL bOpen = CFile::Open(pszFileName, nOpenFlags, pException);
    CFile::Close();
    if (!bOpen)
        return FALSE;

    m_bForeignToRtf = !(nOpenFlags & (CFile::modeReadWrite | CFile::modeWrite));

    // check for reading empty file
    if (m_bForeignToRtf)
    {
        CFileStatus _stat;
        if (CFile::GetStatus(pszFileName, _stat) && _stat.m_size == 0)
            return TRUE;
    }

    //set security attributes to inherit handle
    SECURITY_ATTRIBUTES sa = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};
    //create the events
    m_hEventFile = CreateEvent(&sa, TRUE, FALSE, NULL);
    m_hEventConv = CreateEvent(&sa, TRUE, FALSE, NULL);
    //create the converter thread and create the events

    if (m_bUseOEM)
        CharToOemA(buf, buf);

    ASSERT(m_hFileName == NULL);
    m_hFileName = StringToHGLOBAL(buf);

    m_pThis = this;
    m_bDone = FALSE;
    m_hBuff = GlobalAlloc(GHND, BUFFSIZE);
    ASSERT(m_hBuff != NULL);

    AfxBeginThread(ConverterThread, this, THREAD_PRIORITY_NORMAL, 0, 0, &sa);

    return TRUE;
}

// m_hEventConv -- the main thread signals this event when ready for more data
// m_hEventFile -- the converter signals this event when data is ready

UINT CConverter::Read(void FAR* lpBuf, UINT nCount)
{
    ASSERT(m_bForeignToRtf);
    if (m_bDone)
        return 0;
    // if converter is done
    int cch = nCount;
    BYTE* pBuf = (BYTE*)lpBuf;
    while (cch != 0)
    {
        if (m_nBytesAvail == 0)
        {
            if (m_pBuf != NULL)
                GlobalUnlock(m_hBuff);
            m_pBuf = NULL;
            SetEvent(m_hEventConv);
            WaitForConverter();
            VERIFY(ResetEvent(m_hEventFile));
            if (m_bConvErr)
                AfxThrowFileException(CFileException::generic);
            if (m_bDone)
                return nCount - cch;
            m_pBuf = (BYTE*)GlobalLock(m_hBuff);
            ASSERT(m_pBuf != NULL);
        }
        int nBytes = min(cch, m_nBytesAvail);
        memcpy(pBuf, m_pBuf, nBytes);
        pBuf += nBytes;
        m_pBuf += nBytes;
        m_nBytesAvail -= nBytes;
        cch -= nBytes;
        OutputPercent(m_nPercent);
    }
    return nCount - cch;
}

void CConverter::Write(const void FAR* lpBuf, UINT nCount)
{
    ASSERT(!m_bForeignToRtf);

    m_nBytesWritten += nCount;
    while (nCount != 0)
    {
        WaitForConverter();
        VERIFY(ResetEvent(m_hEventFile));
        if (m_bConvErr)
            AfxThrowFileException(CFileException::generic);
        m_nBytesAvail = min(nCount, BUFFSIZE);
        nCount -= m_nBytesAvail;
        BYTE* pBuf = (BYTE*)GlobalLock(m_hBuff);
        ASSERT(pBuf != NULL);
        memcpy(pBuf, lpBuf, m_nBytesAvail);
        GlobalUnlock(m_hBuff);
        SetEvent(m_hEventConv);
    }
    OutputString(m_strSaving);
}

LONG CConverter::Seek(LONG lOff, UINT nFrom)
{
    if (lOff != 0 && nFrom != current)
        AfxThrowNotSupportedException();
    return 0;
}

DWORD CConverter::GetPosition() const
{
    return 0;
}

void CConverter::Flush()
{
}

void CConverter::Close()
{
    if (!m_bDone) // converter thread hasn't exited
    {
        m_bDone = TRUE;

        if (!m_bForeignToRtf)
            WaitForConverter();

        m_nBytesAvail = 0;
        VERIFY(ResetEvent(m_hEventFile));
        m_nBytesAvail = 0;
        SetEvent(m_hEventConv);
        WaitForConverter();// wait for DoConversion exit
        VERIFY(ResetEvent(m_hEventFile));
    }

    if (m_bConvErr)
        AfxThrowFileException(CFileException::generic);
}

void CConverter::Abort()
{
}

DWORD CConverter::GetLength() const
{
    ASSERT_VALID(this);
    return 1;
}

CFile* CConverter::Duplicate() const
{
    AfxThrowNotSupportedException();
    return NULL;
}

void CConverter::LockRange(DWORD, DWORD)
{
    AfxThrowNotSupportedException();
}

void CConverter::UnlockRange(DWORD, DWORD)
{
    AfxThrowNotSupportedException();
}

void CConverter::SetLength(DWORD)
{
    AfxThrowNotSupportedException();
}



//+--------------------------------------------------------------------------
//
//  Method:     CConverter::NegotiateForNonOEM
//
//  Synopsis:   Try to tell the converter not to expect OEM filenames
//
//  Parameters: None
//
//  Returns:    void
//
//  Notes:      The converter's RegisterApp function will return a handle
//              containing it's preferences (what it supports).  The 
//              data structure is a 16-bit size and then a sequence of
//              records.  For each record the first byte is the size, the
//              second is the "opcode", and then some variable-length opcode
//              specific data.  All sizes are inclusive.
//
//---------------------------------------------------------------------------

void CConverter::NegotiateForNonOEM()
{
    ASSERT(NULL != m_pRegisterApp);

    HGLOBAL     hPrefs;
    BYTE       *pPrefs;
    __int16     cbPrefs;

    //
    // Tell the converter we don't want to use OEM
    //

    hPrefs = (*m_pRegisterApp)(fRegAppSupportNonOem, NULL);

    if (NULL == hPrefs)
        return;

    pPrefs = (BYTE *) GlobalLock(hPrefs);

    if (NULL == pPrefs)
    {
        ASSERT(!"GlobalLock failed");
        GlobalFree(hPrefs);
        return;
    }

    //
    // Parse the returned structure looking for a RegAppOpcodeCharset opcode.
    // The argument for this opcode should be either ANSI_CHARSET or 
    // OEM_CHARSET.  If its ANSI_CHARSET then we can talk Ansi otherwise were
    // stuck with OEM.
    //

    cbPrefs = (__int16) ((* (__int16 *) pPrefs) - sizeof(cbPrefs));
    pPrefs += sizeof(cbPrefs);

    while (cbPrefs > 0)
    {
        if (RegAppOpcodeCharset == pPrefs[1])
        {
            ASSERT(ANSI_CHARSET == pPrefs[2] || OEM_CHARSET == pPrefs[2]);

            m_bUseOEM = (OEM_CHARSET == pPrefs[2]);
            break;
        }
        else
        {
            if (pPrefs[0] <= 0)
            {
                ASSERT(!"RegisterApp is returning bogus data");
                break;
            }

            cbPrefs = (__int16) (cbPrefs - pPrefs[0]);
            pPrefs += pPrefs[0];
        }
    }

    GlobalUnlock(pPrefs);
    GlobalFree(hPrefs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\mainfrm.h ===
// mainfrm.h : interface of the CMainFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "formatba.h"
#include "ruler.h"

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:
	HICON m_hIconDoc;
	HICON m_hIconText;
	HICON m_hIconWrite;
	HICON GetIcon(int nDocType);

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual void ActivateFrame(int nCmdShow = -1);
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

public:
	CToolBar	m_wndToolBar;
	CStatusBar  m_wndStatusBar;
	CFormatBar	m_wndFormatBar;
	CRulerBar	m_wndRulerBar;
protected:  // control bar embedded members
	BOOL CreateToolBar();
	BOOL CreateFormatBar();
	BOOL CreateStatusBar();
	BOOL CreateRulerBar();
// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSysColorChange();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnMove(int x, int y);
	afx_msg void OnHelpFinder();
	afx_msg void OnDropFiles(HDROP hDropInfo);
	afx_msg void OnCharColor();
	afx_msg void OnPenToggle();
	afx_msg void OnFontChange();
	afx_msg BOOL OnQueryNewPalette();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
	//}}AFX_MSG
	afx_msg LONG OnBarState(UINT wParam, LONG lParam);
	afx_msg LONG OnOpenMsg(UINT wParam, LONG lParam);
   afx_msg LONG OnOLEHelpMsg(UINT wParam, LONG lParam);
	DECLARE_MESSAGE_MAP()
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\optionsh.cpp ===
// optionsh.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "unitspag.h"
#include "docopt.h"
#include "optionsh.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COptionSheet

COptionSheet::COptionSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	: CCSPropertySheet(nIDCaption, pParentWnd, iSelectPage),
	pageText(IDS_TEXT_OPTIONS), pageRTF(IDS_RTF_OPTIONS),
	pageWord(IDS_WORD6_OPTIONS), pageWrite(IDS_WRITE_OPTIONS),
	pageEmbedded()
{
	units.m_nUnits = theApp.GetUnits();
	units.m_bWordSel = theApp.m_bWordSel;
	pageText.m_nWordWrap = theApp.GetDocOptions(RD_TEXT).m_nWordWrap;
	pageRTF.m_nWordWrap = theApp.GetDocOptions(RD_RICHTEXT).m_nWordWrap;
	pageWord.m_nWordWrap = theApp.GetDocOptions(RD_WINWORD6).m_nWordWrap;
	pageWrite.m_nWordWrap = theApp.GetDocOptions(RD_WRITE).m_nWordWrap;
	pageEmbedded.m_nWordWrap = theApp.GetDocOptions(RD_EMBEDDED).m_nWordWrap;
	SetPageButtons(pageText, theApp.GetDocOptions(RD_TEXT));
	SetPageButtons(pageRTF, theApp.GetDocOptions(RD_RICHTEXT));
	SetPageButtons(pageWord, theApp.GetDocOptions(RD_WINWORD6));
	SetPageButtons(pageWrite, theApp.GetDocOptions(RD_WRITE));
	SetPageButtons(pageEmbedded, theApp.GetDocOptions(RD_EMBEDDED));
	SetPageButtons(pageEmbedded, theApp.GetDocOptions(RD_EMBEDDED), FALSE);
	AddPage(&units);
	AddPage(&pageText);
	AddPage(&pageRTF);
	AddPage(&pageWord);
	AddPage(&pageWrite);
	AddPage(&pageEmbedded);
}

void COptionSheet::SetPageButtons(CDocOptPage& page, CDocOptions& options, BOOL bPrimary)
{
    CDocOptions::CBarState& barstate = options.GetBarState(bPrimary);

    page.m_bFormatBar = barstate.m_bFormatBar;
    page.m_bRulerBar  = barstate.m_bRulerBar;
    page.m_bToolBar   = barstate.m_bToolBar;
    page.m_bStatusBar = barstate.m_bStatusBar;
}

void COptionSheet::SetState(CDocOptPage& page, CDocOptions& options, BOOL bPrimary)
{
    CDocOptions::CBarState& barstate = options.GetBarState(bPrimary);
    CDockState&             ds = options.GetDockState(bPrimary);

    barstate.m_bFormatBar = page.m_bFormatBar;
    barstate.m_bRulerBar  = page.m_bRulerBar;
    barstate.m_bToolBar   = page.m_bToolBar;
    barstate.m_bStatusBar = page.m_bStatusBar;

    for (int i = 0;i < ds.m_arrBarInfo.GetSize(); i++)
	{
		CControlBarInfo* pInfo = (CControlBarInfo*)ds.m_arrBarInfo[i];
		ASSERT(pInfo != NULL);
		switch (pInfo->m_nBarID)
		{
			case ID_VIEW_FORMATBAR:
				pInfo->m_bVisible = page.m_bFormatBar;
				break;
			case ID_VIEW_RULER:
				pInfo->m_bVisible = page.m_bRulerBar;
				break;
			case ID_VIEW_TOOLBAR:
				pInfo->m_bVisible = page.m_bToolBar;
				break;
			case ID_VIEW_STATUS_BAR:
				pInfo->m_bVisible = page.m_bStatusBar;
				break;
		}
	}
}

LONG COptionSheet::OnHelp(UINT, LONG)
{
    return 0;
}

LONG COptionSheet::OnHelpContextMenu(UINT, LONG)
{
    return 0;
}

BEGIN_MESSAGE_MAP(COptionSheet, CCSPropertySheet)
	//{{AFX_MSG_MAP(COptionSheet)
	ON_WM_CREATE()
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnHelpContextMenu)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// COptionSheet message handlers

int COptionSheet::DoModal()
{
   //
   // Turn apply button off
   //

   m_psh.dwFlags |= PSH_NOAPPLYNOW ;

	int nRes = CCSPropertySheet::DoModal();
	if (nRes == IDOK)
	{
		SetState(pageText, theApp.GetDocOptions(RD_TEXT));
		SetState(pageRTF, theApp.GetDocOptions(RD_RICHTEXT));
		SetState(pageWord, theApp.GetDocOptions(RD_WINWORD6));
		SetState(pageWrite, theApp.GetDocOptions(RD_WRITE));
		SetState(pageEmbedded, theApp.GetDocOptions(RD_EMBEDDED));
		SetState(pageEmbedded, theApp.GetDocOptions(RD_EMBEDDED), FALSE);
		theApp.SetUnits(units.m_nUnits);
		theApp.m_bWordSel = units.m_bWordSel;
		theApp.GetDocOptions(RD_TEXT).m_nWordWrap = pageText.m_nWordWrap;
		theApp.GetDocOptions(RD_RICHTEXT).m_nWordWrap = pageRTF.m_nWordWrap;
		theApp.GetDocOptions(RD_WINWORD6).m_nWordWrap = pageWord.m_nWordWrap;
		theApp.GetDocOptions(RD_WRITE).m_nWordWrap = pageWrite.m_nWordWrap;
		theApp.GetDocOptions(RD_EMBEDDED).m_nWordWrap = pageEmbedded.m_nWordWrap;
	}
	return nRes;
}

/////////////////////////////////////////////////////////////////////////////
// COptionSheet message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\options.h ===
// options.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CUnit
{
public:
	int m_nTPU;
	int m_nSmallDiv;	// small divisions - small line displayed
	int m_nMediumDiv;	// medium divisions - large line displayed
	int m_nLargeDiv;	// large divisions - numbers displayed
	int m_nMinMove;		// minimum tracking movements
	UINT m_nAbbrevID;
	BOOL m_bSpaceAbbrev; // put space before abbreviation
	CString m_strAbbrev;// cm, pt, pi, ", in, inch, inches

	CUnit() {}
	CUnit(int nTPU, int nSmallDiv, int nMediumDiv, int nLargeDiv, 
		int nMinMove, UINT nAbbrevID, BOOL bSpaceAbbrev);
	const CUnit& operator=(const CUnit& unit);
};

class CDocOptions
{
public:
	CDocOptions(int nDefWrap) {m_nDefWrap = nDefWrap;}
	CDockState m_ds1;
	CDockState m_ds2;

	int m_nWordWrap;
	int m_nDefWrap;

    struct CBarState
    {
        BOOL m_bRulerBar;
        BOOL m_bStatusBar;
        BOOL m_bToolBar;
        BOOL m_bFormatBar;
    }
    m_barstate[2];

	void SaveOptions(LPCTSTR lpsz);
	void LoadOptions(LPCTSTR lpsz);
	void SaveDockState(CDockState& ds, LPCTSTR lpszProfileName, 
		LPCTSTR lpszLayout);
	void LoadDockState(CDockState& ds, LPCTSTR lpszProfileName, 
		LPCTSTR lpszLayout);
	CDockState& GetDockState(BOOL bPrimary) {return (bPrimary) ? m_ds1 : m_ds2;}
    CBarState & GetBarState(BOOL bPrimary) {return bPrimary ? m_barstate[0] : m_barstate[1];}
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\srvritem.h ===
// srvritem.h : interface of the CWordPadSrvrItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CWordPadDoc;
class CWordPadView;

class CEmbeddedItem : public COleServerItem
{
	DECLARE_DYNAMIC(CEmbeddedItem)

// Constructors
public:
	CEmbeddedItem(CWordPadDoc* pContainerDoc, int nBeg = 0, int nEnd = -1);

// Attributes
	int m_nBeg;
	int m_nEnd;
	LPDATAOBJECT m_lpRichDataObj;
	CWordPadDoc* GetDocument() const
		{ return (CWordPadDoc*) COleServerItem::GetDocument(); }
	CWordPadView* GetView() const;

// Implementation
public:
	BOOL OnDrawEx(CDC* pDC, CSize& rSize, BOOL bOutput);
	virtual BOOL OnDraw(CDC* pDC, CSize& rSize);
	virtual BOOL OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize);

protected:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wordpad.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\pageset.cpp ===
// pageset.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "resource.h"
#include "pageset.h"
#include "ruler.h"
#include "ddxm.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPageSetupDlg dialog

const DWORD CPageSetupDlg::m_nHelpIDs[] = 
{
	IDC_EDIT_TM, IDH_WORDPAD_TOPMARGIN,
	IDC_EDIT_BM, IDH_WORDPAD_BOTTOMMARGIN,
	IDC_EDIT_LM, IDH_WORDPAD_LEFTMARGIN,
	IDC_EDIT_RM, IDH_WORDPAD_RIGHTMARGIN,
	IDC_BOX, IDH_COMM_GROUPBOX,
	0, 0
};

CPageSetupDlg::CPageSetupDlg(CWnd* pParent /*=NULL*/)
	: CCSDialog(CPageSetupDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPageSetupDlg)
	m_nTopMargin = 0;
	m_nRightMargin = 0;
	m_nLeftMargin = 0;
	m_nBottomMargin = 0;
	//}}AFX_DATA_INIT
}

void CPageSetupDlg::DoDataExchange(CDataExchange* pDX)
{
	CCSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPageSetupDlg)
	DDX_Twips(pDX, IDC_EDIT_TM, m_nTopMargin);
	DDV_MinMaxTwips(pDX, m_nTopMargin, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_RM, m_nRightMargin);
	DDV_MinMaxTwips(pDX, m_nRightMargin, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_LM, m_nLeftMargin);
	DDV_MinMaxTwips(pDX, m_nLeftMargin, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_BM, m_nBottomMargin);
	DDV_MinMaxTwips(pDX, m_nBottomMargin, -31680, 31680);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPageSetupDlg, CCSDialog)
	//{{AFX_MSG_MAP(CPageSetupDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPageSetupDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\stdafx2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// STDAFX.H is the header that includes the standard includes that are used
//  for most of the project.  These are compiled into a pre-compiled header

// turn off warnings for /W4 (just for MFC implementation)
#ifndef ALL_WARNINGS
#pragma warning(disable: 4073)  // disable warning about using init_seg
#ifdef _MAC
#pragma warning(disable: 4121)  // disable (incorrect?) warning about packing of MachineLocation in OSUtils.h
#endif
#endif

// MFC inline constructors (including compiler generated) can get deep
#pragma inline_depth(16)

// override default values for data import/export when building MFC DLLs
#ifdef _AFX_CORE_IMPL
	#define AFX_CORE_DATA   AFX_DATA_EXPORT
	#define AFX_CORE_DATADEF
#endif

#ifdef _AFX_OLE_IMPL
	#define AFX_OLE_DATA    AFX_DATA_EXPORT
	#define AFX_OLE_DATADEF
#endif

#ifdef _AFX_DB_IMPL
	#define AFX_DB_DATA     AFX_DATA_EXPORT
	#define AFX_DB_DATADEF
#endif

#ifdef _AFX_NET_IMPL
	#define AFX_NET_DATA    AFX_DATA_EXPORT
	#define AFX_NET_DATADEF
#endif

#ifndef _AFX_NOFORCE_LIBS
#define _AFX_NOFORCE_LIBS
#endif

#define _AFX_FULLTYPEINFO
#define VC_EXTRALEAN
#define NO_ANSIUNI_ONLY

// include these first so that protected structures in winwlm.h are declared
#ifdef _MAC
#define SystemSevenOrLater 1
#include <macname1.h>
#include <Types.h>
#include <QuickDraw.h>
#include <AppleEvents.h>
#include <macname2.h>
#endif

// core headers
#include "afx.h"
#include "afxplex_.h"
#include "afxcoll.h"

// public headers
#include "afxwin.h"

//
// MFC 4.2 hardcodes _RICHEDIT_VER to 0x0100 in afxwin.h.  This prevents
// richedit.h from enabling any richedit 2.0 features.
//

#ifdef _RICHEDIT_VER
#if _RICHEDIT_VER < 0x0200
#undef _RICHEDIT_VER
#define _RICHEDIT_VER 0x0200
#endif
#endif

#ifndef _AFX_ENABLE_INLINES
#define _AFX_ENABLE_INLINES
#endif

#define _AFXCMN2_INLINE     inline 
#define _AFXDLGS2_INLINE    inline
#define _AFXRICH2_INLINE    inline

#include "afxdlgs.h"
#include "afxdlgs2.h"
#include "afxext.h"
#ifndef _AFX_NO_OLE_SUPPORT
	#ifndef _OLE2_H_
		#include <ole2.h>
	#endif

#include <winspool.h>

#ifdef _MAC
	// include OLE dialog/helper APIs
	#include <ole2ui.h>
#else
	// include OLE dialog/helper APIs
	#ifndef _OLEDLG_H_
		#include <oledlg.h>
	#endif
#endif

	#include <winreg.h>
		#include "afxcom_.h"
//	#include "oleimpl.h"
	#include "afxole.h"
#ifndef _MAC
	#include "afxdocob.h"
#endif

#ifndef _AFX_NO_DAO_SUPPORT
	#include "afxdao.h"
#endif

	#include "afxodlgs.h"
#endif

#ifndef _AFX_NO_OCX_SUPPORT
	#include "afxctl.h"
#endif
#ifndef _AFX_NO_DB_SUPPORT
	#include "afxdb.h"
#endif
#ifndef _AFX_NO_SYNC_SUPPORT
	#include "afxmt.h"
#endif
#ifndef _AFX_NO_INET_SUPPORT
	#include "afxinet.h"
#endif

// private headers as well
#include "afxpriv.h"
#include "afximpl2.h"
//#include "winhand_.h"
#ifndef _AFX_NO_OLE_SUPPORT
	#include "oleimpl3.h"
#endif
#ifndef _AFX_NO_OCX_SUPPORT
//	#include "ctlimpl.h"
#endif
#ifndef _AFX_NO_DB_SUPPORT
//	#include "dbimpl.h"
#endif
#ifndef _AFX_NO_DAO_SUPPORT
//	#include "daoimpl.h"
#endif
#ifndef _AFX_NO_SOCKET_SUPPORT
	#ifndef _WINSOCKAPI_
//		#include <winsock.h>
	#endif
//	#include "sockimpl.h"
//	#include "afxsock.h"
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
//	#include "commimpl.h"
	#include "afxcmn.h"
	#include "afxcview.h"
#endif
	#include "afxrich2.h"

#include <winreg.h>
#include <winnls.h>
#include <stddef.h>
#include <limits.h>
#include <malloc.h>
#include <new.h>
#ifndef _AFX_OLD_EXCEPTIONS
#include <eh.h>     // for set_terminate
#endif

#undef AfxWndProc

// implementation uses _AFX_PACKING as well
#ifdef _AFX_PACKING
#ifndef ALL_WARNINGS
#pragma warning(disable: 4103)
#endif
#pragma pack(_AFX_PACKING)
#endif

// special exception handling just for MFC library implementation
#ifndef _AFX_OLD_EXCEPTIONS

// MFC does not rely on auto-delete semantics of the TRY..CATCH macros,
//  therefore those macros are mapped to something closer to the native
//  C++ exception handling mechanism when building MFC itself.

#undef TRY
#define TRY { try {

#undef CATCH
#define CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); UNUSED(e);

#undef AND_CATCH
#define AND_CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); UNUSED(e);

#undef CATCH_ALL
#define CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); UNUSED(e);

#undef AND_CATCH_ALL
#define AND_CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); UNUSED(e);

#undef END_TRY
#define END_TRY } catch (CException* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); e->Delete(); } }

#undef THROW_LAST
#define THROW_LAST() throw

// Because of the above definitions of TRY...CATCH it is necessary to
//  explicitly delete exception objects at the catch site.

#define DELETE_EXCEPTION(e) do { e->Delete(); } while (0)
#define NO_CPP_EXCEPTION(expr)

#else   //!_AFX_OLD_EXCEPTIONS

// In this case, the TRY..CATCH macros provide auto-delete semantics, so
//  it is not necessary to explicitly delete exception objects at the catch site.

#define DELETE_EXCEPTION(e)
#define NO_CPP_EXCEPTION(expr) expr

#endif  //_AFX_OLD_EXCEPTIONS


#include <afxcmn2.h>
#include <afxrich2.h>

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\optionsh.h ===
// optionsh.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// COptionSheet

class COptionSheet : public CCSPropertySheet
{
// Construction
public:
	COptionSheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:
	CUnitsPage units;
	CDocOptPage pageText;
	CDocOptPage pageRTF;
	CDocOptPage pageWord;
	CDocOptPage pageWrite;
	CEmbeddedOptPage pageEmbedded;

// Operations
public:
	int DoModal();
	void SetPageButtons(CDocOptPage& page, CDocOptions& options, BOOL bPrimary = TRUE);
	void SetState(CDocOptPage& page, CDocOptions& optiosn, BOOL bPrimary = TRUE);

// Overrides
    virtual LONG OnHelp(UINT, LONG lParam);
    virtual LONG OnHelpContextMenu(UINT, LONG lParam);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COptionSheet)
	//}}AFX_VIRTUAL

// Implementation
public:

	// Generated message map functions
protected:
	//{{AFX_MSG(COptionSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\strings.cpp ===
// strings.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "strings.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

const TCHAR szWordPadClass[] = _T("WordPadClass");
const TCHAR szLayout1[] = _T("Layout2");
const TCHAR szLayout2[] = _T("LayoutAux2");
const TCHAR szRegKey[] = _T("Microsoft\\Windows\\CurrentVersion\\Applets");

const TCHAR szTextSection[] = _T("Text");
const TCHAR szRTFSection[] = _T("RTF");
const TCHAR szWordSection[] = _T("Word6");
const TCHAR szWriteSection[] =_T("Write");
const TCHAR szIPSection[] = _T("IP");
const TCHAR szWrap[] = _T("Wrap");
const TCHAR szPageMargin[] = _T("PageMargin");

const TCHAR szSection[] = _T("Options");
const TCHAR szWordSel[] = _T("WordSel");
const TCHAR szUnits[] = _T("Units");
const TCHAR szFrameRect[] = _T("FrameRect");
const TCHAR szMaximized[] = _T("Maximized");

const TCHAR szSumInfo[] = _T("\005SummaryInformation");
const TCHAR szContents[] = _T("Contents");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\strings.h ===
// strings.h : defines all extern const strings
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

extern const TCHAR szWordPadClass[];
extern const TCHAR szLayout1[];
extern const TCHAR szLayout2[];
extern const TCHAR szRegKey[];

extern const TCHAR szTextSection[];
extern const TCHAR szRTFSection[];
extern const TCHAR szWordSection[];
extern const TCHAR szWriteSection[];
extern const TCHAR szIPSection[];
extern const TCHAR szWrap[];
extern const TCHAR szPageMargin[];

extern const TCHAR szSection[];
extern const TCHAR szWordSel[];
extern const TCHAR szUnits[];
extern const TCHAR szFrameRect[];
extern const TCHAR szMaximized[];
extern const TCHAR szDeleteTemp[];

extern const TCHAR szSumInfo[];
extern const TCHAR szContents[];

extern TCHAR szWordConverter[];
extern TCHAR szWriteConverter[];
extern TCHAR szWord97Converter[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\unitspag.h ===
// unitspag.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CUnitsPage dialog

class CUnitsPage : public CCSPropertyPage
{
// Construction
public:
	CUnitsPage();   // standard constructor

// Dialog Data
	//{{AFX_DATA(CUnitsPage)
	enum { IDD = IDD_OPTIONS_UNITS };
	int		m_nUnits;
	BOOL	m_bWordSel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CUnitsPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}

	// Generated message map functions
	//{{AFX_MSG(CUnitsPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\ruler.h ===
// riched.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __RULER_H__
#define __RULER_H__

class CWordPadView;
class CWordPadDoc;
class CRulerBar;

// ruler items include left margin, right margin, indent, and tabs

// horz positions in twips -- necessary to avoid rounding errors
// vertical position in pixels
class CRulerItem
{
public:
    CRulerItem(UINT nBitmapID = 0);
    ~CRulerItem();
    virtual BOOL HitTestPix(CPoint pt) { return GetHitRectPix().PtInRect(pt); }
    virtual void Draw(CDC& dc);
    virtual void SetHorzPosTwips(int nXPos);
    virtual void TrackHorzPosTwips(int nXPos, BOOL bOnRuler = TRUE);
    virtual void SetVertPos(int nYPos) { m_nYPosPix = nYPos; }
    virtual void SetAlignment(int nAlign) {m_nAlignment = nAlign;}
    virtual void SetRuler(CRulerBar* pRuler) {m_pRuler = pRuler;}
    virtual void SetBounds(int nMin, int nMax) { m_nMin = nMin; m_nMax = nMax; }
    int GetMin() { return m_nMin;}
    int GetMax() { return m_nMax;}
    void Invalidate();
    int GetVertPosPix() { return m_nYPosPix;}
    int GetHorzPosTwips() { return m_nXPosTwips;}
    int GetHorzPosPix();
    CRect GetHitRectPix();
    void DrawFocusLine();
    void SetTrack(BOOL b);

    HBITMAP m_hbm;
    HBITMAP m_hbmMask;
    CSize m_size;   // size of item in pixels

// Operations
    BOOL LoadMaskedBitmap(LPCTSTR lpszResourceName);

protected:
    int m_nYPosPix;
    int m_nXPosTwips;
    int m_nAlignment;
    BOOL m_bTrack;
    CRulerBar* m_pRuler;
    CRect m_rcTrack;
    CDC* m_pDC; // dc used for drawing tracking line
    int m_nMin, m_nMax;
};

class CComboRulerItem : public CRulerItem
{ 
public:
    CComboRulerItem(UINT nBitmapID1, UINT nBitmapID2, CRulerItem& item);
    virtual BOOL HitTestPix(CPoint pt);
    virtual void Draw(CDC& dc);
    virtual void SetHorzPosTwips(int nXPos);
    virtual void TrackHorzPosTwips(int nXPos, BOOL bOnRuler = TRUE);
    virtual void SetVertPos(int nYPos);
    virtual void SetAlignment(int nAlign);
    virtual void SetRuler(CRulerBar* pRuler);
    virtual void SetBounds(int nMin, int nMax);
    int GetMin();
    int GetMax();
protected:
    CRulerItem m_secondary;
    CRulerItem& m_link;
    BOOL m_bHitPrimary;
};

class CTabRulerItem : public CRulerItem
{
public:
    CTabRulerItem() { SetAlignment(TA_LEFT); }
    virtual void Draw(CDC& dc) {if (GetHorzPosTwips() != 0) CRulerItem::Draw(dc);}
    virtual void TrackHorzPosTwips(int nXPos, BOOL bOnRuler = TRUE);
    virtual BOOL HitTestPix(CPoint pt) { return (GetHorzPosTwips() != 0) ? CRulerItem::HitTestPix(pt) : FALSE;}
};

/////////////////////////////////////////////////////////////////////////////
// CRulerBar

class CRulerBar : public CControlBar
{
// Construction
public:
    CRulerBar();
    ~CRulerBar();

// Operations
public:
    virtual BOOL Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID);
protected:
    void Update(const PARAFORMAT& pf);
    void Update(CSize sizePaper, const CRect& rectMargins);

// Attributes
public:
    BOOL m_bDeferInProgress;
    CUnit m_unit;
    CRulerItem* m_pSelItem;
    CFont fnt;
    CSize GetBaseUnits();
    CComboRulerItem m_leftmargin;
    CRulerItem m_indent;
    CRulerItem m_rightmargin;
    CRulerItem m_tabItem;
    CTabRulerItem m_pTabItems[MAX_TAB_STOPS];
    CSize m_sizePaper;
    CRect m_rectMargin;
    int PrintWidth() {return m_sizePaper.cx - m_rectMargin.left - 
        m_rectMargin.right;}
    int m_nTabs;
    int m_logx;
    int m_nLinePos;
    int m_nScroll; // in pixels

    CPen penFocusLine;
    CPen penBtnHighLight;
    CPen penBtnShadow;
    CPen penWindowFrame;
    CPen penBtnText;
    CPen penBtnFace;
    CPen penWindowText;
    CPen penWindow;
    CBrush brushWindow;
    CBrush brushBtnFace;

// Implementation
public:
    virtual void DoPaint(CDC* pDC);
    virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
    void ClientToRuler(CPoint& pt) {pt.Offset(-m_cxLeftBorder+m_nScroll, -m_cyTopBorder);}
    void ClientToRuler(CRect& rect) {rect.OffsetRect(-m_cxLeftBorder+m_nScroll, -m_cyTopBorder);}
    void RulerToClient(CPoint& pt) {pt.Offset(m_cxLeftBorder-m_nScroll, m_cyTopBorder);}
    void RulerToClient(CRect& rect) {rect.OffsetRect(m_cxLeftBorder-m_nScroll, m_cyTopBorder);}

    int XTwipsToClient(int nT) {return MulDiv(nT, m_logx, 1440) + m_cxLeftBorder - m_nScroll;}
    int XClientToTwips(int nC) {return MulDiv(nC - m_cxLeftBorder + m_nScroll, 1440, m_logx);}

    int XTwipsToRuler(int nT) {return MulDiv(nT, m_logx, 1440);}
    int XRulerToTwips(int nR) {return MulDiv(nR, 1440, m_logx);}

    int XRulerToClient(int nR) {return nR + m_cxLeftBorder - m_nScroll;}
    int XClientToRuler(int nC) {return nC - m_cxLeftBorder + m_nScroll;}

protected:
    virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
    void CreateGDIObjects();
    void DrawFace(CDC& dc);
    void DrawTickMarks(CDC& dC);
    void DrawNumbers(CDC& dc, int nInc, int nTPU);
    void DrawDiv(CDC& dc, int nInc, int nLargeDiv, int nLength);
    void DrawTabs(CDC& dc);
    void FillInParaFormat(PARAFORMAT& pf);
    void SortTabs();
    void SetMarginBounds();
    CRulerItem* GetFreeTab();
    CView* GetView()
    {
        ASSERT(GetParent() != NULL);
        return ((CFrameWnd*)GetParent())->GetActiveView();
    }
    CDocument* GetDocument() { return GetView()->GetDocument(); }

    CTabRulerItem* GetHitTabPix(CPoint pt);

    // Generated message map functions
    //{{AFX_MSG(CRulerBar)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnSysColorChange();
    afx_msg void OnWindowPosChanging(WINDOWPOS FAR* lpwndpos);
    afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
    afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
    //}}AFX_MSG
    afx_msg LRESULT OnSizeParent(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
    
    friend class CRulerItem;
};

inline int CRulerItem::GetHorzPosPix()
    { return m_pRuler->XTwipsToRuler(m_nXPosTwips); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\ruler.cpp ===
// ruler.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "ruler.h"
#include "wordpvw.h"
#include "wordpdoc.h"
#include "strings.h"
#include <memory.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define HEIGHT 17
#define RULERBARHEIGHT 17

CRulerItem::CRulerItem(UINT nBitmapID)
{
    m_nAlignment = TA_CENTER;
    m_pDC = NULL;
    m_bTrack = FALSE;
    m_hbm = NULL;
    m_hbmMask = NULL;
    if (nBitmapID != 0)
    {
        m_hbmMask = ::LoadBitmap(
            AfxFindResourceHandle(MAKEINTRESOURCE(nBitmapID+1), RT_BITMAP), 
            MAKEINTRESOURCE(nBitmapID+1));
        ASSERT(m_hbmMask != NULL);
        VERIFY(LoadMaskedBitmap(MAKEINTRESOURCE(nBitmapID)));
        BITMAP bm;
        ::GetObject(m_hbm, sizeof(BITMAP), &bm);
        m_size = CSize(bm.bmWidth, bm.bmHeight);
    }
}

CRulerItem::~CRulerItem()
{
    if (m_hbm != NULL)
        ::DeleteObject(m_hbm);
    if (m_hbmMask != NULL)
        ::DeleteObject(m_hbmMask);
}

BOOL CRulerItem::LoadMaskedBitmap(LPCTSTR lpszResourceName)
{
    ASSERT(lpszResourceName != NULL);

    if (m_hbm != NULL)
        ::DeleteObject(m_hbm);

    HINSTANCE hInst = AfxFindResourceHandle(lpszResourceName, RT_BITMAP);
    HRSRC hRsrc = ::FindResource(hInst, lpszResourceName, RT_BITMAP);
    if (hRsrc == NULL)
        return FALSE;

    m_hbm = AfxLoadSysColorBitmap(hInst, hRsrc);
    return (m_hbm != NULL);
}

void CRulerItem::SetHorzPosTwips(int nXPos)
{
    if (GetHorzPosTwips() != nXPos)
    {
        if (m_bTrack)
            DrawFocusLine();
        Invalidate();
        m_nXPosTwips = nXPos;
        Invalidate();
        if (m_bTrack)
            DrawFocusLine();
    }
}

void CRulerItem::TrackHorzPosTwips(int nXPos, BOOL /*bOnRuler*/)
{
    int nMin = GetMin();
    int nMax = GetMax();
    if (nXPos < nMin)
        nXPos = nMin;
    if (nXPos > nMax)
        nXPos = nMax;
    SetHorzPosTwips(nXPos);
}

void CRulerItem::DrawFocusLine()
{
    if (GetHorzPosTwips() != 0)
    {
        m_rcTrack.left = m_rcTrack.right = GetHorzPosPix();
        ASSERT(m_pDC != NULL);
        int nLeft = m_pRuler->XRulerToClient(m_rcTrack.left);
        m_pDC->MoveTo(nLeft, m_rcTrack.top);
        m_pDC->LineTo(nLeft, m_rcTrack.bottom);
    }
}

void CRulerItem::SetTrack(BOOL b)
{
    m_bTrack = b;
    
    if (m_pDC != NULL) // just in case we lost focus Capture somewhere
    {
        DrawFocusLine();
        m_pDC->RestoreDC(-1);
        delete m_pDC ;
        m_pDC = NULL;
    }
    if (m_bTrack)
    {
        CWordPadView* pView = (CWordPadView*)m_pRuler->GetView();
        ASSERT(pView != NULL);
        pView->GetClientRect(&m_rcTrack);
        m_pDC = new CWindowDC(pView);
        m_pDC->SaveDC();
        m_pDC->SelectObject(&m_pRuler->penFocusLine);
        m_pDC->SetROP2(R2_XORPEN);
        DrawFocusLine();
    }
}

void CRulerItem::Invalidate()
{
    CRect rc = GetHitRectPix();
    m_pRuler->RulerToClient(rc.TopLeft());
    m_pRuler->RulerToClient(rc.BottomRight());
    m_pRuler->InvalidateRect(rc);
}

CRect CRulerItem::GetHitRectPix()
{
    int nx = GetHorzPosPix();
    return CRect( 
        CPoint( 
            (m_nAlignment == TA_CENTER) ? (nx - m_size.cx/2) :
            (m_nAlignment == TA_LEFT) ? nx : nx - m_size.cx
            , m_nYPosPix
            ), 
        m_size);
}

void CRulerItem::Draw(CDC& dc)
{
    CDC dcBitmap;
    dcBitmap.CreateCompatibleDC(&dc);
    CPoint pt(GetHorzPosPix(), GetVertPosPix());

    HGDIOBJ hbm = ::SelectObject(dcBitmap.m_hDC, m_hbmMask);

    // do mask part
    if (m_nAlignment == TA_CENTER)
        dc.BitBlt(pt.x - m_size.cx/2, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCAND);
    else if (m_nAlignment == TA_LEFT)
        dc.BitBlt(pt.x, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCAND);
    else // TA_RIGHT
        dc.BitBlt(pt.x - m_size.cx, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCAND);
    
    // do image part
    ::SelectObject(dcBitmap.m_hDC, m_hbm);

    if (m_nAlignment == TA_CENTER)
        dc.BitBlt(pt.x - m_size.cx/2, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCINVERT);
    else if (m_nAlignment == TA_LEFT)
        dc.BitBlt(pt.x, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCINVERT);
    else // TA_RIGHT
        dc.BitBlt(pt.x - m_size.cx, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCINVERT);

    ::SelectObject(dcBitmap.m_hDC, hbm);
}

CComboRulerItem::CComboRulerItem(UINT nBitmapID1, UINT nBitmapID2, CRulerItem& item)
    : CRulerItem(nBitmapID1), m_secondary(nBitmapID2) , m_link(item)
{
    m_bHitPrimary = TRUE;
}

BOOL CComboRulerItem::HitTestPix(CPoint pt)
{
    m_bHitPrimary = FALSE;
    if (CRulerItem::GetHitRectPix().PtInRect(pt))
        m_bHitPrimary = TRUE;
    else 
        return m_secondary.HitTestPix(pt);
    return TRUE;
}

void CComboRulerItem::Draw(CDC& dc)
{
    CRulerItem::Draw(dc);
    m_secondary.Draw(dc);
}

void CComboRulerItem::SetHorzPosTwips(int nXPos)
{
    if (m_bHitPrimary) // only change linked items by delta
        m_link.SetHorzPosTwips(m_link.GetHorzPosTwips() + nXPos - GetHorzPosTwips());
    CRulerItem::SetHorzPosTwips(nXPos);
    m_secondary.SetHorzPosTwips(nXPos);
}

void CComboRulerItem::TrackHorzPosTwips(int nXPos, BOOL /*bOnRuler*/)
{
    int nMin = GetMin();
    int nMax = GetMax();
    if (nXPos < nMin)
        nXPos = nMin;
    if (nXPos > nMax)
        nXPos = nMax;
    SetHorzPosTwips(nXPos);
}

void CComboRulerItem::SetVertPos(int nYPos)
{
    m_secondary.SetVertPos(nYPos);
    nYPos += m_secondary.GetHitRectPix().Height();
    CRulerItem::SetVertPos(nYPos);
}

void CComboRulerItem::SetAlignment(int nAlign)
{
    CRulerItem::SetAlignment(nAlign);
    m_secondary.SetAlignment(nAlign);
}

void CComboRulerItem::SetRuler(CRulerBar* pRuler)
{
    m_pRuler = pRuler;
    m_secondary.SetRuler(pRuler);
}

void CComboRulerItem::SetBounds(int nMin, int nMax)
{
    CRulerItem::SetBounds(nMin, nMax);
    m_secondary.SetBounds(nMin, nMax);
}

int CComboRulerItem::GetMin()
{
    if (m_bHitPrimary)
    {
        int nPDist = GetHorzPosTwips() - CRulerItem::GetMin();
        int nLDist = m_link.GetHorzPosTwips() - m_link.GetMin();
        return GetHorzPosTwips() - min(nPDist, nLDist);
    }
    else
        return CRulerItem::GetMin();
}

int CComboRulerItem::GetMax()
{
    if (m_bHitPrimary)
    {
        int nPDist = CRulerItem::GetMax() - GetHorzPosTwips();
        int nLDist = m_link.GetMax() - m_link.GetHorzPosTwips();
        int nMinDist = (nPDist < nLDist) ? nPDist : nLDist;
        return GetHorzPosTwips() + nMinDist;
    }
    else
        return CRulerItem::GetMax();
}

void CTabRulerItem::TrackHorzPosTwips(int nXPos, BOOL bOnRuler)
{
    if (bOnRuler)
        CRulerItem::TrackHorzPosTwips(nXPos, bOnRuler);
    else
        CRulerItem::TrackHorzPosTwips(0, bOnRuler);
}


BEGIN_MESSAGE_MAP(CRulerBar, CControlBar)
    //{{AFX_MSG_MAP(CRulerBar)
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    ON_WM_SYSCOLORCHANGE()
    ON_WM_WINDOWPOSCHANGING()
    ON_WM_SHOWWINDOW()
    ON_WM_WINDOWPOSCHANGED()
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_SIZEPARENT, OnSizeParent)
    // Global help commands
END_MESSAGE_MAP()

CRulerBar::CRulerBar() : 
    m_leftmargin(IDB_RULER_BLOCK, IDB_RULER_UP, m_indent), 
    m_indent(IDB_RULER_DOWN), 
    m_rightmargin(IDB_RULER_UP),
    m_tabItem(IDB_RULER_TAB)
{
    m_bDeferInProgress = FALSE;
    m_leftmargin.SetRuler(this);
    m_indent.SetRuler(this);
    m_rightmargin.SetRuler(this);

    // all of the tab stops share handles
    for (int i=0;i<MAX_TAB_STOPS;i++)
    {
        m_pTabItems[i].m_hbm = m_tabItem.m_hbm;
        m_pTabItems[i].m_hbmMask = m_tabItem.m_hbmMask;
        m_pTabItems[i].m_size = m_tabItem.m_size;
    }

    m_unit.m_nTPU = 0;
    m_nScroll = 0;

    LOGFONT lf;
    memcpy(&lf, &theApp.m_lf, sizeof(LOGFONT));
    lstrcpy(lf.lfFaceName, TEXT("MS Shell Dlg"));
    lf.lfWidth = 0;
    VERIFY(fnt.CreateFontIndirect(&lf));

    m_nTabs = 0;
    m_leftmargin.SetVertPos(9);
    m_indent.SetVertPos(-1);
    m_rightmargin.SetVertPos(9);

    m_cxLeftBorder = 0;
    m_cyTopBorder = 4;
    m_cyBottomBorder = 6;
    
    m_pSelItem = NULL;

    m_logx = theApp.m_dcScreen.GetDeviceCaps(LOGPIXELSX);

    CreateGDIObjects();
}

CRulerBar::~CRulerBar()
{
    // set handles to NULL to avoid deleting twice
    for (int i=0;i<MAX_TAB_STOPS;i++)
    {
        m_pTabItems[i].m_hbm = NULL;
        m_pTabItems[i].m_hbmMask = NULL;
    }
}

void CRulerBar::CreateGDIObjects()
{
    penFocusLine.DeleteObject();
    penBtnHighLight.DeleteObject();
    penBtnShadow.DeleteObject();
    penWindowFrame.DeleteObject();
    penBtnText.DeleteObject();
    penBtnFace.DeleteObject();
    penWindowText.DeleteObject();
    penWindow.DeleteObject();
    brushWindow.DeleteObject();
    brushBtnFace.DeleteObject();

    penFocusLine.CreatePen(PS_DOT, 1,GetSysColor(COLOR_WINDOWTEXT));
    penBtnHighLight.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNHIGHLIGHT));
    penBtnShadow.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNSHADOW));
    penWindowFrame.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOWFRAME));
    penBtnText.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNTEXT));
    penBtnFace.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNFACE));
    penWindowText.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOWTEXT));
    penWindow.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOW));
    brushWindow.CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    brushBtnFace.CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
}

void CRulerBar::OnUpdateCmdUI(CFrameWnd* /*pTarget*/, BOOL /*bDisableIfNoHndler*/)
{
    ASSERT_VALID(this);
    //Get the page size and see if changed -- from document
    //get margins and tabs and see if changed -- from view
    if (m_pSelItem == NULL) // only update if not in middle of dragging
    {
        CWordPadView* pView = (CWordPadView*)GetView();
        ASSERT(pView != NULL);
        Update(pView->GetPaperSize(), pView->GetMargins());
        Update(pView->GetParaFormatSelection());
        CRect rect;
        pView->GetRichEditCtrl().GetRect(&rect);
        CPoint pt = rect.TopLeft();
        pView->ClientToScreen(&pt);
        ScreenToClient(&pt);
        if (m_cxLeftBorder != pt.x)
        {
            m_cxLeftBorder = pt.x;
            Invalidate();
        }
        int nScroll = pView->GetScrollPos(SB_HORZ);
        if (nScroll != m_nScroll)
        {
            m_nScroll = nScroll;
            Invalidate();
        }
    }
}

CSize CRulerBar::GetBaseUnits()
{
    ASSERT(fnt.GetSafeHandle() != NULL);
    CFont* pFont = theApp.m_dcScreen.SelectObject(&fnt);
    TEXTMETRIC tm;
    VERIFY(theApp.m_dcScreen.GetTextMetrics(&tm) == TRUE);
    theApp.m_dcScreen.SelectObject(pFont);
//  return CSize(tm.tmAveCharWidth, tm.tmHeight+tm.tmDescent);
    return CSize(tm.tmAveCharWidth, tm.tmHeight);
}

BOOL CRulerBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
    ASSERT_VALID(pParentWnd);   // must have a parent

    dwStyle |= WS_CLIPSIBLINGS;
    // force WS_CLIPSIBLINGS (avoids SetWindowPos bugs)
    m_dwStyle = (UINT)dwStyle;

    // create the HWND
    CRect rect;
    rect.SetRectEmpty();
    LPCTSTR lpszClass = AfxRegisterWndClass(0, ::LoadCursor(NULL, IDC_ARROW),
        (HBRUSH)(COLOR_BTNFACE+1), NULL);

    if (!CWnd::Create(lpszClass, NULL, dwStyle, rect, pParentWnd, nID))
        return FALSE;
    // NOTE: Parent must resize itself for control bar to be resized

    int i;
    int nMax = 100;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        m_pTabItems[i].SetRuler(this);
        m_pTabItems[i].SetVertPos(8);
        m_pTabItems[i].SetHorzPosTwips(0);
        m_pTabItems[i].SetBounds(0, nMax);
    }
    return TRUE;
}

CSize CRulerBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
    ASSERT(bHorz);
    CSize m_size = CControlBar::CalcFixedLayout(bStretch, bHorz);
    CRect rectSize;
    rectSize.SetRectEmpty();
    CalcInsideRect(rectSize, bHorz);       // will be negative size
    m_size.cy = RULERBARHEIGHT - rectSize.Height();
    return m_size;
}

void CRulerBar::Update(const PARAFORMAT& pf)
{
    ASSERT(pf.cTabCount <= MAX_TAB_STOPS);

    m_leftmargin.SetHorzPosTwips((int)(pf.dxStartIndent + pf.dxOffset));
    m_indent.SetHorzPosTwips((int)pf.dxStartIndent);
    m_rightmargin.SetHorzPosTwips(PrintWidth() - (int) pf.dxRightIndent);

    int i = 0;
    for (i=0;i<pf.cTabCount;i++)
        m_pTabItems[i].SetHorzPosTwips((int)pf.rgxTabs[i]);
    for ( ;i<MAX_TAB_STOPS; i++)
        m_pTabItems[i].SetHorzPosTwips(0);
}

void CRulerBar::Update(CSize sizePaper, const CRect& rectMargins)
{
    if ((sizePaper != m_sizePaper) || (rectMargins != m_rectMargin))
    {
        m_sizePaper = sizePaper;
        m_rectMargin = rectMargins;
        Invalidate();
    }
    if (m_unit.m_nTPU != theApp.GetTPU())
    {
        m_unit = theApp.GetUnit();
        Invalidate();
    }
}

void CRulerBar::FillInParaFormat(PARAFORMAT& pf)
{
    pf.dwMask = PFM_STARTINDENT | PFM_RIGHTINDENT | PFM_OFFSET | PFM_TABSTOPS;
    pf.dxStartIndent = m_indent.GetHorzPosTwips();
    pf.dxOffset = m_leftmargin.GetHorzPosTwips() - pf.dxStartIndent;
    pf.dxRightIndent = PrintWidth() - m_rightmargin.GetHorzPosTwips();
    pf.cTabCount = 0L;
    SortTabs();
    int i, nPos = 0;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        // get rid of zeroes and multiples
        // i.e. if we have 0,0,0,1,2,3,4,4,5
        // we will get tabs at 1,2,3,4,5
        if (nPos != m_pTabItems[i].GetHorzPosTwips())
        {
            nPos = m_pTabItems[i].GetHorzPosTwips();
            pf.rgxTabs[pf.cTabCount++] = nPos;
        }
    }
}

// simple bubble sort is adequate for small number of tabs
void CRulerBar::SortTabs()
{
    int i,j, nPos;
    for (i=0;i<MAX_TAB_STOPS - 1;i++)
    {
        for (j=i+1; j < MAX_TAB_STOPS;j++)
        {
            if (m_pTabItems[j].GetHorzPosTwips() < m_pTabItems[i].GetHorzPosTwips())
            {
                nPos = m_pTabItems[j].GetHorzPosTwips();
                m_pTabItems[j].SetHorzPosTwips(m_pTabItems[i].GetHorzPosTwips());
                m_pTabItems[i].SetHorzPosTwips(nPos);
            }
        }
    }
}

void CRulerBar::DoPaint(CDC* pDC)
{
    CControlBar::DoPaint(pDC); // CControlBar::DoPaint -- draws border
    if (m_unit.m_nTPU != 0)
    {
        pDC->SaveDC();
        // offset coordinate system
        CPoint pointOffset(0,0);
        RulerToClient(pointOffset);
        pDC->SetViewportOrg(pointOffset);

        DrawFace(*pDC);
        DrawTickMarks(*pDC);

        DrawTabs(*pDC);
        m_leftmargin.Draw(*pDC);
        m_indent.Draw(*pDC);
        m_rightmargin.Draw(*pDC);   

        pDC->RestoreDC(-1);
    }
    // Do not call CControlBar::OnPaint() for painting messages
}

void CRulerBar::DrawTabs(CDC& dc)
{
    int i;
    int nPos = 0;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        if (m_pTabItems[i].GetHorzPosTwips() > nPos)
            nPos = (m_pTabItems[i].GetHorzPosTwips());
        m_pTabItems[i].Draw(dc);
    }
    int nPageWidth = PrintWidth();
    nPos = nPos - nPos%720 + 720;
    dc.SelectObject(&penBtnShadow);
    for ( ; nPos < nPageWidth; nPos += 720)
    {
        int nx = XTwipsToRuler(nPos);
        dc.MoveTo(nx, HEIGHT - 1);
        dc.LineTo(nx, HEIGHT + 1);
    }
}

void CRulerBar::DrawFace(CDC& dc)
{
    int nPageWidth = XTwipsToRuler(PrintWidth());
    int nPageEdge = XTwipsToRuler(PrintWidth() + m_rectMargin.right);

    dc.SaveDC();

    dc.SelectObject(&penBtnShadow);
    dc.MoveTo(0,0);
    dc.LineTo(nPageEdge - 1, 0);
    dc.LineTo(nPageEdge - 1, HEIGHT - 2);
    dc.LineTo(nPageWidth - 1, HEIGHT - 2);
    dc.LineTo(nPageWidth - 1, 1);
    dc.LineTo(nPageWidth, 1);
    dc.LineTo(nPageWidth, HEIGHT -2);
    
    dc.SelectObject(&penBtnHighLight);
    dc.MoveTo(nPageWidth, HEIGHT - 1);
    dc.LineTo(nPageEdge, HEIGHT -1);
    dc.MoveTo(nPageWidth + 1, HEIGHT - 3);
    dc.LineTo(nPageWidth + 1, 1);
    dc.LineTo(nPageEdge - 1, 1);
    
    dc.SelectObject(&penWindow);
    dc.MoveTo(0, HEIGHT - 1);
    dc.LineTo(nPageWidth, HEIGHT -1);

    dc.SelectObject(&penBtnFace);
    dc.MoveTo(1, HEIGHT - 2);
    dc.LineTo(nPageWidth - 1, HEIGHT - 2);
    
    dc.SelectObject(&penWindowFrame);
    dc.MoveTo(0, HEIGHT - 2);
    dc.LineTo(0, 1);
    dc.LineTo(nPageWidth - 1, 1);
    
    dc.FillRect(CRect(1, 2, nPageWidth - 1, HEIGHT-2), &brushWindow);
    dc.FillRect(CRect(nPageWidth + 2, 2, nPageEdge - 1, HEIGHT-2), &brushBtnFace);

    CRect rcClient;
    GetClientRect(&rcClient);
    ClientToRuler(rcClient);
    rcClient.top = HEIGHT;
    rcClient.bottom = HEIGHT + 8;
    rcClient.right -= 2;

    DrawEdge(dc, &rcClient, EDGE_RAISED, BF_BOTTOM | BF_MIDDLE);
    
    //
    // Small fixup to account for the fact that the left border needs to merge
    // with the window below the ruler.
    //

    dc.SetPixel(rcClient.left, rcClient.bottom-1, GetSysColor(COLOR_3DSHADOW));

    dc.RestoreDC(-1);
}

void CRulerBar::DrawTickMarks(CDC& dc)
{
    dc.SaveDC();

    dc.SelectObject(&penWindowText);
    dc.SelectObject(&fnt);
    dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
    dc.SetBkMode(TRANSPARENT);

    DrawDiv(dc, m_unit.m_nSmallDiv, m_unit.m_nLargeDiv, 2);
    DrawDiv(dc, m_unit.m_nMediumDiv, m_unit.m_nLargeDiv, 5);
    DrawNumbers(dc, m_unit.m_nLargeDiv, m_unit.m_nTPU);
    
    dc.RestoreDC(-1);
}

void CRulerBar::DrawNumbers(CDC& dc, int nInc, int nTPU)
{
    int nPageWidth = PrintWidth();
    int nPageEdge = nPageWidth + m_rectMargin.right;
    TCHAR buf[10];

    int nTwips, nPixel, nLen;

    for (nTwips = nInc; nTwips < nPageEdge; nTwips += nInc)
    {
        if (nTwips == nPageWidth)
            continue;
        nPixel = XTwipsToRuler(nTwips);
        wsprintf(buf, _T("%d"), nTwips/nTPU);
        nLen = lstrlen(buf);
        CSize sz = dc.GetTextExtent(buf, nLen);
        dc.ExtTextOut(nPixel - sz.cx/2, HEIGHT/2 - sz.cy/2, 0, NULL, buf, nLen, NULL);
    }
}

void CRulerBar::DrawDiv(CDC& dc, int nInc, int nLargeDiv, int nLength)
{
    int nPageWidth = PrintWidth();
    int nPageEdge = nPageWidth + m_rectMargin.right;

    int nTwips, nPixel;

    for (nTwips = nInc; nTwips < nPageEdge; nTwips += nInc)
    {
        if (nTwips == nPageWidth || nTwips%nLargeDiv == 0)
            continue;
        nPixel = XTwipsToRuler(nTwips);
        dc.MoveTo(nPixel, HEIGHT/2 - nLength/2);
        dc.LineTo(nPixel, HEIGHT/2 - nLength/2 + nLength);
    }
}

void CRulerBar::OnLButtonDown(UINT nFlags, CPoint point)
{
    CPoint pt = point;
    ClientToRuler(pt);
    
    m_pSelItem = NULL;
    if (m_leftmargin.HitTestPix(pt))
        m_pSelItem = &m_leftmargin;
    else if (m_indent.HitTestPix(pt))
        m_pSelItem = &m_indent;
    else if (m_rightmargin.HitTestPix(pt))
        m_pSelItem = &m_rightmargin;
    else
        m_pSelItem = GetHitTabPix(pt);
    if (m_pSelItem == NULL)
        m_pSelItem = GetFreeTab();
    if (m_pSelItem == NULL)
        return;
    SetCapture();

    m_pSelItem->SetTrack(TRUE);
    SetMarginBounds();
    OnMouseMove(nFlags, point);
}

void CRulerBar::SetMarginBounds()
{
    m_leftmargin.SetBounds(0, m_rightmargin.GetHorzPosTwips());
    m_indent.SetBounds(0, m_rightmargin.GetHorzPosTwips());

    int nMin = (m_leftmargin.GetHorzPosTwips() > m_indent.GetHorzPosTwips()) ? 
        m_leftmargin.GetHorzPosTwips() : m_indent.GetHorzPosTwips();
    int nMax = PrintWidth() + m_rectMargin.right;
    m_rightmargin.SetBounds(nMin, nMax);
    
    // tabs can go from zero to the right page edge
    for (int i=0;i<MAX_TAB_STOPS;i++)
        m_pTabItems[i].SetBounds(0, nMax);
}

CRulerItem* CRulerBar::GetFreeTab()
{
    int i;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        if (m_pTabItems[i].GetHorzPosTwips() == 0)
            return &m_pTabItems[i];
    }
    return NULL;
}

CTabRulerItem* CRulerBar::GetHitTabPix(CPoint point)
{
    int i;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        if (m_pTabItems[i].HitTestPix(point))
            return &m_pTabItems[i];
    }
    return NULL;
}

void CRulerBar::OnLButtonUp(UINT nFlags, CPoint point)
{
    if (::GetCapture() != m_hWnd)
        return;
    OnMouseMove(nFlags, point);
    m_pSelItem->SetTrack(FALSE);
    ReleaseCapture();
    CWordPadView* pView = (CWordPadView*)GetView();
    ASSERT(pView != NULL);
    PARAFORMAT& pf = pView->GetParaFormatSelection();
    FillInParaFormat(pf);
    pView->SetParaFormat(pf);
    m_pSelItem = NULL;
}

void CRulerBar::OnMouseMove(UINT nFlags, CPoint point)
{
    CControlBar::OnMouseMove(nFlags, point);
// use ::GetCapture to avoid creating temporaries
    if (::GetCapture() != m_hWnd)
        return;
    ASSERT(m_pSelItem != NULL);
    CRect rc(0,0, XTwipsToRuler(PrintWidth() + m_rectMargin.right), HEIGHT);
    RulerToClient(rc);
    BOOL bOnRuler = rc.PtInRect(point);

// snap to minimum movement
    point.x = XClientToTwips(point.x);
    point.x += m_unit.m_nMinMove/2;
    point.x -= point.x%m_unit.m_nMinMove;

    m_pSelItem->TrackHorzPosTwips(point.x, bOnRuler);
    UpdateWindow();
}

void CRulerBar::OnSysColorChange()
{
    CControlBar::OnSysColorChange();
    CreateGDIObjects();
    Invalidate();   
}

void CRulerBar::OnWindowPosChanging(WINDOWPOS FAR* lpwndpos) 
{
    CControlBar::OnWindowPosChanging(lpwndpos);
    CRect rect;
    GetClientRect(rect);
    int minx = min(rect.Width(), lpwndpos->cx);
    int maxx = max(rect.Width(), lpwndpos->cx);
    rect.SetRect(minx-2, rect.bottom - 6, minx, rect.bottom);
    InvalidateRect(rect);
    rect.SetRect(maxx-2, rect.bottom - 6, maxx, rect.bottom);
    InvalidateRect(rect);
}

void CRulerBar::OnShowWindow(BOOL bShow, UINT nStatus) 
{
    CControlBar::OnShowWindow(bShow, nStatus);
    m_bDeferInProgress = FALSE; 
}

void CRulerBar::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos) 
{
    CControlBar::OnWindowPosChanged(lpwndpos);
    m_bDeferInProgress = FALSE; 
}

LRESULT CRulerBar::OnSizeParent(WPARAM wParam, LPARAM lParam)
{
    BOOL bVis = GetStyle() & WS_VISIBLE;
    if ((bVis && (m_nStateFlags & delayHide)) ||
        (!bVis && (m_nStateFlags & delayShow)))
    {
        m_bDeferInProgress = TRUE;
    }
    return CControlBar::OnSizeParent(wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\winctrl2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "stdafx2.h"

#ifdef AFX_CMNCTL_SEG
#pragma code_seg(AFX_CMNCTL_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CRichEdit

CRichEdit2Ctrl::~CRichEdit2Ctrl()
{
	DestroyWindow();
}


#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_DYNAMIC(CRichEdit2Ctrl, CWnd)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef _UNICODE
#define VC_EXTRALEAN            // use stripped down Win32 headers
#endif

#define CONVERTERS

#include <afxwin.h>         // MFC core and standard components

//
// MFC 4.2 hardcodes _RICHEDIT_VER to 0x0100 in afxwin.h.  This prevents
// richedit.h from enabling any richedit 2.0 features.
//

#ifdef _RICHEDIT_VER
#if _RICHEDIT_VER < 0x0200
#undef _RICHEDIT_VER
#define _RICHEDIT_VER 0x0200
#endif
#endif

#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxcmn.h>
//#include <afxrich.h>
#include <afxpriv.h>

//
// Private headers for richedit2 support until MFC gets native support
//

#ifndef _AFX_ENABLE_INLINES
#define _AFX_ENABLE_INLINES
#endif

#define _AFXCMN2_INLINE     inline
#define _AFXDLGS2_INLINE    inline
#define _AFXRICH2_INLINE    inline

#include <afxdlgs2.h>
#include <afxcmn2.h>
#include <afxrich2.h>



#define HORZ_TEXTOFFSET 15
#define VERT_TEXTOFFSET 5

class CDisplayIC : public CDC
{
public:
	CDisplayIC() { CreateIC(_T("DISPLAY"), NULL, NULL, NULL); }
};

struct CCharFormat : public CHARFORMAT  // re20 requires this line; added by t-stefb
//struct CCharFormat : public _charformat
{
	CCharFormat() {cbSize = sizeof(CHARFORMAT);}  // re20 requires this line; added by t-stefb
//	CCharFormat() {cbSize = sizeof(_charformat);}
	BOOL operator==(CCharFormat& cf);
};

struct CParaFormat : public _paraformat
{
	CParaFormat() {cbSize = sizeof(_paraformat);}
	BOOL operator==(PARAFORMAT& pf);
};

#include "doctype.h"
#include "chicdial.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wordpad.rc
//
#define IDR_SRVR_INPLACE                4
#define IDR_SRVR_EMBEDDED               5
#define IDR_CNTR_INPLACE                6
#define IDP_OLE_INIT_FAILED             100
#define IDP_FAILED_TO_CREATE            102
#define IDS_INVALID_MEASUREMENT         103
#define IDS_PLEASE_WAIT                 104
#define IDS_COMPLETE                    105
#define IDS_SAVE_UNSUPPORTED            106
#define IDS_CLOSE_TEXT                  107
#define IDS_RICHED_LOAD_FAIL            108
#define IDS_DEFAULTFONT                 109
#define IDC_COMBO_ALIGNMENT             111
#define IDS_DEFAULTTEXTFONT             111
#define IDS_SAVE_FORMAT_TEXT            112
#define IDS_SAVE_FORMAT                 113
#define IDS_SAVING                      113
#define IDS_CLIP_RTF                    114
#define IDS_FORMATTING                  115
#define IDS_LEFT                        116
#define IDS_CENTER                      117
#define IDS_RIGHT                       118
#define IDS_NOWRAP                      119
#define IDS_MEASUREMENT_RANGE           119
#define IDS_WRAPTOWINDOW                120
#define IDS_INVALID_NUMBER              120
#define IDS_WRAPTORULER                 121
#define IDS_INVALID_FONTSIZE            121
#define IDS_INCHES                      122
#define IDS_CENTIMETERS                 123
#define IDS_POINTS                      124
#define IDS_PICAS                       125
#define IDS_WORD_WARNING                126
#define IDS_WORD_WARNING_BUTTONS        127
#define IDR_MAINFRAME                   128
#define IDS_TEXT_DOC                    129
#define IDS_RICHTEXT_DOC                130
#define IDB_BITMAP_TT                   130
#define IDS_WRITE_DOC                   131
#define IDB_RULER_BLOCK                 131
#define IDS_ALL_DOC                     132
#define IDB_RULER_BLOCKM                132
#define IDS_WINWORD6_DOC                133
#define IDB_RULER_DOWN                  133
#define IDS_WINWORD2_DOC                134
#define IDB_RULER_DOWNM                 134
#define IDB_RULER_TAB                   135
#define IDB_RULER_TABM                  136
#define IDS_FILE_EXISTS                 136
#define IDB_RULER_UP                    137
#define IDS_MAPILOAD_FAILED             137
#define IDS_OEMTEXT_DOC                 137
#define IDB_RULER_UPM                   138
#define IDS_CLIP_TEXT                   138
#define IDB_FORMATBAR                   139
#define IDS_CLIP_FILENAME               139
#define IDR_MAINFRAME1                  140
#define IDB_FORMATBAR_BIG               141
#define IDR_COLOR_MENU                  142
#define IDR_MAINFRAME_BIG               142
#define IDD_FORMAT_PARA                 143
#define IDR_MAINFRAME1_BIG              143
#define IDR_SRVR_INPLACE_BIG            144
#define IDD_FORMAT_TAB                  145
#define IDD_LISTDIALOG                  147
#define IDD_OPTIONS                     148
#define IDS_DT1                         149
#define IDD_PAGE_SETUP_DIALOG           150
#define IDS_DT2                         150
#define IDR_MENU1                       151
#define IDS_DT3                         151
#define IDD_DATEDIALOG                  151
#define IDS_DT4                         152
#define IDR_TEXT_POPUP                  152
#define IDS_DT5                         153
#define IDS_DT6                         154
#define IDI_ICON_DOC                    154
#define IDS_DT7                         155
#define IDI_ICON_WRITE                  155
#define IDS_DT8                         156
#define IDS_DT9                         157
#define IDD_SPLASH                      157
#define IDS_DT10                        158
#define IDD_OPTIONS_UNITS               158
#define IDS_DT11                        159
#define IDD_OPTIONS_WRAP                159
#define IDS_DT12                        160
#define IDD_OPTIONS_MARGINS             160
#define IDD_FILENEWDIALOG               160
#define IDS_DT13                        161
#define IDB_BITMAP48                    162
#define IDB_BITMAP_PRINTER              163
#define IDS_FINISHED_SEARCH             164
#define IDC_FONTNAME                    165
#define IDI_ICON_TEXT                   165
#define IDC_FONTSIZE                    166
#define IDS_TITLE_FORMATBAR             167
#define IDB_PRINTER                     167
#define IDB_FONTTYPE                    167
#define IDS_TITLE_TOOLBAR               168
#define IDS_INCH1_ABBREV                169
#define IDS_INCH2_ABBREV                170
#define IDS_INCH3_ABBREV                171
#define IDS_INCH4_ABBREV                172
#define IDS_CM_ABBREV                   173
#define IDS_POINT_ABBREV                174
#define IDS_PICA_ABBREV                 175
#define IDS_NOMORETABS                  176
#define IDS_MAPI_FAIL                   177
#define IDS_ERRSPACE                    178
#define IDS_CANT_LOAD                   179
#define IDS_TOOMANYFILES                180
#define IDS_DIRFULL                     181
#define IDS_SHAREVIOLATION              182
#define IDS_TEXT_OPTIONS                183
#define IDS_RTF_OPTIONS                 184
#define IDS_WORD6_OPTIONS               185
#define IDS_OPTIONS                     186
#define IDS_WRITE_OPTIONS               187
#define IDS_EMBEDDED_OPTIONS            188
#define IDS_TEXT_DOCUMENT               189
#define IDS_RTF_DOCUMENT                190
#define IDS_WORD6_DOCUMENT              191
#define IDS_WRITEPROTECT                192
#define IDS_UNICODETEXT_DOC             193
#define IDS_UNICODETEXT_DOCUMENT        194
#define IDS_CONVERTER_ABORTED           195
#define IDS_WORD97_DOC                  196
#define IDS_WORD97_WARNING              197
#define IDS_FEWINWORD5_DOC              198
#define IDS_INCH1_NOLOC                 199
#define IDS_INCH2_NOLOC                 200
#define IDS_INCH3_NOLOC                 201
#define IDS_INCH4_NOLOC                 202
#define IDS_CM_NOLOC                    203
#define IDS_POINT_NOLOC                 204
#define IDS_PICA_NOLOC                  205
#define IDC_EDIT_LEFT                   1000
#define IDC_EDIT_RIGHT                  1001
#define IDC_EDIT_FIRST_LINE             1002
#define IDC_BUTTON_SET                  1005
#define IDC_EDIT_BM                     1005
#define IDC_BUTTON_CLEAR                1006
#define IDC_EDIT_LM                     1006
#define IDC_BUTTON_CLEARALL             1007
#define IDC_EDIT_RM                     1007
#define IDC_STATIC_HEADING              1009
#define IDC_COMBO_WRAP                  1011
#define IDC_COMBO_UNITS                 1012
#define IDC_EDIT_TM                     1016
#define IDC_TEXT_ALIGNMENT              1017
#define IDC_LISTDIALOG_LIST             1018
#define IDC_DATEDIALOG_LIST             1018
#define IDC_COMBO1                      1019
#define IDC_TEXT_WRAP                   1020
#define IDC_TEXT_UNITS                  1021
#define IDC_BOX                         1022
#define IDC_BIGICON                     1023
#define IDC_UNITS_IN                    1024
#define IDC_UNITS_CM                    1025
#define IDC_WRAP_RULER                  1025
#define IDC_UNITS_PT                    1026
#define IDC_WRAP_WINDOW                 1026
#define IDC_UNITS_PI                    1027
#define IDC_WRAP_NONE                   1027
#define IDC_CHECK_TOOLBAR               1028
#define IDC_CHECK_FORMATBAR             1029
#define IDC_WORDSEL                     1029
#define IDC_CHECK_RULERBAR              1030
#define IDC_CHECK_STATUSBAR             1031
#define IDC_BOXT                        1032
#define ID_CANCEL_EDIT_CNTR             32768
#define ID_CANCEL_EDIT_SRVR             32769
#define ID_PAGE_SETUP                   32771
#define ID_VIEW_OPTIONS                 32776
#define ID_INSERT_BULLET                32777
#define ID_INSERT_DATE_TIME             32778
#define ID_FORMAT_PARAGRAPH             32780
#define ID_FORMAT_TABS                  32781
#define ID_COLOR0                       32782
#define ID_COLOR1                       32783
#define ID_COLOR2                       32784
#define ID_COLOR3                       32785
#define ID_COLOR4                       32786
#define ID_COLOR5                       32787
#define ID_COLOR6                       32788
#define ID_COLOR7                       32789
#define ID_COLOR8                       32790
#define ID_COLOR9                       32791
#define ID_COLOR10                      32792
#define ID_COLOR11                      32793
#define ID_COLOR12                      32794
#define ID_COLOR13                      32795
#define ID_COLOR14                      32796
#define ID_COLOR15                      32797
#define ID_COLOR16                      32798
#define ID_CHAR_BOLD                    32799
#define ID_CHAR_ITALIC                  32800
#define ID_CHAR_COLOR                   32801
#define ID_CHAR_UNDERLINE               32802
#define ID_PARA_LEFT                    32803
#define ID_PARA_CENTER                  32804
#define ID_PARA_RIGHT                   32805
#define ID_PEN_PERIOD                   32807
#define ID_PEN_SPACE                    32808
#define ID_PEN_BACKSPACE                32809
#define ID_PEN_NEWLINE                  32810
#define ID_OLE_VERB_POPUP               32811
#define ID_PEN_TOGGLE                   32812
#define ID_PEN_LENS                     32813
#define ID_PEN_TAB                      32814
#define ID_VIEW_FORMATBAR               59396
#define ID_VIEW_RULER                   59397
#define ID_DELAYED_INVALIDATE           59398

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        172
#define _APS_NEXT_COMMAND_VALUE         32816
#define _APS_NEXT_CONTROL_VALUE         1033
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\srvritem.cpp ===
// srvritem.cpp : implementation of the CWordPadSrvrItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "srvritem.h"
#include <limits.h>

IMPLEMENT_DYNAMIC(CEmbeddedItem, COleServerItem)

extern CLIPFORMAT cfRTF;

CEmbeddedItem::CEmbeddedItem(CWordPadDoc* pContainerDoc, int nBeg, int nEnd)
	: COleServerItem(pContainerDoc, TRUE)
{
	ASSERT(pContainerDoc != NULL);
	ASSERT_VALID(pContainerDoc);
	m_nBeg = nBeg;
	m_nEnd = nEnd;
}

CWordPadView* CEmbeddedItem::GetView() const
{
	CDocument* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	POSITION pos = pDoc->GetFirstViewPosition();
	if (pos == NULL)
		return NULL;

	CWordPadView* pView = (CWordPadView*)pDoc->GetNextView(pos);
	ASSERT_VALID(pView);
	ASSERT(pView->IsKindOf(RUNTIME_CLASS(CWordPadView)));
	return pView;
}

void CEmbeddedItem::Serialize(CArchive& ar)
{
	if (m_lpRichDataObj != NULL)
	{
		ASSERT(ar.IsStoring());
		FORMATETC etc = {NULL, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
		etc.cfFormat = (CLIPFORMAT)cfRTF;
		STGMEDIUM stg;
		if (SUCCEEDED(m_lpRichDataObj->GetData(&etc, &stg)))
		{
			LPBYTE p = (LPBYTE)GlobalLock(stg.hGlobal);
			if (p != NULL)
			{
				ar.Write(p, GlobalSize(stg.hGlobal));
				GlobalUnlock(stg.hGlobal);
			}
			ASSERT(stg.tymed == TYMED_HGLOBAL);
			ReleaseStgMedium(&stg);
		}
	}
	else
		GetDocument()->Serialize(ar);
}

BOOL CEmbeddedItem::OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize)
{
	if (dwDrawAspect != DVASPECT_CONTENT)
		return COleServerItem::OnGetExtent(dwDrawAspect, rSize);

	CClientDC dc(NULL);
	return OnDrawEx(&dc, rSize, FALSE);
}

BOOL CEmbeddedItem::OnDraw(CDC* pDC, CSize& rSize)
{
	return OnDrawEx(pDC, rSize, TRUE);
}

BOOL CEmbeddedItem::OnDrawEx(CDC* pDC, CSize& rSize, BOOL bOutput)
{
	CDisplayIC dc;
	CWordPadView* pView = GetView();
	if (pView == NULL)
		return FALSE;
	ASSERT_VALID(pView);

	int nWrap = pView->m_nWordWrap;

	CRect rect;//rect in twips
	rect.left = rect.top = 0;
	rect.bottom = 32767; // bottomless

	rect.right = 32767;
	if (nWrap == 0) // no word wrap
		rect.right = 32767;
	else if (nWrap == 1) // wrap to window
	{
		CRect rectClient;
		pView->GetClientRect(&rectClient);
		rect.right = rectClient.right - HORZ_TEXTOFFSET;
		rect.right = MulDiv(rect.right, 1440, dc.GetDeviceCaps(LOGPIXELSX));
	}
	else if (nWrap == 2) // wrap to ruler
		rect.right = pView->GetPrintWidth();
                 
	// first just determine the correct extents of the text
	pDC->SetBkMode(TRANSPARENT);
	
	if (pView->PrintInsideRect(pDC, rect, m_nBeg, m_nEnd, FALSE) == 0)
	{
		// default to 12pts high and 4" wide if no text
		rect.bottom = rect.top+12*20+1; // 12 pts high
		rect.right = rect.left+ 4*1440;
	}
	rect.bottom+=3*(1440/dc.GetDeviceCaps(LOGPIXELSX)); // three pixels

	// then, really output the text
	CRect rectOut = rect; // don't pass rect because it will get clobbered
	if (bOutput)
		pView->PrintInsideRect(pDC, rectOut, m_nBeg, m_nEnd, TRUE);
	ASSERT(rectOut.right == rect.right);

	// adjust for border (rect.left is already adjusted)
	if (pView->GetStyle() & WS_HSCROLL)
		++rect.bottom;  // account for border on scroll bar!

	// return HIMETRIC size
	rSize = rect.Size();
	rSize.cx = MulDiv(rSize.cx, 2540, 1440); // convert twips to HIMETRIC
	rSize.cy = MulDiv(rSize.cy, 2540, 1440); // convert twips to HIMETRIC
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\unitspag.cpp ===
// unitspag.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "unitspag.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CUnitsPage dialog

const DWORD CUnitsPage::m_nHelpIDs[] = 
{
	IDC_BOX, IDH_COMM_GROUPBOX,
	IDC_UNITS_IN, IDH_WORDPAD_INCHES,
	IDC_UNITS_CM, IDH_WORDPAD_CENTIMETERS,
	IDC_UNITS_PT, IDH_WORDPAD_POINTS,
	IDC_UNITS_PI, IDH_WORDPAD_PICAS,
	IDC_WORDSEL, IDH_WORDPAD_OPTIONS_AUTOWORDSEL,
 	0, 0
};

CUnitsPage::CUnitsPage() : CCSPropertyPage(CUnitsPage::IDD)
{
	//{{AFX_DATA_INIT(CUnitsPage)
	m_nUnits = -1;
	m_bWordSel = FALSE;
	//}}AFX_DATA_INIT
}


void CUnitsPage::DoDataExchange(CDataExchange* pDX)
{
	CCSPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CUnitsPage)
	DDX_Radio(pDX, IDC_UNITS_IN, m_nUnits);
	DDX_Check(pDX, IDC_WORDSEL, m_bWordSel);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CUnitsPage, CCSPropertyPage)
	//{{AFX_MSG_MAP(CUnitsPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CUnitsPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\wordpad.h ===
// wordpad.h : main header file for the WORDPAD application
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "options.h"
#include "afxtempl.h"

#define WPM_BARSTATE WM_USER

#define WORDPAD_HELP_FILE TEXT("WORDPAD.HLP")

/////////////////////////////////////////////////////////////////////////////
// CWordPadApp:
// See wordpad.cpp for the implementation of this class
//

class CWordPadCommandLineInfo : public CCommandLineInfo
{
public:
	CWordPadCommandLineInfo() {m_bForceTextMode = FALSE;}
	BOOL m_bForceTextMode;
	virtual void ParseParam(const char* pszParam,BOOL bFlag,BOOL bLast);
};

class CWordPadApp : public CWinApp
{
private:

    enum InitializationPhase
    {
        InitializationPending       = 0,
        InitializingPrinter         = 1,
        UpdatingPrinterRelatedUI    = 2,
        UpdatingRegistry            = 3,
        InitializationComplete      = 99
    };

public:
	CWordPadApp();
	~CWordPadApp();

//Attributes
	CWordPadCommandLineInfo cmdInfo;
	CDC m_dcScreen;
	LOGFONT m_lf;
	int m_nDefFont;
	static int m_nOpenMsg;
	static int m_nPrinterChangedMsg;
   static int m_nOLEHelpMsg;
	CRect m_rectPageMargin;
	CRect m_rectInitialFrame;
	BOOL m_bMaximized;
	BOOL m_bPromptForType;
	BOOL m_bWin4;
#ifndef _UNICODE
	BOOL m_bWin31;
#endif
	BOOL m_bLargeIcons;
	BOOL m_bForceTextMode;
	BOOL m_bWordSel;
	BOOL m_bForceOEM;
	int m_nFilterIndex;
	int m_nNewDocType;
	CDocOptions m_optionsText;
	CDocOptions m_optionsRTF;
	CDocOptions m_optionsWord; //wrap to ruler
	CDocOptions m_optionsWrite; //wrap to ruler
	CDocOptions m_optionsIP;	//wrap to ruler
	CDocOptions m_optionsNull;
	CList<HWND, HWND> m_listPrinterNotify;

	BOOL IsDocOpen(LPCTSTR lpszFileName);

// Get
	int GetUnits() {return m_nUnits;}
	int GetTPU() { return GetTPU(m_nUnits);}
	int GetTPU(int n) { return m_units[n].m_nTPU;}
	LPCTSTR GetAbbrev() { return m_units[m_nUnits].m_strAbbrev;}
	LPCTSTR GetAbbrev(int n) { return m_units[n].m_strAbbrev;}
	const CUnit& GetUnit() {return m_units[m_nUnits];}
	CDockState& GetDockState(int nDocType, BOOL bPrimary = TRUE);
	CDocOptions& GetDocOptions(int nDocType);

// Set
	void SetUnits(int n)
	{ ASSERT(n>=0 && n <m_nPrimaryNumUnits); m_nUnits = n; }

// Operations
	void RegisterFormats();
	static BOOL CALLBACK StaticEnumProc(HWND hWnd, LPARAM lParam);
	void UpdateRegistry();
	void NotifyPrinterChanged(BOOL bUpdatePrinterSelection = FALSE);
	BOOL PromptForFileName(CString& fileName, UINT nIDSTitle, DWORD dwFlags,
		BOOL bOpenFileDialog, int* pType = NULL);

	BOOL ParseMeasurement(TCHAR* buf, int& lVal);
	void PrintTwips(TCHAR* buf, int nValue, int nDecimal);
	void SaveOptions();
	void LoadOptions();
	void LoadAbbrevStrings();
	HGLOBAL CreateDevNames();
    void EnsurePrinterIsInitialized();

   HGLOBAL GetDevNames(void)
   {
       return m_hDevNames ;
   }

// Overrides
	BOOL IsIdleMessage(MSG* pMsg);
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWordPadApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	virtual BOOL OnDDECommand(LPTSTR lpszCommand);
	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
	COleTemplateServer m_server;
		// Server object for document creation

	//{{AFX_MSG(CWordPadApp)
	afx_msg void OnAppAbout();
	afx_msg void OnFileNew();
	afx_msg void OnFileOpen();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	int m_nUnits;
	static const int m_nPrimaryNumUnits;
	static const int m_nNumUnits;
	static CUnit m_units[];

// Initialization

    volatile InitializationPhase m_initialization_phase;
    CWinThread *                 m_pInitializationThread;

    static UINT AFX_CDECL DoDeferredInitialization(LPVOID pvWordPadApp);
};

/////////////////////////////////////////////////////////////////////////////

extern CWordPadApp theApp;
//inline CWordPadApp* GetWordPadApp() {return (CWordPadApp*)AfxGetApp();}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\wordpdoc.cpp ===
// wordpdoc.cpp : implementation of the CWordPadDoc class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "wordpad.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "cntritem.h"
#include "srvritem.h"
#include "formatba.h"

#include "mainfrm.h"
#include "ipframe.h"
#include "buttondi.h"
#include "helpids.h"
#include "strings.h"
#include "unitspag.h"
#include "docopt.h"
#include "optionsh.h"

#include "multconv.h"

#include "fixhelp.h"

BOOL AskAboutFormatLoss(CWordPadDoc *pDoc) ;

//
// These defines are from ..\shell\userpri\uconvert.h
//

#define REVERSE_BYTE_ORDER_MARK   0xFFFE
#define BYTE_ORDER_MARK           0xFEFF

BOOL CheckForUnicodeTextFile(LPCTSTR lpszPathName) ;


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern BOOL AFXAPI AfxFullPath(LPTSTR lpszPathOut, LPCTSTR lpszFileIn);
extern UINT AFXAPI AfxGetFileTitle(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);

#ifndef OFN_EXPLORER
#define OFN_EXPLORER 0x00080000L
#endif
/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc
IMPLEMENT_DYNCREATE(CWordPadDoc, CRichEdit2Doc)

BEGIN_MESSAGE_MAP(CWordPadDoc, CRichEdit2Doc)
	//{{AFX_MSG_MAP(CWordPadDoc)
	ON_COMMAND(ID_VIEW_OPTIONS, OnViewOptions)
	ON_UPDATE_COMMAND_UI(ID_OLE_VERB_POPUP, OnUpdateOleVerbPopup)
	ON_COMMAND(ID_FILE_SEND_MAIL, OnFileSendMail)
	ON_UPDATE_COMMAND_UI(ID_FILE_NEW, OnUpdateIfEmbedded)
	ON_UPDATE_COMMAND_UI(ID_FILE_OPEN, OnUpdateIfEmbedded)
	ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateIfEmbedded)
	ON_UPDATE_COMMAND_UI(ID_FILE_PRINT, OnUpdateIfEmbedded)
	ON_UPDATE_COMMAND_UI(ID_FILE_PRINT_DIRECT, OnUpdateIfEmbedded)
	ON_UPDATE_COMMAND_UI(ID_FILE_PRINT_PREVIEW, OnUpdateIfEmbedded)
	//}}AFX_MSG_MAP
	ON_UPDATE_COMMAND_UI(ID_FILE_SEND_MAIL, OnUpdateFileSendMail)
	ON_COMMAND(ID_OLE_EDIT_LINKS, OnEditLinks)
	ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, CRichEdit2Doc::OnUpdateObjectVerbMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, CRichEdit2Doc::OnUpdateObjectVerbMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, CRichEdit2Doc::OnUpdateEditLinksMenu)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc construction/destruction

CWordPadDoc::CWordPadDoc()
{
	m_nDocType = -1;
	m_nNewDocType = -1;
}

BOOL CWordPadDoc::OnNewDocument()
{
	if (!CRichEdit2Doc::OnNewDocument())
		return FALSE;

 	//correct type already set in theApp.m_nNewDocType;
 	int nDocType = (IsEmbedded()) ? RD_EMBEDDED : theApp.m_nNewDocType;

	GetView()->SetDefaultFont(IsTextType(nDocType));
	SetDocType(nDocType);

	return TRUE;
}

void CWordPadDoc::ReportSaveLoadException(LPCTSTR lpszPathName,
	CException* e, BOOL bSaving, UINT nIDP)
{
	if (!m_bDeferErrors && e != NULL)
	{
		ASSERT_VALID(e);
		if (e->IsKindOf(RUNTIME_CLASS(CFileException)))
		{
			switch (((CFileException*)e)->m_cause)
			{
			case CFileException::fileNotFound:
			case CFileException::badPath:
				nIDP = AFX_IDP_FAILED_INVALID_PATH;
				break;
			case CFileException::diskFull:
				nIDP = AFX_IDP_FAILED_DISK_FULL;
				break;
			case CFileException::accessDenied:
                nIDP = AFX_IDP_FILE_ACCESS_DENIED;

				if (((CFileException*)e)->m_lOsError == ERROR_WRITE_PROTECT)
					nIDP = IDS_WRITEPROTECT;
				break;
			case CFileException::tooManyOpenFiles:
				nIDP = IDS_TOOMANYFILES;
				break;
			case CFileException::directoryFull:
				nIDP = IDS_DIRFULL;
				break;
			case CFileException::sharingViolation:
				nIDP = IDS_SHAREVIOLATION;
				break;
			case CFileException::lockViolation:
			case CFileException::badSeek:
			case CFileException::generic:
			case CFileException::invalidFile:
			case CFileException::hardIO:
				nIDP = bSaving ? AFX_IDP_FAILED_IO_ERROR_WRITE :
						AFX_IDP_FAILED_IO_ERROR_READ;
				break;
			default:
				break;
			}
			CString prompt;
			AfxFormatString1(prompt, nIDP, lpszPathName);
			AfxMessageBox(prompt, MB_ICONEXCLAMATION, nIDP);
			return;
		}
	}
	CRichEdit2Doc::ReportSaveLoadException(lpszPathName, e, bSaving, nIDP);
	return;
}


BOOL CheckForUnicodeTextFile(LPCTSTR lpszPathName)
{
    BOOL fRet = FALSE ;
    HANDLE hFile = (HANDLE) 0 ;
    WORD wBOM ;
    DWORD dwBytesRead = 0 ;
    BOOL bTmp ;

    if (lpszPathName == NULL)
    {
       return FALSE ;
    }

    hFile = CreateFile(
                lpszPathName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL) ;

    if (hFile == INVALID_HANDLE_VALUE)
    {
       return FALSE ;
    }

    bTmp = ReadFile(
               hFile,
               &wBOM,
               sizeof(WORD),
               &dwBytesRead,
               NULL) ;

    if (bTmp)
    {
        if (dwBytesRead == sizeof(WORD))
        {
            if ( (wBOM == BYTE_ORDER_MARK) ||
                 (wBOM == REVERSE_BYTE_ORDER_MARK) )
            {
                fRet = TRUE ;

            }
        }
    }

    CloseHandle(hFile) ;

    return fRet ;
}

BOOL CWordPadDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
    if (m_lpRootStg != NULL) // we are embedded
	{
		// we really want to use the converter on this storage
		m_nNewDocType = RD_EMBEDDED;
	}
	else
	{            
		if (theApp.cmdInfo.m_bForceTextMode)
			m_nNewDocType = RD_TEXT;
		else
		{
			CFileException fe;
			m_nNewDocType = GetDocTypeFromName(lpszPathName, fe);
			if (m_nNewDocType == -1)
			{
				ReportSaveLoadException(lpszPathName, &fe, FALSE,
					AFX_IDP_FAILED_TO_OPEN_DOC);
				return FALSE;
			}

            if (RD_FEWINWORD5 == m_nNewDocType)
            {
                AfxMessageBox(IDS_FEWINWORD5_DOC, MB_OK, MB_ICONINFORMATION);
                return FALSE;
            }

			if (m_nNewDocType == RD_TEXT && theApp.m_bForceOEM)
				m_nNewDocType = RD_OEMTEXT;
		}
		ScanForConverters();
		if (!doctypes[m_nNewDocType].bRead)
		{
			CString str;
			CString strName = doctypes[m_nNewDocType].GetString(DOCTYPE_DOCTYPE);
			AfxFormatString1(str, IDS_CANT_LOAD, strName);
			AfxMessageBox(str, MB_OK|MB_ICONINFORMATION);
			return FALSE;
		}
	}

    if (RD_TEXT == m_nNewDocType)
    {
        if (CheckForUnicodeTextFile(lpszPathName))
            m_nNewDocType = RD_UNICODETEXT;
    }

	if (!CRichEdit2Doc::OnOpenDocument(lpszPathName))
		return FALSE;

    // Update any Ole links

    COleUpdateDialog(this).DoModal();

	return TRUE;
}

void CWordPadDoc::Serialize(CArchive& ar)
{
	COleMessageFilter* pFilter = AfxOleGetMessageFilter();
	ASSERT(pFilter != NULL);
	pFilter->EnableBusyDialog(FALSE);

	if (ar.IsLoading())
		SetDocType(m_nNewDocType);

    //
    // Strip (or output) the byte order mark if this is a Unicode file
    //

    if (m_bUnicode)
    {
        if (ar.IsLoading())
        {
            WORD byte_order_mark;

            ar >> byte_order_mark;

            // No support for byte-reversed files

            ASSERT(BYTE_ORDER_MARK == byte_order_mark);
        }
        else
        {
            ar << (WORD) BYTE_ORDER_MARK;
        }
    }   

	CRichEdit2Doc::Serialize(ar);
	pFilter->EnableBusyDialog(TRUE);
}



BOOL AskAboutFormatLoss(CWordPadDoc *pDoc)
{
    return (IDYES == AfxMessageBox(IDS_SAVE_FORMAT_TEXT, MB_YESNO));
}

BOOL CWordPadDoc::DoSave(LPCTSTR pszPathName, BOOL bReplace /*=TRUE*/)
	// Save the document data to a file
	// pszPathName = path name where to save document file
	// if pszPathName is NULL then the user will be prompted (SaveAs)
	// note: pszPathName can be different than 'm_strPathName'
	// if 'bReplace' is TRUE will change file name if successful (SaveAs)
	// if 'bReplace' is FALSE will not change path name (SaveCopyAs)
{
	CString newName = pszPathName;
	int nOrigDocType = m_nDocType;  //saved in case of SaveCopyAs or failure
   int nDocType ;
   int nRes ;

	//	newName		bWrite	type	result
	//	empty		TRUE	-		SaveAs dialog
	//	empty		FALSE	-		SaveAs dialog
	//	notempty	TRUE	-		nothing
	//	notempty	FALSE	W6		warn (change to wordpad, save as, cancel)
	//	notempty	FALSE	other	warn (save as, cancel)

	BOOL bModified = IsModified();

	ScanForConverters();

	BOOL bSaveAs = FALSE;

	if (newName.IsEmpty())
		bSaveAs = TRUE;

	else if (!doctypes[m_nDocType].bWrite)
	{
		if (m_nDocType == RD_WINWORD6)
		{
			nRes = CButtonDialog::DisplayMessageBox(
				MAKEINTRESOURCE(IDS_WORD_WARNING), AfxGetAppName(),
				MAKEINTRESOURCE(IDS_WORD_WARNING_BUTTONS),
				MB_ICONQUESTION, 1, 2);

			if (nRes == 0) // Save
				SetDocType(RD_WORDPAD, TRUE);
			else if (nRes == 2) // Cancel
				return FALSE;
			else
				bSaveAs = TRUE;
			// else save as
		}
        else if (m_nDocType == RD_WORD97)
        {
            //
            // We can't save Word97 files.  Ask the user if they want to
            // save in a different format
            //

            nRes = AfxMessageBox(IDS_WORD97_WARNING, MB_OKCANCEL);

            if (IDOK == nRes)
                bSaveAs = TRUE;
            else
                return FALSE;
        }
		else //
		{
			if (AfxMessageBox(IDS_SAVE_UNSUPPORTED,
				MB_YESNO | MB_ICONQUESTION) != IDYES)
			{
				return FALSE;
			}
			else
				bSaveAs = TRUE;
		}
	}

	if (m_lpRootStg == NULL && IsTextType(m_nDocType) &&
		!bSaveAs && !GetView()->IsFormatText())
	{
        if (!AskAboutFormatLoss(this))
            bSaveAs = TRUE;
	}

	GetView()->GetParentFrame()->RecalcLayout();

	if (bSaveAs)
	{
      newName = m_strPathName;

		if (bReplace && newName.IsEmpty())
		{
			newName = m_strTitle;
			int iBad = newName.FindOneOf(_T(" #%;/\\"));    // dubious filename
			if (iBad != -1)
				newName.ReleaseBuffer(iBad);

			// append the default suffix if there is one
			newName += GetExtFromType(m_nDocType);
		}

		nDocType = m_nDocType;

promptloop:

		if (!theApp.PromptForFileName(newName,
			bReplace ? AFX_IDS_SAVEFILE : AFX_IDS_SAVEFILECOPY,
			OFN_HIDEREADONLY | OFN_PATHMUSTEXIST, FALSE, &nDocType))
		{
			SetDocType(nOrigDocType, TRUE);
			return FALSE;       // don't even try to save
		}
      else
      {
          //
          // If we are transitioning from non-text to text, we need
          // to warn the user if there is any formatting / graphics
          // that will be lost
          //

          if (IsTextType(nDocType))
          {
              if (m_lpRootStg == NULL && !GetView()->IsFormatText())
              {
                if (!AskAboutFormatLoss(this))
                    goto promptloop;
              }
          }
      }

		SetDocType(nDocType, TRUE);
	}

	BeginWaitCursor();

	if (!OnSaveDocument(newName))
	{
		if (pszPathName == NULL)
		{
			// be sure to delete the file
			TRY
			{
				CFile::Remove(newName);
			}
			CATCH_ALL(e)
			{
				TRACE0("Warning: failed to delete file after failed SaveAs\n");
			}
			END_CATCH_ALL
		}
		// restore orginal document type
		SetDocType(nOrigDocType, TRUE);
		EndWaitCursor();
		return FALSE;
	}

	EndWaitCursor();
	if (bReplace)
	{
		int nType = m_nDocType;
		SetDocType(nOrigDocType, TRUE);
		SetDocType(nType);
		// Reset the title and change the document name
		SetPathName(newName, TRUE);
		ASSERT(m_strPathName == newName);       // must be set
	}
	else // SaveCopyAs
	{
		SetDocType(nOrigDocType, TRUE);
		SetModifiedFlag(bModified);
	}
	return TRUE;        // success
}


class COIPF : public COleIPFrameWnd
{
public:
	CFrameWnd* GetMainFrame() { return m_pMainFrame;}
	CFrameWnd* GetDocFrame() { return m_pDocFrame;}
};

void CWordPadDoc::OnDeactivateUI(BOOL bUndoable)
{
	if (GetView()->m_bDelayUpdateItems)
		UpdateAllItems(NULL);
	SaveState(m_nDocType);
	CRichEdit2Doc::OnDeactivateUI(bUndoable);
	COIPF* pFrame = (COIPF*)m_pInPlaceFrame;
	if (pFrame != NULL)
	{
		if (pFrame->GetMainFrame() != NULL)
			ForceDelayed(pFrame->GetMainFrame());
		if (pFrame->GetDocFrame() != NULL)
			ForceDelayed(pFrame->GetDocFrame());
	}
}

void CWordPadDoc::ForceDelayed(CFrameWnd* pFrameWnd)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pFrameWnd);

	POSITION pos = pFrameWnd->m_listControlBars.GetHeadPosition();
	while (pos != NULL)
	{
		// show/hide the next control bar
		CControlBar* pBar =
			(CControlBar*)pFrameWnd->m_listControlBars.GetNext(pos);

		BOOL bVis = pBar->GetStyle() & WS_VISIBLE;
		UINT swpFlags = 0;
		if ((pBar->m_nStateFlags & CControlBar::delayHide) && bVis)
			swpFlags = SWP_HIDEWINDOW;
		else if ((pBar->m_nStateFlags & CControlBar::delayShow) && !bVis)
			swpFlags = SWP_SHOWWINDOW;
		pBar->m_nStateFlags &= ~(CControlBar::delayShow|CControlBar::delayHide);
		if (swpFlags != 0)
		{
			pBar->SetWindowPos(NULL, 0, 0, 0, 0, swpFlags|
				SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc Attributes
CLSID CWordPadDoc::GetClassID()
{
	return (m_pFactory == NULL) ? CLSID_NULL : m_pFactory->GetClassID();
}

void CWordPadDoc::SetDocType(int nNewDocType, BOOL bNoOptionChange)
{
	ASSERT(nNewDocType != -1);
	if (nNewDocType == m_nDocType)
		return;

	m_bRTF = !IsTextType(nNewDocType);
    m_bUnicode = (nNewDocType == RD_UNICODETEXT);

	if (bNoOptionChange)
		m_nDocType = nNewDocType;
	else
	{
		SaveState(m_nDocType);
		m_nDocType = nNewDocType;
		RestoreState(m_nDocType);
	}
}

CWordPadView* CWordPadDoc::GetView()
{
	POSITION pos = GetFirstViewPosition();
	return (CWordPadView* )GetNextView( pos );
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc Operations

CFile* CWordPadDoc::GetFile(LPCTSTR pszPathName, UINT nOpenFlags, CFileException* pException)
{
	CTrackFile* pFile = NULL;
	CFrameWnd* pWnd = GetView()->GetParentFrame();
#ifdef CONVERTERS
	ScanForConverters();

	// if writing use current doc type otherwise use new doc type
	int nType = (nOpenFlags & CFile::modeReadWrite) ? m_nDocType : m_nNewDocType;
	// m_nNewDocType will be same as m_nDocType except when opening a new file
	if (doctypes[nType].pszConverterName != NULL)
		pFile = new CConverter(doctypes[nType].pszConverterName, pWnd);
	else
#endif
	if (nType == RD_OEMTEXT)
		pFile = new COEMFile(pWnd);
	else
		pFile = new CTrackFile(pWnd);
 	if (!pFile->Open(pszPathName, nOpenFlags, pException))
	{
 		delete pFile;
		return NULL;
	}
	if (nOpenFlags & (CFile::modeWrite | CFile::modeReadWrite))
		pFile->m_dwLength = 0; // can't estimate this
	else
		pFile->m_dwLength = pFile->GetLength();
	return pFile;
}

CRichEdit2CntrItem* CWordPadDoc::CreateClientItem(REOBJECT* preo) const
{
	// cast away constness of this
	return new CWordPadCntrItem(preo, (CWordPadDoc*)this);
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc server implementation

COleServerItem* CWordPadDoc::OnGetEmbeddedItem()
{
	// OnGetEmbeddedItem is called by the framework to get the COleServerItem
	//  that is associated with the document.  It is only called when necessary.

	CEmbeddedItem* pItem = new CEmbeddedItem(this);
	ASSERT_VALID(pItem);
	return pItem;
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc serialization

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc diagnostics

#ifdef _DEBUG
void CWordPadDoc::AssertValid() const
{
	CRichEdit2Doc::AssertValid();
}

void CWordPadDoc::Dump(CDumpContext& dc) const
{
	CRichEdit2Doc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc commands

int CWordPadDoc::MapType(int nType)
{
	if (nType == RD_OEMTEXT || nType == RD_UNICODETEXT)
		nType = RD_TEXT;
	else if (!IsInPlaceActive() && nType == RD_EMBEDDED)
		nType = RD_RICHTEXT;
	return nType;
}

void CWordPadDoc::OnViewOptions()
{
	int nType = MapType(m_nDocType);
	int nFirstPage = 3;
	if (nType == RD_TEXT)
		nFirstPage = 1;
	else if (nType == RD_RICHTEXT)
		nFirstPage = 2;
	else if (nType == RD_WRITE)
		nFirstPage = 4;
	else if (nType == RD_EMBEDDED)
		nFirstPage = 5;

	SaveState(nType);

	COptionSheet sheet(IDS_OPTIONS, NULL, nFirstPage);

	if (sheet.DoModal() == IDOK)
	{
		CWordPadView* pView = GetView();
		if (theApp.m_bWordSel)
			pView->GetRichEditCtrl().SetOptions(ECOOP_OR, ECO_AUTOWORDSELECTION);
		else
		{
			pView->GetRichEditCtrl().SetOptions(ECOOP_AND,
				~(DWORD)ECO_AUTOWORDSELECTION);
		}
		RestoreState(nType);
	}
}

void CWordPadDoc::OnUpdateOleVerbPopup(CCmdUI* pCmdUI)
{
	pCmdUI->m_pParentMenu = pCmdUI->m_pMenu;
	CRichEdit2Doc::OnUpdateObjectVerbMenu(pCmdUI);
}

BOOL CWordPadDoc::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
	if (nCode == CN_COMMAND && nID == ID_OLE_VERB_POPUP)
		nID = ID_OLE_VERB_FIRST;	
	return CRichEdit2Doc::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

void CWordPadDoc::SaveState(int nType)
{
	if (nType == -1)
		return;
	nType = MapType(nType);
	CWordPadView* pView = GetView();
	if (pView != NULL)
	{
		CFrameWnd* pFrame = pView->GetParentFrame();
		ASSERT(pFrame != NULL);
		// save current state
		pFrame->SendMessage(WPM_BARSTATE, 0, nType);
		theApp.GetDocOptions(nType).m_nWordWrap = pView->m_nWordWrap;
	}
}

void CWordPadDoc::RestoreState(int nType)
{
	if (nType == -1)
		return;
	nType = MapType(nType);
	CWordPadView* pView = GetView();
	if (pView != NULL)
	{
		CFrameWnd* pFrame = pView->GetParentFrame();
		ASSERT(pFrame != NULL);
		// set new state
		pFrame->SendMessage(WPM_BARSTATE, 1, nType);
		int nWrapNew = theApp.GetDocOptions(nType).m_nWordWrap;
		if (pView->m_nWordWrap != nWrapNew)
		{
			pView->m_nWordWrap = nWrapNew;
			pView->WrapChanged();
		}
	}
}

void CWordPadDoc::OnCloseDocument()
{
	SaveState(m_nDocType);
	CRichEdit2Doc::OnCloseDocument();
}

void CWordPadDoc::PreCloseFrame(CFrameWnd* pFrameArg)
{
	CRichEdit2Doc::PreCloseFrame(pFrameArg);
	SaveState(m_nDocType);
}

void CWordPadDoc::OnFileSendMail()
{
	if (m_strTitle.Find('.') == -1)
	{
		// add the extension because the default extension will be wrong
		CString strOldTitle = m_strTitle;
		m_strTitle += GetExtFromType(m_nDocType);
		CRichEdit2Doc::OnFileSendMail();
		m_strTitle = strOldTitle;
	}
	else
		CRichEdit2Doc::OnFileSendMail();
}

void CWordPadDoc::OnUpdateIfEmbedded(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(!IsEmbedded());
}


void CWordPadDoc::OnEditLinks()
{
    g_fDisableStandardHelp = TRUE ;

    SetHelpFixHook() ;

    CRichEdit2Doc::OnEditLinks() ;

    RemoveHelpFixHook() ;

    g_fDisableStandardHelp = FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\wordpdoc.h ===
// wordpdoc.h : interface of the CWordPadDoc class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CFormatBar;
class CWordPadSrvrItem;
class CWordPadView;

class CWordPadDoc : public CRichEdit2Doc
{
protected: // create from serialization only
	CWordPadDoc();
	DECLARE_DYNCREATE(CWordPadDoc)

// Attributes
public:
	int m_nDocType;
	int m_nNewDocType;
	void SetDocType(int nDocType, BOOL bNoOptionChange = FALSE);
	CWordPadView* GetView();
	CLSID GetClassID();
	LPCTSTR GetSection();

// Operations
public:
	void SaveState(int nType);
	void RestoreState(int nType);
	virtual CFile* GetFile(LPCTSTR pszPathName, UINT nOpenFlags, 
		CFileException* pException);
	virtual BOOL DoSave(LPCTSTR pszPathName, BOOL bReplace = TRUE);
	int MapType(int nType);
	void ForceDelayed(CFrameWnd* pFrameWnd);

// Overrides
	virtual CRichEdit2CntrItem* CreateClientItem(REOBJECT* preo) const;
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual void Serialize(CArchive& ar);
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWordPadDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual void OnCloseDocument();
	virtual void ReportSaveLoadException(LPCTSTR lpszPathName, CException* e, BOOL bSaving, UINT nIDPDefault);
	protected:
	virtual COleServerItem* OnGetEmbeddedItem();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual void PreCloseFrame(CFrameWnd* pFrameArg);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CWordPadDoc)
	afx_msg void OnViewOptions();
	afx_msg void OnUpdateOleVerbPopup(CCmdUI* pCmdUI);
	afx_msg void OnFileSendMail();
	afx_msg void OnUpdateIfEmbedded(CCmdUI* pCmdUI);
	afx_msg void OnEditLinks();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\wordpad.cpp ===
// wordpad.cpp : Defines the class behaviors for the application.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"

#include "wordpad.h"
#include "mainfrm.h"
#include "ipframe.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "strings.h"
#include "key.h"
#include "filenewd.h"
#include <locale.h>
#include <winnls.h>
#include <winreg.h>
#include "fixhelp.h"
#if _WIN32_IE < 0x400
#undef _WIN32_IE
#define _WIN32_IE   0x0400
#endif
#include <shlobj.h>

#define szRichName "RICHED20"

extern BOOL AFXAPI AfxFullPath(LPTSTR lpszPathOut, LPCTSTR lpszFileIn);
static BOOL RegisterHelper(LPCTSTR* rglpszRegister, LPCTSTR* rglpszSymbols,
   BOOL bReplace);

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CLIPFORMAT cfEmbeddedObject;
CLIPFORMAT cfRTF;
CLIPFORMAT cfRTO;

int CWordPadApp::m_nOpenMsg = RegisterWindowMessage(_T("WordPadOpenMessage"));
int CWordPadApp::m_nPrinterChangedMsg = RegisterWindowMessage(_T("WordPadPrinterChanged"));
int CWordPadApp::m_nOLEHelpMsg = RegisterWindowMessage(SZOLEUI_MSG_HELP);

CUnit CWordPadApp::m_units[] =
{
//    TPU,  SmallDiv,MedDiv,LargeDiv,MinMove,szAbbrev,         bSpace
CUnit(1440, 180,     720,   1440,    90,     IDS_INCH1_ABBREV, FALSE),//"
CUnit(568,  142,     284,   568,     142,    IDS_CM_ABBREV,    TRUE),//cm's
CUnit(20,   120,     720,   720,     100,    IDS_POINT_ABBREV, TRUE),//points
CUnit(240,  240,     1440,  1440,    120,    IDS_PICA_ABBREV,  TRUE),//picas
CUnit(1440, 180,     720,   1440,    90,     IDS_INCH2_ABBREV, FALSE),//in
CUnit(1440, 180,     720,   1440,    90,     IDS_INCH3_ABBREV, FALSE),//inch
CUnit(1440, 180,     720,   1440,    90,     IDS_INCH4_ABBREV, FALSE),//inches

// Non-localized units

CUnit(1440, 180,     720,   1440,    90,     IDS_INCH1_NOLOC,  FALSE),//"
CUnit(1440, 180,     720,   1440,    90,     IDS_INCH2_NOLOC,  FALSE),//in
CUnit(1440, 180,     720,   1440,    90,     IDS_INCH3_NOLOC,  FALSE),//inch
CUnit(1440, 180,     720,   1440,    90,     IDS_INCH4_NOLOC,  FALSE),//inches
CUnit(568,  142,     284,   568,     142,    IDS_CM_NOLOC,     TRUE),//cm's
CUnit(20,   120,     720,   720,     100,    IDS_POINT_NOLOC,  TRUE),//points
CUnit(240,  240,     1440,  1440,    120,    IDS_PICA_NOLOC,   TRUE)//picas
};

const int CWordPadApp::m_nPrimaryNumUnits = 4;
const int CWordPadApp::m_nNumUnits = sizeof(m_units) / sizeof(m_units[0]);


/////////////////////////////////////////////////////////////////////////////
// CWordPadApp

BEGIN_MESSAGE_MAP(CWordPadApp, CWinApp)
   //{{AFX_MSG_MAP(CWordPadApp)
   ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
   ON_COMMAND(ID_FILE_NEW, OnFileNew)
   ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CWordPadCommandLineInfo::ParseParam(const char* pszParam,BOOL bFlag,BOOL bLast)
{
   if (bFlag)
   {
      if (lstrcmpA(pszParam, "t") == 0)
      {
         m_bForceTextMode = TRUE;
         return;
      }
   }
   CCommandLineInfo::ParseParam(pszParam, bFlag, bLast);
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadApp construction

CWordPadApp::CWordPadApp() 
      : m_optionsText(0), 
        m_optionsRTF(1),
        m_optionsWord(2), 
        m_optionsWrite(2), 
        m_optionsIP(2), 
        m_optionsNull(0),
        m_initialization_phase(InitializationPending),
        m_pInitializationThread(NULL)
{
// _tsetlocale(LC_ALL, _T(""));
   setlocale(LC_ALL, "");     // change made by t-stefb

   m_nFilterIndex = 1;
   DWORD dwVersion = ::GetVersion();
   m_bWin4 = (BYTE)dwVersion >= 4;
#ifndef _UNICODE
   m_bWin31 = (dwVersion > 0x80000000 && !m_bWin4);
#endif
   m_nDefFont = (m_bWin4) ? DEFAULT_GUI_FONT : ANSI_VAR_FONT;
   m_dcScreen.Attach(::GetDC(NULL));
   m_bLargeIcons = m_dcScreen.GetDeviceCaps(LOGPIXELSX) >= 120;
   m_bForceOEM = FALSE;
}

CWordPadApp::~CWordPadApp()
{
   if (m_dcScreen.m_hDC != NULL)
      ::ReleaseDC(NULL, m_dcScreen.Detach());

    delete m_pInitializationThread;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWordPadApp object

CWordPadApp theApp;

// Register the application's document templates.  Document templates
//  serve as the connection between documents, frame windows and views.
static CSingleDocTemplate DocTemplate(
      IDR_MAINFRAME,
      RUNTIME_CLASS(CWordPadDoc),
      RUNTIME_CLASS(CMainFrame),       // main SDI frame window
      RUNTIME_CLASS(CWordPadView));

// This identifier was generated to be statistically unique for your app.
// You may change it if you prefer to choose a specific identifier.
static const CLSID BASED_CODE clsid =
{ 0x73FDDC80L, 0xAEA9, 0x101A, { 0x98, 0xA7, 0x00, 0xAA, 0x00, 0x37, 0x49, 0x59} };

/////////////////////////////////////////////////////////////////////////////
// CWordPadApp initialization


BOOL CWordPadApp::InitInstance()
{
   ParseCommandLine(cmdInfo);

   if (::FindWindow(szWordPadClass, NULL) && IsDocOpen(cmdInfo.m_strFileName))
      return FALSE;

   SetRegistryKey(szRegKey);

   // The resistry stuff shouldn't be localized so just hardcode it

   if (NULL != m_pszProfileName)
        free((void *) m_pszProfileName);

   m_pszProfileName = _tcsdup(TEXT("Wordpad"));

   LoadOptions();

   Enable3dControls();
   if (!cmdInfo.m_bRunEmbedded)
   {
      switch (m_nCmdShow)
      {
         case SW_RESTORE:
         case SW_SHOW:
         case SW_SHOWDEFAULT:
         case SW_SHOWNA:
         case SW_SHOWNOACTIVATE:
         case SW_SHOWNORMAL:
         case SW_SHOWMAXIMIZED:
            if (m_bMaximized)
               m_nCmdShow = SW_SHOWMAXIMIZED;
            break;
      }
   }
   else
   {
      //Excel 4 will start OLE servers minimized
      m_nCmdShow = SW_SHOWNORMAL;
   }
   int nCmdShow = m_nCmdShow;

   LoadAbbrevStrings();

   m_pszHelpFilePath = _tcsdup(WORDPAD_HELP_FILE) ;

   // Initialize OLE libraries
   if (!AfxOleInit())
   {
      AfxMessageBox(IDP_OLE_INIT_FAILED);
      return FALSE;
   }
   RegisterFormats();

   // Initialize RichEdit control
   if (LoadLibrary(_T(szRichName)) == NULL)
   {
      AfxMessageBox(IDS_RICHED_LOAD_FAIL, MB_OK|MB_ICONEXCLAMATION);
      return FALSE;
   }

   // Standard initialization
   // If you are not using these features and wish to reduce the size
   //  of your final executable, you should remove from the following
   //  the specific initialization routines you do not need.

   LoadStdProfileSettings();  // Load standard INI file options (including MRU)

   // Register the application's document templates.  Document templates
   //  serve as the connection between documents, frame windows and views.

   DocTemplate.SetContainerInfo(IDR_CNTR_INPLACE);
   DocTemplate.SetServerInfo(
      IDR_SRVR_EMBEDDED, IDR_SRVR_INPLACE,
      RUNTIME_CLASS(CInPlaceFrame));

   // Connect the COleTemplateServer to the document template.
   //  The COleTemplateServer creates new documents on behalf
   //  of requesting OLE containers by using information
   //  specified in the document template.
   m_server.ConnectTemplate(clsid, &DocTemplate, TRUE);


    //
    // Setup deferred initialization now so the printer can start
    // initializing in case we get a print or printto command at startup
    //

    m_pInitializationThread = AfxBeginThread(
                                    DoDeferredInitialization,
                                    this,
                                    THREAD_PRIORITY_IDLE,
                                    0,
                                    CREATE_SUSPENDED);

    if (NULL != m_pInitializationThread)
    {
        m_pInitializationThread->m_bAutoDelete = FALSE;
        m_pInitializationThread->ResumeThread();
    }

   // Check to see if launched as OLE server
   if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
   {
      // Register all OLE server (factories) as running.  This enables the
      //  OLE libraries to create objects from other applications.
      COleTemplateServer::RegisterAll();
      AfxOleSetUserCtrl(FALSE);

      // Application was run with /Embedding or /Automation.  Don't show the
      //  main window in this case.
      return TRUE;
   }

   // make sure the main window is showing
   m_bPromptForType = FALSE;
   OnFileNew();
   m_bPromptForType = TRUE;
   m_nCmdShow = -1;
   if (m_pMainWnd == NULL) // i.e. OnFileNew failed
      return FALSE;

   if (!cmdInfo.m_strFileName.IsEmpty())  // open an existing document
      m_nCmdShow = nCmdShow;
   // Dispatch commands specified on the command line
   if (cmdInfo.m_nShellCommand != CCommandLineInfo::FileNew &&
      !ProcessShellCommand(cmdInfo))
   {
      return FALSE;
   }

   // Enable File Manager drag/drop open
   m_pMainWnd->DragAcceptFiles();

    //
    // Set the current directory to "My Documents" so that will be the default
    // location for the first save/open
    //

    TCHAR szDefaultPath[MAX_PATH];

    if (SHGetSpecialFolderPath(NULL, szDefaultPath, CSIDL_PERSONAL, FALSE))
        SetCurrentDirectory(szDefaultPath);

    return TRUE;
}

BOOL CWordPadApp::IsDocOpen(LPCTSTR lpszFileName)
{
   if (lpszFileName[0] == NULL)
      return FALSE;
   TCHAR szPath[_MAX_PATH];
   AfxFullPath(szPath, lpszFileName);
   ATOM atom = GlobalAddAtom(szPath);
   ASSERT(atom != NULL);
   if (atom == NULL)
      return FALSE;
   EnumWindows(StaticEnumProc, (LPARAM)&atom);
   if (atom == NULL)
      return TRUE;
   DeleteAtom(atom);
   return FALSE;
}

BOOL CALLBACK CWordPadApp::StaticEnumProc(HWND hWnd, LPARAM lParam)
{
   TCHAR szClassName[30];
   GetClassName(hWnd, szClassName, 30);
   if (lstrcmp(szClassName, szWordPadClass) != 0)
      return TRUE;

   ATOM* pAtom = (ATOM*)lParam;
   ASSERT(pAtom != NULL);
   DWORD dw = NULL;
   ::SendMessageTimeout(hWnd, m_nOpenMsg, NULL, (LPARAM)*pAtom,
      SMTO_ABORTIFHUNG, 500, &dw);
   if (dw)
   {
      ::SetForegroundWindow(hWnd);
      DeleteAtom(*pAtom);
      *pAtom = NULL;
      return FALSE;
   }           
   return TRUE;
}

void CWordPadApp::RegisterFormats()
{
   cfEmbeddedObject = (CLIPFORMAT)::RegisterClipboardFormat(_T("Embedded Object"));
   cfRTF = (CLIPFORMAT)::RegisterClipboardFormat(CF_RTF);
   cfRTO = (CLIPFORMAT)::RegisterClipboardFormat(CF_RETEXTOBJ);
}

CDocOptions& CWordPadApp::GetDocOptions(int nDocType)
{
   switch (nDocType)
   {
      case RD_WINWORD6:
      case RD_WORDPAD:
      case RD_WORD97:
         return m_optionsWord;
      case RD_RICHTEXT:
         return m_optionsRTF;
      case RD_TEXT:
      case RD_OEMTEXT:
      case RD_UNICODETEXT:
         return m_optionsText;
      case RD_WRITE:
         return m_optionsWrite;
      case RD_EMBEDDED:
         return m_optionsIP;
   }
   ASSERT(FALSE);
   return m_optionsNull;
}

CDockState& CWordPadApp::GetDockState(int nDocType, BOOL bPrimary)
{
   return GetDocOptions(nDocType).GetDockState(bPrimary);
}

void CWordPadApp::SaveOptions()
{
   WriteProfileInt(szSection, szWordSel, m_bWordSel);
   WriteProfileInt(szSection, szUnits, GetUnits());
   WriteProfileInt(szSection, szMaximized, m_bMaximized);
   WriteProfileBinary(szSection, szFrameRect, (BYTE*)&m_rectInitialFrame,
      sizeof(CRect));
   WriteProfileBinary(szSection, szPageMargin, (BYTE*)&m_rectPageMargin,
      sizeof(CRect));
   m_optionsText.SaveOptions(szTextSection);
   m_optionsRTF.SaveOptions(szRTFSection);
   m_optionsWord.SaveOptions(szWordSection);
   m_optionsWrite.SaveOptions(szWriteSection);
   m_optionsIP.SaveOptions(szIPSection);
}

void CWordPadApp::LoadOptions()
{
   BYTE* pb = NULL;
   UINT nLen = 0;

   HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
   if (hFont == NULL)
      hFont = (HFONT)GetStockObject(ANSI_VAR_FONT);
   VERIFY(GetObject(hFont, sizeof(LOGFONT), &m_lf));

   m_bWordSel = GetProfileInt(szSection, szWordSel, TRUE);
   TCHAR buf[2];
   buf[0] = NULL;
   GetLocaleInfo(GetUserDefaultLCID(), LOCALE_IMEASURE, buf, 2);
   int nDefUnits = buf[0] == _T('1') ? 0 : 1;
   SetUnits(GetProfileInt(szSection, szUnits, nDefUnits));
   m_bMaximized = GetProfileInt(szSection, szMaximized, (int)FALSE);

   if (GetProfileBinary(szSection, szFrameRect, &pb, &nLen))
   {
      ASSERT(nLen == sizeof(CRect));
      memcpy(&m_rectInitialFrame, pb, sizeof(CRect));
      delete pb;
   }
   else
      m_rectInitialFrame.SetRect(0,0,0,0);


   CRect rectScreen(0, 0, GetSystemMetrics(SM_CXSCREEN),
      GetSystemMetrics(SM_CYSCREEN));
   CRect rectInt;
   rectInt.IntersectRect(&rectScreen, &m_rectInitialFrame);
   if (rectInt.Width() < 10 || rectInt.Height() < 10)
      m_rectInitialFrame.SetRect(0, 0, 0, 0);

   if (GetProfileBinary(szSection, szPageMargin, &pb, &nLen))
   {
      ASSERT(nLen == sizeof(CRect));
      memcpy(&m_rectPageMargin, pb, sizeof(CRect));
      delete pb;
   }
   else
      m_rectPageMargin.SetRect(1800, 1440, 1800, 1440);  

   m_optionsText.LoadOptions(szTextSection);
   m_optionsRTF.LoadOptions(szRTFSection);
   m_optionsWord.LoadOptions(szWordSection);
   m_optionsWrite.LoadOptions(szWriteSection);
   m_optionsIP.LoadOptions(szIPSection);
}

void CWordPadApp::LoadAbbrevStrings()
{
   for (int i=0;i<m_nNumUnits;i++)
      m_units[i].m_strAbbrev.LoadString(m_units[i].m_nAbbrevID);
}

BOOL CWordPadApp::ParseMeasurement(LPTSTR buf, int& lVal)
{
   TCHAR* pch;
   if (buf[0] == NULL)
      return FALSE;
   float f = (float)_tcstod(buf,&pch);

   // eat white space, if any
   while (isspace(*pch))
      pch++;

   if (pch[0] == NULL) // default
   {
      lVal = (f < 0.f) ? (int)(f*GetTPU()-0.5f) : (int)(f*GetTPU()+0.5f);
      return TRUE;
   }
   for (int i=0;i<m_nNumUnits;i++)
   {
      if (lstrcmpi(pch, GetAbbrev(i)) == 0)
      {
         lVal = (f < 0.f) ? (int)(f*GetTPU(i)-0.5f) : (int)(f*GetTPU(i)+0.5f);
         return TRUE;
      }
   }
   return FALSE;
}

void CWordPadApp::PrintTwips(TCHAR* buf, int nValue, int nDec)
{
   ASSERT(nDec == 2);
   int div = GetTPU();
   int lval = nValue;
   BOOL bNeg = FALSE;
   
   int* pVal = new int[nDec+1];

   if (lval < 0)
   {
      bNeg = TRUE;
      lval = -lval;
   }

   for (int i=0;i<=nDec;i++)
   {
      pVal[i] = lval/div; //integer number
      lval -= pVal[i]*div;
      lval *= 10;
   }
   i--;
   if (lval >= div/2)
      pVal[i]++;

   while ((pVal[i] == 10) && (i != 0))
   {
      pVal[i] = 0;
      pVal[--i]++;
   }

   while (nDec && pVal[nDec] == 0)
      nDec--;

   _stprintf(buf, _T("%.*f"), nDec, (float)nValue/(float)div);

   if (m_units[m_nUnits].m_bSpaceAbbrev)
      lstrcat(buf, _T(" "));
   lstrcat(buf, GetAbbrev());
   delete []pVal;
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadApp commands

void CWordPadApp::OnAppAbout()
{
   CString strTitle;
   VERIFY(strTitle.LoadString(AFX_IDS_APP_TITLE));
   ShellAbout(m_pMainWnd->GetSafeHwnd(), strTitle, _T(""), LoadIcon(IDR_MAINFRAME));
}

int CWordPadApp::ExitInstance()
{
   FreeLibrary(GetModuleHandle(_T(szRichName)));
   SaveOptions();

   //
   // This tooltip code is a workaround for a bug in MFC 4.0.
   // It <should> be fixed in MFC 4.1.  When NT starts using
   // MFC 4.1 we can remove this.
   //

   _AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
   CToolTipCtrl* pToolTip = pThreadState->m_pToolTip;

   if (NULL != pToolTip)
   {
       pToolTip->DestroyWindow();
       delete pToolTip;
       pThreadState->m_pToolTip = NULL ;
   }

   return CWinApp::ExitInstance();
}

void CWordPadApp::OnFileNew()
{
   int nDocType = -1;
   if (!m_bPromptForType)
   {
      if (cmdInfo.m_bForceTextMode)
         nDocType = RD_TEXT;
      else if (!cmdInfo.m_strFileName.IsEmpty())
      {
         CFileException fe;
         nDocType = GetDocTypeFromName(cmdInfo.m_strFileName, fe);
      }
      if (nDocType == -1)
         nDocType = RD_DEFAULT;
   }
   else
   {
      CFileNewDialog dlg;
      if (dlg.DoModal() == IDCANCEL)
         return;

      nDocType = (dlg.m_nSel == 0) ? RD_DEFAULT:   //Word 6
               (dlg.m_nSel == 1) ? RD_RICHTEXT :   //RTF
               (dlg.m_nSel == 2) ? RD_TEXT :       //text
               RD_UNICODETEXT;

      if (nDocType != RD_TEXT)
         cmdInfo.m_bForceTextMode = FALSE;
   }
   m_nNewDocType = nDocType;
   DocTemplate.OpenDocumentFile(NULL);
      // if returns NULL, the user has already been alerted
}

// prompt for file name - used for open and save as
// static function called from app
BOOL CWordPadApp::PromptForFileName(CString& fileName, UINT nIDSTitle,
   DWORD dwFlags, BOOL bOpenFileDialog, int* pType)
{
   ScanForConverters();
   CFileDialog dlgFile(bOpenFileDialog);
   CString title;

   VERIFY(title.LoadString(nIDSTitle));
   
   dlgFile.m_ofn.Flags |= dwFlags;

   int nIndex = m_nFilterIndex;
   if (!bOpenFileDialog)
   {
      int nDocType = (pType != NULL) ? *pType : RD_DEFAULT;
      nIndex = GetIndexFromType(nDocType, bOpenFileDialog);
      if (nIndex == -1)
         nIndex = GetIndexFromType(RD_DEFAULT, bOpenFileDialog);
      if (nIndex == -1)
         nIndex = GetIndexFromType(RD_NATIVE, bOpenFileDialog);
      ASSERT(nIndex != -1);
      nIndex++;
   }
   dlgFile.m_ofn.nFilterIndex = nIndex;
   // strDefExt is necessary to hold onto the memory from GetExtFromType
   CString strDefExt = GetExtFromType(GetTypeFromIndex(nIndex-1, bOpenFileDialog));

   //
   // The open file dialog doesn't want the extension to start with '.' but
   // thats how GetExtFromType gives it to us.
   //

   dlgFile.m_ofn.lpstrDefExt = strDefExt;
   ASSERT(TEXT('.') == *dlgFile.m_ofn.lpstrDefExt);
   ++dlgFile.m_ofn.lpstrDefExt;

   CString strFilter = GetFileTypes(bOpenFileDialog);
   dlgFile.m_ofn.lpstrFilter = strFilter;
   dlgFile.m_ofn.lpstrTitle = title;
   dlgFile.m_ofn.lpstrFile = fileName.GetBuffer(_MAX_PATH);

   BOOL bRet = (dlgFile.DoModal() == IDOK) ? TRUE : FALSE;
   fileName.ReleaseBuffer();
   if (bRet)
   {
      if (bOpenFileDialog)
         m_nFilterIndex = dlgFile.m_ofn.nFilterIndex;
      if (pType != NULL)
      {
         int nIndex = (int)dlgFile.m_ofn.nFilterIndex - 1;
         ASSERT(nIndex >= 0);
         *pType = GetTypeFromIndex(nIndex, bOpenFileDialog);
      }
   }
   return bRet;
}

void CWordPadApp::OnFileOpen()
{
   // prompt the user (with all document templates)
   CString newName;
   int nType = RD_DEFAULT;
   if (!PromptForFileName(newName, AFX_IDS_OPENFILE,
     OFN_HIDEREADONLY | OFN_FILEMUSTEXIST, TRUE, &nType))
      return; // open cancelled

   if (nType == RD_OEMTEXT)
      m_bForceOEM = TRUE;
   OpenDocumentFile(newName);
   m_bForceOEM = FALSE;
   // if returns NULL, the user has already been alerted
}

BOOL CWordPadApp::OnDDECommand(LPTSTR /*lpszCommand*/)
{
   return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// DDE and ShellExecute support

//HKEY_CLASSES_ROOT\.RTF = rtffile
//HKEY_CLASSES_ROOT\rtffile =
//HKEY_CLASSES_ROOT\rtffile\CLSID = {73FDDC80-AEA9-101A-98A7-00AA00374959}
//HKEY_CLASSES_ROOT\rtffile\protocol\StdFileEditing\server = WORDPAD.EXE
//HKEY_CLASSES_ROOT\rtffile\protocol\StdFileEditing\verb\0 = &Edit
//HKEY_CLASSES_ROOT\rtffile\shell\open\command = WORDPAD.EXE %1
//HKEY_CLASSES_ROOT\rtffile\shell\print\command = WORDPAD.EXE /p %1

#define REGENTRY(key, value) _T(key) _T("\0\0") _T(value)
#define REGENTRYX(key, valuename, value) _T(key) _T("\0") _T(valuename) _T("\0") _T(value)

static const TCHAR sz00[] = REGENTRY("%2", "%5");
static const TCHAR sz01[] = REGENTRY("%2\\CLSID", "%1");
static const TCHAR sz02[] = REGENTRY("%2\\Insertable", "");
static const TCHAR sz03[] = REGENTRY("%2\\protocol\\StdFileEditing\\verb\\0", "&Edit");
static const TCHAR sz04[] = REGENTRY("%2\\protocol\\StdFileEditing\\server", "%3");
static const TCHAR sz05[] = REGENTRY("CLSID\\%1", "%5");
static const TCHAR sz06[] = REGENTRY("CLSID\\%1\\ProgID", "%2");
static const TCHAR sz07[] = REGENTRY("CLSID\\%1\\InprocHandler32", "ole32.dll");
static const TCHAR sz08[] = REGENTRY("CLSID\\%1\\LocalServer32", "%3");
static const TCHAR sz09[] = REGENTRY("CLSID\\%1\\Verb\\0", "&Edit,0,2");
static const TCHAR sz10[] = REGENTRY("CLSID\\%1\\Verb\\1", "&Open,0,2");
static const TCHAR sz11[] = REGENTRY("CLSID\\%1\\Insertable", "");
static const TCHAR sz12[] = REGENTRY("CLSID\\%1\\AuxUserType\\2", "%4");
static const TCHAR sz13[] = REGENTRY("CLSID\\%1\\AuxUserType\\3", "%6");
static const TCHAR sz14[] = REGENTRY("CLSID\\%1\\DefaultIcon", "%3,1");
static const TCHAR sz15[] = REGENTRY("CLSID\\%1\\MiscStatus", "0");
static const TCHAR sz16[] = REGENTRY("%2\\shell\\open\\command", "%3 \"%%1\"");
static const TCHAR sz17[] = REGENTRY("%2\\shell\\print\\command", "%3 /p \"%%1\"");
static const TCHAR sz18[] = REGENTRY("%7", "%2");
static const TCHAR sz19[] = REGENTRY("%2", ""); // like sz00 only no long type name
static const TCHAR sz20[] = REGENTRY("%2\\shell\\printto\\command", "%3 /pt \"%%1\" \"%%2\" \"%%3\" \"%%4\"");
static const TCHAR sz21[] = REGENTRY("%2\\DefaultIcon", "%3,%8");
static const TCHAR sz22[] = REGENTRYX("%7\\ShellNew", "NullFile", "true");
static const TCHAR sz23[] = REGENTRYX("%7\\ShellNew", "Data", "{\\rtf1}");

// %1 - class ID
// %2 - class name            WordPad.Document.1
// %3 - SFN executable path      C:\PROGRA~1\ACCESS~1\WORDPAD.EXE
// %4 - short type name       Document
// %5 - long type name        Microsoft WordPad Document
// %6 - long application name Microsoft WordPad
// %7 = extension          .rtf
// %8 = default icon       0,1,2,3
#define NUM_REG_ARGS 8

static const LPCTSTR rglpszWordPadRegister[] =
{sz00, sz02, sz03, sz05, sz09, sz10, sz11, sz15, NULL};

static const LPCTSTR rglpszWordPadOverwrite[] =
{sz01, sz04, sz06, sz07, sz08, sz12, sz13, sz14, sz16, sz17, sz20, NULL};

//static const LPCTSTR rglpszExtRegister[] =
//{sz00, sz18, NULL};

//static const LPCTSTR rglpszExtOverwrite[] =
//{sz01, sz16, sz17, sz21, NULL};

static const LPCTSTR rglpszWriExtRegister[] =
{sz18, NULL};
static const LPCTSTR rglpszWriRegister[] =
{sz00, sz01, sz16, sz17, sz20, sz21, NULL};

static const LPCTSTR rglpszRtfExtRegister[] =
{sz18, sz23, NULL};
static const LPCTSTR rglpszRtfRegister[] =
{sz00, sz01, sz16, sz17, sz20, sz21, NULL};

static const LPCTSTR rglpszTxtExtRegister[] =
{sz18, sz22, NULL};
static const LPCTSTR rglpszTxtRegister[] =
{sz00, sz01, sz16, sz17, sz20, sz21, NULL};

static const LPCTSTR rglpszDocExtRegister[] =
{sz18, sz22, NULL};
static const LPCTSTR rglpszDocRegister[] =
{sz00, sz01, sz16, sz17, sz20, sz21, NULL};

static void RegisterExt(LPCTSTR lpszExt, LPCTSTR lpszProgID, UINT nIDTypeName,
   LPCTSTR* rglpszSymbols, LPCTSTR* rglpszExtRegister,
   LPCTSTR* rglpszRegister, int nIcon)
{
   // don't overwrite anything with the extensions
   CString strWhole;
   VERIFY(strWhole.LoadString(nIDTypeName));
   CString str;
   AfxExtractSubString(str, strWhole, DOCTYPE_PROGID);

   rglpszSymbols[1] = lpszProgID;
   rglpszSymbols[4] = str;
   rglpszSymbols[6] = lpszExt;
   TCHAR buf[10];
   wsprintf(buf, _T("%d"), nIcon);
   rglpszSymbols[7] = buf;
   // check for .ext and progid
   CKey key;
   if (!key.Open(HKEY_CLASSES_ROOT, lpszExt)) // .ext doesn't exist
      RegisterHelper(rglpszExtRegister, rglpszSymbols, TRUE);
   key.Close();
   if (!key.Open(HKEY_CLASSES_ROOT, lpszProgID)) // ProgID doesn't exist (i.e. txtfile)
      RegisterHelper(rglpszRegister, rglpszSymbols, TRUE);
}

void CWordPadApp::UpdateRegistry()
{
   USES_CONVERSION;
   LPOLESTR lpszClassID = NULL;
   CDocTemplate* pDocTemplate = &DocTemplate;

   // get registration info from doc template string
   CString strServerName;
   CString strLocalServerName;
   CString strLocalShortName;

   if (!pDocTemplate->GetDocString(strServerName,
      CDocTemplate::regFileTypeId) || strServerName.IsEmpty())
   {
      TRACE0("Error: not enough information in DocTemplate to register OLE server.\n");
      return;
   }
   if (!pDocTemplate->GetDocString(strLocalServerName,
      CDocTemplate::regFileTypeName))
      strLocalServerName = strServerName;     // use non-localized name
   if (!pDocTemplate->GetDocString(strLocalShortName,
      CDocTemplate::fileNewName))
      strLocalShortName = strLocalServerName; // use long name

   ASSERT(strServerName.Find(' ') == -1);  // no spaces allowed

   ::StringFromCLSID(clsid, &lpszClassID);
   ASSERT (lpszClassID != NULL);

   // get path name to server
   TCHAR szLongPathName[_MAX_PATH];
   TCHAR szShortPathName[_MAX_PATH];
   ::GetModuleFileName(AfxGetInstanceHandle(), szLongPathName, _MAX_PATH);
   ::GetShortPathName(szLongPathName, szShortPathName, _MAX_PATH);
   
   LPCTSTR rglpszSymbols[NUM_REG_ARGS];
   rglpszSymbols[0] = OLE2CT(lpszClassID);
   rglpszSymbols[1] = strServerName;
   rglpszSymbols[2] = szShortPathName;
   rglpszSymbols[3] = strLocalShortName;
   rglpszSymbols[4] = strLocalServerName;
   rglpszSymbols[5] = m_pszAppName; // will usually be long, readable name
   rglpszSymbols[6] = NULL;

   if (RegisterHelper((LPCTSTR*)rglpszWordPadRegister, rglpszSymbols, FALSE))
      RegisterHelper((LPCTSTR*)rglpszWordPadOverwrite, rglpszSymbols, TRUE);

// RegisterExt(_T(".txt"), _T("txtfile"), IDS_TEXT_DOC, rglpszSymbols,
//    (LPCTSTR*)rglpszTxtExtRegister, (LPCTSTR*)rglpszTxtRegister, 3);
   RegisterExt(_T(".rtf"), _T("rtffile"), IDS_RICHTEXT_DOC, rglpszSymbols,
      (LPCTSTR*)rglpszRtfExtRegister, (LPCTSTR*)rglpszRtfRegister, 1);
   RegisterExt(_T(".wri"), _T("wrifile"), IDS_WRITE_DOC, rglpszSymbols,
      (LPCTSTR*)rglpszWriExtRegister, (LPCTSTR*)rglpszWriRegister, 2);
   RegisterExt(_T(".doc"), _T("WordPad.Document.1"), IDS_WINWORD6_DOC, rglpszSymbols,
      (LPCTSTR*)rglpszDocExtRegister, (LPCTSTR*)rglpszDocRegister, 1);

   // free memory for class ID
   ASSERT(lpszClassID != NULL);
   CoTaskMemFree(lpszClassID);
}

BOOL RegisterHelper(LPCTSTR* rglpszRegister, LPCTSTR* rglpszSymbols,
   BOOL bReplace)
{
   ASSERT(rglpszRegister != NULL);
   ASSERT(rglpszSymbols != NULL);

   CString strKey;
   CString strValueName;
   CString strValue;

   // keeping a key open makes this go a bit faster
   CKey keyTemp;
   VERIFY(keyTemp.Create(HKEY_CLASSES_ROOT, _T("CLSID")));

   BOOL bResult = TRUE;
   while (*rglpszRegister != NULL)
   {
      LPCTSTR lpszKey = *rglpszRegister++;
      if (*lpszKey == '\0')
         continue;

      LPCTSTR lpszValueName = lpszKey + lstrlen(lpszKey) + 1;
      LPCTSTR lpszValue = lpszValueName + lstrlen(lpszValueName) + 1;

      strKey.ReleaseBuffer(
         FormatMessage(FORMAT_MESSAGE_FROM_STRING |
         FORMAT_MESSAGE_ARGUMENT_ARRAY, lpszKey, NULL,   NULL,
         strKey.GetBuffer(256), 256, (va_list*) rglpszSymbols));
      strValueName = lpszValueName;
      strValue.ReleaseBuffer(
         FormatMessage(FORMAT_MESSAGE_FROM_STRING |
         FORMAT_MESSAGE_ARGUMENT_ARRAY, lpszValue, NULL, NULL,
         strValue.GetBuffer(256), 256, (va_list*) rglpszSymbols));

      if (strKey.IsEmpty())
      {
         TRACE1("Warning: skipping empty key '%s'.\n", lpszKey);
         continue;
      }

      CKey key;
      VERIFY(key.Create(HKEY_CLASSES_ROOT, strKey));
      if (!bReplace)
      {
         CString str;
         if (key.GetStringValue(str, strValueName) && !str.IsEmpty())
            continue;
      }

      if (!key.SetStringValue(strValue, strValueName))
      {
         TRACE2("Error: failed setting key '%s' to value '%s'.\n",
            (LPCTSTR)strKey, (LPCTSTR)strValue);
         bResult = FALSE;
         break;
      }
   }

   return bResult;
}

void CWordPadApp::WinHelp(DWORD dwData, UINT nCmd)
{
   if (g_fDisableStandardHelp)
   {
       return ;
   }

   if (nCmd == HELP_INDEX || nCmd == HELP_CONTENTS)
      nCmd = HELP_FINDER;
   CWinApp::WinHelp(dwData, nCmd);
}

BOOL CWordPadApp::PreTranslateMessage(MSG* pMsg)
{
   if (pMsg->message == WM_PAINT)
      return FALSE;
   // CWinApp::PreTranslateMessage does nothing but call base
   return CWinThread::PreTranslateMessage(pMsg);
}

void CWordPadApp::NotifyPrinterChanged(BOOL bUpdatePrinterSelection)
{
   if (bUpdatePrinterSelection)
      UpdatePrinterSelection(FALSE);
   POSITION pos = m_listPrinterNotify.GetHeadPosition();
   while (pos != NULL)
   {
      HWND hWnd = m_listPrinterNotify.GetNext(pos);
      ::SendMessage(hWnd, m_nPrinterChangedMsg, 0, 0);
   }
}

BOOL CWordPadApp::IsIdleMessage(MSG* pMsg)
{
   if (pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_NCMOUSEMOVE)
      return FALSE;
   return CWinApp::IsIdleMessage(pMsg);
}

#define DN_PADDINGCHARS 16

HGLOBAL CWordPadApp::CreateDevNames()
{
    HGLOBAL hDev = NULL;
    CString strDriverName;
    CString strPrinterName;
    CString strPortName;
 
    if (!cmdInfo.m_strPrinterName.IsEmpty())
    {
        strDriverName = cmdInfo.m_strDriverName;
        strPrinterName = cmdInfo.m_strPrinterName;
        strPortName = cmdInfo.m_strPortName;
    }
    else
    {
        PRINTDLG    printdlg;
        DEVNAMES   *devnames;

        if (!GetPrinterDeviceDefaults(&printdlg))
            return NULL;

        devnames = (DEVNAMES *) ::GlobalLock(printdlg.hDevNames);
        if (NULL == devnames)
            return NULL;

        strDriverName = (LPTSTR) ((BYTE *) devnames) + devnames->wDriverOffset;
        strPrinterName = (LPTSTR) ((BYTE *) devnames) + devnames->wDeviceOffset;
        strPortName = (LPTSTR) ((BYTE *) devnames) + devnames->wOutputOffset;

        ::GlobalUnlock(printdlg.hDevNames);
    }
 
    DWORD cbDevNames ;

    cbDevNames = strDriverName.GetLength() + 1 +
                 strPrinterName.GetLength() + 1 +
                 strPortName.GetLength() + 1 +
                 DN_PADDINGCHARS ;

    cbDevNames *= sizeof(TCHAR) ;
    cbDevNames += sizeof(DEVNAMES) ;

    hDev = GlobalAlloc(GPTR, cbDevNames) ;

    LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(hDev) ;

    lpDev->wDriverOffset = sizeof(DEVNAMES) / sizeof(TCHAR) ;
    lstrcpy((LPTSTR) lpDev + lpDev->wDriverOffset, strDriverName) ;

    lpDev->wDeviceOffset = (WORD) (lpDev->wDriverOffset 
                                    + strDriverName.GetLength() + 1);
    lstrcpy((LPTSTR) lpDev + lpDev->wDeviceOffset, strPrinterName) ;

    lpDev->wOutputOffset = (WORD) (lpDev->wDeviceOffset 
                                    + strPrinterName.GetLength() + 1);
    lstrcpy((LPTSTR) lpDev + lpDev->wOutputOffset, strPortName) ;

    lpDev->wDefault = 0;
   
    return hDev;
}

//+---------------------------------------------------------------------------
//
//  Method:     CWordPadApp::DoDeferredInitialization, static
//
//  Synopsis:   Thread entry point for low priority initialization
//
//  Parameters: [pvWordPadApp]          -- Pointer to to CWordPadApp
//
//  Returns:    Thread exit code
//
//---------------------------------------------------------------------------

UINT AFX_CDECL CWordPadApp::DoDeferredInitialization(LPVOID pvWordPadApp)
{
    ASSERT(NULL != pvWordPadApp);


    CWordPadApp *pWordPadApp = (CWordPadApp *) pvWordPadApp;

    pWordPadApp->m_initialization_phase = InitializingPrinter;
    pWordPadApp->CreateDevNames();

    pWordPadApp->m_initialization_phase = UpdatingPrinterRelatedUI;
    pWordPadApp->NotifyPrinterChanged( ((pWordPadApp->m_hDevNames) == NULL) );

    pWordPadApp->m_initialization_phase = UpdatingRegistry;
    pWordPadApp->UpdateRegistry();

    pWordPadApp->m_initialization_phase = InitializationComplete;

    return 0;
}

//+--------------------------------------------------------------------------
//
//  Method:     CWordPadApp::EnsurePrinterIsInitialized
//
//  Synopsis:   Make sure the printer is done initializing
//
//  Parameters: None
//
//  Returns:    void
//
//  Notes:      We'll only wait two minutes.  If the printer takes that long
//              to initialize printing probably is going to be flakey anyway.
//
//              The main purpose of doing printer initialization on a different
//              thread is so that it doesn't get in the way of doing real work.
//              On the other hand if printing is the real work we should try to
//              get things moving so bump it up from idle priority.
//
//---------------------------------------------------------------------------

void CWordPadApp::EnsurePrinterIsInitialized()
{
    int     nWaits = 0;
    BOOL    bBumpedPriority = FALSE;

    if (NULL == m_pInitializationThread)
    {
        ASSERT(NULL != m_pInitializationThread);
        bBumpedPriority = TRUE;
    }

    while (m_initialization_phase <= InitializingPrinter && nWaits < 1200)
    {
        if (!bBumpedPriority)
        {
            m_pInitializationThread->SetThreadPriority(
                                            THREAD_PRIORITY_ABOVE_NORMAL);
            bBumpedPriority = TRUE;
        }

        Sleep(100);
        ++nWaits;
    }

    if (bBumpedPriority)
        m_pInitializationThread->SetThreadPriority(THREAD_PRIORITY_IDLE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\viewrich.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "stdafx2.h"

// See Win98 HACKHACK below
#ifdef _CHICAGO_
#include <initguid.h>
#include <tom.h>
#pragma comment (lib, "oleaut32.lib")
#endif // _CHICAGO_

#ifdef AFX_CORE4_SEG
#pragma code_seg(AFX_CORE4_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CRe2Object

class CRe2Object : public _reobject
{
public:
    CRe2Object();
    CRe2Object(CRichEdit2CntrItem* pItem);
    ~CRe2Object();
};

CRe2Object::CRe2Object()
{
    cbStruct = sizeof(REOBJECT);
    poleobj = NULL;
    pstg = NULL;
    polesite = NULL;
}

CRe2Object::CRe2Object(CRichEdit2CntrItem* pItem)
{
    ASSERT(pItem != NULL);
    cbStruct = sizeof(REOBJECT);

    pItem->GetClassID(&clsid);
    poleobj = pItem->m_lpObject;
    pstg = pItem->m_lpStorage;
    polesite = pItem->m_lpClientSite;
    ASSERT(poleobj != NULL);
    ASSERT(pstg != NULL);
    ASSERT(polesite != NULL);
    poleobj->AddRef();
    pstg->AddRef();
    polesite->AddRef();

    sizel.cx = sizel.cy = 0; // let richedit determine initial size
    dvaspect = pItem->GetDrawAspect();
    dwFlags = REO_RESIZABLE;
    dwUser = 0;
}

CRe2Object::~CRe2Object()
{
    if (poleobj != NULL)
        poleobj->Release();
    if (pstg != NULL)
        pstg->Release();
    if (polesite != NULL)
        polesite->Release();
}


//+-------------------------------------------------------------------------
//
//  HACKHACK:   
//
//  The Richedit2 control is Unicode internally so it needs to convert
//  strings from Ansi to Unicode when it recieves a EM_FINDTEXTEX message.
//  Unfortunately it seems to set the code page for the conversion based
//  on the current keyboard layout.  This breaks in the following scenario:
//
//  Start Wordpad on FE Win98 and type some DBCS chars.  Pull up the find
//  dialog and enter one of the DBCS chars that you typed before.  Set the
//  keyboard layout to US and try to find the character - it will fail.
//  Now set it to non-US and try the find - it will work.
//
//  The hack is to do the conversion ourselves using the system default
//  codepage and then do the find using the TOM interfaces.
//
//  Richedit3 is supposed to be smarter about this whole issue and hopefully
//  this hack can be removed then.
//
//--------------------------------------------------------------------------

#ifdef _CHICAGO_
long CRichEdit2Ctrl::FindText(DWORD dwFlags, FINDTEXTEX* pFindText) const
{
    long            index = -1;
    ITextRange     *range = NULL;
    HRESULT         hr = S_OK;
    UINT            cchFind = _tcslen(pFindText->lpstrText) + 1;
    LPWSTR          lpwszFind = NULL;
    long            length;

    // 
    // Get the base richedit ole interface
    //

    IUnknown *unk = GetIRichEditOle();

    if (NULL == unk)
        hr = E_NOINTERFACE;

    //
    // Get a range object
    //

    if (S_OK == hr)
    {
        ITextDocument *doc;

        hr = unk->QueryInterface(IID_ITextDocument, (void **) &doc);

        if (S_OK == hr)
        {
            hr = doc->Range(
                        pFindText->chrg.cpMin, 
                        pFindText->chrg.cpMax, 
                        &range);

            doc->Release();
        }

        unk->Release();
    }

    //
    // Convert the text-to-find to Unicode using the system default code page
    //

    if (S_OK == hr)
    {
        try
        {
             lpwszFind = (LPWSTR) alloca(cchFind * sizeof(WCHAR));
        }
        catch (...)
        {
            hr = E_OUTOFMEMORY; // alloca failed
        }

        if (S_OK == hr)
        {
            int error = MultiByteToWideChar(
                                CP_ACP, 
                                MB_ERR_INVALID_CHARS, 
                                pFindText->lpstrText, 
                                -1, 
                                lpwszFind, 
                                cchFind);

            if (0 != error)
                lpwszFind = SysAllocString(lpwszFind);
            else
                hr = E_FAIL;
        }
    }

    //
    // Try to find the text
    //

    if (S_OK == hr)
    {
        long flags = 0;

        flags |= (dwFlags & FR_MATCHCASE) ? tomMatchCase : 0;
        flags |= (dwFlags & FR_WHOLEWORD) ? tomMatchWord : 0;

        hr = range->FindText((BSTR) lpwszFind, 0, flags, &length);

        SysFreeString(lpwszFind);

        if (S_OK == hr)
        {
            hr = range->GetIndex(tomCharacter, &index);
            
            if (S_OK == hr)
            {
                // GetIndex returns 1-based indices, EM_FINDTEXTEX returns
                // 0-based indices.

                --index;
                pFindText->chrgText.cpMin = index;
                pFindText->chrgText.cpMax = index + length;
            }
        }
    }

    if (NULL != range)
        range->Release();

    //
    // If all else fails, fall back to EM_FINDTEXTEX
    //

    if (S_OK != hr)
        index = (long)::SendMessage(
                            m_hWnd, 
                            EM_FINDTEXTEX, 
                            dwFlags, 
                            (LPARAM)pFindText);

    return index;
}
#endif // _CHICAGO

    

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View

static const UINT nMsgFindReplace = ::RegisterWindowMessage(FINDMSGSTRING);

BEGIN_MESSAGE_MAP(CRichEdit2View, CCtrlView)
    //{{AFX_MSG_MAP(CRichEdit2View)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateNeedSel)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateNeedClip)
    ON_UPDATE_COMMAND_UI(ID_EDIT_FIND, OnUpdateNeedText)
    ON_UPDATE_COMMAND_UI(ID_EDIT_REPEAT, OnUpdateNeedFind)
    ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_SPECIAL, OnUpdateEditPasteSpecial)
    ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_PROPERTIES, OnUpdateEditProperties)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateNeedSel)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR, OnUpdateNeedSel)
    ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, OnUpdateNeedText)
    ON_UPDATE_COMMAND_UI(ID_EDIT_REPLACE, OnUpdateNeedText)
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_COMMAND(ID_EDIT_CLEAR, OnEditClear)
    ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
    ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
    ON_COMMAND(ID_EDIT_FIND, OnEditFind)
    ON_COMMAND(ID_EDIT_REPLACE, OnEditReplace)
    ON_COMMAND(ID_EDIT_REPEAT, OnEditRepeat)
    ON_COMMAND(ID_EDIT_PASTE_SPECIAL, OnEditPasteSpecial)
    ON_COMMAND(ID_OLE_EDIT_PROPERTIES, OnEditProperties)
    ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
    ON_COMMAND(ID_FORMAT_FONT, OnFormatFont)
    ON_WM_SIZE()
    ON_WM_CREATE()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    ON_NOTIFY_REFLECT(EN_SELCHANGE, OnSelChange)
    ON_REGISTERED_MESSAGE(nMsgFindReplace, OnFindReplaceCmd)
END_MESSAGE_MAP()

// richedit buffer limit -- let's set it at 16M
AFX_DATADEF ULONG CRichEdit2View::lMaxSize = 0xffffff;

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View construction/destruction

CRichEdit2View::CRichEdit2View() : CCtrlView(RICHEDIT_CLASS, AFX_WS_DEFAULT_VIEW |
    WS_HSCROLL | WS_VSCROLL | ES_AUTOHSCROLL | ES_AUTOVSCROLL |
    ES_MULTILINE | ES_NOHIDESEL | ES_SAVESEL | ES_SELECTIONBAR)
{
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    m_lpRichEditOle = NULL;
    m_nBulletIndent = 720; // 1/2 inch
    m_nWordWrap = WrapToWindow;
    m_nPasteType = 0;
    SetPaperSize(CSize(8*1440+720, 11*1440));
    SetMargins(CRect(0,0,0,0));
    m_charformat.cbSize = sizeof(CHARFORMAT);
    m_paraformat.cbSize = sizeof(PARAFORMAT);
}

BOOL CRichEdit2View::PreCreateWindow(CREATESTRUCT& cs)
{
    _AFX_RICHEDIT2_STATE* pState = AfxGetRichEdit2State();
    if (pState->m_hInstRichEdit == NULL)
#ifndef _MAC
        pState->m_hInstRichEdit = LoadLibraryA("RICHED20.DLL");
#else
        pState->m_hInstRichEdit = RELoadLibrary();
#endif
    ASSERT(pState->m_hInstRichEdit != NULL);
    CCtrlView::PreCreateWindow(cs);
    cs.lpszName = &afxChNil;

    cs.cx = cs.cy = 100; // necessary to avoid bug with ES_SELECTIONBAR and zero for cx and cy
    cs.style |= WS_CLIPSIBLINGS;

    return TRUE;
}

int CRichEdit2View::OnCreate(LPCREATESTRUCT lpcs)
{
    if (CCtrlView::OnCreate(lpcs) != 0)
        return -1;
    GetRichEditCtrl().LimitText(lMaxSize);
    GetRichEditCtrl().SetEventMask(ENM_SELCHANGE | ENM_CHANGE | ENM_SCROLL);
    VERIFY(GetRichEditCtrl().SetOLECallback(&m_xRichEditOleCallback));
    m_lpRichEditOle = GetRichEditCtrl().GetIRichEditOle();
    DragAcceptFiles();
    GetRichEditCtrl().SetOptions(ECOOP_OR, ECO_AUTOWORDSELECTION);
    WrapChanged();
    ASSERT(m_lpRichEditOle != NULL);
    return 0;
}

void CRichEdit2View::OnInitialUpdate()
{
    CCtrlView::OnInitialUpdate();
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View document like functions

void CRichEdit2View::DeleteContents()
{
    ASSERT_VALID(this);
    ASSERT(m_hWnd != NULL);
    SetWindowText(_T(""));
    GetRichEditCtrl().EmptyUndoBuffer();
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    ASSERT_VALID(this);
}

void CRichEdit2View::WrapChanged()
{
    CWaitCursor wait;
    CRichEdit2Ctrl& ctrl = GetRichEditCtrl();
    if (m_nWordWrap == WrapNone)
        ctrl.SetTargetDevice(NULL, 1);
    else if (m_nWordWrap == WrapToWindow)
        ctrl.SetTargetDevice(NULL, 0);
    else if (m_nWordWrap == WrapToTargetDevice) // wrap to ruler
    {
        AfxGetApp()->CreatePrinterDC(m_dcTarget);
        if (m_dcTarget.m_hDC == NULL)
            m_dcTarget.CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
        ctrl.SetTargetDevice(m_dcTarget, GetPrintWidth());
    }
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View serialization support

class _afxRichEditCookie
{
public:
    CArchive& m_ar;
    DWORD m_dwError;
    _afxRichEditCookie(CArchive& ar) : m_ar(ar) {m_dwError=0;}
};

void CRichEdit2View::Serialize(CArchive& ar)
    // Read and write CRichEdit2View object to archive, with length prefix.
{
    ASSERT_VALID(this);
    ASSERT(m_hWnd != NULL);
    Stream(ar, FALSE);
    ASSERT_VALID(this);
}

void CRichEdit2View::Stream(CArchive& ar, BOOL bSelection)
{
    EDITSTREAM es = {0, 0, EditStreamCallBack};
    _afxRichEditCookie cookie(ar);
    es.dwCookie = (DWORD)&cookie;
    int nFormat = GetDocument()->GetStreamFormat();

    if (bSelection)
        nFormat |= SFF_SELECTION;
    if (GetDocument()->IsUnicode())
        nFormat |= SF_UNICODE;

    if (ar.IsStoring())
        GetRichEditCtrl().StreamOut(nFormat, es);
    else
    {
        GetRichEditCtrl().StreamIn(nFormat, es);
        Invalidate();
    }
    if (cookie.m_dwError != 0)
        AfxThrowFileException(cookie.m_dwError);
}

// return 0 for no error, otherwise return error code
DWORD CALLBACK CRichEdit2View::EditStreamCallBack(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)
{
    _afxRichEditCookie* pCookie = (_afxRichEditCookie*)dwCookie;
    CArchive& ar = pCookie->m_ar;
    ar.Flush();
    DWORD dw = 0;
    *pcb = cb;
    TRY
    {
        if (ar.IsStoring())
            ar.GetFile()->WriteHuge(pbBuff, cb);
        else
            *pcb = ar.GetFile()->ReadHuge(pbBuff, cb);
    }
    CATCH(CFileException, e)
    {
        *pcb = 0;
        pCookie->m_dwError = (DWORD)e->m_cause;
        dw = 1;
        DELETE_EXCEPTION(e);
    }
    AND_CATCH_ALL(e)
    {
        *pcb = 0;
        pCookie->m_dwError = (DWORD)CFileException::generic;
        dw = 1;
        DELETE_EXCEPTION(e);
    }
    END_CATCH_ALL
    return dw;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View Printing support

void CRichEdit2View::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo*)
{
    ASSERT_VALID(this);
//  ASSERT_VALID(pDC);
    // initialize page start vector
    ASSERT(m_aPageStart.GetSize() == 0);
    m_aPageStart.Add(0);
    ASSERT(m_aPageStart.GetSize() > 0);
    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache

    ASSERT_VALID(this);
}

BOOL CRichEdit2View::PaginateTo(CDC* pDC, CPrintInfo* pInfo)
    // attempts pagination to pInfo->m_nCurPage, TRUE == success
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);

    CRect rectSave = pInfo->m_rectDraw;
    UINT nPageSave = pInfo->m_nCurPage;
    ASSERT(nPageSave > 1);
    ASSERT(nPageSave >= (UINT)m_aPageStart.GetSize());
    VERIFY(pDC->SaveDC() != 0);
    pDC->IntersectClipRect(0, 0, 0, 0);
    pInfo->m_nCurPage = m_aPageStart.GetSize();
    while (pInfo->m_nCurPage < nPageSave)
    {
        ASSERT(pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize());
        OnPrepareDC(pDC, pInfo);
        ASSERT(pInfo->m_bContinuePrinting);
        pInfo->m_rectDraw.SetRect(0, 0,
            pDC->GetDeviceCaps(HORZRES), pDC->GetDeviceCaps(VERTRES));
        pDC->DPtoLP(&pInfo->m_rectDraw);
        OnPrint(pDC, pInfo);
        if (pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize())
            break;
        ++pInfo->m_nCurPage;
    }
    BOOL bResult = pInfo->m_nCurPage == nPageSave;
    pDC->RestoreDC(-1);
    pInfo->m_nCurPage = nPageSave;
    pInfo->m_rectDraw = rectSave;
    ASSERT_VALID(this);
    return bResult;
}

void CRichEdit2View::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    ASSERT(pInfo != NULL);  // overriding OnPaint -- never get this.

    pDC->SetMapMode(MM_TEXT);

    if (pInfo->m_nCurPage > (UINT)m_aPageStart.GetSize() &&
        !PaginateTo(pDC, pInfo))
    {
        // can't paginate to that page, thus cannot print it.
        pInfo->m_bContinuePrinting = FALSE;
    }
    ASSERT_VALID(this);
}

long CRichEdit2View::PrintPage(CDC* pDC, long nIndexStart, long nIndexStop)
    // worker function for laying out text in a rectangle.
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    FORMATRANGE fr;

    // offset by printing offset
    pDC->SetViewportOrg(-pDC->GetDeviceCaps(PHYSICALOFFSETX),
        -pDC->GetDeviceCaps(PHYSICALOFFSETY));
    // adjust DC because richedit doesn't do things like MFC
    if (::GetDeviceCaps(pDC->m_hDC, TECHNOLOGY) != DT_METAFILE && pDC->m_hAttribDC != NULL)
    {
        ::ScaleWindowExtEx(pDC->m_hDC,
            ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSX),
            ::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSX),
            ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSY),
            ::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSY), NULL);
    }

    fr.hdcTarget = pDC->m_hAttribDC;
    fr.hdc = pDC->m_hDC;
    fr.rcPage = GetPageRect();
    fr.rc = GetPrintRect();

    fr.chrg.cpMin = nIndexStart;
    fr.chrg.cpMax = nIndexStop;
    long lRes = GetRichEditCtrl().FormatRange(&fr,TRUE);
    return lRes;
}

long CRichEdit2View::PrintInsideRect(CDC* pDC, RECT& rectLayout,
    long nIndexStart, long nIndexStop, BOOL bOutput)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    FORMATRANGE fr;

    // adjust DC because richedit doesn't do things like MFC
    if (::GetDeviceCaps(pDC->m_hDC, TECHNOLOGY) != DT_METAFILE && pDC->m_hAttribDC != NULL)
    {
        ::ScaleWindowExtEx(pDC->m_hDC,
            ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSX),
            ::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSX),
            ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSY),
            ::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSY), NULL);
    }

    fr.hdcTarget = pDC->m_hAttribDC;
    fr.hdc = pDC->m_hDC;
    // convert rect to twips
    fr.rcPage = rectLayout;
    fr.rc = rectLayout;

    fr.chrg.cpMin = nIndexStart;
    fr.chrg.cpMax = nIndexStop;
    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache
    // if bOutput is FALSE, we only measure
    long lres = GetRichEditCtrl().FormatRange(&fr, bOutput);
    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache

    rectLayout = fr.rc;
    return lres;
}

void CRichEdit2View::OnPrint(CDC* pDC, CPrintInfo* pInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    ASSERT(pInfo != NULL);
    ASSERT(pInfo->m_bContinuePrinting);

    UINT nPage = pInfo->m_nCurPage;
    ASSERT(nPage <= (UINT)m_aPageStart.GetSize());
    long nIndex = (long) m_aPageStart[nPage-1];

    // print as much as possible in the current page.
    nIndex = PrintPage(pDC, nIndex, 0xFFFFFFFF);

    if (nIndex >= GetTextLength())
    {
        TRACE0("End of Document\n");
        pInfo->SetMaxPage(nPage);
    }

    // update pagination information for page just printed
    if (nPage == (UINT)m_aPageStart.GetSize())
    {
        if (nIndex < GetTextLength())
            m_aPageStart.Add(nIndex);
    }
    else
    {
        ASSERT(nPage+1 <= (UINT)m_aPageStart.GetSize());
        ASSERT(nIndex == (long)m_aPageStart[nPage+1-1]);
    }
}


void CRichEdit2View::OnEndPrinting(CDC*, CPrintInfo*)
{
    ASSERT_VALID(this);
    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache
    m_aPageStart.RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View::XRichEditOleCallback

BEGIN_INTERFACE_MAP(CRichEdit2View, CCtrlView)
    // we use IID_IUnknown because richedit doesn't define an IID
    INTERFACE_PART(CRichEdit2View, IID_IUnknown, RichEditOleCallback)
END_INTERFACE_MAP()

STDMETHODIMP_(ULONG) CRichEdit2View::XRichEditOleCallback::AddRef()
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)
    return (ULONG)pThis->InternalAddRef();
}

STDMETHODIMP_(ULONG) CRichEdit2View::XRichEditOleCallback::Release()
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)
    return (ULONG)pThis->InternalRelease();
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::QueryInterface(
    REFIID iid, LPVOID* ppvObj)
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)
    return (HRESULT)pThis->InternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetNewStorage(LPSTORAGE* ppstg)
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)

    // Create a flat storage and steal it from the client item
    // the client item is only used for creating the storage
    COleClientItem item;
    item.GetItemStorageFlat();
    *ppstg = item.m_lpStorage;
    HRESULT hRes = E_OUTOFMEMORY;
    if (item.m_lpStorage != NULL)
    {
        item.m_lpStorage = NULL;
        hRes = S_OK;
    }
    pThis->GetDocument()->InvalidateObjectCache();
    return hRes;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetInPlaceContext(
    LPOLEINPLACEFRAME* lplpFrame, LPOLEINPLACEUIWINDOW* lplpDoc,
    LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    return pThis->GetWindowContext(lplpFrame, lplpDoc, lpFrameInfo);
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::ShowContainerUI(BOOL fShow)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    return pThis->ShowContainerUI(fShow);
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::QueryInsertObject(
    LPCLSID /*lpclsid*/, LPSTORAGE /*pstg*/, LONG /*cp*/)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    pThis->GetDocument()->InvalidateObjectCache();
    return S_OK;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::DeleteObject(LPOLEOBJECT /*lpoleobj*/)
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)
    pThis->GetDocument()->InvalidateObjectCache();
    return S_OK;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::QueryAcceptData(
    LPDATAOBJECT lpdataobj, CLIPFORMAT* lpcfFormat, DWORD reco,
    BOOL fReally, HGLOBAL hMetaPict)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    return pThis->QueryAcceptData(lpdataobj, lpcfFormat, reco,
        fReally, hMetaPict);
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::ContextSensitiveHelp(BOOL /*fEnterMode*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetClipboardData(
    CHARRANGE* lpchrg, DWORD reco, LPDATAOBJECT* lplpdataobj)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    LPDATAOBJECT lpOrigDataObject = NULL;

    // get richedit's data object
    if (FAILED(pThis->m_lpRichEditOle->GetClipboardData(lpchrg, reco,
        &lpOrigDataObject)))
    {
        return E_NOTIMPL;
    }

    // allow changes
    HRESULT hRes = pThis->GetClipboardData(lpchrg, reco, lpOrigDataObject,
        lplpdataobj);

    // if changed then free original object
    if (SUCCEEDED(hRes))
    {
        if (lpOrigDataObject!=NULL)
            lpOrigDataObject->Release();
        return hRes;
    }
    else
    {
        // use richedit's data object
        *lplpdataobj = lpOrigDataObject;
        return S_OK;
    }
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetDragDropEffect(
    BOOL fDrag, DWORD grfKeyState, LPDWORD pdwEffect)
{
    if (!fDrag) // allowable dest effects
    {
        DWORD dwEffect;
        // check for force link
#ifndef _MAC
        if ((grfKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
#else
        if ((grfKeyState & (MK_OPTION|MK_SHIFT)) == (MK_OPTION|MK_SHIFT))
#endif
            dwEffect = DROPEFFECT_LINK;
        // check for force copy
#ifndef _MAC
        else if ((grfKeyState & MK_CONTROL) == MK_CONTROL)
#else
        else if ((grfKeyState & MK_OPTION) == MK_OPTION)
#endif
            dwEffect = DROPEFFECT_COPY;
        // check for force move
        else if ((grfKeyState & MK_ALT) == MK_ALT)
            dwEffect = DROPEFFECT_MOVE;
        // default -- recommended action is move
        else
            dwEffect = DROPEFFECT_MOVE;
        if (dwEffect & *pdwEffect) // make sure allowed type
            *pdwEffect = dwEffect;
    }
    return S_OK;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetContextMenu(
    WORD seltype, LPOLEOBJECT lpoleobj, CHARRANGE* lpchrg,
    HMENU* lphmenu)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    HMENU hMenu = pThis->GetContextMenu(seltype, lpoleobj, lpchrg);
    if (hMenu == NULL)
        return E_NOTIMPL;
    *lphmenu = hMenu;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View command helpers

void CRichEdit2View::OnCharEffect(DWORD dwMask, DWORD dwEffect)
{
    GetCharFormatSelection();
    if (m_charformat.dwMask & dwMask) // selection is all the same
        m_charformat.dwEffects ^= dwEffect;
    else
        m_charformat.dwEffects |= dwEffect;
    m_charformat.dwMask = dwMask;
    SetCharFormat(m_charformat);
}

void CRichEdit2View::OnUpdateCharEffect(CCmdUI* pCmdUI, DWORD dwMask, DWORD dwEffect)
{
    GetCharFormatSelection();
    pCmdUI->SetCheck((m_charformat.dwMask & dwMask) ?
        ((m_charformat.dwEffects & dwEffect) ? 1 : 0) : 2);
}

void CRichEdit2View::OnParaAlign(WORD wAlign)
{
    GetParaFormatSelection();
    m_paraformat.dwMask = PFM_ALIGNMENT;
    m_paraformat.wAlignment = wAlign;
    SetParaFormat(m_paraformat);
}

void CRichEdit2View::OnUpdateParaAlign(CCmdUI* pCmdUI, WORD wAlign)
{
    GetParaFormatSelection();
    // disable if no word wrap since alignment is meaningless
    pCmdUI->Enable( (m_nWordWrap == WrapNone) ?
        FALSE : TRUE);
    pCmdUI->SetCheck( (m_paraformat.dwMask & PFM_ALIGNMENT) ?
        ((m_paraformat.wAlignment == wAlign) ? 1 : 0) : 2);
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View commands

void CRichEdit2View::OnUpdateNeedSel(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    long nStartChar, nEndChar;
    GetRichEditCtrl().GetSel(nStartChar, nEndChar);
    pCmdUI->Enable(nStartChar != nEndChar);
    ASSERT_VALID(this);
}

void CRichEdit2View::OnUpdateNeedClip(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    pCmdUI->Enable(CanPaste());
}

void CRichEdit2View::OnUpdateNeedText(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    pCmdUI->Enable(GetTextLength() != 0);
}

void CRichEdit2View::OnUpdateNeedFind(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    pCmdUI->Enable(GetTextLength() != 0 &&
        !pEditState->strFind.IsEmpty());
}

void CRichEdit2View::OnUpdateEditUndo(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    pCmdUI->Enable(GetRichEditCtrl().CanUndo());
}

void CRichEdit2View::OnEditCut()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().Cut();
}

void CRichEdit2View::OnEditCopy()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().Copy();
}

void CRichEdit2View::OnEditPaste()
{
    ASSERT_VALID(this);
    m_nPasteType = 0;
    GetRichEditCtrl().Paste();
}

void CRichEdit2View::OnEditClear()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().Clear();
}

void CRichEdit2View::OnEditUndo()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().Undo();
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
}

void CRichEdit2View::OnEditSelectAll()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().SetSel(0, -1);
}

void CRichEdit2View::OnEditFind()
{
    ASSERT_VALID(this);
    OnEditFindReplace(TRUE);
}

void CRichEdit2View::OnEditReplace()
{
    ASSERT_VALID(this);
    OnEditFindReplace(FALSE);
}

void CRichEdit2View::OnEditRepeat()
{
    ASSERT_VALID(this);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    if (!FindText(pEditState))
        TextNotFound(pEditState->strFind);
}

void CRichEdit2View::OnCancelEditCntr()
{
    m_lpRichEditOle->InPlaceDeactivate();
}

void CRichEdit2View::OnInsertObject()
{
    // Invoke the standard Insert Object dialog box to obtain information
    COleInsertDialog dlg;
    if (dlg.DoModal() != IDOK)
        return;

    CWaitCursor wait;

    CRichEdit2CntrItem* pItem = NULL;
    TRY
    {
        // create item from dialog results
        pItem = GetDocument()->CreateClientItem();
        pItem->m_bLock = TRUE;
        if (!dlg.CreateItem(pItem))
        {
            pItem->m_bLock = FALSE;
            AfxThrowMemoryException();  // any exception will do
        }

        HRESULT hr = InsertItem(pItem);
        pItem->UpdateItemType();

        pItem->m_bLock = FALSE;

        if (hr != NOERROR)
            AfxThrowOleException(hr);

        // if insert new object -- initially show the object
        if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
            pItem->DoVerb(OLEIVERB_SHOW, this);
    }
    CATCH(CException, e)
    {
        if (pItem != NULL)
        {
            ASSERT_VALID(pItem);
            pItem->Delete();
        }
        AfxMessageBox(AFX_IDP_FAILED_TO_CREATE);
    }
    END_CATCH
}

void CRichEdit2View::OnSelChange(NMHDR* pNMHDR, LRESULT* pResult)
{
    ASSERT(pNMHDR->code == EN_SELCHANGE);
    UNUSED(pNMHDR); // not used in release builds

    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    *pResult = 0;
}

void CRichEdit2View::OnDestroy()
{
    if (m_lpRichEditOle != NULL)
        m_lpRichEditOle->Release();
    CCtrlView::OnDestroy();
}

void CRichEdit2View::OnEditProperties()
{
    ASSERT(m_lpRichEditOle != NULL);
    CRichEdit2CntrItem* pSelection = GetSelectedItem();
    // make sure item is in sync with richedit's item
    CRe2Object reo;
    HRESULT hr = m_lpRichEditOle->GetObject(REO_IOB_SELECTION, &reo,
        REO_GETOBJ_NO_INTERFACES);
    pSelection->SyncToRichEditObject(reo);
    COlePropertiesDialog dlg(pSelection);

    //
    // The Object Properties dialog doesn't display a help button even if 
    // you tell it to.  The dialogs under it (e.g. Change Icon) will display
    // the help button though.  We never want a help button but MFC turns it
    // on by default.  If the Ole dialogs are fixed to not display the help
    // button then this can be removed.
    //
    dlg.m_op.dwFlags &= ~OPF_SHOWHELP;

    dlg.DoModal();
}

void CRichEdit2View::OnUpdateEditProperties(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(GetSelectedItem() != NULL);
}

void CRichEdit2View::OnCharBold()
{
    OnCharEffect(CFM_BOLD, CFE_BOLD);
}

void CRichEdit2View::OnUpdateCharBold(CCmdUI* pCmdUI)
{
    OnUpdateCharEffect(pCmdUI, CFM_BOLD, CFE_BOLD);
}

void CRichEdit2View::OnCharItalic()
{
    OnCharEffect(CFM_ITALIC, CFE_ITALIC);
}

void CRichEdit2View::OnUpdateCharItalic(CCmdUI* pCmdUI)
{
    OnUpdateCharEffect(pCmdUI, CFM_ITALIC, CFE_ITALIC);
}

void CRichEdit2View::OnCharUnderline()
{
    OnCharEffect(CFM_UNDERLINE, CFE_UNDERLINE);
}

void CRichEdit2View::OnUpdateCharUnderline(CCmdUI* pCmdUI)
{
    OnUpdateCharEffect(pCmdUI, CFM_UNDERLINE, CFE_UNDERLINE);
}

void CRichEdit2View::OnParaCenter()
{
    OnParaAlign(PFA_CENTER);
}

void CRichEdit2View::OnUpdateParaCenter(CCmdUI* pCmdUI)
{
    OnUpdateParaAlign(pCmdUI, PFA_CENTER);
}

void CRichEdit2View::OnParaLeft()
{
    OnParaAlign(PFA_LEFT);
}

void CRichEdit2View::OnUpdateParaLeft(CCmdUI* pCmdUI)
{
    OnUpdateParaAlign(pCmdUI, PFA_LEFT);
}

void CRichEdit2View::OnParaRight()
{
    OnParaAlign(PFA_RIGHT);
}

void CRichEdit2View::OnUpdateParaRight(CCmdUI* pCmdUI)
{
    OnUpdateParaAlign(pCmdUI, PFA_RIGHT);
}

void CRichEdit2View::OnBullet()
{
    GetParaFormatSelection();
    if (m_paraformat.dwMask & PFM_NUMBERING && m_paraformat.wNumbering == PFN_BULLET)
    {
        m_paraformat.wNumbering = 0;
        m_paraformat.dxOffset = 0;
        m_paraformat.dxStartIndent = 0;
        m_paraformat.dwMask = PFM_NUMBERING | PFM_STARTINDENT | PFM_OFFSET;
    }
    else
    {
        m_paraformat.wNumbering = PFN_BULLET;
        m_paraformat.dwMask = PFM_NUMBERING;
        if (m_paraformat.dxOffset == 0)
        {
            m_paraformat.dxOffset = m_nBulletIndent;
            m_paraformat.dwMask = PFM_NUMBERING | PFM_STARTINDENT | PFM_OFFSET;
        }
    }
    SetParaFormat(m_paraformat);
}

void CRichEdit2View::OnUpdateBullet(CCmdUI* pCmdUI)
{
    GetParaFormatSelection();
    pCmdUI->SetCheck( (m_paraformat.dwMask & PFM_NUMBERING) ? ((m_paraformat.wNumbering & PFN_BULLET) ? 1 : 0) : 2);
}

void CRichEdit2View::OnFormatFont()
{
    GetCharFormatSelection();
    CFontDialog2 dlg(m_charformat, CF_BOTH|CF_NOOEMFONTS);
    if (dlg.DoModal() == IDOK)
    {
        dlg.GetCharFormat(m_charformat);
        SetCharFormat(m_charformat);
    }
}

void CRichEdit2View::OnColorPick(COLORREF cr)
{
    GetCharFormatSelection();
    m_charformat.dwMask = CFM_COLOR;
    m_charformat.dwEffects = NULL;
    m_charformat.crTextColor = cr;
    SetCharFormat(m_charformat);
}

void CRichEdit2View::OnColorDefault()
{
    GetCharFormatSelection();
    m_charformat.dwMask = CFM_COLOR;
    m_charformat.dwEffects = CFE_AUTOCOLOR;
    SetCharFormat(m_charformat);
}

void CRichEdit2View::OnEditPasteSpecial()
{
    COlePasteSpecialDialog dlg;
    dlg.AddStandardFormats();
    dlg.AddFormat(_oleData.cfRichTextFormat, TYMED_HGLOBAL, AFX_IDS_RTF_FORMAT, FALSE, FALSE);
    dlg.AddFormat(CF_TEXT, TYMED_HGLOBAL, AFX_IDS_TEXT_FORMAT, FALSE, FALSE);

    if (dlg.DoModal() != IDOK)
        return;

    DVASPECT dv = dlg.GetDrawAspect();
    HMETAFILE hMF = (HMETAFILE)dlg.GetIconicMetafile();
    CLIPFORMAT cf =
        dlg.m_ps.arrPasteEntries[dlg.m_ps.nSelectedIndex].fmtetc.cfFormat;

    CWaitCursor wait;
    SetCapture();

    // we set the target type so that QueryAcceptData know what to paste
    m_nPasteType = dlg.GetSelectionType();
    GetRichEditCtrl().PasteSpecial(cf, dv, hMF);
    m_nPasteType = 0;

    ReleaseCapture();
}

void CRichEdit2View::OnUpdateEditPasteSpecial(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(CanPaste());
}

void CRichEdit2View::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if (nChar == VK_F10 && GetKeyState(VK_SHIFT) < 0)
    {
        CRect rect;
        GetClientRect(rect);
        CPoint pt = rect.CenterPoint();
        SendMessage(WM_CONTEXTMENU, (WPARAM)m_hWnd, MAKELPARAM(pt.x, pt.y));
    }
    else
        CCtrlView::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CRichEdit2View::OnDropFiles(HDROP hDropInfo)
{
    TCHAR szFileName[_MAX_PATH];
    UINT nFileCount = ::DragQueryFile(hDropInfo, 0xFFFFFFFF, NULL, 0);
    ASSERT(nFileCount != 0);
    CHARRANGE cr;

    GetRichEditCtrl().GetSel(cr);
    int nMin = cr.cpMin;
    for (UINT i=0;i<nFileCount;i++)
    {
        ::DragQueryFile(hDropInfo, i, szFileName, _MAX_PATH);
        InsertFileAsObject(szFileName);
        GetRichEditCtrl().GetSel(cr);
        cr.cpMin = cr.cpMax;
        GetRichEditCtrl().SetSel(cr);
        UpdateWindow();
    }
    cr.cpMin = nMin;
    GetRichEditCtrl().SetSel(cr);
    ::DragFinish(hDropInfo);
}

void CRichEdit2View::OnDevModeChange(LPTSTR /*lpDeviceName*/)
{
    // WM_DEVMODECHANGE forwarded by the main window of the app
    CDC dc;
    AfxGetApp()->CreatePrinterDC(dc);
    OnPrinterChanged(dc);
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View attributes

BOOL AFX_CDECL CRichEdit2View::IsRichEdit2Format(CLIPFORMAT cf)
{
    return ((cf == _oleData.cfRichTextFormat)     ||
            (cf == _oleData.cfRichTextAndObjects) || 
            (cf == CF_TEXT)                       ||
            (cf == CF_UNICODETEXT));
}

BOOL CRichEdit2View::CanPaste() const
{
    return (CountClipboardFormats() != 0) &&
        (IsClipboardFormatAvailable(CF_TEXT) ||
        IsClipboardFormatAvailable(_oleData.cfRichTextFormat) ||
        IsClipboardFormatAvailable(_oleData.cfEmbedSource) ||
        IsClipboardFormatAvailable(_oleData.cfEmbeddedObject) ||
        IsClipboardFormatAvailable(_oleData.cfFileName) ||
        IsClipboardFormatAvailable(_oleData.cfFileNameW) ||
        IsClipboardFormatAvailable(CF_METAFILEPICT) ||
        IsClipboardFormatAvailable(CF_DIB) ||
        IsClipboardFormatAvailable(CF_BITMAP) ||
        GetRichEditCtrl().CanPaste());
}

CHARFORMAT& CRichEdit2View::GetCharFormatSelection()
{
    if (m_bSyncCharFormat)
    {
        GetRichEditCtrl().GetSelectionCharFormat(m_charformat);
        m_bSyncCharFormat = FALSE;
    }
    return m_charformat;
}

PARAFORMAT& CRichEdit2View::GetParaFormatSelection()
{
    if (m_bSyncParaFormat)
    {
        GetRichEditCtrl().GetParaFormat(m_paraformat);
        m_bSyncParaFormat = FALSE;
    }
    return m_paraformat;
}

void CRichEdit2View::SetCharFormat(CHARFORMAT cf)
{
    CWaitCursor wait;
    GetRichEditCtrl().SetSelectionCharFormat(cf);
    m_bSyncCharFormat = TRUE;
}

void CRichEdit2View::SetParaFormat(PARAFORMAT& pf)
{
    CWaitCursor wait;
    GetRichEditCtrl().SetParaFormat(pf);
    m_bSyncParaFormat = TRUE;
}

CRichEdit2CntrItem* CRichEdit2View::GetSelectedItem() const
{
    ASSERT(m_lpRichEditOle != NULL);
    CRichEdit2Doc* pDoc = GetDocument();
    CRichEdit2CntrItem* pItem = NULL;

    CRe2Object reo;
    HRESULT hr = m_lpRichEditOle->GetObject(REO_IOB_SELECTION, &reo,
        REO_GETOBJ_ALL_INTERFACES);
    //reo's interfaces are all in UNICODE
    if (GetScode(hr) == S_OK)
    {
        pItem = pDoc->LookupItem(reo.poleobj);
        if (pItem == NULL)
            pItem = pDoc->CreateClientItem(&reo);
        ASSERT(pItem != NULL);
    }
    return pItem;
}

CRichEdit2CntrItem* CRichEdit2View::GetInPlaceActiveItem() const
{
    ASSERT(m_lpRichEditOle != NULL);
    CRichEdit2Doc* pDoc = GetDocument();
    CRichEdit2CntrItem* pItem = NULL;

    CRe2Object reo;
    HRESULT hr = m_lpRichEditOle->GetObject(REO_IOB_SELECTION, &reo,
        REO_GETOBJ_ALL_INTERFACES);
    //reo's interfaces are all in UNICODE
    if (GetScode(hr) == S_OK && (reo.dwFlags & REO_INPLACEACTIVE))
    {
        pItem = pDoc->LookupItem(reo.poleobj);
        if (pItem == NULL)
            pItem = pDoc->CreateClientItem(&reo);
        ASSERT(pItem != NULL);
    }
    return pItem;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View operations
HRESULT CRichEdit2View::InsertItem(CRichEdit2CntrItem* pItem)
{
    ASSERT(m_lpRichEditOle != NULL);
    CRe2Object reo(pItem);
    reo.cp = REO_CP_SELECTION;

    HRESULT hr = m_lpRichEditOle->InsertObject(&reo);

    CHARRANGE cr;
    GetRichEditCtrl().GetSel(cr);
    cr.cpMin = cr.cpMax -1;
    GetRichEditCtrl().SetSel(cr);
    return hr;
}

void CRichEdit2View::InsertFileAsObject(LPCTSTR lpszFileName)
{
    CString str = lpszFileName;
    CWaitCursor wait;
    CRichEdit2CntrItem* pItem = NULL;
    TRY
    {
        // create item from dialog results
        pItem = GetDocument()->CreateClientItem();
        pItem->m_bLock = TRUE;
        if (!pItem->CreateFromFile(str))
            AfxThrowMemoryException();  // any exception will do
        pItem->UpdateLink();
        InsertItem(pItem);
        pItem->m_bLock = FALSE;
    }
    CATCH(CException, e)
    {
        if (pItem != NULL)
        {
            pItem->m_bLock = FALSE;
            ASSERT_VALID(pItem);
            pItem->Delete();
        }
    }
    END_CATCH
}

void CRichEdit2View::DoPaste(COleDataObject& dataobj, CLIPFORMAT cf, HMETAFILEPICT hMetaPict)
{
    CWaitCursor wait;

    CRichEdit2CntrItem* pItem = NULL;
    TRY
    {
        // create item from dialog results
        pItem = GetDocument()->CreateClientItem();
        pItem->m_bLock = TRUE;

        if (m_nPasteType == COlePasteSpecialDialog::pasteLink)      // paste link
        {
            if (!pItem->CreateLinkFromData(&dataobj))
                AfxThrowMemoryException();  // any exception will do
        }
        else if (m_nPasteType == COlePasteSpecialDialog::pasteNormal)
        {
            if (!pItem->CreateFromData(&dataobj))
                AfxThrowMemoryException();      // any exception will do
        }
        else if (m_nPasteType == COlePasteSpecialDialog::pasteStatic)
        {
            if (!pItem->CreateStaticFromData(&dataobj))
                AfxThrowMemoryException();      // any exception will do
        }
        else
        {
            // paste embedded
            if (!pItem->CreateFromData(&dataobj) &&
                !pItem->CreateStaticFromData(&dataobj))
            {
                AfxThrowMemoryException();      // any exception will do
            }
        }

        if (cf == 0)
        {
            // copy the current iconic representation
            FORMATETC fmtetc;
            fmtetc.cfFormat = CF_METAFILEPICT;
            fmtetc.dwAspect = DVASPECT_ICON;
            fmtetc.ptd = NULL;
            fmtetc.tymed = TYMED_MFPICT;
            fmtetc.lindex = 1;
            HGLOBAL hObj = dataobj.GetGlobalData(CF_METAFILEPICT, &fmtetc);
            if (hObj != NULL)
            {
                pItem->SetIconicMetafile(hObj);
                // the following code is an easy way to free a metafile pict
                STGMEDIUM stgMed;
                memset(&stgMed, 0, sizeof(stgMed));
                stgMed.tymed = TYMED_MFPICT;
                stgMed.hGlobal = hObj;
                ReleaseStgMedium(&stgMed);
            }

            // set the current drawing aspect
            hObj = dataobj.GetGlobalData((CLIPFORMAT)_oleData.cfObjectDescriptor);
            if (hObj != NULL)
            {
                ASSERT(hObj != NULL);
                // got CF_OBJECTDESCRIPTOR ok.  Lock it down and extract size.
                LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(hObj);
                ASSERT(pObjDesc != NULL);
                ((COleClientItem*)pItem)->SetDrawAspect((DVASPECT)pObjDesc->dwDrawAspect);
                GlobalUnlock(hObj);
                GlobalFree(hObj);
            }
        }
        else
        {
            if (hMetaPict != NULL)
            {
                pItem->SetIconicMetafile(hMetaPict);
                ((COleClientItem*)pItem)->SetDrawAspect(DVASPECT_ICON);
            }
            else
                ((COleClientItem*)pItem)->SetDrawAspect(DVASPECT_CONTENT);
        }

/////////
        HRESULT hr = InsertItem(pItem);
        pItem->UpdateItemType();

        pItem->m_bLock = FALSE;

        if (hr != NOERROR)
            AfxThrowOleException(hr);

    }
    CATCH(CException, e)
    {
        if (pItem != NULL)
        {
            pItem->m_bLock = FALSE;
            ASSERT_VALID(pItem);
            pItem->Delete();
        }
    }
    END_CATCH
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View virtuals

void CRichEdit2View::OnPrinterChanged(const CDC& dcPrinter)
{
    // this is typically called by the view when it gets a WM_DEVMODECHANGE
    // also called during page setup
    CSize size;
    if (dcPrinter.m_hDC != NULL)
    {
        // this will fill in the page size
        size.cx = MulDiv(dcPrinter.GetDeviceCaps(PHYSICALWIDTH), 1440,
            dcPrinter.GetDeviceCaps(LOGPIXELSX));
        size.cy = MulDiv(dcPrinter.GetDeviceCaps(PHYSICALHEIGHT), 1440,
            dcPrinter.GetDeviceCaps(LOGPIXELSY));
    }
    else
        size = CSize(8*1440+720, 11*1440); // 8.5" by 11"
    if (GetPaperSize() != size)
    {
        SetPaperSize(size);
        if (m_nWordWrap == WrapToTargetDevice) //wrap to ruler
            WrapChanged();
    }
}

BOOL CRichEdit2View::OnPasteNativeObject(LPSTORAGE)
{
    // use this function to pull out native data from an embedded object
    // one would typically do this by create a COleStreamFile and attaching it
    // to an archive
    return FALSE;
}

HMENU CRichEdit2View::GetContextMenu(WORD, LPOLEOBJECT, CHARRANGE* )
{
    return NULL;
}

HRESULT CRichEdit2View::GetClipboardData(CHARRANGE* /*lpchrg*/, DWORD /*reco*/,
    LPDATAOBJECT /*lpRichDataObj*/, LPDATAOBJECT* /*lplpdataobj*/)
{
    return E_NOTIMPL;
}

HRESULT CRichEdit2View::QueryAcceptData(LPDATAOBJECT lpdataobj,
    CLIPFORMAT* lpcfFormat, DWORD /*dwReco*/, BOOL bReally, HGLOBAL hMetaPict)
{
    ASSERT(lpcfFormat != NULL);
    if (!bReally) // not actually pasting
        return S_OK;
    // if direct pasting a particular native format allow it
    if (IsRichEdit2Format(*lpcfFormat))
        return S_OK;

    COleDataObject dataobj;
    dataobj.Attach(lpdataobj, FALSE);
    // if format is 0, then force particular formats if available
    if (*lpcfFormat == 0 && (m_nPasteType == 0))
    {
        if (dataobj.IsDataAvailable((CLIPFORMAT)_oleData.cfRichTextAndObjects)) // native avail, let richedit do as it wants
            return S_OK;
        else if (dataobj.IsDataAvailable((CLIPFORMAT)_oleData.cfRichTextFormat))
        {
            *lpcfFormat = (CLIPFORMAT)_oleData.cfRichTextFormat;
            return S_OK;
        }
        else if (dataobj.IsDataAvailable(CF_TEXT))
        {
            *lpcfFormat = CF_TEXT;
            return S_OK;
        }
    }
    // paste OLE formats

    DoPaste(dataobj, *lpcfFormat, hMetaPict);
    return S_FALSE;
}

HRESULT CRichEdit2View::GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
    LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    CRichEdit2CntrItem* pItem = GetSelectedItem();
    if (pItem == NULL)
        return E_FAIL;
    pItem->m_pView = this;
    HRESULT hr = pItem->GetWindowContext(lplpFrame, lplpDoc, lpFrameInfo);
    pItem->m_pView = NULL;
    return hr;
}

HRESULT CRichEdit2View::ShowContainerUI(BOOL b)
{
    CRichEdit2CntrItem* pItem = GetSelectedItem();
    if (pItem == NULL)
        return E_FAIL;
    if (b)
        pItem->m_pView = this;
    HRESULT hr = pItem->ShowContainerUI(b);
    if (FAILED(hr) || !b)
        pItem->m_pView = NULL;
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View Find & Replace

void CRichEdit2View::AdjustDialogPosition(CDialog* pDlg)
{
    ASSERT(pDlg != NULL);
    long lStart, lEnd;
    GetRichEditCtrl().GetSel(lStart, lEnd);
    CPoint point = GetRichEditCtrl().GetCharPos(lStart);
    ClientToScreen(&point);
    CRect rectDlg;
    pDlg->GetWindowRect(&rectDlg);
    if (rectDlg.PtInRect(point))
    {
        if (point.y > rectDlg.Height())
            rectDlg.OffsetRect(0, point.y - rectDlg.bottom - 20);
        else
        {
            int nVertExt = GetSystemMetrics(SM_CYSCREEN);
            if (point.y + rectDlg.Height() < nVertExt)
                rectDlg.OffsetRect(0, 40 + point.y - rectDlg.top);
        }
        pDlg->MoveWindow(&rectDlg);
    }
}

void CRichEdit2View::OnEditFindReplace(BOOL bFindOnly)
{
    ASSERT_VALID(this);
    m_bFirstSearch = TRUE;
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    if (pEditState->pFindReplaceDlg != NULL)
    {
        if (pEditState->bFindOnly == bFindOnly)
        {
            pEditState->pFindReplaceDlg->SetActiveWindow();
            pEditState->pFindReplaceDlg->ShowWindow(SW_SHOW);
            return;
        }
        else
        {
            ASSERT(pEditState->bFindOnly != bFindOnly);
            pEditState->pFindReplaceDlg->SendMessage(WM_CLOSE);
            ASSERT(pEditState->pFindReplaceDlg == NULL);
            ASSERT_VALID(this);
        }
    }
    CString strFind = GetRichEditCtrl().GetSelText();
    // if selection is empty or spans multiple lines use old find text
    if (strFind.IsEmpty() || (strFind.FindOneOf(_T("\n\r")) != -1))
        strFind = pEditState->strFind;
    CString strReplace = pEditState->strReplace;
    pEditState->pFindReplaceDlg = new CFindReplaceDialog;
    ASSERT(pEditState->pFindReplaceDlg != NULL);
    DWORD dwFlags = NULL;
    if (pEditState->bNext)
        dwFlags |= FR_DOWN;
    if (pEditState->bCase)
        dwFlags |= FR_MATCHCASE;
    if (pEditState->bWord)
        dwFlags |= FR_WHOLEWORD;
    // hide stuff that RichEdit doesn't support
    dwFlags |= FR_HIDEUPDOWN;
    if (!pEditState->pFindReplaceDlg->Create(bFindOnly, strFind,
        strReplace, dwFlags, this))
    {
        pEditState->pFindReplaceDlg = NULL;
        ASSERT_VALID(this);
        return;
    }
    ASSERT(pEditState->pFindReplaceDlg != NULL);
    pEditState->bFindOnly = bFindOnly;
    pEditState->pFindReplaceDlg->SetActiveWindow();
    pEditState->pFindReplaceDlg->ShowWindow(SW_SHOW);
    ASSERT_VALID(this);
}

void CRichEdit2View::OnFindNext(LPCTSTR lpszFind, BOOL bNext, BOOL bCase, BOOL bWord)
{
    ASSERT_VALID(this);

    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    pEditState->strFind = lpszFind;
    pEditState->bCase = bCase;
    pEditState->bWord = bWord;
    pEditState->bNext = bNext;

    if (!FindText(pEditState))
        TextNotFound(pEditState->strFind);
    else
        AdjustDialogPosition(pEditState->pFindReplaceDlg);
    ASSERT_VALID(this);
}

void CRichEdit2View::OnReplaceSel(LPCTSTR lpszFind, BOOL bNext, BOOL bCase,
    BOOL bWord, LPCTSTR lpszReplace)
{
    ASSERT_VALID(this);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    pEditState->strFind = lpszFind;
    pEditState->strReplace = lpszReplace;
    pEditState->bCase = bCase;
    pEditState->bWord = bWord;
    pEditState->bNext = bNext;

    if (!SameAsSelected(pEditState->strFind, pEditState->bCase, pEditState->bWord))
    {
        if (!FindText(pEditState))
            TextNotFound(pEditState->strFind);
        else
            AdjustDialogPosition(pEditState->pFindReplaceDlg);
        return;
    }

    long start;
    long end;
    long length1;
    long length2;

    GetRichEditCtrl().GetSel(start, end);
    length1 = end - start;

    GetRichEditCtrl().ReplaceSel(pEditState->strReplace);
    if (!FindText(pEditState))
    {
        TextNotFound(pEditState->strFind);
    }
    else
    {
        GetRichEditCtrl().GetSel(start, end);
        length2 = end - start;

        if (m_lInitialSearchPos < 0)
            m_lInitialSearchPos += (length2 - length1);

        AdjustDialogPosition(pEditState->pFindReplaceDlg);
    }
    ASSERT_VALID(this);
}

void CRichEdit2View::OnReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace, BOOL bCase, BOOL bWord)
{
    ASSERT_VALID(this);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    pEditState->strFind = lpszFind;
    pEditState->strReplace = lpszReplace;
    pEditState->bCase = bCase;
    pEditState->bWord = bWord;
    pEditState->bNext = TRUE;

    CWaitCursor wait;
    // no selection or different than what looking for
    if (!SameAsSelected(pEditState->strFind, pEditState->bCase, pEditState->bWord))
    {
        if (!FindText(pEditState))
        {
            TextNotFound(pEditState->strFind);
            return;
        }
    }

    GetRichEditCtrl().HideSelection(TRUE, FALSE);
    do
    {
        GetRichEditCtrl().ReplaceSel(pEditState->strReplace);
    } while (FindTextSimple(pEditState));
    TextNotFound(pEditState->strFind);
    GetRichEditCtrl().HideSelection(FALSE, FALSE);

    ASSERT_VALID(this);
}

LRESULT CRichEdit2View::OnFindReplaceCmd(WPARAM, LPARAM lParam)
{
    ASSERT_VALID(this);
    CFindReplaceDialog* pDialog = CFindReplaceDialog::GetNotifier(lParam);
    ASSERT(pDialog != NULL);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    ASSERT(pDialog == pEditState->pFindReplaceDlg);
    if (pDialog->IsTerminating())
        pEditState->pFindReplaceDlg = NULL;
    else if (pDialog->FindNext())
    {
        OnFindNext(pDialog->GetFindString(), pDialog->SearchDown(),
            pDialog->MatchCase(), pDialog->MatchWholeWord());
    }
    else if (pDialog->ReplaceCurrent())
    {
        ASSERT(!pEditState->bFindOnly);
        OnReplaceSel(pDialog->GetFindString(),
            pDialog->SearchDown(), pDialog->MatchCase(), pDialog->MatchWholeWord(),
            pDialog->GetReplaceString());
    }
    else if (pDialog->ReplaceAll())
    {
        ASSERT(!pEditState->bFindOnly);
        OnReplaceAll(pDialog->GetFindString(), pDialog->GetReplaceString(),
            pDialog->MatchCase(), pDialog->MatchWholeWord());
    }
    ASSERT_VALID(this);
    return 0;
}

BOOL CRichEdit2View::SameAsSelected(LPCTSTR lpszCompare, BOOL bCase, BOOL /*bWord*/)
{
    CString strSelect = GetRichEditCtrl().GetSelText();
    return (bCase && lstrcmp(lpszCompare, strSelect) == 0) ||
        (!bCase && lstrcmpi(lpszCompare, strSelect) == 0);
}

BOOL CRichEdit2View::FindText(_AFX_RICHEDIT2_STATE* pEditState)
{
    ASSERT(pEditState != NULL);
    return FindText(pEditState->strFind, pEditState->bCase, pEditState->bWord);
}

BOOL CRichEdit2View::FindText(LPCTSTR lpszFind, BOOL bCase, BOOL bWord)
{
    ASSERT_VALID(this);
    CWaitCursor wait;
    return FindTextSimple(lpszFind, bCase, bWord);
}

BOOL CRichEdit2View::FindTextSimple(_AFX_RICHEDIT2_STATE* pEditState)
{
    ASSERT(pEditState != NULL);
    return FindTextSimple(pEditState->strFind, pEditState->bCase, pEditState->bWord);
}

BOOL CRichEdit2View::FindTextSimple(LPCTSTR lpszFind, BOOL bCase, BOOL bWord)
{
    USES_CONVERSION;
    ASSERT(lpszFind != NULL);
    FINDTEXTEX  ft;
    long        cchText;

    GETTEXTLENGTHEX textlen;

    textlen.flags = GTL_NUMCHARS;
#ifdef UNICODE
    textlen.codepage = 1200;            // Unicode code page
#else
    textlen.codepage = CP_ACP;
#endif

    cchText = GetRichEditCtrl().SendMessage(
                                    EM_GETTEXTLENGTHEX,
                                    (WPARAM) &textlen,
                                    0);

    GetRichEditCtrl().GetSel(ft.chrg);

    if (m_bFirstSearch)
    {
        m_lInitialSearchPos = ft.chrg.cpMin;
        m_bFirstSearch = FALSE;
    }
    //REVIEW: Is this cast safe?
    ft.lpstrText = (LPTSTR)lpszFind;
    if (ft.chrg.cpMin != ft.chrg.cpMax) // i.e. there is a selection
        ft.chrg.cpMin++;

    DWORD dwFlags = bCase ? FR_MATCHCASE : 0;
    dwFlags |= bWord ? FR_WHOLEWORD : 0;
    dwFlags |= FR_DOWN;

    ft.chrg.cpMax = cchText;

    long index = GetRichEditCtrl().FindText(dwFlags, &ft);

    if (-1 == index && m_lInitialSearchPos > 0)
    {
        //
        // m_lInitialSearchPos pulls double duty as the point at which we
        // started searching and a flag which says if we've wrapped back
        // to the beginning of the text during a search.  If it's negative
        // (biased by the number of characters) then we've already wrapped
        //

        m_lInitialSearchPos = m_lInitialSearchPos - cchText;

        ft.chrg.cpMin = 0;
        ft.chrg.cpMax = cchText;
        index = GetRichEditCtrl().FindText(dwFlags, &ft);
    }

    if (-1 != index && m_lInitialSearchPos < 0)
        if (index >= (m_lInitialSearchPos + cchText) )
            index = -1;

    if (-1 != index)    
        GetRichEditCtrl().SetSel(ft.chrgText);

    return (-1 != index);
}

long CRichEdit2View::FindAndSelect(DWORD dwFlags, FINDTEXTEX& ft)
{
    long index = GetRichEditCtrl().FindText(dwFlags, &ft);
    if (index != -1) // i.e. we found something
        GetRichEditCtrl().SetSel(ft.chrgText);
    return index;
}

void CRichEdit2View::TextNotFound(LPCTSTR lpszFind)
{
    ASSERT_VALID(this);
    m_bFirstSearch = TRUE;
    OnTextNotFound(lpszFind);
}

void CRichEdit2View::OnTextNotFound(LPCTSTR)
{
    MessageBeep(MB_ICONHAND);
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View diagnostics

#ifdef _DEBUG
void CRichEdit2View::AssertValid() const
{
    CCtrlView::AssertValid();
    ASSERT_VALID(&m_aPageStart);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    if (pEditState->pFindReplaceDlg != NULL)
        ASSERT_VALID(pEditState->pFindReplaceDlg);
}

void CRichEdit2View::Dump(CDumpContext& dc) const
{
    CCtrlView::Dump(dc);
    AFX_DUMP1(dc, "\nm_aPageStart ", &m_aPageStart);
    AFX_DUMP0(dc, "\n Static Member Data:");
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    if (pEditState->pFindReplaceDlg != NULL)
    {
        AFX_DUMP1(dc, "\npFindReplaceDlg = ",
            (void*)pEditState->pFindReplaceDlg);
        AFX_DUMP1(dc, "\nbFindOnly = ", pEditState->bFindOnly);
    }
    AFX_DUMP1(dc, "\nstrFind = ", pEditState->strFind);
    AFX_DUMP1(dc, "\nstrReplace = ", pEditState->strReplace);
    AFX_DUMP1(dc, "\nbCase = ", pEditState->bCase);
    AFX_DUMP1(dc, "\nbWord = ", pEditState->bWord);
    AFX_DUMP1(dc, "\nbNext = ", pEditState->bNext);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

BOOL CRichEdit2View::IsSelected(const CObject* pDocItem) const
{
    return (pDocItem == GetSelectedItem());
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc

CRichEdit2Doc::CRichEdit2Doc()
{
    m_bRTF = TRUE;
    m_bUnicode = FALSE;
    m_bUpdateObjectCache = FALSE;
    ASSERT_VALID(this);
}

CRichEdit2View* CRichEdit2Doc::GetView() const
{
    // find the first view - if there are no views
    // we must return NULL

    POSITION pos = GetFirstViewPosition();
    if (pos == NULL)
        return NULL;

    // find the first view that is a CRichEdit2View

    CView* pView;
    while (pos != NULL)
    {
        pView = GetNextView(pos);
        if (pView->IsKindOf(RUNTIME_CLASS(CRichEdit2View)))
            return (CRichEdit2View*) pView;
    }

    // can't find one--return NULL

    return NULL;
}

BOOL CRichEdit2Doc::IsModified()
{
    return GetView()->GetRichEditCtrl().GetModify();
}

void CRichEdit2Doc::SetModifiedFlag(BOOL bModified)
{
    GetView()->GetRichEditCtrl().SetModify(bModified);
    ASSERT(!!GetView()->GetRichEditCtrl().GetModify() == !!bModified);
}

COleClientItem* CRichEdit2Doc::GetInPlaceActiveItem(CWnd* pWnd)
{
    ASSERT_KINDOF(CRichEdit2View, pWnd);
    CRichEdit2View* pView = (CRichEdit2View*)pWnd;
    return pView->GetInPlaceActiveItem();
}

void CRichEdit2Doc::SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU)
{
    // we call CDocument and not COleServerDoc because we don't want to do the
    // SetHostNames stuff here.  The richedit will do it. And we tell the richedit
    // in SetTitle
    CDocument::SetPathName(lpszPathName, bAddToMRU);
}

void CRichEdit2Doc::SetTitle(LPCTSTR lpszTitle)
{
    USES_CONVERSION;
    COleServerDoc::SetTitle(lpszTitle);
    CRichEdit2View *pView = GetView();
    ASSERT(pView != NULL);
    ASSERT(pView->m_lpRichEditOle != NULL);
    pView->m_lpRichEditOle->SetHostNames(T2CA(AfxGetAppName()),
        T2CA(lpszTitle));
}

CRichEdit2CntrItem* CRichEdit2Doc::LookupItem(LPOLEOBJECT lpobj) const
{
    POSITION pos = COleServerDoc::GetStartPosition();
    CRichEdit2CntrItem* pItem;
    while (pos != NULL)
    {
        pItem = (CRichEdit2CntrItem*) COleServerDoc::GetNextItem(pos);
        // delete item is right type and not under construction
        if (pItem->IsKindOf(RUNTIME_CLASS(CRichEdit2CntrItem)) &&
            pItem->m_lpObject == lpobj)
        {
            return pItem;
        }
    }
    return NULL;
}

CRichEdit2CntrItem* CRichEdit2Doc::CreateClientItem(REOBJECT* preo) const
{
    // cast away constness of this
    return new CRichEdit2CntrItem(preo, (CRichEdit2Doc*)this);
    // a derived class typically needs  to return its own item of a class
    // derived from CRichEdit2CntrItem
}

void CRichEdit2Doc::MarkItemsClear() const
{
    POSITION pos = COleServerDoc::GetStartPosition();
    CRichEdit2CntrItem* pItem;
    while (pos != NULL)
    {
        pItem = (CRichEdit2CntrItem*) COleServerDoc::GetNextItem(pos);
        // Mark item as not in use unless under construction (i.e. m_lpObject == NULL)
        if (pItem->IsKindOf(RUNTIME_CLASS(CRichEdit2CntrItem)))
            pItem->Mark( (pItem->m_lpObject == NULL) ? TRUE : FALSE);
    }
}

void CRichEdit2Doc::DeleteUnmarkedItems() const
{
    POSITION pos = COleServerDoc::GetStartPosition();
    CRichEdit2CntrItem* pItem;
    while (pos != NULL)
    {
        pItem = (CRichEdit2CntrItem*) COleServerDoc::GetNextItem(pos);
        // Mark item as not in use unless under construction (i.e. m_lpObject == NULL)
        if (pItem->IsKindOf(RUNTIME_CLASS(CRichEdit2CntrItem)) && !pItem->IsMarked())
            delete pItem;
    }
}

POSITION CRichEdit2Doc::GetStartPosition() const
{
    if (m_bUpdateObjectCache)
        ((CRichEdit2Doc*)this)->UpdateObjectCache(); //cast away const
    return COleServerDoc::GetStartPosition();
}

void CRichEdit2Doc::UpdateObjectCache()
{
    CRichEdit2View* pView = GetView();
    CRichEdit2CntrItem* pItem;
    if (pView != NULL)
    {
        ASSERT(pView->m_lpRichEditOle != NULL);
        MarkItemsClear();
        long i,nCount = pView->m_lpRichEditOle->GetObjectCount();
        for (i=0;i<nCount;i++)
        {
            CRe2Object reo; // needs to be in here so destructor called to release interfaces
            HRESULT hr = pView->m_lpRichEditOle->GetObject(i, &reo, REO_GETOBJ_ALL_INTERFACES);
            //reo interfaces are UNICODE
            ASSERT(SUCCEEDED(hr));
            if (GetScode(hr) == S_OK)
            {
                pItem = LookupItem(reo.poleobj);
                if (pItem == NULL)
                {
                    pItem = ((CRichEdit2Doc*)this)->CreateClientItem(&reo);
                    pItem->UpdateItemType();
                }
                ASSERT(pItem != NULL);
                pItem->Mark(TRUE);
            }
        }
        DeleteUnmarkedItems();
    }
    m_bUpdateObjectCache = FALSE;
}
/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc Attributes

COleClientItem* CRichEdit2Doc::GetPrimarySelectedItem(CView* pView)
{
    ASSERT(pView->IsKindOf(RUNTIME_CLASS(CRichEdit2View)));
    return ((CRichEdit2View*)pView)->GetSelectedItem();
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc Operations

void CRichEdit2Doc::DeleteContents()
{
    COleServerDoc::DeleteContents();
    CWaitCursor wait;
    CRichEdit2View *pView = GetView();
    if (pView != NULL)
    {
        pView->DeleteContents();
        pView->GetRichEditCtrl().SetModify(FALSE);
        ASSERT(pView->GetRichEditCtrl().GetModify() == FALSE);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc serialization

void CRichEdit2Doc::Serialize(CArchive& ar)
{
    CRichEdit2View *pView = GetView();
    if (pView != NULL)
        pView->Serialize(ar);
    // we don't call the base class COleServerDoc::Serialize
    // because we don't want the client items serialized
    // the client items are handled directly by the RichEdit control
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc diagnostics

#ifdef _DEBUG
void CRichEdit2Doc::AssertValid() const
{
    COleServerDoc::AssertValid();
}

void CRichEdit2Doc::Dump(CDumpContext& dc) const
{
    COleServerDoc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc commands

void CRichEdit2Doc::PreCloseFrame(CFrameWnd* pFrameArg)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pFrameArg);

    // turn off redraw so the user doesn't see the deactivation happening
    BOOL bSetRedraw = FALSE;
    if (pFrameArg->GetStyle() & WS_VISIBLE)
    {
        pFrameArg->SendMessage(WM_SETREDRAW, (WPARAM)FALSE);
        bSetRedraw = TRUE;
    }

    // deactivate any inplace active items on this frame
    GetView()->m_lpRichEditOle->InPlaceDeactivate();

    POSITION pos = GetStartPosition();
    CRichEdit2CntrItem* pItem;
    while (pos != NULL)
    {
        pItem = (CRichEdit2CntrItem*) GetNextClientItem(pos);
        if (pItem == NULL)
            break;
        ASSERT(pItem->IsKindOf(RUNTIME_CLASS(CRichEdit2CntrItem)));
        pItem->Close();
    }

    // turn redraw back on
    if (bSetRedraw)
        pFrameArg->SendMessage(WM_SETREDRAW, (WPARAM)TRUE);
}

void CRichEdit2Doc::UpdateModifiedFlag()
{
    // don't do anything here
    // let the richedit handle all of this
}

COleServerItem* CRichEdit2Doc::OnGetEmbeddedItem()
{
    ASSERT(FALSE);
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2CntrItem implementation

CRichEdit2CntrItem::CRichEdit2CntrItem(REOBJECT *preo, CRichEdit2Doc* pContainer)
    : COleClientItem(pContainer)
{
    m_bMark = FALSE;
    m_bLock = FALSE;
    if (preo != NULL)
    {
        ASSERT(preo->poleobj != NULL);
        ASSERT(preo->pstg != NULL);
        ASSERT(preo->polesite != NULL);
        m_lpObject = preo->poleobj;
        m_lpStorage = preo->pstg;
        m_lpClientSite = preo->polesite;
        m_lpObject->AddRef();
        m_lpStorage->AddRef();
        m_lpClientSite->AddRef();
    }
    else
    {
        m_lpObject = NULL;
        m_lpStorage = NULL;
        m_lpClientSite = NULL;
    }
}

CRichEdit2CntrItem::~CRichEdit2CntrItem()
{
    if (m_lpClientSite != NULL)
        m_lpClientSite->Release();
}

void CRichEdit2CntrItem::OnDeactivateUI(BOOL bUndoable)
{
    CView* pView = GetActiveView();
    if (pView != NULL)
    {
        ASSERT(pView->GetParentFrame() != NULL);
        pView->GetParentFrame()->SendMessage(WM_SETMESSAGESTRING,
            (WPARAM)AFX_IDS_IDLEMESSAGE);
    }
    COleClientItem::OnDeactivateUI(bUndoable);
}

HRESULT CRichEdit2CntrItem::ShowContainerUI(BOOL b)
{
    if (!CanActivate())
        return E_NOTIMPL;
    if (b)
    {
        OnDeactivateUI(FALSE);
        OnDeactivate();
    }
    else
    {
        OnActivate();
        OnActivateUI();
    }
    return S_OK;
}

BOOL CRichEdit2CntrItem::OnChangeItemPosition(const CRect& /*rectPos*/)
{
    ASSERT_VALID(this);

    // richedit handles this
    return FALSE;
}

BOOL CRichEdit2CntrItem::CanActivate()
{
    // Editing in-place while the server itself is being edited in-place
    //  does not work and is not supported.  So, disable in-place
    //  activation in this case.
    COleServerDoc* pDoc = DYNAMIC_DOWNCAST(COleServerDoc, GetDocument());
    if (pDoc != NULL && pDoc->IsInPlaceActive())
        return FALSE;

    // otherwise, rely on default behavior
    return COleClientItem::CanActivate();
}

HRESULT CRichEdit2CntrItem::GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
    LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    CRect rc1,rc2;
    if (!CanActivate())
        return E_NOTIMPL;
    return m_xOleIPSite.GetWindowContext(lplpFrame, lplpDoc, &rc1, &rc2, lpFrameInfo);
}

BOOL CRichEdit2CntrItem::ConvertTo(REFCLSID clsidNew)
{
    USES_CONVERSION;
    LPRICHEDITOLE preole = GetDocument()->GetView()->m_lpRichEditOle;
    LPOLESTR lpOleStr;
    OleRegGetUserType(clsidNew, USERCLASSTYPE_FULL, &lpOleStr);
    LPCTSTR lpsz = OLE2CT(lpOleStr);
    HRESULT hRes = preole->ConvertObject(REO_IOB_SELECTION, clsidNew, T2CA(lpsz));
    CoTaskMemFree(lpOleStr);
    return (SUCCEEDED(hRes));
}

BOOL CRichEdit2CntrItem::ActivateAs(LPCTSTR, REFCLSID clsidOld,
    REFCLSID clsidNew)
{
    LPRICHEDITOLE preole = GetDocument()->GetView()->m_lpRichEditOle;
    HRESULT hRes = preole->ActivateAs(clsidOld, clsidNew);
    return (SUCCEEDED(hRes));
}

void CRichEdit2CntrItem::SetDrawAspect(DVASPECT nDrawAspect)
{
    LPRICHEDITOLE preole = GetDocument()->GetView()->m_lpRichEditOle;
    preole->SetDvaspect(REO_IOB_SELECTION, nDrawAspect);
    COleClientItem::SetDrawAspect(nDrawAspect);
}

void CRichEdit2CntrItem::SyncToRichEditObject(REOBJECT& reo)
{
    COleClientItem::SetDrawAspect((DVASPECT)reo.dvaspect);
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2CntrItem diagnostics

#ifdef _DEBUG
void CRichEdit2CntrItem::AssertValid() const
{
    COleClientItem::AssertValid();
}

void CRichEdit2CntrItem::Dump(CDumpContext& dc) const
{
    COleClientItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////

LPOLECLIENTSITE CRichEdit2CntrItem::GetClientSite()
{
    if (m_lpClientSite == NULL)
    {
        CRichEdit2Doc* pDoc = DYNAMIC_DOWNCAST(CRichEdit2Doc, GetDocument());
        CRichEdit2View* pView = DYNAMIC_DOWNCAST(CRichEdit2View, pDoc->GetView());
        ASSERT(pView->m_lpRichEditOle != NULL);
        HRESULT hr = pView->m_lpRichEditOle->GetClientSite(&m_lpClientSite);
        if (hr != S_OK)
            AfxThrowOleException(hr);
    }
    ASSERT(m_lpClientSite != NULL);
    return m_lpClientSite;
}

/////////////////////////////////////////////////////////////////////////////

#ifndef _AFX_ENABLE_INLINES

static const char _szAfxWinInl[] = "afxrich2.inl";
#undef THIS_FILE
#define THIS_FILE _szAfxWinInl
#define _AFXRICH_INLINE
#include "afxrich2.inl"

#endif //_AFX_ENABLE_INLINES

/////////////////////////////////////////////////////////////////////////////

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_SERIAL(CRichEdit2CntrItem, COleClientItem, 0)
IMPLEMENT_DYNAMIC(CRichEdit2Doc, COleServerDoc)
IMPLEMENT_DYNCREATE(CRichEdit2View, CCtrlView)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\winctrl4.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include "stdafx2.h"

#ifdef AFX_CMNCTL_SEG
#pragma code_seg(AFX_CMNCTL_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// _AFX_RICHEDIT2_STATE

_AFX_RICHEDIT2_STATE::~_AFX_RICHEDIT2_STATE()
{
	if (m_hInstRichEdit != NULL)
#ifndef _MAC
		::FreeLibrary(m_hInstRichEdit);
#else
		REFreeLibrary(m_hInstRichEdit);
#endif
}

_AFX_RICHEDIT2_STATE* AFX_CDECL AfxGetRichEdit2State()
{
	return _afxRichEdit2State.GetData();
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2

BOOL CRichEdit2Ctrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	_AFX_RICHEDIT2_STATE* pState = _afxRichEdit2State;
	if (pState->m_hInstRichEdit == NULL)
	{
#ifndef _MAC
		pState->m_hInstRichEdit = LoadLibraryA("RICHED20.DLL");
#else
#ifndef _AFXDLL
		// Ordinarily the __gForceREInit reference would be produced by richedit.h, but
		// MFC builds with _WLM_NOFORCE_LIBS, which prevents richedit.h from generating
		// the reference.
		pState->m_hInstRichEdit = ((HINSTANCE)__gForceREInit), RELoadLibrary();
#else
		pState->m_hInstRichEdit = RELoadLibrary();
#endif
#endif
		if (pState->m_hInstRichEdit == NULL)
			return FALSE;
	}

	CWnd* pWnd = this;

	return pWnd->Create(_T("RICHEDIT"), NULL, dwStyle, rect, pParentWnd, nID);
}

int CRichEdit2Ctrl::GetLine(int nIndex, LPTSTR lpszBuffer) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex,
		(LPARAM)lpszBuffer);
}

int CRichEdit2Ctrl::LineIndex(int nLine /* = -1 */) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0);
}

int CRichEdit2Ctrl::LineLength(int nLine /* = -1 */) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0);
}

void CRichEdit2Ctrl::LineScroll(int nLines, int nChars /* = 0 */)
{
	ASSERT(::IsWindow(m_hWnd));
	::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines);
}

void CRichEdit2Ctrl::SetSel(long nStartChar, long nEndChar)
{
	ASSERT(::IsWindow(m_hWnd));
	CHARRANGE cr;
	cr.cpMin = nStartChar;
	cr.cpMax = nEndChar;
	::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr);
}

BOOL CRichEdit2Ctrl::CanPaste(UINT nFormat) const
{
	ASSERT(::IsWindow(m_hWnd));
	COleMessageFilter* pFilter = AfxOleGetMessageFilter();
	if (pFilter != NULL)
		pFilter->BeginBusyState();
	BOOL b = (BOOL)::SendMessage(m_hWnd, EM_CANPASTE, nFormat, 0L);
	if (pFilter != NULL)
		pFilter->EndBusyState();
	return b;
}

void CRichEdit2Ctrl::PasteSpecial(UINT nClipFormat, DWORD dvAspect, HMETAFILE hMF)
{
	ASSERT(::IsWindow(m_hWnd));
	REPASTESPECIAL reps;
	reps.dwAspect = dvAspect;
	reps.dwParam = (DWORD)hMF;
	::SendMessage(m_hWnd, EM_PASTESPECIAL, nClipFormat, (LPARAM)&reps);
}

int CRichEdit2Ctrl::GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const
{
	ASSERT(::IsWindow(m_hWnd));
	*(LPINT)lpszBuffer = nMaxLength;
	return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
}

void CRichEdit2Ctrl::GetSel(long& nStartChar, long& nEndChar) const
{
	ASSERT(::IsWindow(m_hWnd));
	CHARRANGE cr;
	::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
	nStartChar = cr.cpMin;
	nEndChar = cr.cpMax;
}

CString CRichEdit2Ctrl::GetSelText() const
{
	ASSERT(::IsWindow(m_hWnd));

	CHARRANGE cr;
    LPTSTR    lpsz;

	cr.cpMin = cr.cpMax = 0;
	::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);

    try
    {
        // Need to use sizeof(WCHAR) to include DBCS characters
	    lpsz = (TCHAR*)_alloca((cr.cpMax - cr.cpMin + 1)*sizeof(WCHAR));

        // lpsz[0] = NULL;

        //
        // APPCOMPAT: The Ansi richedit2 control does not zero terminate the
        //         returned string if the current selection contains nothing
        //         but DBCS characters.
        //

        ZeroMemory(lpsz, (cr.cpMax - cr.cpMin + 1)*sizeof(WCHAR));

	    ::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpsz);
    }
    catch(...)
    {
        //
        // If _alloca fails it will throw an exception.  It's ok to return a
        // constant string here because it will immediately get copied into
        // a CString.
        //
        
        ASSERT(!"Out of stack space");

        lpsz = TEXT("");
    }

	return lpsz;
}

IRichEditOle* CRichEdit2Ctrl::GetIRichEditOle() const
{
	ASSERT(::IsWindow(m_hWnd));
	IRichEditOle *pRichItem = NULL;
	::SendMessage(m_hWnd, EM_GETOLEINTERFACE, 0, (LPARAM)&pRichItem);
	return pRichItem;
}

BOOL CRichEdit2Ctrl::SetDefaultCharFormat(CHARFORMAT &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
}

BOOL CRichEdit2Ctrl::SetSelectionCharFormat(CHARFORMAT &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
}

BOOL CRichEdit2Ctrl::SetWordCharFormat(CHARFORMAT &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION|SCF_WORD, (LPARAM)&cf);
}

DWORD CRichEdit2Ctrl::GetDefaultCharFormat(CHARFORMAT &cf) const
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 0, (LPARAM)&cf);
}

DWORD CRichEdit2Ctrl::GetSelectionCharFormat(CHARFORMAT &cf) const
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 1, (LPARAM)&cf);
}

DWORD CRichEdit2Ctrl::GetParaFormat(PARAFORMAT &pf) const
{
	ASSERT(::IsWindow(m_hWnd));
	pf.cbSize = sizeof(PARAFORMAT);
	return (DWORD)::SendMessage(m_hWnd, EM_GETPARAFORMAT, 0, (LPARAM)&pf);
}

BOOL CRichEdit2Ctrl::SetParaFormat(PARAFORMAT &pf)
{
	ASSERT(::IsWindow(m_hWnd));
	pf.cbSize = sizeof(PARAFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETPARAFORMAT, 0, (LPARAM)&pf);
}

/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable: 4074)
#pragma init_seg(lib)

PROCESS_LOCAL(_AFX_RICHEDIT2_STATE, _afxRichEdit2State)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\wordpvw.cpp ===
// wordpvw.cpp : implementation of the CWordPadView class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include "wordpad.h"
#include "cntritem.h"
#include "srvritem.h"

#include "wordpdoc.h"
#include "wordpvw.h"
#include "formatta.h"
#include "datedial.h"
#include "formatpa.h"
#include "formatba.h"
#include "ruler.h"
#include "strings.h"
#include "colorlis.h"
#include "pageset.h"
#include <penwin.h>
#include "fixhelp.h"


extern CLIPFORMAT cfEmbeddedObject;
extern CLIPFORMAT cfRTO;

BOOL g_fInternalDragDrop = FALSE ;
BOOL g_fRightButtonDrag = FALSE;

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BOOL CCharFormat::operator==(CCharFormat& cf)
{
    return
        dwMask == cf.dwMask
        && dwEffects == cf.dwEffects
        && yHeight == cf.yHeight
        && yOffset == cf.yOffset
        && crTextColor == cf.crTextColor
        && bPitchAndFamily == cf.bPitchAndFamily
        && (lstrcmp(szFaceName, cf.szFaceName) == 0);
}

BOOL CParaFormat::operator==(PARAFORMAT& pf)
{
    if(
        dwMask != pf.dwMask
        || wNumbering != pf.wNumbering
        || wReserved != pf.wReserved
        || dxStartIndent != pf.dxStartIndent
        || dxRightIndent != pf.dxRightIndent
        || dxOffset != pf.dxOffset
        || cTabCount != pf.cTabCount
        )
    {
        return FALSE;
    }
    for (int i=0;i<pf.cTabCount;i++)
    {
        if (rgxTabs[i] != pf.rgxTabs[i])
            return FALSE;
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadView

IMPLEMENT_DYNCREATE(CWordPadView, CRichEdit2View)

//WM_WININICHANGE -- default printer might have changed
//WM_FONTCHANGE -- pool of fonts changed
//WM_DEVMODECHANGE -- printer settings changes

BEGIN_MESSAGE_MAP(CWordPadView, CRichEdit2View)
    ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
    ON_COMMAND(ID_CANCEL_EDIT_CNTR, OnCancelEditCntr)
    ON_COMMAND(ID_CANCEL_EDIT_SRVR, OnCancelEditSrvr)
    //{{AFX_MSG_MAP(CWordPadView)
    ON_COMMAND(ID_PAGE_SETUP, OnPageSetup)
    ON_COMMAND(ID_CHAR_BOLD, OnCharBold)
    ON_UPDATE_COMMAND_UI(ID_CHAR_BOLD, OnUpdateCharBold)
    ON_COMMAND(ID_CHAR_ITALIC, OnCharItalic)
    ON_UPDATE_COMMAND_UI(ID_CHAR_ITALIC, OnUpdateCharItalic)
    ON_COMMAND(ID_CHAR_UNDERLINE, OnCharUnderline)
    ON_UPDATE_COMMAND_UI(ID_CHAR_UNDERLINE, OnUpdateCharUnderline)
    ON_COMMAND(ID_PARA_CENTER, OnParaCenter)
    ON_UPDATE_COMMAND_UI(ID_PARA_CENTER, OnUpdateParaCenter)
    ON_COMMAND(ID_PARA_LEFT, OnParaLeft)
    ON_UPDATE_COMMAND_UI(ID_PARA_LEFT, OnUpdateParaLeft)
    ON_COMMAND(ID_PARA_RIGHT, OnParaRight)
    ON_UPDATE_COMMAND_UI(ID_PARA_RIGHT, OnUpdateParaRight)
    ON_WM_CREATE()
    ON_COMMAND(ID_INSERT_DATE_TIME, OnInsertDateTime)
   ON_COMMAND(ID_FORMAT_PARAGRAPH, OnFormatParagraph)
   ON_COMMAND(ID_FORMAT_FONT, OnFormatFont)
    ON_COMMAND(ID_EDIT_PASTE_SPECIAL, OnEditPasteSpecial)
    ON_COMMAND(ID_OLE_EDIT_PROPERTIES, OnEditProperties)
    ON_COMMAND(ID_EDIT_FIND, OnEditFind)
    ON_COMMAND(ID_EDIT_REPLACE, OnEditReplace)
    ON_COMMAND(ID_FORMAT_TABS, OnFormatTabs)
    ON_COMMAND(ID_COLOR16, OnColorDefault)
    ON_WM_TIMER()
    ON_WM_DESTROY()
    ON_WM_MEASUREITEM()
    ON_COMMAND(ID_PEN_BACKSPACE, OnPenBackspace)
    ON_COMMAND(ID_PEN_NEWLINE, OnPenNewline)
    ON_COMMAND(ID_PEN_PERIOD, OnPenPeriod)
    ON_COMMAND(ID_PEN_SPACE, OnPenSpace)
    ON_WM_SIZE()
    ON_WM_KEYDOWN()
    ON_COMMAND(ID_FILE_PRINT, OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, OnFilePrint)
    ON_WM_DROPFILES()
    ON_COMMAND(ID_PEN_LENS, OnPenLens)
    ON_COMMAND(ID_PEN_TAB, OnPenTab)
   ON_COMMAND(ID_DELAYED_INVALIDATE, OnDelayedInvalidate)
    ON_WM_PALETTECHANGED()
    ON_WM_QUERYNEWPALETTE()
    ON_WM_WININICHANGE()
    //}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_INSERT_BULLET, CRichEdit2View::OnBullet)
    ON_UPDATE_COMMAND_UI(ID_INSERT_BULLET, CRichEdit2View::OnUpdateBullet)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, OnFilePrintPreview)
    ON_COMMAND_RANGE(ID_COLOR0, ID_COLOR16, OnColorPick)
    ON_EN_CHANGE(AFX_IDW_PANE_FIRST, OnEditChange)
    ON_WM_MOUSEACTIVATE()
    ON_REGISTERED_MESSAGE(CWordPadApp::m_nPrinterChangedMsg, OnPrinterChangedMsg)
    ON_NOTIFY(FN_GETFORMAT, ID_VIEW_FORMATBAR, OnGetCharFormat)
    ON_NOTIFY(FN_SETFORMAT, ID_VIEW_FORMATBAR, OnSetCharFormat)
    ON_NOTIFY(NM_SETFOCUS, ID_VIEW_FORMATBAR, OnBarSetFocus)
    ON_NOTIFY(NM_KILLFOCUS, ID_VIEW_FORMATBAR, OnBarKillFocus)
    ON_NOTIFY(NM_RETURN, ID_VIEW_FORMATBAR, OnBarReturn)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWordPadView construction/destruction

CWordPadView::CWordPadView()
{
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    m_uTimerID = 0;
    m_bDelayUpdateItems = FALSE;
    m_bOnBar = FALSE;
    m_bInPrint = FALSE;
    m_nPasteType = 0;
    m_rectMargin = theApp.m_rectPageMargin;
}

BOOL CWordPadView::PreCreateWindow(CREATESTRUCT& cs)
{
    BOOL bRes = CRichEdit2View::PreCreateWindow(cs);
    cs.style |= ES_SELECTIONBAR;
    return bRes;
}


 
/////////////////////////////////////////////////////////////////////////////
// CWordPadView attributes

BOOL CWordPadView::IsFormatText()
{
    // this function checks to see if any formatting is not default text
    BOOL bRes = FALSE;
    CHARRANGE cr;
    CCharFormat cf;
    CParaFormat pf;
    GetRichEditCtrl().GetSel(cr);
    GetRichEditCtrl().HideSelection(TRUE, FALSE);
    GetRichEditCtrl().SetSel(0,-1);

    if (!(GetRichEditCtrl().GetSelectionType() & (SEL_OBJECT|SEL_MULTIOBJECT)))
    {
      GetRichEditCtrl().GetSelectionCharFormat(cf);

      //
      // Richedit sometimes returns these masks which are not important to us
      //

      cf.dwMask &= ~(CFM_LINK | CFM_CHARSET) ;

      //
      // Richedit sometimes returns the wrong thing here.  This is not that
      // important for the CHARFORMAT comparison, but it fouls things up if
      // we don't work around it.
      //

      cf.bPitchAndFamily = m_defTextCharFormat.bPitchAndFamily ;

      if (cf == m_defTextCharFormat)
        {
            GetRichEditCtrl().GetParaFormat(pf);

            if (pf == m_defParaFormat) //compared using CParaFormat::operator==
                bRes = TRUE;
        }
    }

    GetRichEditCtrl().SetSel(cr);
    GetRichEditCtrl().HideSelection(FALSE, FALSE);
    return bRes;
}

HMENU CWordPadView::GetContextMenu(WORD, LPOLEOBJECT, CHARRANGE* )
{
    CRichEdit2CntrItem* pItem = GetSelectedItem();
    if (pItem == NULL || !pItem->IsInPlaceActive())
    {
        CMenu menuText;
        menuText.LoadMenu(IDR_TEXT_POPUP);
        CMenu* pMenuPopup = menuText.GetSubMenu(0);
        menuText.RemoveMenu(0, MF_BYPOSITION);
        if (!GetSystemMetrics(SM_PENWINDOWS))
        {
            //delete pen specific stuff
            // remove Insert Keystrokes
            pMenuPopup->DeleteMenu(ID_PEN_LENS, MF_BYCOMMAND);
            int nIndex = pMenuPopup->GetMenuItemCount()-1; //index of last item
            // remove Edit Text...
            pMenuPopup->DeleteMenu(nIndex, MF_BYPOSITION);
            // remove separator
            pMenuPopup->DeleteMenu(nIndex-1, MF_BYPOSITION);
        }
        return pMenuPopup->Detach();
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadView operations

void CWordPadView::WrapChanged()
{
    CWaitCursor wait;
    CFrameWnd* pFrameWnd = GetParentFrame();
    ASSERT(pFrameWnd != NULL);
    pFrameWnd->SetMessageText(IDS_FORMATTING);
    CWnd* pBarWnd = pFrameWnd->GetMessageBar();
    if (pBarWnd != NULL)
        pBarWnd->UpdateWindow();

    CRichEdit2View::WrapChanged();

    pFrameWnd->SetMessageText(AFX_IDS_IDLEMESSAGE);
    if (pBarWnd != NULL)
        pBarWnd->UpdateWindow();
}

void CWordPadView::SetUpdateTimer()
{
    if (m_uTimerID != 0) // if outstanding timer kill it
        KillTimer(m_uTimerID);
    m_uTimerID = SetTimer(1, 1000, NULL); //set a timer for 1000 milliseconds
    if (m_uTimerID == 0) // no timer available so force update now
        GetDocument()->UpdateAllItems(NULL);
    else
        m_bDelayUpdateItems = TRUE;
}

void CWordPadView::DeleteContents()
{
    ASSERT_VALID(this);
    ASSERT(m_hWnd != NULL);
    CRichEdit2View::DeleteContents();
    SetDefaultFont(IsTextType(GetDocument()->m_nNewDocType));
}

void CWordPadView::SetDefaultFont(BOOL bText)
{
    ASSERT_VALID(this);
    ASSERT(m_hWnd != NULL);
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    CHARFORMAT* pCharFormat = bText ? &m_defTextCharFormat : &m_defCharFormat;
    // set the default character format -- the FALSE makes it the default
    GetRichEditCtrl().SetSel(0,-1);
    GetRichEditCtrl().SetDefaultCharFormat(*pCharFormat);
    GetRichEditCtrl().SetSelectionCharFormat(*pCharFormat);

    GetRichEditCtrl().SetParaFormat(m_defParaFormat);

    GetRichEditCtrl().SetSel(0,0);
    GetRichEditCtrl().EmptyUndoBuffer();
    GetRichEditCtrl().SetModify(FALSE);
    ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadView drawing

/////////////////////////////////////////////////////////////////////////////
// CWordPadView printing

void CWordPadView::OnBeginPrinting(CDC* pDC, CPrintInfo* printInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    // initialize page start vector
    ASSERT(m_aPageStart.GetSize() == 0);
    ASSERT(NULL != printInfo);
    ASSERT(NULL != printInfo->m_pPD);

    OnPrinterChanged(*pDC);

    m_aPageStart.Add(0);
    ASSERT(m_aPageStart.GetSize() > 0);

    if (printInfo->m_pPD->PrintSelection())
    {
        CHARRANGE   range;

        GetRichEditCtrl().GetSel(range);
        m_aPageStart[0] = range.cpMin;
    }

    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache

    ASSERT_VALID(this);
}

void CWordPadView::OnPrint(CDC* pDC, CPrintInfo* pInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    ASSERT(pInfo != NULL);
    ASSERT(pInfo->m_bContinuePrinting);
    ASSERT(NULL != pInfo->m_pPD);

    UINT nPage              = pInfo->m_nCurPage;
    ASSERT(nPage <= (UINT)m_aPageStart.GetSize());

    long nIndex             = (long) m_aPageStart[nPage-1];
    BOOL bPrintSelection    = pInfo->m_pPD->PrintSelection();
    long nFinalCharIndex;

    if (bPrintSelection)
    {
        CHARRANGE range;

        GetRichEditCtrl().GetSel(range);
        
        nFinalCharIndex = range.cpMax;
    }
    else
    {
        GETTEXTLENGTHEX textlen;

        textlen.flags = GTL_DEFAULT;
#ifdef UNICODE
        textlen.codepage = 1200;            // Unicode code page
#else
        textlen.codepage = CP_ACP;
#endif

        nFinalCharIndex = this->SendMessage(
                                    EM_GETTEXTLENGTHEX, 
                                    (WPARAM) &textlen,
                                    0);
    }

    // print as much as possible in the current page.
    nIndex = PrintPage(pDC, nIndex, nFinalCharIndex);

    if (nIndex >= nFinalCharIndex)
    {
        TRACE0("End of Document\n");
        pInfo->SetMaxPage(nPage);
    }

    // update pagination information for page just printed
    if (nPage == (UINT)m_aPageStart.GetSize())
    {
        if (nIndex < nFinalCharIndex)
            m_aPageStart.Add(nIndex);
    }
    else
    {
        ASSERT(nPage+1 <= (UINT)m_aPageStart.GetSize());
        ASSERT(nIndex == (long)m_aPageStart[nPage+1-1]);
    }

    if (pInfo != NULL && pInfo->m_bPreview)
        DrawMargins(pDC);
}

void CWordPadView::DrawMargins(CDC* pDC)
{
    if (pDC->m_hAttribDC != NULL)
    {
        CRect rect;
        rect.left = m_rectMargin.left;
        rect.right = m_sizePaper.cx - m_rectMargin.right;
        rect.top = m_rectMargin.top;
        rect.bottom = m_sizePaper.cy - m_rectMargin.bottom;
        //rect in twips
        int logx = ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSX);
        int logy = ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSY);
        rect.left = MulDiv(rect.left, logx, 1440);
        rect.right = MulDiv(rect.right, logx, 1440);
        rect.top = MulDiv(rect.top, logy, 1440);
        rect.bottom = MulDiv(rect.bottom, logy, 1440);
        CPen pen(PS_DOT, 0, pDC->GetTextColor());
        CPen* ppen = pDC->SelectObject(&pen);
        pDC->MoveTo(0, rect.top);
        pDC->LineTo(10000, rect.top);
        pDC->MoveTo(rect.left, 0);
        pDC->LineTo(rect.left, 10000);
        pDC->MoveTo(0, rect.bottom);
        pDC->LineTo(10000, rect.bottom);
        pDC->MoveTo(rect.right, 0);
        pDC->LineTo(rect.right, 10000);
        pDC->SelectObject(ppen);
    }
}

BOOL CWordPadView::OnPreparePrinting(CPrintInfo* pInfo)
{
   CWordPadApp *pApp = NULL ;

   pApp = (CWordPadApp *) AfxGetApp() ;

   if (NULL != pApp)
   {
       if ( (pApp->cmdInfo.m_nShellCommand == CCommandLineInfo::FilePrintTo) ||
            (pApp->cmdInfo.m_nShellCommand == CCommandLineInfo::FilePrint) )
       {
           if (pInfo->m_pPD->m_pd.hDevNames == NULL)
           {
               HGLOBAL hDn = pApp->GetDevNames() ;

               if (hDn != NULL)
               {
                   pInfo->m_pPD->m_pd.hDevNames = hDn ;
               }
           }
       }
   }
        
    if (SEL_EMPTY != GetRichEditCtrl().GetSelectionType())
    {
        pInfo->m_pPD->m_pd.Flags = pInfo->m_pPD->m_pd.Flags & ~PD_NOSELECTION;
    }
    
    return DoPreparePrinting(pInfo);
}


void CWordPadView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    ASSERT(pInfo != NULL);  // overriding OnPaint -- never get this.

    pDC->SetMapMode(MM_TEXT);

    if (pInfo->m_nCurPage > (UINT)m_aPageStart.GetSize() &&
        !PaginateTo(pDC, pInfo))
    {
        // can't paginate to that page, thus cannot print it.
        pInfo->m_bContinuePrinting = FALSE;
    }
    ASSERT_VALID(this);
}

BOOL CWordPadView::PaginateTo(CDC* pDC, CPrintInfo* pInfo)
    // attempts pagination to pInfo->m_nCurPage, TRUE == success
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);

    CRect rectSave = pInfo->m_rectDraw;
    UINT nPageSave = pInfo->m_nCurPage;
    ASSERT(nPageSave > 1);
    ASSERT(nPageSave >= (UINT)m_aPageStart.GetSize());
    pDC->IntersectClipRect(0, 0, 0, 0);
    pInfo->m_nCurPage = m_aPageStart.GetSize();
    while (pInfo->m_nCurPage < nPageSave)
    {
        ASSERT(pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize());
        OnPrepareDC(pDC, pInfo);
        ASSERT(pInfo->m_bContinuePrinting);
        pInfo->m_rectDraw.SetRect(0, 0,
            pDC->GetDeviceCaps(HORZRES), pDC->GetDeviceCaps(VERTRES));
        pDC->DPtoLP(&pInfo->m_rectDraw);
        OnPrint(pDC, pInfo);
        if (pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize())
            break;
        ++pInfo->m_nCurPage;
    }
    BOOL bResult = pInfo->m_nCurPage == nPageSave;
    pInfo->m_nCurPage = nPageSave;
    pInfo->m_rectDraw = rectSave;
   pDC->SelectClipRgn(NULL) ;
    ASSERT_VALID(this);
    return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

inline int roundleast(int n)
{
    int mod = n%10;
    n -= mod;
    if (mod >= 5)
        n += 10;
    else if (mod <= -5)
        n -= 10;
    return n;
}

static void RoundRect(LPRECT r1)
{
    r1->left = roundleast(r1->left);
    r1->right = roundleast(r1->right);
    r1->top = roundleast(r1->top);
    r1->bottom = roundleast(r1->bottom);
}

static void MulDivRect(LPRECT r1, LPRECT r2, int num, int div)
{
    r1->left = MulDiv(r2->left, num, div);
    r1->top = MulDiv(r2->top, num, div);
    r1->right = MulDiv(r2->right, num, div);
    r1->bottom = MulDiv(r2->bottom, num, div);
}

void CWordPadView::OnPageSetup()
{
    theApp.EnsurePrinterIsInitialized();

    CPageSetupDialog dlg;
    PAGESETUPDLG& psd = dlg.m_psd;
    BOOL bMetric = theApp.GetUnits() == 1; //centimeters
   BOOL fUpdateWrap = FALSE ;
    psd.Flags |= PSD_MARGINS | (bMetric ? PSD_INHUNDREDTHSOFMILLIMETERS :
        PSD_INTHOUSANDTHSOFINCHES);
    int nUnitsPerInch = bMetric ? 2540 : 1000;
    MulDivRect(&psd.rtMargin, m_rectMargin, nUnitsPerInch, 1440);
    RoundRect(&psd.rtMargin);
    // get the current device from the app
    PRINTDLG pd;
    pd.hDevNames = NULL;
    pd.hDevMode = NULL;
    theApp.GetPrinterDeviceDefaults(&pd);
    psd.hDevNames = pd.hDevNames;
    psd.hDevMode = pd.hDevMode;

    SetHelpFixHook() ;

    if (dlg.DoModal() == IDOK)
    {
        RoundRect(&psd.rtMargin);
        MulDivRect(m_rectMargin, &psd.rtMargin, 1440, nUnitsPerInch);
        theApp.m_rectPageMargin = m_rectMargin;
        
        //
        // SelectPrinter will free the existing devnames and devmodes if the
        // third parameter is TRUE.  We don't want to do that because the 
        // print dialog frees them and allocates new ones.
        //

        theApp.SelectPrinter(psd.hDevNames, psd.hDevMode, FALSE);
        theApp.NotifyPrinterChanged();
        fUpdateWrap = TRUE ;
    }

    RemoveHelpFixHook() ;

    // PageSetupDlg failed
    if (CommDlgExtendedError() != 0)
    {
        CPageSetupDlg dlg;
        dlg.m_nBottomMargin = m_rectMargin.bottom;
        dlg.m_nLeftMargin = m_rectMargin.left;
        dlg.m_nRightMargin = m_rectMargin.right;
        dlg.m_nTopMargin = m_rectMargin.top;
        if (dlg.DoModal() == IDOK)
        {
            m_rectMargin.SetRect(dlg.m_nLeftMargin, dlg.m_nTopMargin,
                dlg.m_nRightMargin, dlg.m_nBottomMargin);
            // m_page will be changed at this point
            theApp.m_rectPageMargin = m_rectMargin;
            theApp.NotifyPrinterChanged();
         fUpdateWrap = TRUE ;
        }
    }

   if (fUpdateWrap)
   {
       CRichEdit2View::WrapChanged();
   }
}

/////////////////////////////////////////////////////////////////////////////
// OLE Server support

// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.  Here,
//  the server (not the container) causes the deactivation.
void CWordPadView::OnCancelEditSrvr()
{
    GetDocument()->OnDeactivateUI(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadView diagnostics

#ifdef _DEBUG
void CWordPadView::AssertValid() const
{
    CRichEdit2View::AssertValid();
}

void CWordPadView::Dump(CDumpContext& dc) const
{
    CRichEdit2View::Dump(dc);
}

CWordPadDoc* CWordPadView::GetDocument() // non-debug version is inline
{
    return (CWordPadDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWordPadView message helpers

/////////////////////////////////////////////////////////////////////////////
// CWordPadView message handlers

int CWordPadView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CRichEdit2View::OnCreate(lpCreateStruct) == -1)
        return -1;
    theApp.m_listPrinterNotify.AddTail(m_hWnd);

    if (theApp.m_bWordSel)
        GetRichEditCtrl().SetOptions(ECOOP_OR, ECO_AUTOWORDSELECTION);
    else
        GetRichEditCtrl().SetOptions(ECOOP_AND, ~(DWORD)ECO_AUTOWORDSELECTION);
//      GetRichEditCtrl().SetOptions(ECOOP_OR, ECO_SELECTIONBAR);

    GetDefaultFont(m_defTextCharFormat, IDS_DEFAULTTEXTFONT);
    GetDefaultFont(m_defCharFormat, IDS_DEFAULTFONT);
        
    GetRichEditCtrl().GetParaFormat(m_defParaFormat);
    m_defParaFormat.cTabCount = 0;

   //
   // Insert our own wrapper interface callback here to get around MFC defaults
   //

   VERIFY(GetRichEditCtrl().SetOLECallback(&m_xWordPadRichEditOleCallback));

    return 0;
}

void CWordPadView::GetDefaultFont(CCharFormat& cf, UINT nFontNameID)
{
    USES_CONVERSION;
    CString strDefFont;
    VERIFY(strDefFont.LoadString(nFontNameID));
    ASSERT(cf.cbSize == sizeof(CHARFORMAT));
    cf.dwMask = CFM_BOLD|CFM_ITALIC|CFM_UNDERLINE|CFM_STRIKEOUT|CFM_SIZE|
        CFM_COLOR|CFM_OFFSET|CFM_PROTECTED;
    cf.dwEffects = CFE_AUTOCOLOR;
    cf.yHeight = 200; //10pt
    cf.yOffset = 0;
    cf.crTextColor = RGB(0, 0, 0);
    cf.bCharSet = 0;
    cf.bPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
    ASSERT(strDefFont.GetLength() < LF_FACESIZE);
    lstrcpyn(cf.szFaceName, strDefFont, LF_FACESIZE);
    cf.dwMask |= CFM_FACE;
}

void CWordPadView::OnInsertDateTime()
{
    CDateDialog dlg;
    if (dlg.DoModal() == IDOK)
    {
        GetRichEditCtrl().ReplaceSel(dlg.m_strSel, TRUE);
    }
}

void CWordPadView::OnFormatParagraph()
{
    CFormatParaDlg dlg(GetParaFormatSelection());
    dlg.m_nWordWrap = m_nWordWrap;
    if (dlg.DoModal() == IDOK)
        SetParaFormat(dlg.m_pf);
}

void CWordPadView::OnFormatTabs()
{
    CFormatTabDlg dlg(GetParaFormatSelection());
    if (dlg.DoModal() == IDOK)
        SetParaFormat(dlg.m_pf);
}

void CWordPadView::OnTextNotFound(LPCTSTR lpStr)
{
    ASSERT_VALID(this);
    MessageBeep(0);
    AfxMessageBox(IDS_FINISHED_SEARCH,MB_OK|MB_ICONINFORMATION);
    CRichEdit2View::OnTextNotFound(lpStr);
}

void CWordPadView::OnColorPick(UINT nID)
{
    CRichEdit2View::OnColorPick(CColorMenu::GetColor(nID));
}

void CWordPadView::OnTimer(UINT nIDEvent)
{
    if (m_uTimerID != nIDEvent) // not our timer
        CRichEdit2View::OnTimer(nIDEvent);
    else
    {
        KillTimer(m_uTimerID); // kill one-shot timer
        m_uTimerID = 0;
        if (m_bDelayUpdateItems)
            GetDocument()->UpdateAllItems(NULL);
        m_bDelayUpdateItems = FALSE;
    }
}

void CWordPadView::OnEditChange()
{
    SetUpdateTimer();
}

void CWordPadView::OnDestroy()
{
    POSITION pos = theApp.m_listPrinterNotify.Find(m_hWnd);
    ASSERT(pos != NULL);
    theApp.m_listPrinterNotify.RemoveAt(pos);

    CRichEdit2View::OnDestroy();
    
    if (m_uTimerID != 0) // if outstanding timer kill it
        OnTimer(m_uTimerID);
    ASSERT(m_uTimerID == 0);

   CWnd *pWnd = AfxGetMainWnd() ;

   if (NULL == pWnd)
   {
       return ;
   }

   pWnd = pWnd->GetTopLevelParent() ;

   if (NULL == pWnd)
   {
       return ;
   }

   ::WinHelp(pWnd->m_hWnd, WORDPAD_HELP_FILE, HELP_QUIT, 0) ;
}

void CWordPadView::CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType)
{
    int nOldWidth = lpClientRect->right - lpClientRect->left;
    CRichEdit2View::CalcWindowRect(lpClientRect, nAdjustType);

    if (theApp.m_bWin4 && nAdjustType != 0 && (GetStyle() & WS_VSCROLL))
        lpClientRect->right--;

    // if the ruler is visible then slide the view up under the ruler to avoid
    // showing the top border of the view
    if (GetExStyle() & WS_EX_CLIENTEDGE)
    {
        CFrameWnd* pFrame = GetParentFrame();
        if (pFrame != NULL)
        {
            CRulerBar* pBar = (CRulerBar*)pFrame->GetControlBar(ID_VIEW_RULER);
            if (pBar != NULL)
            {
                BOOL bVis = pBar->IsVisible();
                if (pBar->m_bDeferInProgress)
                    bVis = !bVis;
                if (bVis)
                    lpClientRect->top -= 2;
            }
        }
    }
}

void CWordPadView::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMIS)
{
    lpMIS->itemID = (UINT)(WORD)lpMIS->itemID;
    CRichEdit2View::OnMeasureItem(nIDCtl, lpMIS);
}

void CWordPadView::OnPenBackspace()
{
    SendMessage(WM_KEYDOWN, VK_BACK, 0);
    SendMessage(WM_KEYUP, VK_BACK, 0);
}

void CWordPadView::OnPenNewline()
{
    SendMessage(WM_CHAR, '\n', 0);
}

void CWordPadView::OnPenPeriod()
{
    SendMessage(WM_CHAR, '.', 0);
}

void CWordPadView::OnPenSpace()
{
    SendMessage(WM_CHAR, ' ', 0);
}

void CWordPadView::OnPenTab()
{
    SendMessage(WM_CHAR, VK_TAB, 0);
}

void CWordPadView::OnDelayedInvalidate()
{
    Invalidate() ;
}

void CWordPadView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if (nChar == VK_F10 && GetKeyState(VK_SHIFT) < 0)
    {
        long nStart, nEnd;
        GetRichEditCtrl().GetSel(nStart, nEnd);
        CPoint pt = GetRichEditCtrl().GetCharPos(nEnd);
        SendMessage(WM_CONTEXTMENU, (WPARAM)m_hWnd, MAKELPARAM(pt.x, pt.y));
    }

   CRichEdit2View::OnKeyDown(nChar, nRepCnt, nFlags);
}

HRESULT CWordPadView::GetClipboardData(CHARRANGE* lpchrg, DWORD /*reco*/,
    LPDATAOBJECT lpRichDataObj,     LPDATAOBJECT* lplpdataobj)
{
    CHARRANGE& cr = *lpchrg;

    if (NULL == lpRichDataObj)
        return E_INVALIDARG;

    if ((cr.cpMax - cr.cpMin == 1) &&
        GetRichEditCtrl().GetSelectionType() == SEL_OBJECT)
    {
        return E_NOTIMPL;
    }

    BeginWaitCursor();
    //create the data source
    COleDataSource* pDataSource = new COleDataSource;

    // put the formats into the data source
    LPENUMFORMATETC lpEnumFormatEtc;
    lpRichDataObj->EnumFormatEtc(DATADIR_GET, &lpEnumFormatEtc);
    if (lpEnumFormatEtc != NULL)
    {
        FORMATETC etc;
        while (lpEnumFormatEtc->Next(1, &etc, NULL) == S_OK)
        {
            STGMEDIUM stgMedium;
            lpRichDataObj->GetData(&etc, &stgMedium);
            pDataSource->CacheData(etc.cfFormat, &stgMedium, &etc);
        }
        lpEnumFormatEtc->Release();
    }

    CEmbeddedItem item(GetDocument(), cr.cpMin, cr.cpMax);
    item.m_lpRichDataObj = lpRichDataObj;
    // get wordpad formats
    item.GetClipboardData(pDataSource);

    // get the IDataObject from the data source
    *lplpdataobj =  (LPDATAOBJECT)pDataSource->GetInterface(&IID_IDataObject);

    EndWaitCursor();
    return S_OK;
}


HRESULT CWordPadView::PasteHDROPFormat(HDROP hDrop)
{
    HRESULT hr = S_OK ;
    UINT i ;
    TCHAR szFile[MAX_PATH + 1] ;
    CHARRANGE cr ;
    LONG tmp ;
    UINT cFiles ;

    cFiles = DragQueryFile(hDrop, (UINT) -1, NULL, 0) ;

    GetRichEditCtrl().GetSel(cr);

    tmp = cr.cpMin ;

    for (i=0; i<cFiles; i++)
    {
        ::DragQueryFile(hDrop, i, szFile, MAX_PATH) ;

        if (FILE_ATTRIBUTE_DIRECTORY == GetFileAttributes(szFile))
        {
            continue ;
        }

        //
        // Fix the selection state up so that multiple objects insert
        // at the right spot
        //

        cr.cpMin = cr.cpMax ;

        GetRichEditCtrl().SetSel(cr);

        //
        // Insert from file
        //

        InsertFileAsObject(szFile) ;
    }

    GetRichEditCtrl().SetSel(cr);

    return hr ;
}

HRESULT CWordPadView::QueryAcceptData(LPDATAOBJECT lpdataobj,
    CLIPFORMAT* lpcfFormat, DWORD reco, BOOL bReally,
    HGLOBAL hMetaPict)
{
   HRESULT hr = S_OK ;

   if (!bReally)
   {
       g_fRightButtonDrag = 0x8000 & GetAsyncKeyState(
                                            GetSystemMetrics(SM_SWAPBUTTON)
                                            ? VK_LBUTTON 
                                            : VK_RBUTTON);
   }

   //
   // If we are doing an inproc drag-drop, we want our drop
   // effect to be DROPEFFECT_MOVE but if we are drag-dropping
   // from another application, we want our effect to be
   // DROPEFFECT_COPY -- in particular so that we don't delete
   // icons dragged from the explorer or text dragged from Word!
   //
   // The reason for this hack is that richedit doesn't supply
   // any mechanism for us to determine whether or not we are
   // both the drop source and the drop target.
   //

   if (!bReally)
   {
       LPUNKNOWN pUnk = NULL ;

       if (S_OK == lpdataobj->QueryInterface(
                        IID_IProxyManager,
                        (LPVOID *) &pUnk))
       {
           //
           // We got an IProxyManager pointer, so we are NOT doing an
           // inproc drag drop
           //

           pUnk->Release() ;

           g_fInternalDragDrop = FALSE ;
       }
       else
       {
           g_fInternalDragDrop = TRUE ;
       }
   }
   else
   {
       g_fInternalDragDrop = FALSE ;
   }

   //
   // Check for native data first
   //

    if (bReally && *lpcfFormat == 0 && (m_nPasteType == 0))
    {
        COleDataObject dataobj;
        dataobj.Attach(lpdataobj, FALSE);
        if (!dataobj.IsDataAvailable(cfRTO)) // native avail, let richedit do as it wants
        {
            if (dataobj.IsDataAvailable(cfEmbeddedObject))
            {
                if (PasteNative(lpdataobj))
            {
               hr = S_FALSE ;

               goto errRet ;
            }
            }
        }
    }

   //
   // We need to support HDROP format from the explorer
   // and the desktop
   //

   if (bReally)
   {
       FORMATETC fe ;

       fe.cfFormat = CF_HDROP ;
       fe.ptd = NULL ;
       fe.dwAspect = DVASPECT_CONTENT ;
       fe.lindex = -1 ;
       fe.tymed = TYMED_HGLOBAL ;

       if (S_OK == lpdataobj->QueryGetData(&fe))
       {
           STGMEDIUM sm ;

           sm.tymed = TYMED_NULL ;
           sm.hGlobal = (HGLOBAL) 0 ;
           sm.pUnkForRelease = NULL ;

           if (S_OK == lpdataobj->GetData(&fe, &sm))
           {
               //
               // If we have a single file in our HDROP data then
               // embed source might *also* be available in which case we
               // should just use the default richedit logic and
               // skip PasteHDROPFormat().  We should not ever get
               // embed source AND an HDROP data block containing
               // multiple files because OLE only supports one drop
               // source per drag-drop operation.  The default richedit
               // logic should handle all cases while dropping a single
               // file, we just have to special case things while dropping
               // multiple files.
               //

               if (DragQueryFile((HDROP) sm.hGlobal, (UINT) -1, NULL, 0) > 1)
               {
                   PasteHDROPFormat((HDROP) sm.hGlobal) ;
                   hr = S_FALSE ;
               }
               else
               {
                   hr = S_OK ;
               }

               ::ReleaseStgMedium(&sm) ;

               if (S_FALSE == hr)
               {
                   goto errRet ;
               }
           }
       }
   }

   //
   // If all else fails, let richedit give it a try
   //

   hr = CRichEdit2View::QueryAcceptData(lpdataobj, lpcfFormat, reco, bReally,
        hMetaPict);

errRet:

   if (bReally)
   {
       //
       // We post a message to ourselves here instead of just calling
       // ::Invalidate() because the richedit control doesn't always
       // repaint unless it is completely done with the data transfer operation.
       //

       PostMessage(WM_COMMAND, ID_DELAYED_INVALIDATE, 0) ;
   }

   return hr ;
}


BOOL CWordPadView::PasteNative(LPDATAOBJECT lpdataobj)
{
    // check data object for wordpad object
    // if true, pull out RTF directly

    FORMATETC etc = {NULL, NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE};
    etc.cfFormat = (CLIPFORMAT)cfEmbeddedObject;
    STGMEDIUM stgMedium = {TYMED_ISTORAGE, 0, NULL};

    // create an IStorage to transfer the data in
    LPLOCKBYTES lpLockBytes;
    if (FAILED(::CreateILockBytesOnHGlobal(NULL, TRUE, &lpLockBytes)))
        return FALSE;
    ASSERT(lpLockBytes != NULL);

    HRESULT hr = ::StgCreateDocfileOnILockBytes(lpLockBytes,
        STGM_SHARE_EXCLUSIVE|STGM_CREATE|STGM_READWRITE, 0, &stgMedium.pstg);
    lpLockBytes->Release(); //storage addref'd
    if (FAILED(hr))
        return FALSE;

    ASSERT(stgMedium.pstg != NULL);

    CLSID clsid;

    BOOL bRes = FALSE; //let richedit do what it wants

    if (SUCCEEDED(lpdataobj->GetDataHere(&etc, &stgMedium)) &&
        SUCCEEDED(ReadClassStg(stgMedium.pstg, &clsid)) &&
        clsid == GetDocument()->GetClassID())
    {
        //pull out RTF now
        // open Contents stream

        COleStreamFile file;
        CFileException fe;
        if (file.OpenStream(stgMedium.pstg, szContents,
            CFile::modeReadWrite|CFile::shareExclusive, &fe))
        {
            CRichEdit2Doc  *doc = GetDocument();
            BOOL            bRTF = doc->m_bRTF;
            BOOL            bUnicode = doc->m_bUnicode;

            // Force the "current" stream type to be rtf

            doc->m_bRTF = TRUE;
            doc->m_bUnicode = FALSE;

            // load it with CArchive (loads from Contents stream)
            CArchive loadArchive(&file, CArchive::load |
                CArchive::bNoFlushOnDelete);
            Stream(loadArchive, TRUE); //stream in selection

            // Restore the "current" stream type

            doc->m_bRTF = bRTF;
            doc->m_bUnicode = bUnicode;

            bRes = TRUE; // don't let richedit do anything
        }
    }
    ::ReleaseStgMedium(&stgMedium);
    return bRes;
}

// things to fix
// if format==0 we are doing a straight EM_PASTE
//      look for native formats
//              richedit specific -- allow richedit to handle (these will be first)
//              look for RTF, CF_TEXT.  If there paste special as these
//      Do standard OLE scenario

// if pasting a particular format (format != 0)
//      if richedit specific, allow through
//      if RTF, CF_TEXT. paste special
//      if OLE format, do standard OLE scenario


void CWordPadView::OnFilePrint()
{
    theApp.EnsurePrinterIsInitialized();

    // don't allow winini changes to occur while printing
    m_bInPrint = TRUE;

    SetHelpFixHook() ;

    CRichEdit2View::OnFilePrint();

    RemoveHelpFixHook() ;
    
    // printer may have changed
    theApp.NotifyPrinterChanged(); // this will cause a GetDocument()->PrinterChanged();
    m_bInPrint = FALSE;
}

void CWordPadView::OnFilePrintPreview()
{
    theApp.EnsurePrinterIsInitialized();
    
    CRichEdit2View::OnFilePrintPreview();
}

int CWordPadView::OnMouseActivate(CWnd* pWnd, UINT nHitTest, UINT message)
{
    if (m_bOnBar)
    {
        SetFocus();
        return MA_ACTIVATEANDEAT;
    }
    else
        return CRichEdit2View::OnMouseActivate(pWnd, nHitTest, message);
}

typedef BOOL (WINAPI *PCWPROC)(HWND, LPSTR, UINT, LPVOID, DWORD, DWORD);
void CWordPadView::OnPenLens()
{
    USES_CONVERSION;
    HINSTANCE hLib = LoadLibrary(_T("PENWIN32.DLL"));
    if (hLib == NULL)
        return;
    PCWPROC pCorrectWriting = (PCWPROC)GetProcAddress(hLib, "CorrectWriting");
    ASSERT(pCorrectWriting != NULL);
    if (pCorrectWriting != NULL)
    {
        CHARRANGE cr;
        GetRichEditCtrl().GetSel(cr);
        int nCnt = 2*(cr.cpMax-cr.cpMin);
        BOOL bSel = (nCnt != 0);
        nCnt = max(1024, nCnt);
        char* pBuf = new char[nCnt];
        pBuf[0] = NULL;
        if (bSel)
            GetRichEditCtrl().GetSelText(pBuf);
        if (pCorrectWriting(m_hWnd, pBuf, nCnt, 0, bSel ? 0 : CWR_INSERT, 0))
            GetRichEditCtrl().ReplaceSel(A2T(pBuf));
        delete [] pBuf;
    }
    FreeLibrary(hLib);
}

LONG CWordPadView::OnPrinterChangedMsg(UINT, LONG)
{
    CDC dc;
    AfxGetApp()->CreatePrinterDC(dc);
    OnPrinterChanged(dc);
    return 0;
}

static void ForwardPaletteChanged(HWND hWndParent, HWND hWndFocus)
{
    // this is a quick and dirty hack to send the WM_QUERYNEWPALETTE to a window that is interested
    HWND hWnd = NULL;
    for (hWnd = ::GetWindow(hWndParent, GW_CHILD); hWnd != NULL; hWnd = ::GetWindow(hWnd, GW_HWNDNEXT))
    {
        if (hWnd != hWndFocus)
        {
            ::SendMessage(hWnd, WM_PALETTECHANGED, (WPARAM)hWndFocus, 0L);
            ForwardPaletteChanged(hWnd, hWndFocus);
        }
    }
}

void CWordPadView::OnPaletteChanged(CWnd* pFocusWnd)
{
    ForwardPaletteChanged(m_hWnd, pFocusWnd->GetSafeHwnd());
    // allow the richedit control to realize its palette
    // remove this if if richedit fixes their code so that
    // they don't realize their palette into foreground
    if (::GetWindow(m_hWnd, GW_CHILD) == NULL)
        CRichEdit2View::OnPaletteChanged(pFocusWnd);
}

static BOOL FindQueryPalette(HWND hWndParent)
{
    // this is a quick and dirty hack to send the WM_QUERYNEWPALETTE to a window that is interested
    HWND hWnd = NULL;
    for (hWnd = ::GetWindow(hWndParent, GW_CHILD); hWnd != NULL; hWnd = ::GetWindow(hWnd, GW_HWNDNEXT))
    {
        if (::SendMessage(hWnd, WM_QUERYNEWPALETTE, 0, 0L))
            return TRUE;
        else if (FindQueryPalette(hWnd))
            return TRUE;
    }
    return FALSE;
}

BOOL CWordPadView::OnQueryNewPalette()
{
    if(FindQueryPalette(m_hWnd))
        return TRUE;
    return CRichEdit2View::OnQueryNewPalette();
}

void CWordPadView::OnWinIniChange(LPCTSTR lpszSection)
{
    CRichEdit2View::OnWinIniChange(lpszSection);
    //printer might have changed
    if (!m_bInPrint)
    {
        if (lstrcmpi(lpszSection, _T("windows")) == 0)
            theApp.NotifyPrinterChanged(TRUE); // force update to defaults
    }
}

void CWordPadView::OnSize(UINT nType, int cx, int cy)
{
    CRichEdit2View::OnSize(nType, cx, cy);
    CRect rect(HORZ_TEXTOFFSET, VERT_TEXTOFFSET, cx, cy);
    GetRichEditCtrl().SetRect(rect);
}

void CWordPadView::OnGetCharFormat(NMHDR* pNMHDR, LRESULT* pRes)
{
    ASSERT(pNMHDR != NULL);
    ASSERT(pRes != NULL);

    ((CHARHDR*)pNMHDR)->cf = GetCharFormatSelection();
    *pRes = 1;
}

void CWordPadView::OnSetCharFormat(NMHDR* pNMHDR, LRESULT* pRes)
{
    ASSERT(pNMHDR != NULL);
    ASSERT(pRes != NULL);
    SetCharFormat(((CHARHDR*)pNMHDR)->cf);
    *pRes = 1;
}

void CWordPadView::OnBarSetFocus(NMHDR*, LRESULT*)
{
    m_bOnBar = TRUE;
}

void CWordPadView::OnBarKillFocus(NMHDR*, LRESULT*)
{
    m_bOnBar = FALSE;
}

void CWordPadView::OnBarReturn(NMHDR*, LRESULT* )
{
    SetFocus();
}

void CWordPadView::OnFormatFont()
{
    SetHelpFixHook() ;

    CRichEdit2View::OnFormatFont() ;

    RemoveHelpFixHook() ;
}

void CWordPadView::OnInsertObject()
{
    g_fDisableStandardHelp = TRUE ;

    SetHelpFixHook() ;

    CRichEdit2View::OnInsertObject() ;

    RemoveHelpFixHook() ;

   g_fDisableStandardHelp = FALSE ;
}

void CWordPadView::OnEditPasteSpecial()
{
    g_fDisableStandardHelp = TRUE ;

    SetHelpFixHook() ;

    CRichEdit2View::OnEditPasteSpecial() ;

    RemoveHelpFixHook() ;

    g_fDisableStandardHelp = FALSE ;
}

void CWordPadView::OnEditFind()
{
    SetHelpFixHook() ;

    CRichEdit2View::OnEditFind() ;

    RemoveHelpFixHook() ;
}

void CWordPadView::OnEditReplace()
{
    SetHelpFixHook() ;

    CRichEdit2View::OnEditReplace() ;

    RemoveHelpFixHook() ;
}

void CWordPadView::OnEditProperties()
{
    g_fDisableStandardHelp = TRUE ;

    SetHelpFixHook() ;

    CRichEdit2View::OnEditProperties() ;

    RemoveHelpFixHook() ;

   g_fDisableStandardHelp = FALSE ;
}


/////////////////////////////////////////////////////////////////////////////
// CWordPadView::XRichEditOleCallback
//
// We implement this so we can override the defaults that MFC has set up.  For
// the most part, we just delegate to MFC.
//

BEGIN_INTERFACE_MAP(CWordPadView, CCtrlView)
    // we use IID_IUnknown because richedit doesn't define an IID
     INTERFACE_PART(CWordPadView, IID_IUnknown, WordPadRichEditOleCallback)
END_INTERFACE_MAP()

STDMETHODIMP_(ULONG) CWordPadView::XWordPadRichEditOleCallback::AddRef()
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

    return pThis->m_xRichEditOleCallback.AddRef() ;
}

STDMETHODIMP_(ULONG) CWordPadView::XWordPadRichEditOleCallback::Release()
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

    return pThis->m_xRichEditOleCallback.Release() ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::QueryInterface(
    REFIID iid, LPVOID* ppvObj)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

    return pThis->m_xRichEditOleCallback.QueryInterface(iid, ppvObj) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetNewStorage(LPSTORAGE* ppstg)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

    return pThis->m_xRichEditOleCallback.GetNewStorage(ppstg) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetInPlaceContext(
    LPOLEINPLACEFRAME* lplpFrame, LPOLEINPLACEUIWINDOW* lplpDoc,
    LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

    return pThis->m_xRichEditOleCallback.GetInPlaceContext(lplpFrame, lplpDoc, lpFrameInfo) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::ShowContainerUI(BOOL fShow)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

    return pThis->m_xRichEditOleCallback.ShowContainerUI(fShow) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::QueryInsertObject(
    LPCLSID lpclsid, LPSTORAGE pstg, LONG cp)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

    return pThis->m_xRichEditOleCallback.QueryInsertObject(lpclsid, pstg, cp) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::DeleteObject(LPOLEOBJECT lpoleobj)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

    return pThis->m_xRichEditOleCallback.DeleteObject(lpoleobj) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::QueryAcceptData(
    LPDATAOBJECT lpdataobj, CLIPFORMAT* lpcfFormat, DWORD reco,
    BOOL fReally, HGLOBAL hMetaPict)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

    return pThis->m_xRichEditOleCallback.QueryAcceptData(lpdataobj, lpcfFormat, reco,
                fReally, hMetaPict) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::ContextSensitiveHelp(BOOL fEnterMode)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

     return pThis->m_xRichEditOleCallback.ContextSensitiveHelp(fEnterMode) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetClipboardData(
    CHARRANGE* lpchrg, DWORD reco, LPDATAOBJECT* lplpdataobj)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

    return pThis->m_xRichEditOleCallback.GetClipboardData(lpchrg, reco, lplpdataobj) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetDragDropEffect(
    BOOL fDrag, DWORD grfKeyState, LPDWORD pdwEffect)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

    if (!fDrag) // allowable dest effects
    {
        DWORD   dwEffect;

        // check for force link
#ifndef _MAC
        if ((grfKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
#else
        if ((grfKeyState & (MK_OPTION|MK_SHIFT)) == (MK_OPTION|MK_SHIFT))
#endif
            dwEffect = DROPEFFECT_LINK;
        // check for force copy
#ifndef _MAC
        else if ((grfKeyState & MK_CONTROL) == MK_CONTROL)
#else
        else if ((grfKeyState & MK_OPTION) == MK_OPTION)
#endif
            dwEffect = DROPEFFECT_COPY;
        // check for force move
        else if ((grfKeyState & MK_ALT) == MK_ALT)
            dwEffect = DROPEFFECT_MOVE;
        // default -- recommended action is 'copy' (overridden from MFC default)
        else
        {
            if (g_fInternalDragDrop)
            {
                dwEffect = DROPEFFECT_MOVE ;
            }
            else
            {
                dwEffect = DROPEFFECT_COPY;
            }
        }

        pThis->m_nPasteType = 0;

        if (dwEffect & *pdwEffect) // make sure allowed type
        {
            *pdwEffect = dwEffect;

            if (DROPEFFECT_LINK == dwEffect)
                pThis->m_nPasteType = COlePasteSpecialDialog::pasteLink;
        }
    }
    return S_OK;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetContextMenu(
    WORD seltype, LPOLEOBJECT lpoleobj, CHARRANGE* lpchrg,
    HMENU* lphmenu)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

    HRESULT hr;

    if (g_fRightButtonDrag)
        hr = E_FAIL;
    else 
        hr = pThis->m_xRichEditOleCallback.GetContextMenu(
                                                    seltype, 
                                                    lpoleobj, 
                                                    lpchrg, 
                                                    lphmenu);

    g_fRightButtonDrag = FALSE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\wordpad\memphis\wordpvw.h ===
// wordpvw.h : interface of the CWordPadView class
//
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CWordPadView : public CRichEdit2View
{
protected: // create from serialization only
	CWordPadView();
	DECLARE_DYNCREATE(CWordPadView)

// Attributes
public:
	UINT m_uTimerID;
	BOOL m_bDelayUpdateItems;
	BOOL m_bInPrint;
	CParaFormat m_defParaFormat;
	CCharFormat m_defCharFormat;
	CCharFormat m_defTextCharFormat;

	CWordPadDoc* GetDocument();
	BOOL IsFormatText();

	virtual HMENU GetContextMenu(WORD seltype, LPOLEOBJECT lpoleobj,
		CHARRANGE* lpchrg);

// Operations
public:
	BOOL PasteNative(LPDATAOBJECT lpdataobj);
	void SetDefaultFont(BOOL bText);
	void SetUpdateTimer();
	void GetDefaultFont(CCharFormat& cf, UINT nFontNameID);
	void DrawMargins(CDC* pDC);
	BOOL SelectPalette();
   HRESULT PasteHDROPFormat(HDROP hDrop) ;
   BOOL PaginateTo(CDC* pDC, CPrintInfo* pInfo) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWordPadView)
	protected:
	virtual void CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType = adjustBorder);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* printInfo);
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL
	BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual HRESULT GetClipboardData(CHARRANGE* lpchrg, DWORD reco,
		LPDATAOBJECT lpRichDataObj,	LPDATAOBJECT* lplpdataobj);
	virtual HRESULT QueryAcceptData(LPDATAOBJECT, CLIPFORMAT*, DWORD,
		BOOL, HGLOBAL);
public:
	virtual void WrapChanged();

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

//
// Wrapper for the richedit callback interface so we can
// get around some MFC defaults
//

public:

	BEGIN_INTERFACE_PART(WordPadRichEditOleCallback, IRichEditOleCallback)
		INIT_INTERFACE_PART(CWordPadView, WordPadRichEditOleCallback)
		STDMETHOD(GetNewStorage) (LPSTORAGE*);
		STDMETHOD(GetInPlaceContext) (LPOLEINPLACEFRAME*,
									  LPOLEINPLACEUIWINDOW*,
									  LPOLEINPLACEFRAMEINFO);
		STDMETHOD(ShowContainerUI) (BOOL);
		STDMETHOD(QueryInsertObject) (LPCLSID, LPSTORAGE, LONG);
		STDMETHOD(DeleteObject) (LPOLEOBJECT);
		STDMETHOD(QueryAcceptData) (LPDATAOBJECT, CLIPFORMAT*, DWORD,BOOL, HGLOBAL);
		STDMETHOD(ContextSensitiveHelp) (BOOL);
		STDMETHOD(GetClipboardData) (CHARRANGE*, DWORD, LPDATAOBJECT*);
		STDMETHOD(GetDragDropEffect) (BOOL, DWORD, LPDWORD);
		STDMETHOD(GetContextMenu) (WORD, LPOLEOBJECT, CHARRANGE*, HMENU*);
	END_INTERFACE_PART(WordPadRichEditOleCallback)

	DECLARE_INTERFACE_MAP()


protected:
	BOOL m_bOnBar;

	// OLE Container support

	virtual void DeleteContents();
	virtual void OnTextNotFound(LPCTSTR);

// Generated message map functions
protected:
	afx_msg void OnCancelEditSrvr();
	//{{AFX_MSG(CWordPadView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPageSetup();
	afx_msg void OnInsertDateTime();
   afx_msg void OnInsertObject();
	afx_msg void OnFormatParagraph();
	afx_msg void OnFormatFont();
	afx_msg void OnFormatTabs();
   afx_msg void OnEditPasteSpecial();
   afx_msg void OnEditProperties();
	afx_msg void OnEditFind();
	afx_msg void OnEditReplace();
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnDestroy();
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnPenBackspace();
	afx_msg void OnPenNewline();
	afx_msg void OnPenPeriod();
	afx_msg void OnPenSpace();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnFilePrint();
    afx_msg void OnFilePrintPreview();
	afx_msg void OnPenLens();
	afx_msg void OnPenTab();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	afx_msg BOOL OnQueryNewPalette();
	afx_msg void OnWinIniChange(LPCTSTR lpszSection);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDelayedInvalidate() ;
	//}}AFX_MSG
	afx_msg void OnEditChange();
	afx_msg void OnColorPick(UINT nID);
	afx_msg int OnMouseActivate(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg LONG OnPrinterChangedMsg(UINT, LONG);
	afx_msg void OnGetCharFormat(NMHDR* pNMHDR, LRESULT* pRes);
	afx_msg void OnSetCharFormat(NMHDR* pNMHDR, LRESULT* pRes);
	afx_msg void OnBarSetFocus(NMHDR*, LRESULT*);
	afx_msg void OnBarKillFocus(NMHDR*, LRESULT*);
	afx_msg void OnBarReturn(NMHDR*, LRESULT* );
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in wordpvw.cpp
inline CWordPadDoc* CWordPadView::GetDocument()
   { return (CWordPadDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\curschme.h ===
//Copyright (c) 1997-2000 Microsoft Corporation


#ifndef _INC_CURSCHME_H
#define _INC_CURSCHME_H

void ApplyCursorScheme(int nScheme);
#define IDSENG_CURSOR_SCHEME_WINDOWS_STANDARD_LARGE      __TEXT("Windows Standard (large)")
#define IDSENG_CURSOR_SCHEME_WINDOWS_STANDARD_EXTRALARGE __TEXT("Windows Standard (extra large)")
#define IDSENG_CURSOR_SCHEME_WINDOWS_BLACK               __TEXT("Windows Black ")
#define IDSENG_CURSOR_SCHEME_WINDOWS_BLACK_LARGE         __TEXT("Windows Black (large)")
#define IDSENG_CURSOR_SCHEME_WINDOWS_BLACK_EXTRALARGE    __TEXT("Windows Black (extra large)")
#define IDSENG_CURSOR_SCHEME_WINDOWS_INVERTED            __TEXT("Windows Inverted")
#define IDSENG_CURSOR_SCHEME_WINDOWS_INVERTED_LARGE      __TEXT("Windows Inverted (large)") 
#define IDSENG_CURSOR_SCHEME_WINDOWS_INVERTED_EXTRALARGE __TEXT("Windows Inverted (extra large)")            


#endif // _INC_CURSCHME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accesory\write\write.c ===
#include <windows.h>
#include <shellapi.h>

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    STARTUPINFOA si;
    LPSTR pszCmdLine = GetCommandLineA();

    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
    	     != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
    	    pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
    	    pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    ShellExecuteA(HWND_DESKTOP, NULL, "wordpad.exe", lpCmdLine, NULL,
                      si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    return 0 ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\accwiz.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_ACCWIZ_H
#define _INC_ACCWIZ_H

#include "schemes.h" // For SCHEMEDATALOCAL
#include "resource.h"

// Helper function
void LoadArrayFromStringTable(int nIdString, int *rgnValues, int *pnCountValues);

// Macros used to save debug info to/from the INI file
// JMC: HACK - Default to '1' for options!!!!!!!!
#define GET_SAVED_INT(xxx) xxx = GetPrivateProfileInt(__TEXT("Options"), __TEXT(#xxx), 1, __TEXT("AccWiz.ini"))
#define PUT_SAVED_INT(xxx) wsprintf(sz, __TEXT("%i"), xxx);WritePrivateProfileString(__TEXT("Options"), __TEXT(#xxx), sz, __TEXT("AccWiz.ini"))

// This class contains the general options for the whole wizard
class CAccWizOptions
{
public:
	CAccWizOptions()
	{
    }
	~CAccWizOptions()
	{
	}
    void InitAccWizOptions()
    {
		OSVERSIONINFO osvi;
		ZeroMemory(&osvi, sizeof(osvi));
		osvi.dwOSVersionInfoSize = sizeof(osvi);
		GetVersionEx(&osvi);
		m_bWin95 = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

		m_nMinimalFontSize = -1; // This will be set by the welcome page

		///////////////////////////////////////////////
		// Calculate globals that we need
 		HDC hDC = GetDC(NULL);
		m_nLogPixelsY = GetDeviceCaps(hDC, LOGPIXELSY);
		ReleaseDC(NULL, hDC);



		///////////////////////////////////////////////
		// Get the default char set for fonts
		TCHAR szCharSet[20];
		if(LoadString(g_hInstDll,IDS_FONTCHARSET, szCharSet,sizeof(szCharSet)/sizeof(TCHAR))) {
			m_lfCharSet = (BYTE)_tcstoul(szCharSet,NULL,10);
		} else {
			m_lfCharSet = 0; // Default
		}

		///////////////////////////////////////////////
		// Get the standard MS Sans Serif fonts
		// JMC: HACK - Free these resources
		int rgnStandardMSSansSerifFontSizes[] = {8, 10, 12, 14, 18, 24};
		LOGFONT lf;
		ZeroMemory(&lf, sizeof(lf));
		lf.lfCharSet = m_lfCharSet;
		LoadString(g_hInstDll, IDS_SYSTEMFONTNAME, lf.lfFaceName, ARRAYSIZE(lf.lfFaceName));
		

		for(int i=0;i<6;i++)
		{
			lf.lfHeight = 0 - (int)((float)m_nLogPixelsY * (float)rgnStandardMSSansSerifFontSizes[i]/ (float)72 + (float).5);
			m_rgnStdMSSansSerifFonts[i] = CreateFontIndirect(&lf);

			// Create underlined version
			lf.lfUnderline = 1;
			m_rgnStdMSSansSerifFonts[i + 6] = CreateFontIndirect(&lf);
			lf.lfUnderline = 0;

		}
		
		// Store away original non-client metrics
		// Get original metrics
		GetNonClientMetrics(&m_ncmOrig, &m_lfIconOrig);

		// Load original Wiz Scheme settings
		m_schemeOriginal.LoadOriginal();

		// Copy to the Preview scheme and to the current scheme
		m_schemePreview = m_schemeOriginal;
		m_schemeCurrent = m_schemeOriginal;

		// This is set by the welcome page, so that the second part knows to update it's check boxes.
		// The second page clears this flag
		m_bWelcomePageTouched = FALSE;

		// this is the default windows settings (for Win2K not necessarilly for Whistler)
		m_schemeWindowsDefault.SetToWindowsDefault();
#ifdef _DEBUG
		m_schemeOriginal.Dump();
#endif
	}

	void RestoreOriginalColorsToPreview()
	{
		memcpy(m_schemePreview.m_rgb, m_schemeOriginal.m_rgb, sizeof(m_schemePreview.m_rgb));
	}

	void ApplyPreview()
	{
		m_schemeCurrent.ApplyChanges(m_schemePreview);
	}
    void ApplyOriginal()
    {
        m_schemeCurrent.ApplyChanges(m_schemeOriginal, &m_ncmOrig, &m_lfIconOrig);
	}
	
    void ApplyWindowsDefault();

	BOOL m_bWelcomePageTouched;

	int m_nLogPixelsY;

	int m_nMinimalFontSize;

	HFONT GetClosestMSSansSerif(int nPointSize, BOOL bUnderlined = FALSE)
	{
		// For Underlined fonts, add '6' the the index
		int nOffset = bUnderlined?6:0;

		if(nPointSize <= 8)
			return m_rgnStdMSSansSerifFonts[0 + nOffset];
		else if(nPointSize <= 10)
			return m_rgnStdMSSansSerifFonts[1 + nOffset];
		else if(nPointSize <= 12)
			return m_rgnStdMSSansSerifFonts[2 + nOffset];
		else if(nPointSize <= 14)
			return m_rgnStdMSSansSerifFonts[3 + nOffset];
		else if(nPointSize <= 18)
			return m_rgnStdMSSansSerifFonts[4 + nOffset];
		return m_rgnStdMSSansSerifFonts[5];
	}

	void ReportChanges(HWND hwndChanges)
	{
		m_schemeCurrent.ReportChanges(m_schemeOriginal, hwndChanges);
	}

	BOOL m_bWin95;
	BYTE m_lfCharSet;

	WIZSCHEME m_schemePreview;
	WIZSCHEME m_schemeOriginal;

protected:
	// Dialogs never modify these copies of the scheme
	WIZSCHEME m_schemeCurrent;
	WIZSCHEME m_schemeWindowsDefault;

	NONCLIENTMETRICS m_ncmOrig;
	LOGFONT m_lfIconOrig;

	HFONT m_rgnStdMSSansSerifFonts[6 * 2]; // 0-5 are for 8, 10, 12, 14, 18, 24.  6-11 are for the same things, but underlined

	friend class CWelcome2Pg; // TODO: HACK - This is only here to give CWelcome2Pg access to m_schemeCurrent
};

// This variable will be accessible to any derived wizard page.
// It contains information specific to this application
extern CAccWizOptions g_Options;


VOID WINAPI AccWiz_RunDllA(HWND hwnd, HINSTANCE hInstance, LPSTR pszCmdLine, INT nCmdShow);
VOID WINAPI AccWiz_RunDllW(HWND hwnd, HINSTANCE hInstance, LPWSTR pszCmdLine, INT nCmdShow);

#endif // _INC_ACCWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\accwiz.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // PCH
#pragma hdrstop

#include "AccWiz.h"

#include "resource.h"

#include "pgfinish.h"
#include "pgGenric.h"

// Welcome page
#include "pgnWelCome.h"
#include "pgWelcom.h"
#include "pgWelco2.h"

// Options page
#include "pgWizOpt.h"

// Color pages
#include "pgLokPrv.h"

// Mouse pages
#include "pgMseCur.h"
#include "pgMseBut.h"
#include "pgcaret.h"

#include "pgTmeOut.h"
#include "pgSveDef.h"
#include "pgSveFil.h"

#include "pgExtras.h"



#include "LookPrev.h"
#include "Select.h"
#include "w95trace.h"

EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;

// Declaration of the global options variable
CAccWizOptions g_Options;
HINSTANCE g_hInstDll = NULL;    // DLL instance handle.

BOOL g_bHACKHACKSavedOptions = FALSE;
HANDLE              g_hAccwizRunning;

int WINAPI WinMain( 
				   HINSTANCE hInstance, // handle to current instance 
				   HINSTANCE hPrevInstance, // handle to previous instance 
				   LPSTR lpCmdLine, // pointer to command line 
				   int nCmdShow // show state of window 
				   )
{
	g_hInstDll = hInstance;
    
    SetLastError(0);
    // Allow only ONE instance of the program to run.
    // The mutex is automatically destroyed when Accwiz exits
    g_hAccwizRunning = CreateMutex(NULL, TRUE, TEXT("AK:AccwizRunning:KHALI"));
    if ( (g_hAccwizRunning == NULL) ||
        (GetLastError() == ERROR_ALREADY_EXISTS) )
    {
        return 0;
    }
	
	// Required for Link Window OLE marshalling :AK
    DBPRINTF(TEXT("Calling CoInitialize\r\n"));
	if (FAILED(CoInitialize(NULL)))
		return 0;	// Prefix #113783 (quit if CoInitialize fails)

    g_Options.InitAccWizOptions();
	InitCommonControls();

	// for the Link Window in finish page...
	LinkWindow_RegisterClass();

	VERIFY(CLookPrev::sm_Globals.Initialize()); // Make sure this has been initialized
	// VERIFY(CSelection::Initialize()); // Make sure this has been initialized: chnage this!

	// Get the commandline so that it works for MUI/Unicode
	LPTSTR lpCmdLineW = GetCommandLine();
  
	if ( *lpCmdLineW == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++lpCmdLineW && (*lpCmdLineW
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *lpCmdLineW == TEXT('\"') )
            lpCmdLineW++;
    }
    else {
        while (*lpCmdLineW > TEXT(' '))
            lpCmdLineW++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*lpCmdLineW && (*lpCmdLineW <= TEXT(' '))) {
        lpCmdLineW++;
    }

	if(NULL != lpCmdLineW && lstrlen(lpCmdLineW))
	{
		TCHAR szFileName[_MAX_PATH];
		lstrcpy(szFileName, lpCmdLineW);
		StrTrim(szFileName, TEXT("\"\0"));

		// Load the settings file back in.
		HANDLE hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if(hFile != INVALID_HANDLE_VALUE)
		{
            // declare structs for each scheme we might encounter

            WIZSCHEME_LEGACY_STRUCT(WIZSCHEME_WIN9X, schemeLegacyWin9x, COLOR_MAX_WIN9X) /* Win9x & Millen */
            WIZSCHEME_LEGACY_STRUCT(WIZSCHEME_NT400, schemeLegacyNT400, COLOR_MAX_NT400) /* WinNT 4.0 */
            WIZSCHEME_LEGACY_STRUCT(WIZSCHEME_NT500, schemeLegacyNT500, COLOR_MAX_NT500) /* Win2K */
            WIZSCHEME_LEGACY_STRUCT(WIZSCHEME_NT401, schemeLegacyNT501, COLOR_MAX_NT501) /* WinXP */

            // see if we can find the right scheme in order of ascending size

            #define OLD2NEW_SCHEME(scheme) \
            { \
			    DWORD dwRead; \
                ReadFile(hFile, (LPVOID)&scheme, sizeof(scheme), &dwRead, NULL); \
                if (dwRead != scheme.m_cbSize) \
                { \
		            StringTableMessageBox(NULL, IDS_WIZERRORLOADINGFILETEXT, IDS_WIZERRORLOADINGFILETITLE, MB_OK); \
		            return 0; \
                } \
                WIZSCHEME_COPY_LEGACY(g_Options.m_schemePreview, scheme) \
                /* legacy schemes wouldn't have theme or wallpaper set */ \
                g_Options.m_schemePreview.ClearTheme(); \
                g_Options.m_schemePreview.ClearWallpaper(); \
                /* figure out what the legacy scheme's SelectedStyle and SelectedSize is */ \
                g_Options.m_schemePreview.SetStyleNSize(); \
            }

			DWORD dwFileSize = GetFileSize(hFile, NULL);
            if (dwFileSize == schemeLegacyWin9x.m_cbSize)
            {
                OLD2NEW_SCHEME(schemeLegacyWin9x)
            }
            else if (dwFileSize == schemeLegacyNT400.m_cbSize)
            {
                OLD2NEW_SCHEME(schemeLegacyNT400)
            }
            else if (dwFileSize == schemeLegacyNT500.m_cbSize)
            {
                OLD2NEW_SCHEME(schemeLegacyNT500)
            }
            else if (dwFileSize == schemeLegacyNT501.m_cbSize)
            {
                OLD2NEW_SCHEME(schemeLegacyNT501)
            }
            else
            {
				StringTableMessageBox(NULL, IDS_WIZERRORLOADINGFILETEXT, IDS_WIZERRORLOADINGFILETITLE, MB_OK);
				return 0;
            }

			// IMPORTANT: For loaded schemes, we always want to change to the windows default font
			g_Options.m_schemePreview.m_PortableNonClientMetrics.m_nFontFaces = 1;

			g_bHACKHACKSavedOptions = TRUE;
			g_Options.ApplyPreview();
		}
		else
		{
			StringTableMessageBox(NULL, IDS_WIZERRORLOADINGFILETEXT, IDS_WIZERRORLOADINGFILETITLE, MB_OK);
			return 0;
		}

	}

#ifdef UNICODE	
	AccWiz_RunDllW(NULL, hInstance, lpCmdLineW, nCmdShow);
#else
	AccWiz_RunDllA(NULL, hInstance, lpCmdLineW, nCmdShow);
#endif

	return 0;
}


HRESULT
CreateAndRunWizard(
				   HWND hwndParent);

HRESULT
CreateAndRunWizard2(
				   HWND hwndParent);

HRESULT
OnProcessAttach(
				HINSTANCE hInstDll);

HRESULT
OnProcessDetach(
				VOID);

INT
PropSheetCallback(
				  HWND hwnd,
				  UINT uMsg,
				  LPARAM lParam);


VOID WINAPI AccWiz_RunDllA(HWND hwnd, HINSTANCE hInstance, LPSTR pszCmdLineA, INT nCmdShow)
{
	if (NULL != pszCmdLineA)
	{
		LPWSTR pszCmdLineW = NULL;
		INT cchCmdLine = MultiByteToWideChar(CP_ACP,
											 0,
											 pszCmdLineA,
											 -1,
											 NULL,
											 0);
		pszCmdLineW = new WCHAR[cchCmdLine];
		if (NULL != pszCmdLineW)
		{
			MultiByteToWideChar(CP_ACP,
								0,
								pszCmdLineA,
								-1,
								pszCmdLineW,
								cchCmdLine);

			AccWiz_RunDllW(hwnd, hInstance, pszCmdLineW, nCmdShow);

			delete[] pszCmdLineW;
		}
	}
}


VOID WINAPI AccWiz_RunDllW(HWND hwnd, HINSTANCE hInstance, LPWSTR pszCmdLineW, INT nCmdShow)
{
	HWND hwndParent   = GetDesktopWindow();

	HRESULT hResult;
	if(!g_bHACKHACKSavedOptions)
		hResult = CreateAndRunWizard(hwndParent);
	else
		hResult = CreateAndRunWizard2(hwndParent);


	if(!SUCCEEDED(hResult))
	{
		// TODO: Put out of memory message here
		_ASSERTE(FALSE);
#pragma message("Put Out of Memory message here")
	}
}



const INT MAX_PAGES  = 26;

HRESULT
CreateAndRunWizard(
				   HWND hwndParent)
{
	HRESULT hResult = E_OUTOFMEMORY;
	
	PROPSHEETPAGE psp[MAX_PAGES];
	WizardPage *rgpwp[MAX_PAGES];
	
	// Zero init the arrays
	memset(&psp, 0, sizeof(psp));
	memset(&rgpwp, 0, sizeof(rgpwp));
	
	// ///////////////////////
	// Create Pages Here - NOTE: Order does not matter - we'll control it with our own list
	//
	int nCountPages = 0;
	rgpwp[nCountPages++] = new CWizWelcomePg(psp + nCountPages);
	rgpwp[nCountPages++] = new CWelcomePg(psp + nCountPages);
	rgpwp[nCountPages++] = new CWelcome2Pg(psp + nCountPages);

	rgpwp[nCountPages++] = new CWizardOptionsPg(psp + nCountPages);
	
	rgpwp[nCountPages++] = new CScrollBarPg(psp + nCountPages);

	rgpwp[nCountPages++] = new CIconSizePg(psp + nCountPages);


	// Color	
	rgpwp[nCountPages++] = new CLookPreviewColorPg(psp + nCountPages);
	
	// Sound
	rgpwp[nCountPages++] = new CSoundSentryPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CShowSoundsPg(psp + nCountPages);
	
	// Keyboard
	rgpwp[nCountPages++] = new CStickyKeysPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CFilterKeysPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CFilterKeysSettingsPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CToggleKeysPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CShowKeyboardHelpPg(psp + nCountPages);
	
	// Mouse
	rgpwp[nCountPages++] = new CMouseKeysPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CMouseKeysSettingsPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CMouseTrailsPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CMouseCursorPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CMouseButtonPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CMouseSpeedPg(psp + nCountPages);
    rgpwp[nCountPages++] = new CCaretPg(psp + nCountPages);

	
	// Standard Wizard pages
	rgpwp[nCountPages++] = new CGenericWizPg(psp + nCountPages, IDD_WIZNOOPTIONSSELECTED, IDS_WIZNOOPTIONSSELECTEDTITLE, IDS_WIZNOOPTIONSSELECTEDSUBTITLE);
	rgpwp[nCountPages++] = new CAccessTimeOutPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CSaveForDefaultUserPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CSaveToFilePg(psp + nCountPages);
	rgpwp[nCountPages++] = new FinishWizPg(psp + nCountPages);
	
	// Make sure we have the correct number of pages in our wizard
	_ASSERTE(MAX_PAGES == nCountPages);
	
	// Make sure pages were created
	for (int i = 0; i < nCountPages; i++)
	{
		if (NULL == rgpwp[i])
			break;
	}
	
	if(i<nCountPages)
	{
		// We didn't have enough memory to create all the pages
		// Clean out allocated pages and return
		for(int i=0;i<nCountPages;i++)
			if(rgpwp[i])
				delete rgpwp[i];
			return E_OUTOFMEMORY;
	}


	
	// Create the orders for the pages to be run
	DWORD rgdwMainPath[] = {
                        IDD_WIZNEWWELCOME,
						IDD_WIZWELCOME,
						IDD_WIZWELCOME2,
						IDD_WIZOPTIONS,
						IDD_WIZFINISH // We need this placeholder here so we get a 'NEXT' button on IDD_WIZOPTIONS
							};

	if(!WizardPage::sm_WizPageOrder.AddPages(0xFFFFFFFF, rgdwMainPath, ARRAYSIZE(rgdwMainPath)))
		return E_OUTOFMEMORY;

	/////////////////////////////////////////////
	// See if we need the 16 or 256 color bitmap
	BOOL bUse256ColorBmp = FALSE;
	HDC hdc = GetDC(NULL);
	if(hdc)
	{
		if(GetDeviceCaps(hdc,BITSPIXEL) >= 8)
			bUse256ColorBmp = TRUE;
		ReleaseDC(NULL, hdc);
	}


	////////////////////////////////
	// Do the property sheet

	PROPSHEETHEADER psh;
	memset(&psh, 0, sizeof(psh));
	psh.dwSize		= sizeof(PROPSHEETHEADER);
	psh.dwFlags 	= PSH_USECALLBACK | PSH_WIZARD | PSH_PROPSHEETPAGE
		| PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER /*| *//*PSH_STRETCHWATERMARK*/;
	psh.hwndParent	= hwndParent;
	psh.hInstance	= g_hInstDll;
	psh.pszIcon 	= NULL;
	psh.pszCaption	= NULL;
	psh.nPages		= MAX_PAGES;
	psh.nStartPage	= 54331; // We will actually set it in PropSheetCallback to rgdwMainPath[0]
	// NOTE: Bug - This only works if nStartPage is non-zero
	psh.ppsp		= psp;
	psh.pfnCallback = PropSheetCallback;

#if 0
	psh.nStartPage	= 0; // We will actually set it in PropSheetCallback to rgdwMainPath[0]
	psh.pfnCallback = NULL;
	psh.dwFlags 	= PSH_WIZARD | PSH_PROPSHEETPAGE;
#endif
	
	psh.pszbmWatermark = MAKEINTRESOURCE(IDB_ACCWIZ);
    psh.pszbmHeader = MAKEINTRESOURCE(IDB_ACCMARK);

#if 0 // Right now, no watermarks
	psh.pszbmWatermark = bUse256ColorBmp?MAKEINTRESOURCE(IDB_WATERMARK256):MAKEINTRESOURCE(IDB_WATERMARK16);
	psh.pszbmHeader = bUse256ColorBmp?MAKEINTRESOURCE(IDB_BANNER256):MAKEINTRESOURCE(IDB_BANNER16);
#endif
   
	
    if (-1 != PropertySheet(&psh))
		hResult = NO_ERROR;
	else
		hResult = E_FAIL;

    // Clean up memory allocated for WizardPage's
	for(i=0;i<nCountPages;i++)
		if(rgpwp[i])
			delete rgpwp[i];
		
	
	return hResult;
}












HRESULT
CreateAndRunWizard2(
				   HWND hwndParent)
{
	HRESULT hResult = E_OUTOFMEMORY;
	
	PROPSHEETPAGE psp[1];
	WizardPage *rgpwp[1];
	
	// Zero init the arrays
	memset(&psp, 0, sizeof(psp));
	memset(&rgpwp, 0, sizeof(rgpwp));
	
	// ///////////////////////
	// Create Pages Here - NOTE: Order does not matter - we'll control it with our own list
	//
	int nCountPages = 0;
	rgpwp[nCountPages++] = new FinishWizPg(psp + nCountPages);
	
	// Make sure pages were created
	for (int i = 0; i < nCountPages; i++)
	{
		if (NULL == rgpwp[i])
			break;
	}
	
	if(i<nCountPages)
	{
		// We didn't have enough memory to create all the pages
		// Clean out allocated pages and return
		for(int i=0;i<nCountPages;i++)
			if(rgpwp[i])
				delete rgpwp[i];
			return E_OUTOFMEMORY;
	}


	
	// Create the orders for the pages to be run
	DWORD rgdwMainPath[] = {
						IDD_WIZFINISH // We need this placeholder here so we get a 'NEXT' button on IDD_WIZOPTIONS
							};

	if(!WizardPage::sm_WizPageOrder.AddPages(0xFFFFFFFF, rgdwMainPath, ARRAYSIZE(rgdwMainPath)))
		return E_OUTOFMEMORY;

	/////////////////////////////////////////////
	// See if we need the 16 or 256 color bitmap
	BOOL bUse256ColorBmp = FALSE;
	HDC hdc = GetDC(NULL);
	if(hdc)
	{
		if(GetDeviceCaps(hdc,BITSPIXEL) >= 8)
			bUse256ColorBmp = TRUE;
		ReleaseDC(NULL, hdc);
	}


	////////////////////////////////
	// Do the property sheet

	PROPSHEETHEADER psh;
	memset(&psh, 0, sizeof(psh));
	psh.dwSize		= sizeof(PROPSHEETHEADER);
	psh.dwFlags 	= PSH_USECALLBACK | PSH_WIZARD | PSH_PROPSHEETPAGE
		| PSH_WIZARD97 | PSH_WATERMARK |PSH_HEADER /*| *//*PSH_STRETCHWATERMARK*/;
	psh.hwndParent	= hwndParent;
	psh.hInstance	= g_hInstDll;
	psh.pszIcon 	= NULL;
	psh.pszCaption	= NULL;
	psh.nPages		= 1;
	psh.nStartPage	= 54331; // We will actually set it in PropSheetCallback to rgdwMainPath[0]
	// NOTE: Bug - This only works if nStartPage is non-zero
	psh.ppsp		= psp;
	psh.pfnCallback = PropSheetCallback;

#if 0
	psh.nStartPage	= 0; // We will actually set it in PropSheetCallback to rgdwMainPath[0]
	psh.pfnCallback = NULL;
	psh.dwFlags 	= PSH_WIZARD | PSH_PROPSHEETPAGE;
#endif
	
	psh.pszbmWatermark = MAKEINTRESOURCE(IDB_ACCWIZ);
    psh.pszbmHeader = MAKEINTRESOURCE(IDB_ACCMARK);

#if 0 // Right now, no watermarks
	psh.pszbmWatermark = bUse256ColorBmp?MAKEINTRESOURCE(IDB_WATERMARK256):MAKEINTRESOURCE(IDB_WATERMARK16);
	psh.pszbmHeader = bUse256ColorBmp?MAKEINTRESOURCE(IDB_BANNER256):MAKEINTRESOURCE(IDB_BANNER16);
#endif
	
	if (-1 != PropertySheet(&psh))
		hResult = NO_ERROR;
	else
		hResult = E_FAIL;
	
	// Clean up memory allocated for WizardPage's
	for(i=0;i<nCountPages;i++)
		if(rgpwp[i])
			delete rgpwp[i];
		
		
		
		
		
	return hResult;
}















INT
PropSheetCallback(
				  HWND hwnd,
				  UINT uMsg,
				  LPARAM lParam
				  )
{
	switch(uMsg)
	{
	case PSCB_PRECREATE:
		break;
		
	case PSCB_INITIALIZED:
        {
            // Set the first page according to are global list of page orders
            //			PropSheet_SetCurSelByID(hwnd, WizardPage::sm_WizPageOrder.GetFirstPage());
            // HACK - Set TO Options page since we added WIZWIZ page
            
            // HACK. Remove Context Sensitive help
            LONG Style = GetWindowLong(hwnd, GWL_EXSTYLE);
            
            if(0 == Style)
            {
                // DbgTrace((DEBUG_ERROR, "GetWindowLong failed. WizDlgs.cpp\n"));
                // DbgTraceSystemError(GetLastError());
            }
            if(0 == SetWindowLong(hwnd, GWL_EXSTYLE, Style & ~WS_EX_CONTEXTHELP))
            {
                // DbgTrace((DEBUG_ERROR, "SetWindowLong failed. WizDlgs.cpp\n"));
                // DbgTraceSystemError(GetLastError());
            }

#ifdef WIZWIZ
			_ASSERTE(IDD_WIZWIZ == WizardPage::sm_WizPageOrder.GetFirstPage()); // Change this if we remove the wiz wiz page
			PropSheet_SetCurSelByID(hwnd, IDD_WIZWELCOME);
#endif
		}
		break;
	}
	return 0;
}


// Helper functions
// Helper function
void LoadArrayFromStringTable(int nIdString, int *rgnValues, int *pnCountValues)
{
	// This function load the allowed value array from the string table
	// If the values are not stored in the string table, the function
	// can be overridden in a derived class
	// Load in allowed sizes for scroll bar from string table

	_ASSERTE(nIdString); // Make sure we were passed a string

	TCHAR szArray[255];
    LoadString(g_hInstDll, nIdString, szArray, ARRAYSIZE(szArray));

	// Assume at most MAX_DISTINCT_VALUES sizes
	LPTSTR szCurrentLocation = szArray;
	for(int i=0;i<MAX_DISTINCT_VALUES;i++)
	{
		if(!szCurrentLocation)
			break;
		int cFlds = _stscanf(szCurrentLocation, __TEXT("%i"), &rgnValues[i]);
		_ASSERTE(cFlds);
		if (!cFlds)
			break;	// Prefix #113775 (no more fields)

		// Find the next space
		// NOTE: If there are more than one spaces between characters, this will read the same entry twice
		szCurrentLocation = _tcschr(++szCurrentLocation, __TEXT(' '));
	}
	*pnCountValues = i;
	_ASSERTE(*pnCountValues);
}



// This function is prototyped in the pre-compiled header
int StringTableMessageBox(HWND hWnd, int nText, int nCaption, UINT uType)
{
	TCHAR szTitle[1024];
	TCHAR szText[1024];
	LoadString(g_hInstDll, nCaption, szTitle, ARRAYSIZE(szTitle));
	LoadString(g_hInstDll, nText, szText, ARRAYSIZE(szText));
	return MessageBox(hWnd, szText, szTitle, uType);
}

void CAccWizOptions::ApplyWindowsDefault()
{
    HKEY hkey;
    DWORD dwDisposition;
    DWORD len;
    
    m_schemeCurrent.ApplyChanges(m_schemeWindowsDefault);
    
    // BUG: Update the preview scheme. Else will put back the old 
    // color scheme if something changes
    m_schemePreview = m_schemeWindowsDefault;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\desk.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif

#ifdef SIZEOF
#undef SIZEOF
#endif

#define CCH_NONE          20        /* ARRAYSIZE( "(None)" ), big enough for German */
#define CCH_CLOSE         20        /* ARRAYSIZE( "Close" ), big enough for German */

#define CMSEC_COVER_WINDOW_TIMEOUT  (15 * 1000)     // 15 second timeout
#define ID_CVRWND_TIMER             0x96F251CC      // somewhat uniq id

// information about the monitor bitmap
// x, y, dx, dy define the size of the "screen" part of the bitmap
// the RGB is the color of the screen's desktop
// these numbers are VERY hard-coded to a monitor bitmap
#define MON_X   16
#define MON_Y   17
#define MON_DX  152
#define MON_DY  112
#define MON_RGB RGB(0, 128, 128)
#define MON_TRAY 8


#define         MIN_MINUTES     1
#define         MAX_MINUTES     60
#define         BUFFER_SIZE     400

#define         MAX_METHODS     100

VOID RefreshColors (void);

BOOL DeskInitCpl(void);
void DeskShowPropSheet( HINSTANCE hInst, HWND hwndParent, LPCTSTR szCmdLine );

BOOL APIENTRY BackgroundDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL APIENTRY ScreenSaverDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL APIENTRY AppearanceDlgProc( HWND hDlg, UINT message, UINT   wParam, LONG   lParam);
BOOL CALLBACK DisplayPageProc(   HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

BOOL FAR GetMonitorSettingsPage(LPPROPSHEETPAGE psp, int iDevice);

BOOL APIENTRY DeskDefPropPageProc( HWND hDlg, UINT message, UINT wParam, LONG lParam);
LONG WINAPI MyStrToLong(LPCTSTR sz);

// background previewer includes

#define DIBERR_SUCCESS  1       // successful open
#define DIBERR_NOOPEN   -1      // file could not be opened
#define DIBERR_INVALID  -2      // file is not a valid bitmap

#define BP_NEWPAT       0x01    // pattern changed
#define BP_NEWWALL      0x02    // wallpaper changed
#define BP_TILE         0x04    // tile the wallpaper (center otherwise)
#define BP_REINIT       0x08    // reload the image (system colors changed)

#define WM_SETBACKINFO (WM_USER + 1)

#define BACKPREV_CLASS TEXT("BackgroundPreview")
#define LOOKPREV_CLASS TEXT("LookPreview")

BOOL FAR PASCAL RegisterBackPreviewClass(HINSTANCE hInst);
BOOL FAR PASCAL RegisterLookPreviewClass(HINSTANCE hInst);

HBITMAP FAR LoadMonitorBitmap( BOOL bFillDesktop );

#ifdef UNICODE
    UINT WinExecN( LPCTSTR lpCmdLine, UINT uCmdShow );
#else
    // If we're on Win95, then just use the ANSI-only WinExec instead of
    // rolling our own
#   define WinExecN    WinExec
#endif

#define SETTINGSPAGE_DEFAULT    -1
#define SETTINGSPAGE_FALLBACK   0

#define Assert(p)   /* nothing */

#define ARRAYSIZE( a )  (sizeof(a) / sizeof(a[0]))
#define SIZEOF( a )     sizeof(a)


//
// CreateCoverWindow
//
// creates a window which obscures the display
//  flags:
//      0 means erase to black
//      COVER_NOPAINT means "freeze" the display
//
// just post it a WM_CLOSE when you're done with it
//
#define COVER_NOPAINT (0x1)
//
HWND FAR PASCAL CreateCoverWindow( DWORD flags );
//

//
// Macro to replace MAKEPOINT() since points now have 32 bit x & y
//
#define LPARAM2POINT( lp, ppt ) \
    ((ppt)->x = LOWORD(lp), (ppt)->y = HIWORD(lp))

//
// Globals
//

extern TCHAR g_szNULL[];
extern TCHAR g_szNone[CCH_NONE];
extern TCHAR g_szClose[CCH_CLOSE];
extern TCHAR g_szControlIni[];
extern TCHAR g_szPatterns[];

extern TCHAR g_szCurPattern[];   // name of currently selected pattern
extern TCHAR g_szCurWallpaper[]; // name of currently selected wallpaper
extern BOOL g_bValidBitmap;     // whether or not wallpaper is valid

extern TCHAR g_szBoot[];
extern TCHAR g_szSystemIni[];
extern TCHAR g_szWindows[];

extern HDC g_hdcMem;

#if 0
#   pragma message(__FILE__"(134): warning : remove debug code before checkin")
#   define DBG_PRINT
#   define DPRINT(s)   OutputDebugString(TEXT(s) TEXT("\n"))
#   define DPRINTF(p)   if(1){TCHAR szdbuf[256]; wsprintf p; OutputDebugString(szdbuf);}else

#   ifdef DM_TRACE
#       undef DM_TRACE
#   endif
#   define DM_TRACE     szdbuf
#else
// Remove all the DPRINTS once we have debugged USER
#   define DPRINT(s)
#   define DPRINTF(p)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\deskid.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#define IDC_STATIC                      -1

#define DLG_SCREENSAVER  150
#define DLG_BACKGROUND   151
#define DLG_APPEARANCE   152
#define DLG_MONITOR      153
#define DLG_ADAPTER      154
#define DLG_CUSTOMFONT   155
#define DLG_COLORPICK    156
#define DLG_PATTERN      157
#define DLG_MULTIMONITOR 159

#define DLG_FLICKER	160
#define DLG_KEEPNEW	161
#define DLG_SAVESCHEME	162

#define IDS_ICON    40
#define IDS_NAME    41
#define IDS_INFO    42
#define IDS_DESK_NOMEM  43

#define IDB_VIDMETR	120
#define IDB_COLOR1	121
#define IDB_COLOR4	122
#define IDB_COLOR8	123
#define IDB_ENERGYSTAR	124

#define IDC_NO_HELP_1	200	// Used in place of IDC_STATIC when context Help
#define IDC_NO_HELP_2	201	// should be disabled for a control
#define IDC_NO_HELP_3	202	

// screen saver controls
#define IDC_CHOICES		1000
#define IDC_METHOD              1001
#define IDC_BIGICON             1002
#define IDC_SETTING             1003
#define IDC_TEST                1004
#define IDC_ENERGYSTAR_BMP	1005
#define IDC_SCREENSAVEDELAY     1006
#define IDC_SCREENSAVEARROW     1007

#define IDC_LOWPOWERCONFIG      1008

//                              1014        unused
#define IDC_DEMO                1015
#define IDC_SSDELAYLABEL        1016
#define IDC_ENERGY_TEXT         1017
#define IDC_ENERGY_TEXT2        1018
#define IDC_ENERGY_TEXT3        1019
#define IDC_USEPASSWORD	        1020
#define IDC_SETPASSWORD         1021
#define IDC_SSDELAYSCALE        1022

#define IDS_POWERCFG_CMDLINE    1030

// background controls
#define IDC_PATLIST	1100
#define IDC_WALLLIST	1101
#define IDC_EDITPAT	1102
#define IDC_BROWSEWALL	1103
#define IDC_CENTER	1104
#define IDC_TILE	1105
#define IDC_PATTERN	1106
#define IDC_WALLPAPER	1107
#define IDC_BACKPREV	1108
#define IDC_TXT_DISPLAY 1109

// background dialog strings
#define IDS_NONE	1100
#define IDS_UNLISTEDPAT	1101
#define IDS_BITMAPOPENERR	1102
#define IDS_DIB_NOOPEN		1103
#define IDS_DIB_INVALID		1104
#define IDS_DIB_NOMEM		1105
#define IDS_BADWALLPAPER	1106
#define IDS_BROWSETITLE         1107
#define IDS_BROWSEFILTER        1108

// appearance controls
#define IDC_SCHEMES	1400
#define IDC_SAVESCHEME	1401
#define IDC_DELSCHEME	1402
#define IDC_ELEMENTS	1403
#define IDC_MAINSIZE	1404
#define IDC_FONTNAME	1407
#define IDC_FONTSIZE	1408
#define IDC_FONTBOLD	1409
#define IDC_FONTITAL	1410
#define IDC_SIZEARROWS	1411
#define IDC_MAINCOLOR	1412
#define IDC_TEXTCOLOR	1413
#define IDC_GRADCOLOR   1414

#define IDC_SIZELABEL		1450
#define IDC_COLORLABEL		1451
#define IDC_FONTLABEL		1452
#define IDC_FNCOLORLABEL	1453
#define IDC_FONTSIZELABEL	1454

#define IDC_LOOKPREV	1470

// these need to be all clumped together because they are treated as a group
#define IDC_STARTMAINCOLOR	1500
#define IDC_CUSTOMMAINCOLOR	1549
#define IDC_ENDMAINCOLOR	IDC_CUSTOMMAINCOLOR
#define IDC_STARTTEXTCOLOR	1550
#define IDC_CUSTOMTEXTCOLOR	1599
#define IDC_ENDTEXTCOLOR	IDC_CUSTOMTEXTCOLOR

// appearance elements
#define ELNAME_DESKTOP		1401
#define ELNAME_INACTIVECAPTION	1402
#define ELNAME_INACTIVEBORDER	1403
#define ELNAME_ACTIVECAPTION	1404
#define ELNAME_ACTIVEBORDER	1405
#define ELNAME_MENU		1406
#define ELNAME_MENUSELECTED	1407
#define ELNAME_WINDOW		1408
#define ELNAME_SCROLLBAR	1409
#define ELNAME_BUTTON		1410
#define ELNAME_SMALLCAPTION	1411
#define ELNAME_ICONTITLE	1412
#define ELNAME_CAPTIONBUTTON	1413
#define ELNAME_DISABLEDMENU	1414
#define ELNAME_MSGBOX		1415
#define ELNAME_SCROLLBUTTON	1416
#define ELNAME_APPSPACE		1417
#define ELNAME_SMCAPSYSBUT	1418
#define ELNAME_SMALLWINDOW	1419
#define ELNAME_DXICON           1420
#define ELNAME_DYICON           1421
#define ELNAME_INFO             1422
#define ELNAME_ICON             1423
#define ELNAME_SMICON           1424

// appearance strings for sample
#define IDS_ACTIVE	1450
#define IDS_INACTIVE	1451
#define IDS_MINIMIZED	1452
#define IDS_ICONTITLE	1453
#define IDS_NORMAL	1454
#define IDS_DISABLED	1455
#define IDS_SELECTED	1456
#define IDS_MSGBOX	1457
#define IDS_BUTTONTEXT	1458
#define IDS_SMCAPTION	1459
#define IDS_WINDOWTEXT	1460
#define IDS_MSGBOXTEXT	1461

#define IDS_FONTBOLD    1463
#define IDS_FONTITAL    1464

#define IDS_BLANKNAME		1480
#define IDS_NOSCHEME2DEL	1481

// appearance preview menu
#define IDR_MENU	1
#define IDM_NORMAL	10
#define IDM_DISABLED	11
#define IDM_SELECTED	12

// monitor settings controls
#define IDC_COLORLIST	1200
#define IDC_RESLIST	1201
#define IDC_RESSIZE	1204
#define IDC_SCREENSAMPLE 1205
#define IDC_COLORSAMPLE 1206
#define IDC_RESXY	1207
#define IDC_ZOOMIN	1209
#define IDC_ZOOMOUT	1210
#define IDC_CUSTOMFONT  1211
#define IDC_FONTLIST    1212
#define IDC_CHANGEDRV   1213
#define IDC_FULLDRAG    1214
#define IDC_SMOOTHFONTS 1215
#define IDC_FONTGROUPBOX 1216

#define BMP_MONITOR	1250

// adapter settings controls
#define IDC_ADAPTERNAME		1301
#define IDC_ADAPTERCHANGE	1302
#define IDC_MONITORNAME		1303
#define IDC_MONITORCHANGE	1304
#define IDC_DRVMAN		1305
#define IDC_DRVVER		1306
#define IDC_DRVFILES		1307
#define IDC_DPMS		1308
#define IDC_DRVMAN_TXT		1309
#define IDC_DRVVER_TXT		1310
#define IDC_DRVFILES_TXT	1311

#define IDS_CLOSE		1300

// strings for monitor settings
// the ordering matches a color resolution array
// NOTE: numbering = base + (res/4)
#define IDS_COLOR	1200
#define IDS_COLOR_1	IDS_COLOR + 0
#define IDS_COLOR_4	IDS_COLOR + 1
#define IDS_COLOR_8	IDS_COLOR + 2
#define IDS_COLOR_16	IDS_COLOR + 4
#define IDS_COLOR_24	IDS_COLOR + 6
#define IDS_COLOR_32	IDS_COLOR + 8

#define IDS_CANCELNEW	1220
#define IDS_FAILRESET	1221
#define IDS_X_BY_Y	1224
#define IDS_UNKNOWN	1225
#define IDS_NOINFO	1226
#define IDS_CUSTFONTPER 1229
#define IDS_CUSTFONTWARN 1230
#define IDS_PAT_REMOVE  1231
#define IDS_PAT_CHANGE  1232
#define IDS_PAT_CREATE  1233
#define IDS_REMOVEPATCAPTION	1234
#define IDS_CHANGEPATCAPTION	1235

#define IDS_WARNFLICK1  1250
#define IDS_WARNFLICK2  1251
// order is based on values in ddk\inc16\valmode.inc
#define	IDS_NOVALID0	1254
#define	IDS_NOVALID1	1255
#define	IDS_NOVALID2	1256
#define	IDS_NOVALID3	1257
#define	IDS_NOVALID4	1258
#define	IDS_NOMONITOR	1260
#define IDS_FALLBACKMODE 1261
#define IDS_FALLBACKDRV 1262

#define IDS_NOADAPTER           1270
#define IDS_CONFLICT            1271
#define IDS_BADSETTINGS         1272
#define IDS_DISPDISABLED        1273

//controls & strings for custom font dialog
#define IDC_CUSTOMSAMPLE	1400
#define IDC_CUSTOMRULER		1501
#define IDC_CUSTOMCOMBO		1502

#define IDS_10PTSAMPLE		1500
#define IDS_RULERDIRECTION      1501
#define IDS_10PTSAMPLEFACENAME  1510

#define IDS_NEWSETTINGS         1600
#define IDS_NEWSETTINGS_RESTART 1601

#define IDS_CATRESCOLOR         1610

// color picker mini-dialog
#define IDC_16COLORS	1615
#define IDC_COLORCUST	1616
#define IDC_COLOROTHER	1617
#define IDC_COLORETCH	1618

// patern edit dialog

#define IDD_PATTERN		1700
#define IDD_PATTERNCOMBO	1701
#define IDD_ADDPATTERN		1702
#define IDD_CHANGEPATTERN       1703
#define IDD_DELPATTERN		1704
#define IDD_PATSAMPLE           1705
#define IDD_PATSAMPLE_TXT       1706
#define IDD_PATTERN_TXT		1707

// Multimonitor controls

#define IDC_DISPLAYLIST         1800
#define IDC_DISPLAYDESK         1801
#define IDC_DISPLAYPROPERTIES   1802
#define IDC_DISPLAYNAME         1803
#define IDC_DISPLAYMODE         1804
#define IDC_DISPLAYUSEME        1805
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\dlgfonts.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "DlgFonts.h"
#include "accwiz.h" // for g_Options


HFONT BigBoldFont = NULL;
HFONT BoldFont = NULL;
HFONT BigFont = NULL;


// Helper function
void SetControlFont(HFONT hFont, HWND hwnd, int nId)
{
	if(!hFont)
		return;
	HWND hwndControl = GetDlgItem(hwnd, nId);
	if(!hwndControl)
		return;
	SetWindowFont(hwndControl, hFont, TRUE);
}


void SetupFonts(HWND hwnd)
{
	// Only execute this code once
	static BOOL bOneTime = TRUE;
	if(bOneTime)
		bOneTime = FALSE;
	else
		return;

	// Create the fonts we need based on the dialog font
	NONCLIENTMETRICS ncm;
	memset(&ncm, 0, sizeof(ncm));
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

	LOGFONT BigBoldLogFont = ncm.lfMessageFont;
	LOGFONT BoldLogFont = ncm.lfMessageFont;
	LOGFONT BigLogFont = ncm.lfMessageFont;

	// Create Big Bold Font and Bold Font
    BigBoldLogFont.lfWeight = FW_BOLD;
	BoldLogFont.lfWeight = FW_BOLD;
    BigLogFont.lfWeight = FW_NORMAL;

    TCHAR FontSizeString[24];
    int FontSizeBigBold;
    int FontSizeBold;
    int FontSizeBig;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
	BigBoldLogFont.lfCharSet = g_Options.m_lfCharSet;
	BoldLogFont.lfCharSet = g_Options.m_lfCharSet;
	BigLogFont.lfCharSet = g_Options.m_lfCharSet;

    if(!LoadString(g_hInstDll,IDS_BIGBOLDFONTNAME,BigBoldLogFont.lfFaceName,LF_FACESIZE)) {
        lstrcpy(BigBoldLogFont.lfFaceName,TEXT("MS Serif"));
    }

    if(!LoadString(g_hInstDll,IDS_BOLDFONTNAME,BoldLogFont.lfFaceName,LF_FACESIZE)) {
        lstrcpy(BoldLogFont.lfFaceName,TEXT("MS Serif"));
    }

    if(!LoadString(g_hInstDll,IDS_BIGFONTNAME,BigLogFont.lfFaceName,LF_FACESIZE)) {
        lstrcpy(BigLogFont.lfFaceName,TEXT("MS Serif"));
    }

    if(LoadString(g_hInstDll,IDS_BIGBOLDFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR))) {
		FontSizeBigBold = _tcstoul(FontSizeString,NULL,10);
    } else {
        FontSizeBigBold = 16;
    }

    if(LoadString(g_hInstDll,IDS_BOLDFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR))) {
        FontSizeBold = _tcstoul(FontSizeString,NULL,10);
    } else {
        FontSizeBold = 8;
    }

    if(LoadString(g_hInstDll,IDS_BIGFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR))) {
        FontSizeBig = _tcstoul(FontSizeString,NULL,10);
    } else {
        FontSizeBig = 16;
    }

	HDC hdc;
    if(hdc = GetDC(hwnd)) {

        BigBoldLogFont.lfHeight = 0 - (int)((float)GetDeviceCaps(hdc,LOGPIXELSY) * (float)FontSizeBigBold / (float)72 + (float).5);
        BoldLogFont.lfHeight = 0 - (int)((float)GetDeviceCaps(hdc,LOGPIXELSY) * (float)FontSizeBold / (float)72 + (float).5);
        BigLogFont.lfHeight = 0 - (int)((float)GetDeviceCaps(hdc,LOGPIXELSY) * (float)FontSizeBig / (float)72 + (float).5);

        BigBoldFont = CreateFontIndirect(&BigBoldLogFont);
		BoldFont = CreateFontIndirect(&BoldLogFont);
        BigFont = CreateFontIndirect(&BigLogFont);

        ReleaseDC(hwnd,hdc);
    }

}

void DialogFonts_InitWizardPage(
	IN HWND hwndWizardPage
	)
{
	SetupFonts(hwndWizardPage);

	// If we are going to change the fonts of all wizard pages,
	// we can't allow the user to go back and change the size
	// they picked.  This is because this function is only called
	// once for each page.
/*
	if(-1 != g_Options.m_nMinimalFontSize)
	{
*/
	HWND hwndChild = GetTopWindow(hwndWizardPage);
	do
	{
		int nId = GetDlgCtrlID(hwndChild);
		switch(nId)
		{
		case IDC_BOLDTITLE:
			SetControlFont(BoldFont, hwndWizardPage, IDC_BOLDTITLE);
			break;
		case IDC_BIGBOLDTITLE:
			SetControlFont(BigBoldFont, hwndWizardPage, IDC_BIGBOLDTITLE);
			break;
		case IDC_BIGTITLE:
			SetControlFont(BigFont, hwndWizardPage, IDC_BIGTITLE);
			break;
#if 0 // This used to be for the icon size page
		case IDC_STATICNORMAL:
			SetWindowFont(hwndChild, g_Options.GetClosestMSSansSerif(8), TRUE);
			break;
		case IDC_STATICLARGE:
			SetWindowFont(hwndChild, g_Options.GetClosestMSSansSerif(12), TRUE);
			break;
		case IDC_STATICEXTRALARGE:
			SetWindowFont(hwndChild, g_Options.GetClosestMSSansSerif(18), TRUE);
			break;
#endif
		default:
#if 0 // We decided that we weren't going to resize the fonts in the dialog
			// DON'T go above 12 points for the dialog fonts
			SetWindowFont(hwndChild, g_Options.GetClosestMSSansSerif(min(12, g_Options.m_nMinimalFontSize)), TRUE);
#endif
			break;
		}
	}
	while(hwndChild = GetNextWindow(hwndChild, GW_HWNDNEXT));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\curschme.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "CurSchme.h"

DWORD g_dwSchemeSource;

static LPCTSTR g_rgszCursorNames[] = 
{
	__TEXT("Arrow"),    
	__TEXT("Help"),       
	__TEXT("AppStarting"),
	__TEXT("Wait"),       
	__TEXT("Crosshair"),  
	__TEXT("IBeam"),      
	__TEXT("NWPen"),      
	__TEXT("No"),         
	__TEXT("SizeNS"),     
	__TEXT("SizeWE"),     
	__TEXT("SizeNWSE"),   
	__TEXT("SizeNESW"),   
	__TEXT("SizeAll"),    
	__TEXT("UpArrow"),    
	__TEXT("Hand"),       
	NULL // This is the default value
};


#define CCURSORS   (sizeof(g_rgszCursorNames) / sizeof(g_rgszCursorNames[0]))

TCHAR g_szOrigCursors[CCURSORS][_MAX_PATH];
DWORD g_dwOrigSchemeSource = 0;

const TCHAR g_szCursorRegPath[] = REGSTR_PATH_CURSORS;
const TCHAR szSchemeSource[] = TEXT("Scheme Source");


TCHAR g_szSchemeNames[8][100]; // HACK - We have to make sure the scheme names are less than 100 characters



typedef
LANGID
(WINAPI *pfnGetUserDefaultUILanguage)(
    void
    );
typedef
LANGID
(WINAPI *pfnGetSystemDefaultUILanguage)(
    void
    );


BOOL IsMUI_Enabled()
{

    OSVERSIONINFO verinfo;
    LANGID        rcLang;
    HMODULE       hModule;
    pfnGetUserDefaultUILanguage gpfnGetUserDefaultUILanguage;     
    pfnGetSystemDefaultUILanguage gpfnGetSystemDefaultUILanguage; 
    static        g_bPFNLoaded=FALSE;
    static        g_bMUIStatus=FALSE;


    if(g_bPFNLoaded)
       return g_bMUIStatus;

    g_bPFNLoaded = TRUE;

    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);    
    GetVersionEx( &verinfo) ;

    if (verinfo.dwMajorVersion == 5)        
    {   

       hModule = GetModuleHandle(TEXT("kernel32.dll"));
       if (hModule)
       {
          gpfnGetSystemDefaultUILanguage =
          (pfnGetSystemDefaultUILanguage)GetProcAddress(hModule,"GetSystemDefaultUILanguage");
          if (gpfnGetSystemDefaultUILanguage)
          {
             rcLang = (LANGID) gpfnGetSystemDefaultUILanguage();
             if (rcLang == 0x409 )
             {  
                gpfnGetUserDefaultUILanguage =
                (pfnGetUserDefaultUILanguage)GetProcAddress(hModule,"GetUserDefaultUILanguage");
                
                if (gpfnGetUserDefaultUILanguage)
                {
                   if (rcLang != (LANGID)gpfnGetUserDefaultUILanguage() )
                   {
                       g_bMUIStatus = TRUE;
                   }

                }
             }
          }
       }
    }
    return g_bMUIStatus;
}

void LoadCursorSchemeNames()
{  
	static BOOL g_bSchemeNamesLoaded = FALSE;
   
	if(g_bSchemeNamesLoaded)
		return;
	g_bSchemeNamesLoaded = TRUE;
   if (!IsMUI_Enabled())
   {
	   LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_STANDARD_LARGE     , g_szSchemeNames[0], 100);
   	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_STANDARD_EXTRALARGE, g_szSchemeNames[1], 100);
   	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_BLACK              , g_szSchemeNames[2], 100);
   	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_BLACK_LARGE        , g_szSchemeNames[3], 100);
   	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_BLACK_EXTRALARGE   , g_szSchemeNames[4], 100);
   	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_INVERTED           , g_szSchemeNames[5], 100);
   	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_INVERTED_LARGE     , g_szSchemeNames[6], 100);
   	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_INVERTED_EXTRALARGE, g_szSchemeNames[7], 100);
   }
   else
   {     
      lstrcpy(g_szSchemeNames[0],IDSENG_CURSOR_SCHEME_WINDOWS_STANDARD_LARGE);    
      lstrcpy(g_szSchemeNames[1],IDSENG_CURSOR_SCHEME_WINDOWS_STANDARD_EXTRALARGE);
      lstrcpy(g_szSchemeNames[2],IDSENG_CURSOR_SCHEME_WINDOWS_BLACK);
      lstrcpy(g_szSchemeNames[3],IDSENG_CURSOR_SCHEME_WINDOWS_BLACK_LARGE);
      lstrcpy(g_szSchemeNames[4],IDSENG_CURSOR_SCHEME_WINDOWS_BLACK_EXTRALARGE);
      lstrcpy(g_szSchemeNames[5],IDSENG_CURSOR_SCHEME_WINDOWS_INVERTED);
      lstrcpy(g_szSchemeNames[6],IDSENG_CURSOR_SCHEME_WINDOWS_INVERTED_LARGE);
      lstrcpy(g_szSchemeNames[7],IDSENG_CURSOR_SCHEME_WINDOWS_INVERTED_EXTRALARGE);
   }
   
	// Load the current cursor settings
	HKEY hkCursors;
	if (ERROR_SUCCESS == RegOpenKey( HKEY_CURRENT_USER, g_szCursorRegPath, &hkCursors ))
	{
		for(int i=0;i<CCURSORS;i++)
		{
			g_szOrigCursors[i][0] = 0;
			DWORD dwCount = _MAX_PATH * sizeof(TCHAR);
			DWORD dwType;
			RegQueryValueEx( hkCursors,
					         g_rgszCursorNames[i],
					         NULL,
					         &dwType,
					         (LPBYTE)g_szOrigCursors[i],
					         &dwCount );
      
		}
		// Get the scheme source value
		DWORD dwLen = sizeof(g_dwOrigSchemeSource);
		if (RegQueryValueEx( hkCursors, szSchemeSource, NULL, NULL, (unsigned char *)&g_dwOrigSchemeSource, &dwLen ) != ERROR_SUCCESS)
			g_dwOrigSchemeSource = 1;
		RegCloseKey(hkCursors);
	}
	else
		_ASSERTE(FALSE);

}

static const TCHAR c_szRegPathCursorSchemes[] = REGSTR_PATH_CURSORS TEXT( "\\Schemes" );
static const TCHAR c_szRegPathSystemSchemes[] = REGSTR_PATH_SETUP TEXT("\\Control Panel\\Cursors\\Schemes");



// ApplyScheme(int nScheme)
// '0' Scheme loaded in g_szOrigScheme
// '1' Windows Default
// '2' Standard Large
// '3' Standard Ex Large
// '4' Black
// '5' Black Large
// '6' Black Ex Large
// '7' Inverted
// '8' Inverted Large
// '9' Inverted Ex Large
void ApplyCursorScheme(int nScheme)
{
	LoadCursorSchemeNames();
	HKEY hkCursors;
    DWORD dwPosition;

    // Initially for default cursor, The registry "\\ControlPanel\Cursors" is not created 
    // so. Create the registry values: a-anilk
	if(ERROR_SUCCESS != RegCreateKeyEx( HKEY_CURRENT_USER, g_szCursorRegPath, 0L, TEXT(""), 
        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkCursors, &dwPosition ))
		return;

	int i;

	DWORD dwSchemeSource;

	switch(nScheme)
	{
	case 0: // Original scheme
		dwSchemeSource = g_dwOrigSchemeSource;
		for(i=0;i<CCURSORS;i++)
			RegSetValueEx( hkCursors, g_rgszCursorNames[i], 0L, REG_SZ, (CONST LPBYTE)g_szOrigCursors[i], (lstrlen(g_szOrigCursors[i])+1)*sizeof(TCHAR));
		break;
	case 1: // Windows default
		dwSchemeSource = 0;
		for(i=0;i<CCURSORS;i++)
			RegSetValueEx( hkCursors, g_rgszCursorNames[i], 0L, REG_SZ, (CONST LPBYTE)"", sizeof(TCHAR));
		break;
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
		{
			dwSchemeSource = 2; // Assume System schemes
			HKEY hkScheme;
			// Try to find the 'system' schemes first
			if(ERROR_SUCCESS != RegOpenKey( HKEY_LOCAL_MACHINE, c_szRegPathSystemSchemes, &hkScheme ))
			{
				// Couldn't find system schemes, try looking in user schemes
				dwSchemeSource = 1; // User schemes
				if(ERROR_SUCCESS != RegOpenKey( HKEY_CURRENT_USER, c_szRegPathCursorSchemes, &hkScheme ))
					return;
			}

			DWORD dwCount = 0;
			DWORD dwType;
			long nResult;
			if(ERROR_SUCCESS != (nResult = RegQueryValueEx( hkScheme, g_szSchemeNames[nScheme - 2], NULL, &dwType, NULL, &dwCount )))
				dwCount = 1; // The value probably was not there.  Fake it and allocate 1 byte.

			LPTSTR lpszData = (LPTSTR)new BYTE[dwCount]; // NOTE: For Unicode, RegQueryValueEx still returns the 'Byte' size not 'Char count'
			lpszData[0] = 0;

			if(ERROR_SUCCESS == nResult)
				RegQueryValueEx( hkScheme, g_szSchemeNames[nScheme - 2], NULL, &dwType, (LPBYTE)lpszData, &dwCount );


			LPTSTR lpszCurrentValue = lpszData;
			LPTSTR lpszFinalNULL = lpszData + lstrlen(lpszData);
			// Parse the information
			for(i=0;i<CCURSORS;i++)
			{
				// Hack to set the default value
				if(CCURSORS - 1 == i)
				{
					lpszCurrentValue = g_szSchemeNames[nScheme - 2];
					RegSetValueEx( hkCursors, NULL, 0L, REG_SZ, (CONST LPBYTE)lpszCurrentValue, (lstrlen(lpszCurrentValue)+1)*sizeof(TCHAR));
				}
				else
				{
					// Find next comma
					LPTSTR lpszComma = _tcschr(lpszCurrentValue, __TEXT(','));
					// Turn it into a zero
					if(lpszComma)
						*lpszComma = 0;
					RegSetValueEx( hkCursors, g_rgszCursorNames[i], 0L, REG_SZ, (CONST LPBYTE)lpszCurrentValue, (lstrlen(lpszCurrentValue)+1)*sizeof(TCHAR));
					lpszCurrentValue = min(lpszFinalNULL, lpszCurrentValue + lstrlen(lpszCurrentValue) + 1);
				}

			}
			delete [] lpszData;
			RegCloseKey(hkScheme);
		}
		break;
	default:
		_ASSERTE(FALSE);

	}

	// Save the 'Scheme Source'
	RegSetValueEx(hkCursors, szSchemeSource, 0, REG_DWORD, (unsigned char *)&dwSchemeSource, sizeof(dwSchemeSource));
	
	RegCloseKey(hkCursors);
	SystemParametersInfo( SPI_SETCURSORS, 0, 0, SPIF_SENDCHANGE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\dlgfonts.h ===
//Copyright (c) 1997-2000 Microsoft Corporation



////////////////////////////////////
//
// Stuff used for different fonts in dialogs
//

void DialogFonts_InitWizardPage(
	IN HWND hwndWizardPage
	);

//
////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\lookprev.h ===
//Copyright (c) 1997-2000 Microsoft Corporation

#define CCH_MAX_STRING    256

class CLookPreviewGlobals
{
public:
	CLookPreviewGlobals()
	{
		// We don't initialize stuff here because we rely
		// on some other global variables that are not yet initialized
		m_bInitialized = FALSE;
	}
	BOOL Initialize();

	TCHAR m_szActive[CCH_MAX_STRING];
	TCHAR m_szInactive[CCH_MAX_STRING];
	TCHAR m_szMinimized[CCH_MAX_STRING];
	TCHAR m_szIconTitle[CCH_MAX_STRING];
	TCHAR m_szNormal[CCH_MAX_STRING];
	TCHAR m_szDisabled[CCH_MAX_STRING];
	TCHAR m_szSelected[CCH_MAX_STRING];
	TCHAR m_szMsgBox[CCH_MAX_STRING];
	TCHAR m_szButton[CCH_MAX_STRING];
//	TCHAR m_szSmallCaption[40];
	TCHAR m_szWindowText[CCH_MAX_STRING];
	TCHAR m_szMsgBoxText[CCH_MAX_STRING];

protected:
	static BOOL sm_bOneInstanceCreated; // This variable insures that only one instance of CLookPreviewGlobals is created
	BOOL m_bInitialized;
};

class CLookPrev
{
public:
	CLookPrev()
	{
		m_hwnd = NULL;
		m_hmenuSample = NULL;
		m_hbmLook = NULL;       // bitmap for the appearance preview
	}
	
	HWND m_hwnd;

	// Static window proc
	static LRESULT CALLBACK LookPreviewWndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	static CLookPreviewGlobals sm_Globals;

protected:
	HMENU m_hmenuSample;
	HBITMAP m_hbmLook;       // bitmap for the appearance preview

	void ShowBitmap(HDC hdc);
	void Draw(HDC hdc);

protected: // Message handlers
	void OnCreate();
	void OnDestroy();
	void OnRepaint();
	void OnRecalc();
	void OnPaint(HDC hdc);
};


// Messages for the Look Preview window
#define LPM_REPAINT		WM_USER + 1
#define LPM_RECALC		WM_USER + 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\look.h ===
//Copyright (c) 1997-2000 Microsoft Corporation

#define FONT_NONE	-1
#define FONT_CAPTION	0
#define FONT_SMCAPTION	1
#define FONT_MENU	2
#define FONT_ICONTITLE	3
#define FONT_STATUS	4
#define FONT_MSGBOX	5

#define NUM_FONTS	6
typedef struct {
    HFONT hfont;
    LOGFONT lf;
} LOOK_FONT;
extern LOOK_FONT g_fonts[];

#define COLOR_NONE	-1
extern HBRUSH g_brushes[];
extern HPALETTE g_hpal3D;
extern BOOL g_bPalette;

#define SIZE_NONE	-1
#define SIZE_FRAME	0
#define SIZE_SCROLL	1
#define SIZE_CAPTION	2
#define SIZE_SMCAPTION	3
#define SIZE_MENU	4
#define SIZE_DXICON     5
#define SIZE_DYICON     6
#define SIZE_ICON       7
#define SIZE_SMICON     8

#define NUM_SIZES	9

typedef struct {
    int CurSize;
    int MinSize;
    int MaxSize;
} LOOK_SIZE;
extern LOOK_SIZE g_sizes[];

typedef struct {
    int iMainColor;
    int iSize;
    BOOL fLinkSizeToFont;
    int iTextColor;
    int iFont;
    int iResId;		// id of name in resource (or -1 if duplicate)
    int iBaseElement;	// index of element that this overlaps (or -1)
    RECT rc;
    int iGradColor;
} LOOK_ELEMENT;

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//this order has to match the array order in lookdlg.c
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
enum _ELEMENTS {
    ELEMENT_APPSPACE = 0,
    ELEMENT_DESKTOP,
    ELEMENT_INACTIVEBORDER,
    ELEMENT_ACTIVEBORDER,
    ELEMENT_INACTIVECAPTION,
    ELEMENT_INACTIVESYSBUT1,
    ELEMENT_INACTIVESYSBUT2,
    ELEMENT_ACTIVECAPTION,
    ELEMENT_ACTIVESYSBUT1,
    ELEMENT_ACTIVESYSBUT2,
    ELEMENT_MENUNORMAL,
    ELEMENT_MENUSELECTED,
    ELEMENT_MENUDISABLED,
    ELEMENT_WINDOW,
    ELEMENT_MSGBOX,
    ELEMENT_MSGBOXCAPTION,
    ELEMENT_MSGBOXSYSBUT,
    ELEMENT_SCROLLBAR,
    ELEMENT_SCROLLUP,
    ELEMENT_SCROLLDOWN,
    ELEMENT_BUTTON,
    ELEMENT_SMCAPTION,
    ELEMENT_ICON,
    ELEMENT_ICONHORZSPACING,
    ELEMENT_ICONVERTSPACING,
    ELEMENT_INFO
};
// BOGUS:  need to get a size from somewhere
#define NUM_ELEMENTS ELEMENT_INFO+1

#if 0
// go fix lookdlg.c if you decide to add this back in
    ELEMENT_SMICON,
#endif


#define CPI_VGAONLY	0x0001
#define CPI_PALETTEOK	0x0002

typedef struct {
    HWND hwndParent;    // parent for any modal dialogs (choosecolor et al)
    HWND hwndOwner;     // control that owns mini color picker
    COLORREF rgb;
    UINT flags;
    HPALETTE hpal;
} COLORPICK_INFO, FAR * LPCOLORPICK_INFO;

extern int cyBorder;
extern int cxBorder;
extern int cyEdge;
extern int cxEdge;

// NOTE: the order in g_elements must match the enum order above
extern LOOK_ELEMENT g_elements[];

void FAR PASCAL Look_SelectElement(HWND hDlg, int iElement, DWORD dwFlags);

BOOL WINAPI ChooseColorMini(LPCOLORPICK_INFO lpcpi);

DWORD FAR PASCAL DarkenColor(DWORD rgb, int n);
DWORD FAR PASCAL BrightenColor(DWORD rgb, int n);


#define LF32toLF(lplf32, lplf)  (*(lplf) = *(lplf32))
#define LFtoLF32(lplf, lplf32)  (*(lplf32) = *(lplf))

// HACK - REMOVE THESE
extern int g_LogDPI;              // logical resolution of display
extern HPALETTE g_hpalVGA;              // only exist if palette device
void GetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm);
void SetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm);
void PASCAL Look_RebuildSysStuff(BOOL fInit);
#if(WINVER >= 0x0501)
#define NT40_COLOR_ENDCOLORS         COLOR_ENDCOLORS
#else
#define NT40_COLOR_ENDCOLORS         COLOR_GRADIENTINACTIVECAPTION
#endif
#define NT40_COLOR_MAX               (NT40_COLOR_ENDCOLORS+1)
#define NT40_COLOR_MAX_REAL          (COLOR_INFOBK + 1)
extern const TCHAR c_szRegPathUserMetrics[];
extern const TCHAR c_szRegValIconSize[];
extern const TCHAR c_szRegValSmallIconSize[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\lookprev.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
/*  LOOKPREV.C
**
**
**
**  History:
**
*/
#include "pch.hxx" // PCH
#pragma hdrstop

#include "AccWiz.h"

#include "desk.h"
//#include "deskid.h"
#include "resource.h"
#include "look.h"

#include "LookPrev.h"

#define RCZ(element)         g_elements[element].rc


//////////////////////////////////
// Support function
void MyDrawBorderBelow(HDC hdc, LPRECT prc);
void MyDrawFrame(HDC hdc, LPRECT prc, HBRUSH hbrColor, int cl);


HDC g_hdcMem;
TCHAR g_szABC[] = TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
int cxSize;

//////////////////////////////////////////////////////////////
// Declarations of static variables declared in classes
BOOL CLookPreviewGlobals::sm_bOneInstanceCreated = FALSE; // This variable insures that only one instance of CLookPreviewGlobals is created
CLookPreviewGlobals CLookPrev::sm_Globals;

//////////////////////////////////////////////////////////////
// CLookPreviewGlobals member functions
//

BOOL CLookPreviewGlobals::Initialize()
{
   if(m_bInitialized)
      return TRUE;

   m_bInitialized = TRUE;

   // Make sure there is only one instance of this class created
   _ASSERT(!sm_bOneInstanceCreated);
   sm_bOneInstanceCreated = TRUE;

   //
   // Load our display strings.
   //
   VERIFY(LoadString(g_hInstDll, IDS_ACTIVE, m_szActive, ARRAYSIZE(m_szActive)));
   VERIFY(LoadString(g_hInstDll, IDS_INACTIVE, m_szInactive, ARRAYSIZE(m_szInactive)));
   VERIFY(LoadString(g_hInstDll, IDS_MINIMIZED, m_szMinimized, ARRAYSIZE(m_szMinimized)));
   VERIFY(LoadString(g_hInstDll, IDS_ICONTITLE, m_szIconTitle, ARRAYSIZE(m_szIconTitle)));
   VERIFY(LoadString(g_hInstDll, IDS_NORMAL, m_szNormal, ARRAYSIZE(m_szNormal)));
   VERIFY(LoadString(g_hInstDll, IDS_DISABLED, m_szDisabled, ARRAYSIZE(m_szDisabled)));
   VERIFY(LoadString(g_hInstDll, IDS_SELECTED, m_szSelected, ARRAYSIZE(m_szSelected)));
   VERIFY(LoadString(g_hInstDll, IDS_MSGBOX, m_szMsgBox, ARRAYSIZE(m_szMsgBox)));
   VERIFY(LoadString(g_hInstDll, IDS_BUTTONTEXT, m_szButton, ARRAYSIZE(m_szButton)));
//    VERIFY(LoadString(g_hInstDll, IDS_SMCAPTION, m_szSmallCaption, ARRAYSIZE(m_szSmallCaption)));
   VERIFY(LoadString(g_hInstDll, IDS_WINDOWTEXT, m_szWindowText, ARRAYSIZE(m_szWindowText)));
   VERIFY(LoadString(g_hInstDll, IDS_MSGBOXTEXT, m_szMsgBoxText, ARRAYSIZE(m_szMsgBoxText)));

   /////////////////////////////////////////////
   // Register Look Preview window class
   WNDCLASS wc;
   memset(&wc, 0, sizeof(wc));
   wc.style = 0;
   wc.lpfnWndProc = CLookPrev::LookPreviewWndProc;
   wc.cbClsExtra = 0;
   wc.cbWndExtra = 0;
   wc.hInstance = g_hInstDll;
   wc.hIcon = NULL;
   wc.hCursor = LoadCursor(NULL, IDC_ARROW);
   wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
   wc.lpszMenuName = NULL;
   wc.lpszClassName = LOOKPREV_CLASS;

   VERIFY(RegisterClass(&wc));

   /////////////////////////////////////////////
   // Global initialization of g_hdcMem
   HBITMAP hbmDefault;
   HDC hdc = GetDC(NULL);
   VERIFY(g_hdcMem = CreateCompatibleDC(hdc));
   ReleaseDC(NULL, hdc);

   HBITMAP hbm = CreateBitmap(1, 1, 1, 1, NULL);
   if (!hbm)
      return FALSE;	// Prefix #113777 (avoid null handle reference)

   hbmDefault = (HBITMAP)SelectObject(g_hdcMem, hbm);
   SelectObject(g_hdcMem, hbmDefault);
   DeleteObject(hbm);


   /////////////////////////////////////////////
   // Old initialization form Look_InitSysStuff()
   int i;
   NONCLIENTMETRICS ncm;
   HKEY hkey;

   hdc = GetDC(NULL);
   g_LogDPI = GetDeviceCaps(hdc, LOGPIXELSY);
   g_bPalette = GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE;
   ReleaseDC(NULL, hdc);

   // always make a palette even on non-pal device
   if (g_bPalette || TRUE)
   {
      DWORD pal[21];
      HPALETTE hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

      pal[1]   = RGB(255, 255, 255);
      pal[2]   = RGB(0,   0,  0  );
      pal[3]   = RGB(192, 192, 192);
      pal[4]   = RGB(128, 128, 128);
      pal[5]   = RGB(255, 0,  0  );
      pal[6]   = RGB(128, 0,  0  );
      pal[7]   = RGB(255, 255, 0  );
      pal[8]   = RGB(128, 128, 0  );
      pal[9]   = RGB(0  , 255, 0  );
      pal[10] = RGB(0  , 128, 0  );
      pal[11] = RGB(0  , 255, 255);
      pal[12] = RGB(0 , 128, 128); // Needs to be changed to get Blue color
      pal[13] = RGB(0  , 0,   255);
      pal[14] = RGB(0  , 0,   128);
      pal[15] = RGB(255, 0,   255);
      pal[16] = RGB(128, 0,   128);

      GetPaletteEntries(hpal, 11, 1, (LPPALETTEENTRY)&pal[17]);
      pal[0]   = MAKELONG(0x300, 17);
      g_hpalVGA = CreatePalette((LPLOGPALETTE)pal);

      // get magic colors
      GetPaletteEntries(hpal, 8, 4, (LPPALETTEENTRY)&pal[17]);

      pal[0]   = MAKELONG(0x300, 20);
      g_hpal3D = CreatePalette((LPLOGPALETTE)pal);
   }

   // system colors
   for (i = 0; i < NT40_COLOR_MAX; i++)
   {
      g_Options.m_schemePreview.m_rgb[i] = GetSysColor(i);
      g_brushes[i] = NULL;
   }

   // sizes and fonts
   ncm.cbSize = sizeof(ncm);
   SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm),
                        (void far *)(LPNONCLIENTMETRICS)&ncm, FALSE);

   SetMyNonClientMetrics(&ncm);

   SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT),
            (void far *)(LPLOGFONT)&(g_fonts[FONT_ICONTITLE].lf), FALSE);

   SystemParametersInfo(SPI_SETGRADIENTCAPTIONS, 0, (PVOID)TRUE, 0);

   // default shell icon sizes
   g_sizes[ SIZE_ICON ].CurSize = GetSystemMetrics( SM_CXICON );
   g_sizes[ SIZE_SMICON ].CurSize = g_sizes[ SIZE_ICON ].CurSize / 2;

   if( RegOpenKey( HKEY_CURRENT_USER, c_szRegPathUserMetrics, &hkey )
      == ERROR_SUCCESS )
   {
      TCHAR val[ 8 ];
      LONG len = sizeof( val );

      if( RegQueryValueEx( hkey, c_szRegValIconSize, 0, NULL, (LPBYTE)&val,
         (LPDWORD)&len ) == ERROR_SUCCESS )
      {
         g_sizes[ SIZE_ICON ].CurSize = (int)MyStrToLong( val );
      }

      len = SIZEOF( val );
      if( RegQueryValueEx( hkey, c_szRegValSmallIconSize, 0, NULL, (LPBYTE)&val,
         (LPDWORD)&len ) == ERROR_SUCCESS )
      {
         g_sizes[ SIZE_SMICON ].CurSize = (int)MyStrToLong( val );
      }

      RegCloseKey( hkey );
   }

   g_sizes[ SIZE_DXICON ].CurSize =
      GetSystemMetrics( SM_CXICONSPACING ) - g_sizes[ SIZE_ICON ].CurSize;
   if( g_sizes[ SIZE_DXICON ].CurSize < 0 )
      g_sizes[ SIZE_DXICON ].CurSize = DEF_SPACING;

   g_sizes[ SIZE_DYICON ].CurSize =
      GetSystemMetrics( SM_CYICONSPACING ) - g_sizes[ SIZE_ICON ].CurSize;
   if( g_sizes[ SIZE_DYICON ].CurSize < 0 )
      g_sizes[ SIZE_DYICON ].CurSize = DEF_SPACING;

   // clean out the memory
   for (i = 0; i < NUM_FONTS; i++)
   {
      g_fonts[i].hfont = NULL;
   }

   // build all the brushes/fonts we need
   Look_RebuildSysStuff(TRUE);


   // From Look_InitDialog
   // initialize some globals
   cyBorder = GetSystemMetrics(SM_CYBORDER);
   cxBorder = GetSystemMetrics(SM_CXBORDER);
   cxEdge = GetSystemMetrics(SM_CXEDGE);
   cyEdge = GetSystemMetrics(SM_CYEDGE);

   return TRUE;
}


//////////////////////////////////////////////////////////////
// CLookPreviewGlobals member functions
//

// This is the static window proc function of CLookPrev
LRESULT CALLBACK CLookPrev::LookPreviewWndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
   PAINTSTRUCT ps;

   CLookPrev *pThis = (CLookPrev *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
   if(!pThis)
   {
      // Create the class to handle this object
      // Store the 'this' pointer in 
      pThis = new CLookPrev;
      if (!pThis)
            return ERROR_NOT_ENOUGH_MEMORY;	// Prefix #113776 (catch null pointer)

      pThis->m_hwnd = hWnd;
      SetWindowLongPtr (hWnd, GWLP_USERDATA, (INT_PTR)pThis);
   }

   switch(message)
   {
      case WM_NCCREATE:
         {
            DWORD dw;
            dw = GetWindowLong (hWnd,GWL_STYLE);
            SetWindowLong (hWnd, GWL_STYLE, dw | WS_BORDER);
            dw = GetWindowLong (hWnd,GWL_EXSTYLE);
            SetWindowLong (hWnd, GWL_EXSTYLE, dw | WS_EX_CLIENTEDGE);
         }
         return TRUE;

      case WM_CREATE:
         pThis->OnCreate();
         break;

      case WM_PALETTECHANGED:
         if ((HWND)wParam == hWnd)
            break;
         //fallthru
      case WM_QUERYNEWPALETTE:
         if (g_hpal3D)
            InvalidateRect(hWnd, NULL, FALSE);
         break;

      case WM_PAINT:
         BeginPaint(hWnd, &ps);
         pThis->OnPaint(ps.hdc);
         EndPaint(hWnd, &ps);
         return 0;

      case LPM_REPAINT:
         pThis->OnRepaint();
         return 0;

      case LPM_RECALC:
         pThis->OnRecalc();
         return 0;

   }
   return DefWindowProc(hWnd,message,wParam,lParam);
}

void CLookPrev::OnCreate()
{
   // Load menu for window
   m_hmenuSample = LoadMenu(g_hInstDll, MAKEINTRESOURCE(IDR_MENU));
   EnableMenuItem(m_hmenuSample, IDM_DISABLED, MF_GRAYED | MF_BYCOMMAND);
   HiliteMenuItem(m_hwnd, m_hmenuSample, IDM_SELECTED, MF_HILITE | MF_BYCOMMAND);

   // Create Bitmap for window
   RECT rc;
   HDC hdc;
   GetClientRect(m_hwnd, &rc);
   hdc = GetDC(NULL);
   m_hbmLook = CreateCompatibleBitmap(hdc, rc.right - rc.left, rc.bottom - rc.top);
   ReleaseDC(NULL, hdc);
   // Mirror the memory DC if the window is mirrored to keep the text readable.
   if (GetWindowLong(m_hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
       SetLayout(g_hdcMem, LAYOUT_RTL);
   }
}

void CLookPrev::OnDestroy()
{
   if (m_hbmLook)
      DeleteObject(m_hbmLook);
   if (m_hmenuSample)
      DestroyMenu(m_hmenuSample);

   // Un-allocate memory for this instance of the class
   delete this;
}


void CLookPrev::OnPaint(HDC hdc)
{
   if (m_hbmLook)
      ShowBitmap(hdc);
   else
      Draw(hdc);
}

void CLookPrev::ShowBitmap(HDC hdc)
{
   RECT rc;
   HBITMAP hbmOld;
   HPALETTE hpalOld = NULL;

   if (g_hpal3D)
   {
      hpalOld = SelectPalette(hdc, g_hpal3D, FALSE);
      RealizePalette(hdc);
   }

   GetClientRect(m_hwnd, &rc);
   hbmOld = (HBITMAP)SelectObject(g_hdcMem, m_hbmLook);
   BitBlt(hdc, 0, 0, rc.right - rc.left, rc.bottom - rc.top, g_hdcMem, 0, 0, SRCCOPY);
   SelectObject(g_hdcMem, hbmOld);

   if (hpalOld)
   {
      SelectPalette(hdc, hpalOld, FALSE);
      RealizePalette(hdc);
   }
}



void CLookPrev::Draw(HDC hdc)
{
   RECT rcT;
   int nMode;
   DWORD rgbBk;
   int cxSize, cySize;
   HANDLE hOldColors;
   HPALETTE hpalOld = NULL;
   HICON hiconLogo;
// HFONT hfontOld;

   SaveDC(hdc);

   if (g_hpal3D)
   {
      hpalOld = SelectPalette(hdc, g_hpal3D, TRUE);
      RealizePalette(hdc);
   }

   hOldColors = SetSysColorsTemp(g_Options.m_schemePreview.m_rgb, g_brushes, COLOR_MAX_97_NT5/*COLOR_MAX_95_NT4*/);

   hiconLogo = (HICON)LoadImage(NULL, IDI_APPLICATION, IMAGE_ICON,
                  g_sizes[SIZE_CAPTION].CurSize - 2*cxBorder,
                  g_sizes[SIZE_CAPTION].CurSize - 2*cyBorder, 0);

   //
   // Setup drawing stuff
   //
   nMode = SetBkMode(hdc, TRANSPARENT);
   rgbBk = GetTextColor(hdc);

   cxSize   = GetSystemMetrics(SM_CXSIZE);
   cySize   = GetSystemMetrics(SM_CYSIZE);

   //
   // Desktop
   //
   FillRect(hdc, &RCZ(ELEMENT_DESKTOP), g_brushes[COLOR_BACKGROUND]);

   //
   // Inactive window
   //

   // Border
   rcT = RCZ(ELEMENT_INACTIVEBORDER);
   DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_INACTIVEBORDER], g_sizes[SIZE_FRAME].CurSize);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_3DFACE], 1);

   // Caption
   rcT = RCZ(ELEMENT_INACTIVECAPTION);
   MyDrawBorderBelow(hdc, &rcT);

   // NOTE: because USER draws icon stuff using its own DC and subsequently
   // its own palette, we need to make sure to use the inactivecaption
   // brush before USER does so that it will be realized against our palette.
   // this might get fixed in USER by better be safe. 

   // "clip" the caption title under the buttons
   rcT.left = RCZ(ELEMENT_INACTIVESYSBUT2).left - cyEdge;
   FillRect(hdc, &rcT, g_brushes[COLOR_GRADIENTINACTIVECAPTION]);
   rcT.right = rcT.left;
   rcT.left = RCZ(ELEMENT_INACTIVECAPTION).left;
   DrawCaptionTemp(NULL, hdc, &rcT, g_fonts[FONT_CAPTION].hfont, hiconLogo, sm_Globals.m_szInactive, DC_ICON | DC_TEXT | DC_GRADIENT);

   DrawFrameControl(hdc, &RCZ(ELEMENT_INACTIVESYSBUT1), DFC_CAPTION, DFCS_CAPTIONCLOSE);
   rcT = RCZ(ELEMENT_INACTIVESYSBUT2);
   rcT.right -= (rcT.right - rcT.left)/2;
   DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMIN);
   rcT.left = rcT.right;
   rcT.right = RCZ(ELEMENT_INACTIVESYSBUT2).right;
   DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMAX);


#if 0
   //
   // small caption window
   // 

   {
   HICON hicon;
   int temp;


   rcT = RCZ(ELEMENT_SMCAPTION);
   hicon = (HICON)LoadImage(NULL, IDI_APPLICATION,
         IMAGE_ICON,
                  g_sizes[SIZE_SMCAPTION].CurSize - 2*cxBorder,
                  g_sizes[SIZE_SMCAPTION].CurSize - 2*cyBorder,
               0);

   DrawEdge(hdc, &rcT, EDGE_RAISED, BF_TOP | BF_LEFT | BF_RIGHT | BF_ADJUST);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_3DFACE], 1);
   // "clip" the caption title under the buttons
   temp = rcT.left;  // remember start of actual caption
   rcT.left = RCZ(ELEMENT_SMCAPSYSBUT).left - cxEdge;
   FillRect(hdc, &rcT, g_brushes[COLOR_ACTIVECAPTION]);
   rcT.right = rcT.left;
   rcT.left = temp;  // start of actual caption
   DrawCaptionTemp(NULL, hdc, &rcT, g_fonts[FONT_SMCAPTION].hfont, hicon, sm_Globals.m_szSmallCaption, DC_SMALLCAP | DC_ICON | DC_TEXT);
   DestroyIcon(hicon);

   DrawFrameControl(hdc, &RCZ(ELEMENT_SMCAPSYSBUT), DFC_CAPTION, DFCS_CAPTIONCLOSE);
   }
#endif

   //
   // Active window
   //

   // Border
   rcT = RCZ(ELEMENT_ACTIVEBORDER);
   DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_ACTIVEBORDER], g_sizes[SIZE_FRAME].CurSize);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_3DFACE], 1);

   // Caption
   rcT = RCZ(ELEMENT_ACTIVECAPTION);
   MyDrawBorderBelow(hdc, &rcT);
   // "clip" the caption title under the buttons
   rcT.left = RCZ(ELEMENT_ACTIVESYSBUT2).left - cxEdge;
   FillRect(hdc, &rcT, g_brushes[COLOR_GRADIENTACTIVECAPTION]);
   rcT.right = rcT.left;
   rcT.left = RCZ(ELEMENT_ACTIVECAPTION).left;
   DrawCaptionTemp(NULL, hdc, &rcT, g_fonts[FONT_CAPTION].hfont, hiconLogo, sm_Globals.m_szActive, DC_ACTIVE | DC_ICON | DC_TEXT | DC_GRADIENT);

   DrawFrameControl(hdc, &RCZ(ELEMENT_ACTIVESYSBUT1), DFC_CAPTION, DFCS_CAPTIONCLOSE);
   rcT = RCZ(ELEMENT_ACTIVESYSBUT2);
   rcT.right -= (rcT.right - rcT.left)/2;
   DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMIN);
   rcT.left = rcT.right;
   rcT.right = RCZ(ELEMENT_ACTIVESYSBUT2).right;
   DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMAX);

   // Menu
   rcT = RCZ(ELEMENT_MENUNORMAL);
   
#if 0 // HACK TO SLIP USING DrawMenuBarTemp() which is not available on Memphis
   DrawMenuBarTemp(m_hwnd, hdc, &rcT, g_Options.m_hmenuSample, g_fonts[FONT_MENU].hfont);
#else
   {
      // JMC: HACK - HARD CODED TEXT
      HFONT hOldFont = (HFONT)SelectObject(hdc, g_fonts[FONT_MENU].hfont);
      COLORREF clrrefOldText = SetTextColor(hdc, g_Options.m_schemePreview.m_rgb[COLOR_MENUTEXT]);
      COLORREF clrrefOldBk = SetBkColor(hdc, g_Options.m_schemePreview.m_rgb[COLOR_MENU]);
      int nOldMode = SetBkMode(hdc, OPAQUE);
//    LPCTSTR lpszText = __TEXT("  File   Edit   Help");
      TCHAR szText[200];
      LoadString(g_hInstDll, IDS_PREVIEWMENUTEXT, szText, ARRAYSIZE(szText));
      ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcT, NULL, 0, NULL);
      DrawText(hdc, szText, lstrlen(szText), &rcT, DT_VCENTER | DT_SINGLELINE | DT_EXPANDTABS);
      SetTextColor(hdc, clrrefOldText);
      SetBkColor(hdc, clrrefOldBk);
      SetBkMode(hdc, nOldMode);
      SelectObject(hdc, hOldFont);
   }
#endif
   MyDrawBorderBelow(hdc, &rcT);

   //
   // Client area
   //

   rcT = RCZ(ELEMENT_WINDOW);
   DrawEdge(hdc, &rcT, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
   FillRect(hdc, &rcT, g_brushes[COLOR_WINDOW]);

   // window text
   SetBkMode(hdc, TRANSPARENT);
   SetTextColor(hdc, g_Options.m_schemePreview.m_rgb[COLOR_WINDOWTEXT]);
   TextOut(hdc, RCZ(ELEMENT_WINDOW).left + 2*cxEdge, RCZ(ELEMENT_WINDOW).top + 2*cyEdge, sm_Globals.m_szWindowText, lstrlen(sm_Globals.m_szWindowText));

   //
   // scroll bar
   //
   rcT = RCZ(ELEMENT_SCROLLBAR);
   //MyDrawFrame(hdc, &rcT, g_brushes[COLOR_3DSHADOW], 1);
   //g_brushes[COLOR_SCROLLBAR]);
   //FillRect(hdc, &rcT, (HBRUSH)DefWindowProc(m_hwnd, WM_CTLCOLORSCROLLBAR, (WPARAM)hdc, (LPARAM)m_hwnd));
   FillRect(hdc, &rcT, g_brushes[COLOR_SCROLLBAR]);

   DrawFrameControl(hdc, &RCZ(ELEMENT_SCROLLUP), DFC_SCROLL, DFCS_SCROLLUP);
   DrawFrameControl(hdc, &RCZ(ELEMENT_SCROLLDOWN), DFC_SCROLL, DFCS_SCROLLDOWN);

#if 0 // Don't draw message box
   //
   // MessageBox
   //
   rcT = RCZ(ELEMENT_MSGBOX);
   DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
   FillRect(hdc, &rcT, g_brushes[COLOR_3DFACE]);

   rcT = RCZ(ELEMENT_MSGBOXCAPTION);
   MyDrawBorderBelow(hdc, &rcT);
   // "clip" the caption title under the buttons
   rcT.left = RCZ(ELEMENT_MSGBOXSYSBUT).left - cxEdge;
   FillRect(hdc, &rcT, g_brushes[COLOR_GRADIENTACTIVECAPTION]);
   rcT.right = rcT.left;
   rcT.left = RCZ(ELEMENT_MSGBOXCAPTION).left;
   DrawCaptionTemp(NULL, hdc, &rcT, g_fonts[FONT_CAPTION].hfont, hiconLogo, sm_Globals.m_szMsgBox, DC_ACTIVE | DC_ICON | DC_TEXT | DC_GRADIENT);

   DrawFrameControl(hdc, &RCZ(ELEMENT_MSGBOXSYSBUT), DFC_CAPTION, DFCS_CAPTIONCLOSE);

   // message box text
   SetBkMode(hdc, TRANSPARENT);
   SetTextColor(hdc, g_Options.m_schemePreview.m_rgb[COLOR_WINDOWTEXT]);
   hfontOld = (HFONT)SelectObject(hdc, g_fonts[FONT_MSGBOX].hfont);
   TextOut(hdc, RCZ(ELEMENT_MSGBOX).left + 3*cxEdge, RCZ(ELEMENT_MSGBOXCAPTION).bottom + cyEdge,
                  sm_Globals.m_szMsgBoxText, lstrlen(sm_Globals.m_szMsgBoxText));
   if (hfontOld)
      SelectObject(hdc, hfontOld);

   //
   // Button
   //
   rcT = RCZ(ELEMENT_BUTTON);
   DrawFrameControl(hdc, &rcT, DFC_BUTTON, DFCS_BUTTONPUSH);

// ?????? what font should this use ??????
   SetBkMode(hdc, TRANSPARENT);
   SetTextColor(hdc, g_Options.m_schemePreview.m_rgb[COLOR_BTNTEXT]);
   DrawText(hdc, sm_Globals.m_szButton, -1, &rcT, DT_CENTER | DT_NOPREFIX |
      DT_SINGLELINE | DT_VCENTER);
#endif

   SetBkColor(hdc, rgbBk);
   SetBkMode(hdc, nMode);

   if (hiconLogo)
      DestroyIcon(hiconLogo);

   SetSysColorsTemp(NULL, NULL, (UINT_PTR)hOldColors);

   if (hpalOld)
   {
      hpalOld = SelectPalette(hdc, hpalOld, FALSE);
      RealizePalette(hdc);
   }

   RestoreDC(hdc, -1);
}

void CLookPrev::OnRepaint()
{
   HBITMAP hbmOld;

   if (m_hbmLook)
   {
      hbmOld = (HBITMAP)SelectObject(g_hdcMem, m_hbmLook);
      Draw(g_hdcMem);
      SelectObject(g_hdcMem, hbmOld);
   }
   InvalidateRect(m_hwnd, NULL, FALSE);
}


void CLookPrev::OnRecalc()
{
   DWORD cxNormal;
   int cxDisabled, cxSelected;
   int cxAvgCharx2;
   RECT rc;
   HFONT hfontT;
   int cxFrame, cyFrame;
   int cyCaption;
   int i;
   SIZE sizButton;

   GetClientRect(m_hwnd, &rc);

   //
   // Get our drawing data
   //
   cxSize = GetSystemMetrics(SM_CXSIZE);
   cxFrame = (g_sizes[SIZE_FRAME].CurSize + 1) * cxBorder + cxEdge;
   cyFrame = (g_sizes[SIZE_FRAME].CurSize + 1) * cyBorder + cyEdge;
   cyCaption = g_sizes[SIZE_CAPTION].CurSize;

   //
   // Get text dimensions, with proper font.
   //

   hfontT = (HFONT)SelectObject(g_hdcMem, g_fonts[FONT_MENU].hfont);

   GetTextExtentPoint32(g_hdcMem, sm_Globals.m_szNormal, lstrlen(sm_Globals.m_szNormal), &sizButton);
   cxNormal = sizButton.cx;

   GetTextExtentPoint32(g_hdcMem, sm_Globals.m_szDisabled, lstrlen(sm_Globals.m_szDisabled), &sizButton);
   cxDisabled = sizButton.cx;

   GetTextExtentPoint32(g_hdcMem, sm_Globals.m_szSelected, lstrlen(sm_Globals.m_szSelected), &sizButton);
   cxSelected = sizButton.cx;

   // get the average width (USER style) of menu font
   GetTextExtentPoint32(g_hdcMem, g_szABC, 52, &sizButton);
   cxAvgCharx2 = 2 * (sizButton.cx / 52);

   // actual menu-handling widths of strings is bigger
   cxDisabled += cxAvgCharx2;
   cxSelected += cxAvgCharx2;
   cxNormal += cxAvgCharx2;

   SelectObject(g_hdcMem, hfontT);

   GetTextExtentPoint32(g_hdcMem, sm_Globals.m_szButton, lstrlen(sm_Globals.m_szButton), &sizButton);

   //
   // Desktop
   //
   RCZ(ELEMENT_DESKTOP) = rc;

   InflateRect(&rc, -8*cxBorder, -8*cyBorder);

   //
   // Windows
   //
   rc.bottom -= cyFrame + cyCaption;
   RCZ(ELEMENT_ACTIVEBORDER) = rc;
   OffsetRect(&RCZ(ELEMENT_ACTIVEBORDER), cxFrame,
                  cyFrame + cyCaption + cyBorder);
   RCZ(ELEMENT_ACTIVEBORDER).bottom -= cyCaption;

   //
   // Inactive window
   //

   rc.right -= cyCaption;
   RCZ(ELEMENT_INACTIVEBORDER) = rc;

   // Caption
   InflateRect(&rc, -cxFrame, -cyFrame);
   rc.bottom = rc.top + cyCaption + cyBorder;
   RCZ(ELEMENT_INACTIVECAPTION) = rc;

   // close button
   InflateRect(&rc, -cxEdge, -cyEdge);
   rc.bottom -= cyBorder;     // compensate for magic line under caption
   RCZ(ELEMENT_INACTIVESYSBUT1) = rc;
   RCZ(ELEMENT_INACTIVESYSBUT1).left = rc.right - (cyCaption - cxEdge);

   // min/max buttons
   RCZ(ELEMENT_INACTIVESYSBUT2) = rc;
   RCZ(ELEMENT_INACTIVESYSBUT2).right = RCZ(ELEMENT_INACTIVESYSBUT1).left - cxEdge;
   RCZ(ELEMENT_INACTIVESYSBUT2).left = RCZ(ELEMENT_INACTIVESYSBUT2).right - 
                                    2 * (cyCaption - cxEdge);

#if 0
   //
   // small caption window
   //
   RCZ(ELEMENT_SMCAPTION) = RCZ(ELEMENT_ACTIVEBORDER);
   RCZ(ELEMENT_SMCAPTION).bottom = RCZ(ELEMENT_SMCAPTION).top;
   RCZ(ELEMENT_SMCAPTION).top -= g_sizes[SIZE_SMCAPTION].CurSize + cyEdge + 2 * cyBorder;
   RCZ(ELEMENT_SMCAPTION).right -= cxFrame;
   RCZ(ELEMENT_SMCAPTION).left = RCZ(ELEMENT_INACTIVECAPTION).right + 2 * cxFrame;

   RCZ(ELEMENT_SMCAPSYSBUT) = RCZ(ELEMENT_SMCAPTION);
   // deflate inside frame/border to caption and then another edge's worth
   RCZ(ELEMENT_SMCAPSYSBUT).right -= 2 * cxEdge + cxBorder;
   RCZ(ELEMENT_SMCAPSYSBUT).top += 2 * cxEdge + cxBorder;
   RCZ(ELEMENT_SMCAPSYSBUT).bottom -= cxEdge + cxBorder;
   RCZ(ELEMENT_SMCAPSYSBUT).left = RCZ(ELEMENT_SMCAPSYSBUT).right - 
                              (g_sizes[SIZE_SMCAPTION].CurSize - cxEdge);
#endif

   //
   // Active window
   //

   // Caption
   rc = RCZ(ELEMENT_ACTIVEBORDER);
   InflateRect(&rc, -cxFrame, -cyFrame);
   RCZ(ELEMENT_ACTIVECAPTION) = rc;
   RCZ(ELEMENT_ACTIVECAPTION).bottom = 
      RCZ(ELEMENT_ACTIVECAPTION).top + cyCaption + cyBorder;

   // close button
   RCZ(ELEMENT_ACTIVESYSBUT1) = RCZ(ELEMENT_ACTIVECAPTION);
   InflateRect(&RCZ(ELEMENT_ACTIVESYSBUT1), -cxEdge, -cyEdge);
   RCZ(ELEMENT_ACTIVESYSBUT1).bottom -= cyBorder;     // compensate for magic line under caption
   RCZ(ELEMENT_ACTIVESYSBUT1).left = RCZ(ELEMENT_ACTIVESYSBUT1).right - 
                              (cyCaption - cxEdge);

   // min/max buttons
   RCZ(ELEMENT_ACTIVESYSBUT2) = RCZ(ELEMENT_ACTIVESYSBUT1);
   RCZ(ELEMENT_ACTIVESYSBUT2).right = RCZ(ELEMENT_ACTIVESYSBUT1).left - cxEdge;
   RCZ(ELEMENT_ACTIVESYSBUT2).left = RCZ(ELEMENT_ACTIVESYSBUT2).right - 
                                    2 * (cyCaption - cxEdge);

   // Menu
   rc.top = RCZ(ELEMENT_ACTIVECAPTION).bottom;
   RCZ(ELEMENT_MENUNORMAL) = rc;
   rc.top = RCZ(ELEMENT_MENUNORMAL).bottom = RCZ(ELEMENT_MENUNORMAL).top + g_sizes[SIZE_MENU].CurSize;
   RCZ(ELEMENT_MENUDISABLED) = RCZ(ELEMENT_MENUSELECTED) = RCZ(ELEMENT_MENUNORMAL);

   RCZ(ELEMENT_MENUDISABLED).left = RCZ(ELEMENT_MENUNORMAL).left + cxNormal;
   RCZ(ELEMENT_MENUDISABLED).right = RCZ(ELEMENT_MENUSELECTED).left = 
                  RCZ(ELEMENT_MENUDISABLED).left + cxDisabled;
   RCZ(ELEMENT_MENUSELECTED).right = RCZ(ELEMENT_MENUSELECTED).left + cxSelected;
   
   //
   // Client
   //
   RCZ(ELEMENT_WINDOW) = rc;

   //
   // Scrollbar
   //
   InflateRect(&rc, -cxEdge, -cyEdge); // take off client edge
   RCZ(ELEMENT_SCROLLBAR) = rc;
   rc.right = RCZ(ELEMENT_SCROLLBAR).left = rc.right - g_sizes[SIZE_SCROLL].CurSize;
   RCZ(ELEMENT_SCROLLUP) = RCZ(ELEMENT_SCROLLBAR);
   RCZ(ELEMENT_SCROLLUP).bottom = RCZ(ELEMENT_SCROLLBAR).top + g_sizes[SIZE_SCROLL].CurSize; 

   RCZ(ELEMENT_SCROLLDOWN) = RCZ(ELEMENT_SCROLLBAR);
   RCZ(ELEMENT_SCROLLDOWN).top = RCZ(ELEMENT_SCROLLBAR).bottom - g_sizes[SIZE_SCROLL].CurSize; 

   //
   // Message Box
   //
   rc.top = RCZ(ELEMENT_WINDOW).top + (RCZ(ELEMENT_WINDOW).bottom - RCZ(ELEMENT_WINDOW).top) / 2;
   rc.bottom = RCZ(ELEMENT_DESKTOP).bottom - 2*cyEdge;
   rc.left = RCZ(ELEMENT_WINDOW).left + 2*cyEdge;
   rc.right = RCZ(ELEMENT_WINDOW).left + (RCZ(ELEMENT_WINDOW).right - RCZ(ELEMENT_WINDOW).left) / 2 + 3*cyCaption;
   RCZ(ELEMENT_MSGBOX) = rc;

   // Caption
   RCZ(ELEMENT_MSGBOXCAPTION) = rc;
   RCZ(ELEMENT_MSGBOXCAPTION).top += cyEdge + cyBorder;
   RCZ(ELEMENT_MSGBOXCAPTION).bottom = RCZ(ELEMENT_MSGBOXCAPTION).top + cyCaption + cyBorder;
   RCZ(ELEMENT_MSGBOXCAPTION).left += cxEdge + cxBorder;
   RCZ(ELEMENT_MSGBOXCAPTION).right -= cxEdge + cxBorder;

   RCZ(ELEMENT_MSGBOXSYSBUT) = RCZ(ELEMENT_MSGBOXCAPTION);
   InflateRect(&RCZ(ELEMENT_MSGBOXSYSBUT), -cxEdge, -cyEdge);
   RCZ(ELEMENT_MSGBOXSYSBUT).left = RCZ(ELEMENT_MSGBOXSYSBUT).right - 
                              (cyCaption - cxEdge);
   RCZ(ELEMENT_MSGBOXSYSBUT).bottom -= cyBorder;      // line under caption

   // Button
   RCZ(ELEMENT_BUTTON).bottom = RCZ(ELEMENT_MSGBOX).bottom - (4*cyBorder + cyEdge);
   RCZ(ELEMENT_BUTTON).top = RCZ(ELEMENT_BUTTON).bottom - (sizButton.cy + 8 * cyBorder);

   i = (RCZ(ELEMENT_BUTTON).bottom - RCZ(ELEMENT_BUTTON).top) * 3;
   RCZ(ELEMENT_BUTTON).left = (rc.left + (rc.right - rc.left)/2) - i/2;
   RCZ(ELEMENT_BUTTON).right = RCZ(ELEMENT_BUTTON).left + i;
}












/////////////////////////////////////////////////////////
// Support functions





// ----------------------------------------------------------------------------
//
//  MyDrawFrame() -
//
//  Draws bordered frame, border size cl, and adjusts passed in rect.
//
// ----------------------------------------------------------------------------
void MyDrawFrame(HDC hdc, LPRECT prc, HBRUSH hbrColor, int cl)
{
   HBRUSH hbr;
   int cx, cy;
   RECT rcT;

   rcT = *prc;
   cx = cl * cxBorder;
   cy = cl * cyBorder;

   hbr = (HBRUSH)SelectObject(hdc, hbrColor);

   PatBlt(hdc, rcT.left, rcT.top, cx, rcT.bottom - rcT.top, PATCOPY);
   rcT.left += cx;

   PatBlt(hdc, rcT.left, rcT.top, rcT.right - rcT.left, cy, PATCOPY);
   rcT.top += cy;

   rcT.right -= cx;
   PatBlt(hdc, rcT.right, rcT.top, cx, rcT.bottom - rcT.top, PATCOPY);

   rcT.bottom -= cy;
   PatBlt(hdc, rcT.left, rcT.bottom, rcT.right - rcT.left, cy, PATCOPY);

   hbr = (HBRUSH)SelectObject(hdc, hbr);

   *prc = rcT;
}

/*
** draw a cyBorder band of 3DFACE at the bottom of the given rectangle.
** also, adjust the rectangle accordingly.
*/
void MyDrawBorderBelow(HDC hdc, LPRECT prc)
{
   int i;

   i = prc->top;
   prc->top = prc->bottom - cyBorder;
   FillRect(hdc, prc, g_brushes[COLOR_3DFACE]);
   prc->top = i;
   prc->bottom -= cyBorder;
}

/*-------------------------------------------------------------------
** draw a full window caption with system menu, minimize button,
** maximize button, and text.
**-------------------------------------------------------------------*/
void DrawFullCaption(HDC hdc, LPRECT prc, LPTSTR lpszTitle, UINT flags)
{
   int iRight;
   int iFont;

   SaveDC(hdc);

   // special case gross for small caption that already drew on bottom
   if (!(flags & DC_SMALLCAP))
      MyDrawBorderBelow(hdc, prc);

   iRight = prc->right;
   prc->right = prc->left + cxSize;
   DrawFrameControl(hdc, prc, DFC_CAPTION, DFCS_CAPTIONCLOSE);

   prc->left = prc->right;
   prc->right = iRight - 2*cxSize;
   iFont = flags & DC_SMALLCAP ? FONT_SMCAPTION : FONT_CAPTION;
   DrawCaptionTemp(NULL, hdc, prc, g_fonts[iFont].hfont, NULL, lpszTitle, flags | DC_ICON | DC_TEXT);

   prc->left = prc->right;
   prc->right = prc->left + cxSize;
   DrawFrameControl(hdc, prc, DFC_CAPTION, DFCS_CAPTIONMIN);
   prc->left = prc->right;
   prc->right = prc->left + cxSize;
   DrawFrameControl(hdc, prc, DFC_CAPTION, DFCS_CAPTIONMAX);

   RestoreDC(hdc, -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgbase.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx"
#pragma hdrstop

#include "pgbase.h"
#include "resource.h"
#include "DlgFonts.h"

/***************************************************************************
 * Use the following define if for some reason we have to go back to using
 * a message loop to let shell have time to update the UI
 *
#define NEED_MSG_PUMP
 **************************************************************************/

// Initialization of static members
CWizardPageOrder WizardPage::sm_WizPageOrder;

WizardPage::WizardPage(
					   LPPROPSHEETPAGE ppsp,
					   int nIdTitle,
					   int nIdSubTitle
					   ) : m_hwnd(NULL), m_dwPageId(0)
{
	_ASSERTE(NULL != ppsp);
	
	// If we have a subtitle, we must have a title
	_ASSERTE(nIdSubTitle?nIdTitle:TRUE);
	
	//
	// Many of the members are 0 or NULL.
	//
	ZeroMemory(ppsp, sizeof(PROPSHEETPAGE));
	
	ppsp->dwSize	= sizeof(PROPSHEETPAGE);
	
	ppsp->dwFlags	= PSP_DEFAULT;
	ppsp->hInstance = g_hInstDll;
	
	// If we are using a title/subtitle, include the flags
	// Otherwise, hide the header
	if(nIdTitle)
	{
		ppsp->dwFlags |= PSP_USEHEADERTITLE | (nIdSubTitle?PSP_USEHEADERSUBTITLE:0);
		ppsp->pszHeaderTitle = MAKEINTRESOURCE(nIdTitle);
		ppsp->pszHeaderSubTitle = MAKEINTRESOURCE(nIdSubTitle);
		// ppsp->pszbmHeader = MAKEINTRESOURCE(IDB_ACCMARK);
	}
	else
		ppsp->dwFlags |= PSP_HIDEHEADER;
	
	
	//
	// Callback is a base class function.  The derived page
	// classes need to implement OnPropSheetPageCreate() and
	// OnPropSheetPageRelease() if they want to handle this callback.
	// By WizardPage::OnPropSheetPageCreate() returns 1.
	//
	ppsp->pfnCallback = WizardPage::PropSheetPageCallback;
	ppsp->dwFlags	 |= (PSP_USECALLBACK /*| PSP_USEREFPARENT*/); // JMC: TODO: Do we want PSP_USEREFPARENT
	
	//
	// Store "this" in the page struct so we can call member functions
	// from the page's message proc.
	//
	_ASSERTE(NULL != this);
	ppsp->lParam = (LPARAM)this;
	
	//
	// All dialog messages first go through the base class' message proc.
	// Virtual functions are called for some messages.	If not processed
	// using a message-specific virtual function, the message is passed
	// to the derived class instance through the virtual funcion HandleMsg.
	//
	ppsp->pfnDlgProc = WizardPage::DlgProc;
}


WizardPage::~WizardPage(
						VOID
						)
{
}


UINT
WizardPage::PropSheetPageCallback(
								  HWND hwnd,
								  UINT uMsg,
								  LPPROPSHEETPAGE ppsp
								  )
{
	UINT uResult = 0;
	WizardPage *pThis = (WizardPage *)ppsp->lParam;
	_ASSERTE(NULL != pThis);
	
	switch(uMsg)
	{
	case PSPCB_CREATE:
		uResult = pThis->OnPropSheetPageCreate(hwnd, ppsp);
		break;
		
	case PSPCB_RELEASE:
		uResult = pThis->OnPropSheetPageRelease(hwnd, ppsp);
		//
		// IMPORTANT:
		// This is where we delete each property sheet page.
		// HERE and ONLY HERE.
		//
		//			  delete pThis; // We won't do this since we'll keep our own list
		// The reason it won't work is because if you never get to a page, you
		// will never get this message
		break;
	}
	return uResult;
}



//
// This is a static method.
//
INT_PTR
WizardPage::DlgProc(
					HWND hwnd,
					UINT uMsg,
					WPARAM wParam,
					LPARAM lParam
					)
{
	INT_PTR bResult		= FALSE;
	PROPSHEETPAGE *ppsp = NULL;
	
	if (WM_INITDIALOG == uMsg)
		ppsp = (PROPSHEETPAGE *)lParam;
	else
		ppsp = (PROPSHEETPAGE *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
	
	if (NULL != ppsp)
	{
		WizardPage *pThis = (WizardPage *)ppsp->lParam;
		_ASSERTE(NULL != pThis);
		
		switch(uMsg)
		{
		case WM_INITDIALOG:
			{
				// The following will set fonts for 'known' controls,
				DialogFonts_InitWizardPage(hwnd);
				
				//
				// Store address of PROPSHEETPAGE struct for this page
				// in window's user data.
				//
				SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
				pThis->m_hwnd = hwnd;
				bResult = pThis->OnInitDialog(hwnd, wParam, lParam);
			}
			break;
			
		case WM_NOTIFY:
			bResult = pThis->OnNotify(hwnd, wParam, lParam);
			break;
			
		case PSM_QUERYSIBLINGS:
			bResult = pThis->OnPSM_QuerySiblings(hwnd, wParam, lParam);
			break;
			
		case WM_COMMAND:
			bResult = pThis->OnCommand(hwnd, wParam, lParam);
			break;

		case WM_TIMER:
			bResult = pThis->OnTimer(hwnd, wParam, lParam);
			break;

		case WM_DRAWITEM:
			bResult = pThis->OnDrawItem(hwnd, wParam, lParam);
			break;

		default:
			//
			// Let derived class instance handle any other messages
			// as needed.
			//
			bResult = pThis->HandleMsg(hwnd, uMsg, wParam, lParam);
			break;
		}
	}
	
	return bResult;
}


LRESULT
WizardPage::OnNotify(
					 HWND hwnd,
					 WPARAM wParam,
					 LPARAM lParam
					 )
{
	INT idCtl		= (INT)wParam;
	LPNMHDR pnmh	= (LPNMHDR)lParam;	
	LRESULT lResult = 0;
	
	switch(pnmh->code)
	{
	case PSN_APPLY:
		lResult = OnPSN_Apply(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_HELP:
		lResult = OnPSN_Help(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_KILLACTIVE:
		lResult = OnPSN_KillActive(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_QUERYCANCEL:
		lResult = OnPSN_QueryCancel(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_RESET:
		lResult = OnPSN_Reset(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_SETACTIVE:
		lResult = OnPSN_SetActive(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_WIZBACK:
		lResult = OnPSN_WizBack(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_WIZNEXT:
		lResult = OnPSN_WizNext(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_WIZFINISH:
		lResult = OnPSN_WizFinish(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case NM_CLICK:
	case NM_RETURN:
		OnMsgNotify(hwnd, idCtl, (LPNMHDR) pnmh);
		break;
	default:
		break;
	}
	return lResult;
}


LRESULT
WizardPage::OnPSN_SetActive(
							HWND hwnd,
							INT idCtl,
							LPPSHNOTIFY pnmh
							)
{
	// JMC: TODO: Maybe put this in the OnNotify Code so the overrided class does
	// not have to call this

	//
	// By default, each wizard page has a BACK and NEXT button.
	//
	DWORD dwFlags = 0;
	if(sm_WizPageOrder.GetPrevPage(m_dwPageId))
		dwFlags |= PSWIZB_BACK;
	
	if(sm_WizPageOrder.GetNextPage(m_dwPageId))
		dwFlags |= PSWIZB_NEXT;
	else
		dwFlags |= PSWIZB_FINISH;
	
	PropSheet_SetWizButtons(GetParent(hwnd), dwFlags);
	
	// Tell the wizard that it's ok to go to this page
	SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
	return TRUE;
}


LRESULT
WizardPage::OnPSM_QuerySiblings(
								HWND hwnd,
								WPARAM wParam,
								LPARAM lParam
								)
{
	return 0;
}

LRESULT
WizardPage::OnPSN_QueryCancel(
							   HWND hwnd,
							   INT idCtl,
							   LPPSHNOTIFY pnmh
							   )
{
	//If nothing has changed just exit...
	if ( memcmp( &g_Options.m_schemePreview, &g_Options.m_schemeOriginal, sizeof(WIZSCHEME)) == 0)
	{
		SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
		return TRUE;
	}
	// if ( 
	switch(StringTableMessageBox(hwnd, IDS_WIZSAVECHANGESMESSAGETEXT, IDS_WIZSAVECHANGESMESSAGETITLE, MB_YESNO))
	{
	case IDYES:
		SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
		break;
	case IDNO:
    {
		// Restore all settings to the original settings
		g_Options.ApplyOriginal();

#if NEED_MSG_PUMP
        if (SetTimer(hwnd, 1, 4000, NULL))
        {
             // Wait for messages to be processed

            BOOL fKeepChecking = TRUE;
            while (fKeepChecking)
            {
                MSG msg;
                while (PeekMessage(&msg, hwnd, WM_TIMER, WM_TIMER, PM_REMOVE))
                {
                    if (msg.message == WM_TIMER)
                    {
                        KillTimer(hwnd, 1);
                        fKeepChecking = FALSE;
                        break;
                    }
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            } 
        }
#endif

		SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
    }
		break;
	case IDCANCEL:
		SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 1);
		break;

	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\lookdlg.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
/*  LOOKDLG.C
**
**
**
**  History:
**
*/
#include "pch.hxx" // PCH
#pragma hdrstop

#include "AccWiz.h"

#include "desk.h"
#include "deskid.h"
#include "look.h"
#include <commdlg.h>
#include <commctrl.h>
#include <regstr.h>
#include "help.h"



#define RGB_PALETTE 0x02000000

void FAR SetMagicColors(HDC, DWORD, WORD);

#define CENTRIES_3D 3

HPALETTE g_hpal3D = NULL;               // only exist if palette device
HPALETTE g_hpalVGA = NULL;              // only exist if palette device
BOOL g_bPalette = FALSE;                // is this a palette device?
int cyBorder;
int cxBorder;
int cxEdge;
int cyEdge;

HWND g_hwndTooltip;

LOOK_FONT g_fonts[NUM_FONTS];
HBRUSH g_brushes[NT40_COLOR_MAX];

BOOL g_bInit = TRUE;

BOOL g_fProprtySheetExiting = FALSE;

#define METRIC_CHANGE 0x0001
#define COLOR_CHANGE  0x0002
#define SCHEME_CHANGE 0x8000
UINT g_fChanged;

LOOK_SIZE g_sizes[NUM_SIZES] = {
/* SIZE_FRAME */        {0, 0, 50},
/* SIZE_SCROLL */       {0, 8, 100},
/* SIZE_CAPTION */      {0, 8, 100},
/* SIZE_SMCAPTION */    {0, 4, 100},
/* SIZE_MENU */         {0, 8, 100},
/* SIZE_DXICON */       {0, 0, 150},    // x spacing
/* SIZE_DYICON */       {0, 0, 150},    // y spacing
/* SIZE_ICON */         {0, 16, 72},    // shell icon size
/* SIZE_SMICON */       {0, 8, 36},     // shell small icon size
};

LOOK_SIZE g_elCurSize;

#define COLORFLAG_SOLID 0x0001

UINT g_colorFlags[NT40_COLOR_MAX] = {
/* COLOR_SCROLLBAR           */ 0,
/* COLOR_DESKTOP             */ 0,
/* COLOR_ACTIVECAPTION       */ COLORFLAG_SOLID,
/* COLOR_INACTIVECAPTION     */ COLORFLAG_SOLID,
/* COLOR_MENU                */ COLORFLAG_SOLID,
/* COLOR_WINDOW              */ COLORFLAG_SOLID,
/* COLOR_WINDOWFRAME         */ COLORFLAG_SOLID,
/* COLOR_MENUTEXT            */ COLORFLAG_SOLID,
/* COLOR_WINDOWTEXT          */ COLORFLAG_SOLID,
/* COLOR_CAPTIONTEXT         */ COLORFLAG_SOLID,
/* COLOR_ACTIVEBORDER        */ 0,
/* COLOR_INACTIVEBORDER      */ 0,
/* COLOR_APPWORKSPACE        */ 0,
/* COLOR_HIGHLIGHT           */ COLORFLAG_SOLID,
/* COLOR_HIGHLIGHTTEXT       */ COLORFLAG_SOLID,
/* COLOR_3DFACE              */ COLORFLAG_SOLID,
/* COLOR_3DSHADOW            */ COLORFLAG_SOLID,
/* COLOR_GRAYTEXT            */ COLORFLAG_SOLID,
/* COLOR_BTNTEXT             */ COLORFLAG_SOLID,
/* COLOR_INACTIVECAPTIONTEXT */ COLORFLAG_SOLID,
/* COLOR_3DHILIGHT           */ COLORFLAG_SOLID,
/* COLOR_3DDKSHADOW          */ COLORFLAG_SOLID,
/* COLOR_3DLIGHT             */ COLORFLAG_SOLID,
/* COLOR_INFOTEXT            */ COLORFLAG_SOLID,
/* COLOR_INFOBK              */ 0,
/* COLOR_3DALTFACE           */ COLORFLAG_SOLID,
/* COLOR_HOTLIGHT            */ COLORFLAG_SOLID,
/* COLOR_GRADIENTACTIVECAPTION */ COLORFLAG_SOLID,
/* COLOR_GRADIENTINACTIVECAPTION */ COLORFLAG_SOLID
#if(WINVER >= 0x0501)
/* COLOR_MENUHILIGHT         */, COLORFLAG_SOLID,
/* COLOR_MENUBAR             */  COLORFLAG_SOLID
#endif /* WINVER >= 0x0501 */
};

// strings for color names.
PTSTR s_pszColorNames[NT40_COLOR_MAX] = {
/* COLOR_SCROLLBAR           */ TEXT("Scrollbar"),
/* COLOR_DESKTOP             */ TEXT("Background"),
/* COLOR_ACTIVECAPTION       */ TEXT("ActiveTitle"),
/* COLOR_INACTIVECAPTION     */ TEXT("InactiveTitle"),
/* COLOR_MENU                */ TEXT("Menu"),
/* COLOR_WINDOW              */ TEXT("Window"),
/* COLOR_WINDOWFRAME         */ TEXT("WindowFrame"),
/* COLOR_MENUTEXT            */ TEXT("MenuText"),
/* COLOR_WINDOWTEXT          */ TEXT("WindowText"),
/* COLOR_CAPTIONTEXT         */ TEXT("TitleText"),
/* COLOR_ACTIVEBORDER        */ TEXT("ActiveBorder"),
/* COLOR_INACTIVEBORDER      */ TEXT("InactiveBorder"),
/* COLOR_APPWORKSPACE        */ TEXT("AppWorkspace"),
/* COLOR_HIGHLIGHT           */ TEXT("Hilight"),
/* COLOR_HIGHLIGHTTEXT       */ TEXT("HilightText"),
/* COLOR_3DFACE              */ TEXT("ButtonFace"),
/* COLOR_3DSHADOW            */ TEXT("ButtonShadow"),
/* COLOR_GRAYTEXT            */ TEXT("GrayText"),
/* COLOR_BTNTEXT             */ TEXT("ButtonText"),
/* COLOR_INACTIVECAPTIONTEXT */ TEXT("InactiveTitleText"),
/* COLOR_3DHILIGHT           */ TEXT("ButtonHilight"),
/* COLOR_3DDKSHADOW          */ TEXT("ButtonDkShadow"),
/* COLOR_3DLIGHT             */ TEXT("ButtonLight"),
/* COLOR_INFOTEXT            */ TEXT("InfoText"),
/* COLOR_INFOBK              */ TEXT("InfoWindow"),
/* COLOR_3DALTFACE           */ TEXT("ButtonAlternateFace"),
/* COLOR_HOTLIGHT            */ TEXT("HotTracking"),
/* COLOR_GRADIENTACTIVECAPTION */ TEXT("GradientActiveTitle"),
/* COLOR_GRADIENTINACTIVECAPTION */ TEXT("GradientInactiveTitle")
#if(WINVER >= 0x0501)
/* COLOR_MENUHILIGHT         */ ,TEXT("MenuHighlighted"),
/* COLOR_MENUBAR             */  TEXT("MenuBar")
#endif /* WINVER >= 0x0501 */
};
TCHAR g_szColors[] = TEXT("colors");           // colors section name

// Location of the Colors subkey in Registry; Defined in RegStr.h
TCHAR szRegStr_Colors[] = REGSTR_PATH_COLORS;

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//this order has to match the enum order in look.h
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
LOOK_ELEMENT g_elements[] = {
/* ELEMENT_APPSPACE        */   {COLOR_APPWORKSPACE,    SIZE_NONE,      FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_APPSPACE, -1,       {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_DESKTOP         */   {COLOR_BACKGROUND,      SIZE_NONE,      FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_DESKTOP, -1,        {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_INACTIVEBORDER  */   {COLOR_INACTIVEBORDER,  SIZE_FRAME,     FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_INACTIVEBORDER, -1, {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_ACTIVEBORDER    */   {COLOR_ACTIVEBORDER,    SIZE_FRAME,     FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_ACTIVEBORDER, -1,   {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_INACTIVECAPTION */   {COLOR_INACTIVECAPTION, SIZE_CAPTION,   TRUE,    COLOR_INACTIVECAPTIONTEXT,FONT_CAPTION,ELNAME_INACTIVECAPTION, -1,{-1,-1,-1,-1}, COLOR_GRADIENTINACTIVECAPTION},
/* ELEMENT_INACTIVESYSBUT1 */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_ACTIVESYSBUT1, {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_INACTIVESYSBUT2 */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_ACTIVESYSBUT1, {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_ACTIVECAPTION   */   {COLOR_ACTIVECAPTION,   SIZE_CAPTION,   TRUE,    COLOR_CAPTIONTEXT,      FONT_CAPTION,  ELNAME_ACTIVECAPTION, -1,  {-1,-1,-1,-1}, COLOR_GRADIENTACTIVECAPTION},
/* ELEMENT_ACTIVESYSBUT1   */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_CAPTIONBUTTON, -1,  {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_ACTIVESYSBUT2   */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_ACTIVESYSBUT1, {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_MENUNORMAL      */   {COLOR_MENU,            SIZE_MENU,      TRUE,    COLOR_MENUTEXT,         FONT_MENU,     ELNAME_MENU, -1,           {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_MENUSELECTED    */   {COLOR_HIGHLIGHT,       SIZE_MENU,      TRUE,    COLOR_HIGHLIGHTTEXT,    FONT_MENU,     ELNAME_MENUSELECTED, -1,   {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_MENUDISABLED    */   {COLOR_MENU,            SIZE_MENU,      TRUE,    COLOR_NONE,             FONT_MENU,     -1, ELEMENT_MENUNORMAL,    {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_WINDOW          */   {COLOR_WINDOW,          SIZE_NONE,      FALSE,   COLOR_WINDOWTEXT,       FONT_NONE,     ELNAME_WINDOW, -1,         {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_MSGBOX          */   {COLOR_NONE,            SIZE_NONE,      TRUE,    COLOR_WINDOWTEXT,       FONT_MSGBOX,   ELNAME_MSGBOX, -1,         {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_MSGBOXCAPTION   */   {COLOR_ACTIVECAPTION,   SIZE_CAPTION,   TRUE,    COLOR_CAPTIONTEXT,      FONT_CAPTION,  -1, ELEMENT_ACTIVECAPTION, {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_MSGBOXSYSBUT    */   {COLOR_3DFACE,          SIZE_CAPTION,   TRUE,    COLOR_BTNTEXT,          FONT_CAPTION,  -1, ELEMENT_ACTIVESYSBUT1, {-1,-1,-1,-1}, COLOR_NONE},
// do not even try to set a scrollbar color the system will ignore you
/* ELEMENT_SCROLLBAR       */   {COLOR_NONE,            SIZE_SCROLL,    FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_SCROLLBAR, -1,      {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_SCROLLUP        */   {COLOR_NONE,            SIZE_SCROLL,    FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_SCROLLBAR,     {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_SCROLLDOWN      */   {COLOR_NONE,            SIZE_SCROLL,    FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_SCROLLBAR,     {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_BUTTON          */   {COLOR_3DFACE,          SIZE_NONE,      FALSE,   COLOR_BTNTEXT,          FONT_NONE,     ELNAME_BUTTON, -1,         {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_SMCAPTION       */   {COLOR_NONE,            SIZE_SMCAPTION, TRUE,    COLOR_NONE,             FONT_SMCAPTION,ELNAME_SMALLCAPTION, -1,   {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_ICON            */   {COLOR_NONE,            SIZE_ICON,      FALSE,   COLOR_NONE,             FONT_ICONTITLE,ELNAME_ICON, -1,           {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_ICONHORZSPACING */   {COLOR_NONE,            SIZE_DXICON,    FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_DXICON, -1,         {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_ICONVERTSPACING */   {COLOR_NONE,            SIZE_DYICON,    FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_DYICON, -1,         {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_INFO            */   {COLOR_INFOBK,          SIZE_NONE,      TRUE,    COLOR_INFOTEXT,         FONT_STATUS,   ELNAME_INFO, -1,           {-1,-1,-1,-1}, COLOR_NONE},
};

// used by ChooseColor dialog
COLORREF g_CustomColors[16];

// structure used to store a scheme in the registry
#ifdef UNICODE
#   define SCHEME_VERSION 2        // Ver 2 == Unicode
#else
#   define SCHEME_VERSION 1        // Ver 1 == Win95 ANSI
#endif

/*
 * Note -- this must match the High Contrast accessibility code
 *  in windows\gina\winlogon.
 */

typedef struct {
    SHORT version;
    WORD  wDummy;               // for alignment
    NONCLIENTMETRICS ncm;
    LOGFONT lfIconTitle;
    COLORREF rgb[NT40_COLOR_MAX];
} SCHEMEDATA;


HWND g_hDlg = NULL;             // nonzero if page is up
int g_iCurElement = -2;         // start off as not even "not set"
int g_LogDPI = 96;              // logical resolution of display
#define ELCUR           (g_elements[g_iCurElement])
#define ELCURFONT       (g_fonts[ELCUR.iFont])
// this one kept separately for range purposes
#define ELCURSIZE       g_elCurSize
int g_iPrevSize = SIZE_NONE;

#define MAXSCHEMENAME 100
TCHAR g_szCurScheme[MAXSCHEMENAME];      // current scheme name
TCHAR g_szLastScheme[MAXSCHEMENAME];     // last scheme they had

HBRUSH g_hbrMainColor = NULL;
HBRUSH g_hbrTextColor = NULL;
HBRUSH g_hbrGradColor = NULL;

const TCHAR c_szRegPathUserMetrics[] = TEXT("Control Panel\\Desktop\\WindowMetrics");
const TCHAR c_szRegValIconSize[] = TEXT("Shell Icon Size");
const TCHAR c_szRegValSmallIconSize[] = TEXT("Shell Small Icon Size");

void NEAR PASCAL Look_Repaint(HWND hDlg, BOOL bRecalc);
BOOL NEAR PASCAL Look_ChangeColor(HWND hDlg, int iColor, COLORREF rgb);
BOOL CALLBACK SaveSchemeDlgProc(HWND, UINT, WPARAM, LPARAM);
void NEAR PASCAL Look_UpdateSizeBasedOnFont(HWND hDlg, BOOL fComputeIdeal);
void NEAR PASCAL Look_SetCurSizeAndRange(HWND hDlg);
void NEAR PASCAL Look_SyncSize(HWND hDlg);
void NEAR PASCAL Look_DoSizeStuff(HWND hDlg, BOOL fCanComputeIdeal);


COLORREF GetNearestPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    PALETTEENTRY pe;
    GetPaletteEntries(hpal, GetNearestPaletteIndex(hpal, rgb & 0x00FFFFFF), 1, &pe);
    return RGB(pe.peRed, pe.peGreen, pe.peBlue);
}

BOOL IsPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    return GetNearestPaletteColor(hpal, rgb) == (rgb & 0xFFFFFF);
}

COLORREF NearestColor(int iColor, COLORREF rgb)
{
    rgb &= 0x00FFFFFF;

    //
    // if we are on a palette device, we need to do special stuff...
    //
    if (g_bPalette)
    {
        if (g_colorFlags[iColor] & COLORFLAG_SOLID)
        {
            if (IsPaletteColor(g_hpal3D, rgb))
                rgb |= RGB_PALETTE;
            else
                rgb = GetNearestPaletteColor(g_hpalVGA, rgb);
        }
        else
        {
            if (IsPaletteColor(g_hpal3D, rgb))
                rgb |= RGB_PALETTE;

            else if (IsPaletteColor((HPALETTE)GetStockObject(DEFAULT_PALETTE), rgb))
                rgb ^= 0x000001;    // force a dither
        }
    }
    else
    {
        // map color to nearest color if we need to for this UI element.
        if (g_colorFlags[iColor] & COLORFLAG_SOLID)
        {
            HDC hdc = GetDC(NULL);
            rgb = GetNearestColor(hdc, rgb);
            ReleaseDC(NULL, hdc);
        }
    }

    return rgb;
}



void NEAR PASCAL Set3DPaletteColor(COLORREF rgb, int iColor)
{
    int iPalette;
    PALETTEENTRY pe;

    if (!g_hpal3D)
        return;

    switch (iColor)
    {
        case COLOR_3DFACE:
            iPalette = 16;
            break;
        case COLOR_3DSHADOW:
            iPalette = 17;
            break;
        case COLOR_3DHILIGHT:
            iPalette = 18;
            break;
        default:
            return;
    }

    pe.peRed    = GetRValue(rgb);
    pe.peGreen  = GetGValue(rgb);
    pe.peBlue   = GetBValue(rgb);
    pe.peFlags  = 0;
    SetPaletteEntries(g_hpal3D, iPalette, 1, (LPPALETTEENTRY)&pe);
}


void NEAR PASCAL Look_RebuildSysStuff(BOOL fInit)
{
    int i;
    PALETTEENTRY pal[4];
    HPALETTE hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    SelectObject(g_hdcMem, GetStockObject(BLACK_BRUSH));
    SelectObject(g_hdcMem, GetStockObject(SYSTEM_FONT));

    for (i = 0; i < NUM_FONTS; i++)
    {
        if (g_fonts[i].hfont)
            DeleteObject(g_fonts[i].hfont);
        g_fonts[i].hfont = CreateFontIndirect(&g_fonts[i].lf);
    }

    if (fInit)
    {
        // get current magic colors
        GetPaletteEntries(hpal, 8,  4, pal);
        SetPaletteEntries(g_hpal3D, 16,  4, pal);

        // set up magic colors in the 3d palette
        if (!IsPaletteColor(hpal, g_Options.m_schemePreview.m_rgb[COLOR_3DFACE]))
        {
            Set3DPaletteColor(g_Options.m_schemePreview.m_rgb[COLOR_3DFACE], COLOR_3DFACE);
            Set3DPaletteColor(g_Options.m_schemePreview.m_rgb[COLOR_3DSHADOW], COLOR_3DSHADOW);
            Set3DPaletteColor(g_Options.m_schemePreview.m_rgb[COLOR_3DHILIGHT], COLOR_3DHILIGHT);
        }
    }

    for (i = 0; i < NT40_COLOR_MAX; i++)
    {
        if (g_brushes[i])
            DeleteObject(g_brushes[i]);

        g_brushes[i] = CreateSolidBrush(NearestColor(i, g_Options.m_schemePreview.m_rgb[i]));
    }
}

#ifndef LF32toLF

void NEAR LF32toLF(LPLOGFONT_32 lplf32, LPLOGFONT lplf)
{
    lplf->lfHeight       = (int) lplf32->lfHeight;
    lplf->lfWidth        = (int) lplf32->lfWidth;
    lplf->lfEscapement   = (int) lplf32->lfEscapement;
    lplf->lfOrientation  = (int) lplf32->lfOrientation;
    lplf->lfWeight       = (int) lplf32->lfWeight;
    *((LPCOMMONFONT) &lplf->lfItalic) = lplf32->lfCommon;
}
#endif


void NEAR SetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm)
{
    g_sizes[SIZE_FRAME].CurSize = (int)lpncm->iBorderWidth;
    g_sizes[SIZE_SCROLL].CurSize = (int)lpncm->iScrollWidth;
    g_sizes[SIZE_CAPTION].CurSize = (int)lpncm->iCaptionHeight;
    g_sizes[SIZE_SMCAPTION].CurSize = (int)lpncm->iSmCaptionHeight;
    g_sizes[SIZE_MENU].CurSize = (int)lpncm->iMenuHeight;

    LF32toLF(&(lpncm->lfCaptionFont), &(g_fonts[FONT_CAPTION].lf));
    LF32toLF(&(lpncm->lfSmCaptionFont), &(g_fonts[FONT_SMCAPTION].lf));
    LF32toLF(&(lpncm->lfMenuFont), &(g_fonts[FONT_MENU].lf));
    LF32toLF(&(lpncm->lfStatusFont), &(g_fonts[FONT_STATUS].lf));
    LF32toLF(&(lpncm->lfMessageFont), &(g_fonts[FONT_MSGBOX].lf));
}

/*
** Fill in a NONCLIENTMETRICS structure with latest preview stuff
*/
void NEAR GetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm)
{
    lpncm->iBorderWidth = (LONG)g_sizes[SIZE_FRAME].CurSize;
    lpncm->iScrollWidth = lpncm->iScrollHeight = (LONG)g_sizes[SIZE_SCROLL].CurSize;
    lpncm->iCaptionWidth = lpncm->iCaptionHeight = (LONG)g_sizes[SIZE_CAPTION].CurSize;
    lpncm->iSmCaptionWidth = lpncm->iSmCaptionHeight = (LONG)g_sizes[SIZE_SMCAPTION].CurSize;
    lpncm->iMenuWidth = lpncm->iMenuHeight = (LONG)g_sizes[SIZE_MENU].CurSize;
    LFtoLF32(&(g_fonts[FONT_CAPTION].lf), &(lpncm->lfCaptionFont));
    LFtoLF32(&(g_fonts[FONT_SMCAPTION].lf), &(lpncm->lfSmCaptionFont));
    LFtoLF32(&(g_fonts[FONT_MENU].lf), &(lpncm->lfMenuFont));
    LFtoLF32(&(g_fonts[FONT_STATUS].lf), &(lpncm->lfStatusFont));
    LFtoLF32(&(g_fonts[FONT_MSGBOX].lf), &(lpncm->lfMessageFont));
}




/*
** clean up any mess made in maintaining system information
** also, write out any global changes in our setup.
*/
void NEAR PASCAL Look_DestroySysStuff(void)
{
    int i;
    HKEY hkAppear;

    SelectObject(g_hdcMem, GetStockObject(BLACK_BRUSH));
    SelectObject(g_hdcMem, GetStockObject(SYSTEM_FONT));

    for (i = 0; i < NUM_FONTS; i++)
    {
        if (g_fonts[i].hfont)
            DeleteObject(g_fonts[i].hfont);
    }
    for (i = 0; i < NT40_COLOR_MAX; i++)
    {
        if (g_brushes[i])
            DeleteObject(g_brushes[i]);
    }

    if (g_hpal3D)
        DeleteObject(g_hpal3D);

    if (g_hpalVGA)
        DeleteObject(g_hpalVGA);

    // save out possible changes to custom color table
    if (RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_APPEARANCE, &hkAppear) == ERROR_SUCCESS)
    {
        RegSetValueEx(hkAppear, REGSTR_VAL_CUSTOMCOLORS, 0L, REG_BINARY,
                                (LPBYTE)g_CustomColors, sizeof(g_CustomColors));
    }
}

//------------------------ mini font picker controls --------------------------
/*
** initialize the constant dialog components
**
** initialize the list of element names.  this stays constant with the
** possible exception that some items might be added/removed depending
** on some special case conditions.
*/

void NEAR PASCAL Look_DestroyDialog(HWND hDlg)
{
    HFONT hfont, hfontOther;

    hfontOther = (HFONT)SendDlgItemMessage(hDlg, IDC_MAINSIZE, WM_GETFONT, 0, 0L);
    hfont = (HFONT)SendDlgItemMessage(hDlg, IDC_FONTBOLD, WM_GETFONT, 0, 0L);
    if (hfont && (hfont != hfontOther))
        DeleteObject(hfont);
    hfont = (HFONT)SendDlgItemMessage(hDlg, IDC_FONTITAL, WM_GETFONT, 0, 0L);
    if (hfont && (hfont != hfontOther))
        DeleteObject(hfont);

    DestroyWindow(g_hwndTooltip);
}


#define LSE_SETCUR 0x0001
#define LSE_ALWAYS 0x0002

const static DWORD FAR aAppearanceHelpIds[] = {
        IDC_SCHEMES,        IDH_APPEAR_SCHEME,
        IDC_SAVESCHEME,     IDH_APPEAR_SAVEAS,
        IDC_DELSCHEME,      IDH_APPEAR_DELETE,
        IDC_ELEMENTS,       IDH_APPEAR_ITEM,
        IDC_MAINCOLOR,      IDH_APPEAR_BACKGRNDCOLOR,
        IDC_SIZELABEL,      IDH_APPEAR_ITEMSIZE,
        IDC_MAINSIZE,       IDH_APPEAR_ITEMSIZE,
        IDC_SIZEARROWS,     IDH_APPEAR_ITEMSIZE,
        IDC_FONTLABEL,      IDH_APPEAR_FONT,
        IDC_FONTNAME,       IDH_APPEAR_FONT,
        IDC_FONTSIZE,       IDH_APPEAR_FONTSIZE,
        IDC_FONTBOLD,       IDH_APPEAR_FONTBOLD,
        IDC_FONTITAL,       IDH_APPEAR_FONTITALIC,
        IDC_LOOKPREV,       IDH_APPEAR_GRAPHIC,
        IDC_FONTSIZELABEL,  IDH_APPEAR_FONTSIZE,
        IDC_COLORLABEL,     IDH_APPEAR_BACKGRNDCOLOR,
        IDC_TEXTCOLOR,      IDH_APPEAR_FONTCOLOR,
        IDC_FNCOLORLABEL,   IDH_APPEAR_FONTCOLOR,

        0, 0
};


LONG WINAPI MyStrToLong(LPCTSTR sz)
{
    long l=0;

    while (*sz >= TEXT('0') && *sz <= TEXT('9'))
        l = l*10 + (*sz++ - TEXT('0'));

    return l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgbase.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef __WIZARD_PAGE_BASECLASS_H
#define __WIZARD_PAGE_BASECLASS_H

//
// Special "Wizard Page Messages"
//

#include "AccWiz.h" // JMC: TODO: Maybe move this somewhere else

class CWizardPageOrder
{
public:
	CWizardPageOrder()
	{
		m_nCount = 0;
		for(int i=0;i<ARRAYSIZE(m_rgdwPageIds);i++)
			m_rgdwPageIds[i] = 0;
	}


	BOOL AddPages(DWORD nInsertAfter, DWORD *rgdwIds, int nCount)
	{
		// First remove the pages if they are already there
		RemovePages(rgdwIds, nCount);

		int nStart = m_nCount - 1; // This will add to the end of the array
		if(0xFFFFFFFF != nInsertAfter)
		{
			for(nStart = 0;nStart < m_nCount;nStart++)
				if(m_rgdwPageIds[nStart] == nInsertAfter) break;
			if(nStart >= m_nCount)
			{
				_ASSERTE(FALSE); // The specified insert after was not in the array
				return FALSE;
			}
		}
		
		// Check to see if we have enough space.
		if(nCount + m_nCount > ARRAYSIZE(m_rgdwPageIds))
		{
			_ASSERTE(FALSE); // We don't have space
			return FALSE;
		}

		// Move current allocation upwards
		for(int i=m_nCount-1;i>nStart;i--)
			m_rgdwPageIds[i + nCount] = m_rgdwPageIds[i];

		// Insert new values
		for(i = 0;i<nCount;i++)
			m_rgdwPageIds[nStart + i + 1] = rgdwIds[i];

		// Set new value for m_nCount
		m_nCount += nCount;

		return TRUE;
	}

	BOOL RemovePages(DWORD *rgdwIds, int nCount)
	{
		// NOTE: This will scan the array and find the max and min locations
		// of all the elements in rgdwIds.  It then removes everything from min to max.
		// This is needed in case a sub page added more sub pages.
		int nMin = m_nCount + 1;
		int nMax = 0;
		for(int i=0;i<m_nCount;i++)
		{
			for(int j=0;j<nCount;j++)
			{
				if(m_rgdwPageIds[i] == rgdwIds[j])
				{
					nMin = min(i, nMin);
					nMax = max(i, nMax);
				}
			}
		}
		if(nMax < nMin)
		{
//			_ASSERTE(FALSE); // we could not find the range
			return FALSE;
		}

		// Move elements down
		int nCountElementsToRemove = nMax - nMin + 1;
		for(i=0;i<m_nCount - (nMax + 1);i++)
			m_rgdwPageIds[nMin + i] = m_rgdwPageIds[nMin + i + nCountElementsToRemove];

		// Figure out new m_nCount;
		m_nCount -= nCountElementsToRemove;
		return TRUE;
	}

	DWORD GetNextPage(DWORD dwPageId)
	{
		DWORD dwNextPage = 0;
		// Find the specified page
		for(int i=0;i<m_nCount;i++)
			if(m_rgdwPageIds[i] == dwPageId) break;

		if(i>=m_nCount)
		{
			_ASSERTE(FALSE); // We could not find the current page
			return 0;
		}

		// If we are not on the last page, return the 'next' page
		if(i < (m_nCount-1))
			dwNextPage = m_rgdwPageIds[i+1];

		return dwNextPage;
	}
	DWORD GetPrevPage(DWORD dwPageId)
	{
		DWORD dwPrevPage = 0;
		// Find the specified page
		for(int i=0;i<m_nCount;i++)
			if(m_rgdwPageIds[i] == dwPageId) break;

		if(i>=m_nCount)
		{
			_ASSERTE(FALSE); // We could not find the current page
			return 0;
		}

		// If we are not on the first page, return the 'prev' page
		if(i > 0)
			dwPrevPage = m_rgdwPageIds[i - 1];

		return dwPrevPage;
	}

	DWORD GetFirstPage()
	{
		_ASSERTE(m_nCount); // only call if we have values in the class
		return m_rgdwPageIds[0];
	}

	BOOL GrowArray(int nNewMax)
	{
		_ASSERTE(FALSE); // Not yet implemented
		return FALSE;
	}


protected:
	int m_nCount;
	DWORD m_rgdwPageIds[100]; // JMC: NOTE: We hard code a max of 100 pages that this
							// object can support.  100 is reasonable, since wizards
							// cannot currently support more than 100 pages.
};

class WizardPage
{
public:
	WizardPage(LPPROPSHEETPAGE ppsp, int nIdTitle, int nIdSubTitle);
	virtual ~WizardPage(VOID);
	
	//
	// Object is to apply settings to the system so that they take effect.
	//
	virtual LRESULT ApplySettings(VOID)
	{ return 0; }
	//
	// Object reports if user has changed something in the wizard page.
	//
	virtual BOOL Changed(VOID)
	{ return FALSE; }
	//
	// Object is to restore the original settings in effect when the page
	// was first opened.
	// Don't appy these to the system.	Object will receive an
	// ApplySettings notification when this is required.
	//
	virtual VOID RestoreOriginalSettings(VOID)
	{ /* By default, nothing happens */ }
	//
	// Object is to restore the settings most previously applied.
	// Don't appy these to the system.	Object will receive an
	// ApplySettings notification when this is required.
	//
	virtual VOID RestorePreviousSettings(VOID)
	{ /* By default, nothing happens */ }
	
	// This static member contains the order for all wizard pages in the app
	static CWizardPageOrder sm_WizPageOrder;
	
protected:
	HWND m_hwnd;  // Dialog's hwnd.
	DWORD m_dwPageId;
	
	virtual BOOL AdjustWizPageOrder()
	{
		// Default does nothing
		return TRUE;
	}
	
	//
	// Derived classes override these to respond to page create/release
	// notifications.
	//
	virtual UINT OnPropSheetPageCreate(HWND hwnd, LPPROPSHEETPAGE ppsp)
	{ return 1; }
	virtual UINT OnPropSheetPageRelease(HWND hwnd, LPPROPSHEETPAGE ppsp)
	{ return 1; }
	
	//
	// Method for performing operations common to all wizard pages in response
	// to given messages.  This is the function given to the PROPSHEETPAGE struct.
	//
	static INT_PTR DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	
protected:
	//
	// Prevent copying.
	//
	WizardPage(const WizardPage& rhs);
	WizardPage& operator = (const WizardPage& rhs);
	
	static UINT PropSheetPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
	
	virtual LRESULT HandleMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{ return 0; }
	virtual LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{ return 1; }
	//
	// Property sheet notifications.
	//
	virtual LRESULT OnPSN_Apply(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{ return 0; }
	virtual LRESULT OnPSN_Help(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{ return 0; }
	virtual LRESULT OnPSN_KillActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{ return 0; }
	virtual LRESULT OnPSN_QueryCancel(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	virtual LRESULT OnPSN_Reset(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{ return 0; }
	virtual LRESULT OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	virtual LRESULT OnPSN_WizBack(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{
		AdjustWizPageOrder();
		SetWindowLongPtr(hwnd, DWLP_MSGRESULT,
                         sm_WizPageOrder.GetPrevPage(m_dwPageId));
		return TRUE;
	}
	virtual LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{
		AdjustWizPageOrder();
		SetWindowLongPtr(hwnd, DWLP_MSGRESULT,
                         sm_WizPageOrder.GetNextPage(m_dwPageId));
		return TRUE;
	}
	virtual LRESULT OnPSN_WizFinish(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{ return 0; }
	
	
	virtual LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{ return 0; }
	
	virtual LRESULT OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{ return 0; }
	
	virtual LRESULT OnTimer(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{ return 0; }

	virtual BOOL OnMsgNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
	{ return 0; }

	LRESULT OnPSM_QuerySiblings(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnNotify(HWND hwnd, WPARAM wParam, LPARAM lParam);
	
};



#endif // __WIZARD_PAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgcaret.cpp ===
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgcaret.h"
#include "w95trace.c"

#define BLINK           1000
#define BLINK_OFF       -1

#define CURSORMIN       200
#define CURSORMAX       1300
#define CURSORSUM       (CURSORMIN + CURSORMAX)
#define CURSORRANGE     (CURSORMAX - CURSORMIN)

CCaretPg::CCaretPg(	LPPROPSHEETPAGE ppsp ) : WizardPage(ppsp, IDS_CARETTITLE, IDS_CARETSUBTITLE)
{
	m_dwPageId = IDD_CARET;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
    hwndCursorScroll = NULL;
    uNewBlinkTime = uBlinkTime = 0;
    dwOriginalSize = dwNewSize = 0;
    fBlink = TRUE;
}


CCaretPg::~CCaretPg(void)
{
}


LRESULT CCaretPg::OnInitDialog( HWND hwnd, WPARAM wParam,LPARAM lParam )
{
    DBPRINTF(TEXT("OnInitDialog\r\n"));
    BOOL fRv = SystemParametersInfo(SPI_GETCARETWIDTH, 0, (PVOID)&dwOriginalSize, 0);
    dwNewSize = dwOriginalSize;

    uBlinkTime = RegQueryStrDW(
				     DEFAULT_BLINK_RATE
			       , HKEY_CURRENT_USER
			       , CONTROL_PANEL_DESKTOP
			       , CURSOR_BLINK_RATE);

    // Blink rate of -1 means it is off; a special case to CURSORMAX

    if (uBlinkTime == BLINK_OFF)
        uBlinkTime = CURSORMAX;

    uNewBlinkTime = uBlinkTime;

    // Update the Caret UI
    SendMessage(GetDlgItem(hwnd, KCURSOR_WIDTH), TBM_SETRANGE, 0, MAKELONG(1, 20));
    SendMessage(GetDlgItem(hwnd, KCURSOR_WIDTH), TBM_SETPOS, TRUE, (LONG)dwOriginalSize);

    SendMessage(GetDlgItem(hwnd, KCURSOR_RATE), TBM_SETRANGE, 0, MAKELONG(CURSORMIN / 100, CURSORMAX / 100));
    SendMessage(GetDlgItem(hwnd, KCURSOR_RATE), TBM_SETPOS, TRUE, (LONG)(CURSORSUM - uBlinkTime) / 100);

    // Update Blink and caret size
    hwndCaret = GetDlgItem(hwnd, KCURSOR_BLINK);
    GetWindowRect(hwndCaret, &rCursor);
    MapWindowPoints(HWND_DESKTOP, hwnd, (LPPOINT)&rCursor, 2);

    rCursor.right = rCursor.left + dwOriginalSize;

	return 1;
}


void CCaretPg::UpdateControls()
{
	// Nothing to do
}

void CCaretPg::DrawCaret(HWND hwnd, BOOL fClearFirst)
{
    HDC hDC = GetDC(hwnd);
    if (hDC)
    {
        HBRUSH hBrush;
        if (fClearFirst)
        {
            hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
            if (hBrush)
            {
                RECT rect;
                GetWindowRect(hwndCaret, &rect);
                MapWindowPoints(HWND_DESKTOP, hwnd, (LPPOINT)&rect, 2);
                FillRect(hDC, &rect, hBrush);
                InvalidateRect(hwndCaret, &rect, TRUE);
                DeleteObject(hBrush);
            }
        }
        hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNTEXT));
        if (hBrush)
        {
            FillRect(hDC, &rCursor, hBrush);
            InvalidateRect(hwndCaret, &rCursor, TRUE);
            DeleteObject(hBrush);
        }
        ReleaseDC(hwnd,hDC);
    }
}

LRESULT CCaretPg::OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    if (wParam == BLINK)
    {
        BOOL fNoBlinkRate = (uNewBlinkTime == CURSORMAX)?TRUE:FALSE;
        if (fBlink || fNoBlinkRate)
        {
            DrawCaret(hwnd, fNoBlinkRate);
        }
        else
	    {
            InvalidateRect(hwndCaret, NULL, TRUE);
	    }

        if (fNoBlinkRate)
            KillTimer(hwnd, wParam);

        fBlink = !fBlink;
    }
    return 1;
}


LRESULT CCaretPg::OnHScroll( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    if ((HWND)lParam == GetDlgItem(hwnd, KCURSOR_RATE))
    {
        // blink rate setting

        int nCurrent = (int)SendMessage( (HWND)lParam, TBM_GETPOS, 0, 0L );
        uNewBlinkTime = CURSORSUM - (nCurrent * 100);

        // reset the bink rate timer

        SetTimer(hwnd, BLINK, uNewBlinkTime, NULL);

        if (uNewBlinkTime == CURSORMAX) // draw the caret immediately; if we wait
            DrawCaret(hwnd, TRUE);      // for the timer there is a visible delay
    }
    else
    {
        // cursor width setting

        dwNewSize = (int)SendMessage( (HWND)lParam, TBM_GETPOS, 0, 0L );
	    
	    rCursor.right = rCursor.left + dwNewSize;
        DrawCaret(hwnd, (uNewBlinkTime == CURSORMAX));
    }

    return 1;
}

LRESULT CCaretPg::OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
{
    DBPRINTF(TEXT("OnPSN_SetActive:  uNewBlinkTime = %d\r\n"), uNewBlinkTime);
    if (uNewBlinkTime < CURSORMAX)
    {
        // start the blink rate timer to simulate cursor
        SetTimer(hwnd, BLINK, uBlinkTime, NULL);
    }
    else
    {
        // get the timer to draw the caret immediately
        SetTimer(hwnd, BLINK, 0, NULL);
    }
    return 1;
}

LRESULT CCaretPg::OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
{
    g_Options.m_schemePreview.m_uCursorBlinkTime = (uNewBlinkTime < CURSORMAX)?uNewBlinkTime:BLINK_OFF;
	g_Options.m_schemePreview.m_dwCaretWidth = dwNewSize;
    g_Options.ApplyPreview();
	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgfinish.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef __FINISH_WIZARD_PAGE_H
#define __FINISH_WIZARD_PAGE_H

#include "pgbase.h"

class FinishWizPg : public WizardPage
{
public:
	FinishWizPg(LPPROPSHEETPAGE ppsp);
	~FinishWizPg(VOID);
	
private:
	
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	BOOL OnMsgNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
	
};

#endif // __FINISH_WIZARD_PAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pggenric.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgGenric.h"


CGenericWizPg::CGenericWizPg( 
    LPPROPSHEETPAGE ppsp,
	DWORD dwPageId,
	int nIdTitle /* = IDS_GENERICPAGETITLE */,
	int nIdSubTitle /* = IDS_GENERICPAGESUBTITLE */
    ) : WizardPage(ppsp, nIdTitle, nIdSubTitle)
{
	m_dwPageId = dwPageId;
    ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


CGenericWizPg::~CGenericWizPg(
    VOID
    )
{
}



LRESULT
CGenericWizPg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIO2), TRUE);
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgcaret.h ===
#ifndef _INC_PGCARET_H
#define _INC_PGCARET_H

#include "pgbase.h"

class CCaretPg: public WizardPage
{
public:
    CCaretPg(LPPROPSHEETPAGE ppsp);
    ~CCaretPg(VOID);

protected:
	void UpdateControls();

	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam) {return 1;}
    LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
    LRESULT OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	LRESULT OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam );
	LRESULT OnHScroll( HWND hwnd, WPARAM wParam, LPARAM lParam );
	LRESULT HandleMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		LRESULT rv = 0;
		switch(uMsg)
		{
        case WM_HSCROLL:
			rv = OnHScroll(hwnd, wParam, lParam);
			break;

        // sliders don't get this message so pass it on
	    case WM_SYSCOLORCHANGE:
		    SendMessage(GetDlgItem(hwnd, KCURSOR_WIDTH), WM_SYSCOLORCHANGE, 0, 0);
		    SendMessage(GetDlgItem(hwnd, KCURSOR_RATE), WM_SYSCOLORCHANGE, 0, 0);
		    break;

		default:
			break;
		}
		return rv;
	}

private:
    void CCaretPg::DrawCaret(HWND hwnd, BOOL fClearFirst);

    BOOL fBlink;
    UINT uNewBlinkTime, uBlinkTime;
    DWORD dwNewSize, dwOriginalSize;
    HWND hwndCursorScroll;
    RECT rCursor;
    HWND hwndCaret;
};

#endif // _INC_PGCARET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgextras.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGEXTRAS_H
#define _INC_PGEXTRAS_H

#include "pgbase.h"
#include "Select.h"

class CYesNoPg : public WizardPage
{
public:
	CYesNoPg(LPPROPSHEETPAGE ppsp, int nIdTitle, int nIdSubTitle, int nPageId)
		: WizardPage(ppsp, nIdTitle, nIdSubTitle)
	{
		m_dwPageId = nPageId;
		ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	}
protected:
	virtual BOOL IsOptionSet() = 0;
	virtual void SetOptions(BOOL bOn) = 0;
	virtual int GetSettingsPage() {return 0;} // Default is no next page

	
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{
		// Make sure the controls exist
		_ASSERTE(GetDlgItem(m_hwnd, IDC_RADIOYES));
		_ASSERTE(GetDlgItem(m_hwnd, IDC_RADIONO));

		// Set Yes/No buttons
		Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIOYES), IsOptionSet());
		Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIONO), !IsOptionSet());
		return 1;
	}
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{
		LRESULT lResult = 1;
		SetOptions(Button_GetCheck(GetDlgItem(m_hwnd, IDC_RADIOYES)));
		g_Options.ApplyPreview();
		return lResult;
	}
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{
	 	DWORD dwTemp = GetSettingsPage();
		if(dwTemp)
		{
			if(Button_GetCheck(GetDlgItem(m_hwnd, IDC_RADIOYES)))
				sm_WizPageOrder.AddPages(m_dwPageId, &dwTemp, 1);
			else
				sm_WizPageOrder.RemovePages(&dwTemp, 1);
		}
		return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
	}


};

class CSoundSentryPg : public CYesNoPg
{
public:
    CSoundSentryPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_SNDWIZSENTRYTITLE, IDS_SNDWIZSENTRYSUBTITLE, IDD_SNDWIZSENTRYSHOWSOUNDS) {}
protected:
	BOOL IsOptionSet()
	{
		return (g_Options.m_schemePreview.m_SOUNDSENTRY.dwFlags & SSF_SOUNDSENTRYON);
	}
	void SetOptions(BOOL bOn)
	{
		if(bOn)
		{
			g_Options.m_schemePreview.m_SOUNDSENTRY.dwFlags |= SSF_SOUNDSENTRYON;
            g_Options.m_schemePreview.m_SOUNDSENTRY.dwFlags &= SSF_VALID;

			// Hard code to flash 'Window' if we are setting this option
			g_Options.m_schemePreview.m_SOUNDSENTRY.iWindowsEffect = SSWF_WINDOW;

            // For NT: The other options are not supported. a-anilk
			g_Options.m_schemePreview.m_SOUNDSENTRY.iFSTextEffect = 0;
			g_Options.m_schemePreview.m_SOUNDSENTRY.iFSGrafEffect = 0;
		}
		else
			g_Options.m_schemePreview.m_SOUNDSENTRY.dwFlags &= ~SSF_SOUNDSENTRYON;
	}
};

class CShowSoundsPg : public CYesNoPg
{
public:
    CShowSoundsPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_SNDWIZSHOWSOUNDSTITLE, IDS_SNDWIZSHOWSOUNDSSUBTITLE, IDD_SNDWIZSENTRYSHOWSOUNDS2) {}
protected:
	BOOL IsOptionSet()
	{
		return (g_Options.m_schemePreview.m_bShowSounds);
	}
	void SetOptions(BOOL bOn)
	{
		g_Options.m_schemePreview.m_bShowSounds = bOn;
	}
};

class CFilterKeysPg : public CYesNoPg
{
public:
    CFilterKeysPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_WIZFILTERKEYSTITLE, IDS_WIZFILTERKEYSSUBTITLE, IDD_KBDWIZFILTERKEYS1) {}
protected:
	BOOL IsOptionSet()
	{
		// Return TRUE if filterkeys is ON
		return (g_Options.m_schemePreview.m_FILTERKEYS.dwFlags & FKF_FILTERKEYSON);
	}
	void SetOptions(BOOL bOn)
	{
		if(bOn)
		{
			g_Options.m_schemePreview.m_FILTERKEYS.dwFlags |= FKF_FILTERKEYSON;

            // this code only sets iBounceMSec and doesn't let users set the
            // other filter key options so init the other values to zero
			g_Options.m_schemePreview.m_FILTERKEYS.iWaitMSec = 0;
			g_Options.m_schemePreview.m_FILTERKEYS.iDelayMSec = 0;
			g_Options.m_schemePreview.m_FILTERKEYS.iRepeatMSec = 0;
		}
		else
        {
			g_Options.m_schemePreview.m_FILTERKEYS.dwFlags &= ~FKF_FILTERKEYSON;
        }
	}
	int GetSettingsPage() {return IDD_KBDWIZFILTERKEYS2;}

};


/***************************************/

//
// Times are in milliseconds
//
#define BOUNCESIZE 5
UINT BounceTable[BOUNCESIZE] = {
    {  500 },
    {  700 },
    { 1000 },
    { 1500 },
    { 2000 }
};

class CFilterKeysSettingsPg : public WizardPage
{
public:
    CFilterKeysSettingsPg(LPPROPSHEETPAGE ppsp)
		: WizardPage(ppsp, IDS_WIZFILTERKEYSETTING, IDS_WIZFILTERKEYSSUBTITLE)
	{
		m_dwPageId = IDD_KBDWIZFILTERKEYS2;
		ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	}

protected:
	void UpdateTime()
	{
		INT_PTR nBounceRate = SendDlgItemMessage(m_hwnd,IDC_BK_BOUNCERATE, TBM_GETPOS, 0,0);
		if(nBounceRate < 1 || nBounceRate > BOUNCESIZE)
			nBounceRate = 1;

		// Look up in table
		nBounceRate = BounceTable[nBounceRate - 1];

		TCHAR buf[10], buf2[20];
		wsprintf(buf,__TEXT("%d.%d"),nBounceRate/1000,	(nBounceRate%1000)/100);
		GetNumberFormat(LOCALE_USER_DEFAULT, 0, buf, NULL, buf2, 20);
		SetDlgItemText(m_hwnd, IDC_BK_TIME, buf2);
	}
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{
		_ASSERTE(g_Options.m_schemePreview.m_FILTERKEYS.iBounceMSec);
		_ASSERTE(GetDlgItem(m_hwnd, IDC_RADIOBEEPYES));
		_ASSERTE(GetDlgItem(m_hwnd, IDC_RADIOBEEPNO));

		Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIOBEEPYES), (g_Options.m_schemePreview.m_FILTERKEYS.dwFlags & FKF_CLICKON));
		Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIOBEEPNO), !(g_Options.m_schemePreview.m_FILTERKEYS.dwFlags & FKF_CLICKON));

		// Set slider for bounce rate
		SendDlgItemMessage(m_hwnd,IDC_BK_BOUNCERATE, TBM_SETRANGE,
							 TRUE,MAKELONG(1,BOUNCESIZE));

		// Figure out initial settings
		// Make sure initial slider settings is not SMALLER than current setting
		int nIndex = 0;
		for(int i=BOUNCESIZE - 1;i>=0;i--)
		{
			if(BounceTable[i] >= g_Options.m_schemePreview.m_FILTERKEYS.iBounceMSec)
				nIndex = i;
			else
				break;
		}
		SendDlgItemMessage(m_hwnd,IDC_BK_BOUNCERATE, TBM_SETPOS, TRUE, nIndex+1);
		UpdateTime();

		return 1;
	}
	LRESULT HandleMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		switch(uMsg)
		{
		case WM_HSCROLL:
			{
				UpdateTime();

				if(Button_GetCheck(GetDlgItem(m_hwnd, IDC_RADIOBEEPYES)))
					g_Options.m_schemePreview.m_FILTERKEYS.dwFlags |= FKF_CLICKON;
				else
					g_Options.m_schemePreview.m_FILTERKEYS.dwFlags &= ~FKF_CLICKON;

				// Bounce Keys
				INT_PTR nIndex = SendDlgItemMessage(m_hwnd, IDC_BK_BOUNCERATE, TBM_GETPOS, 0, 0);
                // this code only sets iBounceMSec and doesn't let users set the
                // other filter key options so init the other values to zero
				g_Options.m_schemePreview.m_FILTERKEYS.iWaitMSec = 0;
				g_Options.m_schemePreview.m_FILTERKEYS.iDelayMSec = 0;
				g_Options.m_schemePreview.m_FILTERKEYS.iRepeatMSec = 0;
				g_Options.m_schemePreview.m_FILTERKEYS.iBounceMSec = BounceTable[nIndex - 1];

				g_Options.ApplyPreview();
			}
			break;
		default:
			break;
		}
		return 0;
	}

    // Handle Next> and make sure you transfer all settings as the user may not 
    // always change bounce repeat rate : a-anilk
    LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{
		LRESULT lResult = 1;

		WORD wNotifyCode = HIWORD(wParam);
		WORD wCtlID      = LOWORD(wParam);
		HWND hwndCtl     = (HWND)lParam;

		switch(wCtlID)
		{
		case IDC_RADIOBEEPYES:
		case IDC_RADIOBEEPNO:
			if(Button_GetCheck(GetDlgItem(m_hwnd, IDC_RADIOBEEPYES)))
				g_Options.m_schemePreview.m_FILTERKEYS.dwFlags |= FKF_CLICKON;
			else
				g_Options.m_schemePreview.m_FILTERKEYS.dwFlags &= ~FKF_CLICKON;

            g_Options.ApplyPreview();

			lResult = 0;
			break;

		default:
			break;
		}
		return lResult;
	}

};

////////////////////////////////////////////////////////////////////
// Mouse Keys
class CMouseKeysPg : public CYesNoPg
{
public:
    CMouseKeysPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_MSEWIZMOUSEKEYSTITLE, IDS_MSEWIZMOUSEKEYSSUBTITLE, IDD_MSEWIZMOUSEKEYS) {}
protected:
	BOOL IsOptionSet()
	{
		return (g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags & MKF_MOUSEKEYSON);
	}
	void SetOptions(BOOL bOn)
	{
		if(bOn)
			g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags |= MKF_MOUSEKEYSON;
		else
			g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags &= ~MKF_MOUSEKEYSON;
	}
	int GetSettingsPage() {return IDD_MSEWIZMOUSEKEYS1;}

};

static UINT g_nSpeedTable[] = { 10, 20, 30, 40, 60, 80, 120, 180, 360 };
static UINT g_nAccelTable[] = { 5000, 4500, 4000, 3500, 3000, 2500, 2000, 1500, 1000 };

class CMouseKeysSettingsPg : public WizardPage
{
public:
    CMouseKeysSettingsPg(LPPROPSHEETPAGE ppsp)
		: WizardPage(ppsp, IDS_MSEWIZMOUSEKEYSETTING, IDS_MSEWIZMOUSEKEYSSUBTITLE)
	{
		m_dwPageId = IDD_MSEWIZMOUSEKEYS1;
		ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	}

protected:
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{
		// ALWAYS use modifiers
//		Button_SetCheck(GetDlgItem(m_hwnd, IDC_MK_USEMODKEYS), g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags & MKF_MODIFIERS);

		if(g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags & MKF_REPLACENUMBERS)
			Button_SetCheck(GetDlgItem(m_hwnd, IDC_MK_NLON), TRUE);
		else
			Button_SetCheck(GetDlgItem(m_hwnd, IDC_MK_NLOFF), TRUE);

		SendDlgItemMessage(m_hwnd,IDC_MK_TOPSPEED, TBM_SETRANGE, TRUE,MAKELONG(0,8));
		SendDlgItemMessage(m_hwnd,IDC_MK_ACCEL, TBM_SETRANGE, TRUE,MAKELONG(0,8));

		int nIndex = 0;
		for(int i=8;i>=0;i--)
		{
			if(g_nSpeedTable[i] >= g_Options.m_schemePreview.m_MOUSEKEYS.iMaxSpeed)
				nIndex = i;
			else
				break;
		}
		SendDlgItemMessage(m_hwnd,IDC_MK_TOPSPEED, TBM_SETPOS, TRUE, nIndex);

		for(i=8;i>=0;i--)
		{
			if(g_nAccelTable[i] <= g_Options.m_schemePreview.m_MOUSEKEYS.iTimeToMaxSpeed)
				nIndex = i;
			else
				break;
		}
		SendDlgItemMessage(m_hwnd,IDC_MK_ACCEL, TBM_SETPOS, TRUE, nIndex);
		return 1;
	}

	void GetSettingsFromControls()
	{
		INT_PTR nIndex;

		g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags |= MKF_MOUSEKEYSON;
		if(TRUE/*Button_GetCheck(GetDlgItem(m_hwnd, IDC_MK_USEMODKEYS))*/) // NOTE: ALWAYS use modifiers
			g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags |= MKF_MODIFIERS;
		else
			g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags &= ~MKF_MODIFIERS;

		if(Button_GetCheck(GetDlgItem(m_hwnd, IDC_MK_NLON)))
			g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags |= MKF_REPLACENUMBERS;
		else
			g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags &= ~MKF_REPLACENUMBERS;

		nIndex = SendDlgItemMessage(m_hwnd, IDC_MK_TOPSPEED, TBM_GETPOS, 0, 0);
		g_Options.m_schemePreview.m_MOUSEKEYS.iMaxSpeed = g_nSpeedTable[nIndex];
		nIndex = SendDlgItemMessage(m_hwnd, IDC_MK_ACCEL, TBM_GETPOS, 0, 0);
		g_Options.m_schemePreview.m_MOUSEKEYS.iTimeToMaxSpeed = g_nAccelTable[nIndex];

 #pragma message("Handle THis!")
		// 3/15/95 -
		// Always init the control speed to 1/8 of the screen width/
//		g_mk.iCtrlSpeed = GetSystemMetrics(SM_CXSCREEN) / 16;

		g_Options.ApplyPreview();
	}

	LRESULT HandleMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		switch(uMsg)
		{
		case WM_HSCROLL:
			GetSettingsFromControls();
			break;
		default:
			break;
		}
		return 0;
	}

	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{
		LRESULT lResult = 1;

		WORD wNotifyCode = HIWORD(wParam);
		WORD wCtlID      = LOWORD(wParam);
		HWND hwndCtl     = (HWND)lParam;

		switch(wCtlID)
		{
		case IDC_MK_NLON:
		case IDC_MK_NLOFF:
			GetSettingsFromControls();
			lResult = 0;
			break;

		default:
			break;
		}
		return lResult;
	}
};

//
////////////////////////////////////////////////////////////////////


class CStickyKeysPg : public CYesNoPg
{
public:
    CStickyKeysPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_WIZSTICKYKEYSTITLE, IDS_WIZSTICKYKEYSSUBTITLE, IDD_KBDWIZSTICKYKEYS) {}
protected:
	BOOL IsOptionSet()
	{
		return g_Options.m_schemePreview.m_STICKYKEYS.dwFlags & SKF_STICKYKEYSON;
	}
	void SetOptions(BOOL bOn)
	{
		if(bOn)
		{
			g_Options.m_schemePreview.m_STICKYKEYS.dwFlags |= SKF_STICKYKEYSON;

			// Turn selected flags on
			g_Options.m_schemePreview.m_STICKYKEYS.dwFlags |= SKF_TRISTATE;
			g_Options.m_schemePreview.m_STICKYKEYS.dwFlags |= SKF_TWOKEYSOFF;
			g_Options.m_schemePreview.m_STICKYKEYS.dwFlags |= SKF_AUDIBLEFEEDBACK;
		}
		else
			g_Options.m_schemePreview.m_STICKYKEYS.dwFlags &= ~SKF_STICKYKEYSON;
	}
};

class CToggleKeysPg : public CYesNoPg
{
public:
    CToggleKeysPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_WIZTOGGLEKEYSTITLE, IDS_WIZTOGGLEKEYSSUBTITLE, IDD_KBDWIZTOGGLEKEYS) {}
protected:
	BOOL IsOptionSet()
	{
		return g_Options.m_schemePreview.m_TOGGLEKEYS.dwFlags & TKF_TOGGLEKEYSON;
	}
	void SetOptions(BOOL bOn)
	{
		if(bOn)
			g_Options.m_schemePreview.m_TOGGLEKEYS.dwFlags |= TKF_TOGGLEKEYSON;
		else
			g_Options.m_schemePreview.m_TOGGLEKEYS.dwFlags &= ~TKF_TOGGLEKEYSON;
	}
};

class CShowKeyboardHelpPg : public CYesNoPg
{
public:
    CShowKeyboardHelpPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_WIZSHOWEXTRAKEYBOARDHELPTITLE, IDS_WIZSHOWEXTRAKEYBOARDHELPSUBTITLE, IDD_KBDWIZSHOWEXTRAKEYBOARDHELP) {}
protected:
	BOOL IsOptionSet()
	{
		return g_Options.m_schemePreview.m_bShowExtraKeyboardHelp;
	}
	void SetOptions(BOOL bOn)
	{
		g_Options.m_schemePreview.m_bShowExtraKeyboardHelp = bOn;
	}
};


class CMouseSpeedPg : public WizardPage
{
public:
    CMouseSpeedPg(LPPROPSHEETPAGE ppsp)
		: WizardPage(ppsp, IDS_MSEWIZMOUSESPEEDTITLE, IDS_MSEWIZMOUSESPEEDSUBTITLE)
	{
		m_dwPageId = IDD_MSEWIZMOUSESPEED;
		ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	}

protected:
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{
		// Set slider for mouse speed, (limit 1 to 20), and set its initial value
		SendDlgItemMessage(m_hwnd,IDC_SLIDER1, TBM_SETRANGE, TRUE,MAKELONG(1,20));
		SendDlgItemMessage(m_hwnd,IDC_SLIDER1, TBM_SETPOS, TRUE, min(20, max(1, g_Options.m_schemePreview.m_nMouseSpeed)));
		return 1;
	}
	LRESULT HandleMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		switch(uMsg)
		{
		case WM_HSCROLL:
			g_Options.m_schemePreview.m_nMouseSpeed = (UINT)SendDlgItemMessage(m_hwnd, IDC_SLIDER1, TBM_GETPOS, 0, 0);
			g_Options.ApplyPreview();
			break;
		default:
			break;
		}
		return 0;
	}
};


class CMouseTrailsPg : public CYesNoPg
{
public:
    CMouseTrailsPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_MSEWIZMOUSETRAILSTITLE, IDS_MSEWIZMOUSETRAILSSUBTITLE, IDD_MSEWIZMOUSETRAILS) {}
protected:
	BOOL IsOptionSet()
	{
		return (g_Options.m_schemePreview.m_nMouseTrails > 1);
	}
	void SetOptions(BOOL bOn)
	{
		g_Options.m_schemePreview.m_nMouseTrails = bOn?7:0;
	}
};




#endif // _INC_PGEXTRAS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pggenric.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGGENRIC_H
#define _INC_PGGENRIC_H

#include "pgbase.h"

class CGenericWizPg : public WizardPage
{
    public:
        CGenericWizPg(LPPROPSHEETPAGE ppsp, DWORD dwPageId, int nIdTitle = IDS_GENERICPAGETITLE, int nIdSubTitle = IDS_GENERICPAGESUBTITLE);
        ~CGenericWizPg(VOID);

    private:
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);

};

#endif // _INC_PGGENRIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgfinish.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgfinish.h"


FinishWizPg::FinishWizPg( 
						 LPPROPSHEETPAGE ppsp
						 ) : WizardPage(ppsp, 0, 0)
{
	m_dwPageId = IDD_WIZFINISH;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


FinishWizPg::~FinishWizPg(
						  VOID
						  )
{
}


LRESULT
FinishWizPg::OnInitDialog(
						  HWND hwnd,
						  WPARAM wParam,
						  LPARAM lParam
						  )
{
	g_Options.ReportChanges(GetDlgItem(hwnd, IDC_SZCHANGES));
	
	return 1;
}

LRESULT
FinishWizPg::OnPSN_SetActive(
							 HWND hwnd, 
							 INT idCtl, 
							 LPPSHNOTIFY pnmh
							 )
{
	// Call the base class
	WizardPage::OnPSN_SetActive(hwnd, idCtl, pnmh);

	g_Options.ReportChanges(GetDlgItem(hwnd, IDC_SZCHANGES));

	return TRUE;
}


BOOL FinishWizPg::OnMsgNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
	// Hope the site addr is not more than 256 characters
	TCHAR webAddr[256];
	LoadString(g_hInstDll, IDS_ENABLEWEB, webAddr, 256);

	ShellExecute(hwnd, TEXT("open"), TEXT("iexplore.exe"), webAddr, NULL, SW_SHOW); 
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pglokprv.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgLokPrv.h"

CLookPreviewPg::CLookPreviewPg(
							   LPPROPSHEETPAGE ppsp,
							   int dwPageId,
							   int nIdTitle,
							   int nIdSubTitle,
							   int nIdValueString
							   ) : WizardPage(ppsp, nIdTitle, nIdSubTitle)
{
	m_dwPageId = dwPageId;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);

	m_nIdValueString = nIdValueString;

	m_nCountValues = 0;
	m_nCurValueIndex = 0;
    m_nOrigValueIndex = 0;

	m_hwndSlider = 0;
	m_hwndListBox = 0;
}



CLookPreviewPg::~CLookPreviewPg(
	VOID
	)
{
}

#include "LookPrev.h"

void PASCAL Look_RebuildSysStuff(BOOL fInit);
void SetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm);

LRESULT
CLookPreviewPg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	SendMessage(GetDlgItem(m_hwnd, IDC_LOOKPREV), LPM_RECALC, 0, 0);
	SendMessage(GetDlgItem(m_hwnd, IDC_LOOKPREV), LPM_REPAINT, 0, 0);

	LoadValueArray();

	m_hwndListBox = GetDlgItem(m_hwnd, IDC_PREVLIST);

	// Get the initial value for the type of preview we are doing
	int nCurrentSize = GetCurrentValue(NULL/*&g_Options.m_schemePreview.m_ncm*/);

	// Find next larger
	for(int i=m_nCountValues - 1;i>=0;i--)
	{
		if(m_rgnValues[i] >= nCurrentSize)
			m_nCurValueIndex = i;
		else break;
	}
    m_nOrigValueIndex = m_nCurValueIndex;

	// Initialize the high contrast colors listbox

	for(i=0;i<m_nCountValues;i++)
	{
		TCHAR sz[100];
		GetValueItemText(i, sz, ARRAYSIZE(sz));
		ListBox_AddString(m_hwndListBox, sz);
	}
	ListBox_SetCurSel(m_hwndListBox, m_nCurValueIndex);

	UpdateControls();
	return 1;
}


void CLookPreviewPg::LoadValueArray()
{
	LoadArrayFromStringTable(m_nIdValueString, m_rgnValues, &m_nCountValues);
}


void CLookPreviewPg::UpdateControls()
{
}

LRESULT
CLookPreviewPg::OnCommand(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LRESULT lResult = 1;

	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID      = LOWORD(wParam);
	HWND hwndCtl     = (HWND)lParam;

	switch(wCtlID)
	{
	    case IDC_PREVLIST:
		switch(wNotifyCode)
		{
		    case LBN_SELCHANGE:
			UpdatePreview(wCtlID);
			break;

		    default:
			break;
		}
        break;

        default:
		break;
	}

	return lResult;
}

void CLookPreviewPg::ResetColors()
{
	if(0 != m_nCurValueIndex)
	{
		int nCount = GetScheme(m_nCurValueIndex-1).nColorsUsed;
		for(int i=0;i<nCount;i++)
        {
			g_Options.m_schemePreview.m_rgb[i] = GetScheme(m_nCurValueIndex-1).rgb[i];
        }
	}
	else
	{
		// Use scheme that we came in here with
		g_Options.RestoreOriginalColorsToPreview();
	}

	Look_RebuildSysStuff(TRUE);
	SendMessage(GetDlgItem(m_hwnd, IDC_LOOKPREV), LPM_REPAINT, 0, 0);
}

LRESULT
CLookPreviewPg::HandleMsg(
	HWND hwnd,
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam
	)
{
	return 0;
}

void CLookPreviewPg::UpdatePreview(int nActionCtl)
{
	// Calculate new index based on the control that generated this event
	switch(nActionCtl)
	{
	    case IDC_PREVLIST:
		m_nCurValueIndex = ListBox_GetCurSel(m_hwndListBox);
		break;

	    default:
		break;
	}

	// Make sure we are withing range
	m_nCurValueIndex = max(m_nCurValueIndex, 0);
	m_nCurValueIndex = min(m_nCurValueIndex, m_nCountValues - 1);

	// Modify the ncm structure

	// JMC: The wizard currently does not muck with m_ncm any more - we only change the colors
	// Therefore, we can call ModifyMyNonClientMetrics() with a dummy variable
	NONCLIENTMETRICS ncmDummy;
	ModifyMyNonClientMetrics(ncmDummy/*g_Options.m_schemePreview.m_ncm*/);
    if (m_nCurValueIndex == 0)
    {
        // If we are here the user is going "back" and we revert to "Windows Classic" (Why?)
        LoadString(g_hInstDll, IDS_SCHEME_CURRENTCOLORSCHEME+100, g_Options.m_schemePreview.m_szSelectedStyle, MAX_NUM_SZ);
    }
    else
    {
        lstrcpy(g_Options.m_schemePreview.m_szSelectedStyle, GetScheme(m_nCurValueIndex-1).szNameIndexId);
    }

	Look_RebuildSysStuff(TRUE);
	SendMessage(GetDlgItem(m_hwnd, IDC_LOOKPREV), LPM_RECALC, 0, 0);
	SendMessage(GetDlgItem(m_hwnd, IDC_LOOKPREV), LPM_REPAINT, 0, 0);
}

LRESULT
CLookPreviewPg::OnPSN_WizNext(
						   HWND hwnd,
						   INT idCtl,
						   LPPSHNOTIFY pnmh
						   )
{
    if (m_nOrigValueIndex != m_nCurValueIndex)
    {
        // we are applying the preview; clear theme and wallpaper
        // so visual style gets turned off before we make the change.
        if (m_nCurValueIndex)
        {
		    g_Options.m_schemePreview.ClearTheme();
		    g_Options.m_schemePreview.ClearWallpaper();
        }
        else
        {
            memcpy(&g_Options.m_schemePreview, &g_Options.m_schemeOriginal, sizeof(WIZSCHEME));
        }
	    g_Options.ApplyPreview();
        m_nOrigValueIndex = m_nCurValueIndex;
    }

	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgmsecur.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGMSECUR_H
#define _INC_PGMSECUR_H

#include "pgbase.h"

class CMouseCursorPg : public WizardPage
{
public:
    CMouseCursorPg(LPPROPSHEETPAGE ppsp);
    ~CMouseCursorPg(VOID);

protected:
	void UpdateControls();

	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);


private:

};

#endif // _INC_PGMSECUR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgmsebut.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGMSEBUT_H
#define _INC_PGMSEBUT_H

#include "pgbase.h"

class CMouseButtonPg : public WizardPage
{
public:
    CMouseButtonPg(LPPROPSHEETPAGE ppsp);
    ~CMouseButtonPg(VOID);

protected:
	POINT m_ptRight;
	POINT m_ptLeft;
	void UpdateControls();

	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
};

#endif // _INC_PGMSEBUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgmsecur.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgMseCur.h"


CMouseCursorPg::CMouseCursorPg(
	LPPROPSHEETPAGE ppsp
	) : WizardPage(ppsp, IDS_MSEWIZMOUSECURSORTITLE, IDS_MSEWIZMOUSECURSORSUBTITLE)
{
	m_dwPageId = IDD_MSEWIZMOUSECURSOR;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


CMouseCursorPg::~CMouseCursorPg(
	VOID
	)
{
}

LRESULT
CMouseCursorPg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	HICON hIconSmallWhite = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_SMALL_WHITE));
	HICON hIconMediumWhite = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_MEDIUM_WHITE));
	HICON hIconLargeWhite = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_LARGE_WHITE));

	HICON hIconSmallBlack = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_SMALL_BLACK));
	HICON hIconMediumBlack = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_MEDIUM_BLACK));
	HICON hIconLargeBlack = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_LARGE_BLACK));

	HICON hIconSmallInverting = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_SMALL_INVERTING));
	HICON hIconMediumInverting = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_MEDIUM_INVERTING));
	HICON hIconLargeInverting = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_LARGE_INVERTING));

#pragma message ("Need to destroy bitmaps in OnDestroy")
	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO2), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconSmallWhite);
	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO3), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconMediumWhite);
	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO4), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconLargeWhite);

	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO5), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconSmallBlack);
	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO6), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconMediumBlack);
	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO7), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconLargeBlack);

	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO8), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconSmallInverting);
	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO9), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconMediumInverting);
	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO10), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconLargeInverting);

	Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIO1), TRUE);

	UpdateControls();
	return 1;
}


void CMouseCursorPg::UpdateControls()
{
	// Nothing to do
}


LRESULT
CMouseCursorPg::OnCommand(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LRESULT lResult = 1;

	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID      = LOWORD(wParam);
	HWND hwndCtl     = (HWND)lParam;

	HCURSOR hCursor = NULL;
	switch(wCtlID)
	{
	case IDC_RADIO1:
		g_Options.m_schemePreview.m_nCursorScheme = 0;
		break;
	case IDC_RADIO2:
		g_Options.m_schemePreview.m_nCursorScheme = 1;
		break;
	case IDC_RADIO3:
		g_Options.m_schemePreview.m_nCursorScheme = 2;
		break;
	case IDC_RADIO4:
		g_Options.m_schemePreview.m_nCursorScheme = 3;
		break;
	case IDC_RADIO5:
		g_Options.m_schemePreview.m_nCursorScheme = 4;
		break;
	case IDC_RADIO6:
		g_Options.m_schemePreview.m_nCursorScheme = 5;
		break;
	case IDC_RADIO7:
		g_Options.m_schemePreview.m_nCursorScheme = 6;
		break;
	case IDC_RADIO8:
		g_Options.m_schemePreview.m_nCursorScheme = 7;
		break;
	case IDC_RADIO9:
		g_Options.m_schemePreview.m_nCursorScheme = 8;
		break;
	case IDC_RADIO10:
		g_Options.m_schemePreview.m_nCursorScheme = 9;
		break;
	default:
		break;
	}
	g_Options.ApplyPreview();

	return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgmsebut.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgMseBut.h"

CMouseButtonPg::CMouseButtonPg(
	LPPROPSHEETPAGE ppsp
	) : WizardPage(ppsp, IDS_MSEWIZBUTTONCONFIGTITLE, IDS_MSEWIZBUTTONCONFIGSUBTITLE)
{
	m_dwPageId = IDD_MSEWIZBUTTONCONFIG;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


CMouseButtonPg::~CMouseButtonPg(
	VOID
	)
{
}

LRESULT
CMouseButtonPg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	if(g_Options.m_schemePreview.m_bSwapMouseButtons)
		Button_SetCheck(GetDlgItem(m_hwnd, MOUSE_LEFTHAND), TRUE);
	else
		Button_SetCheck(GetDlgItem(m_hwnd, MOUSE_RIGHTHAND), TRUE);

	RECT rc;
	GetWindowRect(GetDlgItem(m_hwnd, IDC_OBJECTMENU), &rc);
    MapWindowPoints(HWND_DESKTOP, m_hwnd, (LPPOINT)&rc, 2);
	m_ptRight.x = rc.left;
	m_ptRight.y = rc.top;
	GetWindowRect(GetDlgItem(m_hwnd, IDC_SELECTDRAG), &rc);
    MapWindowPoints(HWND_DESKTOP, m_hwnd, (LPPOINT)&rc, 2);
	m_ptLeft.x = rc.left;
	m_ptLeft.y = rc.top;


	UpdateControls();
	return 1;
}


void CMouseButtonPg::UpdateControls()
{
	if(Button_GetCheck(GetDlgItem(m_hwnd, MOUSE_RIGHTHAND)))
	{
		SetWindowPos(GetDlgItem(m_hwnd, IDC_OBJECTMENU), NULL, m_ptRight.x, m_ptRight.y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
		SetWindowPos(GetDlgItem(m_hwnd, IDC_SELECTDRAG), NULL, m_ptLeft.x, m_ptLeft.y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
		ShowWindow(GetDlgItem(m_hwnd, IDC_MOUSEPIC1), TRUE);
		ShowWindow(GetDlgItem(m_hwnd, IDC_MOUSEPIC2), FALSE);
	}
	else
	{
		SetWindowPos(GetDlgItem(m_hwnd, IDC_OBJECTMENU), NULL, m_ptLeft.x, m_ptLeft.y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
		SetWindowPos(GetDlgItem(m_hwnd, IDC_SELECTDRAG), NULL, m_ptRight.x, m_ptRight.y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
		ShowWindow(GetDlgItem(m_hwnd, IDC_MOUSEPIC1), FALSE);
		ShowWindow(GetDlgItem(m_hwnd, IDC_MOUSEPIC2), TRUE);
	}

}


LRESULT
CMouseButtonPg::OnCommand(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LRESULT lResult = 1;

	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID      = LOWORD(wParam);
	HWND hwndCtl     = (HWND)lParam;

	switch(wCtlID)
	{
	case MOUSE_LEFTHAND:
	case MOUSE_RIGHTHAND:
		UpdateControls();
		break;

	}
	g_Options.m_schemePreview.m_bSwapMouseButtons = Button_GetCheck(GetDlgItem(m_hwnd, MOUSE_LEFTHAND));
	g_Options.ApplyPreview();
	return lResult;
}

LRESULT
CMouseButtonPg::OnPSN_WizNext(
						   HWND hwnd,
						   INT idCtl,
						   LPPSHNOTIFY pnmh
						   )
{
	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgnwelcome.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgnWelcome.h"
#include "select.h"

CWizWelcomePg::CWizWelcomePg(
						   LPPROPSHEETPAGE ppsp
						   ) : WizardPage(ppsp, 0, 0)
{
	m_dwPageId = IDD_WIZNEWWELCOME;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


CWizWelcomePg::~CWizWelcomePg(
							VOID
							)
{
}


LRESULT
CWizWelcomePg::OnCommand(
						HWND hwnd,
						WPARAM wParam,
						LPARAM lParam
						)
{
	LRESULT lResult = 1;
	
	return lResult;
}





LRESULT
CWizWelcomePg::OnPSN_WizNext(
						   HWND hwnd,
						   INT idCtl,
						   LPPSHNOTIFY pnmh
						   )
{
	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pglokprv.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGLOKPRV_H
#define _INC_PGLOKPRV_H

#include "pgbase.h"

class CLookPreviewPg : public WizardPage
{
public:
    CLookPreviewPg(LPPROPSHEETPAGE ppsp, int dwPageId, int nIdTitle, int nIdSubTitle, int nIdValueString);
    ~CLookPreviewPg(VOID);


protected: // Virtual functions
	// Override this if the values are not stored in a string table
	virtual void LoadValueArray();

	// This must be overridden so that the dialog knows what item to select as the default
	virtual int GetCurrentValue(NONCLIENTMETRICS *pncm) = 0;

	// If the dialog is using a list box, the user MUST override this function
	virtual void GetValueItemText(int nIndex, LPTSTR lpszBuffer, int nLen) {_ASSERTE(FALSE);}

	// Must be overridden to set ncm to appropriate values based on Value array index
	virtual void ModifyMyNonClientMetrics(NONCLIENTMETRICS &ncm) = 0;

protected:
	void UpdatePreview(int nActionCtl);

	int m_nIdValueString;
	HWND m_hwndSlider;
	HWND m_hwndListBox;

	int m_nCountValues;
	int m_rgnValues[MAX_DISTINCT_VALUES];
	int m_nCurValueIndex;
	int m_nOrigValueIndex;

	void ResetColors();
	void UpdateControls();
	

	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT HandleMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);


private:

};



/////////////////////////////////////////////////////////////
// Color page

class CLookPreviewColorPg : public CLookPreviewPg
{
public:
	CLookPreviewColorPg(LPPROPSHEETPAGE ppsp)
		: CLookPreviewPg(	ppsp,
							IDD_PREV_COLOR,
							IDS_LKPREV_COLORTITLE,
							IDS_LKPREV_COLORSUBTITLE,
							0) {};

	virtual void LoadValueArray()
	{
		// For colors, we just use 0 to GetSchemeCount()
		m_nCountValues = GetSchemeCount() + 1;
		for(int i=0;i<m_nCountValues;i++)
			m_rgnValues[i] = i;
	}
	virtual int GetCurrentValue(NONCLIENTMETRICS *pncm) {return 0;}; // Always return value of 0
	virtual void GetValueItemText(int nIndex, LPTSTR lpszBuffer, int nLen)
	{
		_ASSERTE(nIndex < GetSchemeCount() + 1);
		if(0 == nIndex)
		{
			LoadString(g_hInstDll, IDS_SCHEME_CURRENTCOLORSCHEME, lpszBuffer, nLen);
		}
		else
			GetSchemeName(nIndex - 1, lpszBuffer, nLen);
	}
	virtual void ModifyMyNonClientMetrics(NONCLIENTMETRICS &ncm)
	{
		ResetColors();
	}

};


#endif // _INC_PGLOKPRV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgnwelcome.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _PGNWELCOME_H
#define _PGNWELCOME_H

#include "pgbase.h"
#include "Select.h"

class CWizWelcomePg : public WizardPage
{
public:
    CWizWelcomePg(LPPROPSHEETPAGE ppsp);
    ~CWizWelcomePg(VOID);

protected:
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
private:

};

#endif /*_PGNWELCOME_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgsvedef.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgSveDef.h"


// JMC: This is taken from access.cpl

/***********************************************************************/
// CopyKey( hKey, hKeyDst, name )
//     create the destination key
//     for each value
//         CopyValue
//     for each subkey
//         CopyKey

DWORD CopyKey( HKEY hkeySrc, HKEY hkeyDst, LPSTR szKey )
{
    HKEY hkeyOld = NULL, hkeyNew = NULL;
    char szValue[128];
    BYTE szData[128];
    char szBuffer[128];
    DWORD iStatus;
    UINT nValue, nKey;
    DWORD iValueLen, iDataLen;
	DWORD dwType;

    iStatus = RegOpenKeyA( hkeySrc, szKey, &hkeyOld );
    if( iStatus != ERROR_SUCCESS)
        goto exit;

    iStatus = RegOpenKeyA( hkeyDst, szKey, &hkeyNew );
    if( iStatus != ERROR_SUCCESS )
    {
        iStatus = RegCreateKeyA( hkeyDst, szKey, &hkeyNew );
        if( iStatus != ERROR_SUCCESS )
        {
            goto exit;
        }
    }
    //*********** copy the values **************** //

    for( nValue = 0, iValueLen=sizeof szValue, iDataLen=sizeof szValue;
         ERROR_SUCCESS == (iStatus = RegEnumValueA(hkeyOld,
                                                  nValue,
                                                  szValue,
                                                  &iValueLen,
                                                  NULL, // reserved
                                                  &dwType, // don't need type
                                                  szData,
                                                  &iDataLen ) );
         nValue ++, iValueLen=sizeof szValue, iDataLen=sizeof szValue )
     {
         iStatus = RegSetValueExA( hkeyNew,
                                  szValue,
                                  0, // reserved
                                  dwType,
                                  szData,
                                  iDataLen);
     }
    if( iStatus != ERROR_NO_MORE_ITEMS )
    {
        goto exit;
    }

    //*********** copy the subtrees ************** //

    for( nKey = 0;
         ERROR_SUCCESS == (iStatus = RegEnumKeyA(hkeyOld,nKey,szBuffer,sizeof(szBuffer)));
         nKey ++ )
     {
         iStatus = CopyKey( hkeyOld, hkeyNew, szBuffer );
         if( iStatus != ERROR_NO_MORE_ITEMS && iStatus != ERROR_SUCCESS )
            {
                goto exit;
            }
     }

    if( iStatus == ERROR_NO_MORE_ITEMS )
        iStatus = ERROR_SUCCESS;

exit:
    if (hkeyOld)
        RegCloseKey(hkeyOld);
    if (hkeyNew)
        RegCloseKey(hkeyNew);

    return iStatus;
}

DWORD SaveLookToDefaultUser( void )
{
    DWORD iStatus;
    HKEY hkeyDst;

    iStatus  = RegOpenKeyA( HKEY_USERS, ".DEFAULT", &hkeyDst );
    if( iStatus != ERROR_SUCCESS )
        return iStatus;
    iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, "Control Panel\\Desktop");
    iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, "Control Panel\\Colors");
    RegCloseKey( hkeyDst );
    return iStatus;
}

DWORD SaveAccessibilityToDefaultUser( void )
{
    DWORD iStatus;
    HKEY hkeyDst;

    iStatus  = RegOpenKeyA( HKEY_USERS, ".DEFAULT", &hkeyDst );
    if( iStatus != ERROR_SUCCESS )
        return iStatus;
    iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, "Control Panel\\Accessibility");
    RegCloseKey( hkeyDst );
    return iStatus;
}



CSaveForDefaultUserPg::CSaveForDefaultUserPg( 
    LPPROPSHEETPAGE ppsp
	) : WizardPage(ppsp, IDS_WIZSAVEASDEFAULTTITLE, IDS_WIZSAVEASDEFAULTSUBTITLE)
{
	m_dwPageId = IDD_WIZWORKSTATIONDEFAULT;
    ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


CSaveForDefaultUserPg::~CSaveForDefaultUserPg(
    VOID
    )
{
}

LRESULT CSaveForDefaultUserPg::OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
{
	if(Button_GetCheck(GetDlgItem(m_hwnd, IDC_CHECKSAVESETTINGTODEFAULT)))
	{
		SaveAccessibilityToDefaultUser();
		// JMC Check for admin privleges for both callse
		if(ERROR_SUCCESS != SaveLookToDefaultUser())
			StringTableMessageBox(m_hwnd, IDS_WIZERRORNEEDADMINTEXT, IDS_WIZERRORNEEDADMINTITLE, MB_OK);
	}
	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
}

LRESULT
CSaveForDefaultUserPg::OnCommand(
								 HWND hwnd,
								 WPARAM wParam,
								 LPARAM lParam
								 )
{
	LRESULT lResult = 1;
	
	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID 	 = LOWORD(wParam);
	HWND hwndCtl	 = (HWND)lParam;
	
	return lResult;
}

LRESULT
CSaveForDefaultUserPg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIO2), TRUE);
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgsvefil.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGSVEFIL_H
#define _INC_PGSVEFIL_H

#include "pgbase.h"

class CSaveToFilePg : public WizardPage
{
public:
    CSaveToFilePg(LPPROPSHEETPAGE ppsp);
    ~CSaveToFilePg(VOID);

protected:
	void UpdateControls();

	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);


private:

};

#endif // _INC_PGSVEFIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgwelco2.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGMINTX2_H
#define _INC_PGMINTX2_H

#include "pgbase.h"

struct CDisplayModeInfo
{
	CDisplayModeInfo() {memset(&m_DevMode, 0, sizeof(m_DevMode));m_bCanUse = FALSE;}
	DEVMODE m_DevMode;
	BOOL m_bCanUse;
};

class CWelcome2Pg : public WizardPage
{
public:
	CWelcome2Pg(LPPROPSHEETPAGE ppsp);
	~CWelcome2Pg(VOID);
	
protected:
	void UpdateControls();
	void SetCheckBoxesFromWelcomePageInfo();
	CDisplayModeInfo *m_pDisplayModes;
	int m_nDisplayModes;
	int m_nBestDisplayMode;

	// MOVE THIS STUFF TO THE ACC WIZ OPTIONS
	DEVMODE m_dvmdOrig;
	NONCLIENTMETRICS m_ncmOrig;
	LOGFONT m_lfIconOrig;


	BOOL m_bMagnifierRun;
	BOOL m_bResolutionSwitched;
	BOOL m_bFontsChanged;
	BOOL m_IntlVal;

	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	LRESULT OnPSN_WizBack(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	
private:
	
};

#endif // _INC_PGMINTX2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgsvefil.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgSveFil.h"

CSaveToFilePg::CSaveToFilePg(
	LPPROPSHEETPAGE ppsp
	) : WizardPage(ppsp, IDS_WIZSAVETOFILETITLE, IDS_WIZSAVETOFILESUBTITLE)
{
	m_dwPageId = IDD_WIZSAVETOFILE;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


CSaveToFilePg::~CSaveToFilePg(
	VOID
	)
{
}

LRESULT
CSaveToFilePg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	UpdateControls();
	return 1;
}


void CSaveToFilePg::UpdateControls()
{
	// No options
}


LRESULT
CSaveToFilePg::OnCommand(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LRESULT lResult = 1;

	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID      = LOWORD(wParam);
	HWND hwndCtl     = (HWND)lParam;

	switch(wCtlID)
	{
	case IDC_BTNBROWSE:
		{
			// These commands require us to re-enable/disable the appropriate controls
			TCHAR szBuf[_MAX_PATH];
			TCHAR szBuf2[_MAX_PATH];
			TCHAR szDefaultName[_MAX_PATH];
			LoadString(g_hInstDll, IDS_DEFAULTSAVEFILENAME, szDefaultName, ARRAYSIZE(szDefaultName));
			
			TCHAR szFilterName[_MAX_PATH];
			TCHAR szTemp[_MAX_PATH];
			ZeroMemory(szFilterName, _MAX_PATH);
			LoadString(g_hInstDll, IDS_FILTERNAME, szFilterName, ARRAYSIZE(szFilterName));
			LoadString(g_hInstDll, IDS_FILTER, szTemp, ARRAYSIZE(szTemp));

			// Copy the extension to after the filter name
			lstrcpy(&szFilterName[lstrlen(szFilterName) + 1], szTemp);

			// Double NULL terminate it
			szFilterName[lstrlen(szFilterName) + 1 + lstrlen(szTemp) + 1] = 0;
			szFilterName[lstrlen(szFilterName) + 1 + lstrlen(szTemp) + 2] = 0;


			memset(szBuf, 0, ARRAYSIZE(szBuf));
			memset(szBuf2, 0, ARRAYSIZE(szBuf));
			wsprintf(szBuf, szDefaultName);
			OPENFILENAME ofn;
			memset(&ofn, 0, sizeof(ofn));
			ofn.lStructSize = sizeof(ofn);
			ofn.hwndOwner = m_hwnd;
			ofn.hInstance = g_hInstDll;
			ofn.lpstrFilter = szFilterName; 
			ofn.lpstrCustomFilter = NULL;
			ofn.nMaxCustFilter = 0;
			ofn.nFilterIndex = 0;
			ofn.lpstrFile = szBuf;
			ofn.nMaxFile = _MAX_PATH;
			ofn.lpstrFileTitle = szBuf2;
			ofn.nMaxFileTitle = _MAX_PATH;
			ofn.lpstrInitialDir = NULL;
			ofn.lpstrTitle = NULL;
			ofn.Flags = OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
			ofn.nFileOffset = 0;
			ofn.nFileExtension = 0;
			ofn.lpstrDefExt = __TEXT("acw");
			ofn.lCustData = NULL;
			ofn.lpfnHook = NULL;
			ofn.lpTemplateName = NULL;
			BOOL bOk = GetSaveFileName(&ofn);
			if(bOk)
			{
				// Save the file to disk.
				HANDLE hFile = CreateFile(ofn.lpstrFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
				if(hFile != INVALID_HANDLE_VALUE)
				{
					DWORD dwWritten;
					WriteFile(hFile, (LPCVOID)&g_Options.m_schemePreview, sizeof(g_Options.m_schemePreview), &dwWritten, NULL);
					CloseHandle(hFile);
					// TODO: Maybe go to the next page
				}
				else
					StringTableMessageBox(m_hwnd, IDS_WIZERRORSAVINGFILETEXT, IDS_WIZERRORSAVINGFILETITLE, MB_OK);
			}

			UpdateControls();
			lResult = 0;
		}
		break;
																					 
	default:
		break;
	}

	return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgwelco2.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgWelco2.h"

// Intelli-menu regsitry
#define REGSTR_EXPLORER TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer")
#define REGSTR_INTELLIMENU REGSTR_EXPLORER TEXT("\\Advanced")

#define REGSTR_IE TEXT("Software\\Microsoft\\Internet Explorer\\Main")
#define STRMENU TEXT("IntelliMenus")
#define FAVMENU TEXT("FavIntelliMenus")

CWelcome2Pg::CWelcome2Pg(
	LPPROPSHEETPAGE ppsp
	) : WizardPage(ppsp, IDS_WELCOME2TITLE, IDS_WELCOME2SUBTITLE)
{
	m_dwPageId = IDD_WIZWELCOME2;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	m_pDisplayModes = NULL;
	m_nDisplayModes = 0;
	m_nBestDisplayMode = -1;
	m_IntlVal = FALSE;


	// These are our state variables so we know not to do these things twice.
	m_bMagnifierRun = FALSE;
	m_bResolutionSwitched = FALSE;
	m_bFontsChanged = FALSE;

}


CWelcome2Pg::~CWelcome2Pg(
	VOID
	)
{
	if(m_pDisplayModes)
		delete [] m_pDisplayModes;
}

LRESULT
CWelcome2Pg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	// Enumerate available video modes
	// Check if SM_CMONITORS is > 0 then set text so we don't
	// change resolution.

	DEVMODE dm;
	// Calculate number of display modes
	for(m_nDisplayModes=0;m_nDisplayModes<2000;m_nDisplayModes++) // Limit to 2000 display modes.  If it is this high, something is wrong
		if(!EnumDisplaySettings(NULL, m_nDisplayModes, &dm))
			break;

	m_pDisplayModes = new CDisplayModeInfo[m_nDisplayModes];
	for(int i=0;i<m_nDisplayModes;i++)
		EnumDisplaySettings(NULL, i, &m_pDisplayModes[i].m_DevMode);


	m_nBestDisplayMode = -1;

	memset(&m_dvmdOrig, 0, sizeof(m_dvmdOrig));

	HDC hdc = GetDC(NULL);  // Screen DC used to get current display settings
	// JMC: HOW DO WE GET dmDisplayFlags?
	// TODO: Maybe use ChangeDisplaySettings(NULL, 0) to restore original mode
	m_dvmdOrig.dmSize = sizeof(m_dvmdOrig);
	m_dvmdOrig.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT | /* DM_DISPLAYFLAGS | */(g_Options.m_bWin95?0:DM_DISPLAYFREQUENCY);
	m_dvmdOrig.dmPelsWidth        = GetDeviceCaps(hdc, HORZRES);
	m_dvmdOrig.dmPelsHeight       = GetDeviceCaps(hdc, VERTRES);
	m_dvmdOrig.dmBitsPerPel       = GetDeviceCaps(hdc, BITSPIXEL);
	m_dvmdOrig.dmDisplayFrequency = g_Options.m_bWin95?0:GetDeviceCaps(hdc, VREFRESH);
	ReleaseDC(NULL, hdc);


	for(i=0;i<m_nDisplayModes;i++)
	{
		// Skip anything 'higher' than current mode
		if(		m_pDisplayModes[i].m_DevMode.dmPelsWidth > m_dvmdOrig.dmPelsWidth
			||	m_pDisplayModes[i].m_DevMode.dmPelsHeight > m_dvmdOrig.dmPelsHeight
			||	m_pDisplayModes[i].m_DevMode.dmBitsPerPel > m_dvmdOrig.dmBitsPerPel
			||	(!g_Options.m_bWin95 && m_pDisplayModes[i].m_DevMode.dmDisplayFrequency > m_dvmdOrig.dmDisplayFrequency) )
			continue;

		// Skip this if it is 'worse' than the current best mode
		if(		-1 != m_nBestDisplayMode
			&&	(		m_pDisplayModes[i].m_DevMode.dmPelsWidth < m_pDisplayModes[m_nBestDisplayMode].m_DevMode.dmPelsWidth
					||	m_pDisplayModes[i].m_DevMode.dmPelsHeight < m_pDisplayModes[m_nBestDisplayMode].m_DevMode.dmPelsHeight
					||	m_pDisplayModes[i].m_DevMode.dmBitsPerPel < m_pDisplayModes[m_nBestDisplayMode].m_DevMode.dmBitsPerPel
					||	(!g_Options.m_bWin95 && m_pDisplayModes[i].m_DevMode.dmDisplayFrequency < m_pDisplayModes[m_nBestDisplayMode].m_DevMode.dmDisplayFrequency) ) )
			continue;

		// Skip anything 'less than' 800 x 600 (JMC: Used to be 640 x 480)
		if(		m_pDisplayModes[i].m_DevMode.dmPelsWidth < 800
			||	m_pDisplayModes[i].m_DevMode.dmPelsHeight < 600 )
			continue;


		// See if this is 'smaller' than the current resolution
		if(	m_pDisplayModes[i].m_DevMode.dmPelsHeight < m_dvmdOrig.dmPelsHeight )
			m_nBestDisplayMode = i;

	}

	// Get original metrics
	GetNonClientMetrics(&m_ncmOrig, &m_lfIconOrig);
	
	SetCheckBoxesFromWelcomePageInfo();

	// Set the Personalized menu check box
	HKEY hKey;
	DWORD dwType;
	TCHAR lpszData[24];
	DWORD dwCount = 24;

	if(ERROR_SUCCESS == RegOpenKey( HKEY_CURRENT_USER, REGSTR_INTELLIMENU,&hKey))
	{
		if ( ERROR_SUCCESS == RegQueryValueEx( hKey, STRMENU, NULL, &dwType, (LPBYTE)lpszData, &dwCount ) )
		{
			if ( lstrcmp(lpszData, TEXT("No") ) == 0 )
				m_IntlVal = TRUE;
		}
	}

	Button_SetCheck(GetDlgItem(hwnd, IDC_PERMENU), m_IntlVal);

	return 1;
}


void CWelcome2Pg::UpdateControls()
{
	BOOL bChangeRes = Button_GetCheck(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION));
	BOOL bChangeFont = Button_GetCheck(GetDlgItem(m_hwnd, IDC_CHANGEFONTS));
	BOOL bMagnifier = Button_GetCheck(GetDlgItem(m_hwnd, IDC_USEMAGNIFY));
	DWORD_PTR result;

	if(bChangeRes && !m_bResolutionSwitched)
	{
		if(IDOK != StringTableMessageBox(m_hwnd,IDS_WIZCHANGESHAPPENINGTEXT, IDS_WIZCHANGESHAPPENINGTITLE, MB_OKCANCEL))
		{
			// The user does not want to do this
			Button_SetCheck(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION), FALSE);
		}
		else
		{
			// Lets change the resolution
			if(DISP_CHANGE_SUCCESSFUL != ChangeDisplaySettings(&m_pDisplayModes[m_nBestDisplayMode].m_DevMode, CDS_TEST))
			{
			}
			else
				ChangeDisplaySettings(&m_pDisplayModes[m_nBestDisplayMode].m_DevMode, CDS_UPDATEREGISTRY | CDS_GLOBAL);

			if(IDOK != StringTableMessageBox(m_hwnd, IDS_WIZCANCELCHANGESTEXT, IDS_WIZCANCELCHANGESTITLE, MB_OKCANCEL))
			{
				// Restore original settings
				ChangeDisplaySettings(&m_dvmdOrig, CDS_UPDATEREGISTRY | CDS_GLOBAL);
				Button_SetCheck(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION), FALSE);
			}
			else
				m_bResolutionSwitched = TRUE; // We REALLY changed the settings
		}
	}
	else if (!bChangeRes && m_bResolutionSwitched)
	{
		m_bResolutionSwitched = FALSE;
		// Restore original settings
		ChangeDisplaySettings(&m_dvmdOrig, CDS_UPDATEREGISTRY | CDS_GLOBAL);
	}

	if(bChangeFont && !m_bFontsChanged)
	{
		m_bFontsChanged = TRUE;

		// Get current metrics
		NONCLIENTMETRICS ncm;
		memset(&ncm, 0, sizeof(ncm));
		ncm.cbSize = sizeof(ncm);
		SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);

		LOGFONT lf;
		memset(&lf, 0, sizeof(lf));
		lf.lfHeight = -MulDiv(g_Options.m_nMinimalFontSize, g_Options.m_nLogPixelsY, 72);
		lf.lfWeight = FW_BOLD;
		lf.lfCharSet = g_Options.m_lfCharSet;
		LoadString(g_hInstDll, IDS_SYSTEMFONTNAME, lf.lfFaceName, ARRAYSIZE(lf.lfFaceName));


		// Captions are BOLD
		ncm.lfCaptionFont = lf;

		lf.lfWeight = FW_NORMAL;

		ncm.lfSmCaptionFont = lf; 
		ncm.lfMenuFont = lf;
		ncm.lfStatusFont = lf;
		ncm.lfMessageFont = lf;

		// DYNAMICS
		// JMC: TODO: Change caption height / menu height / button width to match.
		// JMC: HACK
		lf.lfWeight = FW_BOLD; // Caption is BOLD
		HFONT hFont = CreateFontIndirect(&lf);
		lf.lfWeight = FW_NORMAL; // Still need lf for ICON
		TEXTMETRIC tm;
		HDC hdc = GetDC(m_hwnd);
		HFONT hfontOld = (HFONT)SelectObject(hdc, hFont);
		GetTextMetrics(hdc, &tm);
		if (hfontOld)
			SelectObject(hdc, hfontOld);
		ReleaseDC(m_hwnd, hdc);

		/*int cyBorder = GetSystemMetrics(SM_CYBORDER);
		int nSize = abs(lf.lfHeight) + abs(tm.tmExternalLeading) + 2 * cyBorder;
		nSize = max(nSize, GetSystemMetrics(SM_CYICON)/2 + 2 * cyBorder);*/

		// The above calculation of metric sizes is incorrect, Morever, The other values
		// are also wrong..So using hardcoded values: Based on Display.cpl
		// BUG: Changes maybe required for 9x here!!
		if (g_Options.m_nMinimalFontSize >= 14 )
			ncm.iCaptionWidth = ncm.iCaptionHeight = 26;
		else
			ncm.iCaptionWidth = ncm.iCaptionHeight = 18;
		
		ncm.iSmCaptionWidth = 15;
		ncm.iSmCaptionHeight = 15;
		ncm.iMenuWidth = 18;
		ncm.iMenuHeight = 18;

		SystemParametersInfo(SPI_SETNONCLIENTMETRICS, sizeof(ncm), &ncm, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
		SystemParametersInfo(SPI_SETICONTITLELOGFONT, sizeof(lf), &lf, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
		SendMessageTimeout(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0, SMTO_ABORTIFHUNG, 5000, &result );
		SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETNONCLIENTMETRICS, (LPARAM)__TEXT("WindowMetrics"),
			SMTO_ABORTIFHUNG, 5000, &result);

		// HACK - TODO Remove this from here
		g_Options.m_schemePreview.m_PortableNonClientMetrics.LoadOriginal();
		g_Options.m_schemeCurrent.m_PortableNonClientMetrics.LoadOriginal();
	}
	else if (!bChangeFont && m_bFontsChanged)
	{
		m_bFontsChanged = FALSE;

		SystemParametersInfo(SPI_SETNONCLIENTMETRICS, sizeof(m_ncmOrig), &m_ncmOrig, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
		SystemParametersInfo(SPI_SETICONTITLELOGFONT, sizeof(m_lfIconOrig), &m_lfIconOrig, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
		SendMessageTimeout(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0, SMTO_ABORTIFHUNG, 5000, &result);
		SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETNONCLIENTMETRICS, (LPARAM)__TEXT("WindowMetrics"),
			SMTO_ABORTIFHUNG, 5000, &result);

		// HACK - TODO Remove this from here
		g_Options.m_schemePreview.m_PortableNonClientMetrics.LoadOriginal();
		g_Options.m_schemeCurrent.m_PortableNonClientMetrics.LoadOriginal();
	}
	
	if(bMagnifier && !m_bMagnifierRun)
	{
		// Start magnifier
		m_bMagnifierRun = TRUE;
		ShellExecute(NULL, NULL, __TEXT("Magnify.exe"), NULL, NULL, SW_SHOWNORMAL/*SW_SHOWMINIMIZED*/);
	}
	else if (!bMagnifier && m_bMagnifierRun)
	{
		// Stop magnifier
		m_bMagnifierRun = FALSE;
		TCHAR szMag[200];
		LoadString(g_hInstDll, IDS_NAMEOFMAGNIFIER, szMag, ARRAYSIZE(szMag));
		if(HWND hwnd = FindWindow(NULL, szMag))
			SendMessage(hwnd, WM_CLOSE, 0, 0);
	}
	
}


void CWelcome2Pg::SetCheckBoxesFromWelcomePageInfo()
{
	// This algorithm chooses which check boxes to set based on the
	// minimal legible font size specified in g_Options.m_nMinimalFontSize

	// HACK:
//	g_Options.m_nMinimalFontSize = MulDiv(abs(g_Options.m_schemePreview.m_ncm.lfCaptionFont.lfHeight), 72, g_Options.m_nLogPixelsY);

	BOOL bSwitchRes = FALSE;
	BOOL bChangeFonts = FALSE;
 	BOOL bUseMagnify = FALSE;
	switch(g_Options.m_nMinimalFontSize)
	{
	case 8:
	case 9:  // Required for JPN
	case 10:
	case 11: // Required For JPN
		bChangeFonts = TRUE;
		break;
	case 12:
		bChangeFonts = TRUE;
		bSwitchRes = TRUE;
		break;
	case 14:
	case 15: // Required for JPN
	case 16:
	case 18:
	case 20:
	case 22:
	case 24:
		bChangeFonts = TRUE;
		bUseMagnify = TRUE;
		break;
	}

	// JMC: TODO: Handle if the user does not have permission to change
	// the display settings!!!!!!!!!!!!!!

	if(-1 == m_nBestDisplayMode)
	{
		bSwitchRes = FALSE;
//		SetWindowText(GetDlgItem(m_hwnd, IDC_SZRESMESSAGE),
//			__TEXT("There are no display resolutions that would be better for the size text you chose."));
		EnableWindow(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION), FALSE);
	}
	else
	{
#if 0 // We don't display special text any more
		TCHAR sz[200];
		TCHAR szTemp[1024];
		LoadString(g_hInstDll, IDS_DISPLAYRESOLUTIONINFO, szTemp, ARRAYSIZE(szTemp));
		wsprintf(sz, szTemp,
			m_dvmdOrig.dmPelsWidth,
			m_dvmdOrig.dmPelsHeight,
			m_pDisplayModes[m_nBestDisplayMode].m_DevMode.dmPelsWidth,
			m_pDisplayModes[m_nBestDisplayMode].m_DevMode.dmPelsHeight);
		SetWindowText(GetDlgItem(m_hwnd, IDC_SZRESMESSAGE), sz);
#endif
		EnableWindow(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION), TRUE);
	}

	Button_SetCheck(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION), bSwitchRes);
	Button_SetCheck(GetDlgItem(m_hwnd, IDC_CHANGEFONTS), bChangeFonts);
	Button_SetCheck(GetDlgItem(m_hwnd, IDC_USEMAGNIFY), bUseMagnify);
	UpdateControls();
}


LRESULT
CWelcome2Pg::OnCommand(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LRESULT lResult = 1;

	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID      = LOWORD(wParam);
	HWND hwndCtl     = (HWND)lParam;


	// NOTE: DO NOT CALL UpdateControls()
	// UpdateControls() should only be called when entering this page
	// since it sets the check boxes based on the minimal font size
	// determined by the previous wizard page
	
	
	switch(wCtlID)
	{
	case IDC_SWITCHRESOLUTION:
	case IDC_CHANGEFONTS:
	case IDC_USEMAGNIFY:
		UpdateControls();
		lResult = 0;
	break;
	
	  default:
	  break;
	  }
	
	return lResult;
}

LRESULT
CWelcome2Pg::OnPSN_SetActive(
							 HWND hwnd, 
							 INT idCtl, 
							 LPPSHNOTIFY pnmh
							 )
{
	// Call the base class
	WizardPage::OnPSN_SetActive(hwnd, idCtl, pnmh);

	// Make sure our check boxes reflect any change in the minimal
	// font size specified by g_Options.m_nMinimalFontSize
	if(g_Options.m_bWelcomePageTouched)
	{
		g_Options.m_bWelcomePageTouched = FALSE;
		SetCheckBoxesFromWelcomePageInfo();
	}
	
	return TRUE;
}

LRESULT
CWelcome2Pg::OnPSN_WizNext(
						   HWND hwnd,
						   INT idCtl,
						   LPPSHNOTIFY pnmh
						   )
{
	BOOL bIMenu = Button_GetCheck(GetDlgItem(m_hwnd, IDC_PERMENU));
	
    if (!m_bFontsChanged)
    {
        g_Options.m_schemePreview.m_nSelectedSize = g_Options.m_schemeOriginal.m_nSelectedSize;
    }

	// If Intelli-menus are changed
	if(bIMenu != m_IntlVal)
	{
		HKEY hKey;
		DWORD_PTR result;
		
		LPTSTR psz = bIMenu ?  TEXT("No") : TEXT("Yes");

		// Change the Registry entries....
		if ( ERROR_SUCCESS == RegOpenKey( HKEY_CURRENT_USER, REGSTR_INTELLIMENU, &hKey) )
		{
			RegSetValueEx( hKey, STRMENU, 0, REG_SZ, (LPBYTE)psz,
						(lstrlen(psz) + 1) * sizeof(TCHAR) );

			RegCloseKey(hKey);
		}

		if ( ERROR_SUCCESS == RegOpenKey( HKEY_CURRENT_USER, REGSTR_IE, &hKey) )
		{
			RegSetValueEx( hKey, FAVMENU, 0, REG_SZ, (LPBYTE)psz,
						(lstrlen(psz) + 1) * sizeof(TCHAR) );

			RegCloseKey(hKey);
		}

		m_IntlVal = bIMenu;
		SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 
			(LPARAM) 0, SMTO_ABORTIFHUNG, 5000, &result);
	}

	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
}

LRESULT
CWelcome2Pg::OnPSN_WizBack(
						   HWND hwnd,
						   INT idCtl,
						   LPPSHNOTIFY pnmh
						   )
{
	
    // Undo any changes
	Button_SetCheck(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION), FALSE);
	Button_SetCheck(GetDlgItem(m_hwnd, IDC_CHANGEFONTS), FALSE);
	Button_SetCheck(GetDlgItem(m_hwnd, IDC_USEMAGNIFY), FALSE);
	
    // While going back. Just update variables only. Don't apply changes.
    // DONOT call UpdateControls(): a-anilk

    BOOL bChangeRes = Button_GetCheck(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION));
	BOOL bChangeFont = Button_GetCheck(GetDlgItem(m_hwnd, IDC_CHANGEFONTS));
	BOOL bMagnifier = Button_GetCheck(GetDlgItem(m_hwnd, IDC_USEMAGNIFY));
    m_bFontsChanged = FALSE;

	return WizardPage::OnPSN_WizBack(hwnd, idCtl, pnmh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgsvedef.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGSVEDEF_H
#define _INC_PGSVEDEF_H

#include "pgbase.h"

class CSaveForDefaultUserPg : public WizardPage
{
public:
	CSaveForDefaultUserPg(LPPROPSHEETPAGE ppsp);
	~CSaveForDefaultUserPg(VOID);
	
private:
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
	
};

#endif // _INC_PGSVEDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgtmeout.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGTMEOUT_H
#define _INC_PGTMEOUT_H

#include "pgbase.h"

class CAccessTimeOutPg : public WizardPage
{
public:
	CAccessTimeOutPg(LPPROPSHEETPAGE ppsp);
	~CAccessTimeOutPg(VOID);

protected:
	void UpdateControls();

	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
};



#endif // _INC_PGTMEOUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgtmeout.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgTmeOut.h"

CAccessTimeOutPg::CAccessTimeOutPg(
	LPPROPSHEETPAGE ppsp
	) : WizardPage(ppsp, IDS_WIZACCESSTIMEOUTTITLE, IDS_WIZACCESSTIMEOUTSUBTITLE)
{
	m_dwPageId = IDD_WIZACCESSTIMEOUT;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


CAccessTimeOutPg::~CAccessTimeOutPg(
	VOID
	)
{
}

int g_nTimeOuts = 6;
DWORD g_rgdwTimeOuts[] = {5*60000, 10*60000, 15*60000, 20*60000, 25*60000, 30*60000};

LRESULT
CAccessTimeOutPg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	HWND hwndTimeOut = GetDlgItem(m_hwnd, IDC_TO_TIMEOUTVAL);


	// JMC: TODO: Maybe move these into the string table

	// Set timeouts for 5 to 30 minutes
	int i;
	for (i= 0; i < g_nTimeOuts; i++)
	{
		TCHAR buf[256];
		wsprintf(buf,__TEXT("%d"),g_rgdwTimeOuts[i]/60000);
		ComboBox_InsertString(hwndTimeOut, i, buf);
	}



	BOOL bEnable = g_Options.m_schemePreview.m_ACCESSTIMEOUT.dwFlags & ATF_TIMEOUTON;
	if(bEnable)
	{
		Button_SetCheck(GetDlgItem(m_hwnd, IDC_TO_ENABLE), TRUE);
		EnableWindow (GetDlgItem(m_hwnd,IDC_TO_TIMEOUTVAL),TRUE);
	}
	else
	{
		// Hack for radio buttons
		if(GetDlgItem(m_hwnd, IDC_TO_DISABLE))
			Button_SetCheck(GetDlgItem(m_hwnd, IDC_TO_DISABLE), TRUE);
		EnableWindow (GetDlgItem(m_hwnd,IDC_TO_TIMEOUTVAL),FALSE);
	}

	// Figure out the time to use as default
	int nIndex = 0;
	for(i = g_nTimeOuts - 1;i>=0;i--)
	{
		// Brute Force find the largest value
		if(g_rgdwTimeOuts[i] >= g_Options.m_schemePreview.m_ACCESSTIMEOUT.iTimeOutMSec)
			nIndex = i;
		else
			break;
	}
	ComboBox_SetCurSel(hwndTimeOut, nIndex);

	return 1;
}


void CAccessTimeOutPg::UpdateControls()
{
	// enable/disable the combo box depending on which radio
	// button is selected
	if(Button_GetCheck(GetDlgItem(m_hwnd, IDC_TO_ENABLE)))
	{
		EnableWindow (GetDlgItem(m_hwnd,IDC_TO_TIMEOUTVAL), TRUE);
		EnableWindow (GetDlgItem(m_hwnd,IDC_MIN), TRUE);
	}
	else
	{
		EnableWindow (GetDlgItem(m_hwnd,IDC_TO_TIMEOUTVAL), FALSE);
		EnableWindow (GetDlgItem(m_hwnd,IDC_MIN), FALSE);
	}

}


LRESULT
CAccessTimeOutPg::OnCommand(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LRESULT lResult = 1;

	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID      = LOWORD(wParam);
	HWND hwndCtl     = (HWND)lParam;

	switch(wCtlID)
	{
	case IDC_TO_DISABLE:
	case IDC_TO_ENABLE:
		// These commands require us to re-enable/disable the appropriate controls
		UpdateControls();
		lResult = 0;
		break;

	default:
		break;
	}

	return lResult;
}

LRESULT
CAccessTimeOutPg::OnPSN_WizNext(
						   HWND hwnd,
						   INT idCtl,
						   LPPSHNOTIFY pnmh
						   )
{
	BOOL bUseAccessTimeOut= Button_GetCheck(GetDlgItem(m_hwnd, IDC_TO_ENABLE));

	if(bUseAccessTimeOut)
		g_Options.m_schemePreview.m_ACCESSTIMEOUT.dwFlags |= ATF_TIMEOUTON;
	else
		g_Options.m_schemePreview.m_ACCESSTIMEOUT.dwFlags &= ~ATF_TIMEOUTON;

	int nIndex = ComboBox_GetCurSel(GetDlgItem(m_hwnd, IDC_TO_TIMEOUTVAL));
	g_Options.m_schemePreview.m_ACCESSTIMEOUT.iTimeOutMSec = g_rgdwTimeOuts[nIndex];


	g_Options.ApplyPreview();

	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgwelcom.cpp ===
// Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgWelcom.h"

#include "select.h"
extern HPALETTE g_hpal3D;

UINT IDMapT[3][2] = { 0, IDC_TEXT1,
					  1, IDC_TEXT2,
					  2, IDC_TEXT3
					};

// a-anilk; Re-write to use owner drawn controls: 05/08/99
CWelcomePg::CWelcomePg(
						   LPPROPSHEETPAGE ppsp
						   ) : WizardPage(ppsp, IDS_TEXTSIZETITLE, IDS_TEXTSIZESUBTITLE)
{
	m_dwPageId = IDD_WIZWELCOME;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	
	m_nCurrentHilight = 0;
	m_nCurValueIndex = 0;
}


CWelcomePg::~CWelcomePg(
							VOID
							)
{
}


LRESULT
CWelcomePg::OnCommand(
						HWND hwnd,
						WPARAM wParam,
						LPARAM lParam
						)
{
	LRESULT lResult = 1;
	
	return lResult;
}

LRESULT CWelcomePg::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	SetFocus(GetDlgItem(hwnd, IDC_TEXT1));

	LoadString(g_hInstDll, IDS_WELCOMETEXT1, m_szWelcomeText[0], ARRAYSIZE(m_szWelcomeText[0]));
	LoadString(g_hInstDll, IDS_WELCOMETEXT2, m_szWelcomeText[1], ARRAYSIZE(m_szWelcomeText[1]));
	LoadString(g_hInstDll, IDS_WELCOMETEXT3, m_szWelcomeText[2], ARRAYSIZE(m_szWelcomeText[2]));
	LoadString(g_hInstDll, IDS_WELCOMETEXT4, m_szWelcomeText[3], ARRAYSIZE(m_szWelcomeText[3]));

	LoadArrayFromStringTable(IDS_LKPREV_WELCOME_MINTEXTSIZES, m_rgnValues, &m_nCountValues);

	return 1;
}

void CWelcomePg::InvalidateRects(int PrevHilight)
{
	InvalidateRect(GetDlgItem(m_hwnd, IDMapT[PrevHilight][1]), NULL, TRUE);
}

// These is to set the Focus and sync the painting
LRESULT CWelcomePg::OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
{
	syncInit = FALSE;
	uIDEvent = SetTimer(hwnd, NULL, 100, NULL);
	m_nCurrentHilight = m_nCurValueIndex = 0;

	// Localization taken care... 9,11,15 in JPN
	if ( g_Options.m_nMinimalFontSize <=9 )
		m_nCurrentHilight = 0;
	else if (g_Options.m_nMinimalFontSize <=12 )
		m_nCurrentHilight = 1;
	else if (g_Options.m_nMinimalFontSize <=16 )
		m_nCurrentHilight = 2;

	m_nCurValueIndex = m_nCurrentHilight;

	return 0;
}

LRESULT CWelcomePg::OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
	KillTimer(hwnd, uIDEvent);
	syncInit = TRUE;
	return 1;
}

// Sets the focus to the current item in OnInitDialog. 
void CWelcomePg::SetFocussedItem(int m_nCurrentHilight)
{
	SetFocus(GetDlgItem(m_hwnd, IDMapT[m_nCurrentHilight][1]));
}

LRESULT CWelcomePg::OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	UINT idCtrl = (UINT) wParam;
	LPDRAWITEMSTRUCT lpDrawItemStruct = (LPDRAWITEMSTRUCT) lParam;
	int index;
	
	if ( !syncInit)
		SetFocussedItem(m_nCurrentHilight);


	switch(idCtrl)
	{

	case IDC_TEXT1:
		index = 0;
		break;
	
	case IDC_TEXT2:
		index = 1;
		break;
		
	case IDC_TEXT3:
		index = 2;
		break;

	default:
		_ASSERTE(FALSE);
		return 1;	// Prefix #113778 (this should never happen; only three controls on dialog)
		break;

	}
	
	// For each button, Check the state, And if the button is selected,
	// means that it has current focus, So Re-paint the previously hilighted and 
	// the current selected buttons....
	// Make sure we ignore the initial events so that we minimize the flicker...
	if ( (lpDrawItemStruct->itemState & ODS_FOCUS) && (m_nCurrentHilight != index))
	{
		if ( syncInit )
		{
			// Erase the previous one...
			InvalidateRects(m_nCurrentHilight);
			Sleep(100);
			m_nCurrentHilight= m_nCurValueIndex = index;
		}
	}
	Draw( lpDrawItemStruct, index );

	return 1;
}


void CWelcomePg::Draw(LPDRAWITEMSTRUCT ldi, int i)
{
	int nOldBkMode = SetBkMode(ldi->hDC, TRANSPARENT);
	HDC hdc = ldi->hDC;
	
	RECT rcOriginal = ldi->rcItem;
	HFONT hFontOld = (HFONT)SelectObject(hdc, g_Options.GetClosestMSSansSerif(m_rgnValues[i], (m_nCurrentHilight == i)));
	TextOut(hdc, rcOriginal.left + 10 , rcOriginal.top + 10 - i, m_szWelcomeText[i], lstrlen(m_szWelcomeText[i]));
	SelectObject(hdc, hFontOld);
	
	SetBkMode(ldi->hDC, nOldBkMode);

	//If current hi-lighted item, Then draw the bounding rectangle. 
	if ( m_nCurrentHilight == i)
	{
		DrawHilight(m_hwnd, ldi);
	}
}


LRESULT
CWelcomePg::OnPSN_WizNext(
						   HWND hwnd,
						   INT idCtl,
						   LPPSHNOTIFY pnmh
						   )
{
	// Tell the second page that we've done something
	g_Options.m_bWelcomePageTouched = TRUE;

    // In addition to knowing the actual font size we need to know if it's normal,
    // large or extra large so we can update display CPL on what's happened.
	g_Options.m_nMinimalFontSize = m_rgnValues[m_nCurValueIndex];
    g_Options.m_schemePreview.m_nSelectedSize = m_nCurValueIndex;

	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
#if 0 
	// We are going to allow people to 'back' to this page
	// As a HACK, we want this page to come out only once.
	// If we try to remove ourselves, and the call the
	// default OnPSN_WizNext(), we'll get an assert when
	// that function tries to find the 'next' page.  Instead
	// we manually do the things from OnPSN_WizNext()

	// Remove ourself from the wizard after we select a size.
	DWORD dwTemp = IDD_WIZWELCOME;
	sm_WizPageOrder.RemovePages(&dwTemp, 1);
	SetWindowLong(hwnd, DWL_MSGRESULT, IDD_WIZWELCOME2);
	return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgwelcom.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGWELCOM_H
#define _INC_PGWELCOM_H

#include "pgbase.h"

class CWelcomePg : public WizardPage
{
public:
    CWelcomePg(LPPROPSHEETPAGE ppsp);
    ~CWelcomePg(VOID);

protected:
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	LRESULT OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	inline void InvalidateRects(int PrevHilight);
	LRESULT OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam );
	LRESULT OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	inline void SetFocussedItem(int m_nCurrentHilight);

	TCHAR m_szWelcomeText[4][85];
private:

	void Draw(LPDRAWITEMSTRUCT ldi, int i);
	int m_nCountValues;
	int m_rgnValues[MAX_DISTINCT_VALUES];
	int m_nCurValueIndex;
	int m_nCurrentHilight;
	BOOL syncInit;
	UINT uIDEvent;
};

#endif // _INC_PGWELCOM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgwizopt.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGWIZOPT_H
#define _INC_PGWIZOPT_H

#include "pgbase.h"

class CWizardOptionsPg : public WizardPage
{
public:
	CWizardOptionsPg(LPPROPSHEETPAGE ppsp);
	~CWizardOptionsPg(VOID);

protected:
	BOOL AdjustWizPageOrder();
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
private:
    BOOL restoreOpt;
};

#endif // _INC_PGWIZOPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\precomp.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation

#include "pch.hxx" // PCH
#pragma hdrstop

/////////////////////////////////////////////////////////////////
// This file exists for creating the pre-compiled header only. //
/////////////////////////////////////////////////////////////////

#include "resource.h"

void FixupLogfont(LOGFONT *pLogFont)
{
	TCHAR lfFaceName[LF_FACESIZE];
	_ASSERTE(ARRAYSIZE(lfFaceName) == ARRAYSIZE(pLogFont->lfFaceName));

	// This makes sure that logfonts don't have any garbage characters after the NULL termination
	ZeroMemory(lfFaceName, ARRAYSIZE(lfFaceName));
	lstrcpy(lfFaceName, pLogFont->lfFaceName);
	memcpy(pLogFont->lfFaceName, lfFaceName, ARRAYSIZE(lfFaceName));
}

void GetNonClientMetrics(NONCLIENTMETRICS *pncm, LOGFONT *plfIcon)
{
	ZeroMemory(pncm, sizeof(*pncm));
	ZeroMemory(plfIcon, sizeof(*plfIcon));

	pncm->cbSize = sizeof(*pncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(*pncm), pncm, 0);
	SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(*plfIcon), plfIcon, 0);

	// We fix up the log fonts so they can be compared with our new logfonts by a memcmp() call
	FixupLogfont(&pncm->lfCaptionFont);
	FixupLogfont(&pncm->lfSmCaptionFont);
	FixupLogfont(&pncm->lfMenuFont);
	FixupLogfont(&pncm->lfStatusFont);
	FixupLogfont(&pncm->lfMessageFont);
	FixupLogfont(plfIcon);
}

BOOL IsCurrentFaceNamesDifferent()
{
	TCHAR lfFaceName[LF_FACESIZE];
	LoadString(g_hInstDll, IDS_SYSTEMFONTNAME, lfFaceName, ARRAYSIZE(lfFaceName));
	NONCLIENTMETRICS ncm;
	LOGFONT lfIcon;
	GetNonClientMetrics(&ncm, &lfIcon);
	if(		0 != lstrcmp(lfFaceName, ncm.lfCaptionFont.lfFaceName)
		||	0 != lstrcmp(lfFaceName, ncm.lfSmCaptionFont.lfFaceName)
		||	0 != lstrcmp(lfFaceName, ncm.lfMenuFont.lfFaceName)
		||	0 != lstrcmp(lfFaceName, ncm.lfStatusFont.lfFaceName)
		||	0 != lstrcmp(lfFaceName, ncm.lfMessageFont.lfFaceName)
		||	0 != lstrcmp(lfFaceName, lfIcon.lfFaceName) )
	{
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\schemes.h ===
//Copyright (c) 1997-2000 Microsoft Corporation

#ifndef _INC_SCHEMES_H
#define _INC_SCHEMES_H

// HACK - THESE VALUES ARE HARD CODED
#define COLOR_MAX_95_NT4		25
#if(WINVER >= 0x0501)
#define COLOR_MAX_97_NT5		31
#elif(WINVER == 0x0500)
#define COLOR_MAX_97_NT5		29
#else
#define COLOR_MAX_97_NT5		25
#endif

#define MAX_THEME_SZ 512
#define MAX_NUM_SZ 20
#define DEF_SPACING 43  // default horizontal and vertical icon spacing

#define CONTROL_PANEL_DESKTOP TEXT("Control Panel\\Desktop")
#define CURSOR_BLINK_RATE TEXT("CursorBlinkRate")
#define DEFAULT_BLINK_RATE 530
DWORD WINAPI RegQueryStrDW(DWORD dwDefault, HKEY hkey, LPTSTR lpSubKey, LPTSTR lpValueName);
BOOL RegSetStrDW(HKEY hkey, LPTSTR lpSection, LPCTSTR lpKeyName, DWORD dwValue);

#include "resource.h"

#include "CurSchme.h"

// Specify all external variables
extern PTSTR s_pszColorNames[]; // JMC: HACK
extern TCHAR g_szColors[]; // = TEXT("colors");           // colors section name

// Location of the Colors subkey in Registry; Defined in RegStr.h
extern TCHAR szRegStr_Colors[]; // = REGSTR_PATH_COLORS;

extern TCHAR g_winScheme[];

// Scheme data used locally by this app - NOTE: This structure
// does NOT use or need the A and W forms for its members.  The other schemedata's
// MUST use the A and W forms since that's how they are stored in the registry
typedef struct {
	int nNameStringId;       // the rid of the name of the color scheme
    TCHAR szNameIndexId[MAX_NUM_SZ]; // the index into HKCU\Control Panel\Appearance\New Schemes
	int nColorsUsed;
    COLORREF rgb[COLOR_MAX_97_NT5];
} SCHEMEDATALOCAL;


struct PORTABLE_NONCLIENTMETRICS
{
	// Non-ClientMetric storage area
	int m_iBorderWidth;
	int m_iScrollWidth;
	int m_iScrollHeight;
	int m_iCaptionWidth;
	int m_iCaptionHeight;
	int m_lfCaptionFont_lfHeight;
	int m_lfCaptionFont_lfWeight;
	int m_iSmCaptionWidth;
	int m_iSmCaptionHeight;
	int m_lfSmCaptionFont_lfHeight;
	int m_lfSmCaptionFont_lfWeight;
	int m_iMenuWidth;
	int m_iMenuHeight;
	int m_lfMenuFont_lfHeight;
	int m_lfMenuFont_lfWeight;
	int m_lfStatusFont_lfHeight;
	int m_lfStatusFont_lfWeight;
	int m_lfMessageFont_lfHeight;
	int m_lfMessageFont_lfWeight;
	int m_lfIconWindowsDefault_lfHeight;
	int m_lfIconWindowsDefault_lfWeight;

	int m_nFontFaces; // 0 = NoChanges, 1 = Use WindowsDefault font face

	void SetToWindowsDefault()
	{
		m_nFontFaces = 1;

		int rgnValues[MAX_DISTINCT_VALUES];
		int nCountValues;
		LoadArrayFromStringTable(IDS_WINDOWSDEFAULTSIZES, rgnValues, &nCountValues);
		_ASSERTE(21 == nCountValues);
		if(21 != nCountValues)
		{
			// Below is the hard-coded defaults for the window metrics
			m_iBorderWidth = 1;
			m_iScrollWidth = 16;
			m_iScrollHeight = 16;
			m_iCaptionWidth = 18;
			m_iCaptionHeight = 18;
			m_lfCaptionFont_lfHeight = -11;
			m_lfCaptionFont_lfWeight = 700;
			m_iSmCaptionWidth = 15;
			m_iSmCaptionHeight = 15;
			m_lfSmCaptionFont_lfHeight = -11;
			m_lfSmCaptionFont_lfWeight = 700;
			m_iMenuWidth = 18;
			m_iMenuHeight = 18;
			m_lfMenuFont_lfHeight = -11;
			m_lfMenuFont_lfWeight = 400;
			m_lfStatusFont_lfHeight = -11;
			m_lfStatusFont_lfWeight = 400;
			m_lfMessageFont_lfHeight = -11;
			m_lfMessageFont_lfWeight = 400;
			m_lfIconWindowsDefault_lfHeight = -11;
			m_lfIconWindowsDefault_lfWeight = 400;
		}
		else
		{
			m_iBorderWidth = rgnValues[0];
			m_iScrollWidth = rgnValues[1];
			m_iScrollHeight = rgnValues[2];
			m_iCaptionWidth = rgnValues[3];
			m_iCaptionHeight = rgnValues[4];
			m_lfCaptionFont_lfHeight = rgnValues[5];
			m_lfCaptionFont_lfWeight = rgnValues[6];
			m_iSmCaptionWidth = rgnValues[7];
			m_iSmCaptionHeight = rgnValues[8];
			m_lfSmCaptionFont_lfHeight = rgnValues[9];
			m_lfSmCaptionFont_lfWeight = rgnValues[10];
			m_iMenuWidth = rgnValues[11];
			m_iMenuHeight = rgnValues[12];
			m_lfMenuFont_lfHeight = rgnValues[13];
			m_lfMenuFont_lfWeight = rgnValues[14];
			m_lfStatusFont_lfHeight = rgnValues[15];
			m_lfStatusFont_lfWeight = rgnValues[16];
			m_lfMessageFont_lfHeight = rgnValues[17];
			m_lfMessageFont_lfWeight = rgnValues[18];
			m_lfIconWindowsDefault_lfHeight = rgnValues[19];
			m_lfIconWindowsDefault_lfWeight = rgnValues[20];
		}
	}

	void LoadOriginal()
	{
		NONCLIENTMETRICS ncmTemp;
		LOGFONT lfIcon;
		GetNonClientMetrics(&ncmTemp, &lfIcon);

		m_iBorderWidth = ncmTemp.iBorderWidth;
		m_iScrollWidth = ncmTemp.iScrollWidth;
		m_iScrollHeight = ncmTemp.iScrollHeight;
		m_iCaptionWidth = ncmTemp.iCaptionWidth;
		m_iCaptionHeight = ncmTemp.iCaptionHeight;
		m_lfCaptionFont_lfHeight = ncmTemp.lfCaptionFont.lfHeight;
		m_lfCaptionFont_lfWeight = ncmTemp.lfCaptionFont.lfWeight;
		m_iSmCaptionWidth = ncmTemp.iSmCaptionWidth;
		m_iSmCaptionHeight = ncmTemp.iSmCaptionHeight;
		m_lfSmCaptionFont_lfHeight = ncmTemp.lfSmCaptionFont.lfHeight;
		m_lfSmCaptionFont_lfWeight = ncmTemp.lfSmCaptionFont.lfWeight;
		m_iMenuWidth = ncmTemp.iMenuWidth;
		m_iMenuHeight = ncmTemp.iMenuHeight;
		m_lfMenuFont_lfHeight = ncmTemp.lfMenuFont.lfHeight;
		m_lfMenuFont_lfWeight = ncmTemp.lfMenuFont.lfWeight;
		m_lfStatusFont_lfHeight = ncmTemp.lfStatusFont.lfHeight;
		m_lfStatusFont_lfWeight = ncmTemp.lfStatusFont.lfWeight;
		m_lfMessageFont_lfHeight = ncmTemp.lfMessageFont.lfHeight;
		m_lfMessageFont_lfWeight = ncmTemp.lfMessageFont.lfWeight;
		m_lfIconWindowsDefault_lfHeight = lfIcon.lfHeight;
		m_lfIconWindowsDefault_lfWeight = lfIcon.lfWeight;

		m_nFontFaces = 0;
	}

	void ApplyChanges() const;

};

struct WIZSCHEME
{
	WIZSCHEME()
	{
		ZeroMemory(this, sizeof(*this));
		m_cbSize = sizeof(*this);
		m_dwVersion = 0x000000FF;
		ClearTheme();
		ClearWallpaper();
        m_nSelectedSize = -1;
        m_szSelectedStyle[0] = 0;
	}
	DWORD m_cbSize;
	DWORD m_dwVersion;

	COLORREF m_rgb[COLOR_MAX_97_NT5];
	void LoadOriginal();

	FILTERKEYS m_FILTERKEYS;
	MOUSEKEYS m_MOUSEKEYS;
	STICKYKEYS m_STICKYKEYS;
	TOGGLEKEYS m_TOGGLEKEYS;
	SOUNDSENTRY m_SOUNDSENTRY;
	ACCESSTIMEOUT m_ACCESSTIMEOUT;
//	SERIALKEYS m_SERIALKEYS;

	BOOL m_bShowSounds;
	BOOL m_bShowExtraKeyboardHelp;
	BOOL m_bSwapMouseButtons;
	int m_nMouseTrails;
	int m_nMouseSpeed;
	int m_nIconSize;
	int m_nCursorScheme;
	// int m_nScrollWidth;
	// int m_nBorderWidth;

	PORTABLE_NONCLIENTMETRICS m_PortableNonClientMetrics;


#ifdef _DEBUG
	void Dump()
	{
		FILE *pStream = fopen( "c:\\txt.acw", "w" );
		if(pStream)
		{
			for(int i=0;i<COLOR_MAX_97_NT5;i++)
				fprintf(pStream, "m_rgb[%2i] = RGB(%3i,%3i,%3i);\r\n", i, GetRValue(m_rgb[i]), GetGValue(m_rgb[i]), GetBValue(m_rgb[i]));
#define TEMP_MAC(xxx, yyy) fprintf(pStream, "m_" #xxx "." #yyy " = %i;\r\n", m_##xxx.yyy)
			TEMP_MAC(FILTERKEYS, cbSize);
			TEMP_MAC(FILTERKEYS, dwFlags);
			TEMP_MAC(FILTERKEYS, iWaitMSec);
			TEMP_MAC(FILTERKEYS, iDelayMSec);
			TEMP_MAC(FILTERKEYS, iRepeatMSec);
			TEMP_MAC(FILTERKEYS, iBounceMSec);

			TEMP_MAC(MOUSEKEYS, cbSize);
			TEMP_MAC(MOUSEKEYS, dwFlags);
			TEMP_MAC(MOUSEKEYS, iMaxSpeed);
			TEMP_MAC(MOUSEKEYS, iTimeToMaxSpeed);
			TEMP_MAC(MOUSEKEYS, iCtrlSpeed);
			TEMP_MAC(MOUSEKEYS, dwReserved1);
			TEMP_MAC(MOUSEKEYS, dwReserved2);

			TEMP_MAC(STICKYKEYS, cbSize);
			TEMP_MAC(STICKYKEYS, dwFlags);

			TEMP_MAC(TOGGLEKEYS, cbSize);
			TEMP_MAC(TOGGLEKEYS, dwFlags);

			TEMP_MAC(SOUNDSENTRY, cbSize);
			TEMP_MAC(SOUNDSENTRY, dwFlags);
			TEMP_MAC(SOUNDSENTRY, iFSTextEffect);
			TEMP_MAC(SOUNDSENTRY, iFSTextEffectMSec);
			TEMP_MAC(SOUNDSENTRY, iFSTextEffectColorBits);
			TEMP_MAC(SOUNDSENTRY, iFSGrafEffect);
			TEMP_MAC(SOUNDSENTRY, iFSGrafEffectMSec);
			TEMP_MAC(SOUNDSENTRY, iFSGrafEffectColor);
			TEMP_MAC(SOUNDSENTRY, iWindowsEffect);
			TEMP_MAC(SOUNDSENTRY, iWindowsEffectMSec);
			TEMP_MAC(SOUNDSENTRY, lpszWindowsEffectDLL);
			TEMP_MAC(SOUNDSENTRY, iWindowsEffectOrdinal);

			TEMP_MAC(ACCESSTIMEOUT, cbSize);
			TEMP_MAC(ACCESSTIMEOUT, dwFlags);
			TEMP_MAC(ACCESSTIMEOUT, iTimeOutMSec);

#define TEMP_MAC2(xxx) fprintf(pStream, #xxx " = %i;\r\n", xxx)
			TEMP_MAC2(m_bShowSounds);
			TEMP_MAC2(m_bShowExtraKeyboardHelp);
			TEMP_MAC2(m_bSwapMouseButtons);
			TEMP_MAC2(m_nMouseTrails);
			TEMP_MAC2(m_nMouseSpeed);
			TEMP_MAC2(m_nIconSize);
			TEMP_MAC2(m_nCursorScheme);

			NONCLIENTMETRICS ncm;
			LOGFONT lf;
			GetNonClientMetrics(&ncm, &lf);

#define TEMP_MAC3(xxx) fprintf(pStream, "m_ncmWindowsDefault." #xxx " = %i;\n", ncm.xxx)
#define TEMP_MAC4(xxx) fprintf(pStream, "m_ncmWindowsDefault." #xxx ".lfHeight = %i;\nm_ncmWindowsDefault." #xxx ".lfWeight = %i;\n", ncm.xxx.lfHeight, ncm.xxx.lfWeight)
			TEMP_MAC3(cbSize);
			TEMP_MAC3(iBorderWidth);
			TEMP_MAC3(iScrollWidth);
			TEMP_MAC3(iScrollHeight);
			TEMP_MAC3(iCaptionWidth);
			TEMP_MAC3(iCaptionHeight);
			TEMP_MAC4(lfCaptionFont);
			TEMP_MAC3(iSmCaptionWidth);
			TEMP_MAC3(iSmCaptionHeight);
			TEMP_MAC4(lfSmCaptionFont);
			TEMP_MAC3(iMenuWidth);
			TEMP_MAC3(iMenuHeight);
			TEMP_MAC4(lfMenuFont);
			TEMP_MAC4(lfStatusFont);
			TEMP_MAC4(lfMessageFont);

			fprintf(pStream, "m_lfIconWindowsDefault.lfHeight = %i;\nm_lfIconWindowsDefault.lfWeight = %i;\n", lf.lfHeight, lf.lfWeight);


			// Print for string table
#undef TEMP_MAC3
#undef TEMP_MAC4
#define TEMP_MAC3(xxx) fprintf(pStream, "%i ", ncm.xxx)
#define TEMP_MAC4(xxx) fprintf(pStream, "%i %i ", ncm.xxx.lfHeight, ncm.xxx.lfWeight)
			TEMP_MAC3(cbSize);
			TEMP_MAC3(iBorderWidth);
			TEMP_MAC3(iScrollWidth);
			TEMP_MAC3(iScrollHeight);
			TEMP_MAC3(iCaptionWidth);
			TEMP_MAC3(iCaptionHeight);
			TEMP_MAC4(lfCaptionFont);
			TEMP_MAC3(iSmCaptionWidth);
			TEMP_MAC3(iSmCaptionHeight);
			TEMP_MAC4(lfSmCaptionFont);
			TEMP_MAC3(iMenuWidth);
			TEMP_MAC3(iMenuHeight);
			TEMP_MAC4(lfMenuFont);
			TEMP_MAC4(lfStatusFont);
			TEMP_MAC4(lfMessageFont);

			fprintf(pStream, "%i %i\n", lf.lfHeight, lf.lfWeight);

			fclose(pStream);
		}

	}
#endif

	void SetToWindowsDefault()
	{
		m_rgb[ 0] = RGB(212,208,200); //192,192,192
		m_rgb[ 1] = RGB( 58,110,165);
		m_rgb[ 2] = RGB( 10, 36,106); // 0,0,128
		m_rgb[ 3] = RGB(128,128,128);
		m_rgb[ 4] = RGB(212,208,200); //192,192,192
		m_rgb[ 5] = RGB(255,255,255);
		m_rgb[ 6] = RGB(  0,  0,  0);
		m_rgb[ 7] = RGB(  0,  0,  0);
		m_rgb[ 8] = RGB(  0,  0,  0);
		m_rgb[ 9] = RGB(255,255,255);
		m_rgb[10] = RGB(212,208,200); //192,192,192
		m_rgb[11] = RGB(212,208,200); //192,192,192
		m_rgb[12] = RGB(128,128,128);
		m_rgb[13] = RGB( 10, 36,106); // 0,0,128
		m_rgb[14] = RGB(255,255,255);
		m_rgb[15] = RGB(212,208,200); //192,192,192
		m_rgb[16] = RGB(128,128,128);
		m_rgb[17] = RGB(128,128,128);
		m_rgb[18] = RGB(  0,  0,  0);
		m_rgb[19] = RGB(212,208,200); //192,192,192
		m_rgb[20] = RGB(255,255,255);
		m_rgb[21] = RGB( 81, 81, 75); // 0,0,0
		m_rgb[22] = RGB(236,234,231); // 192,192,192
		m_rgb[23] = RGB(  0,  0,  0);
		m_rgb[24] = RGB(255,255,225);
		m_rgb[25] = RGB(181,181,181); // button alternate face
		m_rgb[26] = RGB(  0,  0,128); 
		m_rgb[27] = RGB( 166,202,240); // 16,132,208
		m_rgb[28] = RGB(192,192,192); // 181,181,181

		ClearTheme();
		ClearWallpaper();

		m_FILTERKEYS.cbSize = 24;
		m_FILTERKEYS.dwFlags = 126;
		m_FILTERKEYS.iWaitMSec = 1000;
		m_FILTERKEYS.iDelayMSec = 1000; //500
		m_FILTERKEYS.iRepeatMSec = 500; //1000
		m_FILTERKEYS.iBounceMSec = 0;
		m_MOUSEKEYS.cbSize = 28;
		m_MOUSEKEYS.dwFlags = 62; //58
		m_MOUSEKEYS.iMaxSpeed = 40;
		m_MOUSEKEYS.iTimeToMaxSpeed = 300;
		m_MOUSEKEYS.iCtrlSpeed = 80;
		m_MOUSEKEYS.dwReserved1 = 0;
		m_MOUSEKEYS.dwReserved2 = 0;
		m_STICKYKEYS.cbSize = 8;
		m_STICKYKEYS.dwFlags = 510; //506
		m_TOGGLEKEYS.cbSize = 8;
		m_TOGGLEKEYS.dwFlags = 30; //26
		m_SOUNDSENTRY.cbSize = 48;
		m_SOUNDSENTRY.dwFlags = 2;
		m_SOUNDSENTRY.iFSTextEffect = 2;
		m_SOUNDSENTRY.iFSTextEffectMSec = 500;
		m_SOUNDSENTRY.iFSTextEffectColorBits = 0;
		m_SOUNDSENTRY.iFSGrafEffect = 3;
		m_SOUNDSENTRY.iFSGrafEffectMSec = 500;
		m_SOUNDSENTRY.iFSGrafEffectColor = 0;
		m_SOUNDSENTRY.iWindowsEffect = 1;
		m_SOUNDSENTRY.iWindowsEffectMSec = 500;
		m_SOUNDSENTRY.lpszWindowsEffectDLL = 0;
		m_SOUNDSENTRY.iWindowsEffectOrdinal = 0;
		m_ACCESSTIMEOUT.cbSize = 12;
		m_ACCESSTIMEOUT.dwFlags = 2; //3
		m_ACCESSTIMEOUT.iTimeOutMSec = 300000;
		m_bShowSounds = 0;
		m_bShowExtraKeyboardHelp = 0;
		m_bSwapMouseButtons = 0;
		m_nMouseTrails = 0;
		m_nMouseSpeed = 10;
        m_dwCaretWidth = 1;
        m_uCursorBlinkTime = 530;
		m_nIconSize = 32;
		m_nCursorScheme = 1;


		_ASSERTE(sizeof(m_FILTERKEYS) == m_FILTERKEYS.cbSize);
		_ASSERTE(sizeof(m_MOUSEKEYS) == m_MOUSEKEYS.cbSize);
		_ASSERTE(sizeof(m_STICKYKEYS) == m_STICKYKEYS.cbSize);
		_ASSERTE(sizeof(m_TOGGLEKEYS) == m_TOGGLEKEYS.cbSize);
		_ASSERTE(sizeof(m_SOUNDSENTRY) == m_SOUNDSENTRY.cbSize);
		_ASSERTE(sizeof(m_ACCESSTIMEOUT) == m_ACCESSTIMEOUT.cbSize);

		m_PortableNonClientMetrics.SetToWindowsDefault();

	}

	void AddChangesLine(int nId, LPTSTR szBuffer)
	{
		TCHAR szTemp[80];
		LoadString(g_hInstDll, nId, szTemp, ARRAYSIZE(szTemp));
		lstrcat(szBuffer, szTemp);
		lstrcat(szBuffer, __TEXT("\r\n"));
	}

	void ReportChanges(const WIZSCHEME &schemeOriginal, HWND hwndChanges)
	{
		TCHAR szChanges[80*20];
		szChanges[0] = 0;

		// Check for change in colors
		if(0 != memcmp(schemeOriginal.m_rgb, m_rgb, sizeof(m_rgb)))
			AddChangesLine(IDS_CHANGESCOLOR, szChanges);

#define TEST_CHANGES(xxx) if(0 != memcmp(&schemeOriginal.m_##xxx, &m_##xxx, sizeof(schemeOriginal.m_##xxx))) AddChangesLine(IDS_CHANGES##xxx, szChanges)
 		TEST_CHANGES(FILTERKEYS);
		TEST_CHANGES(MOUSEKEYS);
		TEST_CHANGES(STICKYKEYS);
		TEST_CHANGES(TOGGLEKEYS);
		TEST_CHANGES(SOUNDSENTRY);
		TEST_CHANGES(ACCESSTIMEOUT);
//		TEST_CHANGES(SERIALKEYS);

#define TEST_CHANGES2(xxx) if(schemeOriginal.m_b##xxx != m_b##xxx) AddChangesLine(IDS_CHANGES##xxx, szChanges)
 		TEST_CHANGES2(ShowSounds);
		TEST_CHANGES2(ShowExtraKeyboardHelp);
		TEST_CHANGES2(SwapMouseButtons);

#define TEST_CHANGES3(xxx) if(schemeOriginal.m_n##xxx != m_n##xxx) AddChangesLine(IDS_CHANGES##xxx, szChanges)
		TEST_CHANGES3(MouseTrails);
		TEST_CHANGES3(MouseSpeed);
		TEST_CHANGES3(IconSize);
		TEST_CHANGES3(CursorScheme);

        // Add Caret changes
        if (schemeOriginal.m_dwCaretWidth != m_dwCaretWidth)
            AddChangesLine(IDS_CHANGESCaretWidth, szChanges);
        if (schemeOriginal.m_uCursorBlinkTime != m_uCursorBlinkTime)
            AddChangesLine(IDS_CHANGESBlinkRate, szChanges);

		// TODO: ScrollWidth and BorderWidth have been removed

		// TODO: This provieds only one broad change line for all metric changes (including border/scroll bar)
		// NOTE: we have to check if any of our portable metrics are different, OR, windows is currently
		// not using the default windows font.
		PORTABLE_NONCLIENTMETRICS pncm1(schemeOriginal.m_PortableNonClientMetrics);
		PORTABLE_NONCLIENTMETRICS pncm2(m_PortableNonClientMetrics);
		pncm1.m_nFontFaces = pncm2.m_nFontFaces = 0; // WE MUST IGNORE THIS VALUE WHEN COMPARING

		if(		0 != memcmp(&pncm1, &pncm2, sizeof(pncm1))
			||	(m_PortableNonClientMetrics.m_nFontFaces == 1 && IsCurrentFaceNamesDifferent()))
			AddChangesLine(IDS_CHANGESNONCLIENTMETRICS, szChanges);

		if(!lstrlen(szChanges))
			AddChangesLine(IDS_CHANGESNOCHANGES, szChanges);

		SetWindowText(hwndChanges, szChanges);
	}

    void ApplyChanges(const WIZSCHEME &schemeNew, NONCLIENTMETRICS *pForceNCM = NULL, LOGFONT *pForcelfIcon = NULL);


	////////////////////////////////////////////////////////////
	// Setting the icon size

	static DWORD SetShellLargeIconSize( DWORD dwNewSize )
	{
		#define MAX_LENGTH   512
		HKEY   hKey;
		DWORD   dwOldSize = dwNewSize;

		// open the registry
		if (ERROR_SUCCESS == RegOpenKey( HKEY_CURRENT_USER
                                , TEXT("Control Panel\\desktop\\WindowMetrics"),&hKey))
        {
            DWORD   dwLength = MAX_LENGTH, dwType = REG_SZ;
		    TCHAR   szBuffer[MAX_LENGTH];

		    // get the last size so we can return it
		    if (ERROR_SUCCESS == RegQueryValueEx( hKey, TEXT("Shell Icon Size")
                                        , NULL, &dwType, (LPBYTE)szBuffer, &dwLength))
            {
		        dwOldSize = _ttol( szBuffer );

		        // We will allow only values >=16 and <=72
		        if( (dwNewSize>=16) && (dwNewSize<=72) )
		        {
                    // get the current cell size of icon (includes spacing)
                    ICONMETRICS iconmetrics;
                    iconmetrics.cbSize = sizeof(ICONMETRICS);
                    SystemParametersInfo(SPI_GETICONMETRICS, sizeof(ICONMETRICS), &iconmetrics, 0);

                    // compute the new cell size (including spacing)
                    iconmetrics.iHorzSpacing = dwNewSize + DEF_SPACING;
                    iconmetrics.iVertSpacing = iconmetrics.iHorzSpacing;

                    // update both the icon size and icon cell size and send notifications
			        wsprintf( szBuffer, TEXT("%d"), dwNewSize );
			        RegSetValueEx( hKey, TEXT("Shell Icon Size"), 0, REG_SZ, (LPBYTE)szBuffer,
					        (lstrlen(szBuffer) + 1) * sizeof(TCHAR) );

                    SystemParametersInfo(SPI_SETICONMETRICS, sizeof(ICONMETRICS)
                                        , &iconmetrics, SPIF_SENDWININICHANGE);
			        SendMessage( HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETICONMETRICS
                                        , 0/*(LPARAM)("WindowMetrics")*/ );
		        }
            }
		    // Clean up
		    RegCloseKey( hKey );
        }
		// Let everyone know that things changed
		return dwOldSize;
		#undef MAX_LENGTH
	}

    ///////////////////////////////////////////////////////////////////////////
    // New in Whistler
    ///////////////////////////////////////////////////////////////////////////

    DWORD m_dwCaretWidth;
    UINT m_uCursorBlinkTime;

	TCHAR m_szWallpaper[MAX_THEME_SZ];
	TCHAR m_szThemeName[MAX_THEME_SZ];
	TCHAR m_szThemeColor[MAX_THEME_SZ];
	TCHAR m_szThemeSize[MAX_THEME_SZ];
    BOOL m_fFlatMenus;
    BOOL m_fDropShadows;
    TCHAR m_szSelectedStyle[MAX_NUM_SZ];    // this is a number 0 thru 21 (21 color schemes)
    int m_nSelectedSize;                    // this is a number 0 thru 3 (normal, large, extra large)

    void UpdateSelectedSize(int nSelectedSize, LPCTSTR pszSelectedStyle);
	void SetHCFlag(BOOL fSetOn);
	void SaveTheme();
	BOOL SetTheme(LPCTSTR pszThemeName, LPCTSTR pszThemeColor, LPCTSTR pszThemeSize);
	void ClearTheme()
	{
		m_szThemeName[0] = 0;
		m_szThemeColor[0] = 0;
		m_szThemeSize[0] = 0;
	}
	void SaveWallpaper();
	void SetWallpaper(LPCTSTR pszWallpaper);
	void ClearWallpaper()
	{
		m_szWallpaper[0] = 0;
	}
    void SetStyleNSize();
};

int GetSchemeCount();
void GetSchemeName(int nIndex, LPTSTR lpszName, int nLen);
SCHEMEDATALOCAL &GetScheme(int nIndex);

//////////////////////////////////////////////////////////////////////////////////
// Legacy scheme structures - only used for reading ACW files
//////////////////////////////////////////////////////////////////////////////////


#define COLOR_MAX_WIN9X 25
#define COLOR_MAX_NT400 25
#define COLOR_MAX_NT500 29
#define COLOR_MAX_NT501 31

#define WIZSCHEME_LEGACY_STRUCT(szStruct, szName, nColors) \
    struct szStruct \
    { \
	    szStruct() \
	    { \
		    ZeroMemory(this, sizeof(*this)); \
		    m_cbSize = sizeof(*this); \
		    m_dwVersion = 0x000000FF; \
	    } \
	    DWORD m_cbSize; \
	    DWORD m_dwVersion; \
	    COLORREF m_rgb[nColors]; \
	    FILTERKEYS m_FILTERKEYS; \
	    MOUSEKEYS m_MOUSEKEYS; \
	    STICKYKEYS m_STICKYKEYS; \
	    TOGGLEKEYS m_TOGGLEKEYS; \
	    SOUNDSENTRY m_SOUNDSENTRY; \
	    ACCESSTIMEOUT m_ACCESSTIMEOUT; \
	    BOOL m_bShowSounds; \
	    BOOL m_bShowExtraKeyboardHelp; \
	    BOOL m_bSwapMouseButtons; \
	    int m_nMouseTrails; \
	    int m_nMouseSpeed; \
	    int m_nIconSize; \
	    int m_nCursorScheme; \
	    PORTABLE_NONCLIENTMETRICS m_PortableNonClientMetrics; \
    } szName;

#define WIZSCHEME_COPY_LEGACY(dst, src) \
{ \
    /* ignore m_cbSize */ \
	 dst.m_dwVersion = src.m_dwVersion; \
	 memcpy(dst.m_rgb, src.m_rgb, min(sizeof(dst.m_rgb), sizeof(src.m_rgb))); \
	 dst.m_FILTERKEYS= src.m_FILTERKEYS; \
	 dst.m_MOUSEKEYS= src.m_MOUSEKEYS; \
	 dst.m_STICKYKEYS= src.m_STICKYKEYS; \
	 dst.m_TOGGLEKEYS= src.m_TOGGLEKEYS; \
	 dst.m_SOUNDSENTRY= src.m_SOUNDSENTRY; \
	 dst.m_ACCESSTIMEOUT= src.m_ACCESSTIMEOUT; \
	 dst.m_bShowSounds= src.m_bShowSounds; \
	 dst.m_bShowExtraKeyboardHelp= src.m_bShowExtraKeyboardHelp; \
	 dst.m_bSwapMouseButtons= src.m_bSwapMouseButtons; \
	 dst.m_nMouseTrails= src.m_nMouseTrails; \
	 dst.m_nMouseSpeed= src.m_nMouseSpeed; \
	 dst.m_nIconSize= src.m_nIconSize; \
	 dst.m_nCursorScheme= src.m_nCursorScheme; \
	 dst.m_PortableNonClientMetrics= src.m_PortableNonClientMetrics; \
}


///////////////////////////////////////////
// Stuff for Fonts
int GetFontCount();
void GetFontLogFont(int nIndex, LOGFONT *pLogFont);

#endif // _INC_SCHEMES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\select.cpp ===
// Copyright (c) 1997-2000 Microsoft Corporation
//  Select.cpp

#include "pch.hxx" // PCH
#pragma hdrstop

#include "pgbase.h"
#include "AccWiz.h"
#include "resource.h"
#include "Select.h"

extern HPALETTE g_hpal3D;

// Re-Write to use owner drawn controls....:a-anilk
//////////////////////////////////////////////////////////////
// CIconSizePg member functions
//
UINT IDMap[3][2] = { 0, IDC_ICON1,
					 1, IDC_ICON2,
					 2, IDC_ICON3
					};
			

CIconSizePg::CIconSizePg(LPPROPSHEETPAGE ppsp)
				: WizardPage(ppsp, IDS_LKPREV_ICONTITLE, IDS_LKPREV_ICONSUBTITLE)
{
	m_dwPageId = IDD_PREV_ICON2;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	m_nCountValues = 3;
	m_rgnValues[0] = 32;
	m_rgnValues[1] = 48;
	m_rgnValues[2] = 64;
}

LRESULT CIconSizePg::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	// Initialize the current selection..
	if(g_Options.m_schemePreview.m_nIconSize <= 32)
		m_nCurValueIndex = 0;
	else if(g_Options.m_schemePreview.m_nIconSize <= 48)
		m_nCurValueIndex = 1;
	else
		m_nCurValueIndex = 2;

	m_nCurrentHilight = m_nCurValueIndex;

	return 1;
}


// These is to set the Focus and sync the painting
LRESULT CIconSizePg::OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
{
	syncInit = FALSE;
	uIDEvent = SetTimer(hwnd, NULL, 100, NULL);
	return 0;
}

LRESULT CIconSizePg::OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
	KillTimer(hwnd, uIDEvent);
	syncInit = TRUE;
	return 1;
}

// Selection has chnaged, So Apply for preview. 
LRESULT CIconSizePg::SelectionChanged(int nNewSelection)
{
	g_Options.m_schemePreview.m_nIconSize = m_rgnValues[nNewSelection];
	g_Options.ApplyPreview();

	return 0;
}

// Re-paints the previous radio control. 
void CIconSizePg::InvalidateRects(int PrevHilight)
{
	InvalidateRect(GetDlgItem(m_hwnd, IDMap[PrevHilight][1]), NULL, TRUE);
}

// Sets the focus to the current item in OnInitDialog. 
void CIconSizePg::SetFocussedItem(int m_nCurrentHilight)
{
	SetFocus(GetDlgItem(m_hwnd, IDMap[m_nCurrentHilight][1]));
}

// DrawItem. Handles painting checks the focussed item 
// to determine selection changes
LRESULT CIconSizePg::OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	UINT idCtrl = (UINT) wParam;
	LPDRAWITEMSTRUCT lpDrawItemStruct = (LPDRAWITEMSTRUCT) lParam;
	int index;
	BOOL hasChanged = FALSE;

	if ( !syncInit)
		SetFocussedItem(m_nCurrentHilight);

	switch(idCtrl)
	{

	case IDC_ICON1:
		index = 0;
		break;
	
	case IDC_ICON2:
		index = 1;
		break;
		
	case IDC_ICON3:
		index = 2;
		break;

	default:
		_ASSERTE(FALSE);
		return 1;	// Prefix #113781 (this should never happen; only three controls on dialog)
		break;
	}
	
	// For each button, Check the state, And if the button is selected,
	// means that it has current focus, So Re-paint the previously hilighted and 
	// the current selected buttons....
	// Make sure we ignore the initial events so that we minimize the flicker...
	if ( (lpDrawItemStruct->itemState & ODS_FOCUS) && (m_nCurrentHilight != index))
	{
		// If focussed item!
		if ( syncInit )
		{
			// Erase the previous one...
			InvalidateRects(m_nCurrentHilight);
			m_nCurrentHilight= m_nCurValueIndex = index;
			
			SelectionChanged(m_nCurValueIndex);
		}
	}

	Draw( lpDrawItemStruct, index );

	return 1;
}



void CIconSizePg::Draw(LPDRAWITEMSTRUCT ldi, int i)
{
	HDC hdc = ldi->hDC;

	int nOldBkMode = SetBkMode(hdc, TRANSPARENT);
	int nOldAlign = SetTextAlign(hdc, TA_CENTER);
	
	RECT rcOriginal = ldi->rcItem ;
	TCHAR sz[100];
	LPCTSTR szBitmap = NULL;
	int nFontSize = 8;
	int nOffset = 0;
	HBITMAP hBitmap;

	switch(i)
	{
	case 0:
		szBitmap = __TEXT("IDB_ICON_SAMPLE_NORMAL2"); // NO NEED TO LOCALIZE

		LoadString(g_hInstDll, IDS_ICONSIZENAMENORMAL, sz, ARRAYSIZE(sz));
		nFontSize = 8; 
		nOffset = 16 + 2;
		break;
	case 1:
		szBitmap = __TEXT("IDB_ICON_SAMPLE_LARGE2"); // NO NEED TO LOCALIZE

		LoadString(g_hInstDll, IDS_ICONSIZENAMELARGE, sz, ARRAYSIZE(sz));
		nFontSize = 12; 
		nOffset = 24 + 2;
		break;
	case 2:
		szBitmap = __TEXT("IDB_ICON_SAMPLE_EXLARGE2"); // NO NEED TO LOCALIZE

		LoadString(g_hInstDll, IDS_ICONSIZENAMEEXTRALARGE, sz, ARRAYSIZE(sz));
		nFontSize = 18; 
		nOffset = 32 + 2;
		break;
	default:
		_ASSERTE(FALSE);
		break;
	}

	HFONT hFontOld = (HFONT)SelectObject(hdc, g_Options.GetClosestMSSansSerif(nFontSize, (m_nCurrentHilight == i)));
	TextOut(hdc,
		(rcOriginal.left + rcOriginal.right)/2,
		(rcOriginal.top + rcOriginal.bottom)/2 + nOffset,
		sz, lstrlen(sz));
	SelectObject(hdc, hFontOld);

	HDC hDC = CreateCompatibleDC(hdc);
	if (!hDC)
		return;	// Prefix #113779 (out of resources; give up)

	// Paint the selected Bitmap. 
	hBitmap = (HBITMAP) LoadImage( g_hInstDll, szBitmap, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_SHARED  | LR_LOADMAP3DCOLORS);
	SelectObject(hDC, hBitmap);

	BitBlt(hdc, (rcOriginal.left + rcOriginal.right)/2 - nOffset, 
				(rcOriginal.top + rcOriginal.bottom)/2 - nOffset, 100, 100, hDC, 0, 0, SRCCOPY);

	DeleteDC(hDC);

	SetTextAlign(hdc, nOldAlign);
	SetBkMode(hdc, nOldBkMode);

	//If current hi-lighted item, Then draw the bounding rectangle. 
	if ( m_nCurrentHilight == i)
	{
		DrawHilight(m_hwnd, ldi);
	}
}




/////////////////////////////////
//CScrollBarPg members 
/////////////////////////////////
//
// Map the button-ID and the selection index
//
UINT IDMapS[4][2] = { 0, IDC_SCROLL1,
					  1, IDC_SCROLL2,
					  2, IDC_SCROLL3,
					  3, IDC_SCROLL4
					};

CScrollBarPg::CScrollBarPg(LPPROPSHEETPAGE ppsp)
		: WizardPage(ppsp, IDS_LKPREV_SCROLLBARTITLE, IDS_LKPREV_SCROLLBARSUBTITLE)
{
	m_dwPageId = IDD_FNTWIZSCROLLBAR;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	
	// Initializes the scroll bar widths and number of elements from string table. 
	LoadArrayFromStringTable(IDS_LKPREV_SCROLLSIZES, m_rgnValues, &m_nCountValues);

}


LRESULT CScrollBarPg::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	m_nCurValueIndex = m_nCountValues - 1;
	
	// Compute the current scroll bar type...
	for(int i=0; i < m_nCountValues; i++)
	{
		if(g_Options.m_schemePreview.m_PortableNonClientMetrics.m_iScrollWidth <= m_rgnValues[i])
		{
			m_nCurValueIndex = i;
			break;
		}
	}

	m_nCurrentHilight = m_nCurValueIndex;
	return 1;
}


// When page set active, Start Timer to set the Focus and ignore the 
// Hilighted events....
LRESULT CScrollBarPg::OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
{
	syncInit = FALSE;
	uIDEvent = SetTimer(hwnd, NULL, 100, NULL);

	return 0;
}

// Timer Handler
LRESULT CScrollBarPg::OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
	KillTimer(hwnd, uIDEvent);
	syncInit = TRUE;
	return 1;
}

// Apply new settings...
LRESULT CScrollBarPg::SettingChanged(int nNewSelection)
{
	int nNewValue = (int) m_rgnValues[nNewSelection];

	g_Options.m_schemePreview.m_PortableNonClientMetrics.m_iScrollWidth = nNewValue;
	g_Options.m_schemePreview.m_PortableNonClientMetrics.m_iScrollHeight = nNewValue;
	g_Options.m_schemePreview.m_PortableNonClientMetrics.m_iBorderWidth = nNewSelection; 
	
	g_Options.ApplyPreview();

	return 0;
}

// Set the current focussed item....
void CScrollBarPg::SetFocussedItem(int m_nCurrentHilight)
{
	SetFocus(GetDlgItem(m_hwnd, IDMapS[m_nCurrentHilight][1]));
}

// Erase the previous one....
void CScrollBarPg::InvalidateRects(int PrevHilight)
{
	InvalidateRect(GetDlgItem(m_hwnd, IDMapS[PrevHilight][1]), NULL, TRUE);
}

// Owner Draw message
LRESULT CScrollBarPg::OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	UINT idCtrl = (UINT) wParam;
	LPDRAWITEMSTRUCT lpDrawItemStruct = (LPDRAWITEMSTRUCT) lParam;
	int index;

	if ( !syncInit)
		SetFocussedItem(m_nCurrentHilight);

	switch(idCtrl)
	{

	case IDC_SCROLL1:
		index = 0;
		break;
	
	case IDC_SCROLL2:
		index = 1;
		break;
		
	case IDC_SCROLL3:
		index = 2;
		break;

	case IDC_SCROLL4:
		index = 3;
		break;

	default:
		// Error
		_ASSERTE(FALSE);
		return 1;	// Prefix #113782 (this should never happen; only four controls on dialog)
		break;
	}
	
	// For each button, Check the state, And if the button is selected,
	// means that it has current focus, So Re-paint the previously hilighted and 
	// the current selected buttons....
	// Make sure we ignore the initial events so that we minimize the flicker...
	if ( (lpDrawItemStruct->itemState & ODS_FOCUS) && (m_nCurrentHilight != index))
	{
		if ( syncInit )
		{
			// Erase the previous one...
			InvalidateRects(m_nCurrentHilight);

			m_nCurrentHilight= m_nCurValueIndex = index;
			SettingChanged(m_nCurValueIndex);
			// dirty = TRUE;
		}
	}

	Draw( lpDrawItemStruct, index );

	return 1;
}

// Paints the scroll bars and the selected item
void CScrollBarPg::Draw(LPDRAWITEMSTRUCT ldi, int i)
{
	HDC hdc = ldi->hDC;

	RECT rcOriginal = ldi->rcItem ;
	RECT rci = rcOriginal;
	InflateRect(&rcOriginal, -10, -10);
	
	// Draw border
	DrawEdge(hdc, &rcOriginal, EDGE_RAISED, BF_BOTTOMRIGHT| BF_ADJUST);
	DrawEdge(hdc, &rcOriginal, BDR_RAISEDINNER, BF_FLAT | BF_BOTTOMRIGHT | BF_ADJUST);
	DrawEdge(hdc, &rcOriginal, BDR_RAISEDINNER, BF_FLAT | BF_BOTTOMRIGHT | BF_ADJUST);
	
	// Adjust for the border
	rcOriginal.right -= i;
	rcOriginal.bottom -= i;
	
	// Adjust to the width of the scroll bar
	rcOriginal.left = rcOriginal.right - m_rgnValues[i];
	
	RECT rc = rcOriginal;
	
	
	// Drop the top
	rc.bottom = rc.top + m_rgnValues[i];
	DrawFrameControl(hdc, &rc, DFC_SCROLL, DFCS_SCROLLUP);
	
	// Draw the middle
	rc.top = rc.bottom;
	rc.bottom = rcOriginal.bottom - 2 * m_rgnValues[i];
	HBRUSH hbr = (HBRUSH)DefWindowProc(m_hwnd, WM_CTLCOLORSCROLLBAR, (WPARAM)hdc, (LPARAM)m_hwnd);
	HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, hbr);
	HPEN hpenOld = (HPEN)SelectObject(hdc, GetStockObject(NULL_PEN));
	//				ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
	Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
	SelectObject(hdc, hbrOld);
	SelectObject(hdc, hpenOld);
	
	// Draw the bottom
	rc.top = rc.bottom;
	rc.bottom = rc.top + m_rgnValues[i];
	DrawFrameControl(hdc, &rc, DFC_SCROLL, DFCS_SCROLLDOWN);
	
	// Draw the thumb
	rc.top = rc.bottom;
	rc.bottom = rc.top + m_rgnValues[i];
	DrawFrameControl(hdc, &rc, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);
	
	// Draw the right arrow
	rc.right = rc.left;
	rc.left = rc.right - m_rgnValues[i];
	DrawFrameControl(hdc, &rc, DFC_SCROLL, DFCS_SCROLLRIGHT);
	
	// Draw the middle of the bottom scroll bar
	rc.right = rc.left;
	rc.left = rci.left + 10;
	hbr = (HBRUSH)DefWindowProc(m_hwnd, WM_CTLCOLORSCROLLBAR, (WPARAM)hdc, (LPARAM)m_hwnd);
	hbrOld = (HBRUSH)SelectObject(hdc, hbr);
	hpenOld = (HPEN)SelectObject(hdc, GetStockObject(NULL_PEN));
	//				ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
	Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
	SelectObject(hdc, hbrOld);
	SelectObject(hdc, hpenOld);

	//If current hi-lighted item, Then draw the bounding rectangle. 
	if ( m_nCurrentHilight == i)
	{
		DrawHilight(m_hwnd, ldi);
	}
}

// Global function to draw the hilighted rectangle....
void DrawHilight(HWND hWnd, LPDRAWITEMSTRUCT ldi)
{
	HDC hdc = ldi->hDC;
	UINT clrH = COLOR_HIGHLIGHT;

	HPALETTE hpalOld = NULL;

	SaveDC(hdc);

	if (g_hpal3D)
	{
		hpalOld = SelectPalette(hdc, g_hpal3D, TRUE);
		RealizePalette(hdc);
	}

	// Set the color for drawing the scroll bar
	COLORREF clrrefOld = SetBkColor(hdc, GetSysColor(COLOR_3DHILIGHT));
	COLORREF clrrefOldText = SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));

	// OnDraw(hdc);
	
	// Draw the focus
	RECT rc = ldi->rcItem;
	InflateRect(&rc, -2, -2);
	
	RECT rcTemp;
	
	// If current window not in focus
	if ( GetForegroundWindow() != GetParent(hWnd) )
		clrH = COLOR_GRAYTEXT;

	HWND hwF = GetFocus();

	// Use 'selected' color for scroll bar selection
	COLORREF clrrefSelected = GetSysColor(COLOR_GRAYTEXT); 
	
	if ( (hwF != NULL) && (GetParent(hwF) == hWnd))
		clrrefSelected = GetSysColor(COLOR_HIGHLIGHT); // Use 'Gray' or 'Selected'

	SetBkColor(hdc, clrrefSelected);
	
	// Draw left
	rcTemp = rc;
	rcTemp.right = rcTemp.left + 5;
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcTemp, NULL, 0, NULL);
	
	// Draw top
	rcTemp = rc;
	rcTemp.bottom = rcTemp.top + 5;
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcTemp, NULL, 0, NULL);
	
	// Draw right
	rcTemp = rc;
	rcTemp.left = rcTemp.right - 5;
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcTemp, NULL, 0, NULL);
	
	// Draw bottom
	rcTemp = rc;
	rcTemp.top = rcTemp.bottom - 5;
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcTemp, NULL, 0, NULL);
	
	// Reset the color from drawing the scroll bar
	SetBkColor(hdc, clrrefOld);
	SetTextColor(hdc, clrrefOldText);

	if (hpalOld)
	{
		hpalOld = SelectPalette(hdc, hpalOld, FALSE);
		RealizePalette(hdc);
	}

	RestoreDC(hdc, -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\pgwizopt.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgWizOpt.h"
#include "w95trace.h"

BOOL IsAdmin();

CWizardOptionsPg::CWizardOptionsPg( 
    LPPROPSHEETPAGE ppsp
	) : WizardPage(ppsp, IDS_WIZOPTTITLE, IDS_WIZOPTSUBTITLE)
{
	m_dwPageId = IDD_WIZOPTIONS;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
    restoreOpt = FALSE;
}


CWizardOptionsPg::~CWizardOptionsPg(
    VOID
    )
{
}


DWORD g_rgdwWizNoOptionsSelected[] = {IDD_WIZNOOPTIONSSELECTED};

DWORD g_rgdwWizDoBlind[] = {
							IDD_FNTWIZSCROLLBAR, // scroll bar
							IDD_PREV_ICON2,
							IDD_PREV_COLOR,
                            IDD_MSEWIZMOUSECURSOR,
                            IDD_CARET
								};
DWORD g_rgdwWizDoSounds[] = {
							IDD_SNDWIZSENTRYSHOWSOUNDS,
							IDD_SNDWIZSENTRYSHOWSOUNDS2,
								};
DWORD g_rgdwWizDoKeyboardMouse[] = {
							IDD_KBDWIZSTICKYKEYS,
							IDD_KBDWIZFILTERKEYS1,
							IDD_KBDWIZFILTERKEYS2,
							IDD_KBDWIZTOGGLEKEYS,
							IDD_KBDWIZSHOWEXTRAKEYBOARDHELP,
							IDD_MSEWIZMOUSEKEYS,
							IDD_MSEWIZMOUSECURSOR,
							IDD_MSEWIZBUTTONCONFIG,
							IDD_MSEWIZMOUSESPEED
								};


DWORD g_rgdwWizDoAdmin[] = {
						IDD_WIZACCESSTIMEOUT,
						IDD_WIZWORKSTATIONDEFAULT
							};
DWORD g_rgdwWizFinalPages[] = {
						IDD_WIZFINISH
							};


BOOL CWizardOptionsPg::AdjustWizPageOrder()
{
	BOOL bDoBlind = Button_GetCheck(GetDlgItem(m_hwnd, IDC_DOBLIND));
	BOOL bDoSounds = Button_GetCheck(GetDlgItem(m_hwnd, IDC_DOSOUND));
	BOOL bDoKeyboardMouse = Button_GetCheck(GetDlgItem(m_hwnd, IDC_DOKEYBOARDMOUSE));
	BOOL bDoAdmin = Button_GetCheck(GetDlgItem(m_hwnd, IDC_DOADMIN));

	BOOL bDoNoOptions = (!bDoBlind && !bDoSounds && !bDoKeyboardMouse && !bDoAdmin && !restoreOpt);

	// First remove all possible pages since we want to insert them in the correct order
	// Return value does not matter since the pages may not be in the array
	sm_WizPageOrder.RemovePages(g_rgdwWizNoOptionsSelected, ARRAYSIZE(g_rgdwWizNoOptionsSelected));
	sm_WizPageOrder.RemovePages(g_rgdwWizDoBlind, ARRAYSIZE(g_rgdwWizDoBlind));
	sm_WizPageOrder.RemovePages(g_rgdwWizDoSounds, ARRAYSIZE(g_rgdwWizDoSounds));
	sm_WizPageOrder.RemovePages(g_rgdwWizDoKeyboardMouse, ARRAYSIZE(g_rgdwWizDoKeyboardMouse));
	sm_WizPageOrder.RemovePages(g_rgdwWizDoAdmin, ARRAYSIZE(g_rgdwWizDoAdmin));
	sm_WizPageOrder.RemovePages(g_rgdwWizFinalPages, ARRAYSIZE(g_rgdwWizFinalPages));

	// Then Add in pages in groups in the reverse order that we want them to appear.
	// We do them this way since they are inserted after this page, so the first group inserted
	// will be the last group at the end of this.

	// NOTE: We do not care about the return value from AddPages() in the sense
	// that we they do not allocate or free memory so it does not hurt to keep calling them.  We
	// Will propogate a return value of FALSE if any of them fail.

	BOOL bSuccess = TRUE;

	// Add Final Pages
	bSuccess = bSuccess && sm_WizPageOrder.AddPages(m_dwPageId, g_rgdwWizFinalPages, ARRAYSIZE(g_rgdwWizFinalPages));

	if(bDoNoOptions)
		bSuccess = bSuccess && sm_WizPageOrder.AddPages(m_dwPageId, g_rgdwWizNoOptionsSelected, ARRAYSIZE(g_rgdwWizNoOptionsSelected));

	if(bDoAdmin)
    {
		bSuccess = bSuccess && sm_WizPageOrder.AddPages(m_dwPageId, g_rgdwWizDoAdmin, ARRAYSIZE(g_rgdwWizDoAdmin));
        // Incase you are NOT an admin Remove admin page
        if ( !IsAdmin() )
	        sm_WizPageOrder.RemovePages(&g_rgdwWizDoAdmin[1], 1);
    }

	if(bDoKeyboardMouse)
		bSuccess = bSuccess && sm_WizPageOrder.AddPages(m_dwPageId, g_rgdwWizDoKeyboardMouse, ARRAYSIZE(g_rgdwWizDoKeyboardMouse));

	if(bDoSounds)
		bSuccess = bSuccess && sm_WizPageOrder.AddPages(m_dwPageId, g_rgdwWizDoSounds, ARRAYSIZE(g_rgdwWizDoSounds));

	if(bDoBlind)
		bSuccess = bSuccess && sm_WizPageOrder.AddPages(m_dwPageId, g_rgdwWizDoBlind, ARRAYSIZE(g_rgdwWizDoBlind));

	return bSuccess;
}


LRESULT
CWizardOptionsPg::OnCommand(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LRESULT lResult = 1;

	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID      = LOWORD(wParam);
	HWND hwndCtl     = (HWND)lParam;

	switch(wCtlID)
	{
	case IDC_BTNRESTORETODEFAULT:
		g_Options.ApplyWindowsDefault();
        restoreOpt = TRUE;
		break;

	default:
		break;
	}

	return lResult;
}

BOOL IsAdmin()
{
    HKEY hkey;
    BOOL fOk = (ERROR_SUCCESS == RegOpenKeyExA( HKEY_USERS, ".Default", 0, KEY_ALL_ACCESS, &hkey ));

    if(fOk)
    {
        RegCloseKey(hkey);
    }
    
	return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\resource.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AccWiz.rc
//
#define IDR_MENU                        1
#define IDR_MENUWITHSELECTED            2
#define IDS_WIZNOOPTIONSSELECTEDTITLE   4
#define IDS_WIZNOOPTIONSSELECTEDSUBTITLE 5
#define IDS_GENERICPAGETITLE            6
#define IDS_GENERICPAGESUBTITLE         7
#define IDS_WIZFILTERKEYSTITLE          8
#define IDS_WIZFILTERKEYSSUBTITLE       9
#define IDS_WIZSTICKYKEYSTITLE          10
#define IDM_NORMAL                      10
#define IDS_WIZSTICKYKEYSSUBTITLE       11
#define IDM_DISABLED                    11
#define IDS_WIZTOGGLEKEYSTITLE          12
#define IDM_SELECTED                    12
#define IDS_WIZTOGGLEKEYSSUBTITLE       13
#define IDS_WIZSHOWEXTRAKEYBOARDHELPTITLE 14
#define IDS_WIZSHOWEXTRAKEYBOARDHELPSUBTITLE 15
#define IDS_WIZHOTKEYANDNOTIFICATIONTITLE 18
#define IDS_WIZHOTKEYANDNOTIFICATIONSUBTITLE 19
#define IDS_WIZSAVEASDEFAULTTITLE       20
#define IDS_WIZSAVEASDEFAULTSUBTITLE    21
#define IDS_WIZACCESSTIMEOUTTITLE       22
#define IDS_WIZACCESSTIMEOUTSUBTITLE    23
#define IDS_WIZSAVETOFILETITLE          24
#define IDS_WIZSAVETOFILESUBTITLE       25
#define IDS_WIZOPTTITLE                 26
#define IDS_WIZOPTSUBTITLE              27
#define IDS_MSEWIZMOUSEKEYSTITLE        90
#define IDS_MSEWIZMOUSEKEYSSUBTITLE     91
#define IDS_MSEWIZMOUSECURSORTITLE      92
#define IDS_MSEWIZMOUSECURSORSUBTITLE   93
#define IDS_MSEWIZBUTTONCONFIGTITLE     94
#define IDS_MSEWIZBUTTONCONFIGSUBTITLE  95
#define IDC_GROUPBOX_2                  96
#define IDS_MSEWIZMOUSESPEEDTITLE       96
#define IDC_GROUPBOX_3                  97
#define IDS_MSEWIZMOUSESPEEDSUBTITLE    97
#define IDS_MSEWIZMOUSETRAILSTITLE      98
#define IDS_MSEWIZMOUSETRAILSSUBTITLE   99
#define MOUSE_LEFTHAND                  100
#define IDB_MOUSE                       100
#define MOUSE_RIGHTHAND                 101
#define IDI_APP_ICON                    101
#define KBLINK_EDIT                     103
#define KCURSOR_BLINK                   104
#define KCURSOR_RATE                    105
#define KCURSOR_WIDTH                   108
#define IDD_WIZFINISH                   109
#define IDC_SELECTDRAG                  109
#define IDI_CURSOR_SMALL_BLACK          109
#define IDS_SNDWIZSENTRYSHOWSOUNDSTITLE 110
#define IDC_OBJECTMENU                  110
#define IDS_SNDWIZSENTRYSHOWSOUNDSSUBTITLE 111
#define IDI_CURSOR_SMALL_INVERTING      111
#define IDI_CURSOR_MEDIUM_BLACK         112
#define IDS_SNDWIZSENTRYTITLE           112
#define IDI_CURSOR_MEDIUM_INVERTING     113
#define IDS_SNDWIZSENTRYSUBTITLE        113
#define IDS_SNDWIZSHOWSOUNDSTITLE       114
#define IDS_SNDWIZSHOWSOUNDSSUBTITLE    115
#define IDB_ACCWIZ                      128
#define IDB_ACCMARK                     129
#define IDD_CARET                       132
#define IDD_WIZOPTIONS                  154
#define IDD_WIZWORKSTATIONDEFAULT       176
#define IDD_WIZNOOPTIONSSELECTED        177
#define IDD_MSEWIZMOUSECURSOR           181
#define IDD_SNDWIZSENTRYSHOWSOUNDS      182
#define IDD_MSEWIZMOUSEKEYS             183
#define IDD_KBDWIZSTICKYKEYS            184
#define IDD_KBDWIZTOGGLEKEYS            186
#define IDD_KBDWIZSHOWEXTRAKEYBOARDHELP 187
#define IDI_CURSOR_LARGE_INVERTING      242
#define IDI_CURSOR_SMALL_WHITE          243
#define IDI_CURSOR_MEDIUM_WHITE         244
#define IDI_CURSOR_LARGE_WHITE          245
#define IDI_CURSOR_LARGE_BLACK          246
#define IDS_SNDSEN_SSWF_NONE            300
#define IDS_SNDSEN_SSWF_TITLE           301
#define IDS_SNDSEN_SSWF_WINDOW          302
#define IDS_SNDSEN_SSWF_DISPLAY         303
#define IDS_SNDSEN_SSTF_NONE            304
#define IDS_SNDSEN_SSTF_CHARS           305
#define IDS_SNDSEN_SSTF_BORDER          306
#define IDS_SNDSEN_SSTF_DISPLAY         307
#define IDD_MSEWIZBUTTONCONFIG          400
#define IDS_WELCOMETITLE                400
#define IDD_WIZSAVETOFILE               402
#define IDD_WIZWELCOME2                 404
#define IDD_FNTWIZSCROLLBAR             405
#define IDD_PREV_COLOR                  410
#define IDD_WIZACCESSTIMEOUT            417
#define IDD_MSEWIZMOUSEKEYS1            419
#define IDD_SNDWIZSENTRYSHOWSOUNDS2     422
#define IDD_WIZWELCOME                  423
#define IDD_PREV_ICON2                  424
#define IDD_MSEWIZMOUSESPEED            425
#define IDD_KBDWIZFILTERKEYS1           426
#define IDD_KBDWIZFILTERKEYS2           427
#define IDD_WIZLAUNCHMAGNIFY            428
#define IDD_WIZLAUNCHSCREENREADER       429
#define IDD_WIZLAUNCHONSCREENKEYBOARD   430
#define IDD_MSEWIZMOUSETRAILS           431
#define IDD_WIZNEWWELCOME               432
#define IDC_MK_TOPSPEED                 603
#define IDC_MK_ACCEL                    604
#define IDC_CHECKSAVESETTINGTODEFAULT   1000
#define IDC_DOBLIND                     1006
#define IDC_DOKEYBOARDMOUSE             1007
#define IDC_DOSOUND                     1008
#define IDC_DOADMIN                     1009
#define IDC_PERMENU                     1010
#define IDC_TRANSPARENT1                1011
#define IDC_MK_NLOFF                    1018
#define IDC_MK_NLON                     1019
#define IDC_FK_LBL_TESTBOX              1024
#define IDC_BK_TIME_LBL_SHORT           1025
#define IDC_BK_TIME_LBL_LONG            1026
#define IDC_MK_LBL1                     1033
#define IDC_MK_LBL2                     1034
#define IDC_MK_LBL3                     1035
#define IDC_MK_LBL4                     1036
#define IDC_TO_ENABLE                   1037
#define IDC_MK_LBL5                     1037
#define IDC_TO_TIMEOUTVAL               1038
#define IDC_MK_LBL6                     1038
#define IDC_MK_LBL7                     1039
#define IDC_RADIO1                      1042
#define IDC_RADIO2                      1043
#define IDC_RADIO3                      1044
#define IDC_RADIO4                      1045
#define IDC_RADIO5                      1046
#define IDC_RADIO6                      1047
#define IDC_RADIO7                      1048
#define IDC_BTNBROWSE                   1048
#define IDC_FK_TESTBOX                  1049
#define IDC_RADIO8                      1049
#define IDC_RADIO9                      1050
#define IDC_RADIO10                     1051
#define IDC_SWITCHRESOLUTION            1053
#define IDC_CHANGEFONTS                 1054
#define IDC_USEMAGNIFY                  1055
#define IDC_BK_TIME                     1056
#define IDC_SZRESMESSAGE                1056
#define IDC_BK_BOUNCERATE               1057
#define IDC_BTNRESTORETODEFAULT         1057
#define IDC_PREVLIST                    1074
#define IDC_RADIOYES                    1077
#define IDC_BK_TIME_LBL2                1088
#define IDC_TO_DISABLE                  1089
#define IDC_MOUSEPIC2                   1097
#define IDC_MOUSEPIC1                   1098
#define IDC_SLIDER1                     1105
#define IDC_SELECTIONMINTEXT            1107
#define IDC_SELECTIONICONSIZE           1108
#define IDC_SELECTIONSCROLLBAR          1109
#define IDC_SZCHANGES                   1110
#define IDC_RADIONO                     1111
#define IDC_RADIOBEEPYES                1113
#define IDC_RADIOBEEPNO                 1114
#define IDC_TEXT1                       1116
#define IDC_TEXT2                       1117
#define IDC_TEXT3                       1118
#define IDC_CHECK1                      1119
#define IDC_ICON1                       1120
#define IDC_ICON2                       1121
#define IDC_ICON3                       1122
#define IDC_SCROLL1                     1123
#define IDC_SCROLL2                     1124
#define IDC_SCROLL3                     1125
#define IDC_MIN                         1125
#define IDC_SCROLL4                     1126
#define IDS_ACTIVE                      1450
#define IDS_INACTIVE                    1451
#define IDS_MINIMIZED                   1452
#define IDS_ICONTITLE                   1453
#define IDS_NORMAL                      1454
#define IDS_DISABLED                    1455
#define IDS_SELECTED                    1456
#define IDS_MSGBOX                      1457
#define IDS_BUTTONTEXT                  1458
#define IDS_SMCAPTION                   1459
#define IDS_WINDOWTEXT                  1460
#define IDS_MSGBOXTEXT                  1461
#define IDC_LOOKPREV                    1470
#define IDS_WIZSAVECHANGESMESSAGETITLE  1501
#define IDS_WIZSAVECHANGESMESSAGETEXT   1502
#define IDS_WIZERRORLOADINGFILETITLE    1503
#define IDS_WIZERRORLOADINGFILETEXT     1504
#define IDS_WIZERRORNEEDADMINTITLE      1505
#define IDS_WIZERRORNEEDADMINTEXT       1506
#define IDS_WIZERRORSAVINGFILETITLE     1507
#define IDS_WIZERRORSAVINGFILETEXT      1508
#define IDS_WIZCHANGESHAPPENINGTITLE    1509
#define IDS_WIZCHANGESHAPPENINGTEXT     1510
#define IDS_WIZCANCELCHANGESTITLE       1511
#define IDS_WIZCANCELCHANGESTEXT        1512
#define IDS_ICONSIZENAMENORMAL          1600
#define IDS_ICONSIZENAMELARGE           1601
#define IDS_ICONSIZENAMEEXTRALARGE      1602
#define IDS_DEFAULTSAVEFILENAME         1700
#define IDS_FILTERNAME                  1701
#define IDS_FILTER                      1702
#define IDS_FILTER2                     1703
#define IDS_DISPLAYRESOLUTIONINFO       1709
#define IDS_SCHEME_HIGHCONTRASTBLACK    2000
#define IDS_SCHEME_HIGHCONTRASTWHITE    2001
#define IDS_SCHEME_HIGHCONTRASTBLACKALTERNATE 2002
#define IDS_SCHEME_HIGHCONTRASTWHITEALTERNATE 2003
#define IDS_SCHEME_WINDOWSSTANDARD      2004
#define IDS_SCHEME_CURRENTCOLORSCHEME   2005
#define IDS_SCHEME_BLAHBLAHBLAH         2006
#define IDC_BIGBOLDTITLE                2090
#define IDC_BOLDTITLE                   2091
#define IDC_BIGTITLE                    2092
#define IDB_MOUSE2                      2570
#define IDS_LKPREV_SCROLLSIZES          3000
#define IDS_LKPREV_MINTEXTSIZES         3001
#define IDS_LKPREV_BORDERSIZES          3002
#define IDS_LKPREV_WELCOME_MINTEXTSIZES 3003
#define IDS_LKPREV_MINTEXTTITLE         3100
#define IDS_LKPREV_MINTEXTSUBTITLE      3101
#define IDS_LKPREV_COLORTITLE           3102
#define IDS_LKPREV_COLORSUBTITLE        3103
#define IDS_LKPREV_SCROLLBARTITLE       3104
#define IDS_LKPREV_SCROLLBARSUBTITLE    3105
#define IDS_LKPREV_BORDERTITLE          3106
#define IDS_LKPREV_BORDERSUBTITLE       3107
#define IDS_LKPREV_ICONTITLE            3108
#define IDS_LKPREV_ICONSUBTITLE         3109
#define IDS_WELCOME2TITLE               3110
#define IDS_WELCOME2SUBTITLE            3111
#define IDS_ICONPREV_ITEM1              3112
#define IDS_ICONPREV_ITEM2              3113
#define IDS_ICONPREV_ITEM3              3114
#define IDS_ICONPREV_ITEM4              3115
#define IDS_ICONPREV_ITEM5              3116
#define IDS_ICONPREV_ITEM6              3117
#define IDS_BIGBOLDFONTSIZE             4000
#define IDS_BIGBOLDFONTNAME             4001
#define IDS_BOLDFONTSIZE                4002
#define IDS_BOLDFONTNAME                4003
#define IDS_BIGFONTSIZE                 4004
#define IDS_BIGFONTNAME                 4005
#define IDS_SYSTEMFONTNAME              4006
#define IDS_FONTCHARSET                 4100
#define IDS_WINDOWSDEFAULTSIZES         4200
#define IDS_PREVIEWMENUTEXT             4501
#define IDS_CURSOR_SCHEME_WINDOWS_STANDARD_LARGE 5002
#define IDS_CURSOR_SCHEME_WINDOWS_STANDARD_EXTRALARGE 5003
#define IDS_CURSOR_SCHEME_WINDOWS_BLACK 5004
#define IDS_CURSOR_SCHEME_WINDOWS_BLACK_LARGE 5005
#define IDS_CURSOR_SCHEME_WINDOWS_BLACK_EXTRALARGE 5006
#define IDS_CURSOR_SCHEME_WINDOWS_INVERTED 5007
#define IDS_CURSOR_SCHEME_WINDOWS_INVERTED_LARGE 5008
#define IDS_CURSOR_SCHEME_WINDOWS_INVERTED_EXTRALARGE 5009
#define IDS_WELCOMETEXT1                6001
#define IDS_WELCOMETEXT2                6002
#define IDS_WELCOMETEXT3                6003
#define IDS_WELCOMETEXT4                6004
#define IDS_CHANGESFILTERKEYS           7000
#define IDS_CHANGESMOUSEKEYS            7001
#define IDS_CHANGESSERIALKEYS           7002
#define IDS_CHANGESSTICKYKEYS           7003
#define IDS_CHANGESTOGGLEKEYS           7004
#define IDS_CHANGESSOUNDSENTRY          7005
#define IDS_CHANGESACCESSTIMEOUT        7006
#define IDS_CHANGESHIGHCONTRAST         7007
#define IDS_CHANGESShowSounds           7008
#define IDS_CHANGESShowExtraKeyboardHelp 7009
#define IDS_CHANGESSwapMouseButtons     7010
#define IDS_CHANGESCOLOR                7011
#define IDS_CHANGESNONCLIENTMETRICS     7012
#define IDS_CHANGESMouseSpeed           7013
#define IDS_CHANGESMouseTrails          7014
#define IDS_CHANGESIconSize             7015
#define IDS_CHANGES16                   7016
#define IDS_CHANGESCursorScheme         7016
#define IDS_CHANGES17                   7017
#define IDS_CHANGESScrollWidth          7017
#define IDS_CHANGES18                   7018
#define IDS_CHANGESBorderWidth          7018
#define IDS_CHANGES19                   7019
#define IDS_CHANGES19a                  7019
#define IDS_CHANGESCaretWidth           7020
#define IDS_CHANGESBlinkRate            7021
#define IDS_CHANGES22                   7022
#define IDS_CHANGESNOCHANGES            7023
#define IDC_WEBLINK                     7050
#define IDS_NAMEOFMAGNIFIER             8001
#define IDS_WIZFILTERKEYSETTING         8002
#define IDS_MSEWIZMOUSEKEYSETTING       8003
#define IDS_MSEWIZMOUSEKEYSETSUB        8004
#define IDS_TEXTSIZESUBTITLE            8004
#define IDS_TEXTSIZETITLE               8005
#define IDS_ENABLEWEB                   8006
#define IDS_CARETTITLE                  8007
#define IDS_CARETSUBTITLE               8008
#define IDS_FRIENDLYTYPENAME            16
#define IDS_FRIENDLYTYPENAMETIP         17

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1126
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\schemes.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "Schemes.h"
#include <WININET.H>
#include <initguid.h>
#include <shlobj.h>
#include <objbase.h>
#include <shlguid.h>
#include <uxthemep.h>
#include "w95trace.h"

// To use the old way of enumerating fonts to get the font list,
// and reading schemes from the registry, remove the comments from
// the two lines below
//#define ENUMERATEFONTS
//#define READSCHEMESFROMREGISTRY

#define CPL_APPEARANCE_NEW_SCHEMES TEXT("Control Panel\\Appearance\\New Schemes")
#define NEW_SCHEMES_SELECTEDSTYLE  TEXT("SelectedStyle")
#define NEW_SCHEMES_SELECTEDSIZE   TEXT("SelectedSize")
#define HC_KEY				TEXT("Control Panel\\Accessibility\\HighContrast")
#define HC_FLAGS			TEXT("Flags")
#define PRE_HC_WALLPAPER    TEXT("Pre-High Contrast Wallpaper")
#define SYSPARAMINFO(xxx) m_##xxx.cbSize = sizeof(m_##xxx);SystemParametersInfo(SPI_GET##xxx, sizeof(m_##xxx), &m_##xxx, 0)

//
// Helper functions
//

#define REG_SET_DWSZ(hk, key, dw) \
{ \
	TCHAR szValue[20]; \
	wsprintf(szValue, TEXT("%d"), dw); \
	RegSetValueEx(hk, key, NULL, REG_SZ, (LPCBYTE)szValue, (lstrlen(szValue)+1)*sizeof(TCHAR)); \
}

void WIZSCHEME::ApplyChanges(const WIZSCHEME &schemeNew, NONCLIENTMETRICS *pForceNCM, LOGFONT *pForcelfIcon)
	{
		//
		// If user has changed the color scheme then apply the new scheme.  Since this is
		// a high contrast scheme, also set the high contrast bit.  We have to do this
		// w/o using SystemParametersInfo(SPI_SETHIGHCONTRAST...) because that function
		// also sets non-client metrics that accwiz must deal with separately from color.
		//

		BOOL fThemingOn = SetTheme(
							  schemeNew.m_szThemeName
							, schemeNew.m_szThemeColor
							, schemeNew.m_szThemeSize);

		SetWallpaper(schemeNew.m_szWallpaper);	// set wallpaper to new scheme's value

		if (fThemingOn)
		{
            DBPRINTF(TEXT("ApplyChanges:  Theming is being turned on\r\n"));
            SetHCFlag(FALSE);	                    // manually set high contrast flag off

            // restore "flatmenu" and "dropshadows" settings 
            SystemParametersInfo(SPI_SETFLATMENU, 0, IntToPtr(schemeNew.m_fFlatMenus), SPIF_SENDCHANGE);
            SystemParametersInfo(SPI_SETDROPSHADOW, 0, IntToPtr(schemeNew.m_fDropShadows), SPIF_SENDCHANGE);
		}
		else if (lstrcmpi(schemeNew.m_szSelectedStyle, m_szSelectedStyle))
		{
            DBPRINTF(TEXT("ApplyChanges:  Theming is off or being turned off\r\n"));
		    // Setting a high contrast scheme

		    if (0 != memcmp(schemeNew.m_rgb, m_rgb, sizeof(m_rgb)))
		    {
			    SetHCFlag(TRUE);	                // first, manually set the high contrast flag
                                                    // (requires logoff/logon to take affect)

                // reset "flatmenu" and "dropshadows" settings 
                SystemParametersInfo(SPI_SETFLATMENU, 0, IntToPtr(FALSE), SPIF_SENDCHANGE);
                SystemParametersInfo(SPI_SETDROPSHADOW, 0, IntToPtr(FALSE), SPIF_SENDCHANGE);

                // update the color scheme
			    int rgInts[COLOR_MAX_97_NT5];	       // then set UI elements to selected color scheme
			    for(int i=0;i<COLOR_MAX_97_NT5;i++)
                {
				    rgInts[i] = i;
                }

			    SetSysColors(COLOR_MAX_97_NT5, rgInts, schemeNew.m_rgb);
 
			    // The following code updates the registry HKCU\Control Panel\Colors to
			    // reflect the new scheme so its available when the user logs on again

			    HKEY hk;
			    if (RegCreateKey(HKEY_CURRENT_USER, szRegStr_Colors, &hk) == ERROR_SUCCESS)
			    {
				    TCHAR szRGB[32];
				    for (i = 0; i < COLOR_MAX_97_NT5; i++)
				    {
					    COLORREF rgb;
					    rgb = schemeNew.m_rgb[i];
					    wsprintf(szRGB, TEXT("%d %d %d"), GetRValue(rgb), GetGValue(rgb), GetBValue(rgb));

					    WriteProfileString(g_szColors, s_pszColorNames[i], szRGB);	// update win.ini
					    RegSetValueEx(hk											// update registry
						    , s_pszColorNames[i]
						    , 0L, REG_SZ
						    , (LPBYTE)szRGB
						    , sizeof(TCHAR) * (lstrlen(szRGB)+1));
				    }

				    RegCloseKey(hk);
			    }

                // The W2K color schemes changed with WinXP.  The old schemes (which we still use)
                // are still there but display CPL uses a new method for selecting colors.  These 
                // colors are under HKCU\Control Panel\Appearance\New Schemes.  The "SelectedStyle"
                // string value is the current scheme.  The number (0 thru 21) corresponds to the
                // order of the old colors under HKCU\Control Panel\Appearance\Schemes (excluding
                // those schemes with (large) and (extra large)).  The details for the scheme are
                // subkeys (0 thru nn) under "New Schemes".  In order for display CPL to show the
                // correct current scheme after we've been run, we need to update "SelectedStyle" 
                // and "SelectedSize" (under the subkey specified in "SelectedStyle") with the
                // correct index and size numbers.  Display CPL uses a much more robust way of
                // determining the legacy index but we only support four colors so we shouldn't
                // need all the extra code.

                if (RegOpenKeyEx(
                            HKEY_CURRENT_USER, 
                            CPL_APPEARANCE_NEW_SCHEMES, 
                            0, KEY_ALL_ACCESS, 
                            &hk) == ERROR_SUCCESS)
                {
                    long lRv = RegSetValueEx(
                                        hk, 
                                        NEW_SCHEMES_SELECTEDSTYLE, 
                                        0, REG_SZ, 
                                        (LPCBYTE)schemeNew.m_szSelectedStyle, 
                                        (lstrlen(schemeNew.m_szSelectedStyle)+1)*sizeof(TCHAR));

                    RegCloseKey(hk);

                    // If we've changed color then the size must be updated for that scheme
                    UpdateSelectedSize(schemeNew.m_nSelectedSize, schemeNew.m_szSelectedStyle);
                }
            } 
            else if (schemeNew.m_nSelectedSize >= 0 && schemeNew.m_nSelectedSize != m_nSelectedSize)
            {
                // Also update size if it changed but the color scheme didn't
                UpdateSelectedSize(schemeNew.m_nSelectedSize, schemeNew.m_szSelectedStyle);
            }
        }
		//
		// Apply any other changes
		//

#define APPLY_SCHEME_CURRENT(xxx) if(0 != memcmp(&schemeNew.m_##xxx, &m_##xxx, sizeof(schemeNew.m_##xxx))) SystemParametersInfo(SPI_SET##xxx, sizeof(schemeNew.m_##xxx), (PVOID)&schemeNew.m_##xxx, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE)

		APPLY_SCHEME_CURRENT(FILTERKEYS);
		APPLY_SCHEME_CURRENT(MOUSEKEYS);
		APPLY_SCHEME_CURRENT(STICKYKEYS);
		APPLY_SCHEME_CURRENT(TOGGLEKEYS);
		APPLY_SCHEME_CURRENT(SOUNDSENTRY);
		APPLY_SCHEME_CURRENT(ACCESSTIMEOUT);
//		APPLY_SCHEME_CURRENT(SERIALKEYS);

		// Check Show Sounds
		if(schemeNew.m_bShowSounds != m_bShowSounds)
			SystemParametersInfo(SPI_SETSHOWSOUNDS, schemeNew.m_bShowSounds, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

		// Check Extra keyboard help
		if(schemeNew.m_bShowExtraKeyboardHelp != m_bShowExtraKeyboardHelp)
		{
			// Both required: 
			SystemParametersInfo(SPI_SETKEYBOARDPREF, schemeNew.m_bShowExtraKeyboardHelp, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
			SystemParametersInfo(SPI_SETKEYBOARDCUES, 0, IntToPtr(schemeNew.m_bShowExtraKeyboardHelp), SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
		}

		// Check swap mouse buttons
		if(schemeNew.m_bSwapMouseButtons != m_bSwapMouseButtons)
			SwapMouseButton(schemeNew.m_bSwapMouseButtons);

		// Check Mouse Trails
		if(schemeNew.m_nMouseTrails != m_nMouseTrails)
			SystemParametersInfo(SPI_SETMOUSETRAILS, schemeNew.m_nMouseTrails, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

		// Check Mouse Speed
		if(schemeNew.m_nMouseSpeed != m_nMouseSpeed)
			SystemParametersInfo(SPI_SETMOUSESPEED, 0, IntToPtr(schemeNew.m_nMouseSpeed), SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

        // Reset cursor width and blink time
        if (schemeNew.m_dwCaretWidth != m_dwCaretWidth)
            SystemParametersInfo(SPI_SETCARETWIDTH, 0, IntToPtr(schemeNew.m_dwCaretWidth), SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

        if (schemeNew.m_uCursorBlinkTime != m_uCursorBlinkTime)
        {
            // Set the blink rate for this session
            SetCaretBlinkTime(schemeNew.m_uCursorBlinkTime);

            // and persist it to the registry
            RegSetStrDW(HKEY_CURRENT_USER, CONTROL_PANEL_DESKTOP, CURSOR_BLINK_RATE, schemeNew.m_uCursorBlinkTime);
        }

		// Check icon size
		if(schemeNew.m_nIconSize != m_nIconSize)
			WIZSCHEME::SetShellLargeIconSize(schemeNew.m_nIconSize);

		// Check cursor scheme
		if(schemeNew.m_nCursorScheme != m_nCursorScheme)
			ApplyCursorScheme(schemeNew.m_nCursorScheme);

		// NonClientMetric changes
		{
			NONCLIENTMETRICS ncmOrig;
			LOGFONT lfOrig;
			GetNonClientMetrics(&ncmOrig, &lfOrig);
			if(pForceNCM)
			{
				// If they gave us a NCM, they must also give us a LOGFONT for the icon
				_ASSERTE(pForcelfIcon);
				// We were given an Original NCM to use
				if(0 != memcmp(pForceNCM, &ncmOrig, sizeof(ncmOrig)))
					SystemParametersInfo(SPI_SETNONCLIENTMETRICS, sizeof(*pForceNCM), pForceNCM, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
				if(0 != memcmp(pForcelfIcon, &lfOrig, sizeof(lfOrig)))
					SystemParametersInfo(SPI_SETICONTITLELOGFONT, sizeof(*pForcelfIcon), pForcelfIcon, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
			}
			else
			{
				// Note: This part of apply changes does not look at schemeCurrent - it only looks
				// at what we are applying
				schemeNew.m_PortableNonClientMetrics.ApplyChanges();
			}
		}


		*this = schemeNew;
	}

// Set the high contrast flag on or off based on fSet
void WIZSCHEME::SetHCFlag(BOOL fSetOn)
{
    // 
    // This key is cached in the OS so setting it outside of 
    // SystemParametersInfo(SPI_SETHIGHCONTRAST doesn't take
    // effect until the user logs off and on again.  Is there
    // a way to cause the cache to be refreshed?
    //
	HKEY hk;
	if (RegOpenKeyEx(HKEY_CURRENT_USER, HC_KEY, 0, KEY_ALL_ACCESS, &hk) == ERROR_SUCCESS)
	{
		TCHAR szValue[20];
		DWORD dwSize = sizeof(szValue)*sizeof(TCHAR);

		if (RegQueryValueEx(hk, HC_FLAGS, NULL, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
        {
		    DWORD dwValue = _ttol(szValue);

            if (fSetOn && !(dwValue & HCF_HIGHCONTRASTON))
		    {
                dwValue |= HCF_HIGHCONTRASTON;
			    REG_SET_DWSZ(hk, HC_FLAGS, dwValue)
		    }
		    else if (!fSetOn && (dwValue & HCF_HIGHCONTRASTON))
		    {
                dwValue &= ~HCF_HIGHCONTRASTON;
			    REG_SET_DWSZ(hk, HC_FLAGS, dwValue)
		    }
        }
		RegCloseKey(hk);
	}
}

/***************************************************************************
 * SaveWallpaper
 * 
 * Saves the current wallpaper setting from the system.
 *
 * ISSUE we aren't getting all the active desktop properties; just wallpaper.
 * This isn't a regression in that we didn't even restore wallpaper in W2K.
 *
 ***************************************************************************/
void WIZSCHEME::SaveWallpaper()
{
    IActiveDesktop *p;
    HRESULT hr = CoCreateInstance(
                  CLSID_ActiveDesktop
                , NULL
                , CLSCTX_INPROC_SERVER
                , IID_IActiveDesktop
                , (void **)&p);
    if (SUCCEEDED(hr) && p)
    {
        hr = p->GetWallpaper(m_szWallpaper, MAX_THEME_SZ, 0);
        p->Release();
    }
    DBPRINTF(TEXT("SaveWallpaper:  m_szWallpaper = %s (hr = 0x%x)\r\n"), m_szWallpaper, hr);
}

/***************************************************************************
 * SetWallpaper
 *
 * Restores the pre-high contrast wallpaper setting.  Reads the setting
 * stored in the accessibility registry entries and restores the system
 * setting.  No error return as there isn't anything we can do.
 * 
 ***************************************************************************/
void WIZSCHEME::SetWallpaper(LPCTSTR pszWallpaper)
{
    if (lstrcmpi(m_szWallpaper, pszWallpaper))
    {
        IActiveDesktop *p;
	    LPCTSTR psz = (pszWallpaper)?pszWallpaper:TEXT("");

        HRESULT hr = CoCreateInstance(
                      CLSID_ActiveDesktop
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IActiveDesktop
                    , (void **)&p);
        if (SUCCEEDED(hr) && p)
        {
            hr = p->SetWallpaper(psz, 0);
            if (SUCCEEDED(hr))
                p->ApplyChanges(AD_APPLY_ALL);

            p->Release();
        }
        DBPRINTF(TEXT("SetWallpaper:  psz = %s (hr = 0x%x)\r\n"), psz, hr);
    }
}

/***************************************************************************
 * SaveTheme
 *
 * Saves the theme file settings that are active before accwiz was run.
 * 
 ***************************************************************************/
void WIZSCHEME::SaveTheme()
{
    HRESULT hr = E_FAIL;

    if (IsThemeActive())
    {
        hr = GetCurrentThemeName(
				  m_szThemeName, MAX_THEME_SZ
				, m_szThemeColor, MAX_THEME_SZ
				, m_szThemeSize, MAX_THEME_SZ);
    }

	if (FAILED(hr))
	{
		// themes is not turned on
		m_szThemeName[0] = 0;
		m_szThemeColor[0] = 0;
		m_szThemeSize[0] = 0;
	}

    //---- save off "flatmenu" and "dropshadows" settings ---
    SystemParametersInfo(SPI_GETFLATMENU, 0, (PVOID)&m_fFlatMenus, 0);
    SystemParametersInfo(SPI_GETDROPSHADOW, 0, (PVOID)&m_fDropShadows, 0);

    DBPRINTF(TEXT("SaveTheme:  m_szThemeName = %s m_szThemeColor = %s m_szThemeSize = %s (hr = 0x%x)\r\n"), m_szThemeName, m_szThemeColor, m_szThemeSize, hr);
}

/***************************************************************************
 * SetTheme
 *
 * If a theme name, color and size is passed then sets it 
 * else turns off theming. 
 *
 * Returns TRUE if a theme was set else FALSE it themes were turned off.
 * 
 ***************************************************************************/
BOOL WIZSCHEME::SetTheme(LPCTSTR pszThemeName, LPCTSTR pszThemeColor, LPCTSTR pszThemeSize)
{
	BOOL fRet = FALSE;		// didn't turn themes on

    // only attempt to do anything if the new theme differs from current
    if ( lstrcmpi(m_szThemeName, pszThemeName)
      || lstrcmpi(m_szThemeColor, pszThemeColor)
      || lstrcmpi(m_szThemeSize, pszThemeSize) )
    {
        HRESULT hr;
	    if (pszThemeName[0] && pszThemeColor[0] && pszThemeSize[0])
	    {
		    HTHEMEFILE hThemeFile;

		    hr = OpenThemeFile(pszThemeName, pszThemeColor, pszThemeSize, &hThemeFile, TRUE);
		    if (SUCCEEDED(hr))
		    {
			    hr = ApplyTheme(hThemeFile, AT_LOAD_SYSMETRICS | AT_SYNC_LOADMETRICS, NULL);
			    CloseThemeFile(hThemeFile);
			    fRet = TRUE;	// turned themes on
		    }
            DBPRINTF(TEXT("SetTheme:  pszThemeName = %s pszThemeColor = %s pszThemeSize = %s(hr = 0x%x)\r\n"), pszThemeName, pszThemeColor, pszThemeSize, hr);
	    } 
        else if (IsThemeActive())
	    {
            hr = ApplyTheme(NULL, 0, NULL);
            DBPRINTF(TEXT("SetTheme:  Themes are now off hr = 0x%x\r\n"), hr);
	    }
    }

	return fRet;
}

/***************************************************************************
 * UpdateSelectedSize
 *
 * Updates the SelectedSize under a "New Scheme" entry. 
 *
 * NOTE:  AccWiz doesn't use the font metrics from the registry so
 *        it doesn't actually give fonts that are "normal", "large"
 *        and "extra large" as display and access CPLs know them.
 *        The closest sizes are "normal" and "large".
 * 
 ***************************************************************************/
void WIZSCHEME::UpdateSelectedSize(int nSelectedSize, LPCTSTR pszSelectedStyle)
{
    LPTSTR pszSelectedSize;
    LPTSTR aszSelectedSizes[] = {TEXT("0")/*normal*/, TEXT("2")/*large*/, TEXT("1")/*extra large*/};

    switch (nSelectedSize)
    {
        case 0: pszSelectedSize = aszSelectedSizes[0]; break; // normal text size
        case 1: pszSelectedSize = aszSelectedSizes[0]; break; // normal text size
        case 2: pszSelectedSize = aszSelectedSizes[1]; break; // large text size
        default: pszSelectedSize =  0;                 break;
    }

    if (pszSelectedSize)
    {
		HKEY hk;
        if (RegOpenKeyEx(HKEY_CURRENT_USER, 
                         CPL_APPEARANCE_NEW_SCHEMES, 
                         0, KEY_ALL_ACCESS, 
                         &hk) == ERROR_SUCCESS)
        {
            HKEY hkSub;
            if (RegOpenKeyEx(hk, pszSelectedStyle, 0, KEY_ALL_ACCESS, &hkSub) == ERROR_SUCCESS)
            {
	            RegSetValueEx(hkSub, 
                              NEW_SCHEMES_SELECTEDSIZE, 
                              0, REG_SZ, 
                              (LPCBYTE)pszSelectedSize, 
                              (lstrlen(pszSelectedSize)+1)*sizeof(TCHAR));

                RegCloseKey(hkSub);
            }
        }
        RegCloseKey(hk);
    }
}

/***************************************************************************
 * SetStyleNSize
 *
 * Helper for legacy schemes - figures out SelectedStyle and SelectedSize
 * from the legacy scheme's data. 
 * 
 ***************************************************************************/
void WIZSCHEME::SetStyleNSize()
{
    int cStdSchemes = GetSchemeCount();
    int i;

    // Init the fields this function will be setting

    m_szSelectedStyle[0] = 0;
    m_nSelectedSize = 0;

    // Figure out the SelectedStyle by finding the best-match for
    // colors between what accwiz supports now and what it had in
    // previous versions.  After finding the best match, copy the
    // latest colors in; this fixes some bugs with old colors.

    SCHEMEDATALOCAL sdlTemp;
    int iBestColorFit = -1; // guarrantee we'll find one
    int cBestMatch = 0;

    for (i=0;i<cStdSchemes;i++)
    {
        int cMatches = 0;
        sdlTemp = GetScheme(i);

        // assumption:  sizeof(m_rgb) > sizeof(sdlTemp.rgb)
        for (int cColor = 0;cColor < sdlTemp.nColorsUsed; cColor++)
        {
            if (sdlTemp.rgb[cColor] == m_rgb[cColor])
            {
                cMatches++;
            }
        }

        if (cBestMatch < cMatches)
        {
            iBestColorFit = i;
            cBestMatch = cMatches;
        }

        // if its an exact match just use it
        if (cMatches == sdlTemp.nColorsUsed)
            break;
    }

    // load up the SelectedStyle
    sdlTemp = GetScheme(iBestColorFit);
    LoadString(g_hInstDll, sdlTemp.nNameStringId+100
                         , m_szSelectedStyle
                         , ARRAYSIZE(m_szSelectedStyle));

    // fix up any color problems
    memcpy(m_rgb, sdlTemp.rgb, sizeof(sdlTemp.rgb));

    // Figure out the SelectedSize based on reverse-compute minimum
    // font size and hard-coded limits from the Welcome page

 	HDC hDC = GetDC(NULL);
    if (hDC)
    {
        long lMinFontSize = ((-m_PortableNonClientMetrics.m_lfCaptionFont_lfHeight)*72)/GetDeviceCaps(hDC, LOGPIXELSY);
	    ReleaseDC(NULL, hDC);
    
	    if (lMinFontSize <=9)
        {
		    m_nSelectedSize = 0;
        }
	    else if (lMinFontSize <=12)
        {
		    m_nSelectedSize = 1;
        }
	    else if (lMinFontSize <=16)
        {
		    m_nSelectedSize = 2;
        }
    }
}

void WIZSCHEME::LoadOriginal()
{
    DBPRINTF(TEXT("LoadOriginal\r\n"));
	//
	// Save off current UI element colors, theme information, and wallpaper setting
	//

	for(int i=0;i<COLOR_MAX_97_NT5;i++)
		m_rgb[i] = GetSysColor(i);

	SaveTheme();
	SaveWallpaper();

	//
	// Save off the rest of the UI settings
	//

	SYSPARAMINFO(FILTERKEYS);
	SYSPARAMINFO(MOUSEKEYS);
	SYSPARAMINFO(STICKYKEYS);
	SYSPARAMINFO(TOGGLEKEYS);
	SYSPARAMINFO(SOUNDSENTRY);
	SYSPARAMINFO(ACCESSTIMEOUT);

	m_bShowSounds = GetSystemMetrics(SM_SHOWSOUNDS);
	SystemParametersInfo(SPI_GETKEYBOARDPREF, 0, &m_bShowExtraKeyboardHelp, 0);
	m_bSwapMouseButtons = GetSystemMetrics(SM_SWAPBUTTON);
	SystemParametersInfo(SPI_GETMOUSETRAILS, 0, &m_nMouseTrails, 0);
	SystemParametersInfo(SPI_GETMOUSESPEED,0, &m_nMouseSpeed, 0);
    SystemParametersInfo(SPI_GETCARETWIDTH, 0 , &m_dwCaretWidth, 0);
    m_uCursorBlinkTime = RegQueryStrDW(
							 DEFAULT_BLINK_RATE
						   , HKEY_CURRENT_USER
						   , CONTROL_PANEL_DESKTOP
						   , CURSOR_BLINK_RATE);
	m_nIconSize = SetShellLargeIconSize(0); // This just gets the current size
	m_nCursorScheme = 0;					// We are always using the 'current' cursor scheme =)

	m_PortableNonClientMetrics.LoadOriginal();

    // Save off current "New Schemes" settings if we aren't themed

    if (IsThemeActive())
    {
        LoadString(g_hInstDll, IDS_SCHEME_CURRENTCOLORSCHEME+100, m_szSelectedStyle, MAX_NUM_SZ);
        m_nSelectedSize = 0;
    }
    else
    {
        HKEY hk;
        if (RegOpenKeyEx(HKEY_CURRENT_USER, CPL_APPEARANCE_NEW_SCHEMES, 0, KEY_READ, &hk) == ERROR_SUCCESS)
        {
            DWORD ccb = ARRAYSIZE(m_szSelectedStyle)*sizeof(TCHAR);
            m_szSelectedStyle[0] = 0;
	        if (RegQueryValueEx(hk, NEW_SCHEMES_SELECTEDSTYLE, 0, NULL, (LPBYTE)m_szSelectedStyle, &ccb) == ERROR_SUCCESS && ccb > 2)
            {
                HKEY hkSub;
                if (RegOpenKeyEx(hk, m_szSelectedStyle, 0, KEY_READ, &hkSub) == ERROR_SUCCESS)
                {
                    TCHAR szSize[MAX_NUM_SZ] = {0};
                    ccb = ARRAYSIZE(szSize)*sizeof(TCHAR);
                    DBPRINTF(TEXT("RegQueryValueEx(NEW_SCHEMES_SELECTEDSIZE=%s,,,ccb=%d)\r\n"), NEW_SCHEMES_SELECTEDSIZE, ccb);

	                RegQueryValueEx(hkSub, NEW_SCHEMES_SELECTEDSIZE, 0, NULL, (LPBYTE)szSize, &ccb);

                    m_nSelectedSize = (szSize[0] && ccb > 2) ? _wtoi(szSize) : -1;
                    DBPRINTF(TEXT("szSize=%d ccb=%d m_nSelectedSize=%d\r\n"), szSize, ccb, m_nSelectedSize);
                    RegCloseKey(hkSub);
                }
            }
            RegCloseKey(hk);
        }
    }
}


/////////////////////////////////////////////////////////////////////
//  New way of enumerating fonts

#ifndef ENUMERATEFONTS

static LPCTSTR g_lpszFontNames[] =
{
	__TEXT("Arial"),
	__TEXT("MS Sans Serif"),
	__TEXT("Tahoma"),
	__TEXT("Times New Roman")
};

int GetFontCount()
{
	return ARRAYSIZE(g_lpszFontNames);
}

void GetFontLogFont(int nIndex, LOGFONT *pLogFont)
{
	_ASSERTE(nIndex < ARRAYSIZE(g_lpszFontNames));
	memset(pLogFont, 0, sizeof(*pLogFont));
	lstrcpy(pLogFont->lfFaceName, g_lpszFontNames[nIndex]);
}


#endif // ENUMERATEFONTS

//
/////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////
//  New way of storing schemes as hard coded values

// CONSIDER - this isn't a very robust way to do this; see sethc

#ifndef READSCHEMESFROMREGISTRY

#include "resource.h"

static SCHEMEDATALOCAL g_rgSchemeData[] = 
{
	{
		IDS_SCHEME_HIGHCONTRASTBLACKALTERNATE,
        {NULL},
#if(WINVER >= 0x0501)
        31,
#elif(WINVER == 0x0500)
        29,
#else
		25,
#endif
		{
			RGB(  0,   0,   0), // Scrollbar
			RGB(  0,   0,   0), // Background
			RGB(  0,   0, 255), // ActiveTitle
			RGB(  0, 255, 255), // InactiveTitle
			RGB(  0,   0,   0), // Menu
			RGB(  0,   0,   0), // Window
			RGB(255, 255, 255), // WindowFrame
			RGB(255, 255, 255), // MenuText
			RGB(255, 255,   0), // WindowText
			RGB(255, 255, 255), // TitleText
			RGB(  0,   0, 255), // ActiveBorder
			RGB(  0, 255, 255), // InactiveBorder
			RGB(  0,   0,   0), // AppWorkspace
			RGB(  0, 128,   0), // Hilight
			RGB(255, 255, 255), // HilightText
			RGB(  0,   0,   0), // ButtonFace
			RGB(128, 128, 128), // ButtonShadow
			RGB(  0, 255,   0), // GrayText
			RGB(255, 255, 255), // ButtonText
			RGB(  0,   0,   0), // InactiveTitleText
			RGB(192, 192, 192), // ButtonHilight
			RGB(255, 255, 255), // ButtonDkShadow
			RGB(255, 255, 255), // ButtonLight
			RGB(255, 255,   0), // InfoText
			RGB(  0,   0,   0), // InfoWindow
#if(WINVER >= 0x0500)
			RGB(192, 192, 192), // ButtonAlternateFace
			RGB(128,   0, 128), // HotTrackingColor
			RGB(  0,   0, 255), // GradientActiveTitle
			RGB(  0, 255, 255), // GradientInactiveTitle
#if(WINVER >= 0x0501)
			RGB(128,   0, 128), // MenuHighlighted
			RGB(  0,   0,   0)  // MenuBar
#endif /* WINVER >= 0x0501 */
#endif /* WINVER >= 0x0500 */
		}
	},
	{
		IDS_SCHEME_HIGHCONTRASTWHITEALTERNATE,
        {NULL},
#if(WINVER >= 0x0501)
        31,
#elif(WINVER == 0x0500)
        29,
#else
		25,
#endif
		{
			RGB(  0,   0,   0), // Scrollbar
			RGB(  0,   0,   0), // Background
			RGB(  0, 255, 255), // ActiveTitle
			RGB(  0,   0, 255), // InactiveTitle
			RGB(  0,   0,   0), // Menu
			RGB(  0,   0,   0), // Window
			RGB(255, 255, 255), // WindowFrame
			RGB(  0, 255,   0), // MenuText
			RGB(  0, 255,   0), // WindowText
			RGB(  0,   0,   0), // TitleText
			RGB(  0, 255, 255), // ActiveBorder
			RGB(  0,   0, 255), // InactiveBorder
			RGB(255, 251, 240), // AppWorkspace
			RGB(  0,   0, 255), // Hilight
			RGB(255, 255, 255), // HilightText
			RGB(  0,   0,   0), // ButtonFace
			RGB(128, 128, 128), // ButtonShadow
			RGB(  0, 255,   0), // GrayText
			RGB(  0, 255,   0), // ButtonText
			RGB(255, 255, 255), // InactiveTitleText
			RGB(192, 192, 192), // ButtonHilight
			RGB(255, 255, 255), // ButtonDkShadow
			RGB(255, 255, 255), // ButtonLight
			RGB(  0,   0,   0), // InfoText
			RGB(255, 255,   0), // InfoWindow
#if(WINVER >= 0x0500)
			RGB(192, 192, 192), // ButtonAlternateFace
			RGB(128,   0, 128), // HotTrackingColor
			RGB(  0, 255, 255), // GradientActiveTitle
			RGB(  0,   0, 255), // GradientInactiveTitle
#if(WINVER >= 0x0501)
			RGB(128,   0, 128), // MenuHighlighted
			RGB(  0,   0,   0)  // MenuBar
#endif /* WINVER >= 0x0501 */
#endif /* WINVER >= 0x0500 */
		}
	},
	{
		IDS_SCHEME_HIGHCONTRASTBLACK,
        {NULL},
#if(WINVER >= 0x0501)
        31,
#elif(WINVER == 0x0500)
        29,
#else
		25,
#endif
		{
			RGB(  0,   0,   0), // Scrollbar
			RGB(  0,   0,   0), // Background
			RGB(128,   0, 128), // ActiveTitle
			RGB(  0, 128,   0), // InactiveTitle
			RGB(  0,   0,   0), // Menu
			RGB(  0,   0,   0), // Window
			RGB(255, 255, 255), // WindowFrame
			RGB(255, 255, 255), // MenuText
			RGB(255, 255, 255), // WindowText
			RGB(255, 255, 255), // TitleText
			RGB(255, 255,   0), // ActiveBorder
			RGB(  0, 128,   0), // InactiveBorder
			RGB(  0,   0,   0), // AppWorkspace
			RGB(128,   0, 128), // Hilight
			RGB(255, 255, 255), // HilightText
			RGB(  0,   0,   0), // ButtonFace
			RGB(128, 128, 128), // ButtonShadow
			RGB(  0, 255,   0), // GrayText
			RGB(255, 255, 255), // ButtonText
			RGB(255, 255, 255), // InactiveTitleText
			RGB(192, 192, 192), // ButtonHilight
			RGB(255, 255, 255), // ButtonDkShadow
			RGB(255, 255, 255), // ButtonLight
			RGB(255, 255, 255), // InfoText
			RGB(  0,   0,   0), // InfoWindow
#if(WINVER >= 0x0500)
			RGB(192, 192, 192), // ButtonAlternateFace
			RGB(128,   0, 128), // HotTrackingColor
			RGB(128,   0, 128), // GradientActiveTitle
			RGB(  0, 128,   0), // GradientInactiveTitle
#if(WINVER >= 0x0501)
			RGB(128,   0, 128), // MenuHighlighted
			RGB(  0,   0,   0)  // MenuBar
#endif /* WINVER >= 0x0501 */
#endif /* WINVER >= 0x0500 */
		}
	},
	{
		IDS_SCHEME_HIGHCONTRASTWHITE,
        {NULL},
#if(WINVER >= 0x0501)
        31,
#elif(WINVER == 0x0500)
        29,
#else
		25,
#endif
		{
			RGB(255, 255, 255), // Scrollbar
			RGB(255, 255, 255), // Background
			RGB(  0,   0,   0), // ActiveTitle
			RGB(255, 255, 255), // InactiveTitle
			RGB(255, 255, 255), // Menu
			RGB(255, 255, 255), // Window
			RGB(  0,   0,   0), // WindowFrame
			RGB(  0,   0,   0), // MenuText             (enabled menu text FlatMenuMode = TRUE)
			RGB(  0,   0,   0), // WindowText
			RGB(255, 255, 255), // TitleText
			RGB(128, 128, 128), // ActiveBorder
			RGB(192, 192, 192), // InactiveBorder
			RGB(128, 128, 128), // AppWorkspace
			RGB(  0,   0,   0), // Hilight              (and enabled menu highlighted background FlatMenuMode = FALSE)
			RGB(255, 255, 255), // HilightText          (and menu highlighted text FlatMenuMode = FALSE)
			RGB(255, 255, 255), // ButtonFace
			RGB(128, 128, 128), // ButtonShadow
			RGB(  0, 255,   0), // GrayText             (disabled menu text highlighted = green)
			RGB(  0,   0,   0), // ButtonText
			RGB(  0,   0,   0), // InactiveTitleText
			RGB(192, 192, 192), // ButtonHilight        (disabled menu text = grey)
			RGB(  0,   0,   0), // ButtonDkShadow
			RGB(192, 192, 192), // ButtonLight
			RGB(  0,   0,   0), // InfoText
			RGB(255, 255, 255), // InfoWindow
#if(WINVER >= 0x0500)
			RGB(192, 192, 192), // ButtonAlternateFace
			RGB(  0,   0,   0), // HotTrackingColor
			RGB(  0,   0,   0), // GradientActiveTitle
			RGB(255, 255, 255), // GradientInactiveTitle
#if(WINVER >= 0x0501)
			RGB(  0,   0,   0), // MenuHighlighted      (enabled menu highlighted background FlatMenuMode = TRUE)
			RGB(255, 255, 255)  // MenuBar
#endif /* WINVER >= 0x0501 */
#endif /* WINVER >= 0x0500 */
		}
	}
};


int GetSchemeCount()
{
	return ARRAYSIZE(g_rgSchemeData);
}

// GetSchemeName is only called to initialize the color scheme list box
void GetSchemeName(int nIndex, LPTSTR lpszName, int nLen) // JMC: HACK - You must allocate enough space
{
	_ASSERTE(nIndex < ARRAYSIZE(g_rgSchemeData));
	LoadString(g_hInstDll, g_rgSchemeData[nIndex].nNameStringId, lpszName, nLen);   // return the name
    LoadString(g_hInstDll, g_rgSchemeData[nIndex].nNameStringId+100
                         , g_rgSchemeData[nIndex].szNameIndexId
                         , ARRAYSIZE(g_rgSchemeData[nIndex].szNameIndexId));        // get the "SelectedStyle" index
}

SCHEMEDATALOCAL &GetScheme(int nIndex)
{
	_ASSERTE(nIndex < ARRAYSIZE(g_rgSchemeData));
	return g_rgSchemeData[nIndex];
}


#endif // READSCHEMESFROMREGISTRY

//
/////////////////////////////////////////////////////////////////////





/////////////////////////////////////////////////////////////////////
// Below this point in the file, we have the old way we use
// to enumerate fonts and schemes.





/////////////////////////////////////////////////////////////////////
//  Old way of enumerating fonts
#ifdef ENUMERATEFONTS

// Global Variables
static ENUMLOGFONTEX g_rgFonts[200]; // JMC: HACK - At Most 200 Fonts
static int g_nFontCount = 0;
static BOOL bFontsAlreadyInit = FALSE;

void Font_Init();

int GetFontCount()
{
	if(!bFontsAlreadyInit)
		Font_Init();
	return g_nFontCount;
}

void GetFontLogFont(int nIndex, LOGFONT *pLogFont)
{
	if(!bFontsAlreadyInit)
		Font_Init();
	*pLogFont = g_rgFonts[nIndex].elfLogFont;
}


int CALLBACK EnumFontFamExProc(
    ENUMLOGFONTEX *lpelfe,	// pointer to logical-font data
    NEWTEXTMETRICEX *lpntme,	// pointer to physical-font data
    int FontType,	// type of font
    LPARAM lParam	// application-defined data 
   )
{
	if(g_nFontCount>200)
		return 0; // JMC: HACK - Stop enumerating if more than 200 families

	// Don't use if we already have this font name
	BOOL bHave = FALSE;
	for(int i=0;i<g_nFontCount;i++)
		if(0 == lstrcmp((TCHAR *)g_rgFonts[i].elfFullName, (TCHAR *)lpelfe->elfFullName))
		{
			bHave = TRUE;
			break;
		}
	if(!bHave)
		g_rgFonts[g_nFontCount++] = *lpelfe;
	return 1;
}

void Font_Init()
{
	// Only do the stuff in this function once.
	if(bFontsAlreadyInit)
		return;
	bFontsAlreadyInit = TRUE;

	LOGFONT lf;
	memset(&lf, 0, sizeof(lf));
//	lf.lfCharSet = DEFAULT_CHARSET;
	lf.lfCharSet = OEM_CHARSET;
	HDC hdc = GetDC(NULL);
	EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)EnumFontFamExProc, 0, 0);
	ReleaseDC(NULL, hdc);
	// JMC: Make sure there is at least one font
}

#endif ENUMERATEFONTS

//
/////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////
//  Old way of reading schemes from the registry

#ifdef READSCHEMESFROMREGISTRY

extern PTSTR s_pszColorNames[]; // JMC: HACK


// Scheme data for Windows 95
typedef struct {
    SHORT version;
//    NONCLIENTMETRICSA ncm;
//    LOGFONTA lfIconTitle;
	BYTE rgDummy[390]; // This is the size of NONCLIENTMETRICSA and LOGFONTA in 16 bit Windows!!!
    COLORREF rgb[COLOR_MAX_95_NT4];
} SCHEMEDATA_95;

// New scheme data for Windows 97
typedef struct {
    SHORT version;
//    NONCLIENTMETRICSA ncm;
//    LOGFONTA lfIconTitle;
	BYTE rgDummy[390]; // This is the size of NONCLIENTMETRICSA and LOGFONTA in 16 bit Windows!!!
    COLORREF rgb[COLOR_MAX_97_NT5];
} SCHEMEDATA_97;

// Scheme data for Windows NT 4.0
typedef struct {
    SHORT version;
    WORD  wDummy;               // for alignment
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX_95_NT4];
} SCHEMEDATA_NT4;

// Scheme data for Windows NT 5.0
typedef struct {
    SHORT version;
    WORD  wDummy;               // for alignment
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX_97_NT5];
} SCHEMEDATA_NT5;

static SCHEMEDATALOCAL g_rgSchemeData[100]; // JMC: HACK - At Most 100 schemes
static TCHAR g_rgSchemeNames[100][100];
static int g_nSchemeCount = 0;
static BOOL bSchemesAlreadyInit = FALSE;

void Scheme_Init();

int GetSchemeCount()
{
	Scheme_Init();
	return g_nSchemeCount;
}

void GetSchemeName(int nIndex, LPTSTR lpszName, int nLen) // JMC: HACK - You must allocate enough space
{
	Scheme_Init();
	_tcsncpy(lpszName, g_rgSchemeNames[i], nLen - 1);
	lpstName[nLen - 1] = 0; // Guarantee NULL termination
}

SCHEMEDATALOCAL &GetScheme(int nIndex)
{
	Scheme_Init();
	return g_rgSchemeData[nIndex];
}

void Scheme_Init()
{
	// Only do the stuff in this function once.
	if(bSchemesAlreadyInit)
		return;
	bSchemesAlreadyInit = TRUE;

    HKEY hkSchemes;
    DWORD dw, dwSize;
    TCHAR szBuf[100];

	g_nSchemeCount = 0;

    if (RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_LOOKSCHEMES, &hkSchemes) != ERROR_SUCCESS)
        return;

    for (dw=0; ; dw++)
    {
		if(g_nSchemeCount>99)
			break; //JMC: HACK - At Most 100 schemes

        dwSize = ARRAYSIZE(szBuf);
        if (RegEnumValue(hkSchemes, dw, szBuf, &dwSize, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
            break;  // Bail if no more values

		DWORD dwType;
		DWORD dwSize;
		RegQueryValueEx(hkSchemes, szBuf, NULL, &dwType, NULL, &dwSize);
		if(dwType == REG_BINARY)
		{
			// Always copy the current name to the name array - if there
			// is an error in the data, we just won't upcount g_nSchemeCount
			lstrcpy(g_rgSchemeNames[g_nSchemeCount], szBuf);

			// Find out which type of scheme this is, and convert to the
			// SCHEMEDATALOCAL type
			switch(dwSize)
			{
			case sizeof(SCHEMEDATA_95):
				{
					SCHEMEDATA_95 sd;
					RegQueryValueEx(hkSchemes, szBuf, NULL, &dwType, (BYTE *)&sd, &dwSize);
					if(1 != sd.version)
						break; // We have the wrong version even though the size was correct

					// Copy the color information from the registry info to g_rgSchemeData
					g_rgSchemeData[g_nSchemeCount].nColorsUsed = COLOR_MAX_95_NT4;

					// Copy the color array
					for(int i=0;i<g_rgSchemeData[g_nSchemeCount].nColorsUsed;i++)
						g_rgSchemeData[g_nSchemeCount].rgb[i] = sd.rgb[i];

					g_nSchemeCount++;
				}
				break;
			case sizeof(SCHEMEDATA_NT4):
				{
					SCHEMEDATA_NT4 sd;
					RegQueryValueEx(hkSchemes, szBuf, NULL, &dwType, (BYTE *)&sd, &dwSize);
					if(2 != sd.version)
						break; // We have the wrong version even though the size was correct

					// Copy the color information from the registry info to g_rgSchemeData
					g_rgSchemeData[g_nSchemeCount].nColorsUsed = COLOR_MAX_95_NT4;

					// Copy the color array
					for(int i=0;i<g_rgSchemeData[g_nSchemeCount].nColorsUsed;i++)
						g_rgSchemeData[g_nSchemeCount].rgb[i] = sd.rgb[i];

					g_nSchemeCount++;
				}
				break;
			case sizeof(SCHEMEDATA_97):
				{
					SCHEMEDATA_97 sd;
					RegQueryValueEx(hkSchemes, szBuf, NULL, &dwType, (BYTE *)&sd, &dwSize);
					if(3 != sd.version)
						break; // We have the wrong version even though the size was correct

					// Copy the color information from the registry info to g_rgSchemeData
					g_rgSchemeData[g_nSchemeCount].nColorsUsed = COLOR_MAX_97_NT5;

					// Copy the color array
					for(int i=0;i<g_rgSchemeData[g_nSchemeCount].nColorsUsed;i++)
						g_rgSchemeData[g_nSchemeCount].rgb[i] = sd.rgb[i];

					g_nSchemeCount++;
				}
				break;
			case sizeof(SCHEMEDATA_NT5):
				{
					SCHEMEDATA_NT5 sd;
					RegQueryValueEx(hkSchemes, szBuf, NULL, &dwType, (BYTE *)&sd, &dwSize);
					if(2 != sd.version)
						break; // We have the wrong version even though the size was correct

					// Copy the color information from the registry info to g_rgSchemeData
					g_rgSchemeData[g_nSchemeCount].nColorsUsed = COLOR_MAX_97_NT5;

					// Copy the color array
					for(int i=0;i<g_rgSchemeData[g_nSchemeCount].nColorsUsed;i++)
						g_rgSchemeData[g_nSchemeCount].rgb[i] = sd.rgb[i];

					g_nSchemeCount++;
				}
				break;
			default:
				// We had an unknown sized structure in the registry - IGNORE IT
#ifdef _DEBUG
				TCHAR sz[200];
				wsprintf(sz, __TEXT("Scheme - %s, size = %i, sizeof(95) = %i, sizeof(NT4) = %i, sizeof(97) = %i, sizeof(NT5) = %i"), szBuf, dwSize,
						sizeof(SCHEMEDATA_95),
						sizeof(SCHEMEDATA_NT4),
						sizeof(SCHEMEDATA_97),
						sizeof(SCHEMEDATA_NT5)
						);
				MessageBox(NULL, sz, NULL, MB_OK);
#endif // _DEBUG
				break;
			}
		}
    }
    RegCloseKey(hkSchemes);
}

#endif // READSCHEMESFROMREGISTRY

void PORTABLE_NONCLIENTMETRICS::ApplyChanges() const
{
		NONCLIENTMETRICS ncmOrig;
		LOGFONT lfIconOrig;
		GetNonClientMetrics(&ncmOrig, &lfIconOrig);

		NONCLIENTMETRICS ncmNew;
		LOGFONT lfIconNew;

		ZeroMemory(&ncmNew, sizeof(ncmNew));
		ZeroMemory(&lfIconNew, sizeof(lfIconNew));

		ncmNew.cbSize = sizeof(ncmNew);
		ncmNew.iBorderWidth = m_iBorderWidth;
		ncmNew.iScrollWidth = m_iScrollWidth;
		ncmNew.iScrollHeight = m_iScrollHeight;
		ncmNew.iCaptionWidth = m_iCaptionWidth;
		ncmNew.iCaptionHeight = m_iCaptionHeight;
		ncmNew.lfCaptionFont.lfHeight = m_lfCaptionFont_lfHeight;
		ncmNew.lfCaptionFont.lfWeight = m_lfCaptionFont_lfWeight;
		ncmNew.iSmCaptionWidth = m_iSmCaptionWidth;
		ncmNew.iSmCaptionHeight = m_iSmCaptionHeight;
		ncmNew.lfSmCaptionFont.lfHeight = m_lfSmCaptionFont_lfHeight;
		ncmNew.lfSmCaptionFont.lfWeight = m_lfSmCaptionFont_lfWeight;
		ncmNew.iMenuWidth = m_iMenuWidth;
		ncmNew.iMenuHeight = m_iMenuHeight;
		ncmNew.lfMenuFont.lfHeight = m_lfMenuFont_lfHeight;
		ncmNew.lfMenuFont.lfWeight = m_lfMenuFont_lfWeight;
		ncmNew.lfStatusFont.lfHeight = m_lfStatusFont_lfHeight;
		ncmNew.lfStatusFont.lfWeight = m_lfStatusFont_lfWeight;
		ncmNew.lfMessageFont.lfHeight = m_lfMessageFont_lfHeight;
		ncmNew.lfMessageFont.lfWeight = m_lfMessageFont_lfWeight;
		lfIconNew.lfHeight = m_lfIconWindowsDefault_lfHeight;
		lfIconNew.lfWeight = m_lfIconWindowsDefault_lfWeight;


		// Fill in fonts
		if(m_nFontFaces)
		{
			TCHAR lfFaceName[LF_FACESIZE];
			LoadString(g_hInstDll, IDS_SYSTEMFONTNAME, lfFaceName, ARRAYSIZE(lfFaceName));

			BYTE lfCharSet;
			TCHAR szCharSet[20];
			if(LoadString(g_hInstDll,IDS_FONTCHARSET, szCharSet,sizeof(szCharSet)/sizeof(TCHAR))) {
				lfCharSet = (BYTE)_tcstoul(szCharSet,NULL,10);
			} else {
				lfCharSet = 0; // Default
			}

			ncmNew.lfCaptionFont.lfCharSet = lfCharSet;
			ncmNew.lfSmCaptionFont.lfCharSet = lfCharSet;
			ncmNew.lfMenuFont.lfCharSet = lfCharSet;
			ncmNew.lfStatusFont.lfCharSet = lfCharSet;
			ncmNew.lfMessageFont.lfCharSet = lfCharSet;
			lfIconNew.lfCharSet = lfCharSet;

			lstrcpy(ncmNew.lfCaptionFont.lfFaceName, lfFaceName);
			lstrcpy(ncmNew.lfSmCaptionFont.lfFaceName, lfFaceName);
			lstrcpy(ncmNew.lfMenuFont.lfFaceName, lfFaceName);
			lstrcpy(ncmNew.lfStatusFont.lfFaceName, lfFaceName);
			lstrcpy(ncmNew.lfMessageFont.lfFaceName, lfFaceName);
			lstrcpy(lfIconNew.lfFaceName, lfFaceName);
		}
		else
		{
			ncmNew.lfCaptionFont.lfCharSet = ncmOrig.lfCaptionFont.lfCharSet;
			ncmNew.lfSmCaptionFont.lfCharSet = ncmOrig.lfSmCaptionFont.lfCharSet;
			ncmNew.lfMenuFont.lfCharSet = ncmOrig.lfMenuFont.lfCharSet;
			ncmNew.lfStatusFont.lfCharSet = ncmOrig.lfStatusFont.lfCharSet;
			ncmNew.lfMessageFont.lfCharSet = ncmOrig.lfMessageFont.lfCharSet;
			lfIconNew.lfCharSet = lfIconOrig.lfCharSet;

			lstrcpy(ncmNew.lfCaptionFont.lfFaceName, ncmOrig.lfCaptionFont.lfFaceName);
			lstrcpy(ncmNew.lfSmCaptionFont.lfFaceName, ncmOrig.lfSmCaptionFont.lfFaceName);
			lstrcpy(ncmNew.lfMenuFont.lfFaceName, ncmOrig.lfMenuFont.lfFaceName);
			lstrcpy(ncmNew.lfStatusFont.lfFaceName, ncmOrig.lfStatusFont.lfFaceName);
			lstrcpy(ncmNew.lfMessageFont.lfFaceName, ncmOrig.lfMessageFont.lfFaceName);
			lstrcpy(lfIconNew.lfFaceName, lfIconOrig.lfFaceName);
		}


		if(0 != memcmp(&ncmNew, &ncmOrig, sizeof(ncmOrig)))
			SystemParametersInfo(SPI_SETNONCLIENTMETRICS, sizeof(ncmNew), (PVOID)&ncmNew, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
		if(0 != memcmp(&lfIconNew, &lfIconOrig, sizeof(lfIconOrig)))
			SystemParametersInfo(SPI_SETICONTITLELOGFONT, sizeof(lfIconNew), &lfIconNew, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
}

// Helpers for setting/getting numeric string reg entry 
void WINAPI RegQueryStr(
   LPTSTR lpDefault,
   HKEY hkey,
   LPTSTR lpSubKey,
   LPTSTR lpValueName,
   LPTSTR lpszValue,
   DWORD cbData) // note this is bytes, not characters.
{
   DWORD dwType;

   lstrcpy(lpszValue, lpDefault);
   if (ERROR_SUCCESS == RegOpenKeyEx(hkey, lpSubKey, 0, KEY_QUERY_VALUE, &hkey)) 
   {
      RegQueryValueEx(hkey, lpValueName, NULL, &dwType, (PBYTE) lpszValue, &cbData);
      RegCloseKey(hkey);
   }
}

BOOL RegSetStr(
    HKEY hkey,
    LPCTSTR lpSection,
    LPCTSTR lpKeyName,
    LPCTSTR lpString)
{
    BOOL fRet = FALSE;
    LONG lErr;
    DWORD dwDisposition;

    lErr = RegCreateKeyEx(
            hkey,
            lpSection,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE,
            NULL,
            &hkey,
            &dwDisposition);

    if (ERROR_SUCCESS == lErr)
    {
        if (NULL != lpString)
        {
            lErr = RegSetValueEx(
                    hkey,
                    lpKeyName,
                    0,
                    REG_SZ,
                    (CONST BYTE *)lpString,
                    (lstrlen(lpString) + 1) * sizeof(*lpString));
        }
        else
        {
            lErr = RegSetValueEx(
                    hkey,
                    lpKeyName,
                    0,
                    REG_SZ,
                    (CONST BYTE *)__TEXT(""),
                    1 * sizeof(*lpString));
        }

        if (ERROR_SUCCESS == lErr)
        {
            fRet = TRUE;
        }
        RegCloseKey(hkey);
    }
    return(fRet);
}

DWORD WINAPI RegQueryStrDW(
    DWORD dwDefault,
    HKEY hkey,
    LPTSTR lpSubKey,
    LPTSTR lpValueName)
{
    DWORD dwRet = dwDefault;
    TCHAR szTemp[40];
    TCHAR szDefault[40];

    wsprintf(szDefault, TEXT("%d"), dwDefault);

    RegQueryStr(szDefault, hkey, lpSubKey, lpValueName, szTemp, sizeof(szTemp));

    dwRet = _ttol(szTemp);

    return dwRet;
}


BOOL RegSetStrDW(HKEY hkey, LPTSTR lpSection, LPCTSTR lpKeyName, DWORD dwValue)
{
    TCHAR szTemp[40];

    wsprintf(szTemp, TEXT("%d"), dwValue);
    return RegSetStr(hkey, lpSection, lpKeyName, szTemp);
}

//
/////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\select.h ===
//Copyright (c) 1997-2000 Microsoft Corporation

#ifndef _INC_SELECT_H
#define _INC_SELECT_H


class WizardPage;
void DrawHilight(HWND hWnd, LPDRAWITEMSTRUCT ldi);

// CIconSizePg
class CIconSizePg : public WizardPage
{
public:
    CIconSizePg(LPPROPSHEETPAGE ppsp);

protected:
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam );
	LRESULT OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);

private:
	void Draw(LPDRAWITEMSTRUCT ldi, int i);
	inline void SetFocussedItem(int m_nCurrentHilight);
	inline void InvalidateRects(int PrevHilight);
	LRESULT SelectionChanged(int nNewSelection);
	UINT GetCtrlID(int);

	int m_nCountValues;
	int m_rgnValues[MAX_DISTINCT_VALUES];
	int m_nCurValueIndex;
	int m_nCurrentHilight;
	BOOL syncInit;
	UINT uIDEvent;
};


// CScrollBarPg
class CScrollBarPg : public WizardPage
{
public:
    CScrollBarPg(LPPROPSHEETPAGE ppsp);

protected:
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	
	LRESULT OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam );
	LRESULT OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);

private:
	void Draw(LPDRAWITEMSTRUCT ldi, int i);
	inline void SetFocussedItem(int m_nCurrentHilight);
	inline void InvalidateRects(int PrevHilight);
	LRESULT SettingChanged(int sel);
	UINT GetCtrlID(int);

	int m_nCountValues;
	int m_rgnValues[MAX_DISTINCT_VALUES];
	int m_nCurValueIndex;
	int m_nCurrentHilight;
	BOOL syncInit;
	UINT uIDEvent;
};


#endif // _INC_SELECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\sources.inc ===
TARGETNAME=accwiz
TARGETPATH=obj
TARGETTYPE=PROGRAM
USE_MSVCRT=1
USE_NATIVE_EH=1

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(WINDOWS_LIB_PATH)\user32p.lib   \
           $(SDK_LIB_PATH)\gdi32.lib    \
           $(SDK_LIB_PATH)\mpr.lib      \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\comctl32.lib \
           $(SDK_LIB_PATH)\comdlg32.lib \
           $(SDK_LIB_PATH)\syssetup.lib \
           $(SDK_LIB_PATH)\setupapi.lib \
           $(SDK_LIB_PATH)\version.lib  \
           $(SDK_LIB_PATH)\shlwapi.lib  \
           $(SHELL_LIB_PATH)\shell32p.lib \
           $(SDK_LIB_PATH)\ole32.lib    \
		   $(SHELL_LIB_PATH)\uxthemep.lib

NOT_LEAN_AND_MEAN=1

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..;$(WINDOWS_INC_PATH);..\..\inc;$(SHELL_INC_PATH)

SOURCES= ..\Accwiz.cpp      \
         ..\CurSchme.cpp    \
         ..\DLGFONTS.CPP    \
         ..\LOOKDLG.CPP     \
         ..\LOOKPREV.CPP    \
         ..\precomp.CPP     \
         ..\Pgbase.cpp      \
         ..\Pgfinish.cpp    \
         ..\PGGENRIC.CPP    \
         ..\PGLOKPRV.CPP    \
         ..\PGMSEBUT.CPP    \
         ..\Pgmsecur.cpp    \
         ..\PGSVEDEF.CPP    \
         ..\Pgsvefil.cpp    \
         ..\PGTMEOUT.CPP    \
         ..\pgnWelCome.cpp  \
         ..\pgWelco2.cpp    \
         ..\pgWelcom.cpp    \
         ..\Pgwizopt.cpp    \
         ..\pgcaret.cpp     \
         ..\SCHEMES.CPP     \
         ..\Select.cpp      \
         ..\accwiz.rc

UMENTRY=winmain

UMTYPE=windows

PRECOMPILED_INCLUDE=..\pch.hxx
PRECOMPILED_PCH=pch.pch
PRECOMPILED_OBJ=pch.obj
PRECOMPILED_CXX=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\accwiz\version.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
// ACCWIZ.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "Microsoft Accessibility Wizard"
#define VER_INTERNALNAME_STR        "ACCWIZ"
#define VER_ORIGINALFILENAME_STR    "ACCWIZ.EXE"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\inc\mappedfile.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
//
// This header contains classes used to manage the memory mapped file for this DLL
//

class CScopeMutex
{
public:
    CScopeMutex()
        : m_hMutex(0)
        {};
    ~CScopeMutex() { MutexRelease(); }
    BOOL Create(LPCTSTR szMutex, unsigned long ulWait)
    {
	    m_hMutex = CreateMutex( NULL, FALSE, szMutex );
        if (m_hMutex)
        {
    	    WaitForSingleObject(m_hMutex, ulWait);
			return TRUE;
        }
	    DBPRINTF(TEXT("CScopeMutex::Create FAILED\r\n"));
        return FALSE;
    }
    void Release()
    {
        MutexRelease();
    }

private:
    HANDLE m_hMutex;

    inline void MutexRelease()
    {
        if (m_hMutex)
        {
	        ReleaseMutex(m_hMutex);
	        CloseHandle(m_hMutex);
            m_hMutex = 0;
        }
    }
};

class CMemMappedFile 
{
public:
    CMemMappedFile()     
        : m_hMappedFile(0)
        , m_pvMappedAddr(0)
        , m_fFirstOpen(FALSE)
        {};
    ~CMemMappedFile() { Close(); }
    BOOL Open(LPCTSTR szName, unsigned long ulMemSize);
    BOOL AccessMem(void **ppvMappedAddr);
    void Close();
    BOOL FirstOpen() { return m_fFirstOpen; }

private:
    HANDLE m_hMappedFile;
    void *m_pvMappedAddr;
    BOOL m_fFirstOpen;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\inc\tssessionnotify.c ===
#include "wtsapi32.h"   // for terminal services

typedef LRESULT CALLBACK FN_TSNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
typedef BOOL (WINAPI *LPWTSREGISTERSESSIONNOTIFICATION)(HWND hWnd, DWORD dwFlags);
typedef BOOL (WINAPI *LPWTSUNREGISTERSESSIONNOTIFICATION)(HWND hWnd);
HMODULE g_hLibrary = 0;
LPWTSREGISTERSESSIONNOTIFICATION g_lpfnWTSRegisterSessionNotification = 0;
LPWTSUNREGISTERSESSIONNOTIFICATION g_lpfnWTSUnRegisterSessionNotification = 0;

BOOL GetWTSLib()
{
	g_hLibrary = LoadLibrary(TEXT("wtsapi32.dll"));
	if (g_hLibrary)
	{
	    g_lpfnWTSRegisterSessionNotification 
            = (LPWTSREGISTERSESSIONNOTIFICATION)GetProcAddress(
                                                      g_hLibrary
                                                    , "WTSRegisterSessionNotification");
	    g_lpfnWTSUnRegisterSessionNotification 
            = (LPWTSUNREGISTERSESSIONNOTIFICATION)GetProcAddress(
                                                      g_hLibrary
                                                    , "WTSUnRegisterSessionNotification");
	}
    return (g_lpfnWTSRegisterSessionNotification 
         && g_lpfnWTSUnRegisterSessionNotification)?TRUE:FALSE;
}

void FreeWTSLib()
{
	if (g_hLibrary)
	{
		FreeLibrary(g_hLibrary);
        g_hLibrary = 0;
        g_lpfnWTSRegisterSessionNotification = 0;
        g_lpfnWTSUnRegisterSessionNotification = 0;
	}
}

// CreateWTSNotifyWindow - create a message-only windows to handle 
// terminal server notification messages
//
HWND CreateWTSNotifyWindow(HINSTANCE hInstance, FN_TSNotifyWndProc lpfnTSNotifyWndProc)
{
    HWND hWnd = 0;

    if (GetWTSLib())
    {
        LPTSTR pszWindowClass = TEXT("TS Notify Window");
	    WNDCLASS wc;
	    wc.style = 0;
	    wc.lpfnWndProc = lpfnTSNotifyWndProc;
        wc.cbClsExtra = 0;
	    wc.cbWndExtra = 0;
	    wc.hInstance = hInstance;
        wc.hIcon = NULL;
	    wc.hCursor = NULL;
	    wc.hbrBackground = NULL;
        wc.lpszMenuName = NULL;
	    wc.lpszClassName = pszWindowClass;

        // RegisterClass can legally fail sometimes.  If the class fails 
        // to register, we'll fail when we try to create the window.

	    RegisterClass(&wc);

	    // Create window to receive terminal service notification messages
        hWnd = CreateWindow(
                      pszWindowClass
                    , NULL,0,0,0,0,0
                    , HWND_MESSAGE
                    , NULL, hInstance, NULL);
	    if( hWnd )
	    {
            if (!g_lpfnWTSRegisterSessionNotification(hWnd, NOTIFY_FOR_THIS_SESSION))
            {
                DBPRINTF(TEXT("CreateWTSNotifyWindow:  WTSRegisterSessionNotification FAILED %d\r\n"), GetLastError());
                DestroyWindow(hWnd);
                hWnd = 0;
            }
        }
    }

    return hWnd;
}

// DestroyWTSNotifyWindow - clean up terminal server notification window
//
void DestroyWTSNotifyWindow(HWND hWnd)
{
	if(hWnd && g_lpfnWTSUnRegisterSessionNotification)
	{
        g_lpfnWTSUnRegisterSessionNotification(hWnd);
        DBPRINTF(TEXT("DestroyWTSNotifyWindow:  WTSUnRegisterSessionNotification returned %d\r\n"), GetLastError());
    }

	if(hWnd)
	{
        DestroyWindow(hWnd);
    }
    FreeWTSLib();
}

/*
// TSNotifyWndProc - callback that receives window message notifications from terminal services
//
// This is a sample notification callback function
//
LRESULT CALLBACK TSNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg != WM_WTSSESSION_CHANGE)
        return 0;

	switch (wParam)
	{
		case WTS_CONSOLE_CONNECT:   // local session is connected
		break;

		case WTS_CONSOLE_DISCONNECT:// local session is disconnected
		break;

		case WTS_REMOTE_CONNECT:    // remote session is connected
		break;

		case WTS_REMOTE_DISCONNECT: // remote session is disconnected
		break;

		case WTS_SESSION_LOGON:     // session is being logged on
		break;

		case WTS_SESSION_LOGOFF:    // session is being logged off
		break;

		default:
		break;
	}

	return DefWindowProc( hwnd, uMsg, wParam, lParam );
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\inc\w95trace.c ===
// Copyright (c) 1996-1999 Microsoft Corporation


/*
    Implementation of Win95 tracing facility to mimic that of NT. Works on both.
*/

#pragma warning(disable:4201)	// allows nameless structs and unions
#pragma warning(disable:4514)	// don't care when unreferenced inline functions are removed
#pragma warning(disable:4706)	// we are allowed to assign within a conditional


#include "windows.h"
#include <stdio.h>
#include <stdarg.h>
#include <process.h>
#include "w95trace.h"

// Uncomment the following line if you need debugging but can't use the mutex
//#define NOMUTEX

#if defined( _DEBUG ) ||defined( DEBUG ) || defined( DBG )

#ifdef __cplusplus
extern "C" {
#endif

static HANDLE g_hSpewFile = INVALID_HANDLE_VALUE;

__inline BOOL TestMutex()
{
#ifndef NOMUTEX
    HANDLE hTestMutex = OpenMutex( SYNCHRONIZE, FALSE, TEXT("oleacc-msaa-use-dbwin") );
    if( ! hTestMutex )
        return FALSE;
    CloseHandle( hTestMutex );
#endif
    return TRUE;
}

void OutputDebugStringW95( LPCTSTR lpOutputString, ...)
{
    // Only produce output if this mutex is set...
    if (TestMutex())
	{
        HANDLE heventDBWIN;  /* DBWIN32 synchronization object */
        HANDLE heventData;   /* data passing synch object */
        HANDLE hSharedFile;  /* memory mapped file shared data */
        LPTSTR lpszSharedMem;
        TCHAR achBuffer[500];
        int cch;

        /* create the output buffer */
        va_list args;
        va_start(args, lpOutputString);
        cch = wvsprintf(achBuffer, lpOutputString, args);
        va_end(args);

        /* 
            Do a regular OutputDebugString so that the output is 
            still seen in the debugger window if it exists.

            This ifdef is necessary to avoid infinite recursion 
            from the inclusion of W95TRACE.H
        */
#ifdef UNICODE
        OutputDebugStringW(achBuffer);
#else
        ::OutputDebugStringA(achBuffer);
#endif

//        Uncomment the following lines if you need DBPRINTF lines to go to a file
//        (your code will have to open and close the file)
//        if (g_hSpewFile && g_hSpewFile != INVALID_HANDLE_VALUE)
//        {
//            SpewToFile(achBuffer);
//        }

        /* bail if it's not Win95 */
        {
            OSVERSIONINFO VerInfo;
            VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            GetVersionEx(&VerInfo);
            if ( VerInfo.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS )
                return;
        }

        /* make sure DBWIN is open and waiting */
        heventDBWIN = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_BUFFER_READY"));
        if ( !heventDBWIN )
        {
            //MessageBox(NULL, TEXT("DBWIN_BUFFER_READY nonexistent"), NULL, MB_OK);
            return;            
        }

        /* get a handle to the data synch object */
        heventData = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_DATA_READY"));
        if ( !heventData )
        {
            // MessageBox(NULL, TEXT("DBWIN_DATA_READY nonexistent"), NULL, MB_OK);
            CloseHandle(heventDBWIN);
            return;            
        }
    
        hSharedFile = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0, 4096, TEXT("DBWIN_BUFFER"));
        if (!hSharedFile) 
        {
            //MessageBox(NULL, TEXT("DebugTrace: Unable to create file mapping object DBWIN_BUFFER"), TEXT("Error"), MB_OK);
            CloseHandle(heventDBWIN);
            CloseHandle(heventData);
            return;
        }

        lpszSharedMem = (LPTSTR)MapViewOfFile(hSharedFile, FILE_MAP_WRITE, 0, 0, 512);
        if (!lpszSharedMem) 
        {
            //MessageBox(NULL, "DebugTrace: Unable to map shared memory", "Error", MB_OK);
            CloseHandle(heventDBWIN);
            CloseHandle(heventData);
            return;
        }

        /* wait for buffer event */
        WaitForSingleObject(heventDBWIN, INFINITE);

        /* write it to the shared memory */
        *((LPDWORD)lpszSharedMem) = _getpid();
        wsprintf(lpszSharedMem + sizeof(DWORD), TEXT("%s"), achBuffer);

        /* signal data ready event */
        SetEvent(heventData);

        /* clean up handles */
        CloseHandle(hSharedFile);
        CloseHandle(heventData);
        CloseHandle(heventDBWIN);
	}
    return;
}
void SpewOpenFile(LPCTSTR pszSpewFile)
{
#ifdef UNICODE // only works for unicode
    // Only produce output if this mutex is set...
    if (g_hSpewFile == INVALID_HANDLE_VALUE && TestMutex())
    {
        TCHAR szSpewFile[MAX_PATH] = TEXT("C:\\");
#ifndef NOMUTEX
        // if NOMUTEX is defined most likely you are debugging when
        // there's no interactive user (so no temp path)
        GetTempPath(MAX_PATH, szSpewFile);
#endif
        if (lstrlen(szSpewFile)+lstrlen(pszSpewFile) >= MAX_PATH)
        {
            MessageBox(NULL, TEXT("SpewOpenFile:  Name will be longer than MAX_PATH"), TEXT("OOPS"), MB_OK);
            return;
        }
        lstrcat(szSpewFile, pszSpewFile);
        g_hSpewFile = CreateFile(szSpewFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == g_hSpewFile)
        {
//            MessageBox(NULL, TEXT("SpewOpenFile:  Unable to open spew file"), TEXT("Error"), MB_OK);
        }
    }
#endif
}
void SpewToFile( LPCTSTR lpOutputString, ...)
{
#ifdef UNICODE // only works for unicode
    if (g_hSpewFile != INVALID_HANDLE_VALUE && TestMutex())
    {
        TCHAR achBuffer[1025];
        CHAR achAnsiBuf[500];
        DWORD dwcBytesWr, dwcBytes;
        va_list args;
        va_start(args, lpOutputString);
        wvsprintf(achBuffer, lpOutputString, args);
        dwcBytes = WideCharToMultiByte(CP_ACP, 0, achBuffer, -1, achAnsiBuf, sizeof(achAnsiBuf)*sizeof(CHAR), NULL, NULL);
        if (!WriteFile(g_hSpewFile, achAnsiBuf, dwcBytes-1, &dwcBytesWr, NULL))
        {
//            MessageBox(NULL, TEXT("SpewToFile:  Unable to write to spew file"), TEXT("Error"), MB_OK);
        }
        va_end(args);
    }
#endif
}
void SpewCloseFile()
{
#ifdef UNICODE // only works for unicode
    if (g_hSpewFile != INVALID_HANDLE_VALUE && TestMutex())
        CloseHandle(g_hSpewFile);
#endif
}
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\inc\deskswitch.c ===
/*************************************************************************
    Module:     DeskSwitch.c

    Copyright (C) 1997-2000 by Microsoft Corporation.  All rights reserved.
*************************************************************************/
#ifdef _WIN32_IE
#undef _WIN32_IE
#endif
#define _WIN32_IE 0x0600
#include <shlwapi.h>    // for IsOS
#include <shlwapip.h>    // for IsOS

////////////////////////////////////////////////////////////////////////////
// Helper functions and globals for detecting desktop switch
//
// Usage:  Call InitWatchDeskSwitch() with an hWnd and message during
//         initialization.  The message will be posted to hWnd whenever
//         a desktop switch has occurred.  When the message is received
//         the desktop switch has taken place already.
//
//         Call TermWatchDeskSwitch() to stop watching for desktop
//         switches.
////////////////////////////////////////////////////////////////////////////

HANDLE g_hDesktopSwitchThread = 0;
HANDLE g_hDesktopSwitchEvent = 0;
HANDLE g_hTerminateEvent = 0;

typedef struct MsgInfo {
    HWND    hWnd;
    DWORD   dwMsg;
    DWORD   dwTIDMain;
    DWORD   fPostMultiple;
} MSG_INFO;
MSG_INFO g_MsgInfo;

void Cleanup()
{
	if (g_hDesktopSwitchEvent)
	{
		CloseHandle(g_hDesktopSwitchEvent);
		g_hDesktopSwitchEvent = 0;
	}
	if (g_hTerminateEvent)
	{
		CloseHandle(g_hTerminateEvent);
		g_hTerminateEvent = 0;
	}
}

#ifndef DESKTOP_ACCESSDENIED
#define DESKTOP_ACCESSDENIED 0
#define DESKTOP_DEFAULT      1
#define DESKTOP_SCREENSAVER  2
#define DESKTOP_WINLOGON     3
#define DESKTOP_TESTDISPLAY  4
#define DESKTOP_OTHER        5
#endif

int GetDesktopType()
{
    HDESK hdesk;
    TCHAR szName[100];
    DWORD nl;
    int iCurrentDesktop = DESKTOP_OTHER;

    hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (!hdesk)
    {
         hdesk = OpenDesktop(TEXT("Winlogon"), 0, FALSE, MAXIMUM_ALLOWED);
         if (!hdesk)
         {
            // fails when ap has insufficient permission on secure desktop
            return DESKTOP_ACCESSDENIED;
         }
    }
    GetUserObjectInformation(hdesk, UOI_NAME, szName, 100, &nl);
    CloseDesktop(hdesk);

    if (!lstrcmpi(szName, TEXT("Default"))) 
    {
        iCurrentDesktop = DESKTOP_DEFAULT;
    } else if (!lstrcmpi(szName, TEXT("Winlogon")))
    {
        iCurrentDesktop = DESKTOP_WINLOGON;
    }
    return iCurrentDesktop;
}

// WatchDesktopProc - waits indefinitely for a desktop switch.  When
//                    it gets one, it posts a message to the window
//                    specified in InitWatchDeskSwitch.  It also waits
//                    on an event that signals the procedure to exit.
//
DWORD WatchDesktopProc(LPVOID pvData)
{
    BOOL fCont = TRUE;
    DWORD dwEventIndex;
	HANDLE ahEvents[2];
    int iDesktopT, iCurrentDesktop = GetDesktopType();

    SetThreadDesktop(GetThreadDesktop(g_MsgInfo.dwTIDMain));

	ahEvents[0] = g_hDesktopSwitchEvent;
	ahEvents[1] = g_hTerminateEvent;
    
    while (fCont)
    {
        iDesktopT = GetDesktopType();
        if (iDesktopT == iCurrentDesktop)
        {
            DBPRINTF(TEXT("Wait for desktop switch or exit on desktop = %d\r\n"), iCurrentDesktop);
            dwEventIndex = WaitForMultipleObjects(2, ahEvents, FALSE, INFINITE);
		    dwEventIndex -= WAIT_OBJECT_0;
        } else
        {
            // missed a desktop switch so handle it
            dwEventIndex = 0;
        }

        switch (dwEventIndex) 
        {
			case 0:
            // With a FUS there is a spurious switch to Winlogon
            iDesktopT = GetDesktopType();
            DBPRINTF(TEXT("desktop switch from %d to %d\r\n"), iCurrentDesktop, iDesktopT);
            if (iDesktopT != iCurrentDesktop)
            {
                iCurrentDesktop = iDesktopT;

			    // Handle desk switch event
			    DBPRINTF(TEXT("WatchDesktopProc:  PostMessage(0x%x, %d...) desktop %d\r\n"), g_MsgInfo.hWnd, g_MsgInfo.dwMsg, iCurrentDesktop);
			    PostMessage(g_MsgInfo.hWnd, g_MsgInfo.dwMsg, iCurrentDesktop, 0);
            } else DBPRINTF(TEXT("WatchDesktopProc:  Ignore switch to %d\r\n"), iDesktopT);
			break;

			case 1:
			// Handle terminate thread event
			fCont = FALSE;
			DBPRINTF(TEXT("WatchDesktopProc:  got terminate event\r\n"));
			break;

            default:
			// Unexpected event
            fCont = FALSE;
			DBPRINTF(TEXT("WatchDesktopProc unexpected event %d\r\n"), dwEventIndex + WAIT_OBJECT_0);
			break;
        }
    }

	Cleanup();

    DBPRINTF(TEXT("WatchDesktopProc returning...\r\n"));
    return 0;
}

// InitWatchDeskSwitch - starts a thread to watch for desktop switches
//
// hWnd  [in]   - window handle to post message to
// dwMsg [in]   - message to post on desktop switch
//
// Call this function after the window has been created whenever it
// is to wait for a desktop switch.
// 
void InitWatchDeskSwitch(HWND hWnd, DWORD dwMsg)
{
    DWORD dwTID;

    if (g_hDesktopSwitchThread || g_hDesktopSwitchEvent)
        return; // don't do this again if it's already running

	// Create an unnamed event used to signal the thread to terminate
	g_hTerminateEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	// and open the desktop switch event.  If utility manager is
    // running then we will wait on it's desktop switch event otherwise
    // wait on the system desktop switch event.  If waiting on utilman
    // then only post one switch message.
	g_hDesktopSwitchEvent = OpenEvent(SYNCHRONIZE
                                    , FALSE
                                    , TEXT("UtilMan_DesktopSwitch"));
    g_MsgInfo.fPostMultiple = FALSE;

    if (!g_hDesktopSwitchEvent)
    {
	    g_hDesktopSwitchEvent = OpenEvent(SYNCHRONIZE
                                        , FALSE
                                        , TEXT("WinSta0_DesktopSwitch"));
        g_MsgInfo.fPostMultiple = TRUE;
    }

    if (g_hDesktopSwitchEvent && g_hTerminateEvent)
    {
		g_MsgInfo.hWnd = hWnd;
		g_MsgInfo.dwMsg = dwMsg;
		g_MsgInfo.dwTIDMain = GetCurrentThreadId();

		DBPRINTF(TEXT("InitWatchDeskSwitch(0x%x, %d, %d)\r\n"), g_MsgInfo.hWnd, g_MsgInfo.dwMsg, g_MsgInfo.dwTIDMain);
		g_hDesktopSwitchThread = CreateThread(
					  NULL, 0
					, WatchDesktopProc
					, &g_MsgInfo, 0
					, &dwTID);
    }

	// cleanup if failed to create thread

    if (!g_hDesktopSwitchThread)
    {
        DBPRINTF(TEXT("InitWatchDeskSwitch failed!\r\n"));
		Cleanup();
    }
}

// TermWatchDeskSwitch - cleans up after a desktop switch
//
// Call this function to terminate the thread that is watching
// for desktop switches (if it is running) and to clean up the
// event handle.
// 
void TermWatchDeskSwitch()
{
    DBPRINTF(TEXT("TermWatchDeskSwitch...\r\n"));
    if (g_hDesktopSwitchThread)
    {
		SetEvent(g_hTerminateEvent);
        DBPRINTF(TEXT("TermWatchDeskSwitch: SetEvent(0x%x)\r\n"), g_hDesktopSwitchThread);
        g_hDesktopSwitchThread = 0;
    } else DBPRINTF(TEXT("TermWatchDeskSwitch: g_hDesktopSwitchThread = 0\r\n"));
}

////////////////////////////////////////////////////////////////////////////
// helper functions for detecting if UtilMan is running (in
// which case this applets is being managed by it)
////////////////////////////////////////////////////////////////////////////

__inline BOOL IsUtilManRunning()
{
    HANDLE hEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT("UtilityManagerIsActiveEvent"));
    if (hEvent != NULL)
    {
        CloseHandle(hEvent);
        return TRUE;
    }
    return FALSE;
}

__inline BOOL CanLockDesktopWithoutDisconnect()
{
    // This function may have to change if UI is added to Whistler that
    // allows switching users for computers that are part of a domain.
    // For now, domain users may have FUS enabled because TS allows remote
    // logon which can result in multiple sessions on a machine (a form
    // of FUS) even though Start/Logoff doesn't allow the "Switch User" 
    // option.  In this case, the user can lock their desktop without
    // causing their session to disconnect.  If FUS is explicitly off
    // in the registry then "Switch User" is not a Logoff option nor can
    // a remote logon happen and the user can lock their desktop without
    // causing their session to disconnect.
    return (IsOS(OS_DOMAINMEMBER) || !IsOS(OS_FASTUSERSWITCHING));
}

////////////////////////////////////////////////////////////////////////////
// RunSecure - helper function to tell accessibility UI when to run secure
//             (no help, no active URL links, etc...).  Accessibility UI
//             should run in secure mode if it is running on the winlogon
//             desktop or as SYSTEM.
////////////////////////////////////////////////////////////////////////////
BOOL RunSecure(DWORD dwDesktop)
{
    BOOL fOK = FALSE;
	BOOL fIsLocalSystem = FALSE;
    SID_IDENTIFIER_AUTHORITY siaLocalSystem = SECURITY_NT_AUTHORITY;
    PSID psidSystem = 0;

	if (dwDesktop == DESKTOP_WINLOGON)
		return TRUE;

	if (AllocateAndInitializeSid(&siaLocalSystem, 
								1,
								SECURITY_LOCAL_SYSTEM_RID,
								0, 0, 0, 0, 0, 0, 0,
								&psidSystem) && psidSystem)
	{			
		fOK = CheckTokenMembership(NULL, psidSystem, &fIsLocalSystem);
		FreeSid(psidSystem);
	}

    return (fOK && fIsLocalSystem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\inc\mappedfile.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation

// Memory mapped file routines

#include <windows.h>
#include "w95trace.h"
#include "mappedfile.h"

BOOL CMemMappedFile::Open(
    LPCTSTR szName,         // name of the mapped file
    unsigned long ulMemSize // size of the mapped file
    )
{
    // assumption: the code isn't going to call Open twice w/different szName
    if (!m_hMappedFile)
    {
        // Create the mapped file from system page file.  If it has been created
        // previously, then CreateFileMapping acts like OpenFileMapping.

        m_hMappedFile = CreateFileMapping(
            INVALID_HANDLE_VALUE,    // Current file handle. 
            NULL,                    // Default security. 
            PAGE_READWRITE,          // Read/write permission. 
            0,                       // Hi-order DWORD of file size
            ulMemSize,               // Lo-order DWORD of file size
            szName);                 // Name of mapping object. 

        if (!m_hMappedFile) 
        {
            DBPRINTF(TEXT("CMemMappedFile::Open:  CreateFileMapping %s failed 0x%x\r\n"), szName, GetLastError());
            return FALSE;
        }

        // Note if this is the first open for the file?
        m_fFirstOpen = (GetLastError() == ERROR_SUCCESS)?TRUE:FALSE;
    }

    return TRUE;
}

BOOL CMemMappedFile::AccessMem(
    void **ppvMappedAddr    // returned pointer into memory
    )
{
    if (IsBadWritePtr(ppvMappedAddr, sizeof(void *)))
        return FALSE;

    if (!m_hMappedFile)
        return FALSE;

    // Get a pointer to the mapped memory if we don't already have it

    if (!m_pvMappedAddr)
    {
	    DBPRINTF(TEXT("MapViewOfFile\r\n"));
        m_pvMappedAddr = MapViewOfFile(
            m_hMappedFile,           // Handle to mapping object. 
            FILE_MAP_ALL_ACCESS,     // Read/write permission 
            0,                       // Max. object size. 
            0,                       // Size of hFile. 
            0);                      // Map entire file. 

        *ppvMappedAddr = m_pvMappedAddr;
    }

    if (NULL == m_pvMappedAddr) 
    {
        DBPRINTF(TEXT("CMemMappedFile::AccessMem:  MapViewOfFile failed 0x%x\r\n"), GetLastError());
        return FALSE;
    }

    return TRUE;
}

void CMemMappedFile::Close()
{
    if (m_pvMappedAddr)
    {
        UnmapViewOfFile(m_pvMappedAddr);
	    m_pvMappedAddr = 0;
    }

    if (m_hMappedFile)
    {
        CloseHandle(m_hMappedFile);
        m_hMappedFile = 0;
    }

    m_fFirstOpen = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\inc\w95trace.h ===
/*
    declarations for Win95 tracing facility
*/

#ifndef __TRACEW95__
#define __TRACEW95__



#if defined( _DEBUG ) ||defined( DEBUG ) || defined( DBG )

#define DBPRINTF OutputDebugStringW95




// redefine all the MFC macros to point to us

#undef  TRACE
#define TRACE   OutputDebugStringW95

#undef  TRACE0
#define TRACE0   OutputDebugStringW95

#undef  TRACE1
#define TRACE1   OutputDebugStringW95

#undef  TRACE2
#define TRACE2   OutputDebugStringW95

#undef  TRACE3
#define TRACE3   OutputDebugStringW95

// redefine OutputDebugString so that it works with 
// API calls
#undef OutputDebugString
#define OutputDebugString   OutputDebugStringW95


// function declarations
#ifdef __cplusplus
extern "C" {
#endif
void OutputDebugStringW95( LPCTSTR lpOutputString, ... );
void SpewOpenFile(LPCTSTR pszSpewFile);
void SpewToFile( LPCTSTR lpOutputString, ...);
void SpewCloseFile();
#ifdef __cplusplus
}
#endif



#else
// avoid warning:
// error C4353: nonstandard extension used: constant 0 as function expression.
// Use '__noop' function intrinsic instead
  #define DBPRINTF        __noop
  #define SpewOpenFile    __noop
  #define SpewToFile      __noop
  #define SpewCloseFile   __noop
#endif  // _DEBUG || DEBUG || DBG


#endif  //__TRACEW95__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\inc\wineventrefilter.h ===
//
// wineventrefilter - utility class to filter out reentrant WinEvent events
//
// Copyright (C) 1998 by Microsoft Corporation.  All rights reserved.
//



typedef 
void CALLBACK FN_WinEventProc( HWINEVENTHOOK hEvent,
                               DWORD         event,
                               HWND          hwnd,
                               LONG          idObject,
                               LONG          idChild,
                               DWORD         idThread,
                               DWORD         dwmsEventTime );


class WinEventReentrancyFilter
{
public:

    virtual ~WinEventReentrancyFilter() { }
    virtual void SetCallback( FN_WinEventProc *  pWinEventProc ) = 0;
    virtual void HandleWinEvent( HWINEVENTHOOK hEvent,
                                 DWORD         event,
                                 HWND          hwnd,
                                 LONG          idObject,
                                 LONG          idChild,
                                 DWORD         idThread,
                                 DWORD         dwmsEventTime ) = 0;
};


WinEventReentrancyFilter * CreateWinEventReentrancyFilter();




// Template class that makes this easier to use.
//
// If your existing code looks like...
//
//     void CALLBACK MyWinEventProc( ... );
//
//     ...
//
//     HWINEVENTHOOK hHook = SetWinEventHook(
//                                    ...
//                                    MyWinEventProc
//                                    ... );
//
//
// Change it to...
//
//     // No changes to WinEventProc
//     void CALLBACK WinEventProc( ... );
//
//     // * Add a new global - the template parameter is the name of your
//     //   existing callback...
//     CWinEventReentrancyFilter< MyWinEventProc > g_WinEventReFilter;
//
//     ...
//
//
//     // * Call SetWinEventHook using g_WinEventReFilter.WinEventProc
//     //   instead of your callback. This will filter reentrant events,
//     //   and pass them to your callback in the correct order.
//     HWINEVENTHOOK hHook = SetWinEventHook(
//                                    ...
//                                    g_WinEventReFilter.WinEventProc
//                                    ... );
//
//
// It is acceptable to use multiple filters, provided that they all
// use different callbacks. For example, this is allowed:
//
//     void CALLBACK MyWinEventProc1( ... );
//     void CALLBACK MyWinEventProc2( ... );
//
//     CWinEventReentrancyFilter< MyWinEventProc1 > g_WinEventReFilter1;
//     CWinEventReentrancyFilter< MyWinEventProc2 > g_WinEventReFilter2;
//
// ... but this is NOT allowed ...
//
//     void CALLBACK MyWinEventProc( ... );
//
//     CWinEventReentrancyFilter< MyWinEventProc > g_WinEventReFilter1;
//     CWinEventReentrancyFilter< MyWinEventProc > g_WinEventReFilter2;
//

template < FN_WinEventProc pCallback >
class CWinEventReentrancyFilter
{
    static
    WinEventReentrancyFilter * m_pFilter;

public:

    CWinEventReentrancyFilter()
    {
        m_pFilter = CreateWinEventReentrancyFilter();
        if( m_pFilter )
        {
            m_pFilter->SetCallback( pCallback );
        }
    }

    BOOL Check()
    {
        return m_pFilter;
    }

    ~CWinEventReentrancyFilter()
    {
        if( m_pFilter )
        {
            delete m_pFilter;
        }
    }

    static
    void CALLBACK WinEventProc( HWINEVENTHOOK hEvent,
                                DWORD         event,
                                HWND          hwnd,
                                LONG          idObject,
                                LONG          idChild,
                                DWORD         idThread,
                                DWORD         dwmsEventTime )
    {
        if( ! m_pFilter )
            return;
        m_pFilter->HandleWinEvent( hEvent, event, hwnd, idObject, idChild,
                                   idThread, dwmsEventTime );
    }
};

template < FN_WinEventProc pCallback >
WinEventReentrancyFilter * CWinEventReentrancyFilter< pCallback >::m_pFilter = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\appbar.cpp ===
/******************************************************************************
Module name: AppBar.cpp
Written by:  Jeffrey Richter
Purpose: 	 AppBar base class implementation file.
******************************************************************************/


#include "stdafx.h"
#include <WinReg.h>
#include "AppBar.h"
#include "Desktop.h"
#include "w95trace.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

int MAX_MAGNIFY_SIZE_PCT  = 65;
// max size of magnifier window, as a percent of screen (or primary monitor)
// width/height

/////////////////////////////////////////////////////////////////////////////
// Static, AppBar-specific helper functions


void CAppBar::ResetSystemKnowledge (void) {

#ifdef _DEBUG
	// Only do this for debug builds.
	APPBARDATA abd;
	abd.cbSize = sizeof(abd);
	abd.hWnd = NULL;
	::SHAppBarMessage(ABM_REMOVE, &abd);
#endif
}


/////////////////////////////////////////////////////////////////////////////


UINT CAppBar::GetEdgeFromPoint (DWORD fdwFlags, CPoint pt) {

	// At least one edge or floating must be allowed.
	ASSERT((fdwFlags & ABF_ALLOWANYWHERE) != 0);

	UINT uState = ABE_FLOAT;	// Assume that the AppBar is floating

	// Let's get floating out of the way first
	if ((fdwFlags & ABF_ALLOWFLOAT) != 0) {

		// If point outside main screen (eg. on multi-monitor system), allow float...
		CRect rc( 0, 0, GetSystemMetrics( SM_CXSCREEN ), GetSystemMetrics( SM_CYSCREEN ) );
		if( ! rc.PtInRect(pt) )
			return(uState);		// The AppBar should float

		// Get the rectangle that bounds the size of the screen
		// minus any docked (but not-autohidden) AppBars.
		::SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, 0);

		// Leave a 1/2 width/height-of-a-scrollbar gutter around the workarea
		rc.InflateRect(-GetSystemMetrics(SM_CXVSCROLL), -GetSystemMetrics(SM_CYHSCROLL));

		if (rc.PtInRect(pt) || ((fdwFlags & ABF_ALLOWANYEDGE) == 0)) {
			// If the point is in the adjusted workarea
			// OR no edges are allowed.
			return(uState);		// The AppBar should float
		}
	}

	// If we get here, the AppBar should be docked; determine the proper edge

	// Get the dimensions of the screen
	int cxScreen = GetSystemMetrics(SM_CXSCREEN);
	int cyScreen = GetSystemMetrics(SM_CYSCREEN);

	// Find the center of the screen
	CPoint ptCenter(cxScreen / 2, cyScreen / 2);

	// Find the distance from the point to the center
	CPoint ptOffset = pt - ptCenter;

	// Determine if the point is farther from the left/right or top/bottom
	BOOL fIsLeftOrRight = (AbsoluteValue(ptOffset.y) * cxScreen) <=
		(AbsoluteValue(ptOffset.x) * cyScreen);

	// If (it should be left/right, AND we allow left/right) 
	// OR we don't allow top/bottom
	if ((fIsLeftOrRight && ((fdwFlags & ABF_ALLOWLEFTRIGHT) != 0)) ||
		 ((fdwFlags & ABF_ALLOWTOPBOTTOM) == 0)) {

		uState = (0 <= ptOffset.x) ? ABE_RIGHT : ABE_LEFT;
	} else {

		uState = (0 <= ptOffset.y) ? ABE_BOTTOM : ABE_TOP;
	}
	
	return(uState);	// Return calculated edge
}


/////////////////////////////////////////////////////////////////////////////
// Public member functions


CAppBar::CAppBar (UINT nIDTemplate, CWnd* pParent /*=NULL*/)
	: CDialog(nIDTemplate, pParent) {
	//{{AFX_DATA_INIT(CAppBar)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
		// Setup the default width/height for the AppBar

	// Force the shell to update its list of AppBars and the workarea.
	// This is a precaution and is very useful when debugging.	If you create
	// an AppBar and then just terminate the application, the shell still 
	// thinks that the AppBar exists and the user's workarea is smaller than
	// it should be.	When a new AppBar is created, calling this function 
	// fixes the user's workarea.
	ResetSystemKnowledge();

	// For Multimon, Increase the size available. 
	if ( GetSystemMetrics(SM_CMONITORS) > 1)
		MAX_MAGNIFY_SIZE_PCT  = 90;

	// Set default state of AppBar to docked on bottom with no width & height
	ZeroMemory(&m_abs, sizeof(m_abs));
	m_abs.m_cbSize 					 = sizeof(m_abs);
	m_abs.m_uState 					 = ABE_BOTTOM;
	m_abs.m_fAutohide 				 = FALSE;
	m_abs.m_fAlwaysOnTop 			 = FALSE;
	m_abs.m_auDimsDock[ABE_LEFT]	 = 0;
	m_abs.m_auDimsDock[ABE_TOP]	 = 0;
	m_abs.m_auDimsDock[ABE_RIGHT]  = 0;
	m_abs.m_auDimsDock[ABE_BOTTOM] = 0;
	m_abs.m_rcFloat.SetRectEmpty();

	m_fdwTaskBarState 				= (DWORD)SHAppBarMessage(ABM_GETSTATE);
	m_fdwFlags							= 0;
	m_szSizeInc 						= CSize(0, 0); // Don't allow re-sizing
	m_uStateProposedPrev 			= ABE_UNKNOWN;
	m_fFullScreenAppOpen 			= FALSE;
	m_fAutoHideIsVisible 			= FALSE;
	m_fHidden						= FALSE;
    m_rcOldWorkArea                 = CRect(0, 0, 0, 0);
}


/////////////////////////////////////////////////////////////////////////////


UINT CAppBar::GetAutohideEdge (void) {

	for (UINT uEdge = ABE_LEFT; uEdge <= ABE_BOTTOM; uEdge++) {
		if (m_hWnd == (HWND) SHAppBarMessage(ABM_GETAUTOHIDEBAR, uEdge)) {
			// We are an auto-hide AppBar and we found our edge.
			return(uEdge);
		}
	}

	// NOTE: If AppBar is docked but not auto-hidden, we return ABE_UNKNOWN
	return(ABE_UNKNOWN);   
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::MimicState (DWORD fdwStateChangedMask, DWORD fdwState) {

	BOOL fAnyChange = FALSE;	// Assume that nothing changes

	// If the autohide state changed AND our style allows 
	// us to mimic the Autohide state
	if (((fdwStateChangedMask & ABS_AUTOHIDE) != 0) && 
		 ((m_fdwFlags & ABF_MIMICTASKBARAUTOHIDE) != 0)) {

		BOOL fIsAutohide = (ABS_AUTOHIDE & fdwState) != 0;

		// If our state doesn't match, change our state
		if (IsBarAutohide() != fIsAutohide) {
			m_abs.m_fAutohide = fIsAutohide;
			fAnyChange = TRUE;
		}
	}

	// If the AlwaysOnTop state changed AND our style allows 
	// us to mimic the AlwaysOnTop state/
	if (((fdwStateChangedMask & ABS_ALWAYSONTOP) != 0) && 
		 ((m_fdwFlags & ABF_MIMICTASKBARALWAYSONTOP) != 0)) {

		// If our state doesn't match, change our state
		m_abs.m_fAlwaysOnTop = (ABS_ALWAYSONTOP & fdwState) != 0;
		fAnyChange = TRUE;
	}
	if (fAnyChange) {
		SetState();
		ShowHiddenAppBar(FALSE);
	}
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::SetState (UINT uState) {

	// If the AppBar is registered as auto-hide, unregister it.
	UINT uEdge = GetAutohideEdge();
	if (uEdge != ABE_UNKNOWN) {
		// Our AppBar is auto-hidden, unregister it.
		SHAppBarMessage(ABM_SETAUTOHIDEBAR, uEdge, FALSE);
	}

	// Save the new requested state
	m_abs.m_uState = uState;

	switch (uState) {
		case ABE_UNKNOWN:
			// We are being completely unregisterred.
			// Probably, the AppBar window is being destroyed.
			// If the AppBar is registered as NOT auto-hide, unregister it.
			SHAppBarMessage(ABM_REMOVE);
			break;

		case ABE_FLOAT:
			// We are floating and therefore are just a regular window.
			// Tell the shell that the docked AppBar should be of 0x0 dimensions
			// so that the workspace is not affected by the AppBar.
			SHAppBarMessage(ABM_SETPOS, uState, FALSE, &CRect(0, 0, 0, 0));
			SetWindowPos(NULL, m_abs.m_rcFloat.left, m_abs.m_rcFloat.top, 
				m_abs.m_rcFloat.Width(), m_abs.m_rcFloat.Height(), 
				SWP_NOZORDER | SWP_NOACTIVATE);
			break;

		default:
			if (IsBarAutohide() && !SHAppBarMessage(ABM_SETAUTOHIDEBAR, GetState(), TRUE)) {
				// We couldn't set the AppBar on a new edge, let's dock it instead.
				m_abs.m_fAutohide = FALSE;
				// Call a virtual function to let derived classes know that the AppBar
				// changed from auto-hide to docked.
				OnAppBarForcedToDocked();
			}
			CRect rc;
			GetRect(GetState(), &rc);
			if (IsBarAutohide()) {
				SHAppBarMessage(ABM_SETPOS, ABE_LEFT, FALSE, &CRect(0, 0, 0, 0));
			} else {
				// Tell the shell where the AppBar is.
				if ( m_fHidden )
    				SHAppBarMessage(ABM_SETPOS, uState, FALSE, &CRect(0, 0, 0, 0));
                else
    				SHAppBarMessage(ABM_SETPOS, uState, FALSE, &rc);
			}
			AdjustLocationForAutohide(m_fAutoHideIsVisible, &rc);
			// Slide window in from or out to the edge
			SlideWindow(rc);
			break;
	}

	// Set the AppBar's z-order appropriately
	const CWnd* pwnd = &wndNoTopMost;		// Assume normal Z-Order
	if (m_abs.m_fAlwaysOnTop) {	
		// If we are supposed to be always-on-top, put us there.
		pwnd = &wndTopMost;

		if (m_fFullScreenAppOpen) {
			// But, if a full-screen window is opened, put ourself at the bottom
			// of the z-order so that we don't cover the full-screen window
			pwnd = &wndBottom;
		}
	}
	SetWindowPos(pwnd, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

	// Make sure that any auto-hide appbars stay on top of us after we move
	// even though our activation state has not changed.
	SHAppBarMessage(ABM_ACTIVATE);

	// Tell our derived class that there is a state change
	OnAppBarStateChange(FALSE, uState);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::SetState (APPBARSTATE& abs) {

	// The AppBar window doesn't exist, just update the state variables
	CopyMemory(&m_abs, &abs, min(abs.m_cbSize, sizeof(m_abs)));
	m_abs.m_cbSize = sizeof(m_abs);		// In case caller used an old version
	if (IsWindow(m_hWnd)) SetState();
}


/////////////////////////////////////////////////////////////////////////////
// Internal implementation functions


UINT_PTR CAppBar::SHAppBarMessage (DWORD dwMessage, UINT uEdge /*= ABE_FLOAT*/, 
	LPARAM lParam /*= 0*/, CRect *rc /*= NULL*/) {

    UINT_PTR uRetVal;
	// Initialize an APPBARDATA structure.
	APPBARDATA abd;
	abd.cbSize				= sizeof(abd);
	abd.hWnd 				= m_hWnd;
	abd.uCallbackMessage    = s_uAppBarNotifyMsg;
	abd.uEdge				= uEdge;
	abd.rc					= (rc == NULL) ? CRect(0, 0, 0, 0) : *rc;
	abd.lParam				= lParam;

    // SHAppBarMessage depends on the system tray to handle its messages.  When
    // on the secure desktop these calls are failing.  The one that we need to 
    // handle ourselves is when the app bar window is sized or positioned such
    // that the desktop work area needs to be resized.  In this case we need to
    // call SystemParametersInfo to set a new work area.  Only do this for setting
    // the position and if we're not hidden and we're on the secure desktop. 
    // Otherwise we call the Shell SHAppBarMessage.  We rely on SHAppBarMessage
    // to fail gracefully if we call it when the system tray isn't present.
    // We don't try to handle OOBE here because it doesn't do the right thing when
    // the WM_SETTINGCHANGE message is sent.  Otherwise we should use ShellRunning().

    if (ABM_SETPOS == dwMessage && !IsBarAutohide() && IsWindowVisible() && GetDesktop() == DESKTOP_WINLOGON)
    {
        // Are we on the primary monitor?

		CRect rcWorkArea( 0, 0, GetSystemMetrics( SM_CXSCREEN ), GetSystemMetrics( SM_CYSCREEN ) );

		if( rcWorkArea.PtInRect(rc->CenterPoint()) )
        {
            BOOL fChangeIt = FALSE;

		    // We are on the primary monitor so get the desktop work area, reduce
            // it by our window area and let the system know the new work area.

            // ASSUMPTION:  Magnifier is the only app bar on the secure desktop

            switch (uEdge)
            {
                case ABE_LEFT:   rcWorkArea.left   = abd.rc.right;  fChangeIt = TRUE; break;
                case ABE_TOP:    rcWorkArea.top    = abd.rc.bottom; fChangeIt = TRUE; break;
                case ABE_RIGHT:  rcWorkArea.right  = abd.rc.left;   fChangeIt = TRUE; break;
                case ABE_BOTTOM: rcWorkArea.bottom = abd.rc.top;    fChangeIt = TRUE; break;
                case ABE_FLOAT:  /* use entire work area */         fChangeIt = TRUE; break;
                default: DBPRINTF(TEXT("CAppBar::SHAppBarMessage uEdge is unknown!\r\n")); break;
            }

            // Don't do this if the work area size hasn't really changed
            if (rcWorkArea == m_rcOldWorkArea)
            {
                fChangeIt = FALSE;
            }

            m_rcOldWorkArea = rcWorkArea;

            if (fChangeIt)
            {
                ::SystemParametersInfo(SPI_SETWORKAREA, TRUE, &rcWorkArea, SPIF_SENDWININICHANGE);
            }
        }

        // This return is consistent with SHAppBarMessage(ABM_SETPOS...)
        uRetVal = TRUE;
    }
    else
    {
	    uRetVal = ::SHAppBarMessage(dwMessage, &abd);
    }

	// If the caller passed a rectangle, return the updated rectangle.
	if (rc != NULL) *rc = abd.rc;
	return uRetVal;
}


/////////////////////////////////////////////////////////////////////////////


UINT CAppBar::CalcProposedState (const CPoint& pt) {

	// Force the AppBar to float if the user is holding down the Ctrl key
	// and the AppBar's style allows floating.
	BOOL fForceFloat = ((GetKeyState(VK_CONTROL) & 0x8000) != 0) 
		&& ((m_fdwFlags & ABF_ALLOWFLOAT) != 0);
	return(fForceFloat ? ABE_FLOAT : GetEdgeFromPoint(m_fdwFlags, pt));
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::GetRect (UINT uStateProposed, CRect* prcProposed) {

	// This function finds the x, y, cx, cy of the AppBar window
	if (ABE_FLOAT == uStateProposed) {

		// The AppBar is floating, the proposed rectangle is correct
	} else {

		// The AppBar is docked or auto-hide

		// Set dimensions to full screen.
		*prcProposed = CRect(0, 0, 
			GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));

		// Subtract off what we want from the full screen dimensions
		if (!IsBarAutohide()) {
			// Ask the shell where we can dock.
			SHAppBarMessage(ABM_QUERYPOS, uStateProposed, FALSE, prcProposed);
		}

		switch (uStateProposed) {
			case ABE_LEFT: 	
				prcProposed->right = 
					prcProposed->left + m_abs.m_auDimsDock[uStateProposed];
				break;

			case ABE_TOP:
				prcProposed->bottom = 
					prcProposed->top + m_abs.m_auDimsDock[uStateProposed]; 
				break;

			case ABE_RIGHT:	
				prcProposed->left = 
					prcProposed->right - m_abs.m_auDimsDock[uStateProposed]; 
				break;

			case ABE_BOTTOM:	
				prcProposed->top = 
					prcProposed->bottom - m_abs.m_auDimsDock[uStateProposed]; 
				break;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////


BOOL CAppBar::AdjustLocationForAutohide (BOOL fShow, CRect* prc) {

	if ((GetState() == ABE_UNKNOWN) || (GetState() == ABE_FLOAT) || 
		!IsBarAutohide()) {

		// If we are not docked on an edge OR we are not auto-hidden, there is
		// nothing for us to do; just return.
		return(FALSE);
	}

	// Showing/hiding doesn't change our size; only our position.
	int x = 0, y = 0; 	// Assume a position of (0, 0)

	if (fShow) {

		// If we are on the right or bottom, calculate our visible position
		switch (GetState()) {
			case ABE_RIGHT:
				x = GetSystemMetrics(SM_CXSCREEN) - prc->Width();
				break;

			case ABE_BOTTOM:
				y = GetSystemMetrics(SM_CYSCREEN) - prc->Height();
				break;
		}
	} else {

		// Keep a part of the AppBar visible at all times
		const int cxVisibleBorder = 2 * GetSystemMetrics(SM_CXBORDER);
		const int cyVisibleBorder = 2 * GetSystemMetrics(SM_CYBORDER);

		// Calculate our x or y coordinate so that only the border is visible
		switch (GetState()) {
			case ABE_LEFT:   
				x = -(prc->Width() - cxVisibleBorder); 
				break;

			case ABE_RIGHT:  
				x = GetSystemMetrics(SM_CXSCREEN) - cxVisibleBorder; 
				break;

			case ABE_TOP:
				y = -(prc->Height() - cyVisibleBorder); 
				break;

			case ABE_BOTTOM:
				y = GetSystemMetrics(SM_CYSCREEN) - cyVisibleBorder; 
				break;
		}
	}
	*prc = CRect(x, y, x + prc->Width(), y + prc->Height());
	return(TRUE);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::ShowHiddenAppBar (BOOL fShow /*= TRUE*/) {

	if (m_fAutoHideIsVisible != fShow) {
		// We are chaning our visibility
		// Get our window location in screen coordinates.
		CRect rc;
		GetWindowRect(&rc);

		if (AdjustLocationForAutohide(fShow, &rc)) {
			// the rectangle was adjusted, we are an autohide bar
			// Rememebr whether we are visible or not.
			m_fAutoHideIsVisible = fShow;

			// Slide window in from or out to the edge
			SlideWindow(rc);
		}
	}
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::SlideWindow (const CRect& rcEnd) {

	BOOL fFullDragOn;

	// Only slide the window if the user has FullDrag turned on
	::SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &fFullDragOn, 0);

	// Get the current window position
	CRect rcStart;
	GetWindowRect(&rcStart);	

	if (fFullDragOn && (rcStart != rcEnd)) {

		// Get our starting and ending time.
		DWORD dwTimeStart = GetTickCount();
		DWORD dwTimeEnd = dwTimeStart + AUTOHIDETIMERINTERVAL;
		DWORD dwTime;

		while ((dwTime = ::GetTickCount()) < dwTimeEnd) {

			// While we are still sliding, calculate our new position
			int x = rcStart.left - (rcStart.left - rcEnd.left) 
				* (int) (dwTime - dwTimeStart) / AUTOHIDETIMERINTERVAL;

			int y = rcStart.top	- (rcStart.top  - rcEnd.top)	
				* (int) (dwTime - dwTimeStart) / AUTOHIDETIMERINTERVAL;

			int nWidth	= rcStart.Width()  - (rcStart.Width()	- rcEnd.Width())	
				* (int) (dwTime - dwTimeStart) / AUTOHIDETIMERINTERVAL;

			int nHeight = rcStart.Height() - (rcStart.Height() - rcEnd.Height()) 
				* (int) (dwTime - dwTimeStart) / AUTOHIDETIMERINTERVAL;

			// Show the window at its changed position
			SetWindowPos(NULL, x, y, nWidth, nHeight, 
				SWP_NOZORDER | SWP_NOACTIVATE | SWP_DRAWFRAME);
			UpdateWindow();
		}
	}

	// Make sure that the window is at its final position
	SetWindowPos(NULL, rcEnd.left, rcEnd.top, rcEnd.Width(), rcEnd.Height(),
		SWP_NOZORDER | SWP_NOACTIVATE | SWP_DRAWFRAME);
	UpdateWindow();
}


/////////////////////////////////////////////////////////////////////////////
// Overridable functions


void CAppBar::OnAppBarStateChange (BOOL fProposed, UINT uStateProposed) {

	// This function intentionally left blank.
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnAppBarForcedToDocked (void) {

	// Display the ppBar's caption text as the message box caption text.
	CString sz;
	GetWindowText(sz);

	::MessageBox(NULL, 
		__TEXT("There is already an auto hidden window on this edge.\n")
		__TEXT("Only one auto hidden window is allowed on each edge."),
		sz, MB_OK | MB_ICONSTOP);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnABNFullScreenApp (BOOL fOpen) {

	// This function is called when a FullScreen window is openning or 
	// closing. A FullScreen window is a top-level window that has its caption 
	// above the top of the screen allowing the entire screen to be occupied 
	// by the window's client area.	
	
	// If the AppBar is a topmost window when a FullScreen windiw is activated, 
	// we need to change our window to a non-topmost window so that the AppBar 
	// doesn't cover the FullScreen window's client area.

	// If the FullScreen window is closing, we need to set the AppBar's 
	// Z-Order back to when the user wants it to be.
	// Do this if we are not floating...
	if (GetState() != ABE_FLOAT)
		m_fFullScreenAppOpen = fOpen;

	SetState();
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnABNPosChanged (void) {

	// The TaskBar or another AppBar has changed its size or position. 
	if ((GetState() != ABE_FLOAT) && !IsBarAutohide()) {

		// If we're not floating and we're not auto-hidden, we have to 
		// reposition our window.
		SetState();
	}
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnABNStateChange (DWORD fdwStateChangedMask, DWORD fdwState) {

	// Make our state mimic the taskbar's state.
	MimicState(fdwStateChangedMask, fdwState);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnABNWindowArrange (BOOL fBeginning) {

	// This function intentionally left blank.
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAppBar)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////


// Register a window message for the AppBar's callback notifications
UINT CAppBar::s_uAppBarNotifyMsg = 
	RegisterWindowMessage(__TEXT("AppBarNotify"));


/////////////////////////////////////////////////////////////////////////////


// Called when the AppBar recieves a g_uAppBarNotifyMsg window message
LRESULT CAppBar::OnAppBarCallbackMsg (WPARAM uNotifyMsg, LPARAM lParam) {

	switch (uNotifyMsg) {

		case ABN_FULLSCREENAPP: 
			OnABNFullScreenApp((BOOL) lParam); 
			break;

		case ABN_POSCHANGED:
			OnABNPosChanged(); 
			break;

		case ABN_WINDOWARRANGE:
			OnABNWindowArrange((BOOL) lParam); 
			break;

		case ABN_STATECHANGE:
			// The shell sends ABN_STATECHANGE notifications at inappropriate 
			// times.  So, we remember the TaskBar's current state and set
			// a mask indicating which states have actually changed. This mask
			// and the state information is passed to the derived class.

			// Get the state of the Taskbar
			DWORD fdwTaskBarState = (DWORD)SHAppBarMessage(ABM_GETSTATE);

			// Prepare a mask indicating which states have changed. The code in
			// the derived class should only act on the states that have changed.
			DWORD fdwStateChangedMask = 0;
			if ((fdwTaskBarState & ABS_ALWAYSONTOP) != 
				 (m_fdwTaskBarState & ABS_ALWAYSONTOP)) {
				fdwStateChangedMask |= ABS_ALWAYSONTOP;
			}
			if ((fdwTaskBarState & ABS_AUTOHIDE) != 
				 (m_fdwTaskBarState & ABS_AUTOHIDE)) {
				fdwStateChangedMask |= ABS_AUTOHIDE;
			}

			// Call the derived class
			OnABNStateChange(fdwStateChangedMask, fdwTaskBarState);

			// Save the TaskBar's state so that we can see exactly which states
			// change the next time be get an ABN_STATECHANGE notification.
			m_fdwTaskBarState = fdwTaskBarState;
			break;
	}

	return(0);
}


/////////////////////////////////////////////////////////////////////////////


BEGIN_MESSAGE_MAP(CAppBar, CDialog)
	ON_REGISTERED_MESSAGE(s_uAppBarNotifyMsg, OnAppBarCallbackMsg)
	ON_MESSAGE(WM_ENTERSIZEMOVE, OnEnterSizeMove)
	ON_MESSAGE(WM_SIZING, OnSizing)
	ON_MESSAGE(WM_MOVING, OnMoving)
	ON_MESSAGE(WM_EXITSIZEMOVE, OnExitSizeMove)
	//{{AFX_MSG_MAP(CAppBar)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_WINDOWPOSCHANGED()
	ON_WM_ACTIVATE()
	ON_WM_NCMOUSEMOVE()
	ON_WM_NCHITTEST()
	ON_WM_TIMER()
    ON_WM_GETMINMAXINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAppBar message handlers


int CAppBar::OnCreate(LPCREATESTRUCT lpCreateStruct) {

	if (CDialog::OnCreate(lpCreateStruct) == -1)
		return(-1);

	// Associate a timer with the AppBar.	The timer is used to determine
	// when a visible, inactive, auto-hide AppBar should be re-hidden.
	SetTimer(AUTOHIDETIMERID, AUTOHIDETIMERINTERVAL, NULL);

	// Register our AppBar window with the Shell
	SHAppBarMessage(ABM_NEW);

	// Force the AppBar to mimic the state of the TaskBar
	// Assume that all states have changed
	MimicState(ABS_ALWAYSONTOP | ABS_AUTOHIDE, m_fdwTaskBarState);

	return(0);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnDestroy() {

	// Kill the Autohide timer 
	KillTimer(AUTOHIDETIMERID);

	// Unregister our AppBar window with the Shell
	SetState(ABE_UNKNOWN);

	CDialog::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos) {

	CDialog::OnWindowPosChanged(lpwndpos);

	// When our window changes position, tell the Shell so that any 
	// auto-hidden AppBar on our edge stays on top of our window making it 
	// always accessible to the user.
	SHAppBarMessage(ABM_WINDOWPOSCHANGED);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) {

	CDialog::OnActivate(nState, pWndOther, bMinimized);

	if (nState == WA_INACTIVE) {
		// Hide the AppBar if we are docked and auto-hidden
		ShowHiddenAppBar(FALSE);
	}

	// When our window changes position, tell the Shell so that any 
	// auto-hidden AppBar on our edge stays on top of our window making it 
	// always accessible to the user.
	SHAppBarMessage(ABM_ACTIVATE);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnTimer(UINT nIDEvent) {

	if (GetActiveWindow() != this) {

		// Possibly hide the AppBar if we are not the active window 
		
		// Get the position of the mouse and the AppBar's position
		// Everything must be in screen coordinates.
		CPoint pt(::GetMessagePos());
		CRect rc;
		GetWindowRect(&rc);

		// Add a little margin around the AppBar
		rc.InflateRect(2 * GetSystemMetrics(SM_CXDOUBLECLK), 
			2 * GetSystemMetrics(SM_CYDOUBLECLK));

		if (!rc.PtInRect(pt)) {
			// If the mouse is NOT over the AppBar, hide the AppBar
			ShowHiddenAppBar(FALSE);
		}
	}

	CDialog::OnTimer(nIDEvent);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnNcMouseMove(UINT nHitTest, CPoint point) {

	// If we are a docked, auto-hidden AppBar, shown us
	// when the user moves over our non-client area
	ShowHiddenAppBar(TRUE);

	CDialog::OnNcMouseMove(nHitTest, point);
}


/////////////////////////////////////////////////////////////////////////////


UINT CAppBar::OnNcHitTest(CPoint point) {

	// Find out what the system thinks is the hit test code
	UINT u = CDialog::OnNcHitTest(point);

	// NOTE: If the user presses the secondary mouse button, pretend that the
	// user clicked on the client area so that we get WM_CONTEXTMENU messages
	BOOL fPrimaryMouseBtnDown = 
		(GetAsyncKeyState(GetSystemMetrics(SM_SWAPBUTTON) 
			? VK_RBUTTON : VK_LBUTTON) & 0x8000) != 0;

	if ((u == HTCLIENT) && fPrimaryMouseBtnDown) {

		// User clicked in client area, allow AppBar to move.  We get this 
		// behavior by pretending that the user clicked on the caption area.
		u = HTCAPTION;
	}

	// When the AppBar is docked, the user can resize only one edge.
	// This next section determines which edge the user can resize.
	// To allow resizing, the AppBar window must have the WS_THICKFRAME style.

	// If the AppBar is docked and the hittest code is a resize code...
	if ((GetState() != ABE_FLOAT) && (GetState() != ABE_UNKNOWN) && 
		 (HTSIZEFIRST <= u) && (u <= HTSIZELAST)) {

		if (0 == (IsEdgeLeftOrRight(GetState()) ? 
			m_szSizeInc.cx : m_szSizeInc.cy)) {

			// If the width/height size increment is zero, then resizing is NOT 
			// allowed for the edge that the AppBar is docked on.
			u = HTBORDER;	// Pretend that the mouse is not on a resize border
		} else {

			// Resizing IS allowed for the edge that the AppBar is docked on.
			// Get the location of the appbar's client area in screen coordinates.
			CRect rcClient;
			GetClientRect(&rcClient);
			ClientToScreen(rcClient);
			u = HTBORDER;	// Assume that we can't resize

			switch (GetState()) {
				case ABE_LEFT:
					if (point.x > rcClient.right) u = HTRIGHT;
					break;

				case ABE_TOP:
					if (point.y > rcClient.bottom) u = HTBOTTOM;
					break;

				case ABE_RIGHT:
					if (point.x < rcClient.left) u = HTLEFT;
					break;

				case ABE_BOTTOM:
					if (point.y < rcClient.top) u = HTTOP;
					break;
			}
		}
	}

	return(u);	// Return the hittest code
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI )
{
	if( GetState() == ABE_FLOAT )
    {
        lpMMI->ptMaxTrackSize.x = ( GetSystemMetrics( SM_CXSCREEN ) * MAX_MAGNIFY_SIZE_PCT ) / 100;
        lpMMI->ptMaxTrackSize.y = ( GetSystemMetrics( SM_CYSCREEN ) * MAX_MAGNIFY_SIZE_PCT ) / 100;
    }
}


/////////////////////////////////////////////////////////////////////////////


LRESULT CAppBar::OnEnterSizeMove(WPARAM wParam, LPARAM lParam) {

	// The user started moving/resizing the AppBar, save its current state.
	m_uStateProposedPrev = GetState();

    // If we are on the secure desktop and the user is dragging the window from
    // a docked position reset the work area to full screen.  
    // We don't try to handle OOBE here because it doesn't do the right thing when
    // the WM_SETTINGCHANGE message is sent.  Otherwise we should use ShellRunning().
    if ((m_uStateProposedPrev == ABE_LEFT ||  m_uStateProposedPrev == ABE_RIGHT   || 
         m_uStateProposedPrev == ABE_TOP  ||  m_uStateProposedPrev == ABE_BOTTOM) && 
         GetDesktop() == DESKTOP_WINLOGON )
    {
        ResetWorkarea();
    }

	return(0);
}


/////////////////////////////////////////////////////////////////////////////


LRESULT CAppBar::OnExitSizeMove(WPARAM wParam, LPARAM lParam) {

	// The user stopped moving/resizing the AppBar, set the new state.

	// Save the new proposed state of the AppBar.
	UINT uStateProposedPrev = m_uStateProposedPrev;

	// Set the proposed state back to unknown.  This causes GetState
	// to return the current state rather than the proposed state.
	m_uStateProposedPrev = ABE_UNKNOWN;

	// Get the location of the window in screen coordinates
	CRect rc;
	GetWindowRect(&rc);

	// If the AppBar's state has changed...
	if (GetState() == uStateProposedPrev) {

		switch (GetState()) {
			case ABE_UNKNOWN:
				break;

			case ABE_LEFT: 
			case ABE_RIGHT:
				// Save the new width of the docked AppBar
				m_abs.m_auDimsDock[m_abs.m_uState] = rc.Width(); 
				break;

			case ABE_TOP: 
			case ABE_BOTTOM:
				// Save the new height of the docked AppBar
				m_abs.m_auDimsDock[m_abs.m_uState] = rc.Height(); 
				break;
		}
	}

	// Always save the new position of the floating AppBar
	if (uStateProposedPrev == ABE_FLOAT)
		m_abs.m_rcFloat = rc; 

	// After setting the dimensions, set the AppBar to the proposed state
	SetState(uStateProposedPrev);
	return(0);
}


/////////////////////////////////////////////////////////////////////////////


LRESULT CAppBar::OnMoving(WPARAM wParam, LPARAM lParam) {

	// We control the moving of the AppBar.  For example, if the mouse moves 
	// close to an edge, we want to dock the AppBar.

	// The lParam contains the window's position proposed by the system
	CRect* prc = (CRect *) lParam;

	// Get the location of the mouse cursor
	CPoint pt(::GetMessagePos());

	// Where should the AppBar be based on the mouse position?
	UINT uStateProposed = CalcProposedState(pt);

	if ((m_uStateProposedPrev != ABE_FLOAT) && (uStateProposed == ABE_FLOAT)) {
		// While moving, the user took us from a docked/autohidden state to 
		// the float state.	We have to calculate a rectangle location so that
		// the mouse cursor stays inside the window.
		GetFloatRect(prc);
		*prc = CRect(pt.x - prc->Width() / 2, pt.y, 
			(pt.x - prc->Width() / 2) + prc->Width(), pt.y + prc->Height());
	}

	// Remember the most-recently proposed state
	m_uStateProposedPrev = uStateProposed;

	// Tell the system where to move the window based on the proposed state
	GetRect(uStateProposed, prc);

	// Tell our derived class that there is a proposed state change
	OnAppBarStateChange(TRUE, uStateProposed);

    // If Full Drag is off, we have horrible problems.  When we receive
	// the ExitSizeMove message, we have not been resized to the proper
	// size. - GetClientRect() returns the wrong rect.  To fix this,
	// we 'simulate' Full Drag when it is turned off
	BOOL m_bFullDrag;
	SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &m_bFullDrag, 0);
	if(!m_bFullDrag)
		SetWindowPos(NULL, prc->left, prc->top, prc->Width(), prc->Height(), SWP_NOZORDER);

	return(0);
}


/////////////////////////////////////////////////////////////////////////////


LRESULT CAppBar::OnSizing(WPARAM wParam, LPARAM lParam) {

	// We control the sizing of the AppBar.  For example, if the user re-sizes 
	// an edge, we want to change the size in descrete increments.

	// The lParam contains the window's position proposed by the system
	CRect* prc = (CRect *) lParam;

	// Get the minimum size of the window assuming it has no client area.
	// This is the width/height of the window that must always be present
	CRect rcBorder(0, 0, 0, 0);
	AdjustWindowRectEx(&rcBorder, GetStyle(), FALSE, GetExStyle());

	// We force the window to resize in discrete units set by the m_szSizeInc 
	// member.	From the new, proposed window dimensions passed to us, round 
	// the width/height to the nearest discrete unit.
	int nWidthNew	= ((prc->Width()	- rcBorder.Width())	+ m_szSizeInc.cx / 2) / 
		m_szSizeInc.cx * m_szSizeInc.cx + rcBorder.Width();
	int nHeightNew = ((prc->Height() - rcBorder.Height()) + m_szSizeInc.cy / 2) / 
		m_szSizeInc.cy * m_szSizeInc.cy + rcBorder.Height();

	// Adjust the rectangle's dimensions
	switch (wParam) {
		case WMSZ_LEFT:	 
			prc->left	= prc->right  - nWidthNew;  
			break;

		case WMSZ_TOP: 	 
			prc->top 	= prc->bottom - nHeightNew; 
			break;

		case WMSZ_RIGHT:	 
			prc->right	= prc->left   + nWidthNew;  
			break;

		case WMSZ_BOTTOM:  
			prc->bottom = prc->top	  + nHeightNew; 
			break;

		case WMSZ_BOTTOMLEFT:
			prc->bottom = prc->top	  + nHeightNew; 
			prc->left	= prc->right  - nWidthNew;  
			break;

		case WMSZ_BOTTOMRIGHT:
			prc->bottom = prc->top	  + nHeightNew; 
			prc->right	= prc->left   + nWidthNew;  
			break;

		case WMSZ_TOPLEFT:
			prc->left	= prc->right  - nWidthNew;
			prc->top 	= prc->bottom - nHeightNew;
			break;

		case WMSZ_TOPRIGHT:
			prc->top 	= prc->bottom - nHeightNew;
			prc->right	= prc->left   + nWidthNew;  
			break;
	}
	return(0);
}


void CAppBar::SetHidden(BOOL fHidden) {
	if(fHidden && !m_fHidden)
	{
		// Hide it
		m_fHidden = TRUE;

		// If docked, tell the system that we are 0x0
		if(GetState() != ABE_FLOAT)
			SHAppBarMessage(ABM_SETPOS, ABE_FLOAT, FALSE, &CRect(0, 0, 0, 0));
		ShowWindow(SW_HIDE);
	}
	else /*if(m_fHidden)HACK : : A-ANILK*/
	{
		// Show it
		m_fHidden = FALSE;

		// Show, but don't activate (ie. leave focus where it is...)
		ShowWindow(SW_SHOWNOACTIVATE);
		if(GetState() != ABE_FLOAT)
			SetState(GetState());
	}
}

//////////////////////////////// End of File //////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\appbar.h ===
/******************************************************************************
Module name: AppBar.h
Written by:  Jeffrey Richter
Purpose: 	 AppBar base class description file.
******************************************************************************/

#ifndef __APPBAR_H__
#define __APPBAR_H__


// An AppBar can be in one of 6 states shown in the table below: 
// State 			Description
// ----------- 	-----------------------------------------------------
// ABE_UNKNOWN 	The Appbar is in an unknown state 
// 					(usually during construction/destruction)
// ABE_FLOAT		The AppBar is floating on the screen
// ABE_LEFT 		The Appbar is docked on the left   edge of the screen
// ABE_TOP			The Appbar is docked on the top	  edge of the screen
// ABE_RIGHT		The Appbar is docked on the right  edge of the screen
// ABE_BOTTOM		The Appbar is docked on the bottom edge of the screen

// The ABE_edge state macros are defined in SHELLAPI.H as follows:
// #define ABE_LEFT			0
// #define ABE_TOP			1
// #define ABE_RIGHT 		2
// #define ABE_BOTTOM		3

// The ABE_UNKNOWN and ABE_FLOAT macros are defined here as follows:
#define ABE_UNKNOWN				((UINT) -1)
#define ABE_FLOAT 				((UINT) -2)


///////////////////////////////////////////////////////////////////////////////


// An AppBar can have several behavior flags as shown below: 
// Flag								 Description
// ----------- 					 ------------------------------------------------
// ABF_ALLOWLEFTRIGHT			 Allow dock on left/right of screen
// ABF_ALLOWTOPBOTTOM			 Allow dock on top/bottom of screen
// ABF_ALLOWANYEDGE				 Allow dock on any edge of screen
// ABF_ALLOWFLOAT 				 Allow float in the middle of screen
// ABF_ALLOWANYWHERE 			 Allow dock and float
// ABF_MIMICTASKBARAUTOHIDE	 Follow Autohide state of TaskBar
// ABF_MIMICTASKBARALWAYSONTOP Follow AlwaysOnTop state of TaskBar


#define ABF_ALLOWLEFTRIGHT 			0x00000001
#define ABF_ALLOWTOPBOTTOM 			0x00000002
#define ABF_ALLOWANYEDGE				(ABF_ALLOWLEFTRIGHT | ABF_ALLOWTOPBOTTOM)
#define ABF_ALLOWFLOAT					0x00000004
#define ABF_ALLOWANYWHERE				(ABF_ALLOWANYEDGE | ABF_ALLOWFLOAT)
#define ABF_MIMICTASKBARAUTOHIDE 	0x00000010
#define ABF_MIMICTASKBARALWAYSONTOP 0x00000020


// Helper macro to set the work area to full screen

inline void ResetWorkarea()
{
	CRect rcWorkArea( 0, 0, GetSystemMetrics( SM_CXSCREEN ), GetSystemMetrics( SM_CYSCREEN ) );
    ::SystemParametersInfo(SPI_SETWORKAREA, TRUE, &rcWorkArea, SPIF_SENDWININICHANGE);
}

// ShellRunning - helper function returns TRUE if the shell isn't running

inline BOOL ShellRunning()
{
	// look for the task bar by its class name
	return (FindWindow(TEXT("Shell_TrayWnd"), NULL) != NULL)?TRUE:FALSE;
}

///////////////////////////////////////////////////////////////////////////////

typedef struct {
		DWORD m_cbSize;			// Size of this structure
		UINT	m_uState;			// ABE_UNKNOWN, ABE_FLOAT, or ABE_edge
		BOOL	m_fAutohide;		// Should AppBar be auto-hidden when docked?
		BOOL	m_fAlwaysOnTop;	// Should AppBar always be on top?
		UINT	m_auDimsDock[4];	// Width/height for docked bar on 4 edges
		CRect m_rcFloat;			// Floating rectangle (in screen coordinates)
	} APPBARSTATE;

class CAppBar : public CDialog {

public:	// Static, AppBar-specific helper functions
	// Returns TRUE if uEdge is ABE_LEFT or ABE_RIGHT, else FALSE is returned
	static BOOL IsEdgeLeftOrRight (UINT uEdge);

	// Returns TRUE if uEdge is ABE_TOP or ABE_BOTTOM, else FALSE is returned
	static BOOL IsEdgeTopOrBottom (UINT uEdge);

	// Forces the shell to update its AppBar list and the workspace area
	static void ResetSystemKnowledge (void);

	// Returns a proposed edge or ABE_FLOAT based on ABF_* flags and a 
	// point specified in screen coordinates).
	static UINT GetEdgeFromPoint (DWORD fdwFlags, CPoint pt);


protected:	// Internal implementation state variables
	// Registered window message for the AppBar's callback notifications
	static UINT s_uAppBarNotifyMsg;

	// AppBar's class-specific constants
	enum { AUTOHIDETIMERID = 1, AUTOHIDETIMERINTERVAL = 400 };

	// See the OnAppBarCallbackMsg function for usage.
	DWORD m_fdwTaskBarState;

	// The structure below contains all of the AppBar settings that
	// can be saved/loaded in/from the Registry.
	APPBARSTATE *PAPPBARSTATE;
	APPBARSTATE m_abs;			// This AppBar's state info

	DWORD m_fdwFlags; 			// See the ABF_* flags above
	CSize m_szSizeInc;			// Descrete width/height size increments

	// We need a member variable which tracks the proposed state of the
	// AppBar while the user is moving it, deciding where to position it.
	// While not moving, this member must contain ABE_UNKNOWN so that 
	// GetState() returns the current state contained in m_ps.m_uState.
	// While moving the AppBar, m_uStateProposedPrev contains the 
	// proposed state based on the position of the AppBar.  The proposed 
	// state becomes the new state when the user stops moving the AppBar.
	UINT m_uStateProposedPrev;

	// We need a member variable which tracks whether a full screen 
	// application window is open
	BOOL m_fFullScreenAppOpen;

	// We need a member variable which tracks whether our autohide window 
	// is visible or not
	BOOL m_fAutoHideIsVisible;

	// Window is entirely hidden
	BOOL m_fHidden;

    // Prevent setting workarea multiple times w/same rect
    CRect m_rcOldWorkArea;
	
public:	// Public member functions
	// Constructs an AppBar
	CAppBar (UINT nIDTemplate, CWnd* pParent = NULL);

	// Returns which edge we're autohidden on or ABE_NONE
	UINT GetAutohideEdge (void);

	// Sets Autohide & AlwaysOnTop to match a specified state
	void MimicState (DWORD fdwStateChangedMask, DWORD fdwState);

	// Forces the appbar's visual appearance to match it's internal state
	void SetState (void);

	// Changes the AppBar's state to ABE_UNKNOWN, ABE_FLOAT or an ABE_edge
	void SetState (UINT uState);

	// Changes the AppBar's window to reflect the persistent state info
	void SetState (APPBARSTATE& abs);

	// Retrieves the AppBar's state.  If the AppBar is being positioned, its
	// proposed state is returned instead.
	UINT GetState (void);

	// Retrieves the AppBar's entire state.  To change many state variables,
	// call this function, change the variables, and then call SetState.
	void GetState (APPBARSTATE* pabs);

	// Gets the AppBar's Autohide state
	BOOL IsBarAutohide (void);

	// Gets the AppBar's always-on-top state
	BOOL IsBarAlwaysOnTop (void);

	// Gets the AppBar's floating rectangle
	void GetFloatRect (CRect* prc);

	// Gets the AppBar's docked width/height dimension
	int  GetDockedDim (UINT uEdge);

	// Hides the AppBar
	void SetHidden(BOOL fHidden);

protected:	// Internal implementation functions
	// This function simplifies calling the shell's SHAppBarMessage function
	UINT_PTR SHAppBarMessage (DWORD dwMessage, UINT uEdge = ABE_UNKNOWN, 
		LPARAM lParam = 0, CRect *rc = NULL);

	// Get a state (ABE_FLOAT or ABE_edge) from a point (screen coordinates)
	UINT CalcProposedState (const CPoint& pt);

	// Get a retangle position (screen coordinates) from a proposed state
	void GetRect (UINT uStateProposed, CRect* prcProposed);

	// Adjust the AppBar's location to account for autohide
	// Returns TRUE if rectangle was adjusted.
	BOOL AdjustLocationForAutohide (BOOL fShow, CRect* prc);

	// If AppBar is Autohide and docked, show/hide the AppBar.
	void ShowHiddenAppBar (BOOL fShow = TRUE);

	// When Autohide AppBar is shown/hidden, slide in/out of view
	void SlideWindow (const CRect& rc);


protected:	// Overridable functions
	// Called when the AppBar's proposed state changes.
	virtual void OnAppBarStateChange(BOOL fProposed, UINT uStateProposed);

	// Called if user attempts to dock an Autohide AppBar on
	// an edge that already contains an Autohide AppBar
	virtual void OnAppBarForcedToDocked(void);

	// Called when AppBar gets an ABN_FULLSCREENAPP notification
	virtual void OnABNFullScreenApp (BOOL fOpen);

	// Called when AppBar gets an ABN_POSCHANGED notification
	virtual void OnABNPosChanged (void);

	// Called when AppBar gets an ABN_STATECHANGE notification
	virtual void OnABNStateChange (DWORD fdwStateChangedMask, DWORD fdwState);

	// Called when AppBar gets an ABN_WINDOWARRANGE notification
	virtual void OnABNWindowArrange (BOOL fBeginning);

// Dialog Data
	//{{AFX_DATA(CAppBar)
	enum { IDD = 0 };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAppBar)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	 // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAppBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg UINT OnNcHitTest(CPoint point);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI );
	//}}AFX_MSG
	afx_msg LRESULT OnAppBarCallbackMsg(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnEnterSizeMove(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnExitSizeMove(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSizing(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnMoving(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////////////
// Inline functions.  See above for descriptions


inline BOOL CAppBar::IsEdgeLeftOrRight (UINT uEdge) { 
	return((uEdge == ABE_LEFT) || (uEdge == ABE_RIGHT)); 
}

inline BOOL CAppBar::IsEdgeTopOrBottom (UINT uEdge) { 
	return((uEdge == ABE_TOP) || (uEdge == ABE_BOTTOM)); 
}

inline void CAppBar::SetState (void) {
	SetState(GetState());
}

inline UINT CAppBar::GetState (void) { 
	return((m_uStateProposedPrev != ABE_UNKNOWN) 
		? m_uStateProposedPrev : m_abs.m_uState); 
}

inline void CAppBar::GetState (APPBARSTATE* pabs) {
	DWORD dwSizeCaller = pabs->m_cbSize;
	CopyMemory(pabs, &m_abs, pabs->m_cbSize);
	pabs->m_cbSize = dwSizeCaller;
}

inline BOOL CAppBar::IsBarAutohide (void) {
	return(m_abs.m_fAutohide); 
}

inline BOOL CAppBar::IsBarAlwaysOnTop (void) { 
	return(m_abs.m_fAlwaysOnTop); 
}

inline void CAppBar::GetFloatRect (CRect* prc) {
	*prc = m_abs.m_rcFloat; 
}

inline int CAppBar::GetDockedDim (UINT uEdge) {
	return(m_abs.m_auDimsDock[uEdge]);
}

inline int AbsoluteValue(int n) { 
	return((n < 0) ? -n : n); 
}


#endif


//////////////////////////////// End of File //////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\desktop.cpp ===
// Desktop.cpp : helper functions for desktop detection
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//  

#include "stdafx.h"
#include "desktop.h"

// Returns the current desktop-ID
DWORD GetDesktop()
{
    HDESK hdesk;
    TCHAR name[300];
    DWORD nl, desktopID, value = 0;
    HKEY  hKey;

    // Detect case where we're in system setup

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\Setup"), 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        DWORD cbData = sizeof(DWORD);
        RegQueryValueEx(hKey, TEXT("SystemSetupInProgress"), NULL, NULL, (LPBYTE)&value, &cbData);
        RegCloseKey(hKey);
    }

	if ( value )
	{
		return DESKTOP_ACCESSDENIED;	// Setup is in progress...
	}

	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (!hdesk)
    {
        // OpenInputDesktop will fail on "Winlogon" desktop
        hdesk = OpenDesktop(__TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
        if (!hdesk)
            return DESKTOP_WINLOGON;
    }
    
	GetUserObjectInformation(hdesk, UOI_NAME, name, 300, &nl);
    CloseDesktop(hdesk);

	if (!_tcsicmp(name, __TEXT("Default")))
    {
        desktopID = DESKTOP_DEFAULT;
    }
    else if (!_tcsicmp(name, __TEXT("Winlogon")))
    {
        desktopID = DESKTOP_WINLOGON;
    }
    else if (!_tcsicmp(name, __TEXT("screen-saver")))
    {
        desktopID = DESKTOP_SCREENSAVER;
    }
    else if (!_tcsicmp(name, __TEXT("Display.Cpl Desktop")))
    {
        desktopID = DESKTOP_TESTDISPLAY;
    }
    else
    {
        desktopID = DESKTOP_OTHER;
    }

	return desktopID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\desktop.h ===
// Desktop.h : Desktop function header
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//  
// Desktop function header

#define DESKTOP_ACCESSDENIED 0
#define DESKTOP_DEFAULT      1
#define DESKTOP_SCREENSAVER  2
#define DESKTOP_WINLOGON     3
#define DESKTOP_TESTDISPLAY  4
#define DESKTOP_OTHER        5

DWORD GetDesktop();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\fastdib.h ===
/******************************Module*Header*******************************\
* Module Name: fastdib.h
*
* CreateCompatibleDIB definitions.
*
* Created: 02-Feb-1996 19:30:45
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef _FASTDIB_H_
#define _FASTDIB_H_

HBITMAP APIENTRY CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight, PVOID *ppvBits);
BOOL APIENTRY UpdateDIBColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal);
BOOL APIENTRY GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride);
BOOL APIENTRY GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector);

#endif //_FASTDIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\fastdib.cpp ===
/******************************Module*Header*******************************\
* Module Name: fastdib.c
*
* CreateCompatibleDIB implementation.
*
* Created: 23-Jan-1996 21:08:18
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <StdAfx.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

#include "fastdib.h"

static BOOL bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi);
static BOOL bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi);
static UINT MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                                      LPPALETTEENTRY lppe);
static BOOL bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal,
                                        BYTE *pajVector);

#if DBG
ULONG DbgPrint(PCH DebugMessage, ...);

#define DBGPRINT(str)                       DbgPrint(str)
#define DBGPRINT1(str, arg1)                DbgPrint(str, arg1)
#define DBGPRINT2(str, arg1, arg2)          DbgPrint(str, arg1, arg2)
#define DBGPRINT3(str, arg1, arg2, arg3)    DbgPrint(str, arg1, arg2, arg3)
#else
#define DBGPRINT(str)
#define DBGPRINT1(str, arg1)
#define DBGPRINT2(str, arg1, arg2)
#define DBGPRINT3(str, arg1, arg2, arg3)
#endif

/******************************Public*Routine******************************\
* CreateCompatibleDIB
*
* Create a DIB section with an optimal format w.r.t. the specified hdc.
*
* If DIB <= 8bpp, then the DIB color table is initialized based on the
* specified palette.  If the palette handle is NULL, then the system
* palette is used.
*
* Note: The hdc must be a direct DC (not an info or memory DC).
*
* Note: On palettized displays, if the system palette changes the
*       UpdateDIBColorTable function should be called to maintain
*       the identity palette mapping between the DIB and the display.
*
* Returns:
*   Valid bitmap handle if successful, NULL if error.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HBITMAP APIENTRY
CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight,
                    PVOID *ppvBits)
{
    HBITMAP hbmRet = (HBITMAP) NULL;
    BYTE aj[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) aj;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        DBGPRINT("CreateCompatibleDIB: not OBJ_DC\n");
        return hbmRet;
    }

    memset(aj, 0, sizeof(aj));
    if ( bFillBitmapInfo(hdc, hpal, pbmi) )
    {
        //
        // Change bitmap size to match specified dimensions.
        //

        pbmi->bmiHeader.biWidth = ulWidth;
        pbmi->bmiHeader.biHeight = ulHeight;
        if (pbmi->bmiHeader.biCompression == BI_RGB)
        {
            pbmi->bmiHeader.biSizeImage = 0;
        }
        else
        {
            if ( pbmi->bmiHeader.biBitCount == 16 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 2;
            else if ( pbmi->bmiHeader.biBitCount == 32 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 4;
            else
                pbmi->bmiHeader.biSizeImage = 0;
        }
        pbmi->bmiHeader.biClrUsed = 0;
        pbmi->bmiHeader.biClrImportant = 0;

        //
        // Create the DIB section.  Let Win32 allocate the memory and return
        // a pointer to the bitmap surface.
        //

        hbmRet = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0);

        if ( !hbmRet )
        {
            DBGPRINT("CreateCompatibleDIB: CreateDIBSection failed\n");
        }
    }
    else
    {
        DBGPRINT("CreateCompatibleDIB: bFillBitmapInfo failed\n");
    }

    return hbmRet;
}

/******************************Public*Routine******************************\
* UpdateDIBColorTable
*
* Synchronize the DIB color table to the specified palette hpal.
* If hpal is NULL, then use the system palette.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
UpdateDIBColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal)
{
    BOOL bRet = FALSE;
    HBITMAP hbm;
    DIBSECTION ds;
    BYTE aj[(sizeof(RGBQUAD) + sizeof(PALETTEENTRY)) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    LPRGBQUAD prgb = (LPRGBQUAD) (lppe + 256);
    ULONG cColors;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        DBGPRINT("UpdateDIBColorTable: not OBJ_DC\n");
        return bRet;
    }
    if ( GetObjectType(hdcMem) != OBJ_MEMDC )
    {
        DBGPRINT("UpdateDIBColorTable: not OBJ_MEMDC\n");
        return bRet;
    }

    //
    // Get the bitmap handle out of the memdc.
    //

    hbm = (HBITMAP)GetCurrentObject(hdcMem, OBJ_BITMAP);

    //
    // Validate bitmap (must be DIB section).
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds)) &&
         ds.dsBm.bmBits )
    {
        //
        // Get palette entries from specified palette or system palette.
        //

        cColors = 1 << ds.dsBmih.biBitCount;

        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe)
           )
        {
            UINT i;

            //
            // Convert to RGBQUAD.
            //

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            //
            // Set the DIB color table.
            //

            bRet = (BOOL) SetDIBColorTable(hdcMem, 0, cColors, prgb);

            if (!bRet)
            {
                DBGPRINT("UpdateDIBColorTable: SetDIBColorTable failed\n");
            }
        }
        else
        {
            DBGPRINT("UpdateDIBColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }
    else
    {
        DBGPRINT("UpdateDIBColorTable: GetObject failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GetCompatibleDIBInfo
*
* Copies pointer to bitmap origin to ppvBase and bitmap stride to plStride.
* Win32 DIBs can be created bottom-up (the default) with the origin at the
* lower left corner or top-down with the origin at the upper left corner.
* If the bitmap is top-down, *plStride is positive; if bottom-up, *plStride
* us negative.
*
* Also, because of restrictions on the alignment of scan lines the width
* the bitmap is often not the same as the stride (stride is the number of
* bytes between vertically adjacent pixels).
*
* The ppvBase and plStride value returned will allow you to address any
* given pixel (x, y) in the bitmap as follows:
*
* PIXEL *ppix;
*
* ppix = (PIXEL *) (((BYTE *)*ppvBase) + (y * *plStride) + (x * sizeof(PIXEL)));
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride)
{
    BOOL bRet = FALSE;
    DIBSECTION ds;

    //
    // Call GetObject to return a DIBSECTION.  If successful, the
    // bitmap is a DIB section and we can retrieve the pointer to
    // the bitmap bits and other parameters.
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && ds.dsBm.bmBits )
    {
        //!!!dbug -- GDI Bug 19374: bmWidthBytes returns pitch assuming
        //!!!        that DIB scanlines are WORD aligned (as they
        //!!!        are in Win95).  But NT DIBs are DWORD aligned.
        //!!!        When bug if corrected, we can remove this block of
        //!!!        code.
        #if 0
        {
            OSVERSIONINFO osvi;

            osvi.dwOSVersionInfoSize = sizeof(osvi);
            if (GetVersionEx(&osvi))
            {
                if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
                {
                    ds.dsBm.bmWidthBytes = (ds.dsBm.bmWidthBytes + 3) & ~3;
                }
            }
            else
            {
                DBGPRINT1("GetCompatibleDIBInfo: GetVersionEx failed with %d\n", GetLastError());
                return bRet;
            }
        }
        #endif

        //
        // If biHeight is positive, then the bitmap is a bottom-up DIB.
        // If biHeight is negative, then the bitmap is a top-down DIB.
        //

        if ( ds.dsBmih.biHeight > 0 )
        {
            *ppvBase  = (PVOID) (((INT_PTR) ds.dsBm.bmBits) + (ds.dsBm.bmWidthBytes * (ds.dsBm.bmHeight - 1)));
            *plStride = (ULONG) (-ds.dsBm.bmWidthBytes);
        }
        else
        {
            *ppvBase  = ds.dsBm.bmBits;
            *plStride = ds.dsBm.bmWidthBytes;
        }

        bRet = TRUE;
    }
    else
    {
        DBGPRINT("GetCompatibleDIBInfo: cannot get pointer to DIBSECTION bmBits\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GetDIBTranslationVector
*
* Copies the translation vector that maps colors in the specified palette,
* hpal, to the DIB selected into the specified DC, hdcMem.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector)
{
    BOOL bRet = FALSE;
    HBITMAP hbm;
    DIBSECTION ds;

    //
    // Validate parameters.
    //

    if ( GetObjectType(hdcMem) != OBJ_MEMDC ||
         GetObjectType(hpal) != OBJ_PAL ||
         !pbVector )
    {
        DBGPRINT("GetDIBTranslationVector: bad parameter\n");
        return bRet;
    }

    //
    // The function bComputeLogicalToSurfaceMap cannot handle palettes
    // greater than 256 entries.
    //

    if ( GetPaletteEntries(hpal, 0, 1, NULL) > 256 )
    {
        DBGPRINT("GetDIBTranslationVector: palette too big\n");
        return bRet;
    }

    //
    // The DIB must have a color table.
    //

    hbm = (HBITMAP)GetCurrentObject(hdcMem, OBJ_BITMAP);
    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && (ds.dsBmih.biBitCount <= 8) )
    {
        bRet = bComputeLogicalToSurfaceMap(hdcMem, hpal, pbVector);
    }
    else
    {
        DBGPRINT("GetDIBTranslationVector: not a DIB section\n");
        return bRet;
    }

    return bRet;
}

//////////////////// Below here are internal-only routines ////////////////////

/******************************Public*Routine******************************\
* bFillBitmapInfo
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    //
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.
    //

    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //

        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if ( pbmi->bmiHeader.biBitCount <= 8 )
        {
            bRet = bFillColorTable(hdc, hpal, pbmi);
        }
        else
        {
            if ( pbmi->bmiHeader.biCompression == BI_BITFIELDS )
            {
                //
                // Call a second time to get the color masks.
                // It's a GetDIBits Win32 "feature".
                //

                GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                          DIB_RGB_COLORS);
            }

            bRet = TRUE;
        }

        DeleteObject(hbm);
    }
    else
    {
        DBGPRINT("bFillBitmapInfo: CreateCompatibleBitmap failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bFillColorTable
*
* Initialize the color table of the BITMAPINFO pointed to by pbmi.  Colors
* are set to the current system palette.
*
* Note: call only valid for displays of 8bpp or less.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    BOOL bRet = FALSE;
    BYTE aj[sizeof(PALETTEENTRY) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    RGBQUAD *prgb = (RGBQUAD *) &pbmi->bmiColors[0];
    ULONG cColors;

    cColors = 1 << pbmi->bmiHeader.biBitCount;
    if ( cColors <= 256 )
    {
        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe) )
        {
            UINT i;

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            bRet = TRUE;
        }
        else
        {
            DBGPRINT("bFillColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* MyGetSystemPaletteEntries
*
* Internal version of GetSystemPaletteEntries.
*
* GetSystemPaletteEntries fails on some 4bpp devices.  This version
* will detect the 4bpp case and supply the hardcoded 16-color VGA palette.
* Otherwise, it will pass the call on to GDI's GetSystemPaletteEntries.
*
* It is expected that this call will only be called in the 4bpp and 8bpp
* cases as it is not necessary for OpenGL to query the system palette
* for > 8bpp devices.
*
* History:
*  17-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static PALETTEENTRY gapeVgaPalette[16] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0x80,0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

static UINT
MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                          LPPALETTEENTRY lppe)
{
    int nDeviceBits;

    nDeviceBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    //
    // Some 4bpp displays will fail the GetSystemPaletteEntries call.
    // So if detected, return the hardcoded table.
    //

    if ( nDeviceBits == 4 )
    {
        if ( lppe )
        {
            nEntries = min(nEntries, (16 - iStartIndex));

            memcpy(lppe, &gapeVgaPalette[iStartIndex],
                   nEntries * sizeof(PALETTEENTRY));
        }
        else
            nEntries = 16;

        return nEntries;
    }
    else
    {
        return GetSystemPaletteEntries(hdc, iStartIndex, nEntries, lppe);
    }
}

/******************************Public*Routine******************************\
* bComputeLogicalToSurfaceMap
*
* Copy logical palette to surface palette translation vector to the buffer
* pointed to by pajVector.  The logical palette is specified by hpal.  The
* surface is specified by hdc.
*
* Note: The hdc may identify either a direct (display) dc or a DIB memory dc.
* If hdc is a display dc, then the surface palette is the system palette.
* If hdc is a memory dc, then the surface palette is the DIB color table.
*
* History:
*  27-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal, BYTE *pajVector)
{
    BOOL bRet = FALSE;
    HPALETTE hpalSurf;
    ULONG cEntries, cSysEntries;
    DWORD dwDcType = GetObjectType(hdc);
    LPPALETTEENTRY lppeTmp, lppeEnd;

    BYTE aj[sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * 512) + (sizeof(RGBQUAD) * 256)];
    LOGPALETTE *ppal = (LOGPALETTE *) aj;
    LPPALETTEENTRY lppeSurf = &ppal->palPalEntry[0];
    LPPALETTEENTRY lppe = lppeSurf + 256;
    RGBQUAD *prgb = (RGBQUAD *) (lppe + 256);

    //
    // Determine number of colors in each palette.
    //

    cEntries = GetPaletteEntries(hpal, 0, 1, NULL);
    if ( dwDcType == OBJ_DC )
        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, 1, NULL);
    else
        cSysEntries = 256;

    //
    // Get the logical palette entries.
    //

    cEntries = GetPaletteEntries(hpal, 0, cEntries, lppe);

    //
    // Get the surface palette entries.
    //

    if ( dwDcType == OBJ_DC )
    {
        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, cSysEntries, lppeSurf);

        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        for (; lppeTmp < lppeEnd; lppeTmp++)
            lppeTmp->peFlags = 0;
    }
    else
    {
        RGBQUAD *prgbTmp;

        //
        // First get RGBQUADs from DIB color table...
        //

        cSysEntries = GetDIBColorTable(hdc, 0, cSysEntries, prgb);

        //
        // ...then convert RGBQUADs into PALETTEENTRIES.
        //

        prgbTmp = prgb;
        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        while ( lppeTmp < lppeEnd )
        {
            lppeTmp->peRed   = prgbTmp->rgbRed;
            lppeTmp->peGreen = prgbTmp->rgbGreen;
            lppeTmp->peBlue  = prgbTmp->rgbBlue;
            lppeTmp->peFlags = 0;

            lppeTmp++;
            prgbTmp++;

        }
    }

    //
    // Construct a translation vector by using GetNearestPaletteIndex to
    // map each entry in the logical palette to the surface palette.
    //

    if ( cEntries && cSysEntries )
    {
        //
        // Create a temporary logical palette that matches the surface
        // palette retrieved above.
        //

        ppal->palVersion = 0x300;
        ppal->palNumEntries = (USHORT) cSysEntries;

        if ( hpalSurf = CreatePalette(ppal) )
        {
            //
            // Translate each logical palette entry into a surface palette
            // index.
            //

            lppeTmp = lppe;
            lppeEnd = lppe + cEntries;

            for ( ; lppeTmp < lppeEnd; lppeTmp++, pajVector++)
            {
                *pajVector = (BYTE) GetNearestPaletteIndex(
                                        hpalSurf,
                                        RGB(lppeTmp->peRed,
                                            lppeTmp->peGreen,
                                            lppeTmp->peBlue)
                                        );
            }

            bRet = TRUE;

            DeleteObject(hpalSurf);
        }
        else
        {
            DBGPRINT("bComputeLogicalToSurfaceMap: CreatePalette failed\n");
        }
    }
    else
    {
        DBGPRINT("bComputeLogicalToSurfaceMap: failed to get pal info\n");
    }

    return bRet;
}

#if DBG
/******************************Public*Routine******************************\
* DbgPrint
*
* Formatted string output to the debugger.
*
* History:
*  26-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG
DbgPrint(PCH DebugMessage, ...)
{
    va_list ap;
    char buffer[256];

    va_start(ap, DebugMessage);

    vsprintf(buffer, DebugMessage, ap);

#ifdef DEBUG
    OutputDebugStringA(buffer);
#endif

    va_end(ap);

    return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\magbar.cpp ===
/******************************************************************************
Module name: MagBar.cpp
Copyright (c) 1997-1999 Microsoft Corporation
Written by:  Jeffrey Richter
Purpose:     Shell Run CAppBar-derived class implementation file.
******************************************************************************/

#include "stdafx.h"
#include <windowsx.h>
#include <malloc.h>
#include <WinReg.h>
#include "..\Mag_Hook\Mag_Hook.h"
#include "Magnify.h"
#include "resource.h"
#include "MagDlg.h"
#include "MagBar.h"
#include "Registry.h"
// The way to include "MultiMon.h" is to include it twice and define 
// COMPILE_MULTIMON_STUBS. a-anilk
#include "MultiMon.h"

#define COMPILE_MULTIMON_STUBS
#include "MultiMon.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
#include "FastDib.h"

template<class TYPE> 
TYPE ForceInRange(TYPE tVal, TYPE tMin, TYPE tMax) {
	TYPE t = tVal;
	if (tVal < tMin) t = tMin;
	else if (tVal > tMax) t = tMax;
	return(t);
}

// If we are using VC5 there is no CURSORINFO structure in winuser.h
// We have to define it here.
#ifdef VC5_BUILD___NOT_NT_BUILD_ENVIRONMENT2
typedef struct tagCURSORINFO
{
    DWORD   cbSize;
    DWORD   flags;
    HCURSOR hCursor;
    POINT   ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;
#endif

#define CURSOR_SHOWING     0x00000001

typedef BOOL (WINAPI *_tagGetCursorInfo)(PCURSORINFO pci);
_tagGetCursorInfo g_pGetCursorInfo = NULL;


/////////////////////////////////////////////////////////////////////////////
// Constant global variables


const TCHAR CMagBar::m_szRegSubkey[] = __TEXT("Software\\Microsoft\\Magnify");


/////////////////////////////////////////////////////////////////////////////
// Public member functions

CMagBar::CMagBar(CMagnifyDlg* pwndSettings) : CAppBar(CMagBar::IDD, NULL)
{
	m_bForceHideCursor = FALSE;
	// Construct and save the physical palette
	PLOGPALETTE ppal = (PLOGPALETTE)_alloca(sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * 256);   // 256 palette entries.
	ppal->palVersion = 0x300;
	ppal->palNumEntries = 256;
	for (int i = 0; i < 256; i++)
	{
		ppal->palPalEntry[i].peFlags = (BYTE)PC_EXPLICIT;
		ppal->palPalEntry[i].peRed   = (BYTE)i;
		ppal->palPalEntry[i].peGreen = (BYTE)0;
		ppal->palPalEntry[i].peBlue  = (BYTE)0;
	}
	m_hpalPhysical.CreatePalette(ppal);
	m_pwndSettings = pwndSettings;
	m_szMinTracking = CSize(0, 0);
	m_fShowCrossHair = /*FALSE JMC*/TRUE;
	m_fShowZoomRect = FALSE;
	//{{AFX_DATA_INIT(CMagBar)
	//}}AFX_DATA_INIT

	m_bSizingOrMoving = FALSE;
	m_str.LoadString(IDS_MOVEFLOAT);
	m_strD.LoadString(IDS_MOVESTRING);

	// JMC: NOTE: There is no unicode version of GetProcAddress
	g_pGetCursorInfo = (_tagGetCursorInfo)GetProcAddress(GetModuleHandle(__TEXT("user32.dll")), "GetCursorInfo");

	m_hbmOffScreen = NULL;
	m_dwLastMouseMoveTrack = 0;
    m_ptLastMousePos.x = 0;
    m_ptLastMousePos.y = 0;
	
}


/////////////////////////////////////////////////////////////////////////////
// Internal implementation functions


void CMagBar::HideFloatAdornments(BOOL fHide)
{
	if (fHide)
		ModifyStyle(WS_CAPTION, 0, SWP_DRAWFRAME);
	else
		ModifyStyle(0, WS_CAPTION | WS_SYSMENU, SWP_DRAWFRAME);
}


/////////////////////////////////////////////////////////////////////////////
// Overridable functions


// Tell our derived class that there is a proposed state change
void CMagBar::OnAppBarStateChange (BOOL fProposed, UINT uStateProposed)
{
	// Hide the window adorments when docked.
	HideFloatAdornments((uStateProposed == ABE_FLOAT) ? FALSE : TRUE);
}


/////////////////////////////////////////////////////////////////////////////


void CMagBar::DoDataExchange(CDataExchange* pDX)
{
	CAppBar::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMagBar)
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////


BEGIN_MESSAGE_MAP(CMagBar, CAppBar)
	//{{AFX_MSG_MAP(CMagBar)
	ON_WM_CONTEXTMENU()
	ON_WM_SIZE()
	ON_WM_GETMINMAXINFO()
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_TIMER()
	ON_WM_KEYDOWN()
	ON_WM_DESTROY()
	ON_WM_SETTINGCHANGE()
	ON_WM_SYSCOLORCHANGE()
	ON_COMMAND(ID_APPBAR_COPYTOCLIPBOARD, OnAppbarCopyToClipboard)
	ON_WM_CLOSE()
	ON_WM_SETCURSOR()
	ON_COMMAND(ID_APPBAR_EXIT, OnAppbarExit)
	ON_COMMAND(ID_APPBAR_OPTIONS, OnAppbarOptions)
	ON_COMMAND(ID_APPBAR_HIDE, OnAppbarHide)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_ENTERSIZEMOVE, OnEnterSizeMove)
	ON_MESSAGE(WM_EXITSIZEMOVE, OnExitSizeMove)
	ON_MESSAGE(WM_EVENT_CARETMOVE, OnEventCaretMove)
	ON_MESSAGE(WM_EVENT_FOCUSMOVE, OnEventFocusMove)
	ON_MESSAGE(WM_EVENT_MOUSEMOVE, OnEventMouseMove)
	ON_MESSAGE(WM_EVENT_FORCEMOVE, OnEventForceMove)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMagBar message handlers


LRESULT CMagBar::OnEventXMove(WPARAM wParam, LPARAM lParam, BOOL fShowCrossHair)
{
	// If the location is over the Magnify window, ignore this event.
// JMC: HACK	if (WindowFromPoint(CPoint(wParam)) != this)
	{
//		DrawZoomRect();	// erase old one
		m_ptZoom = CPoint((DWORD)wParam);
		m_fShowCrossHair = fShowCrossHair;
		DoTheZoomIn(NULL, m_fShowCrossHair);
//		DrawZoomRect();	// draw new one
	}
	return(0);
}


LRESULT CMagBar::OnEventCaretMove(WPARAM wParam, LPARAM lParam)
{
	// Don't track if it has been less than .25 seconds since a mouse track
	if (TrackText() && (GetTickCount() - m_dwLastMouseMoveTrack)> 250) OnEventXMove(wParam, lParam, FALSE);
	return(0);
}


LRESULT CMagBar::OnEventFocusMove(WPARAM wParam, LPARAM lParam)
{
	if (TrackFocus() && (GetTickCount() - m_dwLastMouseMoveTrack)> 250) OnEventXMove(wParam, lParam, FALSE);
	return(0);
}


LRESULT CMagBar::OnEventMouseMove(WPARAM wParam, LPARAM lParam)
{
    if (TrackCursor())
    {
        // If the mouse is w/in the client rect of a window that's just been
        // created then we get a mouse move message even tho the mouse hasn't
        // moved; ignore these.
        if (m_ptLastMousePos.x != GET_X_LPARAM(wParam) || 
            m_ptLastMousePos.y != GET_Y_LPARAM(wParam))
        {
	        OnEventXMove(wParam, lParam, TRUE);
	        m_dwLastMouseMoveTrack = GetTickCount();
            m_ptLastMousePos.x = GET_X_LPARAM(wParam);
            m_ptLastMousePos.y = GET_Y_LPARAM(wParam);
        }
    }
    return(0);
}



LRESULT CMagBar::OnEventForceMove(WPARAM wParam, LPARAM lParam)
{
    // Unconditional move...
    // (Third param actually ignored - should remove globally...)
	OnEventXMove(wParam, lParam, FALSE);
	return(0);
}


/////////////////////////////////////////////////////////////////////////////


UINT CMagBar::MagLevel() { return(m_pwndSettings->m_nStationaryMagLevel); }
BOOL CMagBar::TrackText() { return(m_pwndSettings->m_fStationaryTrackText); }
BOOL CMagBar::TrackSecondaryFocus() { return(m_pwndSettings->m_fStationaryTrackSecondaryFocus); }
BOOL CMagBar::TrackCursor() { return(m_pwndSettings->m_fStationaryTrackCursor); }
BOOL CMagBar::TrackFocus() { return(m_pwndSettings->m_fStationaryTrackFocus); }
BOOL CMagBar::InvertColors() { return(m_pwndSettings->m_fStationaryInvertColors); }


/////////////////////////////////////////////////////////////////////////////


BOOL CMagBar::OnInitDialog()
{
	CAppBar::OnInitDialog();

	// TODO: Add extra initialization here
	// Remove our owner window so that we stay visible when the owner is minimized
	::SetWindowLongPtr(m_hWnd, GWLP_HWNDPARENT, NULL);

	// Set the CAppBar class's behavior flags
	m_fdwFlags = ABF_ALLOWANYWHERE;

	// Width has no limits, height sizes in client-area-height increments
	CRect rc;
	GetClientRect(&rc);
	m_szSizeInc.cx = m_szSizeInc.cy = 1;

	// The appbar has a minimum client-area size that is determin ed by the 
	// client area set in the dialog box template.
	m_szMinTracking.cx = rc.Width();
	m_szMinTracking.cy = rc.Height();

	// Setup default state data for the AppBar
	APPBARSTATE abs;

	abs.m_cbSize = sizeof(abs);
	abs.m_uState = ABE_TOP;
	abs.m_fAutohide = FALSE;
	abs.m_fAlwaysOnTop = TRUE;

	// Set the default floating location of the appbar
	GetWindowRect(&abs.m_rcFloat);

	// Make the default width 80% of the workarea width
	CRect rcWorkArea;
	::SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWorkArea, 0);
	abs.m_rcFloat.right = abs.m_rcFloat.left + (rcWorkArea.Width() * 8 / 10);

	// Temporarily turn off window adornments to determine the dimensions
	// of the appbar when docked.
	HideFloatAdornments(TRUE);
	AdjustWindowRectEx(&rc, GetStyle(), FALSE, GetExStyle());
	HideFloatAdornments(FALSE);
	abs.m_auDimsDock[ABE_LEFT]   = rc.Width();
	abs.m_auDimsDock[ABE_TOP]    = rc.Height();
	abs.m_auDimsDock[ABE_RIGHT]  = rc.Width();
	abs.m_auDimsDock[ABE_BOTTOM] = rc.Height();

	// Check the registry to see if we have been used before and if so,
	// reload our persistent settings.
	CRegSettings reg;
	if (reg.OpenSubkey(TRUE, HKEY_CURRENT_USER, m_szRegSubkey) == ERROR_SUCCESS)
	{
		DWORD cbData = sizeof(abs);
		reg.GetBinary(__TEXT("AppBar"), (PBYTE) &abs, &cbData);
		
		// In case these values are out of bound for multimon case. 
		// Reset to old values. 
		if ( MonitorFromRect( &abs.m_rcFloat, MONITOR_DEFAULTTONULL) == NULL )
		{
			abs.m_uState = ABE_TOP;

			// Set the default floating location of the appbar
			GetWindowRect(&abs.m_rcFloat);

			// Make the default width 80% of the workarea width
			CRect rcWorkArea;
			::SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWorkArea, 0);
			abs.m_rcFloat.right = abs.m_rcFloat.left + (rcWorkArea.Width() * 8 / 10);

			// Temporarily turn off window adornments to determine the dimensions
			// of the appbar when docked.
			HideFloatAdornments(TRUE);
			AdjustWindowRectEx(&rc, GetStyle(), FALSE, GetExStyle());
			HideFloatAdornments(FALSE);
			abs.m_auDimsDock[ABE_LEFT]   = rc.Width();
			abs.m_auDimsDock[ABE_TOP]    = rc.Height();
			abs.m_auDimsDock[ABE_RIGHT]  = rc.Width();
			abs.m_auDimsDock[ABE_BOTTOM] = rc.Height();
		}

		if (cbData != sizeof(abs))
		{
			// The saved persistent data is a different size than what we 
			// expect. The user probably saved the data using an older version
			// of the AppBar class.  Do any version differencing here...
		}
	}

	// Set the initial state of the appbar.
	SetState(abs);

	// Set the system screen reader flag on so that apps
	// like Word 97 will expose the caret position. Send INI change: a-anilk
	::SystemParametersInfo(SPI_SETSCREENREADER, TRUE, NULL, SPIF_UPDATEINIFILE|SPIF_SENDCHANGE);

	// Set the initial zommed area to be where the mouse cursor is
	GetCursorPos(&m_ptZoom);

	// A system menu gives keyboard functionality for sizing/moving...
	CMenu *hSysMenu = GetSystemMenu(FALSE);
	if ( hSysMenu != NULL )
	{
		hSysMenu->EnableMenuItem( 0, MF_BYPOSITION | MF_GRAYED);
		hSysMenu->EnableMenuItem( 3, MF_BYPOSITION | MF_GRAYED);
		hSysMenu->EnableMenuItem( 4, MF_BYPOSITION | MF_GRAYED);
	}

	
	// Create the memory DC's used for blt'ing the cursor to the screen
	m_dcMem.CreateCompatibleDC(NULL); // Used for blt'ing the cursor

	// Setup offscreen DC
	m_dcOffScreen.CreateCompatibleDC(NULL);
	SetupOffScreenDC();
	
	// Set the refresh timer
	SetTimer(eRefreshTimerId, eRefreshTimerInterval, NULL);

	// Install the ActiveX Accessibility WinEvent Hook. 
	// See the Mag_Hook project for the hook filter function. 
    InstallEventHook(m_hWnd);

	return TRUE;  // return TRUE unless you set the focus to a control
}


/////////////////////////////////////////////////////////////////////////////


void CMagBar::OnDestroy()
{
	// TODO: Add your message handler code here
	// Save the current state of the appbar in the registry so that we'll
	// come up in the same state the next time the user runs us.
	CRegSettings reg;
	if (reg.OpenSubkey(FALSE, HKEY_CURRENT_USER, m_szRegSubkey) == ERROR_SUCCESS)
	{
		APPBARSTATE abs;
		abs.m_cbSize = sizeof(abs);
		GetState(&abs);
		// Save the AppBar's state variables to the registry.
		reg.PutBinary(__TEXT("AppBar"), (PBYTE) &abs, sizeof(abs));
	}
	InstallEventHook(NULL);	// remove the event hook
	KillTimer(eRefreshTimerId);

	// Turn off the system-wide screen reader flag.
	// JMR: Remove?:    gfAppExiting=TRUE; No need to send message: a-anilk
	::SystemParametersInfo(SPI_SETSCREENREADER, FALSE, NULL, SPIF_UPDATEINIFILE|SPIF_SENDCHANGE);

	// Destroy the off screen DC before deleting the last bitmap that was in it
	m_dcOffScreen.DeleteDC();
	if(m_hbmOffScreen)
		DeleteObject(m_hbmOffScreen);

	CAppBar::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////


void CMagBar::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
{
	// Get the minimum size of the window assuming it has no client area.
	// This is the width/height of the window that must always be present
	CRect rcBorder(0, 0, 0, 0);
	AdjustWindowRectEx(&rcBorder, GetStyle(), FALSE, GetExStyle());
	
	if (GetState() == ABE_FLOAT)
	{
		lpMMI->ptMinTrackSize.x = m_szMinTracking.cx + rcBorder.Width();
		lpMMI->ptMinTrackSize.y = m_szMinTracking.cy + rcBorder.Height();
	}

	// Get the width & height of the screen
	lpMMI->ptMaxTrackSize.x = GetSystemMetrics(SM_CXSCREEN);
	lpMMI->ptMaxTrackSize.y = GetSystemMetrics(SM_CYSCREEN);
	if (GetState() == ABE_FLOAT)
	{
		// When the window is floating...
		// Width can be 100% of screen
		// JMC: Let the height be full screen
//		lpMMI->ptMaxTrackSize.y /= 2; // Height can be half the screen height
	}
	else
	{
		// The appbar can't be more than half the width or height
		// of the screen when docked
		if (!IsEdgeTopOrBottom(GetState()))
			lpMMI->ptMaxTrackSize.x /= 2;
		
		if (!IsEdgeLeftOrRight(GetState()))
			lpMMI->ptMaxTrackSize.y /= 2;
	}

	CAppBar::OnGetMinMaxInfo(lpMMI);
}


/////////////////////////////////////////////////////////////////////////////


void CMagBar::OnSize(UINT nType, int cx, int cy)
{
	CAppBar::OnSize(nType, cx, cy);
	CalcZoomedSize();
}


/////////////////////////////////////////////////////////////////////////////


void CMagBar::OnTimer(UINT nIDEvent)
{
	if(eRefreshTimerId == nIDEvent)
	{
#if 0
		// JMC: HACK:
		m_ptZoom = CPoint(GetMessagePos());
#endif

		// TODO: Add your message handler code here and/or call default
		DrawZoomRect();
		DoTheZoomIn(NULL, m_fShowCrossHair = /*FALSE JMC*/TRUE); 
		m_fShowCrossHair = FALSE;
		DrawZoomRect();
		CAppBar::OnTimer(nIDEvent);
	}
}


/////////////////////////////////////////////////////////////////////////////


void CMagBar::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// This allows the user to task switch to ScreenX and then pan
	// the view around. The shift key makes it go faster, and the
	// control key makes it go all the way to the edge.
	// This also has the keyboard interface for magnification changes.
	// Use Page Up, Page Down, Home, and End
	switch (nChar)
	{
	case VK_UP: case VK_DOWN: case VK_LEFT: case VK_RIGHT:
		MoveView(nChar, GetKeyState(VK_SHIFT) & 0x8000, GetKeyState(VK_CONTROL) & 0x8000);
		break;
		
	case VK_PRIOR: case VK_NEXT: case VK_HOME: case VK_END:
		ZoomView(nChar); break;
	}

	CAppBar::OnKeyDown(nChar, nRepCnt, nFlags);
}


/////////////////////////////////////////////////////////////////////////////


void CMagBar::OnSettingChange(UINT uFlags, LPCTSTR lpszSection) {
	CAppBar::OnSettingChange(uFlags, lpszSection);
	
	// TODO: Add your message handler code here
	// Note: WM_SETTINGCHANGE is defined as WM_WININICHAGE in WinUser.h
	//if (gfAppExiting) break;

	// If someone else turns off the system-wide screen reader flag, turn it back on.
	// if ((uFlags == SPI_SETSCREENREADER) && (lpszSection != NULL))
	//	::SystemParametersInfo(SPI_SETSCREENREADER, TRUE, NULL, NULL);
}


/////////////////////////////////////////////////////////////////////////////


void CMagBar::OnContextMenu(CWnd* pWnd, CPoint point)
{
	// We cannot use MFC's Command Update Handlers for the menu items because 
	// they only work when you have a CFrameWnd-derived class.
	CMenu menu;
	menu.LoadMenu(MAKEINTRESOURCE(IDR_STATIONARY));
	menu.GetSubMenu(0)->TrackPopupMenu(0, 
		point.x, point.y, this, NULL);	
}

 
/////////////////////////////////////////////////////////////////////////////
// CAppBar command handlers


void CMagBar::OnSysCommand(UINT nID, LPARAM lParam)
{
	// JMC: This code is defective
#if 0
	if (nID == SC_CLOSE)
	{
		// We have to manually add this so that the dialog box closes when 
		// when the user clicks the close button (which appears in the top, right)
		// corner of the dialog box when it is floating).
		OnCancel();
	}
#endif
	
	CAppBar::OnSysCommand(nID, lParam);
}


/////////////////////////////////////////////////////////////////////////////


void CMagBar::OnCancel()
{
	// JMC: We don't want to do anything for 'OnCancel'.  We'll only let the user hit ALT-F4,
	// or use a close button
//   CAppBar::OnCancel();
}


/////////////////////////////////////////////////////////////////////////////


void CMagBar::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	
	// TODO: Add your message handler code here
	DrawZoomRect();
	if(m_bSizingOrMoving)
	{
		CRect rcClient;
		LOGFONT lf;
		HFONT hFont, hOld;
		LOGFONT lfSystem;

		memset( &lf, 0, sizeof(LOGFONT));

		GetClientRect(&rcClient);
		CBrush brush(RGB(255, 255, 128));
		dc.FillRect(&rcClient, &brush);
		dc.SetBkMode(TRANSPARENT);
		
		// Choose the correct font. 
		// lf.lfWeight = FW_BOLD;
		// lstrcpy( lf.lfFaceName , TEXT("MS Shell Dlg"));
		lf.lfHeight = -MulDiv( MagLevel()*2 + 14 , GetDeviceCaps(dc, LOGPIXELSY), 72);
		GetObject(GetStockObject(SYSTEM_FONT), sizeof(lfSystem), (LPVOID) &lfSystem);
		lf.lfCharSet = lfSystem.lfCharSet;

		hFont = ::CreateFontIndirect(&lf);
		hOld = (HFONT) dc.SelectObject(hFont);

		if ( GetState() == ABE_FLOAT )
			dc.ExtTextOut ( 10, 10, 0, &rcClient, m_strD, NULL );
		else
			dc.ExtTextOut ( 10, 10, 0, &rcClient, m_str, NULL );

		dc.SelectObject(hOld);
		DeleteObject(&lf);
	}
	else
		DoTheZoomIn(&dc, m_fShowCrossHair);
	DrawZoomRect();
	// Do not call CAppBar::OnPaint() for painting messages
}


//////////////////////////////// End of File //////////////////////////////////

/************************************************************************
* CalcZoomedSize
* Calculates some globals.  This routine needs to be called any
* time that the size of the app or the zoom factor changes.
************************************************************************/
VOID CMagBar::CalcZoomedSize()
{
	CRect rc;
	GetClientRect(&rc);
	m_cxZoomed = (rc.right  - 1)/ MagLevel() + 1;
	m_cyZoomed = (rc.bottom - 1)/ MagLevel() + 1;
	SIZE sz;
	sz.cx = m_cxZoomed;
	sz.cy = m_cyZoomed;
	// Best to set this same in the MagHook. 
	SetZoomRect(sz);
}

/************************************************************************
* DoTheZoomIn
* Does the actual paint of the zoomed image and the crosshair showing
* the location of the cursor (optional).
* Arguments:
*   HDC hdc - If not NULL, this hdc will be used to paint with.
*             If NULL, a dc for the apps window will be obtained.
*   BOOL fShowLocation - if TRUE, a crosshair will be drawn showing 
*                        the location of the point to zoom in on.               
************************************************************************/
VOID CMagBar::DoTheZoomIn(CDC* pdc, BOOL fShowCrossHair)
{
	if (!pdc)
	{
		// JMC: THIS IS A HACK SO WE DON'T CUE UP TOO MAY ZOOMS
		Invalidate(FALSE);
		return;
	}
	BOOL bCreatedOurOwnClientDC = FALSE;
	if (!pdc)
	{
		// If no DC is specifed, use a DC for our client area
		pdc = new CClientDC(this);
		bCreatedOurOwnClientDC = TRUE;
	}

	// We don't have the correct state information while we are sizing or zooming
	ASSERT(!m_bSizingOrMoving);

	HPALETTE hpalOld = NULL;
	CClientDC dcScreen(NULL);

	BOOL bShowCursor = g_pGetCursorInfo && !(GetAsyncKeyState(VK_SHIFT) & 0x8000) && !m_bForceHideCursor;


	// Calculate the location of the 'zoom' point.  m_ptZoom only contains the point
	// that we would like to zoom.  We must make sure that our zoom rect does not
	// go outside the screen.
	// We know that the width and hight of the zoom rect are going to be m_cxZoomed
	// and m_cyZoomed, so we force ptZoomAdjusted to be >= m_cxZoomed/2 from the left
	// and 'screen width' - m_cxZoomed + m_cxZoomed/2 from the right
	// We must do the same calculation for the 'y'
	// Since m_cxZoomed may be odd, we have to be careful when we look at m_xcZoomed / 2.
	CPoint ptZoomAdjusted;
	int cxScreen = GetSystemMetrics(SM_CXVIRTUALSCREEN);
	// If CXVIRTUALSCREEN isn't there (95), use CXSCREEN instead...
	if( cxScreen == 0 )
	{
        // use old Win95 method
		ptZoomAdjusted.x = ForceInRange((int) m_ptZoom.x, m_cxZoomed / 2, GetSystemMetrics(SM_CXSCREEN) - m_cxZoomed + (m_cxZoomed / 2));
		ptZoomAdjusted.y = ForceInRange((int) m_ptZoom.y, m_cyZoomed / 2, GetSystemMetrics(SM_CYSCREEN) - m_cyZoomed + (m_cyZoomed / 2));
	}
	else
	{
		// Adjust for Multimonitor
		ptZoomAdjusted.x = ForceInRange(
                    (int) m_ptZoom.x
                    , m_cxZoomed / 2 + GetSystemMetrics(SM_XVIRTUALSCREEN)
                    , GetSystemMetrics(SM_CXVIRTUALSCREEN) + GetSystemMetrics(SM_XVIRTUALSCREEN) - m_cxZoomed + (m_cxZoomed / 2));
		ptZoomAdjusted.y = ForceInRange(
                    (int) m_ptZoom.y
                    , m_cyZoomed / 2 + GetSystemMetrics(SM_YVIRTUALSCREEN)
                    , GetSystemMetrics(SM_CYVIRTUALSCREEN) + GetSystemMetrics(SM_YVIRTUALSCREEN) - m_cyZoomed + (m_cyZoomed / 2));
	
    }	


	CPoint ptZoomRectTopLeft(ptZoomAdjusted.x - m_cxZoomed/2, ptZoomAdjusted.y - m_cyZoomed/2);
	CSize sizeZoomRect(m_cxZoomed, m_cyZoomed);
	// Always move the zoom rect

	// Get the cursor bitmaps
	ICONINFO ii;
	ZeroMemory(&ii, sizeof(ii));
	CURSORINFO ci;
	ZeroMemory(&ci, sizeof(ci));
    BITMAP cbm;
    ZeroMemory(&cbm, sizeof(cbm));

    //
    // Get the dimensions of the current cursor.  We'll draw it later.
    //
	if(bShowCursor)
	{
		ci.cbSize = sizeof(ci);

		// JMC: HACK - WE NEED TO MAKE SURE THIS IS THE RIGHT VERSION OF GetCursorInfo
		g_pGetCursorInfo(&ci);

		if(ci.hCursor)
			GetIconInfo(ci.hCursor, &ii);

        if (ii.hbmColor != NULL) {
            GetObject(ii.hbmColor, sizeof(BITMAP), &cbm);
        } else if (ii.hbmMask != NULL) {
            //
            // This is an old-style cursor where the mask is actually two
            // bitmaps stacked on top of each other.
            //
            GetObject(ii.hbmMask, sizeof(BITMAP), &cbm);
            cbm.bmHeight /= 2;
        } else {
			bShowCursor = FALSE; // We do not have the cursor info
        }
	}

	// Clear background - this prevents 'holes' where a bitblt includes
	// an area of the virtual screen which is not actually on any
	// monitor (can happen when using a staggered multimon setup).
	COLORREF clrrefOld = m_dcOffScreen.SetBkColor( RGB( 0, 0, 255 ) );
	m_dcOffScreen.ExtTextOut( 0, 0, ETO_OPAQUE, 
		CRect(0, 0, sizeZoomRect.cx, sizeZoomRect.cy ), NULL, 0, NULL );
	m_dcOffScreen.SetBkColor( clrrefOld );

    // Allow popup menus to be zoomed in our window.  The only way to do this
    // cleanly is to only show what's visible in the zoom window and clip what
    // is outside of it.

 	CRect rcZoom( ptZoomRectTopLeft.x
                , ptZoomRectTopLeft.y
                , ptZoomRectTopLeft.x + sizeZoomRect.cx
                , ptZoomRectTopLeft.y + sizeZoomRect.cy);
    CRect rcOverlapped;
	CRect rcWindow;
	GetClientRect(&rcWindow);
	ClientToScreen(&rcWindow);
 	rcOverlapped.IntersectRect(&rcWindow, &rcZoom);
    CRect rcMenu;           // hold coordinates of our popup menus
    CPoint ptOffset(0,0);   // offset of top/left real menu and top/left zoomed menu
    GetPopupInfo((LPRECT)rcMenu);

	// If the focus is not w/in the magnify window...
    if (rcMenu.IsRectEmpty())
    {
        //
	    // Copy the screen to the offscreen bitmap if that is where focus is
        //
 	    m_dcOffScreen.BitBlt(
                      0, 0
                    , sizeZoomRect.cx
                    , sizeZoomRect.cy
                    , &dcScreen
                    , ptZoomRectTopLeft.x
                    , ptZoomRectTopLeft.y
                    , CAPTUREBLT | (InvertColors() ? NOTSRCCOPY : SRCCOPY));

		// If there is overlap with magnify window then show that area as gray

		if(!rcOverlapped.IsRectEmpty())
		{
			COLORREF clrrefMagWindowDefault = RGB(128, 128, 128);
			CRect rcTemp;
			rcTemp.left = (rcOverlapped.left - ptZoomRectTopLeft.x);
			rcTemp.top = (rcOverlapped.top - ptZoomRectTopLeft.y);
			rcTemp.right = (rcOverlapped.right - ptZoomRectTopLeft.x);
			rcTemp.bottom = (rcOverlapped.bottom - ptZoomRectTopLeft.y);

			// Fill in the rest of the area with our gray color
			COLORREF clrrefOld = m_dcOffScreen.SetBkColor(clrrefMagWindowDefault);
			m_dcOffScreen.ExtTextOut(0, 0, ETO_OPAQUE, &rcTemp, NULL, 0, NULL);
			m_dcOffScreen.SetBkColor(clrrefOld);
		}
    }
    else
	{
        //
        // Focus is w/in the magnifier window so only show graphics w/in that rect
        //
		COLORREF clrrefMagWindowDefault = RGB(128, 128, 128);
		CRect rcTemp(0, 0, sizeZoomRect.cx, sizeZoomRect.cy);

		// Fill in the area with our gray color
		COLORREF clrrefOld = m_dcOffScreen.SetBkColor(clrrefMagWindowDefault);
		m_dcOffScreen.ExtTextOut(0, 0, ETO_OPAQUE, &rcTemp, NULL, 0, NULL);
		m_dcOffScreen.SetBkColor(clrrefOld);

        // Add popup menu if it is there but always center in zoom window

        if (!rcMenu.IsRectEmpty() && MagLevel() > 1)
        {
		    CPoint ptMenuDest;
            CSize sizeMenu(rcMenu.right - rcMenu.left, rcMenu.bottom - rcMenu.top);

            UINT uState = GetState();
            if (uState == ABE_TOP || uState == ABE_BOTTOM || uState == ABE_FLOAT)
            {
                // center based on left/right
                ptMenuDest.x = sizeZoomRect.cx/2 - sizeMenu.cx/2;
                ptMenuDest.y = rcMenu.top - ptZoomRectTopLeft.y;
                ptOffset.x = ptZoomRectTopLeft.x + ptMenuDest.x - rcMenu.left;
            }
            else
            {
                // center based on top/bottom
                ptMenuDest.x = rcMenu.left - ptZoomRectTopLeft.x;
                ptMenuDest.y = sizeZoomRect.cy/2 - sizeMenu.cy/2;
                ptOffset.y = ptZoomRectTopLeft.y + ptMenuDest.y - rcMenu.top;
            }

            // Blt the popup menu to the off-screen copy
		    m_dcOffScreen.BitBlt(
                          ptMenuDest.x
                        , ptMenuDest.y
                        , sizeMenu.cx
                        , sizeMenu.cy
                        , &dcScreen
                        , rcMenu.left
                        , rcMenu.top
                        , CAPTUREBLT | (InvertColors() ? NOTSRCCOPY : SRCCOPY));
        }
	}
	
	// Draw the icon of the cursor on the off screen bitmap
	CRect rcCursor(ci.ptScreenPos.x
                 , ci.ptScreenPos.y
                 , ci.ptScreenPos.x + cbm.bmWidth
                 , ci.ptScreenPos.y + cbm.bmHeight);

	rcOverlapped.IntersectRect(&rcCursor, &rcZoom);
	if(bShowCursor && !rcOverlapped.IsRectEmpty() && MagLevel() > 1)
	{
		CPoint ptIconDest(ci.ptScreenPos.x - ptZoomRectTopLeft.x - ii.xHotspot + ptOffset.x
                        , ci.ptScreenPos.y - ptZoomRectTopLeft.y - ii.yHotspot + ptOffset.y);
        //
        // Copy the cursor to the offscreen bitmap
        //
        DrawIconEx(HDC(m_dcOffScreen), ptIconDest.x, ptIconDest.y, ci.hCursor, cbm.bmWidth, cbm.bmHeight, 0, NULL, DI_NORMAL);
    }

	if(ii.hbmMask)
		DeleteObject(ii.hbmMask);
	if(ii.hbmColor)
		DeleteObject(ii.hbmColor);

	//
	// Copy the off screen bitmap back to the screen.
	//

	CPalette* ppalOld = pdc->SelectPalette(&m_hpalPhysical, FALSE);
	pdc->RealizePalette();
	pdc->SetStretchBltMode(COLORONCOLOR);

	// Stretch the offscreen bitmap to the screen

	pdc->StretchBlt(0, 0
                  , MagLevel() * sizeZoomRect.cx
                  , MagLevel() * sizeZoomRect.cy
                  , &m_dcOffScreen
                  , 0, 0
                  , sizeZoomRect.cx
                  , sizeZoomRect.cy
                  , SRCCOPY);

	pdc->SelectPalette(ppalOld, FALSE);

	if(bCreatedOurOwnClientDC) // we need to delete this DC
		delete pdc;
}

/************************************************************************
* MoveView
* This function moves the current view around.
* Arguments:
*   INT nDirectionCode - Direction to move.  Must be VK_UP, VK_DOWN,
*                        VK_LEFT or VK_RIGHT.
*   BOOL fFast         - TRUE if the move should jump a larger increment.
*                        If FALSE, the move is just one pixel.
*   BOOL fPeg          - If TRUE, the view will be pegged to the screen
*                        boundary in the specified direction.  This overides
*                        the fFast parameter.
************************************************************************/
VOID CMagBar::MoveView(INT nDirectionCode,BOOL fFast,BOOL fPeg)
{
	INT delta;
	
	if (fFast)
		delta = 8;   // Move by 8 pixels at a time instead of 1
	else
		delta = 1;
	int cxScreen = GetSystemMetrics(SM_CXSCREEN);
	int cyScreen = GetSystemMetrics(SM_CYSCREEN);

	switch (nDirectionCode)
	{
	case VK_UP:
		if (fPeg)
			m_ptZoom.y = m_cyZoomed / 2;
		else
			m_ptZoom.y -= delta;
		m_ptZoom.y = ForceInRange((int) m_ptZoom.y, 0, cyScreen);
		break;
		
	case VK_DOWN:
		if (fPeg)
			m_ptZoom.y = cyScreen - (m_cyZoomed / 2);
		else
			m_ptZoom.y += delta;
		m_ptZoom.y = ForceInRange((int) m_ptZoom.y, 0, cyScreen);
		break;
		
	case VK_LEFT:
		if (fPeg)
			m_ptZoom.x = m_cxZoomed / 2;
		else
			m_ptZoom.x -= delta;
		m_ptZoom.x = ForceInRange((int) m_ptZoom.x, 0, cxScreen);
		break;
		
	case VK_RIGHT:
		if (fPeg)
			m_ptZoom.x = cxScreen - (m_cxZoomed / 2);
		else
			m_ptZoom.x += delta;
		m_ptZoom.x = ForceInRange((int) m_ptZoom.x, 0, cxScreen);
		break;
	}
	DrawZoomRect();
	DoTheZoomIn(NULL, /*FALSE JMC*/TRUE);
	DrawZoomRect();
}

/************************************************************************
* DrawZoomRect
* This function draws the tracking rectangle.  The size and shape of
* the rectangle will be proportional to the size and shape of the
* app's client, and will be affected by the zoom factor as well.
************************************************************************/
VOID CMagBar::DrawZoomRect()
{
	CRect rc;
	int x, y;
	
	if (!m_fShowZoomRect) return;
	
	int cxScreen = GetSystemMetrics(SM_CXSCREEN);
	int cyScreen = GetSystemMetrics(SM_CYSCREEN);
	x = ForceInRange((int) m_ptZoom.x, m_cxZoomed / 2, cxScreen - (m_cxZoomed / 2));
	y = ForceInRange((INT) m_ptZoom.y, m_cyZoomed / 2, cyScreen - (m_cyZoomed / 2));
	
	rc.SetRect(x - m_cxZoomed / 2, y - m_cyZoomed / 2, m_cxZoomed, m_cyZoomed);
	rc.InflateRect(1, 1);
	CClientDC dcScreen(NULL);
	dcScreen.PatBlt(rc.left,      rc.top,        rc.right - rc.left,    1,                     DSTINVERT);
	dcScreen.PatBlt(rc.left,      rc.bottom,     1,                     -(rc.bottom - rc.top), DSTINVERT);
	dcScreen.PatBlt(rc.right - 1, rc.top,        1,                     rc.bottom - rc.top,    DSTINVERT);
	dcScreen.PatBlt(rc.right,     rc.bottom - 1, -(rc.right - rc.left), 1,                     DSTINVERT);
}


/************************************************************************
* ZoomView
* This just redraws at the new zoom level, taking a key as input
* Arguments:
*	WPARAM	ZoomChangeCode - how to change the zoom. must be VK_NEXT,
*							 VK_PRIOR,VK_HOME, or VK_END.
************************************************************************/
VOID CMagBar::ZoomView (WPARAM ZoomChangeCode)
{
#if 0
	switch (ZoomChangeCode)
	{
	case VK_NEXT:  m_nZoom++; break;
	case VK_PRIOR: m_nZoom--; break;
	case VK_HOME:  m_nZoom = CMagnifyDlg::nMinZoom; break;
	case VK_END:   m_nZoom = CMagnifyDlg::nMaxZoom; break;
	}

	m_nZoom = ForceInRange(m_nZoom, CMagnifyDlg::nMinZoom, CMagnifyDlg::nMaxZoom);
#endif
	DrawZoomRect();
	CalcZoomedSize();
	DoTheZoomIn(NULL, m_fShowCrossHair);
	DrawZoomRect();
}



VOID CMagBar::CopyToClipboard()
{
	CClientDC dcSrc(this);
	
	if (OpenClipboard())
	{
		CRect rc;
		GetClientRect(&rc);
		// JMC: Don't use a CBitmap because we'll destroy it when we loose scope
		HBITMAP hbm = CreateCompatibleBitmap(dcSrc.GetSafeHdc(), rc.Width(), rc.Height());
		CDC dcDst;
		dcDst.CreateCompatibleDC(&dcSrc);

		// Calculate the dimensions of the bitmap and convert them to 
		// tenths of a millimeter for setting the size with the SetBitmapDimensionEx
		// call.  This allows programs like WinWord to retrieve the bitmap and know 
		// what size to display it as.
		const DWORD dwMM10PERINCH = 254; // Tenths of a millimeter per inch.
		::SetBitmapDimensionEx(hbm,
			(rc.Width()  * dwMM10PERINCH) / (DWORD) dcSrc.GetDeviceCaps(LOGPIXELSX), 
			(rc.Height() * dwMM10PERINCH) / (DWORD) dcSrc.GetDeviceCaps(LOGPIXELSY), 
			NULL);

		CBitmap *pbmOld = dcDst.SelectObject(CBitmap::FromHandle(hbm));
		dcDst.BitBlt(0, 0, rc.Width(), rc.Height(), &dcSrc, rc.left, rc.top, 
			/*InvertColors() ? NOTSRCCOPY : SRCCOPY*/ SRCCOPY); // JMC: Always copy it as it is on screen

		EmptyClipboard();
		SetClipboardData(CF_BITMAP, hbm);
		CloseClipboard();
		dcDst.SelectObject(pbmOld);
	} else ASSERT(FALSE);
}

void CMagBar::OnAppbarCopyToClipboard()
{
	// TODO: Add your command handler code here
	CopyToClipboard();	
}

void CMagBar::OnClose()
{
	// TODO: Add your message handler code here and/or call default
	m_pwndSettings->PostMessage(WM_CLOSE);
	// JMC: Let the options dialog close us.
//	DestroyWindow();	
//	CAppBar::OnClose();
}

// JMC: HACK - Remove this when it is defined correctly in Winuser.h
#define IDC_HAND_TEMPxxx       MAKEINTRESOURCE(32649)

BOOL CMagBar::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
    // get whether the window is selected with the mouse
	BOOL fPrimaryMouseBtnDown = 
		(GetAsyncKeyState(GetSystemMetrics(SM_SWAPBUTTON) 
		? VK_RBUTTON : VK_LBUTTON) & 0x8000) != 0;
	
	// If they are over the client, or the mouse button is down over the caption
	// (ie: when they are dragging the window by its client area), show the 'hand'
	if(HTCLIENT == nHitTest || fPrimaryMouseBtnDown)
	{
		// JMC: TODO: For NT5/Memphis, we should be able to use USER's new IDC_HAND
        // Try NT5/98 cursor first...
        HCURSOR hCur = LoadCursor(NULL, IDC_HAND_TEMPxxx);
        // If that fails, load our own hand cursor...
        if( ! hCur )
            hCur = AfxGetApp()->LoadCursor(IDC_CUSTOM_HAND);
        SetCursor( hCur );

		return TRUE;
	}
	return CAppBar::OnSetCursor(pWnd, nHitTest, message);
}

BOOL CMagBar::PreTranslateMessage(MSG* pMsg) 
{
	// JMC: HACK TO GET THIS TO WORK WITH MouseHook
	switch(pMsg->message)
	{
	case WM_MOUSEMOVE:
	case WM_NCMOUSEMOVE:
		FakeCursorMove(pMsg->pt);
		break;
	default:
		break;
	}
	return CAppBar::PreTranslateMessage(pMsg);
}


LRESULT CMagBar::OnEnterSizeMove(WPARAM wParam, LPARAM lParam)
{
	Invalidate();
	m_bSizingOrMoving = TRUE;
	return CAppBar::OnEnterSizeMove(wParam, lParam);
}


/////////////////////////////////////////////////////////////////////////////


LRESULT CMagBar::OnExitSizeMove(WPARAM wParam, LPARAM lParam)
{
	m_bSizingOrMoving = FALSE;
	SetupOffScreenDC();
	return CAppBar::OnExitSizeMove(wParam, lParam);
}

void CMagBar::SetupOffScreenDC()
{
	CalcZoomedSize();
	HDC hdc = ::GetDC(m_hWnd);
	PVOID pBits = NULL;;
//	m_hbmOffScreen = CreateCompatibleDIB(hdc, NULL, m_cxZoomed, m_cyZoomed, &pBits);

	// We don't need to 'Delete' the old bitmap because it is deleted right after
	// our call to SelectObject
	m_hbmOffScreen = CreateCompatibleBitmap(hdc, m_cxZoomed, m_cyZoomed);
	::ReleaseDC(m_hWnd, hdc);
	CBitmap *pbmOld = m_dcOffScreen.SelectObject(CBitmap::FromHandle(m_hbmOffScreen));
	if(pbmOld)
		pbmOld->DeleteObject();
}

void CMagBar::OnAppbarExit() 
{
	// JMC: This will close us
	m_pwndSettings->PostMessage(WM_CLOSE);
}

void CMagBar::OnAppbarOptions() 
{
	m_pwndSettings->ShowWindow(SW_RESTORE);
	m_pwndSettings->SetForegroundWindow();
	
}

void CMagBar::OnAppbarHide() 
{
	m_pwndSettings->SetStationaryHidden();
}

void CMagBar::OnSysColorChange()
{
	SetupOffScreenDC();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\magbar.h ===
/******************************************************************************
Module name: MagBar.h
Written by:  Jeffrey Richter
Purpose: 	 ShellRun class description file.
******************************************************************************/


#if !defined(AFX_MAGBAR_H__B3056D65_965F_11D0_B287_00A0C90DA742__INCLUDED_)
#define AFX_MAGBAR_H__B3056D65_965F_11D0_B287_00A0C90DA742__INCLUDED_

#include "AppBar.h"
#include "ZoomRect.h"


#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMagnifyDlg;


class CMagBar : public CAppBar {
public:
	void ForceHideCursor(BOOL bForceHideCursor)
	{
		m_bForceHideCursor = bForceHideCursor;
	}
protected:	// Internal implementation state variables
	BOOL m_bForceHideCursor;
	// CSRBar's class-specific constants
	static const TCHAR m_szRegSubkey[];
	CSize m_szMinTracking;	// The minimum size of the client area
	CDC m_dcOffScreen;
	HBITMAP m_hbmOffScreen;
	BOOL m_bSizingOrMoving;
	CZoomRect m_wndZoomRect;

	DWORD m_dwLastMouseMoveTrack;
    POINT m_ptLastMousePos;

public:	// Public member functions
	CMagBar(CMagnifyDlg* pwndSettings);

protected:	// Internal implementation functions
	void HideFloatAdornments (BOOL fHide);

protected:	// Overridable functions
	void OnAppBarStateChange (BOOL fProposed, UINT uStateProposed);

// Dialog Data
	//{{AFX_DATA(CMagBar)
	enum { IDD = IDD_STATIONARY };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMagBar)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	 // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void SetupOffScreenDC();
	void CMagBar::OnCancel();
	LRESULT OnEventXMove(WPARAM wParam, LPARAM lParam, BOOL fLastShowPos);
	LRESULT OnEventCaretMove(WPARAM wParam, LPARAM lParam);
	LRESULT OnEventFocusMove(WPARAM wParam, LPARAM lParam);
	LRESULT OnEventMouseMove(WPARAM wParam, LPARAM lParam);
	LRESULT OnEventForceMove(WPARAM wParam, LPARAM lParam);

	// Generated message map functions
	//{{AFX_MSG(CMagBar)
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnDestroy();
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg void OnAppbarCopyToClipboard();
	afx_msg void OnClose();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnAppbarExit();
	afx_msg void OnAppbarOptions();
	afx_msg void OnAppbarHide();
	afx_msg void OnSysColorChange();
	//}}AFX_MSG
	afx_msg LRESULT OnEnterSizeMove(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnExitSizeMove(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

private:
	CPalette m_hpalPhysical;
	BOOL m_fShowCrossHair;
	int m_cxZoomed, m_cyZoomed;
	POINT m_ptZoom;
	BOOL m_fShowZoomRect;	// Persistent: true if we show (via DrawZoomRect) where the zoomed area is.
	CDC m_dcMem;

private:
	CMagnifyDlg* m_pwndSettings;
	UINT MagLevel();
	BOOL TrackText();
	BOOL TrackSecondaryFocus();
	BOOL TrackCursor();
	BOOL TrackFocus();
	BOOL InvertColors();
	CString m_str;
	CString m_strD;
	
		
	enum { eRefreshTimerId = 55, eRefreshTimerInterval = 500 /* milliseconds */};

	VOID DoTheZoomIn(CDC* pdc, BOOL fShowCrossHair);
	VOID ZoomView (WPARAM ZoomChangeCode);
	VOID MoveView(INT nDirectionCode, BOOL fFast, BOOL fPeg);
	VOID DrawZoomRect();
	VOID CalcZoomedSize();

public:
	VOID ZoomChanged() {CalcZoomedSize();SetupOffScreenDC();}
	VOID CopyToClipboard();
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAGBAR_H__B3056D65_965F_11D0_B287_00A0C90DA742__INCLUDED_)


//////////////////////////////// End of File //////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\numedit.cpp ===
// NumEdit.cpp : implementation file
//

#include "stdafx.h"
#include "magnify.h"
#include "NumEdit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNumberEdit

CNumberEdit::CNumberEdit()
{
}

CNumberEdit::~CNumberEdit()
{
}


BEGIN_MESSAGE_MAP(CNumberEdit, CEdit)
	//{{AFX_MSG_MAP(CNumberEdit)
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNumberEdit message handlers

void CNumberEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	if(nChar >= '1' && nChar <= '9')	
	{
		TCHAR sz[2];
		sz[0] = (TCHAR)nChar;
		sz[1] = 0;
		SetWindowText(sz);
	}
//	CEdit::OnChar(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\magnify.cpp ===
// Magnify.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "Magnify.h"
#include "MagDlg.h"
#include <ole2.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static BOOL  AssignDesktop(LPDWORD desktopID, LPTSTR pname);
static BOOL InitMyProcessDesktopAccess(VOID);
static HWINSTA origWinStation = NULL;
static HWINSTA userWinStation = NULL;
#define DESKTOP_ACCESSDENIED 0
#define DESKTOP_DEFAULT      1
#define DESKTOP_SCREENSAVER  2
#define DESKTOP_WINLOGON     3
#define DESKTOP_TESTDISPLAY  4
#define DESKTOP_OTHER        5

// For Link Window
EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;

/////////////////////////////////////////////////////////////////////////////
// CMagnifyApp

BEGIN_MESSAGE_MAP(CMagnifyApp, CWinApp)
	//{{AFX_MSG_MAP(CMagnifyApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
    
// YX [ 99-10-12
// Commenting out to prevent any problems with unwanted help
//	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
// ] YX
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMagnifyApp construction

CMagnifyApp::CMagnifyApp()
{
    DWORD desktopID;
    TCHAR name[300];
    InitMyProcessDesktopAccess();
    AssignDesktop(&desktopID,name);
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMagnifyApp object
// For UM


CMagnifyApp theApp;


/////////////////////////////////////////////////////////////////////////////
// CMagnifyApp initialization

BOOL CMagnifyApp::InitInstance()
{   
    

	SCODE sc = CoInitialize(NULL);

	if (FAILED(sc))
	{
		// warn about non-NULL success codes
		TRACE(__TEXT("Warning: OleInitialize failed"));
		return FALSE;
	}

	// Make sure we are not already running
	HANDLE hEvent = CreateEvent(NULL, TRUE, TRUE, __TEXT("MSMagnifierAlreadyExistsEvent"));
	if(!hEvent || ERROR_ALREADY_EXISTS == GetLastError())
	{
		CloseHandle(hEvent);
		return FALSE;
	}

	InitCommonControls();

	// for the Link Window in finish page...
	LinkWindow_RegisterClass();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

    // UM
	
    CMagnifyDlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	CoUninitialize();

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

/*LRESULT CMagnifyApp::OnDeskTopChanged(WPARAM wParam, LPARAM lParam) 
{
    ::MessageBox(NULL, NULL, NULL, MB_OK|MB_ICONSTOP);

    return 0;
}




int CMagnifyApp::Run() 
{
    MSG msg;

	// TODO: Add your specialized code here and/or call the base class
	while ((GetMessage(&msg,NULL,0,0)))//support UM: you need to get PostThreadMessage
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
        if (msg.message == uDeskMag)
	    {
            ASSERT(FALSE);
            ::MessageBox(NULL, NULL, NULL, MB_OK|MB_ICONSTOP);
        }
    }

    ASSERT(FALSE);

    return 0;
	
	//return CWinApp::Run();
}*/


// AssignDeskTop() For UM
static BOOL  AssignDesktop(LPDWORD desktopID, LPTSTR pname)
{
    HDESK hdesk;
    TCHAR name[300];
    DWORD nl;
    *desktopID = DESKTOP_ACCESSDENIED;
    hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (!hdesk)
    {
        // OpenInputDesktop will mostly fail on "Winlogon" desktop
        hdesk = OpenDesktop(__TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
        if (!hdesk)
            return FALSE;
    }
    GetUserObjectInformation(hdesk,UOI_NAME,name,300,&nl);
    if (pname)
        _tcscpy(pname,name);
    if (!_tcsicmp(name, __TEXT("Default")))
        *desktopID = DESKTOP_DEFAULT;
    else if (!_tcsicmp(name, __TEXT("Winlogon")))
        *desktopID = DESKTOP_WINLOGON;
    else if (!_tcsicmp(name, __TEXT("screen-saver")))
        *desktopID = DESKTOP_SCREENSAVER;
    else if (!_tcsicmp(name, __TEXT("Display.Cpl Desktop")))
        *desktopID = DESKTOP_TESTDISPLAY;
    else
        *desktopID = DESKTOP_OTHER;
    CloseDesktop(GetThreadDesktop(GetCurrentThreadId()));
    SetThreadDesktop(hdesk);
    return TRUE;
}// AssignDesktop


static BOOL InitMyProcessDesktopAccess(VOID)
{
  origWinStation = GetProcessWindowStation();
  userWinStation = OpenWindowStation(_TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);
  if (!userWinStation)
    return FALSE;
  SetProcessWindowStation(userWinStation);
  return TRUE;
}// InitMyProcessDesktopAccess
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\magnify.h ===
// Magnify.h : main header file for the MAGNIFY application
//

#if !defined(AFX_MAGNIFY_H__C7D0DB66_D691_11D0_AD59_00C04FC2A136__INCLUDED_)
#define AFX_MAGNIFY_H__C7D0DB66_D691_11D0_AD59_00C04FC2A136__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CMagnifyApp:
// See Magnify.cpp for the implementation of this class
//

class CMagnifyApp : public CWinApp
{
public:
	CMagnifyApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMagnifyApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMagnifyApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAGNIFY_H__C7D0DB66_D691_11D0_AD59_00C04FC2A136__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\numedit.h ===
#if !defined(AFX_NUMEDIT_H__CD9E16EA_1CDC_11D1_B6B9_0060083316C7__INCLUDED_)
#define AFX_NUMEDIT_H__CD9E16EA_1CDC_11D1_B6B9_0060083316C7__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// NumEdit.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNumberEdit window

class CNumberEdit : public CEdit
{
// Construction
public:
	CNumberEdit();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNumberEdit)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNumberEdit();

	// Generated message map functions
protected:
	//{{AFX_MSG(CNumberEdit)
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NUMEDIT_H__CD9E16EA_1CDC_11D1_B6B9_0060083316C7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\magdlg.cpp ===
// MagDlg.cpp : implementation file
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//  

#include "stdafx.h"
#include "Magnify.h"
#include "AppBar.h"
#include "MagBar.h"
#include "MagDlg.h"
#include "Registry.h"
#include "Desktop.h"
#include "w95trace.c"

#include <htmlhelp.h>
#include "..\Mag_Hook\Mag_Hook.h" // for WM_EVENT_MOUSEMOVE
#include "DeskSwitch.c"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// JMC: HACK - REMOVE
const TCHAR m_szRegSubkey[] = __TEXT("Software\\Microsoft\\Magnify");
const TCHAR g_szSaveKey[]				= __TEXT("Magnify");
const TCHAR m_szMagSubkey[] = __TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
const TCHAR g_szSaveRoam[]				= __TEXT("Magnify.exe");

// Location of registry entries
// NOTE: If you change the default hot keys, you must change the 'Ver0' to 'Ver1', 'Ver2', etc.
// Otherwise, people with a new copy of the app will continue to use the old hot keys.
const TCHAR g_szRegStationaryTrackText[]				= __TEXT("StationaryTrackText");
const TCHAR g_szRegStationaryTrackSecondaryFocus[]		= __TEXT("StationaryTrackSecondaryFocus");
const TCHAR g_szRegStationaryTrackCursor[]				= __TEXT("StationaryTrackCursor");
const TCHAR g_szRegStationaryTrackFocus[]				= __TEXT("StationaryTrackFocus");
const TCHAR g_szRegStationaryInvertColors[]				= __TEXT("StationaryInvertColors");
const TCHAR g_szRegHotKeyModifiersToggleMouseTracking[]	= __TEXT("HotKeyVer0ModifiersToggleMouseTracking");
const TCHAR g_szRegHotKeyVirtKeyToggleMouseTracking[]	= __TEXT("HotKeyVer0VirtKeyToggleMouseTracking");
const TCHAR g_szRegHotKeyModifiersToggleInvertColors[]	= __TEXT("HotKeyVer0ModifiersToggleInvertColors");
const TCHAR g_szRegHotKeyVirtKeyToggleInvertColors[]	= __TEXT("HotKeyVer0VirtKeyToggleInvertColors");
const TCHAR g_szRegHotKeyModifiersCopyToClipboard[]		= __TEXT("HotKeyVer0ModifiersCopyToClipboard");
const TCHAR g_szRegHotKeyVirtKeyCopyToClipboard[]		= __TEXT("HotKeyVer0VirtKeyCopyToClipboard");
const TCHAR g_szRegHotKeyModifiersCopyToClipboard2[]	= __TEXT("HotKeyVer0ModifiersCopyToClipboard2");
const TCHAR g_szRegHotKeyVirtKeyCopyToClipboard2[]		= __TEXT("HotKeyVer0VirtKeyCopyToClipboard2");
const TCHAR g_szRegHotKeyModifiersHideMagnifier[]		= __TEXT("HotKeyVer0ModifiersHideMagnifier");
const TCHAR g_szRegHotKeyVirtKeyHideMagnifier[]			= __TEXT("HotKeyVer0VirtKeyHideMagnifier");
const TCHAR g_szRegStationaryMagLevel[]					= __TEXT("StationaryMagLevel");
const TCHAR g_szRegStationaryStartMinimized[]			= __TEXT("StationaryStartMinimized");
const TCHAR g_szRegUseHotKeys[]			                = __TEXT("UseHotKeys");
const TCHAR g_szRegShowWarning[]			            = __TEXT("ShowWarning");

#ifndef SPI_GETFONTSMOOTHINGTYPE
// pre-whistler define
#define SPI_GETFONTSMOOTHINGTYPE  116
#define SPI_SETFONTSMOOTHINGTYPE  117
#endif

// Hotkey identifiers for RegisterHotKey
#define HKID_ZOOMUP               1
#define HKID_ZOOMDOWN             2
#define HKID_TOGGLEMOUSETRACKING  3
#define HKID_TOGGLEINVERTCOLORS   4
#define HKID_COPYTOCLIPBOARD      5
#define HKID_COPYTOCLIPBOARD2     6
#define HKID_HIDEMAGNIFIER        7

#define WM_USER_DESKTOPSWITCH     WM_APP + 30
#define WM_DELAYEDMINIMIZE        WM_APP

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult); 
    virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CAboutDlg::PreTranslateMessage(MSG* pMsg) 
{
	// JMC: HACK TO GET THIS TO WORK WITH MouseHook
	switch(pMsg->message)
	{
	case WM_MOUSEMOVE:
	case WM_NCMOUSEMOVE:
		FakeCursorMove(pMsg->pt);
		break;
	default:
		break;
	}
	
	return CDialog::PreTranslateMessage(pMsg);
}
BOOL CAboutDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// disable the URL link if running in secure mode
    if (RunSecure(GetDesktop()))
    {
        GetDlgItem(IDC_ENABLEWEB2)->EnableWindow(FALSE);
    }
	return TRUE;  // return TRUE  unless you set the focus to a control
}

BOOL CAboutDlg::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	INT idCtl		= (INT)wParam;
	LPNMHDR pnmh	= (LPNMHDR)lParam;
	switch ( pnmh->code)
	{
		case NM_RETURN:
		case NM_CLICK:
		if ( idCtl == IDC_ENABLEWEB2 && !RunSecure(GetDesktop()) )
		{
			CString webAddr;
			webAddr.LoadString(IDS_ENABLEWEB);
			ShellExecute(m_hWnd, TEXT("open"), TEXT("iexplore.exe"), webAddr, NULL, SW_SHOW); 
		}
		break;
	}
	return TRUE;
}

class CWarnDlg : public CDialog
{
public:
	CWarnDlg();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	BOOL m_warning;
// Dialog Data
	//{{AFX_DATA(CWarnDlg)
	enum { IDD = IDD_WARNING };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWarnDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult); 
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CWarnDlg)
	afx_msg void OnCheckShowWarning();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CWarnDlg::CWarnDlg() : CDialog(CWarnDlg::IDD)
{
	//{{AFX_DATA_INIT(CWarnDlg)
	//}}AFX_DATA_INIT
	m_warning = 0;
}

void CWarnDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWarnDlg)
		DDX_Check(pDX, IDC_SHOW, m_warning);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWarnDlg, CDialog)
	//{{AFX_MSG_MAP(CWarnDlg)
	ON_BN_CLICKED(IDC_SHOW, OnCheckShowWarning)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CWarnDlg::PreTranslateMessage(MSG* pMsg) 
{
	// JMC: HACK TO GET THIS TO WORK WITH MouseHook
	switch(pMsg->message)
	{
	case WM_MOUSEMOVE:
	case WM_NCMOUSEMOVE:
		FakeCursorMove(pMsg->pt);
		break;
	default:
		break;
	}
	
	return CDialog::PreTranslateMessage(pMsg);
}

BOOL CWarnDlg::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	INT idCtl		= (INT)wParam;
	LPNMHDR pnmh	= (LPNMHDR)lParam;
	switch ( pnmh->code)
	{
		case NM_RETURN:
		case NM_CLICK:
		if ( idCtl == IDC_ENABLEWEB && !RunSecure(GetDesktop()) )
		{
			CString webAddr;
			webAddr.LoadString(IDS_ENABLEWEB);
			ShellExecute(m_hWnd, TEXT("open"), TEXT("iexplore.exe"), webAddr, NULL, SW_SHOW); 
		}
		break;
	}
	return TRUE;
}

void CWarnDlg::OnCheckShowWarning() 
{
    CRegSettings reg;
	if (reg.OpenSubkey(FALSE, HKEY_CURRENT_USER, m_szRegSubkey) == ERROR_SUCCESS) {
		reg.PutBOOL(g_szRegShowWarning, !(((CButton *)GetDlgItem(IDC_SHOW))->GetCheck()));
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMagnifyDlg dialog

#pragma warning(disable:4355)  // Disable warning C4355: 'this' : used in base member initializer list

CMagnifyDlg::CMagnifyDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMagnifyDlg::IDD, pParent)
	, m_wndStationary(this)
	, m_fRestoreClearType(FALSE)
    , m_fRunningSecure(FALSE)
{
	m_fOnInitDialogCalledYet = FALSE;
	//{{AFX_DATA_INIT(CMagnifyDlg)
	m_fStationaryTrackText = TRUE;
	m_fStationaryTrackSecondaryFocus = TRUE;
	m_fStationaryTrackCursor = TRUE;
	m_fStationaryTrackFocus = TRUE;
	m_nStationaryMagLevel = 2;
	m_fStationaryInvertColors = FALSE;
	m_fStationaryStartMinimized = FALSE;
	m_fStationaryShowMagnifier = TRUE;
	//}}AFX_DATA_INIT
	m_fUseHotKeys = FALSE;
	m_fShowWarning = TRUE;
	idEvent = 6465;

	// Set default hotkey for toggling mouse tracking to Win+PageDown
	fuModifiersToggleMouseTracking = MOD_WIN;
	vkToggleMouseTracking = VK_NEXT;

	// Set default hotkey for toggling inverse colors to Win+PageUp
	fuModifiersToggleInvertColors = MOD_WIN;
	vkToggleInvertColors = VK_PRIOR;
	
	// Set default hotkey for copy to Clipboard to Win+PrintScreen
	fuModifiersCopyToClipboard = MOD_WIN;
	vkCopyToClipboard = VK_SNAPSHOT;
	
	// Set default hotkey for copy to Clipboard without mouse cursor to Win+Shift+PrintScreen
	fuModifiersCopyToClipboard2 = MOD_WIN;
	vkCopyToClipboard2 = VK_SCROLL;

	// Set default hotkey for hiding magnifier to Win+End
	fuModifiersHideMagnifier = MOD_WIN;
	vkHideMagnifier = VK_END;

	// Check the registry to see if we have been used before and if so,
	// reload our persistent settings.
	CRegSettings reg;
	if (reg.OpenSubkey(TRUE, HKEY_CURRENT_USER, m_szRegSubkey) == ERROR_SUCCESS) {
		reg.GetBOOL(g_szRegStationaryTrackText, &m_fStationaryTrackText);
		reg.GetBOOL(g_szRegStationaryTrackSecondaryFocus, &m_fStationaryTrackSecondaryFocus);
		reg.GetBOOL(g_szRegStationaryTrackCursor, &m_fStationaryTrackCursor);
		reg.GetBOOL(g_szRegStationaryTrackFocus, &m_fStationaryTrackFocus);
		reg.GetBOOL(g_szRegStationaryInvertColors, &m_fStationaryInvertColors);
		reg.GetDWORD(g_szRegHotKeyModifiersToggleMouseTracking, (PDWORD) &fuModifiersToggleMouseTracking);
		reg.GetDWORD(g_szRegHotKeyVirtKeyToggleMouseTracking, (PDWORD) &vkToggleMouseTracking);
		reg.GetDWORD(g_szRegHotKeyModifiersToggleInvertColors, (PDWORD) &fuModifiersToggleInvertColors);
		reg.GetDWORD(g_szRegHotKeyVirtKeyToggleInvertColors, (PDWORD) &vkToggleInvertColors);
		reg.GetDWORD(g_szRegHotKeyModifiersCopyToClipboard, (PDWORD) &fuModifiersCopyToClipboard);
		reg.GetDWORD(g_szRegHotKeyVirtKeyCopyToClipboard, (PDWORD) &vkCopyToClipboard);
		reg.GetDWORD(g_szRegHotKeyModifiersCopyToClipboard2, (PDWORD) &fuModifiersCopyToClipboard2);
		reg.GetDWORD(g_szRegHotKeyVirtKeyCopyToClipboard2, (PDWORD) &vkCopyToClipboard2);
		reg.GetDWORD(g_szRegHotKeyModifiersHideMagnifier, (PDWORD) &fuModifiersHideMagnifier);
		reg.GetDWORD(g_szRegHotKeyVirtKeyHideMagnifier, (PDWORD) &vkHideMagnifier);
		reg.GetDWORD(g_szRegStationaryMagLevel, (PDWORD) &m_nStationaryMagLevel);
		reg.GetBOOL(g_szRegStationaryStartMinimized, & m_fStationaryStartMinimized);
		reg.GetBOOL(g_szRegUseHotKeys, & m_fUseHotKeys);
		reg.GetBOOL(g_szRegShowWarning, & m_fShowWarning);
	}

	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);

	m_fAccessTimeOutOverWritten = FALSE;

	// If font smoothing is on then see if cleartype is on; we need to turn
	// that off while magnifier is running and restore it when we exit.
	m_fRestoreClearType = ChangeFontSmoothingType(FE_FONTSMOOTHINGCLEARTYPE, FE_FONTSMOOTHINGSTANDARD);
}

CMagnifyDlg::~CMagnifyDlg()
{
	// Save the current state of in the registry so that we'll
	// come up in the same state the next time the user runs us.
    SaveSettings();

	// If we turned off clear type then restore it
	if (m_fRestoreClearType)
		ChangeFontSmoothingType(FE_FONTSMOOTHINGSTANDARD, FE_FONTSMOOTHINGCLEARTYPE);
}

void CMagnifyDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMagnifyDlg)
	DDX_Control(pDX, IDC_CMB_MAGLEVEL, m_wndCmbMagLev);
	DDX_Check(pDX, IDC_STATIONARYTRACKTEXT, m_fStationaryTrackText);
	DDX_Check(pDX, IDC_STATIONARYTRACKSECONDARYFOCUS, m_fStationaryTrackSecondaryFocus);
	DDX_Check(pDX, IDC_STATIONARYTRACKMOUSECURSOR, m_fStationaryTrackCursor);
	DDX_Check(pDX, IDC_STATIONARYTRACKKYBDFOCUS, m_fStationaryTrackFocus);
	DDX_Check(pDX, IDC_STATIONARYINVERTCOLORS, m_fStationaryInvertColors);
	DDX_Check(pDX, IDC_STATIONARYSTARTMINIMIZED, m_fStationaryStartMinimized);
	DDX_Check(pDX, IDC_STATIONARYSHOWMAGNIFIER, m_fStationaryShowMagnifier);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMagnifyDlg, CDialog)
	//{{AFX_MSG_MAP(CMagnifyDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_DESTROY()
    ON_WM_ENDSESSION()
	ON_CBN_SELENDOK(IDC_CMB_MAGLEVEL, OnChangeStationarymaglevel)
	ON_BN_CLICKED(IDC_STATIONARYTRACKMOUSECURSOR, OnStationarytrackmousecursor)
	ON_BN_CLICKED(IDC_STATIONARYTRACKKYBDFOCUS, OnStationarytrackkybdfocus)
	ON_BN_CLICKED(IDC_STATIONARYTRACKSECONDARYFOCUS, OnStationarytracksecondaryfocus)
	ON_BN_CLICKED(IDC_STATIONARYTRACKTEXT, OnStationarytracktext)
	ON_BN_CLICKED(IDC_STATIONARYINVERTCOLORS, OnStationaryinvertcolors)
	ON_BN_CLICKED(ID_MHELP, OnHelp)
	ON_BN_CLICKED(IDC_EXIT, OnExit)
	ON_WM_SETTINGCHANGE()
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_WM_TIMER()
	ON_WM_CLOSE()
	ON_BN_CLICKED(IDC_STATIONARYSHOWMAGNIFIER, OnStationaryshowmagnifier)
	ON_BN_CLICKED(IDC_STATIONARYSTARTMINIMIZED, OnStationarystartminimized)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_HOTKEY, OnHotKey)
	ON_MESSAGE(WM_DELAYEDMINIMIZE, OnDelayedMinimize)
    ON_MESSAGE(WM_USER_DESKTOPSWITCH, OnDeskSwitch)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMagnifyDlg message handlers

BOOL CMagnifyDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	m_fRunningSecure = RunSecure(GetDesktop());

	if (m_fRunningSecure)
	{
		GetDlgItem(ID_MHELP)->EnableWindow(FALSE);
	}

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	m_hEventAlreadyRunning = CreateEvent(NULL, FALSE, FALSE, __TEXT("JMR\\MSMagnifierAlreadyRunning"));
	if (GetLastError() == ERROR_ALREADY_EXISTS) {
		// Prevent multiple instances from running
		EndDialog(1);
		return(FALSE);
	}

	m_fOnInitDialogCalledYet = TRUE;
	
	// Create the Stationary and Roaming windows
	m_wndStationary.Create(IDD_STATIONARY, NULL);
	//m_wndRoaming.Create;
	
	// Register the hotkeys
	if( m_fUseHotKeys )
	{
		::RegisterHotKey(m_hWnd, HKID_ZOOMUP,   MOD_WIN, VK_UP);
		::RegisterHotKey(m_hWnd, HKID_ZOOMDOWN, MOD_WIN, VK_DOWN);
		::RegisterHotKey(m_hWnd, HKID_TOGGLEMOUSETRACKING, fuModifiersToggleMouseTracking, vkToggleMouseTracking);
		::RegisterHotKey(m_hWnd, HKID_TOGGLEINVERTCOLORS,  fuModifiersToggleInvertColors,  vkToggleInvertColors);
		::RegisterHotKey(m_hWnd, HKID_COPYTOCLIPBOARD,     fuModifiersCopyToClipboard,     vkCopyToClipboard);
		::RegisterHotKey(m_hWnd, HKID_COPYTOCLIPBOARD2,    fuModifiersCopyToClipboard2,    vkCopyToClipboard2);
		::RegisterHotKey(m_hWnd, HKID_HIDEMAGNIFIER,       fuModifiersHideMagnifier,       vkHideMagnifier);
	}
	
	// Set the magnification combo box contents
    FillAndSetCombo(nMinZoom, nMaxZoom, m_nStationaryMagLevel);
	
	// Make this dialog box a topmost window too.
	SetWindowPos(&wndTopMost, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

	CenterWindow();

    // When running on the secure desktop the options dialog 
    // always starts minimized (whistler 148037)

    if (m_fRunningSecure)
    {
        CButton *hwndStartMinimized = (CButton *)GetDlgItem(IDC_STATIONARYSTARTMINIMIZED);
        hwndStartMinimized->SetCheck(1);
        hwndStartMinimized->EnableWindow(FALSE);
    }

	if(m_fStationaryStartMinimized || m_fRunningSecure)
	{
		// Doing just a ShowWindow(SW_MINIMIZE) here doesn't quite
		// work - we end up as a minimized dialog *with the focus*.
		// - Windows always focuses dialogs after they're created.
		// This results in the tray icon flashing, and then remaining
		// inverted until the dialog is restored.
		// So we post ourselves this 'delayed minimize' message -
		// when we receive it - after we've been focused - we forcibly
		// minimize ourselves again, losing the focus in the process.
		// This allows us to start minimized 'unobtrusively'.
		// The ShowWindow(...) here just sets the internal window state
		// to minimized before we get displayed, so we are initially displayed
		// as minimized. If we were initially displayed as full, there'd
		// be flicker/animation as we were later minimized.
		ShowWindow(SW_SHOWMINIMIZED);
		::PostMessage(m_hWnd, WM_DELAYEDMINIMIZE, 0, 0);
	}

	// HACK: Make it work with utility Manager: Change post beta3
	m_wndStationary.SetHidden(FALSE);

    // Detect desktop switch
    InitWatchDeskSwitch(m_hWnd, WM_USER_DESKTOPSWITCH);

	// Show the warning message after 100 ms...
	if ( m_fShowWarning && !m_fRunningSecure )
	{
    	SetTimer(idEvent, 10, NULL);
	}

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CMagnifyDlg::OnTimer(UINT idEvent)
{
	KillTimer(idEvent);

    // #409736 - using static to isolate the fix for modal vs modeless problem
	static CWarnDlg dlg;
    if (dlg.Create(IDD_WARNING, this))
    {
        dlg.ShowWindow(SW_SHOW);// show this window
        dlg.CenterWindow();     // make sure it doesn't go under magnifier window
    }
}

void CMagnifyDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
        // #409736 - using static to isolate the fix for modal vs modeless problem
		static CAboutDlg dlgAbout;
        if (dlgAbout.Create(IDD_ABOUTBOX, this))
        {
            dlgAbout.ShowWindow(SW_SHOW);// show this window
            dlgAbout.CenterWindow();     // make sure it doesn't go under magnifier window
        }
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CMagnifyDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CMagnifyDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CMagnifyDlg::OnDestroy() 
{
	if( m_fUseHotKeys )
	{
		::UnregisterHotKey(m_hWnd, HKID_ZOOMUP);
		::UnregisterHotKey(m_hWnd, HKID_ZOOMDOWN);
		::UnregisterHotKey(m_hWnd, HKID_TOGGLEMOUSETRACKING);
		::UnregisterHotKey(m_hWnd, HKID_TOGGLEINVERTCOLORS);
		::UnregisterHotKey(m_hWnd, HKID_COPYTOCLIPBOARD);
		::UnregisterHotKey(m_hWnd, HKID_COPYTOCLIPBOARD2);
		::UnregisterHotKey(m_hWnd, HKID_HIDEMAGNIFIER);
	}

	// When exiting on the secure desktop reset the work area.  Can't rely 
	// on SHAppBarMessage to do that.  It does that thru the system tray
	// and the system tray isn't on the secure desktop.  If we are on the
    // secure desktop and we are exiting then reset the work area.  We 
    // can't check if system tray is running here because we get here 
    // before we can find it in some cases so incorrectly set work area.

    if (GetDesktop() == DESKTOP_WINLOGON)
    {
        ResetWorkarea();
    }
    
	CloseHandle(m_hEventAlreadyRunning); // JMC: Can't forget to close this handle

	ClearAccessTimeOut();

	CDialog::OnDestroy();
}

void CMagnifyDlg::OnOK() 
{
	// Load the values from the controls into the member variables
	if (!UpdateData(TRUE)) {
		TRACE0(TEXT("UpdateData failed during dialog termination.\r\n"));
		// the UpdateData routine will set focus to correct item
		return;
	} else {
		// Data in member variables OK
		// For stationary window to refresh using the new Zoom level
		m_wndStationary.InvalidateRect(NULL, FALSE);
	}
	// NOTE: Don't call CDialog::OnOK or the dialog box will be 
	// destroyed and the process will terminate.  The process should 
	// die when the user presses the Exit button (IDCANCEL)
	ShowWindow(SW_MINIMIZE);

	// Original MFC-produced code: if (CanExit()) CDialog::OnOK();
}

void CMagnifyDlg::OnExit() 
{
    if (CanExit()) {
        // Destroy the Stationary and Roaming windows
        // JMC: Don't send a WM_CLOSE, because its OnClose sends a WM_CLOSE to use
    // Closing this window will mean doing a proper cleanup
        m_wndStationary.DestroyWindow();
        TermWatchDeskSwitch();
        CDialog::OnCancel();
    }
}

void CMagnifyDlg::OnClose() 
{
    if (CanExit()) {
        // Destroy the Stationary and Roaming windows
        // JMC: Don't send a WM_CLOSE, because its OnClose sends a WM_CLOSE to use
    // Closing this window will mean doing a proper cleanup
        m_wndStationary.DestroyWindow();
        TermWatchDeskSwitch();
        CDialog::OnCancel();
    }
}

void CMagnifyDlg::OnCancel() 
{
	return;
}

BOOL CMagnifyDlg::CanExit() {
	return TRUE;
}

void CMagnifyDlg::UpdateState() {
	if (m_fOnInitDialogCalledYet) {
		// Load the values from the controls into the member variables
		if (!UpdateData(TRUE)) {
			TRACE0(TEXT("UpdateData failed during dialog termination.\r\n"));
			// the UpdateData routine will set focus to correct item
			return;
		} else {
			// Data in member variables OK
			// For stationary window to refresh using the new Zoom level
			m_wndStationary.ZoomChanged();
			m_wndStationary.InvalidateRect(NULL, FALSE);
		}
	}
}

void CMagnifyDlg::OnChangeStationarymaglevel() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CDialog::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.

	// Make sure we are in a valid range
	if(m_fOnInitDialogCalledYet)
	{
		UpdateData();
		m_nStationaryMagLevel = GetComboItemData();
		UpdateData(FALSE);
	}

	// TODO: Add your control notification handler code here
	UpdateState();
}

void CMagnifyDlg::OnStationarytrackmousecursor() 
{
	// TODO: Add your control notification handler code here
	UpdateState();
}

void CMagnifyDlg::OnStationarytrackkybdfocus() 
{
	// TODO: Add your control notification handler code here
	UpdateState();
}

void CMagnifyDlg::OnStationarytracksecondaryfocus() 
{
	// TODO: Add your control notification handler code here
	UpdateState();
}

void CMagnifyDlg::OnStationarytracktext() 
{
	// TODO: Add your control notification handler code here
	UpdateState();
}

void CMagnifyDlg::OnStationaryinvertcolors() 
{
	// TODO: Add your control notification handler code here
	UpdateState();
}

void CMagnifyDlg::OnStationarystartminimized() 
{
	// TODO: Add your control notification handler code here
	UpdateState();
}

void CMagnifyDlg::OnStationaryshowmagnifier() 
{
	// TODO: Add your control notification handler code here

	// Don't call update state - just call SetHidden
	UpdateData();
	m_wndStationary.SetHidden(!m_fStationaryShowMagnifier);
	m_wndStationary.InvalidateRect(NULL, FALSE);
}

LRESULT CMagnifyDlg::OnHotKey(WPARAM wParam, LPARAM lParam) {
	INT_PTR idHotKey = wParam;
	UpdateData();
	switch (idHotKey) {
	case HKID_ZOOMUP:
	case HKID_ZOOMDOWN:
		if (idHotKey == HKID_ZOOMUP) {
			if (m_nStationaryMagLevel < nMaxZoom) m_nStationaryMagLevel++;
		} else {
			if (m_nStationaryMagLevel > nMinZoom) m_nStationaryMagLevel--;
		}
		UpdateData(FALSE);
		m_wndStationary.ZoomChanged();
		m_wndStationary.InvalidateRect(NULL, FALSE);
		break;
		
	case HKID_TOGGLEMOUSETRACKING:
		m_fStationaryTrackCursor ^= TRUE;
		UpdateData(FALSE);   // Make sure the dialog box reflect the change.
		break;

	case HKID_TOGGLEINVERTCOLORS:
		m_wndStationary.Invalidate(FALSE);
		m_fStationaryInvertColors ^= TRUE;
		UpdateData(FALSE);   // Make sure the dialog box reflect the change.
		break;
		
	case HKID_COPYTOCLIPBOARD2:
		// make sure for this case we erase the window before copying it
		m_wndStationary.ForceHideCursor(TRUE);
		m_wndStationary.Invalidate(FALSE);
		m_wndStationary.UpdateWindow();
		m_wndStationary.ForceHideCursor(FALSE);
	case HKID_COPYTOCLIPBOARD:
		m_wndStationary.CopyToClipboard();
		break;

	case HKID_HIDEMAGNIFIER:
		// toggle hidden state of magnifier
		m_fStationaryShowMagnifier ^= TRUE;
		UpdateData(FALSE);
		m_wndStationary.SetHidden(!m_fStationaryShowMagnifier);
		m_wndStationary.ZoomChanged();
		m_wndStationary.Invalidate(FALSE);
		break;
	}
	return(0);
}

LRESULT CMagnifyDlg::OnDelayedMinimize(WPARAM wParam, LPARAM lParam)
{
	// Minimize alone isn't enough to shake off the focus!
	// Hiding forces the focus to go the the next window in line,
	// and then we re-show ourselves as minimized (without taking the
	// focus back).
	ShowWindow(SW_HIDE);
	ShowWindow(SW_MINIMIZE);
	return 0;
}

BOOL CMagnifyDlg::PreTranslateMessage(MSG* pMsg) 
{
	// JMC: HACK TO GET THIS TO WORK WITH MouseHook
	switch(pMsg->message)
	{
	case WM_MOUSEMOVE:
	case WM_NCMOUSEMOVE:
		FakeCursorMove(pMsg->pt);
		break;
	default:
		break;
	}
	
	return CDialog::PreTranslateMessage(pMsg);
}

void CMagnifyDlg::OnSettingChange(UINT uFlags, LPCTSTR lpszSection) 
{
	CDialog::OnSettingChange(uFlags, lpszSection);
}

DWORD g_rgHelpIds[] = {	1000, 8200,
						1002, 8202,
						1003, 8204,
						1013, 8206,
						1005, 8208,
						IDOK, 8212,
						IDCANCEL, 8214,
						1007, 8216,
						1008, 8218,
						0, 0
					};


BOOL CMagnifyDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	if ( m_fRunningSecure )
		return 0;

	::HtmlHelp(NULL , TEXT("magnify.chm"), HH_DISPLAY_TOPIC, 0);

	return 1;
//	return CDialog::OnHelpInfo(pHelpInfo);
}

void CMagnifyDlg::OnHelp()
{
	if ( m_fRunningSecure )
		return;

	::HtmlHelp(m_hWnd , TEXT("magnify.chm"), HH_DISPLAY_TOPIC, 0);
}

void CMagnifyDlg::OnContextMenu(CWnd* pWnd, CPoint point)
{
	if ( m_fRunningSecure )
		return;

	::WinHelp(pWnd->m_hWnd, __TEXT("magnify.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_rgHelpIds);

	return;
//	return CDialog::OnHelpInfo(pHelpInfo);
}

void CMagnifyDlg::OverWriteAccessTimeOut()
{
	if(m_fAccessTimeOutOverWritten)
		return;

	m_AccTimeOut.cbSize = sizeof(m_AccTimeOut);
	SystemParametersInfo(SPI_GETACCESSTIMEOUT, sizeof(m_AccTimeOut), &m_AccTimeOut, 0);
	ACCESSTIMEOUT AccTimeOutTemp = m_AccTimeOut;
	AccTimeOutTemp.dwFlags &= ~ATF_TIMEOUTON;
	SystemParametersInfo(SPI_SETACCESSTIMEOUT, sizeof(AccTimeOutTemp), &AccTimeOutTemp, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
	m_fAccessTimeOutOverWritten = TRUE;
}
void CMagnifyDlg::ClearAccessTimeOut()
{
	if(!m_fAccessTimeOutOverWritten)
		return;
	SystemParametersInfo(SPI_SETACCESSTIMEOUT, sizeof(m_AccTimeOut), &m_AccTimeOut, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
	m_fAccessTimeOutOverWritten = FALSE;
}


void CMagnifyDlg::SetStationaryHidden()
{
	// Hide the window
	UpdateData();
	m_fStationaryShowMagnifier = FALSE;
	UpdateData(FALSE);
	m_wndStationary.SetHidden(!m_fStationaryShowMagnifier);
}

// This method is going to save all values of the magnifier in the
// registry. And will write into RunOnce key to enable Magnifier to 
// come up, the next time.
void CMagnifyDlg::OnEndSession( BOOL bEnding )
{
    CDialog::OnEndSession(bEnding);
    

    if(bEnding)
    {
        HKEY  hSubkey;
        DWORD dwPosition;
        
        // a-anilk: Save the current settings of the Magnifier. This is required because
        // While processing WM_ENDSESSION, The destructor call is NOT gaurenteed to be
        // Exceuted properly. Infact in this case, It is NOT 
        SaveSettings();
        
	    
        CRegSettings reg;
        // This will save the registry values required for size
	    if (reg.OpenSubkey(FALSE, HKEY_CURRENT_USER, m_szRegSubkey) == ERROR_SUCCESS)
	    {
		    APPBARSTATE abs;
		    abs.m_cbSize = sizeof(abs);
		    m_wndStationary.GetState(&abs);
		    // Save the AppBar's state variables to the registry.
		    reg.PutBinary(__TEXT("AppBar"), (PBYTE) &abs, sizeof(abs));
	    }
        
        INT len;     // length of string with null in bytes
        len= (lstrlen( g_szSaveRoam )+1) * sizeof(TCHAR);

        // Save in RunOnce key
        if (ERROR_SUCCESS == RegCreateKeyEx(
                                HKEY_CURRENT_USER
                                , m_szMagSubkey
                                , 0
                                , NULL
                                , REG_OPTION_NON_VOLATILE 
                                , KEY_QUERY_VALUE | KEY_SET_VALUE
                                , NULL
                                , &hSubkey
                                , &dwPosition ))
		{
			RegSetValueEx(hSubkey, g_szSaveKey, 0, REG_SZ, (CONST BYTE*)g_szSaveRoam, len);
    
			RegCloseKey(hSubkey);
		}
    }
}


void CMagnifyDlg::SaveSettings()
{

    CRegSettings reg;
	if (reg.OpenSubkey(FALSE, HKEY_CURRENT_USER, m_szRegSubkey) == ERROR_SUCCESS) {
		reg.PutBOOL(g_szRegStationaryTrackText, m_fStationaryTrackText);
		reg.PutBOOL(g_szRegStationaryTrackSecondaryFocus, m_fStationaryTrackSecondaryFocus);
		reg.PutBOOL(g_szRegStationaryTrackCursor, m_fStationaryTrackCursor);
		reg.PutBOOL(g_szRegStationaryTrackFocus, m_fStationaryTrackFocus);
		reg.PutBOOL(g_szRegStationaryInvertColors, m_fStationaryInvertColors);
		reg.PutDWORD(g_szRegHotKeyModifiersToggleMouseTracking, fuModifiersToggleMouseTracking);
		reg.PutDWORD(g_szRegHotKeyVirtKeyToggleMouseTracking, vkToggleMouseTracking);
		reg.PutDWORD(g_szRegHotKeyModifiersToggleInvertColors, fuModifiersToggleInvertColors);
		reg.PutDWORD(g_szRegHotKeyVirtKeyToggleInvertColors, vkToggleInvertColors);
		reg.PutDWORD(g_szRegHotKeyModifiersCopyToClipboard, fuModifiersCopyToClipboard);
		reg.PutDWORD(g_szRegHotKeyVirtKeyCopyToClipboard, vkCopyToClipboard);
		reg.PutDWORD(g_szRegHotKeyModifiersCopyToClipboard2, fuModifiersCopyToClipboard2);
		reg.PutDWORD(g_szRegHotKeyVirtKeyCopyToClipboard2, vkCopyToClipboard2);
		reg.PutDWORD(g_szRegHotKeyModifiersHideMagnifier, fuModifiersHideMagnifier);
		reg.PutDWORD(g_szRegHotKeyVirtKeyHideMagnifier, vkHideMagnifier);
		reg.PutDWORD(g_szRegStationaryMagLevel, m_nStationaryMagLevel);
		reg.PutBOOL(g_szRegStationaryStartMinimized, m_fStationaryStartMinimized);
//		reg.PutBOOL(g_szRegShowWarning, m_fShowWarning);
	}
}

LRESULT CMagnifyDlg::OnDeskSwitch(WPARAM wParam, LPARAM lParam) 
{
    // ASSERT(wParam == WM_USER_DESKTOPSWITCH);
    // Jan23,2001 Optimization to FUS piggybacks the winlogon desktop
    // to the session being switch from.  This means we have to quit
    // in case user needs to run from the winlogon desktop.

    if (IsUtilManRunning() /*&& CanLockDesktopWithoutDisconnect()*/)
    {
		// When exiting we may need to reset the work area.  Rather than check
        // for the presence of Shell check if we're going to default desktop.
        // When going from locked to default desktop we don't see the system
        // tray so end up calling this after shell has correctly set it.

        if (wParam == DESKTOP_DEFAULT)
        {
            ResetWorkarea();
        }
        OnClose();
    }
	
	return 0;
}

// Helper functions for combo boxes

int CMagnifyDlg::GetComboItemData()
{
    int iValue = CB_ERR;
    int iCurSel = m_wndCmbMagLev.GetCurSel();
    if (iCurSel != CB_ERR)
        iValue = m_wndCmbMagLev.GetItemData(iCurSel);

    return iValue;
}

void CMagnifyDlg::FillAndSetCombo(int iMinVal, int iMaxVal, int iSelVal)
{
    m_wndCmbMagLev.ResetContent();

    int iSelPos = -1;
    for (int i=0;iMaxVal >= iMinVal;i++, iMaxVal--)
    {
        TCHAR szItem[100];
        wsprintf(szItem, TEXT("%d"), iMaxVal);

        int iPos = m_wndCmbMagLev.AddString(szItem);
        m_wndCmbMagLev.SetItemData(iPos, iMaxVal);

        if (iSelVal == iMaxVal)
            iSelPos = iPos; // note the current selection
    }

    // show the current value
    m_wndCmbMagLev.SetCurSel(iSelPos);
}

// Sets font smoothing type
BOOL CMagnifyDlg::ChangeFontSmoothingType(DWORD dwFromType, DWORD dwToType)
{
	// If successfully set font smoothing type from dwFromType to dwToType
	// returns TRUE.  Returns FALSE if there was an error or if no action
	// was necessary to change the font smoothing type.

	BOOL fSettingWasChanged = FALSE;

	DWORD dwFontSmoothingType = FE_FONTSMOOTHINGSTANDARD;
	SystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, &dwFontSmoothingType, 0);

	// only change it if it isn't already ToType and it is FromType
	if (!(dwFontSmoothingType & dwToType) && (dwFontSmoothingType & dwFromType))
	{
		dwFontSmoothingType &= ~dwFromType;
		dwFontSmoothingType |= dwToType;

		fSettingWasChanged = SystemParametersInfo(
									  SPI_SETFONTSMOOTHINGTYPE, 0
									, IntToPtr(dwFontSmoothingType)
									, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE
								);
        if (fSettingWasChanged)
            ::RedrawWindow( NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | 
                    RDW_ERASENOW | RDW_UPDATENOW | RDW_ALLCHILDREN );

	}

	return fSettingWasChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\magdlg.h ===
// MagDlg.h : header file
//

#if !defined(AFX_MAGDLG_H__C7D0DB68_D691_11D0_AD59_00C04FC2A136__INCLUDED_)
#define AFX_MAGDLG_H__C7D0DB68_D691_11D0_AD59_00C04FC2A136__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "MagBar.h" // For CMagBar
#include "NumEdit.h" // For CNumberEdit

/////////////////////////////////////////////////////////////////////////////
// CMagnifyDlg dialog
// Desktop Identifiers.

class CMagnifyDlg : public CDialog
{
	void UpdateState();
	UINT fuModifiersToggleMouseTracking, vkToggleMouseTracking;
	UINT fuModifiersToggleInvertColors, vkToggleInvertColors;
	UINT fuModifiersCopyToClipboard, vkCopyToClipboard;
	UINT fuModifiersCopyToClipboard2, vkCopyToClipboard2;
	UINT fuModifiersHideMagnifier, vkHideMagnifier;
	enum { nMinZoom = 1, nMaxZoom = 9 };
	HANDLE m_hEventAlreadyRunning;
	BOOL m_fOnInitDialogCalledYet;
	CMagBar m_wndStationary;
	BOOL CanExit();
	BOOL m_fAccessTimeOutOverWritten;
	ACCESSTIMEOUT m_AccTimeOut;
	void OverWriteAccessTimeOut();
	void ClearAccessTimeOut();
    void SaveSettings();
    BOOL m_fRunningSecure;

// Construction
public:
	CMagnifyDlg(CWnd* pParent = NULL);	// standard constructor
	~CMagnifyDlg();

	void SetStationaryHidden(); // Hide the magnifier window

// Dialog Data
	//{{AFX_DATA(CMagnifyDlg)
	enum { IDD = IDD_MAGNIFY_DIALOG };
    CComboBox m_wndCmbMagLev;
	BOOL	m_fStationaryTrackText;
	BOOL	m_fStationaryTrackSecondaryFocus;
	BOOL	m_fStationaryTrackCursor;
	BOOL	m_fStationaryTrackFocus;
	int		m_nStationaryMagLevel;
	BOOL	m_fStationaryInvertColors;
	BOOL	m_fStationaryStartMinimized;
	BOOL	m_fStationaryShowMagnifier;
	BOOL	m_fShowWarning;
	//}}AFX_DATA
	BOOL    m_fUseHotKeys;
	DWORD   idEvent;

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMagnifyDlg)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;
	BOOL m_fRestoreClearType;

	// Generated message map functions
	//{{AFX_MSG(CMagnifyDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnDestroy();
	virtual void OnOK();
	afx_msg void OnClose();
	virtual void OnCancel();
	afx_msg void OnChangeStationarymaglevel();
	afx_msg void OnHelp();
	afx_msg void OnExit();
	afx_msg void OnStationarytrackmousecursor();
	afx_msg void OnStationarytrackkybdfocus();
	afx_msg void OnStationarytracksecondaryfocus();
	afx_msg void OnStationarytracktext();
	afx_msg void OnStationaryinvertcolors();
	afx_msg void OnStationaryhighcontrast();
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnStationaryshowmagnifier();
	afx_msg void OnStationarystartminimized();
	afx_msg void OnTimer(UINT);
	//}}AFX_MSG
	LRESULT OnHotKey(WPARAM wParam, LPARAM lParam);
	LRESULT OnDelayedMinimize(WPARAM wParam, LPARAM lParam);
	LRESULT OnDeskSwitch(WPARAM wParam, LPARAM lParam);
	afx_msg void OnEndSession( BOOL bEnding );
    int GetComboItemData();
    void FillAndSetCombo(int iMinVal, int iMaxVal, int iSelVal);
	BOOL ChangeFontSmoothingType(DWORD dwFromType, DWORD dwToType);

	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAGDLG_H__C7D0DB68_D691_11D0_AD59_00C04FC2A136__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Magnify.rc
//
#define ID_MHELP                        3
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_MAGNIFY_DIALOG              102
#define IDS_MOVESTRING                  102
#define IDD_STATIONARY                  104
#define IDS_MOVEFLOAT                   105
#define IDC_POINTER                     106
#define IDD_WARNING                     107
#define IDS_ENABLEWEB                   108
#define IDR_MAINFRAME                   128
#define IDR_STATIONARY                  130
#define IDB_BITMAP1                     130
#define IDC_CUSTOM_HAND                 327
#define IDC_CMB_MAGLEVEL                1000
#define IDC_STATIONARYTRACKMOUSECURSOR  1002
#define IDC_STATIONARYTRACKKYBDFOCUS    1003
#define IDC_STATIONARYTRACKSECONDARYFOCUS 1004
#define IDC_STATIONARYINVERTCOLORS      1005
#define IDC_BUTTON1                     1007
#define IDC_STATIONARYINVERTCOLORS2     1007
#define IDC_STATIONARYSTARTMINIMIZED    1007
#define IDC_STATIONARYHIGHCONTRAST2     1008
#define IDC_STATIONARYSHOWMAGNIFIER     1008
#define IDC_SHOW                        1008
#define IDC_EXIT                        1009
#define IDC_ENABLEWEB2                  1010
#define IDC_STATIONARYTRACKTEXT         1013
#define IDC_ENABLEWEB                   1086
#define IDC_WARND3                      1087
#define ID_PLACEHOLDER_EXIT             32771
#define ID_APPBAR_EXIT                  32771
#define ID_APPBAR_COPYTOCLIPBOARD       32772
#define ID_PLACEHOLDER_OPTIONS          32773
#define ID_APPBAR_OPTIONS               32773
#define ID_APPBAR_HIDE                  32774

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32775
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\sources.inc ===
#
# We need to make sure we pick up the right information in the header files
# TODO: Verify that this is the right place for these defines
#

C_DEFINES=$(C_DEFINES)  -DUNICODE -D_UNICODE

WIN32_IE_VERSION=0x0400

TARGETNAME=magnify
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=PROGRAM
USE_MSVCRT=1
USE_NATIVE_EH=1

TARGETLIBS=$(TARGETLIBS) \
           $(SHELL_LIB_PATH)\shell32p.lib \
           $(SDK_LIB_PATH)\ole32.lib \
           $(SDK_LIB_PATH)\comctl32.lib \
           $(SHELL_LIB_PATH)\shlwapip.lib \
           $(SDK_LIB_PATH)\htmlhelp.lib

NOT_LEAN_AND_MEAN=1

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

SOURCES= ..\AppBar.cpp   \
         ..\FastDib.cpp  \
         ..\MagBar.cpp   \
         ..\MagDlg.cpp   \
         ..\Magnify.cpp  \
         ..\NumEdit.cpp  \
         ..\ZoomRect.cpp \
         ..\Desktop.cpp \
         ..\Magnify.rc

UMTYPE=windows

PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_CXX=1

INCLUDES=..;..\..\..\inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C7D0DB6A_D691_11D0_AD59_00C04FC2A136__INCLUDED_)
#define AFX_STDAFX_H__C7D0DB6A_D691_11D0_AD59_00C04FC2A136__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C7D0DB6A_D691_11D0_AD59_00C04FC2A136__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Magnify.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\registry.h ===
/******************************************************************************
Module name: Registry.h
Written by:  Jeffrey Richter
Purpose:     C++ Class to make working with the registry easier.
******************************************************************************/


#ifndef __REGISTRY_H__
#define __REGISTRY_H__


class CRegSettings {
public:
   CRegSettings();
   ~CRegSettings();

   LONG OpenSubkey(BOOL fReadOnly, HKEY hkeyRoot, LPCTSTR pszSubkey);
   void CloseKey();

   LONG GetBOOL(LPCTSTR pszValueName, PBOOL pf);
   LONG PutBOOL(LPCTSTR pszValueName, BOOL f);

   LONG GetDWORD(LPCTSTR pszValueName, PDWORD pdw);
   LONG PutDWORD(LPCTSTR pszValueName, DWORD dw);

   LONG GetString(LPCTSTR pszValueName, LPTSTR psz, int nMaxSize);
   LONG PutString(LPCTSTR pszValueName, LPCTSTR psz);
   
   LONG GetBinary(LPCTSTR pszValueName, PBYTE pb, PDWORD pcbData);
   LONG PutBinary(LPCTSTR pszValueName, CONST BYTE* pb, int nSize);

private:
   HKEY  m_hkeySubkey;
};

inline CRegSettings::CRegSettings() { m_hkeySubkey = NULL; }
inline CRegSettings::~CRegSettings() { CloseKey(); }

inline void CRegSettings::CloseKey() {
   if (m_hkeySubkey != NULL) { RegCloseKey(m_hkeySubkey); m_hkeySubkey = NULL; }
}

inline LONG CRegSettings::OpenSubkey(BOOL fReadOnly, HKEY hkeyRoot, LPCTSTR pszSubkey) {
   CloseKey();
   LONG lError;
   if (fReadOnly) {
      lError = RegOpenKeyEx(hkeyRoot, pszSubkey, 0, KEY_QUERY_VALUE, &m_hkeySubkey); 
   } else {
      DWORD dwDisposition;
      lError = RegCreateKeyEx(hkeyRoot, pszSubkey, 0, NULL, 
         REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &m_hkeySubkey, &dwDisposition);
   }
   return(lError);
}


inline LONG CRegSettings::GetBOOL(LPCTSTR pszValueName, PBOOL pf) {
   return(GetDWORD(pszValueName, (PDWORD) pf));
}


inline LONG CRegSettings::PutBOOL(LPCTSTR pszValueName, BOOL f) {
   return(PutDWORD(pszValueName, (DWORD) f));
}


inline LONG CRegSettings::GetDWORD(LPCTSTR pszValueName, PDWORD pdw) {
   ASSERT(m_hkeySubkey != NULL); // No subkey is opened
   DWORD cbData = sizeof(pdw);
   return(RegQueryValueEx(m_hkeySubkey, pszValueName, NULL, NULL, (LPBYTE) pdw, &cbData));
}


inline LONG CRegSettings::PutDWORD(LPCTSTR pszValueName, DWORD dw) {
   ASSERT(m_hkeySubkey != NULL); // No subkey is opened
   return(RegSetValueEx(m_hkeySubkey, pszValueName, 0, REG_DWORD, (CONST BYTE*) &dw, sizeof(dw)));
}


inline LONG CRegSettings::GetString(LPCTSTR pszValueName, LPTSTR psz, int nMaxSize) {
   ASSERT(m_hkeySubkey != NULL); // No subkey is opened
   DWORD cbData = nMaxSize;
   return(RegQueryValueEx(m_hkeySubkey, pszValueName, NULL, NULL, (LPBYTE) psz, &cbData));
}


inline LONG CRegSettings::PutString(LPCTSTR pszValueName, LPCTSTR psz) {
   ASSERT(m_hkeySubkey != NULL); // No subkey is opened
   return(RegSetValueEx(m_hkeySubkey, pszValueName, 0, REG_SZ, (CONST BYTE*) psz, lstrlen(psz) + 1));
}


inline LONG CRegSettings::GetBinary(LPCTSTR pszValueName, PBYTE pb, PDWORD pcbData) {
   ASSERT(m_hkeySubkey != NULL); // No subkey is opened
   return(RegQueryValueEx(m_hkeySubkey, pszValueName, NULL, NULL, pb, pcbData));
}


inline LONG CRegSettings::PutBinary(LPCTSTR pszValueName, CONST BYTE* pb, int nSize) {
   ASSERT(m_hkeySubkey != NULL); // No subkey is opened
   return(RegSetValueEx(m_hkeySubkey, pszValueName, 0, REG_BINARY, pb, nSize));
}


#endif   // __REGISTRY_H__


//////////////////////////////// End of File //////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\version.h ===
// MAGNIFY.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "Microsoft Magnifier"
#define VER_INTERNALNAME_STR        "MAGNIFIER"
#define VER_ORIGINALFILENAME_STR    "MAGNIFY.EXE"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\zoomrect.h ===
#if !defined(AFX_ZOOMRECT_H__CCBDFADF_E296_11D0_AD57_00C04FC2A136__INCLUDED_)
#define AFX_ZOOMRECT_H__CCBDFADF_E296_11D0_AD57_00C04FC2A136__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ZoomRect.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CZoomRect window

class CZoomRect : public CWnd
{
// Construction
public:
	CZoomRect();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CZoomRect)
	//}}AFX_VIRTUAL

// Implementation
public:
	void SetLocation(int nLeft, int nTop, int nRight, int nBottom);
	virtual ~CZoomRect();

	// Generated message map functions
protected:
	CRect m_rcOutter;
	int m_nBorderWidth;
	//{{AFX_MSG(CZoomRect)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ZOOMRECT_H__CCBDFADF_E296_11D0_AD57_00C04FC2A136__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\magnify\zoomrect.cpp ===
// ZoomRect.cpp : implementation file
//

#include "stdafx.h"
#include "magnify.h"
#include "ZoomRect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CZoomRect

CZoomRect::CZoomRect()
{
	LPCTSTR lpszClass = AfxRegisterWndClass(CS_SAVEBITS);
	CreateEx(WS_EX_TOPMOST, lpszClass, __TEXT("ZoomRect"), WS_POPUP /* | WS_VISIBLE*/, 0, 0, 10, 10, NULL, NULL);
	m_nBorderWidth = 5;
}

CZoomRect::~CZoomRect()
{
}


BEGIN_MESSAGE_MAP(CZoomRect, CWnd)
	//{{AFX_MSG_MAP(CZoomRect)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CZoomRect message handlers

void CZoomRect::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	CRect rcClient;
	GetClientRect(&rcClient);
	CBrush brush(RGB(255, 255, 128));
	dc.FillRect(&rcClient, &brush);
}

HRGN CreateRectRgn(LPCRECT lpRect)
{
	return CreateRectRgn(lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
}

void CZoomRect::SetLocation(int nLeft, int nTop, int nRight, int nBottom)
{
	CRect rcInner(nLeft, nTop, nRight, nBottom);
	CRect rcOutter;
	rcOutter = rcInner;
	rcOutter.InflateRect(m_nBorderWidth, m_nBorderWidth);
	SetWindowPos(NULL, rcOutter.left, rcOutter.top, rcOutter.Width(), rcOutter.Height(), SWP_NOZORDER);

	ScreenToClient(&rcOutter);
	ScreenToClient(&rcInner);

	if(rcOutter != m_rcOutter)
	{
		m_rcOutter = rcOutter;

		HRGN hrgn1 = CreateRectRgn(&rcOutter);
		if (!hrgn1)
			return;	// raid #113784 (note: this function is never called)

		HRGN hrgn2 = CreateRectRgn(&rcInner);
		if (!hrgn2)
		{
			DeleteObject(hrgn1);
			return; // raid #113784 (note: this function is never called)
		}

		CombineRgn(hrgn1, hrgn1, hrgn2, RGN_XOR);
		DeleteObject(hrgn2);
		SetWindowRgn(hrgn1, TRUE);
	}

	UpdateWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\mag_hook\sources.inc ===
TARGETNAME=Mag_Hook
TARGETPATH=obj
TARGETTYPE=DYNLINK
USE_MSVCRT=1
USE_NATIVE_EH=1
TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\oleaut32.lib \
           $(SDK_LIB_PATH)\oleacc.lib \
           $(SDK_LIB_PATH)\uuid.lib

NOT_LEAN_AND_MEAN=1

DLLENTRY=DllMain

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

SOURCES= ..\mag_hook.cpp \
         ..\mag_hook.rc \
         ..\wineventrefilter.cpp

INCLUDES=..\..\..\inc

UMTYPE=windows
UMRES=$(O)\main.res
DLLDEF=..\Mag_Hook.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\mag_hook\version.h ===
// MAGNIFY.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "Microsoft Magnifier hook library file"
#define VER_INTERNALNAME_STR        "Mag_Hook"
#define VER_ORIGINALFILENAME_STR    "Mag_Hook.dll"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\mag_hook\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Mag_Hook.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\mag_hook\mag_hook.cpp ===
// --------------------------------------------------------------------------
//
//  Mag_Hook.cpp
//
//  Accessibility Event trapper for magnifier. Uses an out-of-context WinEvent
//  hook (if MSAA is installed) or a mouse hook (if MSAA is not installed) to 
//  tell the app where to magnify.
//
//  Mainly what we want this to do is to watch for focus changes, caret
//  movement, and mouse pointer movement, and then post the appropriate
//  location to the Magnifier app so it can magnify the correct area.
//
// --------------------------------------------------------------------------
#define STRICT

#include <windows.h>
#include <windowsx.h>

// When building with VC5, we need winable.h since the active
// accessibility structures are not in VC5's winuser.h.  winable.h can
// be found in the active accessibility SDK
#ifdef VC5_BUILD___NOT_NT_BUILD_ENVIRONMENT
#include <winable.h>
#else
// The Active Accessibility SDK used WINABLEAPI for the functions.  When
// the functions were moved to winuser.h, WINABLEAPI was replaced with WINUSERAPI.
#define WINABLEAPI WINUSERAPI
#endif

#include <ole2.h>
#include <oleacc.h>

#define MAGHOOKAPI  __declspec(dllexport)
#include "Mag_Hook.h"
#include <math.h>

#include "wineventrefilter.h"
#include "w95trace.c"
#include "mappedfile.cpp"

BOOL TryFindCaret( HWND hWnd, IAccessible * pAcc, VARIANT * pvarChild, RECT * prc );
BOOL IsFocussedItem( HWND hWnd, IAccessible * pAcc, VARIANT varChild );


// --------------------------------------------------------------------------
//
// Definitions so we don't have to statically link to OLEACC.DLL
// 
// We need the following three functions that were in the Active Accessibility SDK
//
// STDAPI AccessibleObjectFromEvent(HWND hwnd, DWORD dwId, DWORD dwChildId, IAccessible** ppacc, VARIANT* pvarChild);
// WINABLEAPI HWINEVENTHOOK WINAPI SetWinEventHook(DWORD eventMin, DWORD eventMax, HMODULE hmodWinEventProc, WINEVENTPROC lpfnWinEventProc, DWORD idProcess, DWORD idThread, DWORD dwFlags);
// WINABLEAPI BOOL WINAPI UnhookWinEvent(HWINEVENTHOOK hEvent);
//
// --------------------------------------------------------------------------
typedef HRESULT (_stdcall *_tagAccessibleObjectFromEvent)(HWND hwnd, DWORD dwId, DWORD dwChildId, IAccessible** ppacc, VARIANT* pvarChild);
typedef WINABLEAPI HWINEVENTHOOK (WINAPI *_tagSetWinEventHook)(DWORD eventMin, DWORD eventMax, HMODULE hmodWinEventProc, WINEVENTPROC lpfnWinEventProc, DWORD idProcess, DWORD idThread, DWORD dwFlags);
typedef WINABLEAPI BOOL (WINAPI *_tagUnhookWinEvent)(HWINEVENTHOOK hEvent);

_tagAccessibleObjectFromEvent pAccessibleObjectFromEvent = NULL;
_tagSetWinEventHook pSetWinEventHook = NULL;
_tagUnhookWinEvent pUnhookWinEvent = NULL;


// Workaround for menus - menus 'steal' focus, and don't hand it back
// - so we have to remember where it was before going into menu mode, so we
// can restore it properly afterwards.
POINT g_ptLastKnownBeforeMenu;
BOOL g_InMenu = FALSE;
RECT g_rcMenu = {0, 0, 0, 0};

SIZE  g_ZoomSz;

// --------------------------------------------------------------------------
//
//  GetAcctiveAccessibleFunctions()
//
//  This function attempts to load the active accessibility functions we need
//  from OLEACC.DLL and USER32.DLL
//
//  If the functions are availible, this returns TRUE
//
// --------------------------------------------------------------------------
BOOL GetAcctiveAccessibleFunctions()
{
	HMODULE hOleAcc = NULL;
	HMODULE hUser;
	if(!(hOleAcc = LoadLibrary(__TEXT("oleacc.dll"))))
		return FALSE;
	if(!(pAccessibleObjectFromEvent = (_tagAccessibleObjectFromEvent)GetProcAddress(hOleAcc, "AccessibleObjectFromEvent")))
		return FALSE;
	if(!(hUser = GetModuleHandle(__TEXT("user32.dll"))))
		return FALSE;
	if(!(pSetWinEventHook = (_tagSetWinEventHook)GetProcAddress(hUser, "SetWinEventHook")))
		return FALSE;
	if(!(pUnhookWinEvent = (_tagUnhookWinEvent)GetProcAddress(hUser, "UnhookWinEvent")))
		return FALSE;
	return TRUE;
};


// --------------------------------------------------------------------------
//
// Per-process Variables
//
// --------------------------------------------------------------------------
#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#endif

HMODULE     g_hModEventDll;
UINT        g_auiEvents[] = {
                  EVENT_OBJECT_FOCUS
                , EVENT_OBJECT_LOCATIONCHANGE
                , EVENT_SYSTEM_MENUSTART
                , EVENT_SYSTEM_MENUPOPUPSTART
                , EVENT_SYSTEM_MENUEND
                , EVENT_SYSTEM_DIALOGEND
                };

// --------------------------------------------------------------------------
//
// Shared Variables are in the GLOBALDATA structure
//
// --------------------------------------------------------------------------
struct GLOBALDATA {
    UINT            g_cEvents;
    HWINEVENTHOOK	g_hEventHook[ARRAYSIZE(g_auiEvents)];
    HHOOK			g_hMouseHook;
    HWND			g_hwndEventPost;
    DWORD_PTR		g_dwCursorHack;
    DWORD_PTR		g_MainExeThreadID;
};

// pointer to shared global data
GLOBALDATA *g_pGlobalData = 0;
      
// pointer to mem mapped file handle
CMemMappedFile *g_CMappedFile = 0;                       
                    
// size of global data memory mapped file
const int c_cbGlobalData =  sizeof(GLOBALDATA);
          
// name of memory mapped file
const TCHAR c_szMappedFileName[] = TEXT("MagnifyShared");

// mutex to access mem mapped file and wait time
const TCHAR c_szMutexMagnify[] = TEXT("MagnifyMutex");
const int c_nMutexWait = 5000;

BOOL CreateMappedFile()
{
    g_CMappedFile = new CMemMappedFile;
    if (g_CMappedFile)
    {
        if (g_CMappedFile->Open(c_szMappedFileName, c_cbGlobalData))
        {
            CScopeMutex csMutex;
            if (csMutex.Create(c_szMutexMagnify, c_nMutexWait))
            {
                g_CMappedFile->AccessMem((void **)&g_pGlobalData);
                if (g_CMappedFile->FirstOpen())
                {
                    memset(g_pGlobalData, 0, c_cbGlobalData);
                }
                return TRUE;
            }
        }
    }

    // ISSUE Is it possible to see this error when switching desktops and
    // UtilMan is controlling magnify if it can't gracefully shut down the
    // previous version before starting up one on the new desktop?  Could
    // work around this if its a problem by prefixing the name w/desktop.

    return FALSE;
}
void CloseMappedFile()
{
    if (g_CMappedFile)
    {
        g_CMappedFile->Close();
        delete g_CMappedFile;
        g_CMappedFile = 0;
    }
}

// --------------------------------------------------------------------------
//
// Functions Prototypes (Foward References of callback functions
//
// --------------------------------------------------------------------------
void CALLBACK NotifyProc(HWINEVENTHOOK hEvent, DWORD event, HWND hwndMsg, LONG idObject,
						LONG idChild, DWORD idThread, DWORD dwEventTime);

LRESULT CALLBACK MouseProc(int code, WPARAM wParam, LPARAM lParam);


CWinEventReentrancyFilter< NotifyProc > * g_pWinEventReFilter;


// --------------------------------------------------------------------------
//
//  DllMain()
//
// --------------------------------------------------------------------------
BOOL WINAPI DllMain (HINSTANCE hInst, DWORD dwReason, LPVOID fImpLoad)
{
    switch (dwReason) {

		case DLL_PROCESS_ATTACH:
			g_hModEventDll = hInst;

            // Create the memory mapped file for shared global data
            CreateMappedFile();

            break;

		case DLL_PROCESS_DETACH:
            // Close the memory mapped file for shared global data
            CloseMappedFile();

            break;
    }

    return(TRUE);
}

// --------------------------------------------------------------------------
//
//  InstallEventHookWithOleAcc
//
//  This installs the WinEvent hook if hwndPostTo is not null, or removes the
//  hook if the parameter is null. Does no checking for a valid window handle.
//
//  If successful, this returns TRUE.
//
// --------------------------------------------------------------------------
BOOL WINAPI InstallEventHookWithOleAcc (HWND hwndPostTo) 
{
	if (hwndPostTo != NULL) 
    {
		g_pGlobalData->g_MainExeThreadID = GetCurrentThreadId();

		if(g_pGlobalData->g_hwndEventPost || g_pGlobalData->g_cEvents)
			return FALSE; // We already have hooks installed - you can only have one at a time

		// Install the hook
		g_pGlobalData->g_hwndEventPost = hwndPostTo; // Must set this before installing the hook

        g_pWinEventReFilter = new CWinEventReentrancyFilter< NotifyProc >;
        if( ! g_pWinEventReFilter )
        {
            return FALSE;
        }

        // Only hook the events we care about. If we capture all events it degrades
        // the machine if there are lots of windows open at one time.  In particular
        // consoles send many events and hooking these can quickly overrun the console
        // input thread during high activity.  Note that if some of the SetWinEventHook
        // calls fail the global handle array no longer corresponds one-to-one with the
        // event constant array.  We take that into consideration when unhooking these.

        {
            int cEvents = ARRAYSIZE(g_auiEvents);
            for (int i=0;i<cEvents;i++)
            {
		        // Currently using a OUTOFCONTEXT hook. As the INCONTEXT  
		        // hook is not going to work if launched from UM. 
		        g_pGlobalData->g_hEventHook[g_pGlobalData->g_cEvents] = pSetWinEventHook(
                                                                            g_auiEvents[i], 
                                                                            g_auiEvents[i], 
                                                                            g_hModEventDll,
                                                                            g_pWinEventReFilter->WinEventProc,
                                                                            0, 
                                                                            0, 
                                                                            WINEVENT_OUTOFCONTEXT);
                if (g_pGlobalData->g_hEventHook[g_pGlobalData->g_cEvents])
                {
                    g_pGlobalData->g_cEvents++;
                }
            }
        }

		if (!g_pGlobalData->g_cEvents) 
        {
			// Something went wrong - reset g_pGlobalData->g_hwndEventPost to NULL
			g_pGlobalData->g_hwndEventPost = NULL;

			return FALSE;
		}
	} 
    else 
    {
		// NOTE - We never fail if they are trying to uninstall the hook
		g_pGlobalData->g_hwndEventPost = NULL;
		// Uninstalling the hooks
        for (int i = 0; i < g_pGlobalData->g_cEvents; i++)
        {
			BOOL fRv = pUnhookWinEvent(g_pGlobalData->g_hEventHook[i]);
			g_pGlobalData->g_hEventHook[i] = NULL;
        }
	
        delete g_pWinEventReFilter;
        g_pWinEventReFilter = NULL;
    }
	return TRUE;
}

// --------------------------------------------------------------------------
//
//  InstallEventHookWithoutOleAcc
//
//  This installs a mouse hook so we have some functionality when oleacc is
//  not installed
//
//  If successful, this returns TRUE.
//
// --------------------------------------------------------------------------
BOOL WINAPI InstallEventHookWithoutOleAcc (HWND hwndPostTo) 
{
	if (hwndPostTo != NULL) 
    {
		if(g_pGlobalData->g_hwndEventPost || g_pGlobalData->g_hMouseHook)
			return FALSE; // We already have a hook installed - yo u can only have one at a time

		// Install the hook
		g_pGlobalData->g_hwndEventPost = hwndPostTo; // Must set this before installing the hook
		g_pGlobalData->g_hMouseHook = SetWindowsHookEx(WH_MOUSE, MouseProc, g_hModEventDll, 0);
		if (!g_pGlobalData->g_hMouseHook) 
        {
			// Something went wrong - reset g_pGlobalData->g_hwndEventPost to NULL
			g_pGlobalData->g_hwndEventPost = NULL;
			return FALSE;
		}
	} 
    else 
    {
		// NOTE - We never fail if they are trying to uninstall the hook
		g_pGlobalData->g_hwndEventPost = NULL;
		// Uninstalling the hook
		if (g_pGlobalData->g_hMouseHook != NULL) 
        {
			UnhookWindowsHookEx(g_pGlobalData->g_hMouseHook);
			g_pGlobalData->g_hMouseHook = NULL;
		}
	}
	return TRUE;
}


// --------------------------------------------------------------------------
//
//  InstallEventHook
//
//  This function checks to see if Ole Accessibility is installed, and if so
//  uses the WinEvent hook.  Otherwise, it uses a mouse hook.
//
//  If successful, this returns TRUE.
//
// --------------------------------------------------------------------------

BOOL g_bOleAccInstalled = FALSE;
BOOL g_bCheckOnlyOnceForOleAcc = TRUE;

BOOL WINAPI InstallEventHook (HWND hwndPostTo) 
{
    CScopeMutex csMutex;
    if (!csMutex.Create(c_szMutexMagnify, c_nMutexWait))
    {
        DBPRINTF(TEXT("InstallEventHook:  CScopeMutex::Create FAILED!\r\n"));
        return FALSE;
    }

	// We check onl y the first time if Ole Acc is installed.  From then on,
	// we assume it remains constant.
	if(g_bCheckOnlyOnceForOleAcc) 
    {
		g_bCheckOnlyOnceForOleAcc = FALSE;
		g_bOleAccInstalled = GetAcctiveAccessibleFunctions();
	}

	if(g_bOleAccInstalled)
		return InstallEventHookWithOleAcc(hwndPostTo);
	else
		return InstallEventHookWithoutOleAcc(hwndPostTo);
}

// --------------------------------------------------------------------------
//
//  GetCursorHack()
//
//  This function returns the last known user cursor handle.
//  
// --------------------------------------------------------------------------

DWORD_PTR WINAPI GetCursorHack()
{
    CScopeMutex csMutex;
    if (!csMutex.Create(c_szMutexMagnify, c_nMutexWait))
    {
        DBPRINTF(TEXT("GetCursorHack:  CScopeMutex::Create FAILED!\r\n"));
        return NULL;
    }

	return g_pGlobalData->g_dwCursorHack;
}

WPARAM CalcZoom(RECT &rcLoc, BOOL fCenter)
{
	int ZoomX;
	int ZoomY;

	// If the focussed object does not fit into the zoom area, 
	// Then reset the location of the focussed rectangle
	// BUG: Need to handle RTL languages

	// Does Loc rect fit horizontally?
	if( g_ZoomSz.cx <= abs(rcLoc.left - rcLoc.right) )
	{
		// it doesn't so left justify 
		ZoomX = rcLoc.left + (g_ZoomSz.cx/2);
	}
	else
	{
		// it fits so center 
		ZoomX = (rcLoc.left + rcLoc.right) / 2;
	}

    if (fCenter)
    {
	    // Does Loc rect fit vertically?
	    if( g_ZoomSz.cy <= abs(rcLoc.top - rcLoc.bottom) )
	    {
		    // it doesn't so center near top
		    ZoomY = rcLoc.top + (g_ZoomSz.cy/2);
	    }
	    else
	    {
		    // it fits so center 
		    ZoomY = (rcLoc.top + rcLoc.bottom) / 2;
	    }
    } else
    {
        // Don't center vertically; focus at the top
        ZoomY = rcLoc.top;
    }

	return MAKELONG( ZoomX, ZoomY );
}

// --------------------------------------------------------------------------
//
//  NotifyProc()
//
//	This is the callback function for the WinEvent Hook we install. This
//	gets called whenever there is an event to process. The only things we
//	care about are focus changes and mouse/caret movement. The way we handle
//  the events is to post a message to the client (ScreenX) telling it
//	where the focus/mouse/caret is right now. It can then decide where it 
//	should be magnifying.
//
//	Parameters:
//		hEvent			A handle specific to this call back
//		event			The event being sent
//		hwnd			Window handle of the window generating the event or 
//						NULL if no window is associated with the event.
//		idObject		The object identifier or OBJID_WINDOW.
//		idChild			The child ID of the element triggering the event, 
//						or CHILDID_SELF if the event is for the object itself.
//		dwThreadId		The thread ID of the thread generating the event.  
//						Informational only.
//		dwmsEventTime	The time of the event in milliseconds.
// --------------------------------------------------------------------------
/* Forward ref */ BOOL GetObjectLocation(IAccessible * pacc, VARIANT* pvarChild, LPRECT lpRect);
void CALLBACK NotifyProc(HWINEVENTHOOK hEvent, DWORD event, HWND hwndMsg, LONG idObject,
						 LONG idChild, DWORD idThread, DWORD dwmsEventTime) 
{

	WPARAM			wParam;
	LPARAM			lParam;
	// Initialize pac to NULL so that we Release() pointers we've obtained.
	// Otherwise we will continually leak a heck of memory.
	IAccessible *	pacc = NULL;
	RECT			LocationRect, CaretSrch;
	VARIANT 		varChild;
	HRESULT 		hr;
	BOOL			bX, bY;

    CScopeMutex csMutex;
    if (!csMutex.Create(c_szMutexMagnify, c_nMutexWait))
    {
        DBPRINTF(TEXT("NotifyProc:  CScopeMutex::Create FAILED!\r\n"));
        return;
    }

	switch (event) 
    {
	    case EVENT_OBJECT_FOCUS:
		    hr = pAccessibleObjectFromEvent(hwndMsg, idObject, idChild, &pacc, &varChild);
		    if (!SUCCEEDED(hr))
            {
                DBPRINTF(TEXT("NotifyProc(EVENT_OBJECT_FOCUS): AccessibleObjectFromEvent failed 0x%x\r\n"), hr);
			    return;
            }
		    if (!GetObjectLocation(pacc,&varChild,&LocationRect))
            {
                DBPRINTF(TEXT("NotifyProc(EVENT_OBJECT_FOCUS): GetObjectLocation failed\r\n")); 
			    break;
            }
            // Got object rect - fall through and continue processing...

			// Ignore bogus focus events
			if ( !IsFocussedItem( hwndMsg, pacc, varChild ) )
            {
                DBPRINTF(TEXT("NotifyProc(EVENT_OBJECT_FOCUS): Ignoring event:  state is not Focused\r\n"));
				return;
            }

			// Remove bogus all zero events from IE5.0
			if ( (LocationRect.top == 0) && (LocationRect.left == 0) && 
				  (LocationRect.bottom == 0) && (LocationRect.right == 0))
            {
                DBPRINTF(TEXT("NotifyProc(EVENT_OBJECT_FOCUS):  Ignoring location {0,0,0,0}\r\n"));
				return;
            }

			wParam = CalcZoom(LocationRect, TRUE);
		
            // Only update 'last known non-menu point' for focus while not in menu mode
            if( !g_InMenu )
            {
                g_ptLastKnownBeforeMenu.x = LOWORD( wParam );
                g_ptLastKnownBeforeMenu.y = HIWORD( wParam );
            }

		    // JMC: TODO: Make sure the top left corner of the object is in the zoom rect
			// BMCK: PostMessage->SendMessage, since we're in-context. (Avoids hogging message queue)
		    SendMessage(g_pGlobalData->g_hwndEventPost, WM_EVENT_FOCUSMOVE, wParam, 0);
            // OutputDebugString(TEXT(" - success\r\n"));
		    break;
		    
	    case EVENT_OBJECT_LOCATIONCHANGE:
		    switch (idObject) 
            {
		        case OBJID_CARET:
			        hr = pAccessibleObjectFromEvent (hwndMsg,idObject,idChild, &pacc, &varChild);
			        if (!SUCCEEDED(hr))
                    {
                        DBPRINTF(TEXT("NotifyProc(EVENT_OBJECT_LOCATIONCHANGE):  AccessibleObjectFromEvent FAILED 0x%x\r\n"), hr);
				        return;
                    }
			        if (!GetObjectLocation (pacc,&varChild,&LocationRect))
                    {
                        DBPRINTF(TEXT("NotifyProc(EVENT_OBJECT_LOCATIONCHANGE):  GetObjectLocation FAILED\r\n"));
				        break;
                    }
			        
			        // center zoomed area on center of focus rect.
			        wParam = MAKELONG(((LocationRect.left + LocationRect.right) / 2), ((LocationRect.bottom + LocationRect.top) / 2));
			        lParam = dwmsEventTime;

                    // Only update 'last known non-menu point' for caret while not in menu mode
                    if( !g_InMenu )
                    {
                        g_ptLastKnownBeforeMenu.x = LOWORD( wParam );
                        g_ptLastKnownBeforeMenu.y = HIWORD( wParam );
                    }

			        // BMCK: PostMessage->SendMessage, since we're in-context. (Avoids hogging message queue)
			        SendMessage(g_pGlobalData->g_hwndEventPost, WM_EVENT_CARETMOVE, wParam, lParam);
			        break;
			        
		        case OBJID_CURSOR:
			        hr = pAccessibleObjectFromEvent (hwndMsg,idObject,idChild, &pacc, &varChild);
			        if (!SUCCEEDED(hr))
                    {
                        DBPRINTF(TEXT("NotifyProc(OBJID_CURSOR):  AccessibleObjectFromEvent FAILED 0x%x\r\n"), hr);
				        return;
                    }
			        if (!GetObjectLocation (pacc,&varChild,&LocationRect))
                    {
                        DBPRINTF(TEXT("NotifyProc(OBJID_CURSOR):  GetObjectLocation FAILED\r\n"));
				        break;
                    }
			        wParam = MAKELONG(LocationRect.left, LocationRect.top);
			        lParam = dwmsEventTime;

                    // update 'last known non-menu point' for mouse even if in menu mode -
                    // mouse moves can occur while in menu mode, and we do want to remember them.
                    g_ptLastKnownBeforeMenu.x = LOWORD( wParam );
                    g_ptLastKnownBeforeMenu.y = HIWORD( wParam );

			        // BMCK: PostMessage->SendMessage, since we're in-context. (Avoids hogging message queue)
                    SendMessage(g_pGlobalData->g_hwndEventPost, WM_EVENT_MOUSEMOVE, wParam, lParam);
			        break;
		    }
		    break;

            case EVENT_SYSTEM_MENUSTART:
				// Set flag indicating we are in pop-up menu only
				// if the event came from the magnify window
				if (hwndMsg == g_pGlobalData->g_hwndEventPost)
				{
					g_InMenu = TRUE;
				}
                break;

				// Fix context menu tracking. :a-anilk
			case EVENT_SYSTEM_MENUPOPUPSTART:
				{
					TCHAR buffer[100];

					GetClassName(hwndMsg,buffer,100); 

					hr = pAccessibleObjectFromEvent (hwndMsg,idObject,idChild, &pacc, &varChild);
					if (!SUCCEEDED(hr))
                    {
                        DBPRINTF(TEXT("NotifyProc(EVENT_SYSTEM_MENUPOPUPSTART):  AccessibleObjectFromEvent FAILED 0x%x\r\n"), hr);
				        return;
                    }
					if (!GetObjectLocation (pacc,&varChild,&LocationRect))
                    {
                        DBPRINTF(TEXT("NotifyProc(EVENT_SYSTEM_MENUPOPUPSTART):  GetObjectLocation FAILED\r\n"));
				        break;
                    }

                    // if we are in the popup menu then save its window location info
                    // so that the main mag window can bitblt it with the cursor

					lParam = dwmsEventTime;
                    if (!g_InMenu)
                    {
					    wParam = CalcZoom(LocationRect, FALSE);
                    }
                    else
                    {
                        IAccessible * paccParent;
                        hr = pacc->get_accParent((IDispatch **)&paccParent);
                        if (SUCCEEDED(hr))
                        {
                            VARIANT varSelf;
                            varSelf.vt = VT_I4;
                            varSelf.lVal = CHILDID_SELF;
                            GetObjectLocation(paccParent, &varSelf, &g_rcMenu);
                            paccParent->Release();
                        }
                        else
                        {
                            g_rcMenu = LocationRect;
                        }
					    wParam = CalcZoom(g_rcMenu, FALSE);
                    }

                    SendMessage(g_pGlobalData->g_hwndEventPost, WM_EVENT_FORCEMOVE, wParam, lParam);
				}
				break;
	
            case EVENT_SYSTEM_MENUEND:
                if(g_InMenu )
                {
                    g_InMenu = FALSE;
                    memset(&g_rcMenu, 0, sizeof(RECT));

			        lParam = GetTickCount();
                    wParam = MAKELONG( g_ptLastKnownBeforeMenu.x,
                                       g_ptLastKnownBeforeMenu.y );;

        			// BMCK: PostMessage->SendMessage, since we're in-context. (Avoids hogging message queue)
                    SendMessage(g_pGlobalData->g_hwndEventPost, WM_EVENT_FORCEMOVE, wParam, lParam);
                }
                break;

            case EVENT_SYSTEM_DIALOGEND:
                break;
	}
	if (pacc)
		pacc->Release();
}

// --------------------------------------------------------------------------
//
//	GetObjectLocation()
//
//	This fills in a RECT that has the location of the Accessible object
//	specified by pacc and idChild. The coordinates returned are screen
//	coordinates.
//
// --------------------------------------------------------------------------
BOOL GetObjectLocation(IAccessible * pacc, VARIANT* pvarChild, LPRECT lpRect) 
{
	HRESULT hr;
	SetRectEmpty(lpRect);
	
	hr = pacc->accLocation(&lpRect->left, &lpRect->top, &lpRect->right, &lpRect->bottom, *pvarChild);
	
	// the location is not a rect, but a top left, plus a width and height.
	// I want it as a real rect, so I'll convert it.
	lpRect->right  = lpRect->left + lpRect->right;
	lpRect->bottom = lpRect->top  + lpRect->bottom;
	
	if ( hr != S_OK )
    {
		return(FALSE);
    }

	return(TRUE);
}



// --------------------------------------------------------------------------
//
//  MouseProc()
//
//	This is the callback function for the Mouse Hook we install.
//
//	Parameters:
// --------------------------------------------------------------------------
LRESULT CALLBACK MouseProc(int code, WPARAM wParam, LPARAM lParam)
{
    CScopeMutex csMutex;
    if (csMutex.Create(c_szMutexMagnify, c_nMutexWait))
    {
        DBPRINTF(TEXT("MouseProc:  CScopeMutex::Create FAILED!\r\n"));
        return 0;   // TODO not sure what value to return; MSDN is unclear
    }

	// For WM_MOUSEMOVE and WM_NCMOUSEMOVE messages, we post the main window
	// WM_EVENT_MOUSEMOVE messages.  We don't want to do this if we are in
	// the address space of MAGNIFY.EXE.  To avoid this, we also check that
	// g_bCheckOnlyOnceForOleAcc is TRUE.  If g_bCheckOnlyOnceForOleAcc is TRUE,
	// we are in another processes address space.
	// If we posted ourselves WM_EVENT_MOUSEMOVE while in MAGNIFY.EXE, we got all
	// sorts of weird crashes.
	if((WM_MOUSEMOVE == wParam || WM_NCMOUSEMOVE == wParam) && g_bCheckOnlyOnceForOleAcc)
	{
		g_pGlobalData->g_dwCursorHack = (DWORD_PTR)GetCursor(); // JMC: Hack to get cursor on systems that don't support new GetCursorInfo
		MOUSEHOOKSTRUCT *pmhs = (MOUSEHOOKSTRUCT *)lParam;
		PostMessage(g_pGlobalData->g_hwndEventPost, WM_EVENT_MOUSEMOVE, MAKELONG(pmhs->pt.x, pmhs->pt.y), 0);
	}

	return CallNextHookEx(g_pGlobalData->g_hMouseHook, code, wParam, lParam);
}

// --------------------------------------------------------------------------
//
// FakeCursorMove
//
// This function is called to 'fake' the cursor moving.  It is used by the
// magnifier app when a MouseProc is used.  We run into problems when
// posting ourselves messages from the MouseProc of our own process.  To
// avoid these problems, MouseProc() does not post a WM_EVENT_MOUSEMOUVE
// if we are in the address space of MAGNIFY.EXE.  Instead, MAGNIFY.EXE
// is responsible for calling FakeCursorMove() whenever the mouse moves over
// a window of its own process. (NOTE: This is really easy to accomplish in
// MFC.  We just call FakeCursorMove() from PreTranslateMessage() - see
// MagBar.cpp and MagDlg.cpp
//
// --------------------------------------------------------------------------

void WINAPI FakeCursorMove(POINT pt)
{
    CScopeMutex csMutex;
    if (!csMutex.Create(c_szMutexMagnify, c_nMutexWait))
    {
        DBPRINTF(TEXT("FakeCursorMove:  CScopeMutex::Create FAILED!\r\n"));
        return;
    }

	g_pGlobalData->g_dwCursorHack = (DWORD_PTR)GetCursor(); // JMC: Hack to get cursor on systems that don't support new GetCursorInfo
	PostMessage(g_pGlobalData->g_hwndEventPost, WM_EVENT_MOUSEMOVE, MAKELONG(pt.x, pt.y), 0);
}

// --------------------------------------------------------------------------
//
// SetZoomRect: Sets the maximum zoom rectangle.
//
// --------------------------------------------------------------------------

void SetZoomRect( SIZE sz )
{
	g_ZoomSz = sz;
}

// --------------------------------------------------------------------------
//
// GetPopupInfo: returns the rect of the menu popup in screen coordinates
//               or zero'd rect if menu popup isn't up.
//
// --------------------------------------------------------------------------
// TODO do all this with a little class
void GetPopupInfo(RECT *prect)
{
    if (g_InMenu)
    {
        *prect = g_rcMenu;
    } else
    {
        memset(prect, 0, sizeof(RECT));
    }
}

BOOL TryFindCaret( HWND hWnd, IAccessible * pAcc, VARIANT * pvarChild, RECT * prc )
{
    // Check that it is the currently active caret...
    GUITHREADINFO gui;
	TCHAR buffer[100];

	GetClassName(hWnd,buffer,100); 

    gui.cbSize = sizeof(GUITHREADINFO);
    if( ! GetGUIThreadInfo( NULL , &gui ) )
    {
        OutputDebugString( TEXT("GetGUIThreadInfo failed") );
        return FALSE;
    }
        
    if( gui.hwndCaret != hWnd )
    {
        return FALSE;
    }

	// Is it toolbar, We cannot determine who had focus!!!
	if ( (lstrcmpi(buffer, TEXT("ToolbarWindow32")) == 0) ||
		(lstrcmpi(buffer, TEXT("Internet Explorer_Server")) == 0))
			MessageBeep(100);
			// return FALSE;

    // Try to get the caret for that window (if one exists)...
    IAccessible * pAccCaret = NULL;
    VARIANT varCaret;
    varCaret.vt = VT_I4;
    varCaret.lVal = CHILDID_SELF;
    if( S_OK != AccessibleObjectFromWindow( hWnd, OBJID_CARET, IID_IAccessible, (void **) & pAccCaret ) )
    {
        OutputDebugString( TEXT("TryFindCaret: AccessibleObjectFromWindow failed") );
        return FALSE;
    }

    // Now get location of the caret... (will fail if caret is invisible)
    HRESULT hr = pAccCaret->accLocation( & prc->left, & prc->top, & prc->right, & prc->bottom, varCaret );
    pAccCaret->Release();

    if( hr != S_OK )
    {
        // Error, or caret is currently invisible.
        return FALSE;
    }

    // Convert accLocation's left/right/width/height to left/right/top/bottom...
    prc->right += prc->left;
    prc->bottom += prc->top;
	

    // All done!
    return TRUE;
}

BOOL IsFocussedItem( HWND hWnd, IAccessible * pAcc, VARIANT varChild )
{
	
	TCHAR buffer[100];

	GetClassName(hWnd,buffer,100); 
	// Is it toolbar, We cannot determine who had focus!!!
	if ( (lstrcmpi(buffer, TEXT("ToolbarWindow32")) == 0) ||
		(lstrcmpi(buffer, TEXT("Internet Explorer_Server")) == 0))
			return TRUE;
	
	VARIANT varState;
	HRESULT hr;
	
	VariantInit(&varState); 

	hr = pAcc->get_accState(varChild, &varState);

	if ( hr == S_OK )
	{
		if ( ! (varState.lVal & STATE_SYSTEM_FOCUSED) )
		    return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\mag_hook\mag_hook.h ===
/******************************************************************************
Module name: Mag_Hook.h
Written by:  Jeffrey Richter
Purpose:     Magnify Hook DLL Header file for exported functions and symbols.
******************************************************************************/


#ifndef MAGHOOKAPI 
#define MAGHOOKAPI  __declspec(dllimport)
#endif


/////////////////////////////////////////////////////////////////////////////


#define WM_EVENT_CARETMOVE (WM_APP + 0)
#define WM_EVENT_FOCUSMOVE (WM_APP + 1)
#define WM_EVENT_MOUSEMOVE (WM_APP + 2)
// unconditional move - used to restore position to prev location
// when eg. menu disappears...
#define WM_EVENT_FORCEMOVE (WM_APP + 3)

/////////////////////////////////////////////////////////////////////////////


extern "C" MAGHOOKAPI BOOL WINAPI InstallEventHook (HWND hwndPostTo);
extern "C" MAGHOOKAPI DWORD_PTR WINAPI GetCursorHack();
extern "C" MAGHOOKAPI void WINAPI FakeCursorMove(POINT pt);
extern "C" MAGHOOKAPI void SetZoomRect(  SIZE sz );
extern "C" MAGHOOKAPI void GetPopupInfo(RECT *prect);


// Macros and function prototypes for debugging
#ifdef DEBUG
  #define _DEBUG
#endif
#include "w95trace.h"
	
//////////////////////////////// End of File //////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrator\narrator.h ===
// Narrator Globals
#define WM_MSRREPEAT WM_APP+1 //A key for us to process
#define WM_MSRSPEAK WM_APP+2
#define WM_MUTE WM_APP+3
#define WM_MSRHELP WM_APP+4
#define WM_MSRQUIT WM_APP+5
#define WM_MSRCONFIGURE WM_APP+6
#define WM_MSRDESKSW WM_APP+7
#define WM_MSRSPEAKXML WM_APP+8
#define WM_MSRSPEAKMUTE WM_APP+9

#define MSR_ECHOALNUM		  1
#define MSR_ECHOBACK		  2
#define MSR_ECHOSPACE		  4
#define MSR_ECHODELETE		  8
#define MSR_ECHOTAB			 16
#define MSR_ECHOENTER		 32
#define MSR_ECHOMODIFIERS	 64
#define MSR_ECHOGRAPHICS	128

#define ID_PROPERTYFIRST    100
#define ID_NAME         100
#define ID_ROLE         101
#define ID_STATE        102
#define ID_LOCATION     103
#define ID_DESCRIPTION  104
#define ID_VALUE        105
#define ID_HELP         106
#define ID_SHORTCUT     107
#define ID_DEFAULT      108
#define ID_PARENT       109
#define ID_CHILDREN     110
#define ID_SELECTION    111
#define ID_WINDOW       112
#define ID_PROPERTYLAST 112
#define UMR_MACHINE_KEY HKEY_LOCAL_MACHINE
#define UM_REGISTRY_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Accessibility\\Utility Manager")


typedef struct tagObjectInfo
{
    HWND hwnd;
    long* plObj;
    VARIANT varChild;
} OBJINFO;

typedef tagObjectInfo* LPOBJINFO;

// Macros and function prototypes for debugging
#include "..\..\inc\w95trace.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\magnify\mag_hook\wineventrefilter.cpp ===
//
// wineventrefilter - utility class to filter out reentrant WinEvent events
//
// Copyright (C) 1998 by Microsoft Corporation.  All rights reserved.
//

#include <windows.h>
#include <winable.h>

//#include <common.h>
#include <wineventrefilter.h>


class WinEventReentrancyFilter_Impl: public WinEventReentrancyFilter
{
    struct EventInfo
    {
        EventInfo *     m_pNext;

        HWINEVENTHOOK   hEvent;
        DWORD           event;
        HWND            hwnd;
        LONG            idObject;
        LONG            idChild;
        DWORD           idThread;
        DWORD           dwmsEventTime;
    };

    EventInfo *         m_pHead;
    EventInfo *         m_pTail;

    FN_WinEventProc *   m_pWinEventProc;

    BOOL                m_IsBusy;

public:

    WinEventReentrancyFilter_Impl();
    ~WinEventReentrancyFilter_Impl();
    void SetCallback( FN_WinEventProc *  pWinEventProc );
    void HandleWinEvent( HWINEVENTHOOK hEvent,
                         DWORD         event,
                         HWND          hwnd,
                         LONG          idObject,
                         LONG          idChild,
                         DWORD         idThread,
                         DWORD         dwmsEventTime );
};



WinEventReentrancyFilter * CreateWinEventReentrancyFilter()
{
    return new WinEventReentrancyFilter_Impl;
}


WinEventReentrancyFilter_Impl::WinEventReentrancyFilter_Impl()
    : m_pHead( NULL ),
      m_pTail( NULL ),
      m_pWinEventProc( NULL ),
      m_IsBusy( FALSE )
{
    // nothing else to do
}



WinEventReentrancyFilter_Impl::~WinEventReentrancyFilter_Impl()
{
    // clear any unhandled events...
    // TODO: ASSERT( m_pHead == NULL )
    // since queue is only used during recursion, since we should only
    // be deleted at top-level, queue should be empty.
}

void WinEventReentrancyFilter_Impl::SetCallback( FN_WinEventProc *  pWinEventProc )
{
    m_pWinEventProc = pWinEventProc;
}

void WinEventReentrancyFilter_Impl::HandleWinEvent( HWINEVENTHOOK hEvent,
                                                    DWORD         event,
                                                    HWND          hwnd,
                                                    LONG          idObject,
                                                    LONG          idChild,
                                                    DWORD         idThread,
                                                    DWORD         dwmsEventTime )
{
    if( m_IsBusy )
    {
        // we're busy processing another event at the moment - so save this one
        // to the queue for later...
        EventInfo * pInfo = new EventInfo;
        if (pInfo)
        {
            pInfo->hEvent = hEvent;
            pInfo->event = event;
            pInfo->hwnd = hwnd;
            pInfo->idObject = idObject;
            pInfo->idChild = idChild;
            pInfo->idThread = idThread;
            pInfo->dwmsEventTime = dwmsEventTime;
            pInfo->m_pNext = NULL;

            // push the event to the tail of queue...
            if( m_pHead )
            {
                // add to tail of existing queue...
                m_pTail->m_pNext = pInfo;
            }
            else
            {
                // if m_pHead is NULL, then add to the empty queue...
                m_pHead = pInfo;
            }
            m_pTail = pInfo;

            // all done for now - we'll process the event later after we've finished
            // the one we're currently processing.
        }
        // else there's nothing we can do for out of memory condition
    }
    else
    {
        m_IsBusy = TRUE;

        // deliver the event...
        m_pWinEventProc( hEvent,
                         event,
                         hwnd,
                         idObject,
                         idChild,
                         idThread,
                         dwmsEventTime );

        // handle any events that may have occured while we were busy...
        while( m_pHead )
        {
            // Remove the head event...
            EventInfo * pInfo = m_pHead;
            m_pHead = m_pHead->m_pNext;

            // deliver the event...
            m_pWinEventProc( pInfo->hEvent,
                             pInfo->event,
                             pInfo->hwnd,
                             pInfo->idObject,
                             pInfo->idChild,
                             pInfo->idThread,
                             pInfo->dwmsEventTime );

            // free the event info block...
            delete pInfo;
        }

        // all finished - clear the 'busy' flag...
        m_IsBusy = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrator\narrator.cpp ===
/*************************************************************************
    Project:    Narrator
    Module:     narrator.c

    Author:     Paul Blenkhorn 
    Date:       April 1997

    Notes:      Contains main application initalization code
                Credit to be given to MSAA team - bits of code have been
                lifted from:
                Babble, Inspect, and Snapshot.

    Copyright (C) 1997-1999 by Microsoft Corporation.  All rights reserved.
    See bottom of file for disclaimer

    History: Bug Fixes/ New features/ Additions: 1999 Anil Kumar

*************************************************************************/
#define STRICT

#include <windows.h>
#include <windowsx.h>
#include <oleacc.h>
#include <string.h>
#include <stdio.h>
#include <mmsystem.h>
#include <initguid.h>
#include <objbase.h>
#include <objerror.h>
#include <ole2ver.h>
#include <commctrl.h>
#include "Narrator.h"
#include "resource.h"
#include <htmlhelp.h>
#include "reader.h"
#include "..\NarrHook\keys.h"
#include "w95trace.c"
#include "DeskSwitch.c"

// Bring in Speech API declarations
// The SAPI5 define determines whether SAPI5 or SAPI4 is used.  Comment out
// the next line to use SAPI4.
#define SAPI5
#ifndef SAPI5
#include "speech.h"
#else
#include "sapi.h"
#endif
#include <stdlib.h>

// UM
#include <TCHAR.h>
#include <string.h>
#include <WinSvc.h>
#include <stdio.h>

#define MAX_ENUMMODES 80
#define MAX_LANGUAGES 27
#define MAX_NAMELEN   30	// number of characters in the name excluding the path info
#define WM_DELAYEDMINIMIZE WM_USER + 102
#define ARRAYSIZE(n)    (sizeof(n)/sizeof(n[0]))

#ifndef SAPI5
// TTS info
TTSMODEINFO gaTTSInfo[MAX_ENUMMODES];
PIAUDIOMULTIMEDIADEVICE    pIAMM;      // multimedia device interface for audio-dest
#endif

DEFINE_GUID(MSTTS_GUID, 
0xC5C35D60, 0xDA44, 0x11D1, 0xB1, 0xF1, 0x0, 0x0, 0xF8, 0x03, 0xE4, 0x56);


// language test table, taken from WINNT.h...
LPTSTR Languages[MAX_LANGUAGES]={
    TEXT("NEUTRAL"),TEXT("BULGARIAN"),TEXT("CHINESE"),TEXT("CROATIAN"),TEXT("CZECH"),
    TEXT("DANISH"),TEXT("DUTCH"),TEXT("ENGLISH"),TEXT("FINNISH"),
    TEXT("FRENCH"),TEXT("GERMAN"),TEXT("GREEK"),TEXT("HUNGARIAN"),TEXT("ICELANDIC"),
    TEXT("ITALIAN"),TEXT("JAPANESE"),TEXT("KOREAN"),TEXT("NORWEGIAN"),
    TEXT("POLISH"),TEXT("PORTUGUESE"),TEXT("ROMANIAN"),TEXT("RUSSIAN"),TEXT("SLOVAK"),
    TEXT("SLOVENIAN"),TEXT("SPANISH"),TEXT("SWEDISH"),TEXT("TURKISH")};

WORD LanguageID[MAX_LANGUAGES]={
    LANG_NEUTRAL,LANG_BULGARIAN,LANG_CHINESE,LANG_CROATIAN,LANG_CZECH,LANG_DANISH,LANG_DUTCH,
    LANG_ENGLISH,LANG_FINNISH,LANG_FRENCH,LANG_GERMAN,LANG_GREEK,LANG_HUNGARIAN,LANG_ICELANDIC,
    LANG_ITALIAN,LANG_JAPANESE,LANG_KOREAN,LANG_NORWEGIAN,LANG_POLISH,LANG_PORTUGUESE,
    LANG_ROMANIAN,LANG_RUSSIAN,LANG_SLOVAK,LANG_SLOVENIAN,LANG_SPANISH,LANG_SWEDISH,LANG_TURKISH};

// Start Type
DWORD StartMin = FALSE;
// Show warning
DWORD ShowWarn = TRUE;

// the total number of enumerated modes
DWORD gnmodes=0;                        

// Local functions
#ifndef SAPI5
PITTSCENTRAL FindAndSelect(PTTSMODEINFO pTTSInfo);
#endif
BOOL InitTTS(void);
BOOL UnInitTTS(void);

// Dialog call back procs
INT_PTR CALLBACK MainDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AboutDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ConfirmProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK WarnDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL InitApp(HINSTANCE hInstance, int nCmdShow);
BOOL UnInitApp(void);
BOOL SpeakString(TCHAR * pszSpeakText, BOOL forceRead, DWORD dwFlags);
void Shutup(void);
int MessageBoxLoadStrings (HWND hWnd,UINT uIDText,UINT uIDCaption,UINT uType);
void SetRegistryValues();
BOOL SetVolume (int nVolume);
BOOL SetSpeed (int nSpeed);
BOOL SetPitch (int nPitch);
DWORD GetDesktop();
void CenterWindow(HWND);
void FilterSpeech(TCHAR* szSpeak);


// Global varibles
TCHAR               g_szLastStringSpoken[MAX_TEXT] = { NULL };
HWND				g_hwndMain = NULL;
HINSTANCE			g_hInst;
BOOL				g_fAppExiting = FALSE;

int currentVoice = -1;

#ifndef SAPI5
PITTSCENTRAL		g_pITTSCentral;
PITTSENUM			g_pITTSEnum = NULL;
PITTSATTRIBUTES		g_pITTSAttributes = NULL;
#else
ISpObjectToken *g_pVoiceTokens[80];
WCHAR g_szCurrentVoice[256];
WCHAR *g_szVoices[80];

ISpVoice            *g_pISpV = NULL;
#define SPEAK_NORMAL    SPF_ASYNC | SPF_IS_NOT_XML
#define SPEAK_XML       SPF_ASYNC | SPF_PERSIST_XML
#define SPEAK_MUTE      SPF_PURGEBEFORESPEAK
//
//  Simple inline function converts a ulong to a hex string.
//
inline void SpHexFromUlong(WCHAR * psz, ULONG ul)
{
    const static WCHAR szHexChars[] = L"0123456789ABCDEF";
    if (ul == 0)    
    {        
        psz[0] = L'0';
        psz[1] = 0;    
    }
    else    
    {        
        ULONG ulChars = 1;
        psz[0] = 0;

        while (ul)        
        {            
            memmove(psz + 1, psz, ulChars * sizeof(WCHAR));
            psz[0] = szHexChars[ul % 16];
            ul /= 16;            
            ulChars++;
        }    
    }
}


inline HRESULT SpEnumTokens(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    IEnumSpObjectTokens ** ppEnum)
{
    HRESULT hr = S_OK;
    const BOOL fCreateIfNotExist = FALSE;
    
    ISpObjectTokenCategory *cpCategory;
    hr = CoCreateInstance(CLSID_SpObjectTokenCategory, NULL, CLSCTX_ALL, 
                          __uuidof(ISpObjectTokenCategory), 
                          reinterpret_cast<void **>(&cpCategory) );
    
    if (SUCCEEDED(hr))
        hr = cpCategory->SetId(pszCategoryId, fCreateIfNotExist);
    
    if (SUCCEEDED(hr))
        hr = cpCategory->EnumTokens( pszReqAttribs, pszOptAttribs, ppEnum);
        
    cpCategory->Release();
    
    return hr;
}

#endif

DWORD minSpeed, maxSpeed, lastSpeed = -1, currentSpeed = 5;
WORD minPitch, maxPitch, lastPitch = -1, currentPitch = 5;
DWORD minVolume, maxVolume, lastVolume = -1, currentVolume = 5;

#define SET_VALUE(fn, newVal, lastVal) \
{ \
    if (lastVal != newVal) {\
        fn(newVal); \
        lastVal = newVal; \
    } \
}

inline void SetDialogIcon(HWND hwnd)
{
    HANDLE hIcon = LoadImage( g_hInst, MAKEINTRESOURCE(IDI_ICON1), 
                               IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
    if(hIcon)
         SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);

}

// Combo box support
int GetComboItemData(HWND hwnd);
void FillAndSetCombo(HWND hwnd, int iMinVal, int iMaxVal, int iSelVal);


BOOL				g_startUM = FALSE; // Started from Utililty Manager
HANDLE              g_hMutexNarratorRunning;
BOOL				logonCheck = FALSE;	

// UM stuff
static BOOL  AssignDesktop(LPDWORD desktopID, LPTSTR pname);
static BOOL InitMyProcessDesktopAccess(VOID);
static VOID ExitMyProcessDesktopAccess(VOID);
static HWINSTA origWinStation = NULL;
static HWINSTA userWinStation = NULL;
// Keep a global desktop ID
DWORD desktopID;


// For Link Window
EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;

// For Utility Manager
#define UTILMAN_DESKTOP_CHANGED_MESSAGE   __TEXT("UtilityManagerDesktopChanged")
#define DESKTOP_ACCESSDENIED 0
#define DESKTOP_DEFAULT      1
#define DESKTOP_SCREENSAVER  2
#define DESKTOP_WINLOGON     3
#define DESKTOP_TESTDISPLAY  4
#define DESKTOP_OTHER        5


//CS help
DWORD g_rgHelpIds[] = {	IDC_VOICESETTINGS, 70600,
						IDC_VOICE, 70605,
						IDC_NAME, 70605,
						IDC_COMBOSPEED, 70610,
						IDC_COMBOVOLUME, 70615,
						IDC_COMBOPITCH, 70620,
                        IDC_MODIFIERS, 70645,
                        IDC_ANNOUNCE, 70710,
						IDC_READING, 70625,
                        IDC_MOUSEPTR, 70695,
						IDC_MSRCONFIG, 70600,
						IDC_STARTMIN, 70705,
						IDC_EXIT, -1,
						IDC_MSRHELP, -1,
						IDC_CAPTION, -1
                        };

/*************************************************************************
Function:   WinMain
Purpose:    Entry point of application
Inputs:
Returns:    Int containing the return value of the app.
History:
*************************************************************************/
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    UINT deskSwitchMsg;

	// Get the commandline so that it works for MUI/Unicode
	LPTSTR lpCmdLineW = GetCommandLine();
  
	if(NULL != lpCmdLineW && lstrlen(lpCmdLineW))
	{
	    LPTSTR psz = wcschr(lpCmdLineW,_TEXT('/'));
	    if (psz && lstrcmpi(psz, TEXT("/UM")) == 0)
        {
			g_startUM = TRUE;
        }
	}

	// Don't allow multiple versions of Narrator running at a time.  If
    // this instance was started by UtilMan then the code tries up to 4 
    // times to detect the absence of the narrator mutex;  during a 
    // desktop switch we need to wait for the old narrator to quit.

    int cTries;
    for (cTries=0;cTries < 4;cTries++)
    {
	    g_hMutexNarratorRunning = CreateMutex(NULL, TRUE, TEXT("AK:NarratorRunning"));
	    if (g_hMutexNarratorRunning && GetLastError() == ERROR_SUCCESS)
            break;    // mutex created and it didn't already exist

        // cleanup before possible retry
        if (g_hMutexNarratorRunning)
        {
            CloseHandle(g_hMutexNarratorRunning);
            g_hMutexNarratorRunning = 0;
        }

		if (!g_startUM)
            break;    // not started by UtilMan but there's another narrator running

        // pause...
        Sleep(500);
    }
    if (!g_hMutexNarratorRunning || cTries >= 4)
        return 0;   // fail to start narrator
	
    InitCommonControls();

	// for the Link Window in finish page...
	LinkWindow_RegisterClass();

    // Initialization
    g_hInst = hInstance;

    TCHAR name[300];

    // For Multiple desktops (UM)
    deskSwitchMsg = RegisterWindowMessage(UTILMAN_DESKTOP_CHANGED_MESSAGE);

    InitMyProcessDesktopAccess();
	AssignDesktop(&desktopID,name);

    SpewOpenFile(TEXT("NarratorSpew.txt"));

    if (InitApp(hInstance, nCmdShow))
    {
        MSG     msg;

        // Main message loop
        while (GetMessage(&msg, NULL, 0, 0))
        {
            if (!IsDialogMessage(g_hwndMain, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);

                if (msg.message == deskSwitchMsg)
                {
                    g_fAppExiting = TRUE;

                    UnInitApp();
                }
            }
        }
    }

    SpewCloseFile();

    // UM
    ExitMyProcessDesktopAccess();
    return 0;
}


/*************************************************************************
Function:
Purpose:
Inputs:
Returns:
History:
*************************************************************************/
LPTSTR LangIDtoString( WORD LangID )
{
    int i;
    for( i=0; i<MAX_LANGUAGES; i++ )
    {
        if( (LangID & 0xFF) == LanguageID[i] )
            return Languages[i];
    }

    return NULL;
}

#ifndef SAPI5
/*************************************************************************
Function:
Purpose: Get the range for speed, pitch etc..,
Inputs:
Returns:
History:
*************************************************************************/
void GetSpeechMinMaxValues(void)
{
    WORD	tmpPitch;
    DWORD	tmpSpeed;
    DWORD	tmpVolume;

    g_pITTSAttributes->PitchGet(&tmpPitch);
    g_pITTSAttributes->PitchSet(TTSATTR_MAXPITCH);
    g_pITTSAttributes->PitchGet(&maxPitch);
    g_pITTSAttributes->PitchSet(TTSATTR_MINPITCH);
    g_pITTSAttributes->PitchGet(&minPitch);
    g_pITTSAttributes->PitchSet(tmpPitch);

    g_pITTSAttributes->SpeedGet(&tmpSpeed);
    g_pITTSAttributes->SpeedSet(TTSATTR_MINSPEED);
    g_pITTSAttributes->SpeedGet(&minSpeed);
    g_pITTSAttributes->SpeedSet(TTSATTR_MAXSPEED);
    g_pITTSAttributes->SpeedGet(&maxSpeed);
    g_pITTSAttributes->SpeedSet(tmpSpeed);

    g_pITTSAttributes->VolumeGet(&tmpVolume);
    g_pITTSAttributes->VolumeSet(TTSATTR_MINVOLUME);
    g_pITTSAttributes->VolumeGet(&minVolume);
    g_pITTSAttributes->VolumeSet(TTSATTR_MAXVOLUME);
    g_pITTSAttributes->VolumeGet(&maxVolume);
    g_pITTSAttributes->VolumeSet(tmpVolume);
}
#endif

/*************************************************************************
    Function:   VoiceDlgProc
    Purpose:    Handles messages for the Voice Box dialog
    Inputs:
    Returns:
    History:
*************************************************************************/
INT_PTR CALLBACK VoiceDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static WORD oldVoice, oldPitch;
    static DWORD oldSpeed, oldVolume;
	static HWND hwndList;
	WORD	wNewPitch;
	
	DWORD   i;
	int     Selection;
	
	TCHAR   szTxt[MAX_TEXT];
	HRESULT hRes;
	
	szTxt[0]=TEXT('\0');
	
	switch (uMsg)
	{
		case WM_INITDIALOG:
			oldVoice = currentVoice; // save voice parameters in case of CANCEL
			oldPitch = currentPitch;
			oldVolume = currentVolume;
			oldSpeed = currentSpeed;
			
			Shutup();

			hwndList = GetDlgItem(hwnd, IDC_NAME);
			SetDialogIcon(hwnd);

			// Only allow picking a voice when not on secure desktop
			if ( !logonCheck )
			{
#ifndef SAPI5
				for (i = 0; i < gnmodes; i++)
				{
					lstrcpyn(szTxt,gaTTSInfo[i].szModeName,MAX_TEXT);
					lstrcatn(szTxt,TEXT(", "),MAX_TEXT);
					
					lstrcatn(szTxt,
						LangIDtoString(gaTTSInfo[i].language.LanguageID),
						MAX_TEXT);
					lstrcatn(szTxt,TEXT(", "),MAX_TEXT);
					
					lstrcatn(szTxt,gaTTSInfo[i].szMfgName,MAX_TEXT);
					
					SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM) szTxt);
				}
#else
                // Show the description for the voice narrator is using
            	for ( int i = 0; i < ARRAYSIZE( g_szVoices ) && g_szVoices[i] != NULL; i++ )
            	{
        	        SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM) g_szVoices[i] );
            	}
            	
                hRes = g_pISpV->SetVoice( g_pVoiceTokens[currentVoice] );
				if ( FAILED(hRes) )
                    DBPRINTF (TEXT("SetVoice failed hr=0x%lX\r\n"),hRes);
#endif
            	SendMessage(hwndList, LB_SETCURSEL, currentVoice, 0L);
			}
			else
			{
				LoadString(g_hInst, IDS_SAM, szTxt, MAX_TEXT);

				SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM) szTxt);
				EnableWindow(hwndList, FALSE);
			}
            FillAndSetCombo(GetDlgItem(hwnd, IDC_COMBOSPEED), 1, 9, currentSpeed);
            FillAndSetCombo(GetDlgItem(hwnd, IDC_COMBOVOLUME), 1, 9, currentVolume);
            FillAndSetCombo(GetDlgItem(hwnd, IDC_COMBOPITCH), 1, 9, currentPitch);

			break;
			
			
		case WM_COMMAND:
            {
			DWORD	dwValue;
			int control = LOWORD(wParam);
			switch (LOWORD(wParam))
			{
				case IDC_NAME:
					hwndList = GetDlgItem(hwnd,IDC_NAME);

					Selection = (WORD) SendMessage(hwndList, LB_GETCURSEL,0, 0L);
					if (Selection < 0 || Selection > 79)
						Selection = 0;
					Shutup();
#ifndef SAPI5
					if (currentVoice != Selection) 
					{ // voice changed!
						MessageBeep(MB_OK);
						currentVoice = (WORD)Selection;
						// Get the audio dest
						g_pITTSCentral->Release();
						
						if ( pIAMM )
						{
							pIAMM->Release();
							pIAMM = NULL;
						}

						hRes = CoCreateInstance(CLSID_MMAudioDest,
							NULL,
							CLSCTX_ALL,
							IID_IAudioMultiMediaDevice,
							(void**)&pIAMM);

						if (FAILED(hRes))
							return TRUE;     // error

						hRes = g_pITTSEnum->Select( gaTTSInfo[Selection].gModeID,
							&g_pITTSCentral,
							(LPUNKNOWN) pIAMM);
						
						if (FAILED(hRes))
							MessageBeep(MB_OK);
						g_pITTSAttributes->Release();
						
						hRes = g_pITTSCentral->QueryInterface (IID_ITTSAttributes, (void**)&g_pITTSAttributes);
					}
					
					GetSpeechMinMaxValues(); // get speech parameters for this voice
#else
                    if (  currentVoice != Selection )
                    {
                        currentVoice = Selection;
                        hRes = g_pISpV->SetVoice( g_pVoiceTokens[currentVoice] );
                        if ( FAILED(hRes) )
                        {   
                            DBPRINTF (TEXT("SetVoice failed hr=0x%lX\r\n"),hRes);
                        }
                        SendMessage(hwndList, LB_SETCURSEL, currentVoice, 0L);
                    }
#endif
					// then reset pitch etc. accordingly
                    currentPitch = GetComboItemData(GetDlgItem(hwnd, IDC_COMBOPITCH));
                    currentSpeed = GetComboItemData(GetDlgItem(hwnd, IDC_COMBOSPEED));
                    currentVolume = GetComboItemData(GetDlgItem(hwnd, IDC_COMBOVOLUME));

                    SET_VALUE(SetPitch, currentPitch, lastPitch)
                    SET_VALUE(SetSpeed, currentSpeed, lastSpeed)
                    SET_VALUE(SetVolume, currentVolume, lastVolume)
					
					break;
				
				case IDC_COMBOSPEED:
					if (IsWindowVisible(GetDlgItem(hwnd, control)))
					{
                        dwValue = GetComboItemData(GetDlgItem(hwnd, control));
                        SET_VALUE(SetSpeed, dwValue, lastSpeed)
					}
					break;
				
				case IDC_COMBOVOLUME:
					if (IsWindowVisible(GetDlgItem(hwnd, control)))
					{
                        dwValue = GetComboItemData(GetDlgItem(hwnd, control));
                        SET_VALUE(SetVolume, dwValue, lastVolume)
					}
					break;
				
				case IDC_COMBOPITCH:
					if (IsWindowVisible(GetDlgItem(hwnd, control)))
					{
                        dwValue = GetComboItemData(GetDlgItem(hwnd, control));
                        SET_VALUE(SetPitch, dwValue, lastPitch)
					}
					break;
				
				case IDCANCEL:
					MessageBeep(MB_OK);
					Shutup();
#ifndef SAPI5
					if (currentVoice != oldVoice) 
					{ // voice changed!
						currentVoice = oldVoice;
						
						// Get the audio dest
						g_pITTSCentral->Release();

						if ( pIAMM )
						{
							pIAMM->Release();
							pIAMM = NULL;
						}

						hRes = CoCreateInstance(CLSID_MMAudioDest,
							NULL,
							CLSCTX_ALL,
							IID_IAudioMultiMediaDevice,
							(void**)&pIAMM);

						if (FAILED(hRes))
							return TRUE;     // error

						hRes = g_pITTSEnum->Select( gaTTSInfo[currentVoice].gModeID,
							&g_pITTSCentral,
							(LPUNKNOWN) pIAMM);

						if (FAILED(hRes))
							MessageBeep(MB_OK);
						
						g_pITTSAttributes->Release();
						hRes = g_pITTSCentral->QueryInterface (IID_ITTSAttributes, (void**)&g_pITTSAttributes);
					}
					
					GetSpeechMinMaxValues(); // speech get parameters for old voice
#endif
                    currentPitch = oldPitch; // restore old values
                    SET_VALUE(SetPitch, currentPitch, lastPitch)

                    currentSpeed = oldSpeed;
                    SET_VALUE(SetSpeed, currentSpeed, lastSpeed)

                    currentVolume = oldVolume;
                    SET_VALUE(SetVolume, currentVolume, lastVolume)

                    EndDialog (hwnd, IDCANCEL);
					return(TRUE);

				case IDOK: // set values of pitch etc. from check boxes

                    currentPitch = GetComboItemData(GetDlgItem(hwnd, IDC_COMBOPITCH));
                    currentSpeed = GetComboItemData(GetDlgItem(hwnd, IDC_COMBOSPEED));
                    currentVolume = GetComboItemData(GetDlgItem(hwnd, IDC_COMBOVOLUME));

                    SET_VALUE(SetPitch, currentPitch, lastPitch)
                    SET_VALUE(SetSpeed, currentSpeed, lastSpeed)
                    SET_VALUE(SetVolume, currentVolume, lastVolume)

                    SetRegistryValues();
					EndDialog (hwnd, IDOK);
					return(TRUE);
			} // end switch on control of WM_COMMAND
            }
			break;

        case WM_CONTEXTMENU:  // right mouse click
			if ( !RunSecure(GetDesktop()) )
			{
				WinHelp((HWND) wParam, __TEXT("reader.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_rgHelpIds);
			}
            break;

		case WM_CLOSE:
				EndDialog (hwnd, IDOK);
				return TRUE;
			break;

        case WM_HELP:
			if ( !RunSecure(GetDesktop()) )
			{
				WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, __TEXT("reader.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_rgHelpIds);
			}
            return(TRUE);

	} // end switch uMsg

	return(FALSE);  // didn't handle
}



/*************************************************************************
    Function:   SetVolume
    Purpose:    set volume to a normalized value 1-9
    Inputs:     int volume in range 1-9
    Returns:
    History:    At the application layer, volume is a number from 0 to 100 
                where 100 is the maximum value for a voice. It is a linear 
                progression so that a value 50 represents half of the loudest 
                permitted. The increments should be the range divided by 100.
*************************************************************************/
BOOL SetVolume (int nVolume)
{
#ifndef SAPI5
	DWORD	dwNewVolume;
	WORD	wNewVolumeLeft,
			wNewVolumeRight;

	//ASSERT (nVolume >= 1 && nVolume <= 9);
	wNewVolumeLeft = (WORD)( (LOWORD(minVolume) + (((LOWORD(maxVolume) - LOWORD(minVolume))/9.0)*nVolume)) );
	wNewVolumeRight = (WORD)( (HIWORD(minVolume) + (((HIWORD(maxVolume) - HIWORD(minVolume))/9.0)*nVolume)) );
	dwNewVolume = MAKELONG (wNewVolumeLeft,wNewVolumeRight);

    return (SUCCEEDED(g_pITTSAttributes->VolumeSet(dwNewVolume)));
#else
	USHORT 		usNewVolume;
	HRESULT		hr;	

	if(nVolume < 1) nVolume = 1;
	if(nVolume > 9) nVolume = 9;
	//calculate a value between 10 and 90
	usNewVolume = (USHORT)( nVolume * 10 ); 
	hr = g_pISpV->SetVolume(usNewVolume); 
    return	SUCCEEDED(hr);
#endif
}

/*************************************************************************
    Function:   SetSpeed
    Purpose:    set Speed to a normalized value 1-9
    Inputs:     int Speed in range 1-9
    Returns:
    History:    The value can range from -10 to +10. 
	            A value of 0 sets a voice to speak at its default rate. 
	            A value of -10 sets a voice to speak at one-sixth of its default rate. 
	            A value of +10 sets a voice to speak at 6 times its default rate. 
	            Each increment between -10 and +10 is logarithmically distributed such 
	            that incrementing or decrementing by 1 is multiplying or dividing the 
	            rate by the 10th root of 6 (about 1.2). Values more extreme than -10 and +10 
	            will be passed to an engine. However, SAPI 5.0-compliant engines may not 
	            support such extremes and may clip the rate to the maximum or minimum 
                rate it supports.
*************************************************************************/
BOOL SetSpeed (int nSpeed)
{
#ifndef SAPI5
	DWORD	dwNewSpeed;

	//ASSERT (nSpeed >= 1 && nSpeed <= 9);
	dwNewSpeed = minSpeed + (DWORD) ((maxSpeed-minSpeed)/9.0*nSpeed);
	return (SUCCEEDED(g_pITTSAttributes->SpeedSet(dwNewSpeed)));
#else
	long		lNewSpeed;				
	HRESULT		hr;	

	if(nSpeed < 1) nSpeed = 1;		
	if(nSpeed > 9) nSpeed = 9;		
	switch(nSpeed)					
	{							
	    case 1:		lNewSpeed = -8;		break;
	    case 2:		lNewSpeed = -6;		break;
	    case 3:		lNewSpeed = -4;		break;
	    case 4:		lNewSpeed = -2;		break;
	    case 5:		lNewSpeed = 0;		break;
	    case 6:		lNewSpeed = 2;		break;
	    case 7:		lNewSpeed = 4;		break;
	    case 8:		lNewSpeed = 6;		break;
	    case 9:		lNewSpeed = 8;		break;
	    default:	lNewSpeed = 0;		break;
	}
	hr = g_pISpV->SetRate(lNewSpeed); 
	return SUCCEEDED(hr);			
#endif
}

/*************************************************************************
    Function:   SetPitch
    Purpose:    set Pitch to a normalized value 1-9
    Inputs:     int Pitch in range 1-9
    Returns:
    History:    The value can range from -10 to +10. A value of 0 sets a voice to speak at 
                its default pitch. A value of -10 sets a voice to speak at three-fourths of 
                its default pitch. A value of +10 sets a voice to speak at four-thirds of 
                its default pitch. Each increment between -10 and +10 is logarithmically 
                distributed such that incrementing or decrementing by 1 is multiplying or 
                dividing the pitch by the 24th root of 2 (about 1.03). Values outside of 
                the -10 and +10 range will be passed to an engine. However, SAPI 5.0-compliant 
                engines may not support such extremes and may clip the pitch to the maximum or 
                minimum it supports. Values of -24 and +24 must lower and raise pitch by 1 octave 
                respectively. All incrementing or decrementing by 1 must multiply or divide the 
                pitch by the 24th root of 2.

                Pitch changes can only be submitted via ::Speak using XML embedded in a string.

*************************************************************************/
BOOL SetPitch (int nPitch)
{
#ifndef SAPI5
	WORD	wNewPitch;

	wNewPitch = (WORD)((minPitch + (((maxPitch - minPitch)/9.0)*nPitch)));
	return (SUCCEEDED(g_pITTSAttributes->PitchSet(wNewPitch)));
#else
	if(nPitch < 1) nPitch = 1;		
	if(nPitch > 9) nPitch = 9;	
    
	int	nNewPitch;			
	switch(nPitch)					
	{								
	    case 1:		nNewPitch = -8;		break;
	    case 2:		nNewPitch = -6;		break;
	    case 3:		nNewPitch = -4;		break;
	    case 4:		nNewPitch = -2;		break;
	    case 5:		nNewPitch = 0;		break;
	    case 6:		nNewPitch = 2;		break;
	    case 7:		nNewPitch = 4;		break;
	    case 8:		nNewPitch = 6;		break;
	    case 9:		nNewPitch = 8;		break;
	    default:	nNewPitch = 0;		break;
	}

    LPTSTR pszSpeak = new TCHAR[60];
    if (pszSpeak)
    {
	    wsprintf(pszSpeak,L"<PITCH ABSMIDDLE=\"%d\"/>",nNewPitch);
	    SpeakString(pszSpeak, TRUE, SPEAK_XML);
        delete [] pszSpeak;
    }

	return TRUE;		
#endif
}

#define TIMERID 6466
/*************************************************************************
    Function:   MainDlgProc
    Purpose:    Handles messages for the Main dialog
    Inputs:
    Returns:
    History:
*************************************************************************/
INT_PTR CALLBACK MainDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szText[MAX_TEXT];
    switch (uMsg)
        {
        case WM_INITDIALOG:
            {
	    	    SetDialogIcon(hwnd);
	    	    
			    // Disable Help button on other desktops
                BOOL fRunSecure = RunSecure(GetDesktop());
			    if ( fRunSecure )
			    {
				    EnableWindow(GetDlgItem(hwnd, IDC_MSRHELP), FALSE);
			    }

			    CheckDlgButton(hwnd,IDC_MOUSEPTR,GetTrackInputFocus());
			    CheckDlgButton(hwnd,IDC_READING,GetEchoChars());
			    CheckDlgButton(hwnd,IDC_ANNOUNCE,GetAnnounceWindow());
			    CheckDlgButton(hwnd,IDC_STARTMIN,StartMin);
			    
			    // To show the warning message on default desktop...
                if (ShowWarn && !fRunSecure)
    			    SetTimer(hwnd, TIMERID, 20, NULL);

                // Enable desktop switching detection
                InitWatchDeskSwitch(hwnd, WM_MSRDESKSW);
            }
            break;

		case WM_TIMER:
			KillTimer(hwnd, (UINT)wParam);
		    DialogBox (g_hInst, MAKEINTRESOURCE(IDD_WARNING),hwnd, WarnDlgProc);
            return TRUE;
			break;

        case WM_WININICHANGE:
            if (g_fAppExiting) break;

            // If someone else turns off the system-wide screen reader
            // flag, we want to turn it back on.
            if (wParam == SPI_SETSCREENREADER && !lParam)
                SystemParametersInfo(SPI_SETSCREENREADER, TRUE, NULL, SPIF_UPDATEINIFILE|SPIF_SENDCHANGE);
            return 0;

		case WM_DELAYEDMINIMIZE:
			// Delayed mimimize message
			ShowWindow(hwnd, SW_HIDE);
			ShowWindow(hwnd, SW_MINIMIZE);
			break;

		case WM_MUTE:
			Shutup();
			break;

        case WM_MSRSPEAK:
            GetCurrentText(szText, MAX_TEXT);
			SpeakString(szText, TRUE, SPEAK_NORMAL);
			break;

        case WM_MSRSPEAKXML:
            GetCurrentText(szText, MAX_TEXT);
			SpeakString(szText, TRUE, SPEAK_XML);
			break;

        case WM_MSRSPEAKMUTE:
            SpeakString(NULL, TRUE, SPEAK_MUTE);
            break;

        case WM_CLOSE:
        case WM_MSRDESKSW:
            // When the desktop changes, if UtilMan is running and FUS isn't
            // enabled then exit (when FUS is enabled we don't have to worry
            // about running on another desktop therefore we don't need to
            // exit).  UtilMan will start us up again if necessary.
            Shutup();
            g_startUM = IsUtilManRunning();
            // Jan23,2001 Optimization to FUS piggybacks the winlogon desktop
            // to the session being switch from.  This means we have to quit
            // in case user needs to run from the winlogon desktop.
            if (uMsg == WM_MSRDESKSW && (!g_startUM /*|| !CanLockDesktopWithoutDisconnect()*/))
                break;  // ignore message

            // UtilMan is managing starting us.  UtilMan will 
            // start us up again if necessary so quit...

        case WM_MSRQUIT:
			// Do not show an exit confirmation if started from UM and not at logon desktop
			if ( !g_startUM && !RunSecure(GetDesktop()) )
			{
				if (IDOK != DialogBox(g_hInst, MAKEINTRESOURCE(IDD_CONFIRMEXIT), g_hwndMain, ConfirmProc))
					return(FALSE);
			}
            // Intentional fall through

		case WM_DESTROY:
            // Required for desktop switches :a-anilk
            g_fAppExiting = TRUE;
			g_hwndMain = NULL;

            TermWatchDeskSwitch();    // Terminate the desktop switch thread
			UnInitApp();
            
			if ( g_hMutexNarratorRunning ) 
				ReleaseMutex(g_hMutexNarratorRunning);
            // Let others know that you are turning off the system-wide
		    // screen reader flag.
            SystemParametersInfo(SPI_SETSCREENREADER, FALSE, NULL, SPIF_UPDATEINIFILE|SPIF_SENDCHANGE);

            EndDialog (hwnd, IDCANCEL);
            PostQuitMessage(0);

            return(TRUE);

		case WM_MSRHELP:
            // Show HTML help
			if ( !RunSecure(GetDesktop()) )
			{
				 HtmlHelp(hwnd ,TEXT("reader.chm"),HH_DISPLAY_TOPIC, 0);
			}
			break;

		case WM_MSRCONFIGURE:
			DialogBox (g_hInst, MAKEINTRESOURCE(IDD_VOICE),hwnd, VoiceDlgProc);
			break;

		case WM_HELP:
			if ( !RunSecure(GetDesktop()) )
			{
				HtmlHelp(hwnd ,TEXT("reader.chm"),HH_DISPLAY_TOPIC, 0);
			}
			break;

		case WM_CONTEXTMENU:  // right mouse click
			if ( !RunSecure(GetDesktop()) )
			{
				WinHelp((HWND) wParam, __TEXT("reader.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_rgHelpIds);
			}
            break;

        case WM_SYSCOMMAND:
	        if ((wParam & 0xFFF0) == IDM_ABOUTBOX)
            {
		        DialogBox (g_hInst, MAKEINTRESOURCE(IDD_ABOUTBOX),hwnd,AboutDlgProc);
                return TRUE;
	        }
            break;
            
        // case WM_QUERYENDSESSION:
		// return TRUE;

		case WM_ENDSESSION:
		{
			 HKEY hKey;
			 DWORD dwPosition;
			 const TCHAR szSubKey[] =  __TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
			 const TCHAR szImageName[] = __TEXT("Narrator.exe");
             		 const TCHAR szValueName[] = __TEXT("RunNarrator");

			 if ( ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szSubKey, 0, NULL,
				 REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hKey, &dwPosition))
			 {
				 RegSetValueEx(hKey, (LPCTSTR) szValueName, 0, REG_SZ, (CONST BYTE*)szImageName, (lstrlen(szImageName)+1)*sizeof(TCHAR) );
				 RegCloseKey(hKey);
			 }
		}
        return 0;

        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
			case IDC_MSRHELP :
				PostMessage(hwnd, WM_MSRHELP,0,0);
				break;

			case IDC_MINIMIZE:
				BackToApplication();
				break;

			case IDC_MSRCONFIG :
				PostMessage(hwnd, WM_MSRCONFIGURE,0,0);
				break;

			case IDC_EXIT :
				PostMessage(hwnd, WM_MSRQUIT,0,0);
				break;

			case IDC_ANNOUNCE:
				SetAnnounceWindow(IsDlgButtonChecked(hwnd,IDC_ANNOUNCE));
				SetAnnounceMenu(IsDlgButtonChecked(hwnd,IDC_ANNOUNCE));
                SetAnnouncePopup(IsDlgButtonChecked(hwnd,IDC_ANNOUNCE));
				break;

			case IDC_READING:
				if (IsDlgButtonChecked(hwnd,IDC_READING))
					SetEchoChars(MSR_ECHOALNUM | MSR_ECHOSPACE | MSR_ECHODELETE | MSR_ECHOMODIFIERS 
								 | MSR_ECHOENTER | MSR_ECHOBACK | MSR_ECHOTAB);
				else
					SetEchoChars(0);
				SetRegistryValues();	
				break;

			case IDC_MOUSEPTR:
				SetTrackInputFocus(IsDlgButtonChecked(hwnd,IDC_MOUSEPTR));
				SetTrackCaret(IsDlgButtonChecked(hwnd,IDC_MOUSEPTR));
				break;

			case IDC_STARTMIN:
				StartMin = IsDlgButtonChecked(hwnd,IDC_STARTMIN);
				break;
        }
	}
    return(FALSE);  // didn't handle
}

/*************************************************************************
    Function:   AboutDlgProc
    Purpose:    Handles messages for the About Box dialog
    Inputs:
    Returns:
    History:
*************************************************************************/
INT_PTR CALLBACK AboutDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
			Shutup();
			SetDialogIcon(hwnd);

			// If minimized, Center on the desktop..
			if ( IsIconic(g_hwndMain) )
			{
				CenterWindow(hwnd);
			}
            if (RunSecure(GetDesktop()) )
            {
                EnableWindow(GetDlgItem(hwnd, IDC_ENABLEWEBA), FALSE); 
            }
			return TRUE;

			break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
				case IDOK:
                case IDCANCEL:
					Shutup();
                    EndDialog (hwnd, IDCANCEL);
                    return(TRUE);
                }
				break;

				case WM_NOTIFY:
					{
						INT idCtl		= (INT)wParam;
						LPNMHDR pnmh	= (LPNMHDR)lParam;
						switch ( pnmh->code)
						{
							case NM_RETURN:
							case NM_CLICK:
							if ( idCtl == IDC_ENABLEWEBA && !RunSecure(GetDesktop()) )
							{
								TCHAR webAddr[256];
								LoadString(g_hInst, IDS_ENABLEWEB, webAddr, 256);
								ShellExecute(hwnd, TEXT("open"), TEXT("iexplore.exe"), webAddr, NULL, SW_SHOW); 
							}
							break;
						}
					}
					break;

            };

    return(FALSE);  // didn't handle
}


/*************************************************************************
    Function:   WarnDlgProc
    Purpose:    Handles messages for the Warning dialog
    Inputs:
    Returns:
    History:
*************************************************************************/
INT_PTR CALLBACK WarnDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
			Shutup();
			SetDialogIcon(hwnd);

			// If minimized, Center on the desktop..
			if ( IsIconic(g_hwndMain) )
			{
				CenterWindow(hwnd);
			}
			return TRUE;

			break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
				case IDC_WARNING:
					ShowWarn = !(IsDlgButtonChecked(hwnd,IDC_WARNING));
				break;

				case IDOK:
                case IDCANCEL:
					Shutup();
                    EndDialog (hwnd, IDCANCEL);
                    return(TRUE);
			} 
			break;

		case WM_NOTIFY:
			{
				INT idCtl		= (INT)wParam;
				LPNMHDR pnmh	= (LPNMHDR)lParam;
				switch ( pnmh->code)
				{
					case NM_RETURN:
					case NM_CLICK:
					if ( idCtl == IDC_ENABLEWEBA && !RunSecure(GetDesktop()))
					{
						TCHAR webAddr[256];
						LoadString(g_hInst, IDS_ENABLEWEB, webAddr, 256);
						ShellExecute(hwnd, TEXT("open"), TEXT("iexplore.exe"), webAddr, NULL, SW_SHOW); 
					}
					break;
				}
			}
			break;
     };

    return(FALSE);  // didn't handle
}

#define SET_NUMREGENTRY(key, keyname, t) \
{ \
    t value = Get ## keyname(); \
    RegSetValueEx(key, TEXT(#keyname), 0, REG_DWORD, (CONST BYTE *)&value, sizeof(t)); \
}
#define GET_NUMREGENTRY(key, keyname, t) \
{ \
	DWORD dwSize = sizeof(t); \
    t value; \
	if (RegQueryValueEx(key, TEXT(#keyname), 0, NULL, (BYTE *)&value, &dwSize) == ERROR_SUCCESS) \
        Set ## keyname(value); \
}
/*************************************************************************
    Function:
    Purpose: Save registry values
    Inputs:
    Returns:
    History:
*************************************************************************/
void SetRegistryValues()
{ // set up the registry
    HKEY reg_key;	// key for the registry

    if (SUCCEEDED (RegOpenKeyEx (HKEY_CURRENT_USER,__TEXT("Software\\Microsoft\\Narrator"),0,KEY_WRITE,&reg_key)))
    {
        // These we are setting from data stored in narrhook.dll
        SET_NUMREGENTRY(reg_key, TrackCaret, BOOL)
        SET_NUMREGENTRY(reg_key, TrackInputFocus, BOOL)
        SET_NUMREGENTRY(reg_key, EchoChars, int)
        SET_NUMREGENTRY(reg_key, AnnounceWindow, BOOL)
        SET_NUMREGENTRY(reg_key, AnnounceMenu, BOOL)
        SET_NUMREGENTRY(reg_key, AnnouncePopup, BOOL)
        SET_NUMREGENTRY(reg_key, AnnounceToolTips, BOOL)
        SET_NUMREGENTRY(reg_key, ReviewLevel, int)
        // These are properties of the speech engine or narrator itself
        RegSetValueEx(reg_key,__TEXT("CurrentSpeed"),0,REG_DWORD,(unsigned char *) &currentSpeed,sizeof(currentSpeed));
        RegSetValueEx(reg_key,__TEXT("CurrentPitch"),0,REG_DWORD,(unsigned char *) &currentPitch,sizeof(currentPitch));
        RegSetValueEx(reg_key,__TEXT("CurrentVolume"),0,REG_DWORD,(unsigned char *) &currentVolume,sizeof(currentVolume));
#ifndef SAPI5
        RegSetValueEx(reg_key,__TEXT("CurrentVoice"),0,REG_DWORD,(unsigned char *) &currentVoice,sizeof(currentVoice));
#else
        RegSetValueEx(reg_key,__TEXT("CurrentVoice"),0,REG_SZ,
                      (unsigned char *) g_szVoices[currentVoice],lstrlen(g_szVoices[currentVoice])*sizeof(TCHAR)+sizeof(TCHAR));
#endif
        RegSetValueEx(reg_key,__TEXT("StartType"),0,REG_DWORD,(unsigned char *) &StartMin,sizeof(StartMin));
        RegSetValueEx(reg_key,__TEXT("ShowWarning"),0,REG_DWORD, (BYTE*) &ShowWarn,sizeof(ShowWarn));
        RegCloseKey (reg_key);
        return;
    }
}

/*************************************************************************
    Function:
    Purpose: Get Registry values
    Inputs:
    Returns:
    History:
*************************************************************************/
void GetRegistryValues()
{
	DWORD	result;
	HKEY	reg_key;
	DWORD	reg_size;

    // We use RegCreateKeyEx instead of RegOpenKeyEx to make sure that the
    // key is created if it doesn't exist. Note that if the key doesn't
    // exist, the values used will already be set. All these values are
    // globals imported from narrhook.dll
	RegCreateKeyEx(HKEY_CURRENT_USER,__TEXT("Software\\Microsoft\\Narrator"),0,
        __TEXT("MSR"),REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS, NULL, &reg_key, &result);
	if (result == REG_OPENED_EXISTING_KEY)
    {
        // These values go into narrhook DLL shared data
        GET_NUMREGENTRY(reg_key, TrackCaret, BOOL)
        GET_NUMREGENTRY(reg_key, TrackInputFocus, BOOL)
        GET_NUMREGENTRY(reg_key, EchoChars, int)
        GET_NUMREGENTRY(reg_key, AnnounceWindow, BOOL)
        GET_NUMREGENTRY(reg_key, AnnounceMenu, BOOL)
        GET_NUMREGENTRY(reg_key, AnnouncePopup, BOOL)
        GET_NUMREGENTRY(reg_key, AnnounceToolTips, BOOL)
        GET_NUMREGENTRY(reg_key, ReviewLevel, int)
        // These values go into the speech engine or narrator itself
		reg_size = sizeof(currentSpeed);
		RegQueryValueEx(reg_key,__TEXT("CurrentSpeed"),0,NULL,(unsigned char *) &currentSpeed,&reg_size);
		reg_size = sizeof(currentPitch);
		RegQueryValueEx(reg_key,__TEXT("CurrentPitch"),0,NULL,(unsigned char *) &currentPitch,&reg_size);
		reg_size = sizeof(currentVolume);
		RegQueryValueEx(reg_key,__TEXT("CurrentVolume"),0,NULL,(unsigned char *) &currentVolume,&reg_size);
#ifndef SAPI5
		reg_size = sizeof(currentVoice);
        RegQueryValueEx(reg_key,__TEXT("CurrentVoice"),0,NULL,(unsigned char *) &currentVoice,&reg_size);
#else
		reg_size = sizeof(g_szCurrentVoice);
		RegQueryValueEx(reg_key,__TEXT("CurrentVoice"),0,NULL,(unsigned char *) g_szCurrentVoice,&reg_size);
#endif
		// Minimized Value
		reg_size = sizeof(StartMin);
		RegQueryValueEx(reg_key,__TEXT("StartType"),0,NULL,(unsigned char *) &StartMin,&reg_size);
		reg_size = sizeof(ShowWarn);
		RegQueryValueEx(reg_key,__TEXT("ShowWarning"),0,NULL,(unsigned char *) &ShowWarn,&reg_size);
	}
    // If the key was just created, then these values should already be set.
	// The values are exported from narrhook.dll, and must be initialized
	// when they are declared.
	RegCloseKey (reg_key);
}


/*************************************************************************
    Function:   InitApp
    Purpose:    Initalizes the application.
    Inputs:     HINSTANCE hInstance - Handle to the current instance
                INT nCmdShow - how to present the window
    Returns:    TRUE if app initalized without error.
    History:
*************************************************************************/
BOOL InitApp(HINSTANCE hInstance, int nCmdShow)
{
    HMENU	hSysMenu;
	RECT	rcWorkArea;
	RECT	rcWindow;
	int		xPos,yPos;
	HRESULT	hr;

#ifdef SAPI5
	memset( g_szCurrentVoice, NULL, sizeof(g_szCurrentVoice) );
    wcscpy( g_szCurrentVoice, L"Microsoft Sam" );
#endif
	GetRegistryValues();
	// SMode = InitMode();

	// start COM
	hr = CoInitialize(NULL);
	if (FAILED (hr))
	{
		DBPRINTF (TEXT("CoInitialize on primary thread returned 0x%lX\r\n"),hr);
		MessageBoxLoadStrings (NULL, IDS_NO_OLE, IDS_MSR_ERROR, MB_OK);
		return FALSE;
	}
	
	// Create the TTS Objects
	// sets the global variable g_pITTSCentral
	// if it fails, will throw up a message box
	if (InitTTS())
	{
		// Initialize Microsoft Active Accessibility
		// this is in narrhook.dll
		// Installs WinEvent hook, creates helper thread
		if (InitMSAA())
		{
			// Set the system screenreader flag on.
			// e.g. Word 97 will expose the caret position.
			SystemParametersInfo(SPI_SETSCREENREADER, TRUE, NULL, SPIF_UPDATEINIFILE|SPIF_SENDCHANGE);
			
			// Create the dialog box
			g_hwndMain = CreateDialog(g_hInst, MAKEINTRESOURCE(IDD_MAIN),
											    0, MainDlgProc);

			if (!g_hwndMain)
			{
				DBPRINTF(TEXT("unable to create main dialog\r\n"));
				return(FALSE);
			}

			// Init global hot keys (need to do here because we need a hwnd)
			InitKeys(g_hwndMain);

			// set icon for this dialog if we can...
			// not an easy way to do this that I know of.
			// hIcon is in the WndClass, which means that if we change it for
			// us, we change it for everyone. Which means that we would
			// have to create a superclass that looks like a dialog but
			// has it's own hIcon. Sheesh.

			// Add "About Narrator..." menu item to system menu.
			hSysMenu = GetSystemMenu(g_hwndMain,FALSE);
			if (hSysMenu != NULL)
			{
				TCHAR szAboutMenu[100];

				if (LoadString(g_hInst,IDS_ABOUTBOX,szAboutMenu,ARRAYSIZE(szAboutMenu)))
				{
					AppendMenu(hSysMenu,MF_SEPARATOR,NULL,NULL);
					AppendMenu(hSysMenu,MF_STRING,IDM_ABOUTBOX,szAboutMenu);
				}
			}

			// Place dialog at bottom right of screen:AK
			HWND hWndInsertAfter;
            BOOL fRunSecure = RunSecure(GetDesktop());

			hWndInsertAfter =  ( fRunSecure ) ? HWND_TOPMOST:HWND_TOP;

			SystemParametersInfo (SPI_GETWORKAREA,NULL,&rcWorkArea,NULL);
			GetWindowRect (g_hwndMain,&rcWindow);
			xPos = rcWorkArea.right - (rcWindow.right - rcWindow.left);
			yPos = rcWorkArea.bottom - (rcWindow.bottom - rcWindow.top);
			SetWindowPos(g_hwndMain, hWndInsertAfter, 
			              xPos, yPos, 0, 0, SWP_NOSIZE |SWP_NOACTIVATE);

			// If Start type is Minimized. 
			if(StartMin || fRunSecure)
			{
				ShowWindow(g_hwndMain, SW_SHOWMINIMIZED);
				// This is required to kill focus from Narrator
				// And put the focus back to the active window. 
				PostMessage(g_hwndMain, WM_DELAYEDMINIMIZE, 0, 0);
			}
			else 
				ShowWindow(g_hwndMain,nCmdShow);
			return TRUE;
		}
	}

	// Something failed, exit false
	return FALSE;
}


/*************************************************************************
    Function:   UnInitApp
    Purpose:    Shuts down the application
    Inputs:     none
    Returns:    TRUE if app uninitalized properly
    History:
*************************************************************************/
BOOL UnInitApp(void)
{
	SetRegistryValues();
    if (UnInitTTS())
        {
        if (UnInitMSAA())
            {
            UninitKeys();
            return TRUE;
            }
        }
    return FALSE;
}

/*************************************************************************
    Function:   SpeakString
    Purpose:    Sends a string of text to the speech engine
    Inputs:     PSZ pszSpeakText - String of ANSI characters to be spoken
                                   Speech control tags can be embedded.
    Returns:    BOOL - TRUE if string was buffered correctly
    History:
*************************************************************************/
BOOL SpeakString(TCHAR * szSpeak, BOOL forceRead, DWORD dwFlags)
{
    // Check for redundent speak, filter out, If it is not Forced read
    if ((lstrcmp(szSpeak, g_szLastStringSpoken) == 0) && (forceRead == FALSE))
        return FALSE;

    if (dwFlags != SPEAK_MUTE)
    {
	    if (szSpeak[0] == 0) // don't speak null string
		    return FALSE;

	    // if exiting stop
	    if (g_fAppExiting)
		    return FALSE;

        // Different string, save off
        lstrcpyn(g_szLastStringSpoken, szSpeak, MAX_TEXT);

	    FilterSpeech(szSpeak);

        // The L&H speech engine for japanese, goes crazy if you pass a
        // " ", It now takes approx 1 min to come back to life. Need to remove
        // once they fix their stuff! :a-anilk
        if (lstrcmp(szSpeak, TEXT(" ")) == 0)
        {
            return FALSE;
        }

#ifdef SAPI5
        // if there is only punctuation then speak it
        int i = 0;
        int cAlpha = 0;
        while( szSpeak[i] != NULL )
    	{
    		if ( _istalpha(szSpeak[i++]) )
    			cAlpha++;
    	}

        if ( !cAlpha )
            dwFlags |= SPF_NLP_MASK;
#endif
    }

#ifndef SAPI5
    SDATA data;
	data.dwSize = (DWORD)(lstrlen(szSpeak)+1) * sizeof(TCHAR);
	data.pData = szSpeak;
	g_pITTSCentral->TextData (CHARSET_TEXT, 0, data, NULL, IID_ITTSBufNotifySinkW);
#else
	HRESULT hr = g_pISpV->Speak(szSpeak, dwFlags, NULL);
    if (FAILED(hr))
    {
        DBPRINTF(TEXT("SpeakString:  Speak returned 0x%x\r\n"), hr);
        return FALSE;
    }
#endif
    SpewToFile(TEXT("%s\r\n"), szSpeak);
	return TRUE;
}

/*************************************************************************
    Function:   InitTTS
    Purpose:    Starts the Text to Speech Engine
    Inputs:     none
    Returns:    BOOL - TRUE if successful
    History:
*************************************************************************/
BOOL InitTTS(void)
{
	// See if we have a Text To Speech engine to use, and initialize it if it is there.
#ifndef SAPI5
	TTSMODEINFO   ttsModeInfo;
	memset (&ttsModeInfo, 0, sizeof(ttsModeInfo));
	g_pITTSCentral = FindAndSelect (&ttsModeInfo);
	if (!g_pITTSCentral)
#else
	HRESULT hr = CoCreateInstance(CLSID_SpVoice, NULL, CLSCTX_INPROC_SERVER, IID_ISpVoice, (void**)&g_pISpV);
    if (FAILED(hr) || !g_pISpV)
#endif
	{
		MessageBoxLoadStrings (NULL, IDS_NO_TTS, IDS_MSR_ERROR, MB_OK);
		return FALSE;
	};
#ifdef SAPI5
   	memset( g_szVoices, NULL, sizeof(g_szVoices) );
   	memset( g_pVoiceTokens, NULL, sizeof(g_pVoiceTokens) );

    ISpObjectToken *pDefaultVoiceToken = NULL;
    WCHAR *szVoice = NULL;

    hr = g_pISpV->GetVoice(&pDefaultVoiceToken);
    if (SUCCEEDED(hr))
    {
        ISpObjectToken *pCurVoiceToken = pDefaultVoiceToken;
    	IEnumSpObjectTokens *pIEnumSpObjectTokens;
	    hr = SpEnumTokens(SPCAT_VOICES, NULL, NULL, &pIEnumSpObjectTokens);
		if (SUCCEEDED(hr))
		{
    	    ISpObjectToken *pCurVoiceToken;
		    int i = 0;
    	    while (pIEnumSpObjectTokens->Next(1, &pCurVoiceToken, NULL) == S_OK)	
			{
				hr = pCurVoiceToken->GetStringValue(NULL, &szVoice);
		        if (SUCCEEDED(hr))
		        {
                    // if this test for MS Sam is removed all voices in the machine will appear
            	    if ( wcscmp( szVoice, L"Microsoft Sam" ) == 0 )
            	    {
    		            currentVoice = i;
                        hr = g_pISpV->SetVoice( pCurVoiceToken );
		                if (FAILED(hr))
		                    return FALSE;
                        g_szVoices[i] = szVoice;
    		            g_pVoiceTokens[i++] = pCurVoiceToken;
    		        }
                }
                else
                {
                    return FALSE;
                }
   			} 
            if ( currentVoice < 0 )
                return FALSE;
        }
		else
		{
    		return FALSE;
		}
    }
    else
    {
        return FALSE;
    }

    SET_VALUE(SetPitch, currentPitch, lastPitch)
    SET_VALUE(SetSpeed, currentSpeed, lastSpeed)
    SET_VALUE(SetVolume, currentVolume, lastVolume)
#endif
	return TRUE;
}

/*************************************************************************
    Function:   UnInitTTS
    Purpose:    Shuts down the Text to Speech subsystem
    Inputs:     none
    Returns:    BOOL - TRUE if successful
    History:
*************************************************************************/
BOOL UnInitTTS(void)
{
#ifndef SAPI5
    // Release out TTS object - if we have one
    if (g_pITTSCentral)
    {
        g_pITTSCentral->Release();
        g_pITTSCentral = 0;
    }

   // Release IITSAttributes - if we have one:a-anilk
    if (g_pITTSAttributes)
    {
        g_pITTSAttributes->Release();
        g_pITTSAttributes = 0;
    }

	if ( pIAMM )
	{
		pIAMM->Release();
		pIAMM = NULL;
	}
#else
    // Release speech tokens and voice strings
	for ( int i = 0; i < ARRAYSIZE( g_pVoiceTokens ) && g_pVoiceTokens[i] != NULL; i++ )
	{
	    CoTaskMemFree(g_szVoices[i]);
        g_pVoiceTokens[i]->Release();
	}

    // Release speech engine
    if (g_pISpV)
    {
	    g_pISpV->Release();
        g_pISpV = 0;
    }
#endif
    return TRUE;
}

/*************************************************************************
    Function:   Shutup
    Purpose:    stops speaking, flushes speech buffers
    Inputs:     none
    Returns:    none
    History:	
*************************************************************************/
void Shutup(void)
{
#ifndef SAPI5
    if (g_pITTSCentral && !g_fAppExiting)
        g_pITTSCentral->AudioReset();
#else
	if (g_pISpV && !g_fAppExiting)
        SendMessage(g_hwndMain, WM_MSRSPEAKMUTE, 0, 0);
#endif
}

#ifndef SAPI5
/*************************************************************************
    Function:   FindAndSelect
    Purpose:    Selects the TTS engine
    Inputs:     PTTSMODEINFO pTTSInfo - Desired mode
    Returns:    PITTSCENTRAL - Pointer to ITTSCentral interface of engine
    History:	a-anilk created
*************************************************************************/
PITTSCENTRAL FindAndSelect(PTTSMODEINFO pTTSInfo)
{
    PITTSCENTRAL    pITTSCentral;           // central interface
    HRESULT         hRes;
    WORD            voice;
	TCHAR           defaultVoice[128];
	WORD			defLangID;

	hRes = CoCreateInstance (CLSID_TTSEnumerator, NULL, CLSCTX_ALL, IID_ITTSEnum, (void**)&g_pITTSEnum);
    if (FAILED(hRes))
        return NULL;

	// Security Check, Disallow Non-Microsoft Engines on Logon desktops..
	logonCheck = RunSecure(GetDesktop());

    // Get the audio dest
    hRes = CoCreateInstance(CLSID_MMAudioDest,
                            NULL,
                            CLSCTX_ALL,
                            IID_IAudioMultiMediaDevice,
                            (void**)&pIAMM);
    if (FAILED(hRes))
        return NULL;     // error
	
    pIAMM->DeviceNumSet (WAVE_MAPPER);

	if ( !logonCheck )
	{
		hRes = g_pITTSEnum->Next(MAX_ENUMMODES,gaTTSInfo,&gnmodes);
		if (FAILED(hRes))
		{
			DBPRINTF(TEXT("Failed to get any TTS Engine"));
			return NULL;     // error
		}
	
		defLangID = (WORD) GetUserDefaultUILanguage();

		// If the voice needs to be changed, Check in the list of voices..
		// If found a matching language, Great. Otherwise cribb! Anyway select a 
		// voice at the end, First one id none is found...
		// If not initialized, Then we need to over ride voice
		if ( currentVoice < 0 || currentVoice >= gnmodes ) 
		{
			for (voice = 0; voice < gnmodes; voice++)
			{
				if (gaTTSInfo[voice].language.LanguageID == defLangID)
					break;
			}

			if (voice >= gnmodes)
				voice = 0;

			currentVoice = voice;
		}
		

		if( gaTTSInfo[currentVoice].language.LanguageID != defLangID )
		{
			// Error message saying that the language was not not found...AK
			MessageBoxLoadStrings (NULL, IDS_LANGW, IDS_WARNING, MB_OK);
		}

		// Pass off the multi-media-device interface as an IUnknown (since it is one)
		hRes = g_pITTSEnum->Select( gaTTSInfo[currentVoice].gModeID,
									&pITTSCentral,
									(LPUNKNOWN) pIAMM);
		if (FAILED(hRes))
			return NULL;
	}
	else
	{
		// Pass off the multi-media-device interface as an IUnknown (since it is one)
		hRes = g_pITTSEnum->Select( MSTTS_GUID,
									&pITTSCentral,
									(LPUNKNOWN) pIAMM);
		if (FAILED(hRes))
			return NULL;

	}

	hRes = pITTSCentral->QueryInterface (IID_ITTSAttributes, (void**)&g_pITTSAttributes);

	if( FAILED(hRes) )
		return NULL;
	else
    {
		GetSpeechMinMaxValues();
    }

    SET_VALUE(SetPitch, currentPitch, lastPitch)
    SET_VALUE(SetSpeed, currentSpeed, lastSpeed)
    SET_VALUE(SetVolume, currentVolume, lastVolume)

    return pITTSCentral;
}
#endif // ifndef SAPI5

/*************************************************************************
    Function:
    Purpose:
    Inputs:
    Returns:
    History:
*************************************************************************/
int MessageBoxLoadStrings (HWND hWnd,UINT uIDText,UINT uIDCaption,UINT uType)
{
	TCHAR szText[1024];
	TCHAR szCaption[128];

	LoadString(g_hInst, uIDText, szText, sizeof(szText)/sizeof(TCHAR));	// raid #113790
	LoadString(g_hInst, uIDCaption, szCaption, sizeof(szCaption)/sizeof(TCHAR)); // raid #113791
	return (MessageBox(hWnd, szText, szCaption, uType));
}

// AssignDeskTop() For UM
// a-anilk. 1-12-98
static BOOL  AssignDesktop(LPDWORD desktopID, LPTSTR pname)
{
    HDESK hdesk;
    wchar_t name[300];
    DWORD nl;

    *desktopID = DESKTOP_ACCESSDENIED;
    hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);

    if (!hdesk)
    {
        // OpenInputDesktop will mostly fail on "Winlogon" desktop
        hdesk = OpenDesktop(__TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
        if (!hdesk)
            return FALSE;
    }

    GetUserObjectInformation(hdesk,UOI_NAME,name,300,&nl);

    if (pname)
        wcscpy(pname, name);
    if (!_wcsicmp(name, __TEXT("Default")))
        *desktopID = DESKTOP_DEFAULT;
    else if (!_wcsicmp(name, __TEXT("Winlogon")))
    {
        *desktopID = DESKTOP_WINLOGON;
    }
    else if (!_wcsicmp(name, __TEXT("screen-saver")))
        *desktopID = DESKTOP_SCREENSAVER;
    else if (!_wcsicmp(name, __TEXT("Display.Cpl Desktop")))
        *desktopID = DESKTOP_TESTDISPLAY;
    else
        *desktopID = DESKTOP_OTHER;
    
	if ( CloseDesktop(GetThreadDesktop(GetCurrentThreadId())) == 0)
    {
        TCHAR str[10];
        DWORD err = GetLastError();
        wsprintf((LPTSTR)str, (LPCTSTR)"%l", err);
    }

    if ( SetThreadDesktop(hdesk) == 0)
    {
        TCHAR str[10];
        DWORD err = GetLastError();
        wsprintf((LPTSTR)str, (LPCTSTR)"%l", err);
    }

    return TRUE;
}


// InitMyProcessDesktopAccess
// a-anilk: 1-12-98
static BOOL InitMyProcessDesktopAccess(VOID)
{
  origWinStation = GetProcessWindowStation();
  userWinStation = OpenWindowStation(__TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);

  if (!userWinStation)
    return FALSE;
  
  SetProcessWindowStation(userWinStation);
  return TRUE;
}

// ExitMyProcessDesktopAccess
// a-anilk: 1-12-98
static VOID ExitMyProcessDesktopAccess(VOID)
{
  if (origWinStation)
    SetProcessWindowStation(origWinStation);

  if (userWinStation)
  {
	CloseWindowStation(userWinStation);
    userWinStation = NULL;
  }
}

// a-anilk added
// Returns the current desktop-ID
DWORD GetDesktop()
{
    HDESK hdesk;
    TCHAR name[300];
    DWORD value, nl, desktopID = DESKTOP_ACCESSDENIED;
    HKEY reg_key;
    DWORD cbData = sizeof(DWORD);
	LONG retVal;

	// Check if we are in setup mode...
	if (SUCCEEDED( RegOpenKeyEx(HKEY_LOCAL_MACHINE, __TEXT("SYSTEM\\Setup"), 0, KEY_READ, &reg_key)) )
    {
		retVal = RegQueryValueEx(reg_key, __TEXT("SystemSetupInProgress"), 0, NULL, (LPBYTE) &value, &cbData);

		if ( (retVal== ERROR_SUCCESS) && value )
			// Setup is in progress...
			return DESKTOP_ACCESSDENIED;
	}

	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (!hdesk)
    {
        // OpenInputDesktop will mostly fail on "Winlogon" desktop
        hdesk = OpenDesktop(__TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
        if (!hdesk)
            return DESKTOP_WINLOGON;
    }
    
	GetUserObjectInformation(hdesk, UOI_NAME, name, 300, &nl);
    CloseDesktop(hdesk);
    
	if (!_wcsicmp(name, __TEXT("Default")))
        desktopID = DESKTOP_DEFAULT;

    else if (!_wcsicmp(name, __TEXT("Winlogon")))
        desktopID = DESKTOP_WINLOGON;

    else if (!_wcsicmp(name, __TEXT("screen-saver")))
        desktopID = DESKTOP_SCREENSAVER;

    else if (!_wcsicmp(name, __TEXT("Display.Cpl Desktop")))
        desktopID = DESKTOP_TESTDISPLAY;

    else
        desktopID = DESKTOP_OTHER;
    
	return desktopID;
}

//Confirmation dialog.
INT_PTR CALLBACK ConfirmProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
			{
				if ( IsIconic(g_hwndMain) )
				{
					CenterWindow(hwnd);
				}

				return TRUE;
			}
			break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
				case IDOK:
					Shutup();
                    EndDialog (hwnd, IDOK);
                    return(TRUE);
                case IDCANCEL:
					Shutup();
                    EndDialog (hwnd, IDCANCEL);
                    return(TRUE);
             }
     };

     return(FALSE);  // didn't handle
}

// Centers Narrator dialogs when main window is minimized:AK
void CenterWindow(HWND hwnd)
{
	RECT rect, dRect;
	GetWindowRect(GetDesktopWindow(), &dRect);
	GetWindowRect(hwnd, &rect);
	rect.left = (dRect.right - (rect.right - rect.left))/2;
	rect.top = (dRect.bottom - (rect.bottom - rect.top))/2;

	SetWindowPos(hwnd, HWND_TOPMOST ,rect.left,rect.top,0,0,SWP_NOSIZE | SWP_NOACTIVATE);
}

// Helper method Filters smiley face utterances: AK
void FilterSpeech(TCHAR* szSpeak)
{
	// the GUID's have a Tab followed by a {0087....
	// If you find this pattern. Then donot speak that:AK
	if ( lstrlen(szSpeak) <= 3 )
		return;

	while((*(szSpeak+3)) != NULL)
	{
		if ( (*szSpeak == '(') && iswalpha(*(szSpeak + 1)) && ( (*(szSpeak + 3) == ')')) )
		{
			// Replace by isAlpha drive...
			*(szSpeak + 2) = ' ';
		}

		szSpeak++;
	}
}

// Helper functions for combo boxes

int GetComboItemData(HWND hwnd)
{
    int iValue = CB_ERR;
    LRESULT iCurSel = SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    if (iCurSel != CB_ERR)
        iValue = SendMessage(hwnd, CB_GETITEMDATA, iCurSel, 0);

    return iValue;
}

void FillAndSetCombo(HWND hwnd, int iMinVal, int iMaxVal, int iSelVal)
{
    SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

    int iSelPos = -1;
    for (int i=0;iMaxVal >= iMinVal;i++, iMaxVal--)
    {
        TCHAR szItem[100];
        wsprintf(szItem, TEXT("%d"), iMaxVal);

        int iPos = SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szItem);
        SendMessage(hwnd, CB_SETITEMDATA, iPos, iMaxVal);

        if (iSelVal == iMaxVal)
            iSelPos = iPos; // note the current selection
    }

    // show the current value
    SendMessage(hwnd, CB_SETCURSEL, iSelPos, 0);
}
/*************************************************************************
    THE INFORMATION AND CODE PROVIDED HEREUNDER (COLLECTIVELY REFERRED TO
    AS "SOFTWARE") IS PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN
    NO EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
    ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
    CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
    MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGES. SOME STATES DO NOT ALLOW THE EXCLUSION OR
    LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES SO THE
    FOREGOING LIMITATION MAY NOT APPLY.
*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrator\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Narrator.rc
//
#define IDS_COPYRIGHT                   3
#define IDS_VOICE                       8
#define IDS_THETEXT                     9
#define IDS_THETITLE                    10
#define IDS_NO_OLE                      11
#define IDS_NO_SOUNDCARD                12
#define IDS_NO_TTS                      13
#define IDS_MSR_ERROR                   14
#define IDS_ABOUTBOX                    16
#define IDM_ABOUTBOX                    0x0010
#define IDS_HELLO                       17
#define IDS_INTRO                       18
#define IDS_ENABLEWEB                   19
#define IDS_LANGW                       20
#define IDS_WARNING                     21
#define IDS_ERROR                       22
#define IDS_SECURE                      23
#define IDS_SAM                         24
#define IDD_MAIN                        101
#define IDI_ICON1                       102
#define IDD_MOUSE                       103
#define IDD_CONFIG                      104
#define IDD_HELP                        105
#define IDD_REVIEW                      109
#define IDD_VOICE                       110
#define IDD_EVENTS                      112
#define IDD_ABOUTBOX                    113
#define IDD_CONFIRMEXIT                 122
#define IDD_WARNING                     123
#define IDC_EXIT                        1000
#define IDC_MOUSEBUTTON                 1002
#define IDC_INPUTFOCUS                  1004
#define IDC_CARET                       1006
#define IDC_MSRHELP                     1009
#define IDC_MSRCONFIG                   1010
#define IDC_VOICESETTINGS               1017
#define IDC_READING                     1018
#define IDC_EVENTS                      1019
#define IDC_MINIMIZE                    1020
#define IDC_BACKSPACE                   1021
#define IDC_SPACE                       1022
#define IDC_DELETE                      1023
#define IDC_TAB                         1024
#define IDC_ENTER                       1025
#define IDC_MODIFIERS                   1026
#define IDC_ALNUM                       1027
#define IDC_COMBOSPEED                  1030
#define IDC_COMBOVOLUME                 1031
#define IDC_COMBOPITCH                  1032
#define IDC_NAME                        1036
#define IDC_ANNOUNCE_WINDOW             1051
#define IDC_ANNOUNCE_MENU               1052
#define IDC_ANNOUNCEPOPUP               1053
#define IDC_ANNOUNCETOOLTIPS            1054
#define IDC_WINDOWINFO                  1056
#define IDC_BEGINNER                    1059
#define IDC_EXPERIENCED                 1060
#define IDC_PASSIVE                     1061
#define IDC_ABOUTICON                   1062
#define IDC_ABOUTVERSION                1063
#define IDC_ABOUTCOPYRIGHT              1064
#define IDC_ABOUTDISCLAIMER             1065
#define IDC_ABOUTWEBSITE                1066
#define IDC_ABOUTWEBSITE2               1067
#define IDC_SPEEDSLIDER                 1068
#define IDC_ABOUTWEBSITE3               1068
#define IDC_VOLUMESLIDER                1069
#define IDC_PITCHSLIDER                 1070
#define IDC_VOICE                       1071
#define IDC_SPEED                       1072
#define IDC_VOLUME                      1073
#define IDC_PITCH                       1074
#define IDC_NARR_DESC                   1075
#define IDC_ANNOUNCE                    1078
#define IDC_MOUSEPTR                    1080
#define IDC_STARTMIN                    1081
#define IDC_CAPTION                     1082
#define IDC_WARNING                     1083
#define IDC_WARND                       1084
#define IDC_WARND2                      1085
#define IDC_ENABLEWEBA                  1086
#define IDC_ENABLEWEB                   1087
#define IDC_ENABLEWEB2                  1088
#define IDC_WARND3                      1089

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        123
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1088
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrator\reader.h ===
#define IDH_READER_SETTINGS_VOICE		70600 //settings dialog
#define IDH_READER_SELECT_VOICE			70605 //voice dialog
#define IDH_READER_VOICE_SPEED			70610 //voice dialog
#define IDH_READER_VOICE_VOLUME			70615 //voice dialog
#define IDH_READER_VOICE_PITCH			70620 //voice dialog
#define IDH_READER_SETTINGS_READING		70625 //settings dialog
#define IDH_READER_READING_PRINTABLE		70630 //reading dialog
#define IDH_READER_READING_DELETE		70635 //reading dialog
#define IDH_READER_READING_SPACE		70640 //reading dialog
#define IDH_READER_READING_MODIFIERS		70645 //reading dialog
#define IDH_READER_READING_TAB			70650 //reading dialog
#define IDH_READER_READING_BACKSPACE		70655 //reading dialog
#define IDH_READER_READING_ENTER		70660 //reading dialog
#define IDH_READER_SETTINGS_EVENTS		70665 //settings dialog
#define IDH_READER_EVENT_WINDOW			70670 //event dialog
#define IDH_READER_EVENT_MENU			70675 //event dialog
#define IDH_READER_EVENT_POPUP_MENU		70680 //event dialog
#define IDH_READER_EVENT_TOOLTIPS		70685 //event dialog
#define IDH_READER_SETTINGS_MOUSEPOINTER	70690 //settings dialog
#define IDH_READER_MOUSE_ACTIVE_ITEM		70695 //mouse dialog
#define IDH_READER_MOUSE_INSERTION_POINT	70700 //mouse dialog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrator\sources.inc ===
#
# We need to make sure we pick up the right information in the header files
# TODO: Verify that this is the right place for these defines
#

C_DEFINES=$(C_DEFINES)  -DUNICODE -D_UNICODE

WIN32_IE_VERSION=0x0400
WIN32_WINNT_VERSION=0x0500

TARGETNAME=Narrator
TARGETPATH=obj
TARGETTYPE=PROGRAM
USE_MSVCRT=1
USE_NATIVE_EH=1

TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\ole32.lib    \
           $(SDK_LIB_PATH)\winmm.lib    \
           $(SHELL_LIB_PATH)\shell32p.lib \
           $(SDK_LIB_PATH)\htmlhelp.lib \
		   $(SDK_LIB_PATH)\comctl32.lib \
           $(SHELL_LIB_PATH)\shlwapip.lib \
           $(SDK_LIB_PATH)\sapi.lib

NOT_LEAN_AND_MEAN=1

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

SOURCES= ..\Narrator.cpp   \
         ..\Narrator.rc

INCLUDES=$(ENDUSER_INC_PATH);..\..\..\inc

UMTYPE=windows
UMENTRY=winmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrator\version.h ===
// NARRATOR.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "Microsoft Narrator"
#define VER_INTERNALNAME_STR        "NARRATOR"
#define VER_ORIGINALFILENAME_STR    "NARRATOR.EXE"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrator\speech.h ===
/*****************************************************************8
Speech.H - Header file to use the Microsoft Speech APIs.

Copyright 1994, 1995 by Microsoft corporation.All rights reserved.
*/

#ifndef _SPEECH_
#define _SPEECH_

// Disable the warning for zero-length arrays in structures
#pragma warning(disable:4200)


/************************************************************************
Defines common to all of the speech APIs.
*/

// Application  Speech API   Compiler Defines                   _S_UNICODE
// -----------------------------------------------------------------------------
//   ANSI        ANSI        <none>                             undefined
//   ANSI        Unicode     _S_UNICODE                         defined
//   Unicode     ANSI        (UNICODE || _UNICODE) && _S_ANSI   undefined
//   Unicode     Unicode     (UNICODE || _UNICODE)              defined

#if (defined(UNICODE) || defined(_UNICODE)) && !defined(_S_ANSI)
#ifndef _S_UNICODE
#define _S_UNICODE
#endif
#endif

/************************************************************************
defines */
#define  SVFN_LEN    (262)
#define  LANG_LEN    (64)
#define  EI_TITLESIZE   (128)
#define  EI_DESCSIZE    (512)
#define  EI_FIXSIZE     (512)
#define  SVPI_MFGLEN    (64)
#define  SVPI_PRODLEN   (64)
#define  SVPI_COMPLEN   (64)
#define  SVPI_COPYRIGHTLEN (128)
#define  SVI_MFGLEN     (SVPI_MFGLEN)
#define  SETBIT(x)      ((DWORD)1 << (x))


// Error Macros
#define  FACILITY_SPEECH   (FACILITY_ITF)
#define  SPEECHERROR(x)    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_SPEECH, (x)+0x200)
#define  AUDERROR(x)       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_SPEECH, (x)+0x300)
#define  SRWARNING(x)      MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_SPEECH, (x)+0x400)
#define  SRERROR(x)        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_SPEECH, (x)+0x400)
#define  TTSERROR(x)       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_SPEECH, (x)+0x500)
#define  VCMDERROR(x)      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_SPEECH, (x)+0x600)
#define  VTXTERROR(x)      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_SPEECH, (x)+0x700)
#define  LEXERROR(x)       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_SPEECH, (x)+0x800)

// Audio Errors
#define  AUDERR_NONE                      S_OK                          // 0x00000000
#define  AUDERR_BADDEVICEID               AUDERROR(1)                   // 0x80040301
#define  AUDERR_NEEDWAVEFORMAT            AUDERROR(2)                   // 0x80040302
#define  AUDERR_NOTSUPPORTED              E_NOTIMPL                     // 0x80004001
#define  AUDERR_NOTENOUGHDATA             SPEECHERROR(1)                // 0x80040201
#define  AUDERR_NOTPLAYING                AUDERROR(6)                   // 0x80040306
#define  AUDERR_INVALIDPARAM              E_INVALIDARG                  // 0x80070057
#define  AUDERR_WAVEFORMATNOTSUPPORTED    SPEECHERROR(2)                // 0x80040202
#define  AUDERR_WAVEDEVICEBUSY            SPEECHERROR(3)                // 0x80040203
#define  AUDERR_WAVEDEVNOTSUPPORTED       AUDERROR(18)                  // 0x80040312
#define  AUDERR_NOTRECORDING              AUDERROR(19)                  // 0x80040313
#define  AUDERR_INVALIDFLAG               SPEECHERROR(4)                // 0x80040204
#define  AUDERR_INVALIDHANDLE             E_HANDLE                      // 0x80070006
#define  AUDERR_NODRIVER                  AUDERROR(23)                  // 0x80040317
#define  AUDERR_HANDLEBUSY                AUDERROR(24)                  // 0x80040318
#define  AUDERR_INVALIDNOTIFYSINK         AUDERROR(25)                  // 0x80040319
#define  AUDERR_WAVENOTENABLED            AUDERROR(26)                  // 0x8004031A
#define  AUDERR_ALREADYCLAIMED            AUDERROR(29)                  // 0x8004031D
#define  AUDERR_NOTCLAIMED                AUDERROR(30)                  // 0x8004031E
#define  AUDERR_STILLPLAYING              AUDERROR(31)                  // 0x8004031F
#define  AUDERR_ALREADYSTARTED            AUDERROR(32)                  // 0x80040320
#define  AUDERR_SYNCNOTALLOWED            AUDERROR(33)                  // 0x80040321

// Speech Recognition Warnings
#define  SRWARN_BAD_LIST_PRONUNCIATION    SRWARNING(1)

// Speech Recognition Errors
#define  SRERR_NONE                       S_OK                          // 0x00000000
#define  SRERR_OUTOFDISK                  SPEECHERROR(5)                // 0x80040205
#define  SRERR_NOTSUPPORTED               E_NOTIMPL                     // 0x80004001
#define  SRERR_NOTENOUGHDATA              AUDERR_NOTENOUGHDATA          // 0x80040201
#define  SRERR_VALUEOUTOFRANGE            E_UNEXPECTED                  // 0x8000FFFF
#define  SRERR_GRAMMARTOOCOMPLEX          SRERROR(6)                    // 0x80040406
#define  SRERR_GRAMMARWRONGTYPE           SRERROR(7)                    // 0x80040407
#define  SRERR_INVALIDWINDOW              OLE_E_INVALIDHWND             // 0x8004000F
#define  SRERR_INVALIDPARAM               E_INVALIDARG                  // 0x80070057
#define  SRERR_INVALIDMODE                SPEECHERROR(6)                // 0x80040206
#define  SRERR_TOOMANYGRAMMARS            SRERROR(11)                   // 0x8004040B
#define  SRERR_INVALIDLIST                SPEECHERROR(7)                // 0x80040207
#define  SRERR_WAVEDEVICEBUSY             AUDERR_WAVEDEVICEBUSY         // 0x80040203
#define  SRERR_WAVEFORMATNOTSUPPORTED     AUDERR_WAVEFORMATNOTSUPPORTED // 0x80040202
#define  SRERR_INVALIDCHAR                SPEECHERROR(8)                // 0x80040208
#define  SRERR_GRAMTOOCOMPLEX             SRERR_GRAMMARTOOCOMPLEX       // 0x80040406
#define  SRERR_GRAMTOOLARGE               SRERROR(17)                   // 0x80040411
#define  SRERR_INVALIDINTERFACE           E_NOINTERFACE                 // 0x80004002
#define  SRERR_INVALIDKEY                 SPEECHERROR(9)                // 0x80040209
#define  SRERR_INVALIDFLAG                AUDERR_INVALIDFLAG            // 0x80040204
#define  SRERR_GRAMMARERROR               SRERROR(22)                   // 0x80040416
#define  SRERR_INVALIDRULE                SRERROR(23)                   // 0x80040417
#define  SRERR_RULEALREADYACTIVE          SRERROR(24)                   // 0x80040418
#define  SRERR_RULENOTACTIVE              SRERROR(25)                   // 0x80040419
#define  SRERR_NOUSERSELECTED             SRERROR(26)                   // 0x8004041A
#define  SRERR_BAD_PRONUNCIATION          SRERROR(27)                   // 0x8004041B
#define  SRERR_DATAFILEERROR              SRERROR(28)                   // 0x8004041C
#define  SRERR_GRAMMARALREADYACTIVE       SRERROR(29)                   // 0x8004041D
#define  SRERR_GRAMMARNOTACTIVE           SRERROR(30)                   // 0x8004041E
#define  SRERR_GLOBALGRAMMARALREADYACTIVE SRERROR(31)                   // 0x8004041F
#define  SRERR_LANGUAGEMISMATCH           SRERROR(32)                   // 0x80040420
#define  SRERR_MULTIPLELANG               SRERROR(33)                   // 0x80040421
#define  SRERR_LDGRAMMARNOWORDS           SRERROR(34)                   // 0x80040422
#define  SRERR_NOLEXICON                  SRERROR(35)                   // 0x80040423
#define  SRERR_SPEAKEREXISTS              SRERROR(36)                   // 0x80040424
#define  SRERR_GRAMMARENGINEMISMATCH      SRERROR(37)                   // 0x80040425


// Text to Speech Errors
#define  TTSERR_NONE                      S_OK                          // 0x00000000
#define  TTSERR_INVALIDINTERFACE          E_NOINTERFACE                 // 0x80004002
#define  TTSERR_OUTOFDISK                 SRERR_OUTOFDISK               // 0x80040205
#define  TTSERR_NOTSUPPORTED              E_NOTIMPL                     // 0x80004001
#define  TTSERR_VALUEOUTOFRANGE           E_UNEXPECTED                  // 0x8000FFFF
#define  TTSERR_INVALIDWINDOW             OLE_E_INVALIDHWND             // 0x8004000F
#define  TTSERR_INVALIDPARAM              E_INVALIDARG                  // 0x80070057
#define  TTSERR_INVALIDMODE               SRERR_INVALIDMODE             // 0x80040206
#define  TTSERR_INVALIDKEY                SRERR_INVALIDKEY              // 0x80040209
#define  TTSERR_WAVEFORMATNOTSUPPORTED    AUDERR_WAVEFORMATNOTSUPPORTED // 0x80040202
#define  TTSERR_INVALIDCHAR               SRERR_INVALIDCHAR             // 0x80040208
#define  TTSERR_QUEUEFULL                 SPEECHERROR(10)               // 0x8004020A
#define  TTSERR_WAVEDEVICEBUSY            AUDERR_WAVEDEVICEBUSY         // 0x80040203
#define  TTSERR_NOTPAUSED                 TTSERROR(1)                   // 0x80040501
#define  TTSERR_ALREADYPAUSED             TTSERROR(2)                   // 0x80040502


// Voice Command Errors

/*
 *  Everything worked
 */
#define  VCMDERR_NONE                     S_OK                          // 0x00000000

/*
 *  Voice Commands could not allocate memory
 */
#define  VCMDERR_OUTOFMEM                 E_OUTOFMEMORY                 // 0x8007000E

/*
 *  Voice Commands could not store/retrieve a command set from the database
 */
#define  VCMDERR_OUTOFDISK                SRERR_OUTOFDISK               // 0x80040205

/*
 *  Function not implemented
 */
#define  VCMDERR_NOTSUPPORTED             E_NOTIMPL                     // 0x80004001

/*
 *  A parameter was passed that was out of the ranged of accepted values
 */
#define  VCMDERR_VALUEOUTOFRANGE          E_UNEXPECTED                  // 0x8000FFFF

/*
 *  A menu was too complex to compile a context-free grammar
 */
#define  VCMDERR_MENUTOOCOMPLEX           VCMDERROR(0x06)               //  0x80040606

/*
 *  Language mismatch between the speech recognition mode and menu trying
 *  to create
 */
#define  VCMDERR_MENUWRONGLANGUAGE        VCMDERROR(0x07)               // 0x80040607

/*
 *  An invalid window handle was passed to Voice Commands
 */
#define  VCMDERR_INVALIDWINDOW            OLE_E_INVALIDHWND             // 0x8004000F

/*
 *  Voice Commands detected a bad function parameter
 */
#define  VCMDERR_INVALIDPARAM             E_INVALIDARG                  // 0x80070057

/*
 *  This function cannot be completed right now, usually when trying to do
 *  some operation while no speech recognition site is established
 */
#define  VCMDERR_INVALIDMODE              SRERR_INVALIDMODE             // 0x80040206

/*
 *  There are too many Voice Commands menu
 */                                                                     // 0x8004060B
#define  VCMDERR_TOOMANYMENUS             VCMDERROR(0x0B)

/*
 *  Invalid list passed to ListSet/ListGet
 */
#define  VCMDERR_INVALIDLIST              SRERR_INVALIDLIST             // 0x80040207

/*
 *  Trying to open an existing menu that is not in the Voice Commands database
 */
#define  VCMDERR_MENUDOESNOTEXIST         VCMDERROR(0x0D)               // 0x8004060D

/*
 *  The function could not be completed because the menu is actively 
 *  listening for commands
 */
#define  VCMDERR_MENUACTIVE               VCMDERROR(0x0E)               // 0x8004060E

/*
 *  No speech recognition engine is started
 */
#define  VCMDERR_NOENGINE                 VCMDERROR(0x0F)               // 0x8004060F

/*
 *  Voice Commands could not acquire a Grammar interface from the speech
 *  recognition engine
 */
#define  VCMDERR_NOGRAMMARINTERFACE       VCMDERROR(0x10)               // 0x80040610

/*
 *  Voice Commands could not acquire a Find interface from the speech
 *  recognition engine
 */
#define  VCMDERR_NOFINDINTERFACE          VCMDERROR(0x11)               // 0x80040611

/*
 *  Voice Commands could not create a speech recognition enumerator
 */
#define  VCMDERR_CANTCREATESRENUM         VCMDERROR(0x12)               // 0x80040612

/*
 *  Voice Commands could get the appropriate site information to start a
 *  speech recognition engine
 */
#define  VCMDERR_NOSITEINFO               VCMDERROR(0x13)               // 0x80040613

/*
 *  Voice Commands could not find a speech recognition engine
 */
#define  VCMDERR_SRFINDFAILED             VCMDERROR(0x14)               // 0x80040614

/*
 *  Voice Commands could not create an audio source object
 */
#define  VCMDERR_CANTCREATEAUDIODEVICE    VCMDERROR(0x15)               // 0x80040615

/*
 *  Voice Commands could not set the appropriate device number in the
 *  audio source object
 */
#define  VCMDERR_CANTSETDEVICE            VCMDERROR(0x16)               // 0x80040616

/*
 *  Voice Commands could not select a speech recognition engine. Usually the
 *  error will occur when Voice Commands has enumerated and found an
 *  appropriate speech recognition engine, then it is not able to actually
 *  select/start the engine. There are different reasons that the engine won't
 *  start, but the most common is that there is no wave in device.
 */
#define  VCMDERR_CANTSELECTENGINE         VCMDERROR(0x17)               // 0x80040617

/*
 *  Voice Commands could not create a notfication sink for engine
 *  notifications
 */
#define  VCMDERR_CANTCREATENOTIFY         VCMDERROR(0x18)               // 0x80040618

/*
 *  Voice Commands could not create internal data structures.
 */
#define  VCMDERR_CANTCREATEDATASTRUCTURES VCMDERROR(0x19)               // 0x80040619

/*
 *  Voice Commands could not initialize internal data structures
 */
#define  VCMDERR_CANTINITDATASTRUCTURES   VCMDERROR(0x1A)               // 0x8004061A

/*
 *  The menu does not have an entry in the Voice Commands cache
 */
#define  VCMDERR_NOCACHEDATA              VCMDERROR(0x1B)               // 0x8004061B

/*
 *  The menu does not have commands
 */
#define  VCMDERR_NOCOMMANDS               VCMDERROR(0x1C)               // 0x8004061C

/*
 *  Voice Commands cannot extract unique words needed for the engine grammar
 */
#define  VCMDERR_CANTXTRACTWORDS          VCMDERROR(0x1D)               // 0x8004061D

/*
 *  Voice Commands could not get the command set database name
 */
#define  VCMDERR_CANTGETDBNAME            VCMDERROR(0x1E)               // 0x8004061E

/*
 *  Voice Commands could not create a registry key
 */
#define  VCMDERR_CANTCREATEKEY            VCMDERROR(0x1F)               // 0x8004061F

/*
 *  Voice Commands could not create a new database name
 */
#define  VCMDERR_CANTCREATEDBNAME         VCMDERROR(0x20)               // 0x80040620

/*
 *  Voice Commands could not update the registry
 */
#define  VCMDERR_CANTUPDATEREGISTRY       VCMDERROR(0x21)               // 0x80040621

/*
 *  Voice Commands could not open the registry
 */
#define  VCMDERR_CANTOPENREGISTRY         VCMDERROR(0x22)               // 0x80040622

/*
 *  Voice Commands could not open the command set database
 */
#define  VCMDERR_CANTOPENDATABASE         VCMDERROR(0x23)               // 0x80040623

/*
 *  Voice Commands could not create a database storage object
 */
#define  VCMDERR_CANTCREATESTORAGE        VCMDERROR(0x24)               // 0x80040624

/*
 *  Voice Commands could not do CmdMimic
 */
#define  VCMDERR_CANNOTMIMIC              VCMDERROR(0x25)               // 0x80040625

/*
 *  A menu of this name already exist
 */
#define  VCMDERR_MENUEXIST                VCMDERROR(0x26)               // 0x80040626

/*
 *  A menu of this name is open and cannot be deleted right now
 */
#define  VCMDERR_MENUOPEN                 VCMDERROR(0x27)               // 0x80040627


// Voice Text Errors
#define  VTXTERR_NONE                     S_OK                          // 0x00000000

/*
 *  Voice Text failed to allocate memory it needed
 */
#define  VTXTERR_OUTOFMEM                 E_OUTOFMEMORY                 // 0x8007000E

/*
 *  An empty string ("") was passed to the Speak function
 */
#define  VTXTERR_EMPTYSPEAKSTRING         SPEECHERROR(0x0b)             // 0x8004020B

/*
 *  An invalid parameter was passed to a Voice Text function
 */
#define  VTXTERR_INVALIDPARAM             E_INVALIDARG                  // 0x80070057

/*
 *  The called function cannot be done at this time. This usually occurs
 *  when trying to call a function that needs a site, but no site has been
 *  registered.
 */
#define  VTXTERR_INVALIDMODE              SRERR_INVALIDMODE             // 0x80040206

/*
 *  No text-to-speech engine is started
 */
#define  VTXTERR_NOENGINE                 VTXTERROR(0x0F)               // 0x8004070F

/*
 *  Voice Text could not acquire a Find interface from the text-to-speech
 *  engine
 */
#define  VTXTERR_NOFINDINTERFACE          VTXTERROR(0x11)               // 0x80040711

/*
 *  Voice Text could not create a text-to-speech enumerator
 */
#define  VTXTERR_CANTCREATETTSENUM        VTXTERROR(0x12)               // 0x80040712

/*
 *  Voice Text could get the appropriate site information to start a
 *  text-to-speech engine
 */
#define  VTXTERR_NOSITEINFO               VTXTERROR(0x13)               // 0x80040713

/*
 *  Voice Text could not find a text-to-speech engine
 */
#define  VTXTERR_TTSFINDFAILED            VTXTERROR(0x14)               // 0x80040714

/*
 *  Voice Text could not create an audio destination object
 */
#define  VTXTERR_CANTCREATEAUDIODEVICE    VTXTERROR(0x15)               // 0x80040715

/*
 *  Voice Text could not set the appropriate device number in the
 *  audio destination object
 */
#define  VTXTERR_CANTSETDEVICE            VTXTERROR(0x16)               // 0x80040716

/*
 *  Voice Text could not select a text-to-speech engine. Usually the
 *  error will occur when Voice Text has enumerated and found an
 *  appropriate text-to-speech engine, then it is not able to actually
 *  select/start the engine.
 */
#define  VTXTERR_CANTSELECTENGINE         VTXTERROR(0x17)               // 0x80040717

/*
 *  Voice Text could not create a notfication sink for engine
 *  notifications
 */
#define  VTXTERR_CANTCREATENOTIFY         VTXTERROR(0x18)               // 0x80040718

/*
 *  Voice Text is disabled at this time
 */
#define  VTXTERR_NOTENABLED               VTXTERROR(0x19)               // 0x80040719

#define  VTXTERR_OUTOFDISK                SRERR_OUTOFDISK               // 0x80040205
#define  VTXTERR_NOTSUPPORTED             E_NOTIMPL                     // 0x80004001
#define  VTXTERR_NOTENOUGHDATA            AUDERR_NOTENOUGHDATA          // 0x80040201
#define  VTXTERR_QUEUEFULL                TTSERR_QUEUEFULL              // 0x8004020A
#define  VTXTERR_VALUEOUTOFRANGE          E_UNEXPECTED                  // 0x8000FFFF
#define  VTXTERR_INVALIDWINDOW            OLE_E_INVALIDHWND             // 0x8004000F
#define  VTXTERR_WAVEDEVICEBUSY           AUDERR_WAVEDEVICEBUSY         // 0x80040203
#define  VTXTERR_WAVEFORMATNOTSUPPORTED   AUDERR_WAVEFORMATNOTSUPPORTED // 0x80040202
#define  VTXTERR_INVALIDCHAR              SRERR_INVALIDCHAR             // 0x80040208


// ILexPronounce errors
#define  LEXERR_INVALIDTEXTCHAR           LEXERROR(0x01)                // 0x80040801
#define  LEXERR_INVALIDSENSE              LEXERROR(0x02)                // 0x80040802
#define  LEXERR_NOTINLEX                  LEXERROR(0x03)                // 0x80040803
#define  LEXERR_OUTOFDISK                 LEXERROR(0x04)                // 0x80040804
#define  LEXERR_INVALIDPRONCHAR           LEXERROR(0x05)                // 0x80040805
#define  LEXERR_ALREADYINLEX              LEXERROR(0x06)                // 0x80040806
#define  LEXERR_PRNBUFTOOSMALL            LEXERROR(0x07)                // 0x80040807
#define  LEXERR_ENGBUFTOOSMALL            LEXERROR(0x08)                // 0x80040808



/************************************************************************
typedefs */

typedef LPUNKNOWN FAR * PIUNKNOWN;

typedef struct {
   PVOID    pData;
   DWORD    dwSize;
   } SDATA, * PSDATA;



typedef struct {
   LANGID   LanguageID;
   WCHAR    szDialect[LANG_LEN];
   } LANGUAGEW, FAR * PLANGUAGEW;

typedef struct {
   LANGID   LanguageID;
   CHAR     szDialect[LANG_LEN];
   } LANGUAGEA, FAR * PLANGUAGEA;

#ifdef  _S_UNICODE
#define LANGUAGE    LANGUAGEW
#define PLANGUAGE   PLANGUAGEW
#else
#define LANGUAGE    LANGUAGEA
#define PLANGUAGE   PLANGUAGEA
#endif  // _S_UNICODE



typedef unsigned _int64 QWORD, * PQWORD;

typedef enum {
   CHARSET_TEXT           = 0,
   CHARSET_IPAPHONETIC    = 1,
   CHARSET_ENGINEPHONETIC = 2
   } VOICECHARSET;

typedef enum _VOICEPARTOFSPEECH {
   VPS_UNKNOWN = 0,
   VPS_NOUN = 1,
   VPS_VERB = 2,
   VPS_ADVERB = 3,
   VPS_ADJECTIVE = 4,
   VPS_PROPERNOUN = 5,
   VPS_PRONOUN = 6,
   VPS_CONJUNCTION = 7,
   VPS_CARDINAL = 8,
   VPS_ORDINAL = 9,
   VPS_DETERMINER = 10,
   VPS_QUANTIFIER = 11,
   VPS_PUNCTUATION = 12,
   VPS_CONTRACTION = 13,
   VPS_INTERJECTION = 14,
   VPS_ABBREVIATION = 15,
   VPS_PREPOSITION = 16
   } VOICEPARTOFSPEECH;


typedef struct {
   DWORD   dwNextPhonemeNode;
   DWORD   dwUpAlternatePhonemeNode;
   DWORD   dwDownAlternatePhonemeNode;
   DWORD   dwPreviousPhonemeNode;
   DWORD   dwWordNode;
   QWORD   qwStartTime;
   QWORD   qwEndTime;
   DWORD   dwPhonemeScore;
   WORD    wVolume;
   WORD    wPitch;
   } SRRESPHONEMENODE, *PSRRESPHONEMENODE;


typedef struct {
   DWORD   dwNextWordNode;
   DWORD   dwUpAlternateWordNode;
   DWORD   dwDownAlternateWordNode;
   DWORD   dwPreviousWordNode;
   DWORD   dwPhonemeNode;
   QWORD   qwStartTime;
   QWORD   qwEndTime;
   DWORD   dwWordScore;
   WORD      wVolume;
   WORD      wPitch;
   VOICEPARTOFSPEECH   pos;
   DWORD   dwCFGParse;
   DWORD   dwCue;
   } SRRESWORDNODE, * PSRRESWORDNODE;


/************************************************************************
interfaces */

/*
 * ILexPronounce
 */

#undef   INTERFACE
#define  INTERFACE   ILexPronounceW

DEFINE_GUID(IID_ILexPronounceW, 0x090CD9A2, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ILexPronounceW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // LexPronounceW members
   STDMETHOD (Add)            (THIS_ VOICECHARSET, PCWSTR, PCWSTR, 
			       VOICEPARTOFSPEECH, PVOID, DWORD) PURE;
   STDMETHOD (Get)            (THIS_ VOICECHARSET, PCWSTR, WORD, PWSTR, 
			       DWORD, DWORD *, VOICEPARTOFSPEECH *, PVOID, 
			       DWORD, DWORD *) PURE;
   STDMETHOD (Remove)         (THIS_ PCWSTR, WORD) PURE;
   };

typedef ILexPronounceW FAR * PILEXPRONOUNCEW;


#undef   INTERFACE
#define  INTERFACE   ILexPronounceA

DEFINE_GUID(IID_ILexPronounceA, 0x2F26B9C0L, 0xDB31, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ILexPronounceA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // LexPronounceA members
   STDMETHOD (Add)            (THIS_ VOICECHARSET, PCSTR, PCSTR, 
			       VOICEPARTOFSPEECH, PVOID, DWORD) PURE;
   STDMETHOD (Get)            (THIS_ VOICECHARSET, PCSTR, WORD, PSTR, 
			       DWORD, DWORD *, VOICEPARTOFSPEECH *, PVOID, 
			       DWORD, DWORD *) PURE;
   STDMETHOD (Remove)         (THIS_ PCSTR, WORD) PURE;
   };

typedef ILexPronounceA FAR * PILEXPRONOUNCEA;


#ifdef _S_UNICODE
 #define ILexPronounce        ILexPronounceW
 #define IID_ILexPronounce    IID_ILexPronounceW
 #define PILEXPRONOUNCE       PILEXPRONOUNCEW

#else
 #define ILexPronounce        ILexPronounceA
 #define IID_ILexPronounce    IID_ILexPronounceA
 #define PILEXPRONOUNCE       PILEXPRONOUNCEA

#endif   // _S_UNICODE



/************************************************************************
Audio source/destiantion API
*/

/************************************************************************
defines */

// AudioStop
#define      IANSRSN_NODATA             0
#define      IANSRSN_PRIORITY           1
#define      IANSRSN_INACTIVE           2
#define      IANSRSN_EOF                3

// IAudioSourceInstrumented::StateSet
#define          IASISTATE_PASSTHROUGH      0
#define          IASISTATE_PASSNOTHING      1
#define          IASISTATE_PASSREADFROMWAVE 2
#define          IASISTATE_PASSWRITETOWAVE  3

/************************************************************************
typedefs */

/************************************************************************
Class IDs */
// {CB96B400-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(CLSID_MMAudioDest, 
0xcb96b400, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);
// {D24FE500-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(CLSID_MMAudioSource, 
0xd24fe500, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);
// {D4023720-E4B9-11cf-8D56-00A0C9034A7E}
DEFINE_GUID(CLSID_InstAudioSource, 
0xd4023720, 0xe4b9, 0x11cf, 0x8d, 0x56, 0x0, 0xa0, 0xc9, 0x3, 0x4a, 0x7e);

/************************************************************************
interfaces */

// IAudio
#undef   INTERFACE
#define  INTERFACE   IAudio

// {F546B340-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(IID_IAudio, 
0xf546b340, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (IAudio, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IAudio members
   STDMETHOD (Flush)          (THIS) PURE;
   STDMETHOD (LevelGet)       (THIS_ DWORD *) PURE;
   STDMETHOD (LevelSet)       (THIS_ DWORD) PURE;
   STDMETHOD (PassNotify)     (THIS_ PVOID, IID) PURE;
   STDMETHOD (PosnGet)        (THIS_ PQWORD) PURE;
   STDMETHOD (Claim)          (THIS) PURE;
   STDMETHOD (UnClaim)        (THIS) PURE;
   STDMETHOD (Start)          (THIS) PURE;
   STDMETHOD (Stop)           (THIS) PURE;
   STDMETHOD (TotalGet)       (THIS_ PQWORD) PURE;
   STDMETHOD (ToFileTime)     (THIS_ PQWORD, FILETIME *) PURE;
   STDMETHOD (WaveFormatGet)  (THIS_ PSDATA) PURE;
   STDMETHOD (WaveFormatSet)  (THIS_ SDATA) PURE;
   };

typedef IAudio FAR * PIAUDIO;

// IAudioDest

#undef   INTERFACE
#define  INTERFACE   IAudioDest

// {2EC34DA0-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(IID_IAudioDest, 
0x2ec34da0, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (IAudioDest, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IAudioDest members
   STDMETHOD (FreeSpace)      (THIS_ DWORD *, BOOL *) PURE;
   STDMETHOD (DataSet)        (THIS_ PVOID, DWORD) PURE;
   STDMETHOD (BookMark)       (THIS_ DWORD) PURE;
   };

typedef IAudioDest FAR * PIAUDIODEST;



// IAudioDestNotifySink

#undef   INTERFACE
#define  INTERFACE   IAudioDestNotifySink

// {ACB08C00-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(IID_IAudioDestNotifySink, 
0xacb08c00, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (IAudioDestNotifySink, IUnknown) {
   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IAudioDestNotifySink members
   STDMETHOD (AudioStop)      (THIS_ WORD) PURE;
   STDMETHOD (AudioStart)     (THIS) PURE;
   STDMETHOD (FreeSpace)      (THIS_ DWORD, BOOL) PURE;
   STDMETHOD (BookMark)       (THIS_ DWORD, BOOL) PURE;
   };

typedef IAudioDestNotifySink FAR * PIAUDIODESTNOTIFYSINK;



// IAudioMultiMediaDevice

#undef   INTERFACE
#define  INTERFACE   IAudioMultiMediaDevice

// {B68AD320-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(IID_IAudioMultiMediaDevice, 
0xb68ad320, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (IAudioMultiMediaDevice, IUnknown) {
   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IAudioMultiMediaDevice members
   STDMETHOD (CustomMessage)  (THIS_ UINT, SDATA) PURE;
   STDMETHOD (DeviceNumGet)   (THIS_ DWORD*) PURE;
   STDMETHOD (DeviceNumSet)   (THIS_ DWORD) PURE;
   };

typedef IAudioMultiMediaDevice FAR * PIAUDIOMULTIMEDIADEVICE;



// IAudioSource
#undef   INTERFACE
#define  INTERFACE   IAudioSource

// {BC06A220-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(IID_IAudioSource, 
0xbc06a220, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (IAudioSource, IUnknown) {
   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IAudioSource members
   STDMETHOD (DataAvailable)  (THIS_ DWORD *, BOOL *) PURE;
   STDMETHOD (DataGet)        (THIS_ PVOID, DWORD, DWORD *) PURE;
   };

typedef IAudioSource FAR * PIAUDIOSOURCE;



// IAudioSourceInstrumented
#undef   INTERFACE
#define  INTERFACE   IAudioSourceInstrumented

// {D4023721-E4B9-11cf-8D56-00A0C9034A7E}
DEFINE_GUID(IID_IAudioSourceInstrumented, 
0xd4023721, 0xe4b9, 0x11cf, 0x8d, 0x56, 0x0, 0xa0, 0xc9, 0x3, 0x4a, 0x7e);

DECLARE_INTERFACE_ (IAudioSourceInstrumented, IUnknown) {
   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IAudioSourceInstrumented members
   STDMETHOD (AudioSource)    (THIS_ LPUNKNOWN) PURE;
   STDMETHOD (RegistryGet)    (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (RegistrySet)    (THIS_ PCWSTR) PURE;
   STDMETHOD (StateGet)       (THIS_ DWORD*) PURE;
   STDMETHOD (StateSet)       (THIS_ DWORD) PURE;
   STDMETHOD (WaveFileReadGet)(THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (WaveFileReadSet)(THIS_ PCWSTR) PURE;
   STDMETHOD (WaveFileWriteGet)(THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (WaveFileWriteSet)(THIS_ PCWSTR) PURE;
   };

typedef IAudioSourceInstrumented FAR * PIAUDIOSOURCEINSTRUMENTED;


// IAudioSourceNotifySink
#undef   INTERFACE
#define  INTERFACE   IAudioSourceNotifySink

// {C0BD9A80-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(IID_IAudioSourceNotifySink, 
0xc0bd9a80, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (IAudioSourceNotifySink, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IAudioSourceNotifySink members
   STDMETHOD (AudioStop)      (THIS_ WORD) PURE;
   STDMETHOD (AudioStart)     (THIS) PURE;
   STDMETHOD (DataAvailable)  (THIS_ DWORD, BOOL) PURE;
   STDMETHOD (Overflow)       (THIS_ DWORD) PURE;
   };

typedef IAudioSourceNotifySink FAR * PIAUDIOSOURCENOTIFYSINK;



/************************************************************************
defines */
/* SRINFO */
#define  SRMI_NAMELEN                  SVFN_LEN

#define  SRSEQUENCE_DISCRETE           (0)
#define  SRSEQUENCE_CONTINUOUS          (1)
#define  SRSEQUENCE_WORDSPOT            (2)
#define  SRSEQUENCE_CONTCFGDISCDICT     (3)

#define  SRGRAM_CFG                    SETBIT(0)
#define  SRGRAM_DICTATION              SETBIT(1)
#define  SRGRAM_LIMITEDDOMAIN          SETBIT(2)

#define  SRFEATURE_INDEPSPEAKER        SETBIT(0)
#define  SRFEATURE_INDEPMICROPHONE     SETBIT(1)
#define  SRFEATURE_TRAINWORD           SETBIT(2)
#define  SRFEATURE_TRAINPHONETIC       SETBIT(3)
#define  SRFEATURE_WILDCARD            SETBIT(4)
#define  SRFEATURE_ANYWORD             SETBIT(5)
#define  SRFEATURE_PCOPTIMIZED         SETBIT(6)
#define  SRFEATURE_PHONEOPTIMIZED      SETBIT(7)
#define  SRFEATURE_GRAMLIST            SETBIT(8)
#define  SRFEATURE_GRAMLINK            SETBIT(9)
#define  SRFEATURE_MULTILINGUAL        SETBIT(10)
#define  SRFEATURE_GRAMRECURSIVE       SETBIT(11)
#define  SRFEATURE_IPAUNICODE          SETBIT(12)

#define  SRI_ILEXPRONOUNCE             SETBIT(0)
#define  SRI_ISRATTRIBUTES             SETBIT(1)
#define  SRI_ISRCENTRAL                SETBIT(2)
#define  SRI_ISRDIALOGS                SETBIT(3)
#define  SRI_ISRGRAMCOMMON             SETBIT(4)
#define  SRI_ISRGRAMCFG                SETBIT(5)
#define  SRI_ISRGRAMDICTATION          SETBIT(6)
#define  SRI_ISRGRAMINSERTIONGUI       SETBIT(7)
#define  SRI_ISRESBASIC                SETBIT(8)
#define  SRI_ISRESMERGE                SETBIT(9)
#define  SRI_ISRESAUDIO                SETBIT(10)
#define  SRI_ISRESCORRECTION           SETBIT(11)
#define  SRI_ISRESEVAL                 SETBIT(12)
#define  SRI_ISRESGRAPH                SETBIT(13)
#define  SRI_ISRESMEMORY               SETBIT(14)
#define  SRI_ISRESMODIFYGUI            SETBIT(15)
#define  SRI_ISRESSPEAKER              SETBIT(16)
#define  SRI_ISRSPEAKER                SETBIT(17)
#define  SRI_ISRESSCORES               SETBIT(18)


// ISRGramCommon::TrainQuery
#define   SRGRAMQ_NONE                    0
#define   SRGRAMQ_GENERALTRAIN            1
#define   SRGRAMQ_PHRASE                  2
#define   SRGRAMQ_DIALOG                  3

// ISRGramNotifySink::PhraseFinish
#define   ISRNOTEFIN_RECOGNIZED         SETBIT(0)
#define   ISRNOTEFIN_THISGRAMMAR        SETBIT(1)
#define   ISRNOTEFIN_FROMTHISGRAMMAR    SETBIT(2)

// ISRGramNotifySink::Training
#define   SRGNSTRAIN_GENERAL            SETBIT(0)
#define   SRGNSTRAIN_GRAMMAR            SETBIT(1)
#define   SRGNSTRAIN_MICROPHONE         SETBIT(2)

// ISRNotifySink::AttribChange
#define   ISRNSAC_AUTOGAINENABLE        1
#define   ISRNSAC_THRESHOLD             2
#define   ISRNSAC_ECHO                  3
#define   ISRNSAC_ENERGYFLOOR           4
#define   ISRNSAC_MICROPHONE            5
#define   ISRNSAC_REALTIME              6
#define   ISRNSAC_SPEAKER               7
#define   ISRNSAC_TIMEOUT               8

/* Interference */
#define  SRMSGINT_NOISE                (0x0001)
#define  SRMSGINT_NOSIGNAL             (0x0002)
#define  SRMSGINT_TOOLOUD              (0x0003)
#define  SRMSGINT_TOOQUIET             (0x0004)
#define  SRMSGINT_AUDIODATA_STOPPED    (0x0005)
#define  SRMSGINT_AUDIODATA_STARTED    (0x0006)
#define  SRMSGINT_IAUDIO_STARTED       (0x0007)
#define  SRMSGINT_IAUDIO_STOPPED       (0x0008)

// Gramamr header values
#define   SRHDRTYPE_CFG                  0
#define   SRHDRTYPE_LIMITEDDOMAIN        1
#define   SRHDRTYPE_DICTATION            2

#define   SRHDRFLAG_UNICODE              SETBIT(0)  

/* SRCFGSYMBOL */
#define  SRCFG_STARTOPERATION          (1)
#define  SRCFG_ENDOPERATION            (2)
#define  SRCFG_WORD                    (3)
#define  SRCFG_RULE                    (4)
#define  SRCFG_WILDCARD                (5)
#define  SRCFG_LIST                    (6)

#define  SRCFGO_SEQUENCE               (1)
#define  SRCFGO_ALTERNATIVE            (2)
#define  SRCFGO_REPEAT                 (3)
#define  SRCFGO_OPTIONAL               (4)


// Grammar-chunk IDs
#define   SRCK_LANGUAGE                  1
#define   SRCKCFG_WORDS                  2
#define   SRCKCFG_RULES                  3
#define   SRCKCFG_EXPORTRULES            4
#define   SRCKCFG_IMPORTRULES            5
#define   SRCKCFG_LISTS                  6
#define   SRCKD_TOPIC                    7
#define   SRCKD_COMMON                   8
#define   SRCKD_GROUP                    9
#define   SRCKD_SAMPLE                   10
#define   SRCKLD_WORDS                   11
#define   SRCKLD_GROUP                   12
#define   SRCKLD_SAMPLE                  13 
#define   SRCKD_WORDCOUNT                14

/* TrainQuery */
#define  SRTQEX_REQUIRED               (0x0000)
#define  SRTQEX_RECOMMENDED            (0x0001)

/* ISRResCorrection */
#define  SRCORCONFIDENCE_SOME          (0x0001)
#define  SRCORCONFIDENCE_VERY          (0x0002)

/* ISRResMemory constants */
#define  SRRESMEMKIND_AUDIO            SETBIT(0)
#define  SRRESMEMKIND_CORRECTION       SETBIT(1)
#define  SRRESMEMKIND_EVAL             SETBIT(2)
#define  SRRESMEMKIND_PHONEMEGRAPH     SETBIT(3)
#define  SRRESMEMKIND_WORDGRAPH        SETBIT(4)

// Attribute minimums and maximums
#define  SRATTR_MINAUTOGAIN               0
#define  SRATTR_MAXAUTOGAIN               100
#define  SRATTR_MINENERGYFLOOR            0
#define  SRATTR_MAXENERGYFLOOR            0xffff
#define  SRATTR_MINREALTIME               0
#define  SRATTR_MAXREALTIME               0xffffffff
#define  SRATTR_MINTHRESHOLD              0
#define  SRATTR_MAXTHRESHOLD              100
#define  SRATTR_MINTOINCOMPLETE           0
#define  SRATTR_MAXTOINCOMPLETE           0xffffffff
#define  SRATTR_MINTOCOMPLETE             0
#define  SRATTR_MAXTOCOMPLETE             0xffffffff


/************************************************************************
typedefs */

typedef struct {
   DWORD    dwSize;
   DWORD    dwUniqueID;
   BYTE     abData[0];
   } SRCFGRULE, * PSRCFGRULE;



typedef struct {
   DWORD    dwSize;
   DWORD    dwRuleNum;
   WCHAR    szString[0];
   } SRCFGIMPRULEW, * PSRCFGIMPRULEW;

typedef struct {
   DWORD    dwSize;
   DWORD    dwRuleNum;
   CHAR     szString[0];
   } SRCFGIMPRULEA, * PSRCFGIMPRULEA;

#ifdef  _S_UNICODE
#define  SRCFGIMPRULE      SRCFGIMPRULEW
#define  PSRCFGIMPRULE     PSRCFGIMPRULEW
#else
#define  SRCFGIMPRULE      SRCFGIMPRULEA
#define  PSRCFGIMPRULE     PSRCFGIMPRULEA
#endif  // _S_UNICODE



typedef struct {
   DWORD    dwSize;
   DWORD    dwRuleNum;
   WCHAR    szString[0];
   } SRCFGXRULEW, * PSRCFGXRULEW;

typedef struct {
   DWORD    dwSize;
   DWORD    dwRuleNum;
   CHAR     szString[0];
   } SRCFGXRULEA, * PSRCFGXRULEA;

#ifdef  _S_UNICODE
#define  SRCFGXRULE     SRCFGXRULEW
#define  PSRCFGXRULE    PSRCFGXRULEW
#else
#define  SRCFGXRULE     SRCFGXRULEA
#define  PSRCFGXRULE    PSRCFGXRULEA
#endif  // _S_UNICODE



typedef struct {
   DWORD    dwSize;
   DWORD    dwListNum;
   WCHAR    szString[0];
   } SRCFGLISTW, * PSRCFGLISTW;

typedef struct {
   DWORD    dwSize;
   DWORD    dwListNum;
   CHAR     szString[0];
   } SRCFGLISTA, * PSRCFGLISTA;

#ifdef  _S_UNICODE
#define  SRCFGLIST      SRCFGLISTW
#define  PSRCFGLIST     PSRCFGLISTW
#else
#define  SRCFGLIST      SRCFGLISTA
#define  PSRCFGLIST     PSRCFGLISTA
#endif  // _S_UNICODE



typedef struct {
   WORD     wType;
   WORD     wProbability;
   DWORD    dwValue;
   } SRCFGSYMBOL, * PSRCFGSYMBOL;



typedef struct {
   DWORD    dwSize;
   DWORD    dwWordNum;
   WCHAR    szWord[0];
   } SRWORDW, * PSRWORDW;

typedef struct {
   DWORD    dwSize;
   DWORD    dwWordNum;
   CHAR     szWord[0];
   } SRWORDA, * PSRWORDA;

#ifdef  _S_UNICODE
#define  SRWORD      SRWORDW
#define  PSRWORD     PSRWORDW
#else
#define  SRWORD      SRWORDA
#define  PSRWORD     PSRWORDA
#endif  // _S_UNICODE



typedef struct {
   DWORD    dwSize;
   BYTE     abWords[0];
   } SRPHRASEW, * PSRPHRASEW;

typedef struct {
   DWORD    dwSize;
   BYTE     abWords[0];
   } SRPHRASEA, * PSRPHRASEA;

#ifdef  _S_UNICODE
#define  SRPHRASE    SRPHRASEW
#define  PSRPHRASE   PSRPHRASEW
#else
#define  SRPHRASE    SRPHRASEA
#define  PSRPHRASE   PSRPHRASEA
#endif  // _S_UNICODE



typedef struct {
   DWORD      dwType;
   DWORD      dwFlags;
   } SRHEADER, *PSRHEADER;

typedef struct {
   DWORD      dwChunkID;
   DWORD      dwChunkSize;
   BYTE       avInfo[0];
   } SRCHUNK, *PSRCHUNK;



typedef struct {
   GUID       gEngineID;
   WCHAR      szMfgName[SRMI_NAMELEN];
   WCHAR      szProductName[SRMI_NAMELEN];
   GUID       gModeID;
   WCHAR      szModeName[SRMI_NAMELEN];
   LANGUAGEW  language;
   DWORD      dwSequencing;
   DWORD      dwMaxWordsVocab;
   DWORD      dwMaxWordsState;
   DWORD      dwGrammars;
   DWORD      dwFeatures;
   DWORD      dwInterfaces;
   DWORD      dwEngineFeatures;
   } SRMODEINFOW, * PSRMODEINFOW;

typedef struct {
   GUID       gEngineID;
   CHAR       szMfgName[SRMI_NAMELEN];
   CHAR       szProductName[SRMI_NAMELEN];
   GUID       gModeID;
   CHAR       szModeName[SRMI_NAMELEN];
   LANGUAGEA  language;
   DWORD      dwSequencing;
   DWORD      dwMaxWordsVocab;
   DWORD      dwMaxWordsState;
   DWORD      dwGrammars;
   DWORD      dwFeatures;
   DWORD      dwInterfaces;
   DWORD      dwEngineFeatures;
   } SRMODEINFOA, * PSRMODEINFOA;

#ifdef  _S_UNICODE
#define  SRMODEINFO     SRMODEINFOW
#define  PSRMODEINFO    PSRMODEINFOW
#else
#define  SRMODEINFO     SRMODEINFOA
#define  PSRMODEINFO    PSRMODEINFOA
#endif  // _S_UNICODE



typedef struct {
   DWORD      dwEngineID;
   DWORD      dwMfgName;
   DWORD      dwProductName;
   DWORD      dwModeID;
   DWORD      dwModeName;
   DWORD      dwLanguage;
   DWORD      dwDialect;
   DWORD      dwSequencing;
   DWORD      dwMaxWordsVocab;
   DWORD      dwMaxWordsState;
   DWORD      dwGrammars;
   DWORD      dwFeatures;
   DWORD      dwInterfaces;
   DWORD      dwEngineFeatures;
   } SRMODEINFORANK, * PSRMODEINFORANK;



// speech recognition enumeration sharing object
typedef struct {
   QWORD        qwInstanceID;
   DWORD        dwDeviceID;
   SRMODEINFOW  srModeInfo;
} SRSHAREW, * PSRSHAREW;

typedef struct {
   QWORD        qwInstanceID;
   DWORD        dwDeviceID;
   SRMODEINFOA  srModeInfo;
} SRSHAREA, * PSRSHAREA;

#ifdef  _S_UNICODE
#define  SRSHARE    SRSHAREW
#define  PSRSHARE   PSRSHAREW
#else
#define  SRSHARE    SRSHAREA
#define  PSRSHARE   PSRSHAREA
#endif  // _S_UNICODE




// ISRCentral::GrammarLoad
typedef enum {
   SRGRMFMT_CFG = 0x0000,
   SRGRMFMT_LIMITEDDOMAIN = 0x0001,
   SRGRMFMT_DICTATION = 0x0002,
   SRGRMFMT_CFGNATIVE = 0x8000,
   SRGRMFMT_LIMITEDDOMAINNATIVE = 0x8001,
   SRGRMFMT_DICTATIONNATIVE = 0x8002,
   } SRGRMFMT, * PSRGRMFMT;

/************************************************************************
Class IDs */


// {E02D16C0-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(CLSID_SREnumerator, 
0xe02d16c0, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);


/************************************************************************
interfaces */


/*
 * ISRAttributes
 */

#undef   INTERFACE
#define  INTERFACE   ISRAttributesW

DEFINE_GUID(IID_ISRAttributesW, 0x68A33AA0L, 0x44CD, 0x101B, 0x90, 0xA8, 0x00, 0xAA, 0x00, 0x3E, 0x4B, 0x50);

DECLARE_INTERFACE_ (ISRAttributesW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRAttributesW members
   STDMETHOD (AutoGainEnableGet) (THIS_ DWORD *) PURE;
   STDMETHOD (AutoGainEnableSet) (THIS_ DWORD) PURE;
   STDMETHOD (EchoGet)           (THIS_ BOOL *) PURE;
   STDMETHOD (EchoSet)           (THIS_ BOOL) PURE;
   STDMETHOD (EnergyFloorGet)    (THIS_ WORD *) PURE;
   STDMETHOD (EnergyFloorSet)    (THIS_ WORD) PURE;
   STDMETHOD (MicrophoneGet)     (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (MicrophoneSet)     (THIS_ PCWSTR) PURE;
   STDMETHOD (RealTimeGet)       (THIS_ DWORD *) PURE;
   STDMETHOD (RealTimeSet)       (THIS_ DWORD) PURE;
   STDMETHOD (SpeakerGet)        (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (SpeakerSet)        (THIS_ PCWSTR) PURE;
   STDMETHOD (TimeOutGet)        (THIS_ DWORD *, DWORD *) PURE;
   STDMETHOD (TimeOutSet)        (THIS_ DWORD, DWORD) PURE;
   STDMETHOD (ThresholdGet)      (THIS_ DWORD *) PURE;
   STDMETHOD (ThresholdSet)      (THIS_ DWORD) PURE;
   };

typedef ISRAttributesW FAR * PISRATTRIBUTESW;


#undef   INTERFACE
#define  INTERFACE   ISRAttributesA

DEFINE_GUID(IID_ISRAttributesA, 0x2F26B9C1L, 0xDB31, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRAttributesA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRAttributesA members
   STDMETHOD (AutoGainEnableGet) (THIS_ DWORD *) PURE;
   STDMETHOD (AutoGainEnableSet) (THIS_ DWORD) PURE;
   STDMETHOD (EchoGet)           (THIS_ BOOL *) PURE;
   STDMETHOD (EchoSet)           (THIS_ BOOL) PURE;
   STDMETHOD (EnergyFloorGet)    (THIS_ WORD *) PURE;
   STDMETHOD (EnergyFloorSet)    (THIS_ WORD) PURE;
   STDMETHOD (MicrophoneGet)     (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD (MicrophoneSet)     (THIS_ PCSTR) PURE;
   STDMETHOD (RealTimeGet)       (THIS_ DWORD *) PURE;
   STDMETHOD (RealTimeSet)       (THIS_ DWORD) PURE;
   STDMETHOD (SpeakerGet)        (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD (SpeakerSet)        (THIS_ PCSTR) PURE;
   STDMETHOD (TimeOutGet)        (THIS_ DWORD *, DWORD *) PURE;
   STDMETHOD (TimeOutSet)        (THIS_ DWORD, DWORD) PURE;
   STDMETHOD (ThresholdGet)      (THIS_ DWORD *) PURE;
   STDMETHOD (ThresholdSet)      (THIS_ DWORD) PURE;
   };

typedef ISRAttributesA FAR * PISRATTRIBUTESA;


#ifdef _S_UNICODE
 #define ISRAttributes        ISRAttributesW
 #define IID_ISRAttributes    IID_ISRAttributesW
 #define PISRATTRIBUTES       PISRATTRIBUTESW

#else
 #define ISRAttributes        ISRAttributesA
 #define IID_ISRAttributes    IID_ISRAttributesA
 #define PISRATTRIBUTES       PISRATTRIBUTESA

#endif // _S_UNICODE



/*
 * ISRCentral
 */

#undef   INTERFACE
#define  INTERFACE   ISRCentralW

DEFINE_GUID(IID_ISRCentralW, 0xB9BD3860L, 0x44DB, 0x101B, 0x90, 0xA8, 0x00, 0xAA, 0x00, 0x3E, 0x4B, 0x50);

DECLARE_INTERFACE_ (ISRCentralW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRCentralW members
   STDMETHOD (ModeGet)        (THIS_ PSRMODEINFOW) PURE;
   STDMETHOD (GrammarLoad)    (THIS_ SRGRMFMT, SDATA, PVOID, IID, LPUNKNOWN *) PURE;
   STDMETHOD (Pause)          (THIS) PURE;
   STDMETHOD (PosnGet)        (THIS_ PQWORD) PURE;
   STDMETHOD (Resume)         (THIS) PURE;
   STDMETHOD (ToFileTime)     (THIS_ PQWORD, FILETIME *) PURE;
   STDMETHOD (Register)       (THIS_ PVOID, IID, DWORD*) PURE;
   STDMETHOD (UnRegister)     (THIS_ DWORD) PURE;
   };

typedef ISRCentralW FAR * PISRCENTRALW;


#undef   INTERFACE
#define  INTERFACE   ISRCentralA

DEFINE_GUID(IID_ISRCentralA, 0x2F26B9C2L, 0xDB31, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRCentralA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRCentralA members
   STDMETHOD (ModeGet)        (THIS_ PSRMODEINFOA) PURE;
   STDMETHOD (GrammarLoad)    (THIS_ SRGRMFMT, SDATA, PVOID, IID, LPUNKNOWN *) PURE;
   STDMETHOD (Pause)          (THIS) PURE;
   STDMETHOD (PosnGet)        (THIS_ PQWORD) PURE;
   STDMETHOD (Resume)         (THIS) PURE;
   STDMETHOD (ToFileTime)     (THIS_ PQWORD, FILETIME *) PURE;
   STDMETHOD (Register)       (THIS_ PVOID, IID, DWORD*) PURE;
   STDMETHOD (UnRegister)     (THIS_ DWORD) PURE;
   };

typedef ISRCentralA FAR * PISRCENTRALA;


#ifdef _S_UNICODE
 #define ISRCentral           ISRCentralW
 #define IID_ISRCentral       IID_ISRCentralW
 #define PISRCENTRAL          PISRCENTRALW

#else
 #define ISRCentral           ISRCentralA
 #define IID_ISRCentral       IID_ISRCentralA
 #define PISRCENTRAL          PISRCENTRALA

#endif   // _S_UNICODE



/*
 * ISRDialogs
 */

#undef   INTERFACE
#define  INTERFACE   ISRDialogsW

DEFINE_GUID(IID_ISRDialogsW, 0xBCFB4C60L, 0x44DB, 0x101B, 0x90, 0xA8, 0x00, 0xAA, 0x00, 0x3E, 0x4B, 0x50);

DECLARE_INTERFACE_ (ISRDialogsW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRDialogsW members
   STDMETHOD (AboutDlg)       (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (GeneralDlg)     (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (LexiconDlg)     (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TrainMicDlg)    (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TrainGeneralDlg)(THIS_ HWND, PCWSTR) PURE;
   };

typedef ISRDialogsW FAR * PISRDIALOGSW;


#undef   INTERFACE
#define  INTERFACE   ISRDialogsA

DEFINE_GUID(IID_ISRDialogsA, 0x05EB6C60L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRDialogsA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRDialogsA members
   STDMETHOD (AboutDlg)       (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (GeneralDlg)     (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (LexiconDlg)     (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TrainMicDlg)    (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TrainGeneralDlg)(THIS_ HWND, PCSTR) PURE;
   };

typedef ISRDialogsA FAR * PISRDIALOGSA;


#ifdef _S_UNICODE
 #define ISRDialogs        ISRDialogsW
 #define IID_ISRDialogs    IID_ISRDialogsW
 #define PISRDIALOGS       PISRDIALOGSW

#else
 #define ISRDialogs        ISRDialogsA
 #define IID_ISRDialogs    IID_ISRDialogsA
 #define PISRDIALOGS       PISRDIALOGSA

#endif



/*
 *  ISREnum
 */

#undef   INTERFACE
#define  INTERFACE   ISREnumW

DEFINE_GUID(IID_ISREnumW, 0xBFA9F1A0L, 0x44DB, 0x101B, 0x90, 0xA8, 0x00, 0xAA, 0x00, 0x3E, 0x4B, 0x50);

DECLARE_INTERFACE_ (ISREnumW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISREnumW members
   STDMETHOD (Next)           (THIS_ ULONG, PSRMODEINFOW, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ ISREnumW * FAR *) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PISRCENTRALW *, LPUNKNOWN) PURE;
   };

typedef ISREnumW FAR * PISRENUMW;


#undef   INTERFACE
#define  INTERFACE   ISREnumA

DEFINE_GUID(IID_ISREnumA, 0x05EB6C61L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISREnumA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISREnumA members
   STDMETHOD (Next)           (THIS_ ULONG, PSRMODEINFOA, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ ISREnumA * FAR *) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PISRCENTRALA *, LPUNKNOWN) PURE;
   };

typedef ISREnumA FAR * PISRENUMA;


#ifdef _S_UNICODE
 #define ISREnum           ISREnumW
 #define IID_ISREnum       IID_ISREnumW
 #define PISRENUM          PISRENUMW

#else
 #define ISREnum           ISREnumA
 #define IID_ISREnum       IID_ISREnumA
 #define PISRENUM          PISRENUMA

#endif



/*
 * ISRFind
 */

#undef   INTERFACE
#define  INTERFACE   ISRFindW

DEFINE_GUID(IID_ISRFindW, 0xC2835060L, 0x44DB, 0x101B, 0x90, 0xA8, 0x00, 0xAA, 0x00, 0x3E, 0x4B, 0x50);

DECLARE_INTERFACE_ (ISRFindW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRFindW members
   STDMETHOD (Find)           (THIS_ PSRMODEINFOW, PSRMODEINFORANK, PSRMODEINFOW) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PISRCENTRALW *, LPUNKNOWN) PURE;
   };

typedef ISRFindW FAR * PISRFINDW;


#undef   INTERFACE
#define  INTERFACE   ISRFindA

DEFINE_GUID(IID_ISRFindA, 0x05EB6C62L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRFindA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRFindA members
   STDMETHOD (Find)           (THIS_ PSRMODEINFOA, PSRMODEINFORANK, PSRMODEINFOA) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PISRCENTRALA *, LPUNKNOWN) PURE;
   };

typedef ISRFindA FAR * PISRFINDA;


#ifdef _S_UNICODE
 #define ISRFind           ISRFindW
 #define IID_ISRFind       IID_ISRFindW
 #define PISRFIND          PISRFINDW

#else
 #define ISRFind           ISRFindA
 #define IID_ISRFind       IID_ISRFindA
 #define PISRFIND          PISRFINDA

#endif



/*
 * ISRGramCommon
 */

#undef   INTERFACE
#define  INTERFACE   ISRGramCommonW

DEFINE_GUID(IID_ISRGramCommonW, 0xe8c3e160, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (ISRGramCommonW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)     (THIS) PURE;
   STDMETHOD_(ULONG,Release)    (THIS) PURE;

   // ISRGramCommonW members
   STDMETHOD (Activate)         (THIS_ HWND, BOOL, PCWSTR) PURE;
   STDMETHOD (Archive)          (THIS_ BOOL, PVOID, DWORD, DWORD *) PURE;
   STDMETHOD (BookMark)         (THIS_ QWORD, DWORD) PURE;
   STDMETHOD (Deactivate)       (THIS_ PCWSTR) PURE;
   STDMETHOD (DeteriorationGet) (THIS_ DWORD *, DWORD *, DWORD *) PURE;
   STDMETHOD (DeteriorationSet) (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (TrainDlg)         (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TrainPhrase)      (THIS_ DWORD, PSDATA) PURE;
   STDMETHOD (TrainQuery)       (THIS_ DWORD *) PURE;
   };

typedef ISRGramCommonW FAR * PISRGRAMCOMMONW;


#undef   INTERFACE
#define  INTERFACE   ISRGramCommonA

DEFINE_GUID(IID_ISRGramCommonA, 0x05EB6C63L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRGramCommonA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)     (THIS) PURE;
   STDMETHOD_(ULONG,Release)    (THIS) PURE;

   // ISRGramCommonA members
   STDMETHOD (Activate)         (THIS_ HWND, BOOL, PCSTR) PURE;
   STDMETHOD (Archive)          (THIS_ BOOL, PVOID, DWORD, DWORD *) PURE;
   STDMETHOD (BookMark)         (THIS_ QWORD, DWORD) PURE;
   STDMETHOD (Deactivate)       (THIS_ PCSTR) PURE;
   STDMETHOD (DeteriorationGet) (THIS_ DWORD *, DWORD *, DWORD *) PURE;
   STDMETHOD (DeteriorationSet) (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (TrainDlg)         (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TrainPhrase)      (THIS_ DWORD, PSDATA) PURE;
   STDMETHOD (TrainQuery)       (THIS_ DWORD *) PURE;
   };

typedef ISRGramCommonA FAR * PISRGRAMCOMMONA;


#ifdef _S_UNICODE
 #define ISRGramCommon        ISRGramCommonW
 #define IID_ISRGramCommon    IID_ISRGramCommonW
 #define PISRGRAMCOMMON       PISRGRAMCOMMONW

#else
 #define ISRGramCommon        ISRGramCommonA
 #define IID_ISRGramCommon    IID_ISRGramCommonA
 #define PISRGRAMCOMMON       PISRGRAMCOMMONA

#endif



/*
 * ISRGramCFG
 */

#undef   INTERFACE
#define  INTERFACE   ISRGramCFGW

DEFINE_GUID(IID_ISRGramCFGW, 0xecc0b180, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (ISRGramCFGW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRGramCFGW members
   STDMETHOD (LinkQuery)      (THIS_ PCWSTR, BOOL *) PURE;
   STDMETHOD (ListAppend)     (THIS_ PCWSTR, SDATA) PURE;
   STDMETHOD (ListGet)        (THIS_ PCWSTR, PSDATA) PURE;
   STDMETHOD (ListRemove)     (THIS_ PCWSTR, SDATA) PURE;
   STDMETHOD (ListSet)        (THIS_ PCWSTR, SDATA) PURE;
   STDMETHOD (ListQuery)      (THIS_ PCWSTR, BOOL *) PURE;
   };

typedef ISRGramCFGW FAR * PISRGRAMCFGW;


#undef   INTERFACE
#define  INTERFACE   ISRGramCFGA

DEFINE_GUID(IID_ISRGramCFGA, 0x05EB6C64L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRGramCFGA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRGramCFGA members
   STDMETHOD (LinkQuery)      (THIS_ PCSTR, BOOL *) PURE;
   STDMETHOD (ListAppend)     (THIS_ PCSTR, SDATA) PURE;
   STDMETHOD (ListGet)        (THIS_ PCSTR, PSDATA) PURE;
   STDMETHOD (ListRemove)     (THIS_ PCSTR, SDATA) PURE;
   STDMETHOD (ListSet)        (THIS_ PCSTR, SDATA) PURE;
   STDMETHOD (ListQuery)      (THIS_ PCSTR, BOOL *) PURE;
   };

typedef ISRGramCFGA FAR * PISRGRAMCFGA;


#ifdef _S_UNICODE
 #define ISRGramCFG        ISRGramCFGW
 #define IID_ISRGramCFG    IID_ISRGramCFGW
 #define PISRGRAMCFG       PISRGRAMCFGW

#else
 #define ISRGramCFG        ISRGramCFGA
 #define IID_ISRGramCFG    IID_ISRGramCFGA
 #define PISRGRAMCFG       PISRGRAMCFGA

#endif



/* 
 * ISRGramDictation
 */

#undef   INTERFACE
#define  INTERFACE   ISRGramDictationW

DEFINE_GUID(IID_ISRGramDictationW, 0x090CD9A3, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRGramDictationW, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRGramDictationW members
   STDMETHOD (Context)        (THIS_ PCWSTR, PCWSTR) PURE;
   STDMETHOD (Hint)           (THIS_ PCWSTR) PURE;
   STDMETHOD (Words)          (THIS_ PCWSTR) PURE;
   };

typedef ISRGramDictationW FAR *PISRGRAMDICTATIONW;


#undef   INTERFACE
#define  INTERFACE   ISRGramDictationA

DEFINE_GUID(IID_ISRGramDictationA, 0x05EB6C65L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRGramDictationA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRGramDictationA members
   STDMETHOD (Context)        (THIS_ PCSTR, PCSTR) PURE;
   STDMETHOD (Hint)           (THIS_ PCSTR) PURE;
   STDMETHOD (Words)          (THIS_ PCSTR) PURE;
   };

typedef ISRGramDictationA FAR *PISRGRAMDICTATIONA;


#ifdef _S_UNICODE
 #define ISRGramDictation        ISRGramDictationW
 #define IID_ISRGramDictation    IID_ISRGramDictationW
 #define PISRGRAMDICTATION       PISRGRAMDICTATIONW

#else
 #define ISRGramDictation        ISRGramDictationA
 #define IID_ISRGramDictation    IID_ISRGramDictationA
 #define PISRGRAMDICTATION       PISRGRAMDICTATIONA

#endif



// ISRGramInsertionGUI
// This does not need an ANSI/UNICODE interface because no characters are passed
#undef   INTERFACE
#define  INTERFACE   ISRGramInsertionGUI

// {090CD9A4-DA1A-11CD-B3CA-00AA0047BA4F}
DEFINE_GUID(IID_ISRGramInsertionGUI,
0x090CD9A4, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRGramInsertionGUI, IUnknown) {
   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRGramInsertionGUI members
   STDMETHOD (Hide)           (THIS) PURE;
   STDMETHOD (Move)           (THIS_ RECT) PURE;
   STDMETHOD (Show)           (THIS_ HWND) PURE;
   };

typedef ISRGramInsertionGUI FAR *PISRGRAMINSERTIONGUI;



/*
 * ISRGramNotifySink
 */

#undef   INTERFACE
#define  INTERFACE   ISRGramNotifySinkW

DEFINE_GUID(IID_ISRGramNotifySinkW,  0xf106bfa0, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

// {B1AAC561-75D6-11cf-8D15-00A0C9034A7E}
DEFINE_GUID(IID_ISRGramNotifySinkMW, 0xb1aac561, 0x75d6, 0x11cf, 0x8d, 0x15, 0x0, 0xa0, 0xc9, 0x3, 0x4a, 0x7e);

DECLARE_INTERFACE_ (ISRGramNotifySinkW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRGramNotifySinkW members
   STDMETHOD (BookMark)       (THIS_ DWORD) PURE;
   STDMETHOD (Paused)         (THIS) PURE;
   STDMETHOD (PhraseFinish)   (THIS_ DWORD, QWORD, QWORD, PSRPHRASEW, LPUNKNOWN) PURE;
   STDMETHOD (PhraseHypothesis)(THIS_ DWORD, QWORD, QWORD, PSRPHRASEW, LPUNKNOWN) PURE;
   STDMETHOD (PhraseStart)    (THIS_ QWORD) PURE;
   STDMETHOD (ReEvaluate)     (THIS_ LPUNKNOWN) PURE;
   STDMETHOD (Training)       (THIS_ DWORD) PURE;
   STDMETHOD (UnArchive)      (THIS_ LPUNKNOWN) PURE;
   };

typedef ISRGramNotifySinkW FAR * PISRGRAMNOTIFYSINKW;


// ISRGramNotifySinkA
#undef   INTERFACE
#define  INTERFACE   ISRGramNotifySinkA

// {EFEEA350-CE5E-11cd-9D96-00AA002FC7C9}
DEFINE_GUID(IID_ISRGramNotifySinkA, 
0xefeea350, 0xce5e, 0x11cd, 0x9d, 0x96, 0x0, 0xaa, 0x0, 0x2f, 0xc7, 0xc9);

// {B1AAC562-75D6-11cf-8D15-00A0C9034A7E}
DEFINE_GUID(IID_ISRGramNotifySinkMA, 
0xb1aac562, 0x75d6, 0x11cf, 0x8d, 0x15, 0x0, 0xa0, 0xc9, 0x3, 0x4a, 0x7e);

DECLARE_INTERFACE_ (ISRGramNotifySinkA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRGramNotifySinkA members
   STDMETHOD (BookMark)       (THIS_ DWORD) PURE;
   STDMETHOD (Paused)         (THIS) PURE;
   STDMETHOD (PhraseFinish)   (THIS_ DWORD, QWORD, QWORD, PSRPHRASEA, LPUNKNOWN) PURE;
   STDMETHOD (PhraseHypothesis)(THIS_ DWORD, QWORD, QWORD, PSRPHRASEA, LPUNKNOWN) PURE;
   STDMETHOD (PhraseStart)    (THIS_ QWORD) PURE;
   STDMETHOD (ReEvaluate)     (THIS_ LPUNKNOWN) PURE;
   STDMETHOD (Training)       (THIS_ DWORD) PURE;
   STDMETHOD (UnArchive)      (THIS_ LPUNKNOWN) PURE;
   };

typedef ISRGramNotifySinkA FAR * PISRGRAMNOTIFYSINKA;


#ifdef _S_UNICODE
 #define ISRGramNotifySink       ISRGramNotifySinkW
 #define IID_ISRGramNotifySink   IID_ISRGramNotifySinkW
 #define IID_ISRGramNotifySinkM  IID_ISRGramNotifySinkMW
 #define PISRGRAMNOTIFYSINK      PISRGRAMNOTIFYSINKW

#else
 #define ISRGramNotifySink       ISRGramNotifySinkA
 #define IID_ISRGramNotifySink   IID_ISRGramNotifySinkA
 #define IID_ISRGramNotifySinkM  IID_ISRGramNotifySinkMA
 #define PISRGRAMNOTIFYSINK      PISRGRAMNOTIFYSINKA

#endif   // _S_UNICODE



// ISRNotifySink
// This does not need an ANSI/UNICODE interface because no characters are passed
#undef   INTERFACE
#define  INTERFACE   ISRNotifySink

DEFINE_GUID(IID_ISRNotifySink,
0x090CD9B0L, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRNotifySink, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRNotifySink members
   STDMETHOD (AttribChanged)  (THIS_ DWORD) PURE;
   STDMETHOD (Interference)   (THIS_ QWORD, QWORD, DWORD) PURE;
   STDMETHOD (Sound)          (THIS_ QWORD, QWORD) PURE;
   STDMETHOD (UtteranceBegin) (THIS_ QWORD) PURE;
   STDMETHOD (UtteranceEnd)   (THIS_ QWORD, QWORD) PURE;
   STDMETHOD (VUMeter)        (THIS_ QWORD, WORD) PURE;
   };

typedef ISRNotifySink FAR *PISRNOTIFYSINK;

// Just in case anyone uses the wide/ansi versions
#define ISRNotifySinkW       ISRNotifySink
#define IID_ISRNotifySinkW   IID_ISRNotifySink
#define PISRNOTIFYSINKW      PISRNOTIFYSINK
#define ISRNotifySinkA       ISRNotifySink
#define IID_ISRNotifySinkA   IID_ISRNotifySink
#define PISRNOTIFYSINKA      PISRNOTIFYSINK


/*
 * ISRResBasic
 */

#undef   INTERFACE
#define  INTERFACE   ISRResBasicW

DEFINE_GUID(IID_ISRResBasicW, 0x090CD9A5, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResBasicW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRResBasicW members
   STDMETHOD (PhraseGet)      (THIS_ DWORD, PSRPHRASEW, DWORD,  DWORD *) PURE;
   STDMETHOD (Identify)       (THIS_ GUID *) PURE;
   STDMETHOD (TimeGet)        (THIS_ PQWORD, PQWORD) PURE;
   STDMETHOD (FlagsGet)       (THIS_ DWORD, DWORD *) PURE;
   };

typedef ISRResBasicW FAR *PISRRESBASICW;


#undef   INTERFACE
#define  INTERFACE   ISRResBasicA

DEFINE_GUID(IID_ISRResBasicA, 0x05EB6C66L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResBasicA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRResBasicA members
   STDMETHOD (PhraseGet)      (THIS_ DWORD, PSRPHRASEA, DWORD,  DWORD *) PURE;
   STDMETHOD (Identify)       (THIS_ GUID *) PURE;
   STDMETHOD (TimeGet)        (THIS_ PQWORD, PQWORD) PURE;
   STDMETHOD (FlagsGet)       (THIS_ DWORD, DWORD *) PURE;
   };

typedef ISRResBasicA FAR *PISRRESBASICA;


#ifdef _S_UNICODE
 #define ISRResBasic             ISRResBasicW
 #define IID_ISRResBasic         IID_ISRResBasicW
 #define PISRRESBASIC            PISRRESBASICW

#else
 #define ISRResBasic             ISRResBasicA
 #define IID_ISRResBasic         IID_ISRResBasicA
 #define PISRRESBASIC            PISRRESBASICA

#endif   // _S_UNICODE


/*
 * ISRResScore
 * This does not need an ANSI/UNICODE interface because no characters are passed
 */

#undef INTERFACE
#define INTERFACE       ISRResScores


// {0B37F1E0-B8DE-11cf-B22E-00AA00A215ED}
DEFINE_GUID(IID_ISRResScores, 0xb37f1e0, 0xb8de, 0x11cf, 0xb2, 0x2e, 0x0, 0xaa, 0x0, 0xa2, 0x15, 0xed);

DECLARE_INTERFACE_ (ISRResScores, IUnknown) {

	// IUnknown members
	STDMETHOD (QueryInterface)      (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
	STDMETHOD_(ULONG,Release)  (THIS) PURE;

	// ISRResScores members
	STDMETHOD (GetPhraseScore) (THIS_ DWORD, long FAR *) PURE;
	STDMETHOD (GetWordScores)  (THIS_ DWORD, long FAR *, DWORD, LPDWORD) PURE;
};

typedef ISRResScores FAR* PISRRESSCORES;

// In case someone uses the A/W versions...

#define ISRResScoresW           ISRResScores
#define IID_ISRResScoresW       IID_ISRResScores
#define PISRRESSCORESW          PISRRESSCORES
#define ISRResScoresA           ISRResScores
#define IID_ISRResScoresA       IID_ISRResScores
#define PISRRESSCORESA          PISRRESSCORES



/*
 * ISRResMerge
 * This does not need an ANSI/UNICODE interface because no characters are passed
 */

#undef   INTERFACE
#define  INTERFACE   ISRResMerge

DEFINE_GUID(IID_ISRResMerge, 0x090CD9A6, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResMerge, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRResMerge members
   STDMETHOD (Merge)          (THIS_ LPUNKNOWN, PIUNKNOWN ) PURE;
   STDMETHOD (Split)          (THIS_ QWORD, PIUNKNOWN , PIUNKNOWN ) PURE;
   };

typedef ISRResMerge FAR *PISRRESMERGE;



/*
 * ISRResAudio
 * This does not need an ANSI/UNICODE interface because no characters are passed
 */

#undef   INTERFACE
#define  INTERFACE   ISRResAudio

DEFINE_GUID(IID_ISRResAudio, 0x090CD9A7, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResAudio, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRResAudio members
   STDMETHOD (GetWAV)         (THIS_ PSDATA) PURE;
   };

typedef ISRResAudio FAR *PISRRESAUDIO;



/*
 * ISRResCorrection
 */

#undef   INTERFACE
#define  INTERFACE   ISRResCorrectionW

DEFINE_GUID(IID_ISRResCorrectionW, 0x090CD9A8L, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResCorrectionW, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRResCorrectionW members
   STDMETHOD (Correction)         (THIS_ PSRPHRASEW, WORD) PURE;
   STDMETHOD (Validate)           (THIS_ WORD) PURE;
   };

typedef ISRResCorrectionW FAR *PISRRESCORRECTIONW;


#undef   INTERFACE
#define  INTERFACE   ISRResCorrectionA

DEFINE_GUID(IID_ISRResCorrectionA, 0x05EB6C67L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResCorrectionA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRResCorrectionA members
   STDMETHOD (Correction)         (THIS_ PSRPHRASEA, WORD) PURE;
   STDMETHOD (Validate)           (THIS_ WORD) PURE;
   };

typedef ISRResCorrectionA FAR *PISRRESCORRECTIONA;


#ifdef _S_UNICODE
 #define ISRResCorrection        ISRResCorrectionW
 #define IID_ISRResCorrection    IID_ISRResCorrectionW
 #define PISRRESCORRECTION       PISRRESCORRECTIONW

#else
 #define ISRResCorrection        ISRResCorrectionA
 #define IID_ISRResCorrection    IID_ISRResCorrectionA
 #define PISRRESCORRECTION       PISRRESCORRECTIONA

#endif   // _S_UNICODE



// ISRResEval
// This does not need an ANSI/UNICODE interface because no characters are passed
#undef   INTERFACE
#define  INTERFACE   ISRResEval

// {90CD9A9-DA1A-11CD-B3CA-00AA0047BA4F}
DEFINE_GUID(IID_ISRResEval,
0x090CD9A9, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResEval, IUnknown) {
   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   //  SRResEval members
   STDMETHOD (ReEvaluate)     (THIS_ BOOL *) PURE;
   };

typedef ISRResEval FAR *PISRRESEVAL;



/*
 * ISRResGraph
 */

#undef   INTERFACE
#define  INTERFACE ISRResGraphW

DEFINE_GUID(IID_ISRResGraphW, 0x090CD9AA, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResGraphW, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface)     (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)       (THIS) PURE;
   STDMETHOD_(ULONG,Release)      (THIS) PURE;

   // ISRResGraphW members         
   STDMETHOD (BestPathPhoneme)    (THIS_ DWORD, DWORD *, DWORD, DWORD *) PURE;
   STDMETHOD (BestPathWord)       (THIS_ DWORD, DWORD *, DWORD, DWORD *) PURE;
   STDMETHOD (GetPhonemeNode)     (THIS_ DWORD, PSRRESPHONEMENODE, PWCHAR, 
				   PWCHAR) PURE;
   STDMETHOD (GetWordNode)        (THIS_ DWORD, PSRRESWORDNODE, PSRWORDW, DWORD, 
				   DWORD *) PURE;
   STDMETHOD (PathScorePhoneme)   (THIS_ DWORD *, DWORD, LONG *) PURE;
   STDMETHOD (PathScoreWord)      (THIS_ DWORD *, DWORD, LONG *) PURE;
   };

typedef ISRResGraphW FAR *PISRRESGRAPHW;


#undef   INTERFACE
#define  INTERFACE ISRResGraphA

DEFINE_GUID(IID_ISRResGraphA, 0x05EB6C68L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResGraphA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface)     (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)       (THIS) PURE;
   STDMETHOD_(ULONG,Release)      (THIS) PURE;

   // ISRResGraphA members         
   STDMETHOD (BestPathPhoneme)    (THIS_ DWORD, DWORD *, DWORD, DWORD *) PURE;
   STDMETHOD (BestPathWord)       (THIS_ DWORD, DWORD *, DWORD, DWORD *) PURE;
   STDMETHOD (GetPhonemeNode)     (THIS_ DWORD, PSRRESPHONEMENODE, PWCHAR, 
				   PCHAR) PURE;
   STDMETHOD (GetWordNode)        (THIS_ DWORD, PSRRESWORDNODE, PSRWORDA, DWORD, 
				   DWORD *) PURE;
   STDMETHOD (PathScorePhoneme)   (THIS_ DWORD *, DWORD, LONG *) PURE;
   STDMETHOD (PathScoreWord)      (THIS_ DWORD *, DWORD, LONG *) PURE;
   };

typedef ISRResGraphA FAR *PISRRESGRAPHA;


#ifdef _S_UNICODE
 #define ISRResGraph             ISRResGraphW
 #define IID_ISRResGraph         IID_ISRResGraphW
 #define PISRRESGRAPH            PISRRESGRAPHW

#else
 #define ISRResGraph             ISRResGraphA
 #define IID_ISRResGraph         IID_ISRResGraphA
 #define PISRRESGRAPH            PISRRESGRAPHA

#endif   // _S_UNICODE



// ISRResMemory
// This does not need an ANSI/UNICODE interface because no characters are passed
#undef   INTERFACE
#define  INTERFACE   ISRResMemory

DEFINE_GUID(IID_ISRResMemory, 0x090CD9AB, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResMemory, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRResMemory members
   STDMETHOD (Free)           (THIS_ DWORD) PURE;
   STDMETHOD (Get)            (THIS_ DWORD *, DWORD *) PURE;
   STDMETHOD (LockGet)        (THIS_ BOOL *) PURE;
   STDMETHOD (LockSet)        (THIS_ BOOL) PURE;
   };

typedef ISRResMemory FAR *PISRRESMEMORY;



// ISRResModifyGUI
// This does not need an ANSI/UNICODE interface because no characters are passed
#undef   INTERFACE
#define  INTERFACE   ISRResModifyGUI

DEFINE_GUID(IID_ISRResModifyGUI, 0x090CD9AC, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResModifyGUI, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)      (THIS) PURE;
   STDMETHOD_(ULONG,Release)     (THIS) PURE;

   // ISRResModifyGUI members
   STDMETHOD (Hide)              (THIS) PURE;
   STDMETHOD (Move)              (THIS_ RECT *) PURE;
   STDMETHOD (Show)              (THIS_ HWND) PURE;
   };

typedef ISRResModifyGUI FAR *PISRRESMODIFYGUI;



/*
 * ISRResSpeakerW
 */

#undef   INTERFACE
#define  INTERFACE   ISRResSpeakerW

DEFINE_GUID(IID_ISRResSpeakerW, 0x090CD9AD, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResSpeakerW, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)      (THIS) PURE;
   STDMETHOD_(ULONG,Release)     (THIS) PURE;

   // ISRResSpeakerW members
   STDMETHOD (Correction)        (THIS_ PCWSTR, WORD) PURE;
   STDMETHOD (Validate)          (THIS_ WORD) PURE;
   STDMETHOD (Identify)          (THIS_ DWORD, PWSTR, DWORD, DWORD *, 
				  LONG *) PURE;
   STDMETHOD (IdentifyForFree)   (THIS_ BOOL *) PURE;
   };

typedef ISRResSpeakerW FAR *PISRRESSPEAKERW;


#undef   INTERFACE
#define  INTERFACE   ISRResSpeakerA

DEFINE_GUID(IID_ISRResSpeakerA, 0x05EB6C69L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResSpeakerA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)      (THIS) PURE;
   STDMETHOD_(ULONG,Release)     (THIS) PURE;

   // ISRResSpeakerA members
   STDMETHOD (Correction)        (THIS_ PCSTR, WORD) PURE;
   STDMETHOD (Validate)          (THIS_ WORD) PURE;
   STDMETHOD (Identify)          (THIS_ DWORD, PSTR, DWORD, DWORD *, 
				  LONG *) PURE;
   STDMETHOD (IdentifyForFree)   (THIS_ BOOL *) PURE;
   };

typedef ISRResSpeakerA FAR *PISRRESSPEAKERA;


#ifdef _S_UNICODE
 #define ISRResSpeaker           ISRResSpeakerW
 #define IID_ISRResSpeaker       IID_ISRResSpeakerW
 #define PISRRESSPEAKER          PISRRESSPEAKERW

#else
 #define ISRResSpeaker           ISRResSpeakerA
 #define IID_ISRResSpeaker       IID_ISRResSpeakerA
 #define PISRRESSPEAKER          PISRRESSPEAKERA

#endif   // _S_UNICODE



/*
 * ISRSpeaker
 */

#undef   INTERFACE
#define  INTERFACE   ISRSpeakerW

DEFINE_GUID(IID_ISRSpeakerW, 0x090CD9AE, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRSpeakerW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRSpeakerW members
   STDMETHOD (Delete)         (THIS_ PCWSTR) PURE;
   STDMETHOD (Enum)           (THIS_ PWSTR *, DWORD *) PURE;
   STDMETHOD (Merge)          (THIS_ PCWSTR, PVOID, DWORD) PURE;
   STDMETHOD (New)            (THIS_ PCWSTR) PURE;
   STDMETHOD (Query)          (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (Read)           (THIS_ PCWSTR, PVOID *, DWORD *) PURE;
   STDMETHOD (Revert)         (THIS_ PCWSTR) PURE;
   STDMETHOD (Select)         (THIS_ PCWSTR, BOOL) PURE;
   STDMETHOD (Write)          (THIS_ PCWSTR, PVOID, DWORD) PURE;
   };

typedef ISRSpeakerW FAR *PISRSPEAKERW;


#undef   INTERFACE
#define  INTERFACE   ISRSpeakerA

DEFINE_GUID(IID_ISRSpeakerA, 0x090CD9AF, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRSpeakerA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRSpeakerA members
   STDMETHOD (Delete)         (THIS_ PCSTR) PURE;
   STDMETHOD (Enum)           (THIS_ PSTR *, DWORD *) PURE;
   STDMETHOD (Merge)          (THIS_ PCSTR, PVOID, DWORD) PURE;
   STDMETHOD (New)            (THIS_ PCSTR) PURE;
   STDMETHOD (Query)          (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD (Read)           (THIS_ PCSTR, PVOID *, DWORD *) PURE;
   STDMETHOD (Revert)         (THIS_ PCSTR) PURE;
   STDMETHOD (Select)         (THIS_ PCSTR, BOOL) PURE;
   STDMETHOD (Write)          (THIS_ PCSTR, PVOID, DWORD) PURE;
   };

typedef ISRSpeakerA FAR *PISRSPEAKERA;


#ifdef _S_UNICODE
 #define ISRSpeaker              ISRSpeakerW
 #define IID_ISRSpeaker          IID_ISRSpeakerW
 #define PISRSPEAKER             PISRSPEAKERW

#else
 #define ISRSpeaker              ISRSpeakerA
 #define IID_ISRSpeaker          IID_ISRSpeakerA
 #define PISRSPEAKER             PISRSPEAKERA

#endif   // _S_UNICODE



/************************************************************************
Low-Level text-to-speech API
*/


/************************************************************************
defines */

#define  TTSI_NAMELEN                   SVFN_LEN
#define  TTSI_STYLELEN                  SVFN_LEN

#define  GENDER_NEUTRAL                 (0)
#define  GENDER_FEMALE                  (1)
#define  GENDER_MALE                    (2)

#define  TTSFEATURE_ANYWORD             SETBIT(0)
#define  TTSFEATURE_VOLUME              SETBIT(1)
#define  TTSFEATURE_SPEED               SETBIT(2)
#define  TTSFEATURE_PITCH               SETBIT(3)
#define  TTSFEATURE_TAGGED              SETBIT(4)
#define  TTSFEATURE_IPAUNICODE          SETBIT(5)
#define  TTSFEATURE_VISUAL              SETBIT(6)
#define  TTSFEATURE_WORDPOSITION        SETBIT(7)
#define  TTSFEATURE_PCOPTIMIZED         SETBIT(8)
#define  TTSFEATURE_PHONEOPTIMIZED      SETBIT(9)

#define  TTSI_ILEXPRONOUNCE             SETBIT(0)
#define  TTSI_ITTSATTRIBUTES            SETBIT(1)
#define  TTSI_ITTSCENTRAL               SETBIT(2)
#define  TTSI_ITTSDIALOGS               SETBIT(3)

#define  TTSDATAFLAG_TAGGED             SETBIT(0)

#define   TTSBNS_ABORTED                   SETBIT(0)

// ITTSNotifySink
#define   TTSNSAC_REALTIME               0
#define   TTSNSAC_PITCH                  1
#define   TTSNSAC_SPEED                  2
#define   TTSNSAC_VOLUME                 3


#define   TTSNSHINT_QUESTION             SETBIT(0)
#define   TTSNSHINT_STATEMENT            SETBIT(1)
#define   TTSNSHINT_COMMAND              SETBIT(2)
#define   TTSNSHINT_EXCLAMATION          SETBIT(3)
#define   TTSNSHINT_EMPHASIS             SETBIT(4)


// Ages
#define  TTSAGE_BABY                   1
#define  TTSAGE_TODDLER                3
#define  TTSAGE_CHILD                  6
#define  TTSAGE_ADOLESCENT             14
#define  TTSAGE_ADULT                  30
#define  TTSAGE_ELDERLY                70

// Attribute minimums and maximums
#define  TTSATTR_MINPITCH              0
#define  TTSATTR_MAXPITCH              0xffff
#define  TTSATTR_MINREALTIME           0
#define  TTSATTR_MAXREALTIME           0xffffffff
#define  TTSATTR_MINSPEED              0
#define  TTSATTR_MAXSPEED              0xffffffff
#define  TTSATTR_MINVOLUME             0
#define  TTSATTR_MAXVOLUME             0xffffffff


/************************************************************************
typedefs */

typedef struct {
   BYTE     bMouthHeigght;
   BYTE     bMouthWidth;
   BYTE     bMouthUpturn;
   BYTE     bJawOpen;
   BYTE     bTeethUpperVisible;
   BYTE     bTeethLowerVisible;
   BYTE     bTonguePosn;
   BYTE     bLipTension;
   } TTSMOUTH, *PTTSMOUTH;



typedef struct {
   GUID       gEngineID;
   WCHAR      szMfgName[TTSI_NAMELEN];
   WCHAR      szProductName[TTSI_NAMELEN];
   GUID       gModeID;
   WCHAR      szModeName[TTSI_NAMELEN];
   LANGUAGEW  language;
   WCHAR      szSpeaker[TTSI_NAMELEN];
   WCHAR      szStyle[TTSI_STYLELEN];
   WORD       wGender;
   WORD       wAge;
   DWORD      dwFeatures;
   DWORD      dwInterfaces;
   DWORD      dwEngineFeatures;
   } TTSMODEINFOW, *PTTSMODEINFOW;

typedef struct {
   GUID       gEngineID;
   CHAR       szMfgName[TTSI_NAMELEN];
   CHAR       szProductName[TTSI_NAMELEN];
   GUID       gModeID;
   CHAR       szModeName[TTSI_NAMELEN];
   LANGUAGEA  language;
   CHAR       szSpeaker[TTSI_NAMELEN];
   CHAR       szStyle[TTSI_STYLELEN];
   WORD       wGender;
   WORD       wAge;
   DWORD      dwFeatures;
   DWORD      dwInterfaces;
   DWORD      dwEngineFeatures;
   } TTSMODEINFOA, *PTTSMODEINFOA;

#ifdef _S_UNICODE
 #define TTSMODEINFO         TTSMODEINFOW
 #define PTTSMODEINFO        PTTSMODEINFOW

#else
 #define TTSMODEINFO         TTSMODEINFOA
 #define PTTSMODEINFO        PTTSMODEINFOA

#endif   // _S_UNICODE



typedef struct {
   DWORD      dwEngineID;
   DWORD      dwMfgName;
   DWORD      dwProductName;
   DWORD      dwModeID;
   DWORD      dwModeName;
   DWORD      dwLanguage;
   DWORD      dwDialect;
   DWORD      dwSpeaker;
   DWORD      dwStyle;
   DWORD      dwGender;
   DWORD      dwAge;
   DWORD      dwFeatures;
   DWORD      dwInterfaces;
   DWORD      dwEngineFeatures;
   } TTSMODEINFORANK, * PTTSMODEINFORANK;

/************************************************************************
Class IDs */
// {D67C0280-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(CLSID_TTSEnumerator, 
0xd67c0280, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

/************************************************************************
interfaces */

// ITTSAttributes

#undef   INTERFACE
#define  INTERFACE   ITTSAttributesW

DEFINE_GUID(IID_ITTSAttributesW, 0x1287A280L, 0x4A47, 0x101B, 0x93, 0x1A, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSAttributesW, IUnknown) {

// IUnknown members

   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

// ITTSAttributes members

   STDMETHOD (PitchGet)       (THIS_ WORD *) PURE;
   STDMETHOD (PitchSet)       (THIS_ WORD) PURE;  
   STDMETHOD (RealTimeGet)    (THIS_ DWORD *) PURE;
   STDMETHOD (RealTimeSet)    (THIS_ DWORD) PURE;  
   STDMETHOD (SpeedGet)       (THIS_ DWORD *) PURE;
   STDMETHOD (SpeedSet)       (THIS_ DWORD) PURE;  
   STDMETHOD (VolumeGet)      (THIS_ DWORD *) PURE;
   STDMETHOD (VolumeSet)      (THIS_ DWORD) PURE;  
   };

typedef ITTSAttributesW FAR * PITTSATTRIBUTESW;


#undef   INTERFACE
#define  INTERFACE   ITTSAttributesA

DEFINE_GUID(IID_ITTSAttributesA,
0x0FD6E2A1L, 0xE77D, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSAttributesA, IUnknown) {

// IUnknown members

   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

// ITTSAttributes members

   STDMETHOD (PitchGet)       (THIS_ WORD *) PURE;
   STDMETHOD (PitchSet)       (THIS_ WORD) PURE;  
   STDMETHOD (RealTimeGet)    (THIS_ DWORD *) PURE;
   STDMETHOD (RealTimeSet)    (THIS_ DWORD) PURE;  
   STDMETHOD (SpeedGet)       (THIS_ DWORD *) PURE;
   STDMETHOD (SpeedSet)       (THIS_ DWORD) PURE;  
   STDMETHOD (VolumeGet)      (THIS_ DWORD *) PURE;
   STDMETHOD (VolumeSet)      (THIS_ DWORD) PURE;  
   };

typedef ITTSAttributesA FAR * PITTSATTRIBUTESA;


#ifdef _S_UNICODE
 #define ITTSAttributes          ITTSAttributesW
 #define IID_ITTSAttributes      IID_ITTSAttributesW
 #define PITTSATTRIBUTES         PITTSATTRIBUTESW

#else
 #define ITTSAttributes          ITTSAttributesA
 #define IID_ITTSAttributes      IID_ITTSAttributesA
 #define PITTSATTRIBUTES         PITTSATTRIBUTESA

#endif   // _S_UNICODE



// ITTSBufNotifySink

#undef   INTERFACE
#define  INTERFACE   ITTSBufNotifySink

// {E4963D40-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(IID_ITTSBufNotifySink, 
0xe4963d40, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (ITTSBufNotifySink, IUnknown) {

// IUnknown members

   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

// ITTSBufNotifySink members

   STDMETHOD (TextDataDone)   (THIS_ QWORD, DWORD) PURE;
   STDMETHOD (TextDataStarted)(THIS_ QWORD) PURE;
   STDMETHOD (BookMark)       (THIS_ QWORD, DWORD) PURE;  
   STDMETHOD (WordPosition)   (THIS_ QWORD, DWORD) PURE;
   };

typedef ITTSBufNotifySink FAR * PITTSBUFNOTIFYSINK;

// In case anyone uses the W or A interface
#define ITTSBufNotifySinkW          ITTSBufNotifySink
#define IID_ITTSBufNotifySinkW      IID_ITTSBufNotifySink
#define PITTSBUFNOTIFYSINKW         PITTSBUFNOTIFYSINK
#define ITTSBufNotifySinkA          ITTSBufNotifySink
#define IID_ITTSBufNotifySinkA      IID_ITTSBufNotifySink
#define PITTSBUFNOTIFYSINKA         PITTSBUFNOTIFYSINK



/*
 * ITTSCentral
 */

#undef   INTERFACE
#define  INTERFACE   ITTSCentralW

DEFINE_GUID(IID_ITTSCentralW, 0x28016060L, 0x4A47, 0x101B, 0x93, 0x1A, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSCentralW, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSCentralW members
   STDMETHOD (Inject)         (THIS_ PCWSTR) PURE;
   STDMETHOD (ModeGet)        (THIS_ PTTSMODEINFOW) PURE;
   STDMETHOD (Phoneme)        (THIS_ VOICECHARSET, DWORD, SDATA, PSDATA) PURE;
   STDMETHOD (PosnGet)        (THIS_ PQWORD) PURE;
   STDMETHOD (TextData)       (THIS_ VOICECHARSET, DWORD, SDATA, PVOID, IID) PURE;
   STDMETHOD (ToFileTime)     (THIS_ PQWORD, FILETIME *) PURE;
   STDMETHOD (AudioPause)     (THIS) PURE;
   STDMETHOD (AudioResume)    (THIS) PURE;
   STDMETHOD (AudioReset)     (THIS) PURE;
   STDMETHOD (Register)       (THIS_ PVOID, IID, DWORD*) PURE;
   STDMETHOD (UnRegister)     (THIS_ DWORD) PURE;
   };

typedef ITTSCentralW FAR * PITTSCENTRALW;


#undef   INTERFACE
#define  INTERFACE   ITTSCentralA

DEFINE_GUID(IID_ITTSCentralA, 0x05EB6C6AL, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSCentralA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSCentralA members
   STDMETHOD (Inject)         (THIS_ PCSTR) PURE;
   STDMETHOD (ModeGet)        (THIS_ PTTSMODEINFOA) PURE;
   STDMETHOD (Phoneme)        (THIS_ VOICECHARSET, DWORD, SDATA, PSDATA) PURE;
   STDMETHOD (PosnGet)        (THIS_ PQWORD) PURE;
   STDMETHOD (TextData)       (THIS_ VOICECHARSET, DWORD, SDATA, PVOID, IID) PURE;
   STDMETHOD (ToFileTime)     (THIS_ PQWORD, FILETIME *) PURE;
   STDMETHOD (AudioPause)     (THIS) PURE;
   STDMETHOD (AudioResume)    (THIS) PURE;
   STDMETHOD (AudioReset)     (THIS) PURE;
   STDMETHOD (Register)       (THIS_ PVOID, IID, DWORD*) PURE;
   STDMETHOD (UnRegister)     (THIS_ DWORD) PURE;
   };

typedef ITTSCentralA FAR * PITTSCENTRALA;


#ifdef _S_UNICODE
 #define ITTSCentral             ITTSCentralW
 #define IID_ITTSCentral         IID_ITTSCentralW
 #define PITTSCENTRAL            PITTSCENTRALW

#else
 #define ITTSCentral             ITTSCentralA
 #define IID_ITTSCentral         IID_ITTSCentralA
 #define PITTSCENTRAL            PITTSCENTRALA

#endif   // _S_UNICODE



/*
 * ITTSDialogsW
 */

#undef   INTERFACE
#define  INTERFACE   ITTSDialogsW

DEFINE_GUID(IID_ITTSDialogsW, 0x47F59D00L, 0x4A47, 0x101B, 0x93, 0x1A, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSDialogsW, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSDialogsW members
   STDMETHOD (AboutDlg)       (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (LexiconDlg)     (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (GeneralDlg)     (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TranslateDlg)   (THIS_ HWND, PCWSTR) PURE;
   };

typedef ITTSDialogsW FAR * PITTSDIALOGSW;


#undef   INTERFACE
#define  INTERFACE   ITTSDialogsA

DEFINE_GUID(IID_ITTSDialogsA, 0x05EB6C6BL, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSDialogsA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSDialogsA members
   STDMETHOD (AboutDlg)       (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (LexiconDlg)     (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (GeneralDlg)     (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TranslateDlg)   (THIS_ HWND, PCSTR) PURE;
   };

typedef ITTSDialogsA FAR * PITTSDIALOGSA;


#ifdef _S_UNICODE
 #define ITTSDialogs          ITTSDialogsW
 #define IID_ITTSDialogs      IID_ITTSDialogsW
 #define PITTSDIALOGS         PITTSDIALOGSW

#else
 #define ITTSDialogs          ITTSDialogsA
 #define IID_ITTSDialogs      IID_ITTSDialogsA
 #define PITTSDIALOGS         PITTSDIALOGSA

#endif



/*
 * ITTSEnum
 */

#undef   INTERFACE
#define  INTERFACE   ITTSEnumW

DEFINE_GUID(IID_ITTSEnumW, 0x6B837B20L, 0x4A47, 0x101B, 0x93, 0x1A, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSEnumW, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSEnumW members
   STDMETHOD (Next)           (THIS_ ULONG, PTTSMODEINFOW, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ ITTSEnumW * FAR *) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PITTSCENTRALW *, LPUNKNOWN) PURE;
   };

typedef ITTSEnumW FAR * PITTSENUMW;


#undef   INTERFACE
#define  INTERFACE   ITTSEnumA

DEFINE_GUID(IID_ITTSEnumA, 0x05EB6C6DL, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSEnumA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSEnumA members
   STDMETHOD (Next)           (THIS_ ULONG, PTTSMODEINFOA, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ ITTSEnumA * FAR *) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PITTSCENTRALA *, LPUNKNOWN) PURE;
   };

typedef ITTSEnumA FAR * PITTSENUMA;


#ifdef _S_UNICODE
 #define ITTSEnum             ITTSEnumW
 #define IID_ITTSEnum         IID_ITTSEnumW
 #define PITTSENUM            PITTSENUMW

#else
 #define ITTSEnum             ITTSEnumA
 #define IID_ITTSEnum         IID_ITTSEnumA
 #define PITTSENUM            PITTSENUMA

#endif



/*
 * ITTSFind
 */

#undef   INTERFACE
#define  INTERFACE   ITTSFindW

DEFINE_GUID(IID_ITTSFindW, 0x7AA42960L, 0x4A47, 0x101B, 0x93, 0x1A, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSFindW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSFindW members
   STDMETHOD (Find)           (THIS_ PTTSMODEINFOW, PTTSMODEINFORANK, PTTSMODEINFOW) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PITTSCENTRALW *, LPUNKNOWN) PURE;
   };

typedef ITTSFindW FAR * PITTSFINDW;


#undef   INTERFACE
#define  INTERFACE   ITTSFindA

DEFINE_GUID(IID_ITTSFindA, 0x05EB6C6EL, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSFindA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSFindA members
   STDMETHOD (Find)           (THIS_ PTTSMODEINFOA, PTTSMODEINFORANK, PTTSMODEINFOA) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PITTSCENTRALA *, LPUNKNOWN) PURE;
   };

typedef ITTSFindA FAR * PITTSFINDA;


#ifdef _S_UNICODE
 #define ITTSFind             ITTSFindW
 #define IID_ITTSFind         IID_ITTSFindW
 #define PITTSFIND            PITTSFINDW

#else
 #define ITTSFind             ITTSFindA
 #define IID_ITTSFind         IID_ITTSFindA
 #define PITTSFIND            PITTSFINDA

#endif



/*
 * ITTSNotifySink
 */

#undef   INTERFACE
#define  INTERFACE   ITTSNotifySinkW

DEFINE_GUID(IID_ITTSNotifySinkW, 0xC0FA8F40L, 0x4A46, 0x101B, 0x93, 0x1A, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSNotifySinkW, IUnknown) {

// IUnknown members

   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

// ITTSNotifySinkW members

   STDMETHOD (AttribChanged)  (THIS_ DWORD) PURE;
   STDMETHOD (AudioStart)     (THIS_ QWORD) PURE;
   STDMETHOD (AudioStop)      (THIS_ QWORD) PURE;
   STDMETHOD (Visual)         (THIS_ QWORD, WCHAR, WCHAR, DWORD, PTTSMOUTH) PURE;
   };

typedef ITTSNotifySinkW FAR * PITTSNOTIFYSINKW;


#undef   INTERFACE
#define  INTERFACE   ITTSNotifySinkA

DEFINE_GUID(IID_ITTSNotifySinkA, 0x05EB6C6FL, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSNotifySinkA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSNotifySinkA members
   STDMETHOD (AttribChanged)  (THIS_ DWORD) PURE;
   STDMETHOD (AudioStart)     (THIS_ QWORD) PURE;
   STDMETHOD (AudioStop)      (THIS_ QWORD) PURE;
   STDMETHOD (Visual)         (THIS_ QWORD, CHAR, CHAR, DWORD, PTTSMOUTH) PURE;
   };

typedef ITTSNotifySinkA FAR * PITTSNOTIFYSINKA;


#ifdef _S_UNICODE
 #define ITTSNotifySink       ITTSNotifySinkW
 #define IID_ITTSNotifySink   IID_ITTSNotifySinkW
 #define PITTSNOTIFYSINK      PITTSNOTIFYSINKW

#else
 #define ITTSNotifySink       ITTSNotifySinkA
 #define IID_ITTSNotifySink   IID_ITTSNotifySinkA
 #define PITTSNOTIFYSINK      PITTSNOTIFYSINKA

#endif



/************************************************************************
High-Level command and control speech recognition API
*/

/************************************************************************
defines */


// VCMDNAME member lengths
#define VCMD_APPLEN             ((DWORD)32)
#define VCMD_STATELEN           VCMD_APPLEN
#define VCMD_MICLEN             VCMD_APPLEN
#define VCMD_SPEAKERLEN         VCMD_APPLEN

// dwFlags parameter of IVoiceCmd::MenuCreate
#define  VCMDMC_CREATE_TEMP     0x00000001
#define  VCMDMC_CREATE_NEW      0x00000002
#define  VCMDMC_CREATE_ALWAYS   0x00000004
#define  VCMDMC_OPEN_ALWAYS     0x00000008
#define  VCMDMC_OPEN_EXISTING   0x00000010

// dwFlags parameter of IVoiceCmd::Register
#define  VCMDRF_NOMESSAGES      0
#define  VCMDRF_ALLBUTVUMETER   0x00000001
#define  VCMDRF_VUMETER         0x00000002
#define  VCMDRF_ALLMESSAGES     (VCMDRF_ALLBUTVUMETER | VCMDRF_VUMETER)

// dwFlags parameter of IVoiceCmd::MenuEnum
#define  VCMDEF_DATABASE        0x00000000
#define  VCMDEF_ACTIVE          0x00000001
#define  VCMDEF_SELECTED        0x00000002
#define  VCMDEF_PERMANENT       0x00000004
#define  VCMDEF_TEMPORARY       0x00000008

// dwFlags parameter of IVCmdMenu::Activate
#define  VWGFLAG_ASLEEP         0x00000001

// wPriority parameter of IVCmdMenu::Activate
#define  VCMDACT_NORMAL         (0x8000)
#define  VCMDACT_LOW            (0x4000)
#define  VCMDACT_HIGH           (0xC000)

// dwFlags of the VCMDCOMMAND structure
#define  VCMDCMD_VERIFY         0x00000001
#define  VCMDCMD_DISABLED_TEMP  0x00000002
#define  VCMDCMD_DISABLED_PERM  0x00000004

// parameter to any function that processes individual commands
#define  VCMD_BY_POSITION       0x00000001
#define  VCMD_BY_IDENTIFIER     0x00000002


// values for dwAttributes field of IVCmdNotifySink::AttribChanged
#define  IVCNSAC_AUTOGAINENABLE 0x00000001
#define  IVCNSAC_ENABLED        0x00000002
#define  IVCNSAC_AWAKE          0x00000004
#define  IVCNSAC_DEVICE         0x00000008
#define  IVCNSAC_MICROPHONE     0x00000010
#define  IVCNSAC_SPEAKER        0x00000020
#define  IVCNSAC_SRMODE         0x00000040
#define  IVCNSAC_THRESHOLD      0x00000080
#define  IVCNSAC_ORIGINAPP      0x00010000

// values for dwAttributes field of IVTxtNotifySink::AttribChanged
#define  IVTNSAC_DEVICE         0x00000001
#define  IVTNSAC_ENABLED        0x00000002
#define  IVTNSAC_SPEED          0x00000004
#define  IVTNSAC_VOLUME         0x00000008
#define  IVTNSAC_TTSMODE        0x00000010


// values used by IVXxxAttributes::SetMode to set the global speech
// recognition mode
#define  VSRMODE_DISABLED       0x00000001
#define  VSRMODE_OFF            0x00000002
#define  VSRMODE_CMDPAUSED      0x00000004
#define  VSRMODE_CMDNOTPAUSED   0x00000008
#define  VSRMODE_CMDONLY        0x00000010
#define  VSRMODE_DCTONLY        0x00000020
#define  VSRMODE_CMDANDDCT      0x00000040


/************************************************************************
typedefs */

// voice command structure - passed to command menu functions (IVCmdMenu)
typedef struct {
    DWORD   dwSize;         // size of struct including amount of abAction
    DWORD   dwFlags;
    DWORD   dwID;           // Command ID
    DWORD   dwCommand;      // DWORD aligned offset of command string
    DWORD   dwDescription;  // DWORD aligned offset of description string
    DWORD   dwCategory;     // DWORD aligned offset of category string
    DWORD   dwCommandText;  // DWORD aligned offset of command text string
    DWORD   dwAction;       // DWORD aligned offset of action data
    DWORD   dwActionSize;   // size of the action data (could be string or binary)
    BYTE    abData[1];      // command, description, category, and action data
			    // (action data is NOT interpreted by voice command)
} VCMDCOMMAND, * PVCMDCOMMAND;



// site information structure - possible parameter to IVoiceCmd::Register
typedef struct {
    DWORD   dwAutoGainEnable;
    DWORD   dwAwakeState;
    DWORD   dwThreshold;
    DWORD   dwDevice;
    DWORD   dwEnable;
    WCHAR   szMicrophone[VCMD_MICLEN];
    WCHAR   szSpeaker[VCMD_SPEAKERLEN];
    GUID    gModeID;
} VCSITEINFOW, *PVCSITEINFOW;

typedef struct {
    DWORD   dwAutoGainEnable;
    DWORD   dwAwakeState;
    DWORD   dwThreshold;
    DWORD   dwDevice;
    DWORD   dwEnable;
    CHAR    szMicrophone[VCMD_MICLEN];
    CHAR    szSpeaker[VCMD_SPEAKERLEN];
    GUID    gModeID;
} VCSITEINFOA, *PVCSITEINFOA;



// menu name structure
typedef struct {
    WCHAR   szApplication[VCMD_APPLEN]; // unique application name
    WCHAR   szState[VCMD_STATELEN];     // unique application state
} VCMDNAMEW, *PVCMDNAMEW;

typedef struct {
    CHAR    szApplication[VCMD_APPLEN]; // unique application name
    CHAR    szState[VCMD_STATELEN];     // unique application state
} VCMDNAMEA, *PVCMDNAMEA;



#ifdef  _S_UNICODE
 #define VCSITEINFO  VCSITEINFOW
 #define PVCSITEINFO PVCSITEINFOW
 #define VCMDNAME    VCMDNAMEW
 #define PVCMDNAME   PVCMDNAMEW
#else
 #define VCSITEINFO  VCSITEINFOA
 #define PVCSITEINFO PVCSITEINFOA
 #define VCMDNAME    VCMDNAMEA
 #define PVCMDNAME   PVCMDNAMEA
#endif  // _S_UNICODE

/************************************************************************
interfaces */

/*
 *  IVCmdNotifySink
 */
#undef   INTERFACE
#define  INTERFACE   IVCmdNotifySinkW

DEFINE_GUID(IID_IVCmdNotifySinkW, 0xCCFD7A60L, 0x604D, 0x101B, 0x99, 0x26, 0x00, 0xAA, 0x00, 0x3C, 0xFC, 0x2C);

DECLARE_INTERFACE_ (IVCmdNotifySinkW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdNotifySink members

   STDMETHOD (CommandRecognize) (THIS_ DWORD, PVCMDNAMEW, DWORD, DWORD, PVOID, 
				 DWORD, PWSTR, PWSTR) PURE;
   STDMETHOD (CommandOther)     (THIS_ PVCMDNAMEW, PWSTR) PURE;
   STDMETHOD (CommandStart)     (THIS) PURE;
   STDMETHOD (MenuActivate)     (THIS_ PVCMDNAMEW, BOOL) PURE;
   STDMETHOD (UtteranceBegin)   (THIS) PURE;
   STDMETHOD (UtteranceEnd)     (THIS) PURE;
   STDMETHOD (VUMeter)          (THIS_ WORD) PURE;
   STDMETHOD (AttribChanged)    (THIS_ DWORD) PURE;
   STDMETHOD (Interference)     (THIS_ DWORD) PURE;
};

typedef IVCmdNotifySinkW FAR * PIVCMDNOTIFYSINKW;


#undef   INTERFACE
#define  INTERFACE   IVCmdNotifySinkA

// {80B25CC0-5540-11b9-C000-5611722E1D15}
DEFINE_GUID(IID_IVCmdNotifySinkA, 0x80b25cc0, 0x5540, 0x11b9, 0xc0, 0x0, 0x56, 0x11, 0x72, 0x2e, 0x1d, 0x15);

DECLARE_INTERFACE_ (IVCmdNotifySinkA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdNotifySinkA members

   STDMETHOD (CommandRecognize) (THIS_ DWORD, PVCMDNAMEA, DWORD, DWORD, PVOID, 
				 DWORD, PSTR, PSTR) PURE;
   STDMETHOD (CommandOther)     (THIS_ PVCMDNAMEA, PSTR) PURE;
   STDMETHOD (CommandStart)     (THIS) PURE;
   STDMETHOD (MenuActivate)     (THIS_ PVCMDNAMEA, BOOL) PURE;
   STDMETHOD (UtteranceBegin)   (THIS) PURE;
   STDMETHOD (UtteranceEnd)     (THIS) PURE;
   STDMETHOD (VUMeter)          (THIS_ WORD) PURE;
   STDMETHOD (AttribChanged)    (THIS_ DWORD) PURE;
   STDMETHOD (Interference)     (THIS_ DWORD) PURE;
};

typedef IVCmdNotifySinkA FAR * PIVCMDNOTIFYSINKA;


#ifdef _S_UNICODE
 #define IVCmdNotifySink        IVCmdNotifySinkW
 #define IID_IVCmdNotifySink    IID_IVCmdNotifySinkW
 #define PIVCMDNOTIFYSINK       PIVCMDNOTIFYSINKW

#else
 #define IVCmdNotifySink        IVCmdNotifySinkA
 #define IID_IVCmdNotifySink    IID_IVCmdNotifySinkA
 #define PIVCMDNOTIFYSINK       PIVCMDNOTIFYSINKA

#endif // _S_UNICODE


/*
 *  IVCmdNotifySinkEx
 */
#undef   INTERFACE
#define  INTERFACE   IVCmdNotifySinkExW

// {2F440FB4-CE01-11cf-B234-00AA00A215ED}
DEFINE_GUID(IID_IVCmdNotifySinkExW, 
0x2f440fb4, 0xce01, 0x11cf, 0xb2, 0x34, 0x0, 0xaa, 0x0, 0xa2, 0x15, 0xed);

DECLARE_INTERFACE_ (IVCmdNotifySinkExW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdNotifySinkExW members

   STDMETHOD (CommandRecognizeEx)
				(THIS_ DWORD, PVCMDNAMEW, DWORD, DWORD, PVOID, 
				 DWORD, PWSTR, PWSTR, LPUNKNOWN) PURE;
   STDMETHOD (CommandOther)     (THIS_ PVCMDNAMEW, PWSTR) PURE;
   STDMETHOD (CommandStart)     (THIS) PURE;
   STDMETHOD (MenuActivate)     (THIS_ PVCMDNAMEW, BOOL) PURE;
   STDMETHOD (UtteranceBegin)   (THIS) PURE;
   STDMETHOD (UtteranceEnd)     (THIS) PURE;
   STDMETHOD (VUMeter)          (THIS_ WORD) PURE;
   STDMETHOD (AttribChanged)    (THIS_ DWORD) PURE;
   STDMETHOD (Interference)     (THIS_ DWORD) PURE;
};

typedef IVCmdNotifySinkExW FAR * PIVCMDNOTIFYSINKEXW;


#undef   INTERFACE
#define  INTERFACE   IVCmdNotifySinkExA

// {2F440FB8-CE01-11cf-B234-00AA00A215ED}
DEFINE_GUID(IID_IVCmdNotifySinkExA, 
0x2f440fb8, 0xce01, 0x11cf, 0xb2, 0x34, 0x0, 0xaa, 0x0, 0xa2, 0x15, 0xed);

DECLARE_INTERFACE_ (IVCmdNotifySinkExA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdNotifySinkExA members

   STDMETHOD (CommandRecognizeEx)
				(THIS_ DWORD, PVCMDNAMEA, DWORD, DWORD, PVOID, 
				 DWORD, PSTR, PSTR, LPUNKNOWN) PURE;
   STDMETHOD (CommandOther)     (THIS_ PVCMDNAMEA, PSTR) PURE;
   STDMETHOD (CommandStart)     (THIS) PURE;
   STDMETHOD (MenuActivate)     (THIS_ PVCMDNAMEA, BOOL) PURE;
   STDMETHOD (UtteranceBegin)   (THIS) PURE;
   STDMETHOD (UtteranceEnd)     (THIS) PURE;
   STDMETHOD (VUMeter)          (THIS_ WORD) PURE;
   STDMETHOD (AttribChanged)    (THIS_ DWORD) PURE;
   STDMETHOD (Interference)     (THIS_ DWORD) PURE;
};

typedef IVCmdNotifySinkExA FAR * PIVCMDNOTIFYSINKEXA;


#ifdef _S_UNICODE
 #define IVCmdNotifySinkEx        IVCmdNotifySinkExW
 #define IID_IVCmdNotifySinkEx    IID_IVCmdNotifySinkExW
 #define PIVCMDNOTIFYSINKEX       PIVCMDNOTIFYSINKEXW

#else
 #define IVCmdNotifySinkEx        IVCmdNotifySinkExA
 #define IID_IVCmdNotifySinkEx    IID_IVCmdNotifySinkExA
 #define PIVCMDNOTIFYSINKEX       PIVCMDNOTIFYSINKEXA

#endif // _S_UNICODE


/*
 *  IVCmdEnum
 */
#undef   INTERFACE
#define  INTERFACE   IVCmdEnumW

DEFINE_GUID(IID_IVCmdEnumW, 0xD3CC0820L, 0x604D, 0x101B, 0x99, 0x26, 0x00, 0xAA, 0x00, 0x3C, 0xFC, 0x2C);

DECLARE_INTERFACE_ (IVCmdEnumW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdEnum members
   STDMETHOD (Next)           (THIS_ ULONG, PVCMDNAMEW, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ IVCmdEnumW * FAR *) PURE;
};
typedef IVCmdEnumW FAR * PIVCMDENUMW;


#undef   INTERFACE
#define  INTERFACE   IVCmdEnumA

// {E86F9540-DCA2-11CD-A166-00AA004CD65C}
DEFINE_GUID(IID_IVCmdEnumA, 
0xE86F9540, 0xDCA2, 0x11CD, 0xA1, 0x66, 0x0, 0xAA, 0x0, 0x4C, 0xD6, 0x5C);

DECLARE_INTERFACE_ (IVCmdEnumA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdEnum members
   STDMETHOD (Next)           (THIS_ ULONG, PVCMDNAMEA, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ IVCmdEnumA * FAR *) PURE;
};
typedef IVCmdEnumA FAR * PIVCMDENUMA;


#ifdef _S_UNICODE
 #define IVCmdEnum              IVCmdEnumW
 #define IID_IVCmdEnum          IID_IVCmdEnumW
 #define PIVCMDENUM             PIVCMDENUMW

#else
 #define IVCmdEnum              IVCmdEnumA
 #define IID_IVCmdEnum          IID_IVCmdEnumA
 #define PIVCMDENUM             PIVCMDENUMA

#endif // _S_UNICODE


 
 
/*
 *  IEnumSRShare
 */
#undef   INTERFACE
#define  INTERFACE   IEnumSRShareW

// {E97F05C0-81B3-11ce-B763-00AA004CD65C}
DEFINE_GUID(IID_IEnumSRShareW,
0xe97f05c0, 0x81b3, 0x11ce, 0xb7, 0x63, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IEnumSRShareW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IEnumSRShare members
   STDMETHOD (Next)           (THIS_ ULONG, PSRSHAREW, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ IEnumSRShareW * FAR *) PURE;
   STDMETHOD (New)            (THIS_ DWORD, GUID, PISRCENTRALW *, QWORD *) PURE;
   STDMETHOD (Share)          (THIS_ QWORD, PISRCENTRALW *) PURE;
   STDMETHOD (Detach)         (THIS_ QWORD) PURE;
};
typedef IEnumSRShareW FAR * PIENUMSRSHAREW;


#undef   INTERFACE
#define  INTERFACE   IEnumSRShareA

// {E97F05C1-81B3-11ce-B763-00AA004CD65C}
DEFINE_GUID(IID_IEnumSRShareA,
0xe97f05c1, 0x81b3, 0x11ce, 0xb7, 0x63, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IEnumSRShareA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IEnumSRShare members
   STDMETHOD (Next)           (THIS_ ULONG, PSRSHAREA, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ IEnumSRShareA * FAR *) PURE;
   STDMETHOD (New)            (THIS_ DWORD, GUID, PISRCENTRALA *, QWORD *) PURE;
   STDMETHOD (Share)          (THIS_ QWORD, PISRCENTRALA *) PURE;
   STDMETHOD (Detach)         (THIS_ QWORD) PURE;
};
typedef IEnumSRShareA FAR * PIENUMSRSHAREA;


#ifdef _S_UNICODE
 #define IEnumSRShare              IEnumSRShareW
 #define IID_IEnumSRShare          IID_IEnumSRShareW
 #define PIENUMSRSHARE             PIENUMSRSHAREW

#else
 #define IEnumSRShare              IEnumSRShareA
 #define IID_IEnumSRShare          IID_IEnumSRShareA
 #define PIENUMSRSHARE             PIENUMSRSHAREA

#endif // _S_UNICODE


 
 
/*
 *  IVCmdMenu
 */
#undef   INTERFACE
#define  INTERFACE   IVCmdMenuW

DEFINE_GUID(IID_IVCmdMenuW, 0xDAC54F60L, 0x604D, 0x101B, 0x99, 0x26, 0x00, 0xAA, 0x00, 0x3C, 0xFC, 0x2C);

DECLARE_INTERFACE_ (IVCmdMenuW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdMenu members
   STDMETHOD (Activate)       (THIS_ HWND, DWORD) PURE;
   STDMETHOD (Deactivate)     (THIS) PURE;
   STDMETHOD (TrainMenuDlg)   (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (Num)            (THIS_ DWORD *) PURE;
   STDMETHOD (Get)            (THIS_ DWORD, DWORD, DWORD, PSDATA, DWORD *) PURE;
   STDMETHOD (Set)            (THIS_ DWORD, DWORD, DWORD, SDATA) PURE;
   STDMETHOD (Add)            (THIS_ DWORD, SDATA, DWORD *) PURE;
   STDMETHOD (Remove)         (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (ListGet)        (THIS_ PCWSTR, PSDATA, DWORD *) PURE;
   STDMETHOD (ListSet)        (THIS_ PCWSTR, DWORD, SDATA) PURE;
   STDMETHOD (EnableItem)     (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (SetItem)        (THIS_ DWORD, DWORD, DWORD) PURE;
};

typedef IVCmdMenuW FAR * PIVCMDMENUW;


#undef   INTERFACE
#define  INTERFACE   IVCmdMenuA

// {746141E0-5543-11b9-C000-5611722E1D15}
DEFINE_GUID(IID_IVCmdMenuA, 0x746141e0, 0x5543, 0x11b9, 0xc0, 0x0, 0x56, 0x11, 0x72, 0x2e, 0x1d, 0x15);

DECLARE_INTERFACE_ (IVCmdMenuA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdMenu members
   STDMETHOD (Activate)       (THIS_ HWND, DWORD) PURE;
   STDMETHOD (Deactivate)     (THIS) PURE;
   STDMETHOD (TrainMenuDlg)   (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (Num)            (THIS_ DWORD *) PURE;
   STDMETHOD (Get)            (THIS_ DWORD, DWORD, DWORD, PSDATA, DWORD *) PURE;
   STDMETHOD (Set)            (THIS_ DWORD, DWORD, DWORD, SDATA) PURE;
   STDMETHOD (Add)            (THIS_ DWORD, SDATA, DWORD *) PURE;
   STDMETHOD (Remove)         (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (ListGet)        (THIS_ PCSTR, PSDATA, DWORD *) PURE;
   STDMETHOD (ListSet)        (THIS_ PCSTR, DWORD, SDATA) PURE;
   STDMETHOD (EnableItem)     (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (SetItem)        (THIS_ DWORD, DWORD, DWORD) PURE;
};

typedef IVCmdMenuA FAR * PIVCMDMENUA;


#ifdef _S_UNICODE
 #define IVCmdMenu      IVCmdMenuW
 #define IID_IVCmdMenu  IID_IVCmdMenuW
 #define PIVCMDMENU     PIVCMDMENUW

#else
 #define IVCmdMenu      IVCmdMenuA
 #define IID_IVCmdMenu  IID_IVCmdMenuA
 #define PIVCMDMENU     PIVCMDMENUA

#endif // _S_UNICODE



/*
 *  IVoiceCmd
 */
#undef   INTERFACE
#define  INTERFACE   IVoiceCmdW

DEFINE_GUID(IID_IVoiceCmdW, 0xE0DCC220L, 0x604D, 0x101B, 0x99, 0x26, 0x00, 0xAA, 0x00, 0x3C, 0xFC, 0x2C);

DECLARE_INTERFACE_ (IVoiceCmdW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVoiceCmd members
   STDMETHOD (Register)       (THIS_ PCWSTR, LPUNKNOWN, GUID, DWORD,
				     PVCSITEINFOW) PURE;
   STDMETHOD (MenuEnum)       (THIS_ DWORD, PCWSTR, PCWSTR, PIVCMDENUMW *) PURE;
   STDMETHOD (MenuCreate)     (THIS_ PVCMDNAMEW, PLANGUAGEW, DWORD,
				     PIVCMDMENUW *) PURE;
   STDMETHOD (MenuDelete)     (THIS_ PVCMDNAMEW) PURE;
   STDMETHOD (CmdMimic)       (THIS_ PVCMDNAMEW, PCWSTR) PURE;
};

typedef IVoiceCmdW FAR * PIVOICECMDW;


#undef   INTERFACE
#define  INTERFACE   IVoiceCmdA

// {C63A2B30-5543-11b9-C000-5611722E1D15}
DEFINE_GUID(IID_IVoiceCmdA, 0xc63a2b30, 0x5543, 0x11b9, 0xc0, 0x0, 0x56, 0x11, 0x72, 0x2e, 0x1d, 0x15);

DECLARE_INTERFACE_ (IVoiceCmdA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVoiceCmd members
   STDMETHOD (Register)       (THIS_ PCSTR, LPUNKNOWN, GUID, DWORD,
				     PVCSITEINFOA) PURE;
   STDMETHOD (MenuEnum)       (THIS_ DWORD, PCSTR, PCSTR, PIVCMDENUMA *) PURE;
   STDMETHOD (MenuCreate)     (THIS_ PVCMDNAMEA, PLANGUAGEA, DWORD,
				     PIVCMDMENUA *) PURE;
   STDMETHOD (MenuDelete)     (THIS_ PVCMDNAMEA) PURE;
   STDMETHOD (CmdMimic)       (THIS_ PVCMDNAMEA, PCSTR) PURE;
};

typedef IVoiceCmdA FAR * PIVOICECMDA;


#ifdef _S_UNICODE
 #define IVoiceCmd      IVoiceCmdW
 #define IID_IVoiceCmd  IID_IVoiceCmdW
 #define PIVOICECMD     PIVOICECMDW

#else
 #define IVoiceCmd      IVoiceCmdA
 #define IID_IVoiceCmd  IID_IVoiceCmdA
 #define PIVOICECMD     PIVOICECMDA

#endif //_S_UNICODE


/*
 *  IVCmdAttributes
 */
#undef   INTERFACE
#define  INTERFACE   IVCmdAttributesW

DEFINE_GUID(IID_IVCmdAttributesW, 0xE5F24680L, 0x6053, 0x101B, 0x99, 0x26, 0x00, 0xAA, 0x00, 0x3C, 0xFC, 0x2C);

DECLARE_INTERFACE_ (IVCmdAttributesW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdAttributes members
   STDMETHOD (AutoGainEnableGet) (THIS_ DWORD *) PURE;
   STDMETHOD (AutoGainEnableSet) (THIS_ DWORD) PURE;
   STDMETHOD (AwakeStateGet)     (THIS_ DWORD *) PURE;
   STDMETHOD (AwakeStateSet)     (THIS_ DWORD) PURE;
   STDMETHOD (ThresholdGet)      (THIS_ DWORD *) PURE;
   STDMETHOD (ThresholdSet)      (THIS_ DWORD) PURE;
   STDMETHOD (DeviceGet)         (THIS_ DWORD *) PURE;
   STDMETHOD (DeviceSet)         (THIS_ DWORD) PURE;
   STDMETHOD (EnabledGet)        (THIS_ DWORD *) PURE;
   STDMETHOD (EnabledSet)        (THIS_ DWORD) PURE;
   STDMETHOD (MicrophoneGet)     (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (MicrophoneSet)     (THIS_ PCWSTR) PURE;
   STDMETHOD (SpeakerGet)        (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (SpeakerSet)        (THIS_ PCWSTR) PURE;
   STDMETHOD (SRModeGet)         (THIS_ GUID *) PURE;
   STDMETHOD (SRModeSet)         (THIS_ GUID) PURE;
};

typedef IVCmdAttributesW FAR * PIVCMDATTRIBUTESW;


#undef   INTERFACE
#define  INTERFACE   IVCmdAttributesA

// {FFF5DF80-5544-11b9-C000-5611722E1D15}
DEFINE_GUID(IID_IVCmdAttributesA, 0xfff5df80, 0x5544, 0x11b9, 0xc0, 0x0, 0x56, 0x11, 0x72, 0x2e, 0x1d, 0x15);

DECLARE_INTERFACE_ (IVCmdAttributesA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdAttributes members
   STDMETHOD (AutoGainEnableGet) (THIS_ DWORD *) PURE;
   STDMETHOD (AutoGainEnableSet) (THIS_ DWORD) PURE;
   STDMETHOD (AwakeStateGet)     (THIS_ DWORD *) PURE;
   STDMETHOD (AwakeStateSet)     (THIS_ DWORD) PURE;
   STDMETHOD (ThresholdGet)      (THIS_ DWORD *) PURE;
   STDMETHOD (ThresholdSet)      (THIS_ DWORD) PURE;
   STDMETHOD (DeviceGet)         (THIS_ DWORD *) PURE;
   STDMETHOD (DeviceSet)         (THIS_ DWORD) PURE;
   STDMETHOD (EnabledGet)        (THIS_ DWORD *) PURE;
   STDMETHOD (EnabledSet)        (THIS_ DWORD) PURE;
   STDMETHOD (MicrophoneGet)     (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD (MicrophoneSet)     (THIS_ PCSTR) PURE;
   STDMETHOD (SpeakerGet)        (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD (SpeakerSet)        (THIS_ PCSTR) PURE;
   STDMETHOD (SRModeGet)         (THIS_ GUID *) PURE;
   STDMETHOD (SRModeSet)         (THIS_ GUID) PURE;
};

typedef IVCmdAttributesA FAR * PIVCMDATTRIBUTESA;


#ifdef _S_UNICODE
 #define IVCmdAttributes        IVCmdAttributesW
 #define IID_IVCmdAttributes    IID_IVCmdAttributesW
 #define PIVCMDATTRIBUTES       PIVCMDATTRIBUTESW

#else
 #define IVCmdAttributes        IVCmdAttributesA
 #define IID_IVCmdAttributes    IID_IVCmdAttributesA
 #define PIVCMDATTRIBUTES       PIVCMDATTRIBUTESA

#endif // _S_UNICODE



/*
 *  IVCmdDialog
 */
#undef   INTERFACE
#define  INTERFACE   IVCmdDialogsW

DEFINE_GUID(IID_IVCmdDialogsW, 0xEE39B8A0L, 0x6053, 0x101B, 0x99, 0x26, 0x00, 0xAA, 0x00, 0x3C, 0xFC, 0x2C);

DECLARE_INTERFACE_ (IVCmdDialogsW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)     (THIS) PURE;
   STDMETHOD_(ULONG,Release)    (THIS) PURE;

   // IVCmdDialogs members
   STDMETHOD (AboutDlg)         (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (GeneralDlg)       (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (LexiconDlg)       (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TrainGeneralDlg)  (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TrainMicDlg)      (THIS_ HWND, PCWSTR) PURE;
};

typedef IVCmdDialogsW FAR * PIVCMDDIALOGSW;


#undef   INTERFACE
#define  INTERFACE   IVCmdDialogsA

// {AA8FE260-5545-11b9-C000-5611722E1D15}
DEFINE_GUID(IID_IVCmdDialogsA, 0xaa8fe260, 0x5545, 0x11b9, 0xc0, 0x0, 0x56, 0x11, 0x72, 0x2e, 0x1d, 0x15);

DECLARE_INTERFACE_ (IVCmdDialogsA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)     (THIS) PURE;
   STDMETHOD_(ULONG,Release)    (THIS) PURE;

   // IVCmdDialogs members
   STDMETHOD (AboutDlg)         (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (GeneralDlg)       (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (LexiconDlg)       (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TrainGeneralDlg)  (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TrainMicDlg)      (THIS_ HWND, PCSTR) PURE;
};

typedef IVCmdDialogsA FAR * PIVCMDDIALOGSA;


#ifdef _S_UNICODE
 #define IVCmdDialogs       IVCmdDialogsW
 #define IID_IVCmdDialogs   IID_IVCmdDialogsW
 #define PIVCMDDIALOGS      PIVCMDDIALOGSW

#else
 #define IVCmdDialogs       IVCmdDialogsA
 #define IID_IVCmdDialogs   IID_IVCmdDialogsA
 #define PIVCMDDIALOGS      PIVCMDDIALOGSA

#endif // _S_UNICODE



/************************************************************************
class guids */

// DEFINE_GUID(CLSID_VCmd, 0x93898800L, 0x604D, 0x101B, 0x99, 0x26, 0x00, 0xAA, 0x00, 0x3C, 0xFC, 0x2C);
// {6D40D820-0BA7-11ce-A166-00AA004CD65C}
DEFINE_GUID(CLSID_VCmd, 
0x6d40d820, 0xba7, 0x11ce, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);
// {89F70C30-8636-11ce-B763-00AA004CD65C}
DEFINE_GUID(CLSID_SRShare, 
0x89f70c30, 0x8636, 0x11ce, 0xb7, 0x63, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);



/************************************************************************
High-Level dictation speech recognition API
*/

/************************************************************************
defines */
#define     VDCT_TOPICNAMELEN       32

// bit flags for the dwReason field of IVDctNotifySink::TextChanged
#define     VDCT_TEXTADDED          0x00000001
#define     VDCT_TEXTREMOVED        0x00000002
#define     VDCT_TEXTREPLACED       0x00000004

// bit flags for the dwReason field of IVDctText::TextRemove/TextSet
#define     VDCT_TEXTCLEAN          0x00010000
#define     VDCT_TEXTKEEPRESULTS    0x00020000

// bit flags for dwFlags of IVDctGUI::FlagsSet
#define     VDCTGUIF_VISIBLE        0x00000001
#define     VDCTGUIF_DONTMOVE       0x00000002

/************************************************************************
typedefs */

// site information structure - used for IVoiceDictation::SiteInfoGet/Set
typedef struct {
    DWORD   dwAutoGainEnable;
    DWORD   dwAwakeState;
    DWORD   dwThreshold;
    DWORD   dwDevice;
    DWORD   dwEnable;
    WCHAR   szMicrophone[VCMD_MICLEN];
    WCHAR   szSpeaker[VCMD_SPEAKERLEN];
    GUID    gModeID;
} VDSITEINFOW, *PVDSITEINFOW;

typedef struct {
    DWORD   dwAutoGainEnable;
    DWORD   dwAwakeState;
    DWORD   dwThreshold;
    DWORD   dwDevice;
    DWORD   dwEnable;
    CHAR    szMicrophone[VCMD_MICLEN];
    CHAR    szSpeaker[VCMD_SPEAKERLEN];
    GUID    gModeID;
} VDSITEINFOA, *PVDSITEINFOA;


// topic structure used by the IVoiceDictation object
typedef struct {
    WCHAR       szTopic[VDCT_TOPICNAMELEN];
    LANGUAGEW   language;
} VDCTTOPICW, *PVDCTTOPICW;

typedef struct {
    CHAR        szTopic[VDCT_TOPICNAMELEN];
    LANGUAGEA   language;
} VDCTTOPICA, *PVDCTTOPICA;


#ifdef  _S_UNICODE
 #define VDSITEINFO  VDSITEINFOW
 #define PVDSITEINFO PVDSITEINFOW
 #define VDCTTOPIC   VDCTTOPICW
 #define PVDCTTOPIC  PVDCTTOPICW
#else
 #define VDSITEINFO  VDSITEINFOA
 #define PVDSITEINFO PVDSITEINFOA
 #define VDCTTOPIC   VDCTTOPICA
 #define PVDCTTOPIC  PVDCTTOPICA
#endif  // _S_UNICODE


// memory maintenance structure used by MemoryGet/Set in IVDctAttributes
typedef struct {
    DWORD   dwMaxRAM;
    DWORD   dwMaxTime;
    DWORD   dwMaxWords;
    BOOL    fKeepAudio;
    BOOL    fKeepCorrection;
    BOOL    fKeepEval;
} VDCTMEMORY, *PVDCTMEMORY;


// bookmark definition
typedef struct {
    DWORD   dwID;
    DWORD   dwStartChar;
    DWORD   dwNumChars;
} VDCTBOOKMARK, *PVDCTBOOKMARK;



/************************************************************************
interfaces */

/*
 *  IVDctNotifySink
 */
#undef   INTERFACE
#define  INTERFACE   IVDctNotifySinkW

// {5FEB8800-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctNotifySinkW,
0x5feb8800, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctNotifySinkW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctNotifySink members
   STDMETHOD (CommandBuiltIn)       (THIS_ PWSTR) PURE;
   STDMETHOD (CommandOther)         (THIS_ PWSTR) PURE;
   STDMETHOD (CommandRecognize)     (THIS_ DWORD, DWORD, DWORD, PVOID, PWSTR) PURE;
   STDMETHOD (TextSelChanged)       (THIS) PURE;
   STDMETHOD (TextChanged)          (THIS_ DWORD) PURE;
   STDMETHOD (TextBookmarkChanged)  (THIS_ DWORD) PURE;
   STDMETHOD (PhraseStart)          (THIS) PURE;
   STDMETHOD (PhraseFinish)         (THIS_ DWORD, PSRPHRASEW) PURE;
   STDMETHOD (PhraseHypothesis)     (THIS_ DWORD, PSRPHRASEW) PURE;
   STDMETHOD (UtteranceBegin)       (THIS) PURE;
   STDMETHOD (UtteranceEnd)         (THIS) PURE;
   STDMETHOD (VUMeter)              (THIS_ WORD) PURE;
   STDMETHOD (AttribChanged)        (THIS_ DWORD) PURE;
   STDMETHOD (Interference)         (THIS_ DWORD) PURE;
   STDMETHOD (Training)             (THIS_ DWORD) PURE;
   STDMETHOD (Dictating)            (THIS_ PCWSTR, BOOL) PURE;
};

typedef IVDctNotifySinkW FAR * PIVDCTNOTIFYSINKW;


#undef   INTERFACE
#define  INTERFACE   IVDctNotifySinkA

// {88AD7DC0-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctNotifySinkA,
0x88ad7dc0, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctNotifySinkA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctNotifySinkA members
   STDMETHOD (CommandBuiltIn)       (THIS_ PSTR) PURE;
   STDMETHOD (CommandOther)         (THIS_ PSTR) PURE;
   STDMETHOD (CommandRecognize)     (THIS_ DWORD, DWORD, DWORD, PVOID, PSTR) PURE;
   STDMETHOD (TextSelChanged)       (THIS) PURE;
   STDMETHOD (TextChanged)          (THIS_ DWORD) PURE;
   STDMETHOD (TextBookmarkChanged)  (THIS_ DWORD) PURE;
   STDMETHOD (PhraseStart)          (THIS) PURE;
   STDMETHOD (PhraseFinish)         (THIS_ DWORD, PSRPHRASEA) PURE;
   STDMETHOD (PhraseHypothesis)     (THIS_ DWORD, PSRPHRASEA) PURE;
   STDMETHOD (UtteranceBegin)       (THIS) PURE;
   STDMETHOD (UtteranceEnd)         (THIS) PURE;
   STDMETHOD (VUMeter)              (THIS_ WORD) PURE;
   STDMETHOD (AttribChanged)        (THIS_ DWORD) PURE;
   STDMETHOD (Interference)         (THIS_ DWORD) PURE;
   STDMETHOD (Training)             (THIS_ DWORD) PURE;
   STDMETHOD (Dictating)            (THIS_ PCSTR, BOOL) PURE;
};

typedef IVDctNotifySinkA FAR * PIVDCTNOTIFYSINKA;


#ifdef _S_UNICODE
 #define IVDctNotifySink        IVDctNotifySinkW
 #define IID_IVDctNotifySink    IID_IVDctNotifySinkW
 #define PIVDCTNOTIFYSINK       PIVDCTNOTIFYSINKW

#else
 #define IVDctNotifySink        IVDctNotifySinkA
 #define IID_IVDctNotifySink    IID_IVDctNotifySinkA
 #define PIVDCTNOTIFYSINK       PIVDCTNOTIFYSINKA

#endif // _S_UNICODE



 
/*
 *  IVoiceDictation
 */
#undef   INTERFACE
#define  INTERFACE   IVoiceDictationW

// {88AD7DC3-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVoiceDictationW,
0x88ad7dc3, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVoiceDictationW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVoiceDictation members
   STDMETHOD (Register)         (THIS_ PCWSTR, PCWSTR, LPSTORAGE, PCWSTR,
				 PIVDCTNOTIFYSINK, GUID, DWORD) PURE;
   STDMETHOD (SiteInfoGet)      (THIS_ PCWSTR, PVDSITEINFOW) PURE;
   STDMETHOD (SiteInfoSet)      (THIS_ PCWSTR, PVDSITEINFOW) PURE;
   STDMETHOD (SessionSerialize) (THIS_ LPSTORAGE) PURE;
   STDMETHOD (TopicEnum)        (THIS_ PVDCTTOPICW *, DWORD *) PURE;
   STDMETHOD (TopicAdd)         (THIS_ PCWSTR, LANGUAGEW *, PCWSTR *, PCWSTR *,
				 PCWSTR *, PCWSTR *) PURE;
   STDMETHOD (TopicRemove)      (THIS_ PCWSTR) PURE;
   STDMETHOD (TopicSerialize)   (THIS_ LPSTORAGE) PURE;
   STDMETHOD (TopicDeserialize) (THIS_ LPSTORAGE) PURE;
   STDMETHOD (Activate)         (THIS_ HWND) PURE;
   STDMETHOD (Deactivate)       (THIS) PURE;
   STDMETHOD (TopicAddGrammar)  (THIS_ PCWSTR, SDATA) PURE;
};

typedef IVoiceDictationW FAR * PIVOICEDICTATIONW;


#undef   INTERFACE
#define  INTERFACE   IVoiceDictationA

// {88AD7DC4-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVoiceDictationA,
0x88ad7dc4, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVoiceDictationA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVoiceDictation members
   STDMETHOD (Register)         (THIS_ PCSTR, PCSTR, LPSTORAGE, PCSTR,
				 PIVDCTNOTIFYSINK, GUID, DWORD) PURE;
   STDMETHOD (SiteInfoGet)      (THIS_ PCSTR, PVDSITEINFOA) PURE;
   STDMETHOD (SiteInfoSet)      (THIS_ PCSTR, PVDSITEINFOA) PURE;
   STDMETHOD (SessionSerialize) (THIS_ LPSTORAGE) PURE;
   STDMETHOD (TopicEnum)        (THIS_ PVDCTTOPICA *, DWORD *) PURE;
   STDMETHOD (TopicAdd)         (THIS_ PCSTR, LANGUAGEA *, PCSTR *, PCSTR *,
				 PCSTR *, PCSTR *) PURE;
   STDMETHOD (TopicRemove)      (THIS_ PCSTR) PURE;
   STDMETHOD (TopicSerialize)   (THIS_ LPSTORAGE) PURE;
   STDMETHOD (TopicDeserialize) (THIS_ LPSTORAGE) PURE;
   STDMETHOD (Activate)         (THIS_ HWND) PURE;
   STDMETHOD (Deactivate)       (THIS) PURE;
   STDMETHOD (TopicAddGrammar)  (THIS_ PCSTR, SDATA) PURE;
};

typedef IVoiceDictationA FAR * PIVOICEDICTATIONA;


#ifdef _S_UNICODE
 #define IVoiceDictation     IVoiceDictationW
 #define IID_IVoiceDictation IID_IVoiceDictationW
 #define PIVOICEDICTATION    PIVOICEDICTATIONW

#else
 #define IVoiceDictation     IVoiceDictationA
 #define IID_IVoiceDictation IID_IVoiceDictationA
 #define PIVOICEDICTATION    PIVOICEDICTATIONA

#endif //_S_UNICODE



/*
 *  IVDctText
 */
#undef   INTERFACE
#define  INTERFACE   IVDctTextW

// {6D62B3A0-6893-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctTextW,
0x6d62b3a0, 0x6893, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctTextW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctText members
   STDMETHOD (Lock)             (THIS) PURE;
   STDMETHOD (UnLock)           (THIS) PURE;
   STDMETHOD (TextGet)          (THIS_ DWORD, DWORD, PSDATA) PURE;
   STDMETHOD (TextSet)          (THIS_ DWORD, DWORD, PCWSTR, DWORD) PURE;
   STDMETHOD (TextMove)         (THIS_ DWORD, DWORD, DWORD, DWORD) PURE;
   STDMETHOD (TextRemove)       (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (TextSelSet)       (THIS_ DWORD, DWORD) PURE;
   STDMETHOD (TextSelGet)       (THIS_ DWORD *, DWORD *) PURE;
   STDMETHOD (TextLengthGet)    (THIS_ DWORD *) PURE;
   STDMETHOD (GetChanges)       (THIS_ DWORD *, DWORD *, DWORD *, DWORD *) PURE;
   STDMETHOD (BookmarkAdd)      (THIS_ PVDCTBOOKMARK) PURE;
   STDMETHOD (BookmarkRemove)   (THIS_ DWORD) PURE;
   STDMETHOD (BookmarkMove)     (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (BookmarkQuery)    (THIS_ DWORD, PVDCTBOOKMARK) PURE;
   STDMETHOD (BookmarkEnum)     (THIS_ DWORD, DWORD, PVDCTBOOKMARK *,
				       DWORD *) PURE;
   STDMETHOD (Hint)             (THIS_ PCWSTR) PURE;
   STDMETHOD (Words)            (THIS_ PCWSTR) PURE;
   STDMETHOD (ResultsGet)       (THIS_ DWORD, DWORD, DWORD *, DWORD *,
				       LPUNKNOWN *) PURE;
};
typedef IVDctTextW FAR * PIVDCTTEXTW;


#undef   INTERFACE
#define  INTERFACE   IVDctTextA

// {6D62B3A1-6893-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctTextA,
0x6d62b3a1, 0x6893, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctTextA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctText members
   STDMETHOD (Lock)             (THIS) PURE;
   STDMETHOD (UnLock)           (THIS) PURE;
   STDMETHOD (TextGet)          (THIS_ DWORD, DWORD, PSDATA) PURE;
   STDMETHOD (TextSet)          (THIS_ DWORD, DWORD, PCSTR, DWORD) PURE;
   STDMETHOD (TextMove)         (THIS_ DWORD, DWORD, DWORD, DWORD) PURE;
   STDMETHOD (TextRemove)       (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (TextSelSet)       (THIS_ DWORD, DWORD) PURE;
   STDMETHOD (TextSelGet)       (THIS_ DWORD *, DWORD *) PURE;
   STDMETHOD (TextLengthGet)    (THIS_ DWORD *) PURE;
   STDMETHOD (GetChanges)       (THIS_ DWORD *, DWORD *, DWORD *, DWORD *) PURE;
   STDMETHOD (BookmarkAdd)      (THIS_ PVDCTBOOKMARK) PURE;
   STDMETHOD (BookmarkRemove)   (THIS_ DWORD) PURE;
   STDMETHOD (BookmarkMove)     (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (BookmarkQuery)    (THIS_ DWORD, PVDCTBOOKMARK) PURE;
   STDMETHOD (BookmarkEnum)     (THIS_ DWORD, DWORD, PVDCTBOOKMARK *,
				       DWORD *) PURE;
   STDMETHOD (Hint)             (THIS_ PCSTR) PURE;
   STDMETHOD (Words)            (THIS_ PCSTR) PURE;
   STDMETHOD (ResultsGet)       (THIS_ DWORD, DWORD, DWORD *, DWORD *,
				       LPUNKNOWN *) PURE;
};
typedef IVDctTextA FAR * PIVDCTTEXTA;


#ifdef _S_UNICODE
 #define IVDctText      IVDctTextW
 #define IID_IVDctText  IID_IVDctTextW
 #define PIVDCTTEXT     PIVDCTTEXTW

#else
 #define IVDctText      IVDctTextA
 #define IID_IVDctText  IID_IVDctTextA
 #define PIVDCTTEXT     PIVDCTTEXTA

#endif //_S_UNICODE



/*
 *  IVDctAttributes
 */
#undef   INTERFACE
#define  INTERFACE   IVDctAttributesW

// {88AD7DC5-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctAttributesW,
0x88ad7dc5, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctAttributesW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctAttributes members
   STDMETHOD    (AutoGainEnableGet)  (THIS_ DWORD *) PURE;
   STDMETHOD    (AutoGainEnableSet)  (THIS_ DWORD) PURE;
   STDMETHOD    (AwakeStateGet)      (THIS_ DWORD *) PURE;
   STDMETHOD    (AwakeStateSet)      (THIS_ DWORD) PURE;
   STDMETHOD    (ThresholdGet)       (THIS_ DWORD *) PURE;
   STDMETHOD    (ThresholdSet)       (THIS_ DWORD) PURE;
   STDMETHOD    (EchoGet)            (THIS_ BOOL *) PURE;
   STDMETHOD    (EchoSet)            (THIS_ BOOL) PURE;
   STDMETHOD    (EnergyFloorGet)     (THIS_ WORD *) PURE;
   STDMETHOD    (EnergyFloorSet)     (THIS_ WORD) PURE;
   STDMETHOD    (RealTimeGet)        (THIS_ DWORD *) PURE;
   STDMETHOD    (RealTimeSet)        (THIS_ DWORD) PURE;
   STDMETHOD    (TimeOutGet)         (THIS_ DWORD *, DWORD *) PURE;
   STDMETHOD    (TimeOutSet)         (THIS_ DWORD, DWORD) PURE;
   STDMETHOD    (EnabledGet)         (THIS_ DWORD *) PURE;
   STDMETHOD    (EnabledSet)         (THIS_ DWORD) PURE;
   STDMETHOD    (BuiltInFeaturesGet) (THIS_ DWORD *) PURE;
   STDMETHOD    (BuiltInFeaturesSet) (THIS_ DWORD) PURE;
   STDMETHOD    (MemoryGet)          (THIS_ VDCTMEMORY *) PURE;
   STDMETHOD    (MemorySet)          (THIS_ VDCTMEMORY *) PURE;
   STDMETHOD    (DictatingNowGet)    (THIS_ DWORD *) PURE;
   STDMETHOD    (DictatingNowSet)    (THIS_ DWORD) PURE;
   STDMETHOD    (IsAnyoneDictating)  (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD    (MicrophoneGet)      (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD    (MicrophoneSet)      (THIS_ PCWSTR) PURE;
   STDMETHOD    (SpeakerGet)         (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD    (SpeakerSet)         (THIS_ PCWSTR) PURE;
};

typedef IVDctAttributesW FAR * PIVDCTATTRIBUTESW;


#undef   INTERFACE
#define  INTERFACE   IVDctAttributesA

// {88AD7DC6-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctAttributesA,
0x88ad7dc6, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctAttributesA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctAttributes members
   STDMETHOD    (AutoGainEnableGet)  (THIS_ DWORD *) PURE;
   STDMETHOD    (AutoGainEnableSet)  (THIS_ DWORD) PURE;
   STDMETHOD    (AwakeStateGet)      (THIS_ DWORD *) PURE;
   STDMETHOD    (AwakeStateSet)      (THIS_ DWORD) PURE;
   STDMETHOD    (ThresholdGet)       (THIS_ DWORD *) PURE;
   STDMETHOD    (ThresholdSet)       (THIS_ DWORD) PURE;
   STDMETHOD    (EchoGet)            (THIS_ BOOL *) PURE;
   STDMETHOD    (EchoSet)            (THIS_ BOOL) PURE;
   STDMETHOD    (EnergyFloorGet)     (THIS_ WORD *) PURE;
   STDMETHOD    (EnergyFloorSet)     (THIS_ WORD) PURE;
   STDMETHOD    (RealTimeGet)        (THIS_ DWORD *) PURE;
   STDMETHOD    (RealTimeSet)        (THIS_ DWORD) PURE;
   STDMETHOD    (TimeOutGet)         (THIS_ DWORD *, DWORD *) PURE;
   STDMETHOD    (TimeOutSet)         (THIS_ DWORD, DWORD) PURE;
   STDMETHOD    (EnabledGet)         (THIS_ DWORD *) PURE;
   STDMETHOD    (EnabledSet)         (THIS_ DWORD) PURE;
   STDMETHOD    (BuiltInFeaturesGet) (THIS_ DWORD *) PURE;
   STDMETHOD    (BuiltInFeaturesSet) (THIS_ DWORD) PURE;
   STDMETHOD    (MemoryGet)          (THIS_ VDCTMEMORY *) PURE;
   STDMETHOD    (MemorySet)          (THIS_ VDCTMEMORY *) PURE;
   STDMETHOD    (DictatingNowGet)    (THIS_ DWORD *) PURE;
   STDMETHOD    (DictatingNowSet)    (THIS_ DWORD) PURE;
   STDMETHOD    (IsAnyoneDictating)  (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD    (MicrophoneGet)      (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD    (MicrophoneSet)      (THIS_ PCSTR) PURE;
   STDMETHOD    (SpeakerGet)         (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD    (SpeakerSet)         (THIS_ PCSTR) PURE;
};

typedef IVDctAttributesA FAR * PIVDCTATTRIBUTESA;


#ifdef _S_UNICODE
 #define IVDctAttributes        IVDctAttributesW
 #define IID_IVDctAttributes    IID_IVDctAttributesW
 #define PIVDCTATTRIBUTES       PIVDCTATTRIBUTESW

#else
 #define IVDctAttributes        IVDctAttributesA
 #define IID_IVDctAttributes    IID_IVDctAttributesA
 #define PIVDCTATTRIBUTES       PIVDCTATTRIBUTESA

#endif // _S_UNICODE



/*
 *  IVDctCommands
 */
#undef   INTERFACE
#define  INTERFACE   IVDctCommandsW

// {A02C2CA0-AE50-11cf-833A-00AA00A21A29}
DEFINE_GUID(IID_IVDctCommandsW,
0xA02C2CA0, 0xAE50, 0x11cf, 0x83, 0x3A, 0x00, 0xAA, 0x00, 0xA2, 0x1A, 0x29);

DECLARE_INTERFACE_ (IVDctCommandsW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctCommands members
   STDMETHOD    (Add)      (THIS_ BOOL, DWORD, SDATA, DWORD *) PURE;
   STDMETHOD    (Remove)   (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Get)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA*, DWORD *) PURE;
   STDMETHOD    (Set)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA) PURE;
   STDMETHOD    (EnableItem) (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Num)      (THIS_ BOOL, DWORD *) PURE;
};

typedef IVDctCommandsW FAR * PIVDCTCOMMANDSW;


#undef   INTERFACE
#define  INTERFACE   IVDctCommandsA

// {A02C2CA1-AE50-11cf-833A-00AA00A21A29}
DEFINE_GUID(IID_IVDctCommandsA,
0xA02C2CA1, 0xAE50, 0x11cf, 0x83, 0x3A, 0x00, 0xAA, 0x00, 0xA2, 0x1A, 0x29);

DECLARE_INTERFACE_ (IVDctCommandsA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctCommands members
   STDMETHOD    (Add)      (THIS_ BOOL, DWORD, SDATA, DWORD *) PURE;
   STDMETHOD    (Remove)   (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Get)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA*, DWORD *) PURE;
   STDMETHOD    (Set)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA) PURE;
   STDMETHOD    (EnableItem) (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Num)      (THIS_ BOOL, DWORD *) PURE;
};

typedef IVDctCommandsA FAR * PIVDCTCOMMANDSA;


#ifdef _S_UNICODE
 #define IVDctCommands        IVDctCommandsW
 #define IID_IVDctCommands    IID_IVDctCommandsW
 #define PIVDCTCOMMANDS       PIVDCTCOMMANDSW

#else
 #define IVDctCommands        IVDctCommandsA
 #define IID_IVDctCommands    IID_IVDctCommandsA
 #define PIVDCTCOMMANDS       PIVDCTCOMMANDSA

#endif // _S_UNICODE



/*
 *  IVDctGlossary
 */
#undef   INTERFACE
#define  INTERFACE   IVDctGlossaryW

// {A02C2CA2-AE50-11cf-833A-00AA00A21A29}
DEFINE_GUID(IID_IVDctGlossaryW,
0xA02C2CA2, 0xAE50, 0x11cf, 0x83, 0x3A, 0x00, 0xAA, 0x00, 0xA2, 0x1A, 0x29);

DECLARE_INTERFACE_ (IVDctGlossaryW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctGlossary members
   STDMETHOD    (Add)      (THIS_ BOOL, DWORD, SDATA, DWORD *) PURE;
   STDMETHOD    (Remove)   (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Get)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA*, DWORD *) PURE;
   STDMETHOD    (Set)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA) PURE;
   STDMETHOD    (EnableItem) (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Num)      (THIS_ BOOL, DWORD *) PURE;
};

typedef IVDctGlossaryW FAR * PIVDCTGLOSSARYW;


#undef   INTERFACE
#define  INTERFACE   IVDctGlossaryA

// {A02C2CA3-AE50-11cf-833A-00AA00A21A29}
DEFINE_GUID(IID_IVDctGlossaryA,
0xA02C2CA3, 0xAE50, 0x11cf, 0x83, 0x3A, 0x00, 0xAA, 0x00, 0xA2, 0x1A, 0x29);

DECLARE_INTERFACE_ (IVDctGlossaryA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctGlossary members
   STDMETHOD    (Add)      (THIS_ BOOL, DWORD, SDATA, DWORD *) PURE;
   STDMETHOD    (Remove)   (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Get)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA*, DWORD *) PURE;
   STDMETHOD    (Set)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA) PURE;
   STDMETHOD    (EnableItem) (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Num)      (THIS_ BOOL, DWORD *) PURE;
};

typedef IVDctGlossaryA FAR * PIVDCTGLOSSARYA;


#ifdef _S_UNICODE
 #define IVDctGlossary        IVDctGlossaryW
 #define IID_IVDctGlossary    IID_IVDctGlossaryW
 #define PIVDCTGLOSSARY       PIVDCTGLOSSARYW

#else
 #define IVDctGlossary        IVDctGlossaryA
 #define IID_IVDctGlossary    IID_IVDctGlossaryA
 #define PIVDCTGLOSSARY       PIVDCTGLOSSARYA

#endif // _S_UNICODE




/*
 *  IVDctDialog
 */
#undef   INTERFACE
#define  INTERFACE   IVDctDialogsW

// {88AD7DC7-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctDialogsW,
0x88ad7dc7, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctDialogsW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)     (THIS) PURE;
   STDMETHOD_(ULONG,Release)    (THIS) PURE;

   // IVDctDialogs members
   STDMETHOD (AboutDlg)         (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (GeneralDlg)       (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (LexiconDlg)       (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TrainGeneralDlg)  (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TrainMicDlg)      (THIS_ HWND, PCWSTR) PURE;
};

typedef IVDctDialogsW FAR * PIVDCTDIALOGSW;


#undef   INTERFACE
#define  INTERFACE   IVDctDialogsA

// {88AD7DC8-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctDialogsA,
0x88ad7dc8, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctDialogsA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)     (THIS) PURE;
   STDMETHOD_(ULONG,Release)    (THIS) PURE;

   // IVDctDialogs members
   STDMETHOD (AboutDlg)         (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (GeneralDlg)       (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (LexiconDlg)       (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TrainGeneralDlg)  (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TrainMicDlg)      (THIS_ HWND, PCSTR) PURE;
};

typedef IVDctDialogsA FAR * PIVDCTDIALOGSA;


#ifdef _S_UNICODE
 #define IVDctDialogs       IVDctDialogsW
 #define IID_IVDctDialogs   IID_IVDctDialogsW
 #define PIVDCTDIALOGS      PIVDCTDIALOGSW

#else
 #define IVDctDialogs       IVDctDialogsA
 #define IID_IVDctDialogs   IID_IVDctDialogsA
 #define PIVDCTDIALOGS      PIVDCTDIALOGSA

#endif // _S_UNICODE


#undef   INTERFACE
#define  INTERFACE   IVDctGUI

// {8953F1A0-7E80-11cf-8D15-00A0C9034A7E}
DEFINE_GUID(IID_IVDctGUI,
0x8953f1a0, 0x7e80, 0x11cf, 0x8d, 0x15, 0x0, 0xa0, 0xc9, 0x3, 0x4a, 0x7e);

DECLARE_INTERFACE_ (IVDctGUI, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)     (THIS) PURE;
   STDMETHOD_(ULONG,Release)    (THIS) PURE;

   // IVDctDialogs members
   STDMETHOD (SetSelRect)       (THIS_ RECT *) PURE;
   STDMETHOD (FlagsSet)         (THIS_ DWORD) PURE;
   STDMETHOD (FlagsGet)         (THIS_ DWORD *) PURE;
};

typedef IVDctGUI FAR * PIVDCTGUI;



/************************************************************************
class guids */

// {25522CA0-67CE-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(CLSID_VDct, 
0x25522ca0, 0x67ce, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);



/************************************************************************
High-Level text-to-speech API
*/


/************************************************************************
defines */

#define  ONE                    (1)

// dwFlags parameter of IVoiceText::Register
#define  VTXTF_ALLMESSAGES      (ONE<<0)

/*
 *   dwFlags parameter of IVoiceText::Speak
 */

// type of speech
#define  VTXTST_STATEMENT       0x00000001
#define  VTXTST_QUESTION        0x00000002
#define  VTXTST_COMMAND         0x00000004
#define  VTXTST_WARNING         0x00000008
#define  VTXTST_READING         0x00000010
#define  VTXTST_NUMBERS         0x00000020
#define  VTXTST_SPREADSHEET     0x00000040

// priorities
#define  VTXTSP_VERYHIGH        0x00000080
#define  VTXTSP_HIGH            0x00000100
#define  VTXTSP_NORMAL          0x00000200

/************************************************************************
typedefs */

// possible parameter to IVoiceText::Register
typedef struct {
    DWORD   dwDevice;
    DWORD   dwEnable;
    DWORD   dwSpeed;
    GUID    gModeID;
} VTSITEINFO, *PVTSITEINFO;


/************************************************************************
interfaces */

/*
 *  IVCmdNotifySink
 */
#undef   INTERFACE
#define  INTERFACE   IVTxtNotifySinkW

// {FD3A2430-E090-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVTxtNotifySinkW, 0xfd3a2430, 0xe090, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVTxtNotifySinkW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVTxtNotifySinkW members
   STDMETHOD (AttribChanged)    (THIS_ DWORD) PURE;
   STDMETHOD (Visual)           (THIS_ WCHAR, WCHAR, DWORD, PTTSMOUTH) PURE;
   STDMETHOD (Speak)            (THIS_ PWSTR, PWSTR, DWORD) PURE;
   STDMETHOD (SpeakingStarted)  (THIS) PURE;
   STDMETHOD (SpeakingDone)     (THIS) PURE;
};

typedef IVTxtNotifySinkW FAR * PIVTXTNOTIFYSINKW;


#undef   INTERFACE
#define  INTERFACE   IVTxtNotifySinkA

// {D2C840E0-E092-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVTxtNotifySinkA, 0xd2c840e0, 0xe092, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVTxtNotifySinkA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVTxtNotifySinkA members
   STDMETHOD (AttribChanged)    (THIS_ DWORD) PURE;
   STDMETHOD (Visual)           (THIS_ WCHAR, CHAR, DWORD, PTTSMOUTH) PURE;
   STDMETHOD (Speak)            (THIS_ PSTR, PSTR, DWORD) PURE;
   STDMETHOD (SpeakingStarted)  (THIS) PURE;
   STDMETHOD (SpeakingDone)     (THIS) PURE;
};

typedef IVTxtNotifySinkA FAR * PIVTXTNOTIFYSINKA;


#ifdef _S_UNICODE
 #define IVTxtNotifySink        IVTxtNotifySinkW
 #define IID_IVTxtNotifySink    IID_IVTxtNotifySinkW
 #define PIVTXTNOTIFYSINK       PIVTXTNOTIFYSINKW

#else
 #define IVTxtNotifySink        IVTxtNotifySinkA
 #define IID_IVTxtNotifySink    IID_IVTxtNotifySinkA
 #define PIVTXTNOTIFYSINK       PIVTXTNOTIFYSINKA

#endif // _S_UNICODE



/*
 *  IVoiceText
 */
#undef   INTERFACE
#define  INTERFACE   IVoiceTextW

// {C4FE8740-E093-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVoiceTextW, 0xc4fe8740, 0xe093, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVoiceTextW, IUnknown) {
    // IUnknown members
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IVoiceText members

    STDMETHOD (Register)         (THIS_ PCWSTR, PCWSTR, 
					PIVTXTNOTIFYSINK, GUID,
					DWORD, PVTSITEINFO) PURE;
    STDMETHOD (Speak)            (THIS_ PCWSTR, DWORD, PCWSTR) PURE;
    STDMETHOD (StopSpeaking)     (THIS) PURE;
    STDMETHOD (AudioFastForward) (THIS) PURE;
    STDMETHOD (AudioPause)       (THIS) PURE;
    STDMETHOD (AudioResume)      (THIS) PURE;
    STDMETHOD (AudioRewind)      (THIS) PURE;
};

typedef IVoiceTextW FAR * PIVOICETEXTW;


#undef   INTERFACE
#define  INTERFACE   IVoiceTextA

// {E1B7A180-E093-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVoiceTextA, 0xe1b7a180, 0xe093, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVoiceTextA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVoiceText members

    STDMETHOD (Register)         (THIS_ PCSTR, PCSTR, 
					PIVTXTNOTIFYSINK, GUID,
					DWORD, PVTSITEINFO) PURE;
    STDMETHOD (Speak)            (THIS_ PCSTR, DWORD, PCSTR) PURE;
    STDMETHOD (StopSpeaking)     (THIS) PURE;
    STDMETHOD (AudioFastForward) (THIS) PURE;
    STDMETHOD (AudioPause)       (THIS) PURE;
    STDMETHOD (AudioResume)      (THIS) PURE;
    STDMETHOD (AudioRewind)      (THIS) PURE;
};

typedef IVoiceTextA FAR * PIVOICETEXTA;


#ifdef _S_UNICODE
 #define IVoiceText      IVoiceTextW
 #define IID_IVoiceText  IID_IVoiceTextW
 #define PIVOICETEXT     PIVOICETEXTW

#else
 #define IVoiceText      IVoiceTextA
 #define IID_IVoiceText  IID_IVoiceTextA
 #define PIVOICETEXT     PIVOICETEXTA

#endif //_S_UNICODE



/*
 *  IVTxtAttributes
 */
#undef   INTERFACE
#define  INTERFACE   IVTxtAttributesW

// {6A8D6140-E095-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVTxtAttributesW, 0x6a8d6140, 0xe095, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVTxtAttributesW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVTxtAttributes members
   STDMETHOD (DeviceGet)         (THIS_ DWORD *) PURE;
   STDMETHOD (DeviceSet)         (THIS_ DWORD) PURE;
   STDMETHOD (EnabledGet)        (THIS_ DWORD *) PURE;
   STDMETHOD (EnabledSet)        (THIS_ DWORD) PURE;
   STDMETHOD (IsSpeaking)        (THIS_ BOOL *) PURE;
   STDMETHOD (SpeedGet)          (THIS_ DWORD *) PURE;
   STDMETHOD (SpeedSet)          (THIS_ DWORD) PURE;
   STDMETHOD (TTSModeGet)        (THIS_ GUID *) PURE;
   STDMETHOD (TTSModeSet)        (THIS_ GUID) PURE;
};

typedef IVTxtAttributesW FAR * PIVTXTATTRIBUTESW;


#undef   INTERFACE
#define  INTERFACE   IVTxtAttributesA

// {8BE9CC30-E095-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVTxtAttributesA, 0x8be9cc30, 0xe095, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVTxtAttributesA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVTxtAttributes members
   STDMETHOD (DeviceGet)         (THIS_ DWORD *) PURE;
   STDMETHOD (DeviceSet)         (THIS_ DWORD) PURE;
   STDMETHOD (EnabledGet)        (THIS_ DWORD *) PURE;
   STDMETHOD (EnabledSet)        (THIS_ DWORD) PURE;
   STDMETHOD (IsSpeaking)        (THIS_ BOOL *) PURE;
   STDMETHOD (SpeedGet)          (THIS_ DWORD *) PURE;
   STDMETHOD (SpeedSet)          (THIS_ DWORD) PURE;
   STDMETHOD (TTSModeGet)        (THIS_ GUID *) PURE;
   STDMETHOD (TTSModeSet)        (THIS_ GUID) PURE;
};

typedef IVTxtAttributesA FAR * PIVTXTATTRIBUTESA;


#ifdef _S_UNICODE
 #define IVTxtAttributes        IVTxtAttributesW
 #define IID_IVTxtAttributes    IID_IVTxtAttributesW
 #define PIVTXTATTRIBUTES       PIVTXTATTRIBUTESW

#else
 #define IVTxtAttributes        IVTxtAttributesA
 #define IID_IVTxtAttributes    IID_IVTxtAttributesA
 #define PIVTXTATTRIBUTES       PIVTXTATTRIBUTESA

#endif // _S_UNICODE



/*
 *  IVTxtDialog
 */
#undef   INTERFACE
#define  INTERFACE   IVTxtDialogsW

// {D6469210-E095-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVTxtDialogsW, 0xd6469210, 0xe095, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVTxtDialogsW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVTxtDialogs members

   STDMETHOD (AboutDlg)       (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (LexiconDlg)     (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (GeneralDlg)     (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TranslateDlg)   (THIS_ HWND, PCWSTR) PURE;
};

typedef IVTxtDialogsW FAR * PIVTXTDIALOGSW;


#undef   INTERFACE
#define  INTERFACE   IVTxtDialogsA

// {E8F6FA20-E095-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVTxtDialogsA, 0xe8f6fa20, 0xe095, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVTxtDialogsA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVTxtDialogs members
   STDMETHOD (AboutDlg)       (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (LexiconDlg)     (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (GeneralDlg)     (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TranslateDlg)   (THIS_ HWND, PCSTR) PURE;
};

typedef IVTxtDialogsA FAR * PIVTXTDIALOGSA;


#ifdef _S_UNICODE
 #define IVTxtDialogs       IVTxtDialogsW
 #define IID_IVTxtDialogs   IID_IVTxtDialogsW
 #define PIVTXTDIALOGS      PIVTXTDIALOGSW

#else
 #define IVTxtDialogs       IVTxtDialogsA
 #define IID_IVTxtDialogs   IID_IVTxtDialogsA
 #define PIVTXTDIALOGS      PIVTXTDIALOGSA

#endif // _S_UNICODE



/************************************************************************
class guids */

// {080EB9D0-E096-11cd-A166-00AA004CD65C}
// DEFINE_GUID(CLSID_VTxt, 0x80eb9d0, 0xe096, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);
// {F1DC95A0-0BA7-11ce-A166-00AA004CD65C}
DEFINE_GUID(CLSID_VTxt, 
0xf1dc95a0, 0xba7, 0x11ce, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);



#endif    // _SPEECH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrhook\getprop.cpp ===
/*************************************************************************
	Project:    Narrator
    Module:     getprop.cpp

    Author:     Charles Oppermann (ChuckOp)   
    Date:       24 October 1996
    
    Notes:      Gets Object Information

    Copyright (C) 1996 by Microsoft Corporation.  All rights reserved.
    See bottom of file for disclaimer
    
    History: Clean up buffer problems : a-anilk

*************************************************************************/
#define STRICT
#include <windows.h>
#include <windowsx.h>
#include <winerror.h>

#include <oleacc.h>

#include "..\Narrator\Narrator.h"
#include "getprop.h"
#define ARRAYSIZE(x)   (sizeof(x) / sizeof(*x))

void GetObjectProperty(IAccessible*, long, int, LPTSTR, UINT);
void VariantMyInit(VARIANT *pv);

// --------------------------------------------------------------------------
//
//  GetObjectProperty
//
// --------------------------------------------------------------------------
void GetObjectProperty(IAccessible * pobj, LONG idChild, int idProperty,
    LPTSTR lpszName,  UINT cchName)
{
    HRESULT hr=0;
    VARIANT varChild;
    BSTR bstr;
    RECT rc;
    VARIANT varResult;
	TCHAR bigbuf[4096] = TEXT("");


	if (!lpszName || cchName<1) return;
    *lpszName = 0;

    if ( cchName > ARRAYSIZE(bigbuf) )
        cchName = ARRAYSIZE(bigbuf);
    
    //
    // Clear out the possible return value objects
    //
    bstr = NULL;
    SetRectEmpty(&rc);
    VariantMyInit(&varResult);

    //
    // Setup the VARIANT child to pass in to the property
    //
    VariantMyInit(&varChild);
    varChild.vt = VT_I4;
    varChild.lVal = idChild;

    
    //
    // Get the property
    //
    switch (idProperty)
    {
        case ID_NAME:
                hr = pobj->get_accName(varChild, &bstr);
            break;

        case ID_DESCRIPTION:
                hr = pobj->get_accDescription(varChild, &bstr);
            break;

        case ID_VALUE:
                hr = pobj->get_accValue(varChild, &bstr);
            break;

        case ID_HELP:
            // Future enhancement:  Try help file instead if failure
               hr = pobj->get_accHelp(varChild, &bstr);
            break;

        case ID_SHORTCUT:
                hr = pobj->get_accKeyboardShortcut(varChild, &bstr);
            break;

        case ID_DEFAULT:
                hr = pobj->get_accDefaultAction(varChild, &bstr);
            break;

        case ID_ROLE:
                hr = pobj->get_accRole(varChild, &varResult);
            break;

        case ID_STATE:
                hr = pobj->get_accState(varChild, &varResult);
            break;

        case ID_LOCATION:
                hr = pobj->accLocation(&rc.left, &rc.top, &rc.right, &rc.bottom, varChild);
            break;
        case ID_CHILDREN:
//            hr = GetObjectChildren(pobj, idChild, lpszName, cchName);
            break;

        case ID_SELECTION:
//            hr = GetObjectSelection(pobj, idChild, lpszName, cchName);
            break;

        case ID_PARENT:
//            hr = GetObjectParent(pobj, idChild, lpszName, cchName);
            break;

        case ID_WINDOW:
//            hr = GetObjectWindow(pobj, lpszName, cchName);
            break;

    }

    // Return if the IAccessible call failed.
    if (!SUCCEEDED(hr))
    {
#ifdef _DEBUG
        // Pass back the error string to be displayed

        LPVOID  lpMsgBuf;
        LPTSTR  lpTChar;
        int     length;
     
        length = FormatMessage( 
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            hr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL 
        );
        lpTChar = (LPTSTR)lpMsgBuf;
        // remove the \r\n at the end of the string
        if (length > 2)
            if (lpTChar[length-2] == '\r')
                lpTChar[length-2] = 0;

      	wsprintf(bigbuf, TEXT("['%s' hr 0x%lx idProperty %d pobj 0x%lx idChild 0x%lx]"), lpMsgBuf,hr, idProperty, pobj, idChild);
		bigbuf[cchName-1]=0;
		lstrcpy(lpszName, bigbuf);

        // Free the buffer.
        LocalFree( lpMsgBuf );
#endif
        return;
    }

    //
    // Convert it to a display string
    //
    switch (idProperty)
    {
        // These are the cases already taken care of.
        case ID_SELECTION:
        case ID_CHILDREN:
        case ID_PARENT:
        case ID_WINDOW:
            break;

        // These are the cases where we got unicode string back
        case ID_NAME:
        case ID_DESCRIPTION:
        case ID_VALUE:
        case ID_HELP:
        case ID_SHORTCUT:
        case ID_DEFAULT:
            if (bstr)
            {
#ifdef UNICODE
			lstrcpyn(bigbuf, bstr, sizeof(bigbuf) / sizeof(TCHAR));
#else
            WideCharToMultiByte(CP_ACP, 0, bstr, -1, (LPBYTE)bigbuf, cchName, NULL, NULL);
#endif
           
			SysFreeString(bstr);

            }
            break;

        case ID_LOCATION:
            wsprintf(bigbuf, TEXT("{%04d, %04d, %04d, %04d}"), rc.left, rc.top,
                rc.left + rc.right, rc.top + rc.bottom);
            break;

        case ID_ROLE: // Role can be either I4 or BSTR
            break;

        case ID_STATE: // State can either be I4 or BSTR
            if (varResult.vt == VT_BSTR)
            {
#ifdef UNICODE
			lstrcpyn(bigbuf, varResult.bstrVal, sizeof(bigbuf) / sizeof(TCHAR));
#else
                // If we got back a string, use that.
            WideCharToMultiByte(CP_ACP, 0, varResult.bstrVal, -1,
                    bigbuf, cchName, NULL, NULL);
#endif
            }
            else if (varResult.vt == VT_I4)
            {
                int     iStateBit;
                DWORD   lStateBits;
                LPTSTR  lpszT;
                UINT    cchT;

                // We have a mask of standard states.  Make a string.
                // Separate the states with ",".
                lpszT = bigbuf;

                for (iStateBit = 0, lStateBits = 1; iStateBit < 32; iStateBit++, (lStateBits <<= 1))
                {
                    if (varResult.lVal & lStateBits)
                    {
                        cchT = GetStateText(lStateBits, lpszT, cchName);

						// If it is link, say so
						// if (lStateBits==STATE_SYSTEM_LINKED) Say(SAY_ALWAYS, lpszT);

                        lpszT += cchT;
                        cchName -= cchT;

                        *lpszT++ = ',';
                        *lpszT++ = ' ';
                    }
                }

                //
                // Clip off final ", "
                //
                if (varResult.lVal)
                {
                    *(lpszT-2) = 0;
                    *(lpszT-1) = 0;
                }
                else
                    GetStateText(0, bigbuf, cchName);
            }

            VariantClear(&varResult);
            break;

        default:
            DebugBreak();
    }

	bigbuf[cchName-1]=0;
	lstrcpy(lpszName, bigbuf);
	return;
}


/*************************************************************************
    Function:   GetObjectName
    Purpose:    
    Inputs:     
    Returns:    
    History:
*************************************************************************/
/* DWORD GetObjectName(LPOBJINFO poiObj,LPTSTR lpszBuf, int cchBuf)
{
    BSTR  bszName;
    IAccessible* pIAcc;
    long* pl;

    bszName = NULL;

    // Get the object out of the struct
    pl = poiObj->plObj;

    pIAcc =(IAccessible*)pl;

	GetObjectProperty(pIAcc, poiObj->varChild.lVal, ID_NAME, lpszBuf, cchBuf);
	return(0);
}
*/
/*
DWORD GetObjectDescription(LPOBJINFO poiObj,LPTSTR lpszBuf, int cchBuf)
{
    DWORD dwRetVal;
    BSTR  bszDesc;
    IAccessible* pIAcc;
    long* pl;

    bszDesc = NULL;

    // Get the object out of the struct
    pl = poiObj->plObj;

    pIAcc =(IAccessible*)pl;

    // Get the object's name
    pIAcc->get_accDescription(poiObj->varChild, &bszDesc);
    
    // Did we get name string?
    if (bszDesc)
        {
        // Convert from OLE Unicode
        if (WideCharToMultiByte(CP_ACP, 0, 
                            bszDesc,
                            WC_SEPCHARS, // -1
                            lpszBuf,
                            cchBuf,
                            NULL, NULL))
            {
            SysFreeString(bszDesc);

            dwRetVal = NO_ERROR;
            }
        else
            {
            dwRetVal = GetLastError();
            }
        return(dwRetVal);
        }
        
    
    // Need general failure handling routine
    MessageBeep(MB_ICONEXCLAMATION);
    
    return(ERROR_INVALID_FUNCTION);
}
*/
/*
DWORD GetObjectValue(LPOBJINFO poiObj, LPTSTR lpszBuf, int cchBuf)
{
    DWORD dwRetVal;
    BSTR  bszValue;
    IAccessible* pIAcc;
    long* pl;

    bszValue = NULL;

    // Get the object out of the struct
    pl = poiObj->plObj;

    pIAcc =(IAccessible*)pl;

    // Get the object's name
    pIAcc->get_accValue(poiObj->varChild, &bszValue);
    
    // Did we get name string?
    if (bszValue)
        {
        // Convert from OLE Unicode
        if (WideCharToMultiByte(CP_ACP, 0, 
                            bszValue,
                            WC_SEPCHARS, // -1
                            lpszBuf,
                            cchBuf,
                            NULL, NULL))
            {
            SysFreeString(bszValue);

            dwRetVal = NO_ERROR;
            }
        else
            {
            dwRetVal = GetLastError();
            }
        return(dwRetVal);
        }
        
    
    // Need general failure handling routine
    MessageBeep(MB_ICONEXCLAMATION);
    
    return(ERROR_INVALID_FUNCTION);
}
*/

void VariantMyInit(VARIANT *pv)
{
	VariantInit(pv);
	pv->lVal=0;
}

/*************************************************************************
    THE INFORMATION AND CODE PROVIDED HEREUNDER (COLLECTIVELY REFERRED TO
    AS "SOFTWARE") IS PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN
    NO EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
    ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
    CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
    MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGES. SOME STATES DO NOT ALLOW THE EXCLUSION OR
    LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES SO THE
    FOREGOING LIMITATION MAY NOT APPLY.
*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrhook\keys.h ===
// Keys.H

//
// Functions exported from narrhook.dll
//
__declspec(dllexport) BOOL InitKeys(HWND hwnd);
__declspec(dllexport) BOOL UninitKeys(void);
__declspec(dllexport) BOOL InitMSAA(void);
__declspec(dllexport) BOOL UnInitMSAA(void);
__declspec(dllexport) void BackToApplication(void);
__declspec(dllexport) void GetCurrentText(LPTSTR psz, int cch);
__declspec(dllexport) BOOL GetTrackSecondary();
__declspec(dllexport) BOOL GetTrackCaret();
__declspec(dllexport) BOOL GetTrackInputFocus();
__declspec(dllexport) int GetEchoChars();
__declspec(dllexport) BOOL GetAnnounceWindow();
__declspec(dllexport) BOOL GetAnnounceMenu();
__declspec(dllexport) BOOL GetAnnouncePopup();
__declspec(dllexport) BOOL GetAnnounceToolTips();
__declspec(dllexport) BOOL GetReviewStyle();
__declspec(dllexport) int GetReviewLevel();
__declspec(dllexport) void SetCurrentText(LPCTSTR);
__declspec(dllexport) void SetTrackSecondary(BOOL);
__declspec(dllexport) void SetTrackCaret(BOOL);
__declspec(dllexport) void SetTrackInputFocus(BOOL);
__declspec(dllexport) void SetEchoChars(int);
__declspec(dllexport) void SetAnnounceWindow(BOOL);
__declspec(dllexport) void SetAnnounceMenu(BOOL);
__declspec(dllexport) void SetAnnouncePopup(BOOL);
__declspec(dllexport) void SetAnnounceToolTips(BOOL);
__declspec(dllexport) void SetReviewStyle(BOOL);
__declspec(dllexport) void SetReviewLevel(int);

// this is in other.cpp it is used to avoid pulling in C runtime
__declspec(dllexport) LPTSTR lstrcatn(LPTSTR pDest, LPTSTR pSrc, int maxDest);

//
// typedefs 
//
typedef void (*FPACTION)(int nOption);

typedef struct tagHOTK
{
    WPARAM  keyVal;    // Key value, like F1
	int status;
    FPACTION lFunction; // address of function to get info
    int nOption;     // Extra data to send to function
} HOTK;


//
// defines
//
#define MAX_TEXT 20000  

#define TIMER_ID 1001

#define MSR_CTRL  1
#define MSR_SHIFT 2
#define MSR_ALT   4

#define MSR_KEYUP		1
#define MSR_KEYDOWN		2
#define MSR_KEYLEFT		3
#define MSR_KEYRIGHT	4

//
// Function Prototypes
//
void ProcessWinEvent(DWORD event, HWND hwndMsg, LONG idObject, 
                     LONG idChild, DWORD idThread, DWORD dwmsEventTime);

// Macros and function prototypes for debugging
#include "..\..\inc\w95trace.h"

extern DWORD g_tidMain;	// ROBSI: 10-10-99 (defined in keys.cpp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrhook\helpthd.cpp ===
// Copyright (C) 1997-1999 by Microsoft Corporation.  All rights reserved.
// 
// ----------------------------------------------------------------------
// Additions/ Bug fixes 1999 Anil Kumar
// 
// InitMSAA calls InitHelperThread, which creates (duh) a helper thread. 
// In a past version, the WinEventProc would process the WinEvents by 
// calling AccessibleObjectFromEvent on some events, then calling 
// AddEventInfoToStack for all events.
// Problem is that the objects obtained in the main thread cannot be 
// used in the helper thread. So now the helper thread will get it's 
// own IAccessibleObjects when it processes the events, and all 
// IAccessible objects will be created, used, and released by the 
// helper thread.
//

#define STRICT
#include <windows.h>
#include <windowsx.h>
#include <oleacc.h>
#include <objbase.h>

#include "keys.h"       // for ProcessWinEvent
#include "list.h"       // include list.h before helpthd.h, GINFO needs CList
#include "HelpThd.h"

//
// global variables
//
GINFO	gInfo;

//
// Local function prototypes
//
BOOL  OnHelperThreadEvent (void);
DWORD MsgWaitForSingleObject(HANDLE hEvent, DWORD dwTimeout);


/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns: 
    History:    
*************************************************************************/
DWORD WINAPI HelperThreadProc(LPVOID lpParameter)
{
HRESULT	hr;
DWORD	dwWakeup;

	// start COM on this thread
    // SteveDon: CoInitializeEx is supported on both Win95 and WinNT, according to 
    // the SDK docs. Exported from ole32.dll, and defined in objbase.h. 
    // The thing is, for it to be defined, _WIN32_WINNT must be #defined and
    // greater than 0x0400. But since CoInitialize(NULL) is equivalent to
    // CoInitializeEx (NULL,COINIT_APARTMENTTHREADED), we'll just do the 
    // former so it works for sure on both 95 and NT
    //
	hr = CoInitialize (NULL);
	if (FAILED (hr))
	{
		DBPRINTF (TEXT("CoInitialize on helper thread returned 0x%lX\r\n"),hr);
		return (hr);
	}

	// GetGUIThreadInfo (called from acc_getState) will fail if both threads 
	// are not on the same desktop.
	SetThreadDesktop(GetThreadDesktop( g_tidMain )); // ROBSI: 10-10-99

    MSG msg;
	while (TRUE)
    {
        DWORD dwObj = WAIT_FAILED;

        dwObj = MsgWaitForMultipleObjects(1, &gInfo.hHelperEvent, FALSE, INFINITE, QS_ALLINPUT );

        // Proccess the WinEvent
		if ( dwObj == WAIT_OBJECT_0 )
		{
			// OnHelperThreadEvent will return FALSE when it gets
			// the EndHelper event, which means we can terminate 
			// the helper thread.
			if (!OnHelperThreadEvent())
			{
			    DBPRINTF( TEXT("Terminating HelperThreadProc") );
            	CoUninitialize();
            	return 0;
			}
	    }				

		// procces messages that are sent to us.  The only message we expect is
		// WM_TIMER message
		while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

    } 

    return 0;
}


/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns: 
    History:    
*************************************************************************/
BOOL OnHelperThreadEvent (void)
{
    Sleep(100); // was this added by Paul? Not sure why it is here...

	STACKABLE_EVENT_INFO sei;
	while(RemoveInfoFromStack(&sei))
	{
		switch(sei.m_Action)
		{
			case STACKABLE_EVENT_INFO::EndHelper:
				return (FALSE);

            case STACKABLE_EVENT_INFO::NewEvent:
				__try
				{
					ProcessWinEvent(sei.event, sei.hwndMsg, sei.idObject, 
                                    sei.idChild, sei.idThread, sei.dwmsEventTime);
				}
				__except(EXCEPTION_EXECUTE_HANDLER)
				{
					DBPRINTF(TEXT("ProcessWinEvent Exception event=0x%x, hwndMsg=0x%x, idObject=0x%x, idChild=0x%x, idThread=0x%x, dwmsEventTime=0x%x\r\n"),
					          sei.event, sei.hwndMsg, sei.idObject, sei.idChild, sei.idThread, sei.dwmsEventTime);
				}

				break;
			default:
				break;
		} // end switch sei.m_Action
	} // end while RemoveInfoFromStack
	return (TRUE);
} // end OnHelperThreadEvent

/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns: 
    History:    
*************************************************************************/
void AddEventInfoToStack(DWORD event,HWND hwndMsg, LONG idObject, LONG idChild, 
                         DWORD idThread, DWORD dwmsEventTime)
{
	STACKABLE_EVENT_INFO  sei;

	sei.m_Action = STACKABLE_EVENT_INFO::NewEvent;

	sei.event = event;
	sei.hwndMsg = hwndMsg;
	sei.idObject = idObject;
	sei.idChild = idChild;
	sei.idThread = idThread;
	sei.dwmsEventTime = dwmsEventTime;

	EnterCriticalSection(&gInfo.HelperCritSect);

    gInfo.EventInfoList.Add(&sei,sizeof(sei));

	LeaveCriticalSection(&gInfo.HelperCritSect);

	SetEvent(gInfo.hHelperEvent);
}


/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns: 
    History:    
*************************************************************************/
BOOL RemoveInfoFromStack(STACKABLE_EVENT_INFO *pEventInfo)
{
	BOOL bReturn = TRUE;

	EnterCriticalSection(&gInfo.HelperCritSect);

    bReturn = !(gInfo.EventInfoList.IsEmpty());

    if (bReturn)
        gInfo.EventInfoList.RemoveHead(pEventInfo);

	LeaveCriticalSection(&gInfo.HelperCritSect);

	return bReturn;

}

/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns: 
    History:    
*************************************************************************/
void InitHelperThread()
{
	DWORD dwThreadId;

	g_tidMain = GetCurrentThreadId();	// ROBSI: 10-10-99

	InitializeCriticalSection(&gInfo.HelperCritSect);
	gInfo.hHelperEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	gInfo.hHelperThread = CreateThread(NULL, 0, HelperThreadProc, NULL, 0, 
								 	   &dwThreadId);
}

/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns: 
    History:    
*************************************************************************/
void UnInitHelperThread()
{
	STACKABLE_EVENT_INFO  sei;
    
	EnterCriticalSection(&gInfo.HelperCritSect);

	// Force only one event in the queue
    gInfo.EventInfoList.RemoveAll();

	sei.m_Action = STACKABLE_EVENT_INFO::EndHelper;

    gInfo.EventInfoList.Add(&sei,sizeof(sei));

	LeaveCriticalSection(&gInfo.HelperCritSect);

	SetEvent(gInfo.hHelperEvent);

	// Wait for the thread to die
    // note the last sei will be freed by deconstructor

	// Donot wait for eternity here!! Do not care really during Exit!!
	WaitForSingleObject(gInfo.hHelperThread, 3000);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrhook\helpthd.h ===
/*************************************************************************

  Include file for helpthd.cpp

  defines STACAKBLE_EVENT_INFO structure and GINFO (Global Info) structure

*************************************************************************/
typedef struct STACKABLE_EVENT_INFO *PSTACKABLE_EVENT_INFO;

typedef struct STACKABLE_EVENT_INFO {

	enum Action {NewEvent, EndHelper};
	Action       m_Action;

	DWORD        event;
	HWND         hwndMsg;
	LONG         idObject;
	LONG         idChild;
	DWORD        idThread;
	DWORD        dwmsEventTime;

} STACKABLE_EVENT_INFO;


typedef struct GINFO {
    CRITICAL_SECTION HelperCritSect;
    HANDLE           hHelperEvent;
    HANDLE           hHelperThread;
    CList            EventInfoList;
} GINFO;


//
// Function Prototypes
//
void InitHelperThread();
void UnInitHelperThread();

void AddEventInfoToStack(DWORD event, HWND hwndMsg, LONG idObject, LONG idChild, DWORD idThread, DWORD dwmsEventTime);
BOOL RemoveInfoFromStack(STACKABLE_EVENT_INFO *pEventInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrhook\getprop.h ===
//getprop.h
DWORD GetObjectName(LPOBJINFO poiObj, LPSTR lpszBuf, int cchBuf);
DWORD GetObjectDescription(LPOBJINFO poiObj, LPSTR lpszBuf, int cchBuf);
DWORD GetObjectValue(LPOBJINFO poiObj, LPSTR lpszBuf, int cchBuf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrhook\list.h ===
//
// an aribrary list of sized items
//

typedef struct LIST *PLIST;

typedef struct LIST {
    PVOID pData;
    UINT  nBytes;
    PLIST next;
    PLIST prev;
} LIST;

class CList {
    private:
        PLIST m_pListHead;
        PLIST m_pListCurr;
        PLIST m_pListTail;
    public:
        CList();
        ~CList();
        BOOL   IsEmpty() { return (NULL == m_pListHead); }
        void   RemoveAll();
        void   RemoveHead(PVOID pData);
        void   RemoveHead(PVOID pData, PUINT pnBytes);
        BOOL   Add(PVOID pData, UINT nBytes);
        PVOID  PeekHead() { return (IsEmpty() ? NULL : m_pListHead->pData); }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\accessib\narrator\narrhook\keys.cpp ===
/*************************************************************************
	Project:    Narrator
    Module:     keys.cpp

    Author:     Paul Blenkhorn
    Date:       April 1997
    
    Notes:      Credit to be given to MSAA team - bits of code have been 
				lifted from:
					Babble, Inspect, and Snapshot.

    Copyright (C) 1997-1998 by Microsoft Corporation.  All rights reserved.
    See bottom of file for disclaimer
    
    History: Add features, Bug fixes : 1999 Anil Kumar
*************************************************************************/
#define STRICT
#include <windows.h>
#include <windowsx.h>
#include <ole2.h>
#include <ole2ver.h>
#include <commctrl.h>
#include "commdlg.h"
#include <string.h>
#include <initguid.h>
#include <oleacc.h>
#include <TCHAR.H>
#include "..\Narrator\Narrator.h"
#include "keys.h"
#include "w95trace.c"
#include "getprop.h"
#include "..\Narrator\resource.h"
#include "resource.h"

#include "list.h"       // include list.h before helpthd.h, GINFO needs CList
#include "HelpThd.h"
#include <stdio.h>
#include "mappedfile.cpp"

template<class _Ty> class CAutoArray 
{
public:
	explicit CAutoArray(_Ty *_P = 0) : _Ptr(_P) {}
	~CAutoArray()
	{
	    if ( _Ptr )
    	    delete [] _Ptr; 
	}
	_Ty *Get() 
	{
	    return _Ptr; 
	}
private:
	_Ty *_Ptr;
};

#define ARRAYSIZE(x)   (sizeof(x) / sizeof(*x))

// ROBSI: 99-10-09
#define MAX_NAME 4196 // 4K (beyond Max of MSAA)
#define MAX_VALUE 512

// When building with VC5, we need winable.h since the active
// accessibility structures are not in VC5's winuser.h.  winable.h can
// be found in the active accessibility SDK
#ifdef VC5_BUILD___NOT_NT_BUILD_ENVIRONMENT
#include <winable.h>
#endif

#define STATE_MASK (STATE_SYSTEM_CHECKED | STATE_SYSTEM_MIXED | STATE_SYSTEM_READONLY | STATE_SYSTEM_BUSY | STATE_SYSTEM_MARQUEED | STATE_SYSTEM_ANIMATED | STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_UNAVAILABLE)

	  
// Local functions
void Home(int x);
void MoveToEnd(int x);
void SpeakKeyboard(int nOption);
void SpeakWindow(int nOption);
void SpeakRepeat(int nOption);
void SpeakItem(int nOption);
void SpeakMainItems(int nOption);
void SpeakMute(int nOption);
void GetObjectProperty(IAccessible*, long, int, LPTSTR, UINT);
void AddAccessibleObjects(IAccessible*, const VARIANT &);
BOOL AddItem(IAccessible*, const VARIANT &);
void SpeakObjectInfo(LPOBJINFO poiObj, BOOL SpeakExtra);
BOOL Object_Normalize( IAccessible *    pAcc,
                       VARIANT *        pvarChild,
                       IAccessible **   ppAccOut,
                       VARIANT *        pvarChildOut);
_inline void InitChildSelf(VARIANT *pvar)
{
    pvar->vt = VT_I4;
    pvar->lVal = CHILDID_SELF;
}

// MSAA event handlers
BOOL OnFocusChangedEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild, 
                         DWORD dwmsTimeStamp);
BOOL OnValueChangedEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild, 
                         DWORD dwmsTimeStamp);
BOOL OnSelectChangedEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild, 
                          DWORD dwmsTimeStamp);
BOOL OnLocationChangedEvent(DWORD event, HWND hwnd, LONG idObject, 
                            LONG idChild, DWORD dwmsTimeStamp);
BOOL OnStateChangedEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild, 
                         DWORD dwmsTimeStamp);
BOOL OnObjectShowEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild, 
                         DWORD dwmsTimeStamp);

// More local routines
LRESULT CALLBACK KeyboardProc(int code, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK MouseProc(int code, WPARAM wParam, LPARAM lParam);
BOOL IsFocussedItem( HWND hWnd, IAccessible * pAcc, VARIANT varChild );
void FilterGUID(TCHAR* szSpeak); 

// Hot keys
HOTK rgHotKeys[] =
{   //Key       SHIFT					Function            Parameter
    { VK_F12,     MSR_CTRL | MSR_SHIFT,	SpeakKeyboard,          0},  
    { VK_SPACE, MSR_CTRL | MSR_SHIFT,   SpeakWindow,            1},  
    { VK_RETURN,MSR_CTRL | MSR_SHIFT,	SpeakMainItems,         0},  
    { VK_INSERT,MSR_CTRL | MSR_SHIFT,   SpeakItem,              0}, 
    { VK_HOME,	MSR_ALT,				Home,					0},  
    { VK_END,	MSR_ALT,				MoveToEnd,				0},  
};

// a-anilk: this is better than defining as a constant - you don't have to worry
// about making the table and the count match up.
#define CKEYS_HOT (sizeof(rgHotKeys)/sizeof(HOTK))


#define MSR_DONOWT   0
#define MSR_DOCHAR   1
#define MSR_DOWORD	 2
#define MSR_DOLINE	 3
#define MSR_DOLINED  4
#define MSR_DOCHARR  5
#define MSR_DOWORDR  6


#define MSR_DOOBJECT 4
#define MSR_DOWINDOW 5
#define MAX_TEXT_ROLE 128

HHOOK           g_hhookKey = 0;
HHOOK           g_hhookMouse = 0;
HWINEVENTHOOK   g_hEventHook = 0;

POINT   g_ptMoveCursor = {0,0};
UINT_PTR g_uTimer = 0;

// Global Variables stored in memory mapped file

struct GLOBALDATA
{
	int nAutoRead; // Did we get to ReadWindow through focus change or CTRL_ALT_SPACE flag
	int nSpeakWindowSoon; // Flag to indicate the we have a new window ... speak it when sensible

	int nLeftHandSide; // Store left hand side of HTML window we want to read
	BOOL fDoingPassword;
	int nMsrDoNext; // keyboard flag set when curor keys are used ... let us know what to read when caret has moved

	HWND    hwndMSR;

	// Global variables to control events and speech
	BOOL    fInternetExplorer;
	BOOL    fHTML_Help;
	UINT    uMSG_MSR_Cursor;
	POINT   ptCurrentMouse;
	BOOL    fMouseUp;			// flag for mouse up/down
	HWND    hwndHelp;
	BOOL    fJustHadSpace;
	BOOL    fJustHadShiftKeys;
	BOOL	fListFocus;		// To avoid double speaking of list items...
	BOOL	fStartPressed;
	TCHAR   pszTextLocal[2000]; // PB: 22 Nov 1998.  Make it work!!! Make this Global and Shared!

    // Global data that used to be exported from the DLL
    TCHAR szCurrentText[MAX_TEXT];
    int fTrackSecondary;
    int fTrackCaret;
    int fTrackInputFocus;
    int nEchoChars;
    int fAnnounceWindow;
    int fAnnounceMenu;
    int fAnnouncePopup;
    int fAnnounceToolTips;
    int fReviewStyle;
    int nReviewLevel;
};

// pointer to shared global data
GLOBALDATA *g_pGlobalData = 0;
      
// pointer to mem mapped file handle
CMemMappedFile *g_CMappedFile = 0;                       

// the number of times to try to create mem mapped file must be < 10          
const int c_cMappedFileTries = 3;

// name of memory mapped file
TCHAR g_szMappedFileName[] = TEXT("NarratorShared0");

// mutex to access mem mapped file and wait time
TCHAR g_szMutexNarrator[] = TEXT("NarratorMutex0");
const int c_nMutexWait = 5000;

void InitGlobalData()
{
    CScopeMutex csMutex;
    if (csMutex.Create(g_szMutexNarrator, c_nMutexWait) && g_pGlobalData)
    {
        DBPRINTF(TEXT("InitGlobalData\r\n"));
		g_pGlobalData->nMsrDoNext = MSR_DONOWT; // keyboard flag set when curor keys are used
		g_pGlobalData->ptCurrentMouse.x = -1;
		g_pGlobalData->ptCurrentMouse.y = -1;
		g_pGlobalData->fMouseUp = TRUE;		// flag for mouse up/down
        g_pGlobalData->fTrackSecondary = TRUE;
        g_pGlobalData->fTrackCaret = TRUE;
        g_pGlobalData->fTrackInputFocus = FALSE;
        g_pGlobalData->nEchoChars = MSR_ECHOALNUM | MSR_ECHOSPACE | MSR_ECHODELETE | MSR_ECHOMODIFIERS | MSR_ECHOENTER | MSR_ECHOBACK | MSR_ECHOTAB;
        g_pGlobalData->fAnnounceWindow = TRUE;
        g_pGlobalData->fAnnounceMenu = TRUE;
        g_pGlobalData->fAnnouncePopup = TRUE;
        g_pGlobalData->fAnnounceToolTips = FALSE; // this ain't working properly - taken out!
        g_pGlobalData->fReviewStyle = TRUE;
        g_pGlobalData->nReviewLevel = 0;
	}
}

BOOL CreateMappedFile()
{
    g_CMappedFile = new CMemMappedFile;
    if (g_CMappedFile)
    {
        // Append a number thus avoiding restart timing issue 
        // on desktop switches but only try 3 times

        // ISSUE (micw 08/22/00) 
        // - this code has potential problem of ending up with two or more mapped
        // files open.  A mapped file for narrator and one for each hook.  Hooks will
        // cause the DLL to get loaded for that process.  If narrator has NarratorShared1
        // opened and the hook loads this DLL then the hooked process will have
        // NarratorShared0 open.  Could use narrator's hwnd as the thing to append to the
        // file and mutex name.  This code could find the narrator hwnd and use that to
        // open.  Letting this go for now since the above hasn't been observed in testing.

        int iPos1 = lstrlen(g_szMappedFileName) - 1;
        int iPos2 = lstrlen(g_szMutexNarrator) - 1;
        for (int i=0;i<c_cMappedFileTries;i++)
        {
            if (TRUE == g_CMappedFile->Open(g_szMappedFileName, sizeof(GLOBALDATA)))
            {
                CScopeMutex csMutex;
                if (csMutex.Create(g_szMutexNarrator, c_nMutexWait))
                {
                    g_CMappedFile->AccessMem((void **)&g_pGlobalData);
                    if (g_CMappedFile->FirstOpen())
                        InitGlobalData();
                    DBPRINTF(TEXT("CreateMappedFile:  Succeeded %d try!\r\n"), i);
                    return TRUE;
                }
                g_CMappedFile->Close();
                break;  // fail if get to here
            }
            Sleep(500);
            g_szMappedFileName[iPos1] = '1'+i;
            g_szMutexNarrator[iPos2] = '1'+i;
        }
    }
    DBPRINTF(TEXT("CreateMappedFile:  Unable to create the mapped file!\r\n"));
    return FALSE;
}
void CloseMappedFile()
{
    if (g_CMappedFile)
    {
        g_CMappedFile->Close();
        delete g_CMappedFile;
        g_CMappedFile = 0;
    }
}

//
// Accessor functions for what used to be exported, shared, variables
//

#define SIMPLE_FUNC_IMPL(type, prefix, name, error) \
type Get ## name() \
{ \
    CScopeMutex csMutex; \
    if (csMutex.Create(g_szMutexNarrator, c_nMutexWait)) \
    { \
        return g_pGlobalData->prefix ## name; \
    } else \
    { \
        return error; \
    } \
} \
void Set ## name(type value) \
{ \
    CScopeMutex csMutex; \
    if (csMutex.Create(g_szMutexNarrator, c_nMutexWait)) \
    { \
        g_pGlobalData->prefix ## name = value; \
    } \
}

SIMPLE_FUNC_IMPL(BOOL, f, TrackSecondary,   FALSE)
SIMPLE_FUNC_IMPL(BOOL, f, TrackCaret,       FALSE)
SIMPLE_FUNC_IMPL(BOOL, f, TrackInputFocus,  FALSE)
SIMPLE_FUNC_IMPL(int,  n, EchoChars,        0)
SIMPLE_FUNC_IMPL(BOOL, f, AnnounceWindow,   FALSE)
SIMPLE_FUNC_IMPL(BOOL, f, AnnounceMenu,     FALSE)
SIMPLE_FUNC_IMPL(BOOL, f, AnnouncePopup,    FALSE)
SIMPLE_FUNC_IMPL(BOOL, f, AnnounceToolTips, FALSE)
SIMPLE_FUNC_IMPL(BOOL, f, ReviewStyle,      FALSE)
SIMPLE_FUNC_IMPL(int,  n, ReviewLevel,      0)

void GetCurrentText(LPTSTR psz, int cch)
{
    CScopeMutex csMutex;
    if (csMutex.Create(g_szMutexNarrator, c_nMutexWait))
    {
        lstrcpyn(psz, g_pGlobalData->szCurrentText, cch);
    }
}
void SetCurrentText(LPCTSTR psz)
{
    CScopeMutex csMutex;
    if (csMutex.Create(g_szMutexNarrator, c_nMutexWait))
    {
        lstrcpyn(g_pGlobalData->szCurrentText, psz, MAX_TEXT);
    }
}

HINSTANCE g_Hinst = NULL;
DWORD	  g_tidMain=0;	// ROBSI: 10-10-99

// These are class names, This could change from one OS to another and in 
// different OS releases.I have grouped them here : Anil.
// These names may have to changed for Win9x and other releases
#define CLASS_WINSWITCH		TEXT("#32771")  // This is WinSwitch class. Disguises itself :-)AK
#define CLASS_HTMLHELP_IE	TEXT("HTML_Internet Explorer")
#define CLASS_IE_FRAME		TEXT("IEFrame")
#define CLASS_IE_MAINWND	TEXT("Internet Explorer_Server")
#define CLASS_LISTVIEW		TEXT("SysListView32")
#define CLASS_HTMLHELP		TEXT("HH Parent")
#define CLASS_TOOLBAR		TEXT("ToolbarWindow32")
#define CLASS_MS_WINNOTE	TEXT("MS_WINNOTE")
#define CLASS_HH_POPUP  	TEXT("hh_popup")


BOOL IsTridentWindow( LPCTSTR szClass )
{
    return lstrcmpi(szClass, CLASS_HTMLHELP_IE) == 0
        || lstrcmpi(szClass, CLASS_IE_FRAME) == 0
        || lstrcmpi(szClass, CLASS_IE_MAINWND) == 0
        || lstrcmpi(szClass, TEXT("PCHShell Window")) == 0 // Help & Support
        || lstrcmpi(szClass, TEXT("Internet Explorer_TridentDlgFrame")) == 0; // Trident popup windows
}


// Check if the pAcc, varChild refer to a balloon tip. If so, it places the corresponding
// IAccessible and childID in the out ppAcc/pvarChild params.
// The in pAcc/varChild params are always consumed, so should not be freed by caller.
BOOL CheckIsBalloonTipElseRelease( IAccessible * pAcc, VARIANT varChild, IAccessible ** ppAcc, VARIANT * pvarChild )
{
    VARIANT varRole;

    HRESULT hr = pAcc->get_accRole( varChild, &varRole );
    if ( hr == S_OK && varRole.vt == VT_I4 && 
       ( varRole.lVal == ROLE_SYSTEM_TOOLTIP || varRole.lVal == ROLE_SYSTEM_HELPBALLOON ) )
    {
        // Got it...
        *ppAcc = pAcc;
        pvarChild->vt = VT_I4;
        pvarChild->lVal = CHILDID_SELF;
        return TRUE;
    }

    pAcc->Release();
    return FALSE;
}

IAccessible * GetFocusedIAccessibile( HWND hwndFocus, VARIANT * varChild )
{

	IAccessible	*pIAcc = NULL;
	HRESULT hr = AccessibleObjectFromWindow(hwndFocus, OBJID_CLIENT, 
											IID_IAccessible, (void**)&pIAcc);
	InitChildSelf(varChild);
	
	if (S_OK == hr)
	{
        while ( pIAcc )
        {
    		HRESULT hr = pIAcc->get_accFocus(varChild);
    		switch ( varChild->vt )
    		{
        		case VT_I4:
        		    return pIAcc;
           		    break;

           		case VT_DISPATCH:
           		{
                    IAccessible * pAccTemp = NULL;

                    hr = varChild->pdispVal->QueryInterface( IID_IAccessible, (void**) &pAccTemp );
                    VariantClear( varChild );
                    pIAcc->Release();
                    if ( hr != S_OK )
                    {
                        pIAcc = NULL;
                        break;
                    }
                    pIAcc = pAccTemp;

                    break;
           		}
           		
                default:
                    pIAcc->Release();
                    pIAcc = NULL;
                    break;

    		}
        }
	}

    return NULL;
}

/*************************************************************************
    Function:   SpeakString
    Purpose:    Send speak string message back to original application
    Inputs:     TCHAR *str
    Returns:    void
    History:

    Uses sendmessage to avoid other messages firing and overwriting this one.

*************************************************************************/
void SpeakString(TCHAR * str)
{
    DBPRINTF(TEXT("SpeakString '%s'\r\n"), str);
    lstrcpyn(g_pGlobalData->szCurrentText,str,MAX_TEXT);
	SendMessage(g_pGlobalData->hwndMSR, WM_MSRSPEAK, 0, 0);
}

/*************************************************************************
    Function:   SpeakStr
    Purpose:    Send speak string message back to original application
    Inputs:     TCHAR *str
    Returns:    void
    History:
    
    This one uses Postmessage to make focus change work for ALT-TAB???????

*************************************************************************/
void SpeakStr(TCHAR * str)
{
    lstrcpyn(g_pGlobalData->szCurrentText,str,MAX_TEXT);
	PostMessage(g_pGlobalData->hwndMSR, WM_MSRSPEAK, 0, 0);
}


/*************************************************************************
    Function:   SpeakStringAll
    Purpose:    Speak the string, but put out a space first to make sure the
                string is fresh - i.e. stop duplicate string pruning from 
                occuring
    Inputs:     TCHAR *str
    Returns:    void
    History:
*************************************************************************/
void SpeakStringAll(TCHAR * str)
{
    SpeakString(TEXT(" ")); // stop speech filter losing duplicates
    SpeakString(str);
}

/*************************************************************************
    Function:   SpeakStringId
    Purpose:    Speak a string loaded as a resource ID
    Inputs:     UINT id
    Returns:    void
    History:
*************************************************************************/
void SpeakStringId(UINT id)
{
	if (LoadString(g_Hinst, id, g_pGlobalData->szCurrentText, 256) == 0)
	{
		DBPRINTF (TEXT("LoadString failed on hinst %lX id %u\r\n"),g_Hinst,id);
		SpeakString(TEXT("TEXT NOT FOUND!"));
	}
	else 
    {
		SendMessage(g_pGlobalData->hwndMSR, WM_MSRSPEAK, 0, 0);
		SpeakString(TEXT(" ")); // stop speech filter losing duplicates
	}
}


/*************************************************************************
    Function:   SetSecondary
    Purpose:    Set secondary focus position & posibly move mouse pointer
    Inputs:     Position: x & y
				Whether to move cursor: MoveCursor
    Returns:    void
    History:
*************************************************************************/
void SetSecondary(long x, long y, int MoveCursor)
{
	g_pGlobalData->ptCurrentMouse.x = x;
	g_pGlobalData->ptCurrentMouse.y = y;
	if (MoveCursor)
	{
		// Check if co-ordinates are valid, At many places causes 
		// the cursor to vanish...
		if ( x > 0 && y > 0 )
			SetCursorPos(x,y);
	}

	// Tell everyone where the cursor is.
	// g_pGlobalData->uMSG_MSR_Cursor set using RegisterWindowMessage below in InitMSAA
	SendMessage(HWND_BROADCAST,g_pGlobalData->uMSG_MSR_Cursor,x,y);
}

/*************************************************************************
    Function:   TrackCursor
    Purpose:   This is a callback in responce to a SetTimer it calls SetSecondary 
              then kills the timer and resets the global timer flag.
    Returns:    void
    History:
*************************************************************************/
VOID CALLBACK TrackCursor(HWND hwnd,         // handle to window
                             UINT uMsg,         // WM_TIMER message
                             UINT_PTR idEvent,  // timer identifier
                             DWORD dwTime )      // current system time
{
    
    KillTimer( NULL, g_uTimer );
    g_uTimer = 0;
    SetSecondary(g_ptMoveCursor.x, g_ptMoveCursor.y, TRUE);
	
	return;
}

VOID GetStateString(LONG lState,        
                      LONG lStateMask,    
                      LPTSTR szState, 
                      UINT cchState )      
{
        int     iStateBit;
        DWORD   lStateBits;
        LPTSTR  lpszT;
        UINT    cchT;
        bool fFirstTime = true;
        cchState -= 1; // leave room for the null
        if ( !szState )
            return;

        *szState = TEXT('\0');

        for ( iStateBit = 0, lStateBits = 1; iStateBit < 32; iStateBit++, (lStateBits <<= 1) )
        {
            if ( !fFirstTime && cchState > 2)
            {
                *szState++ = TEXT(',');
                *szState++ = TEXT(' ');
                cchState -= 2;
            }
            *szState = TEXT('\0');  // make sure we are always null terminated
            if (lState & lStateBits & lStateMask)
            {
                cchT = GetStateText(lStateBits, szState, cchState);
                szState += cchT;
                cchState -= cchT;
                fFirstTime = false;
            }
        }
}

/*************************************************************************
    Function:   BackToApplication
    Purpose:    Set the focus back to the application that we came from with F12
    Inputs:     void
    Returns:    void
    History:
*************************************************************************/
void BackToApplication(void)
{
	CScopeMutex csMutex;
	if (csMutex.Create(g_szMutexNarrator, c_nMutexWait))
	    SetForegroundWindow(g_pGlobalData->hwndHelp);
}


/*************************************************************************
    Function:   InitKeys
    Purpose:    Set up processing for global hot keys
    Inputs:     HWND hwnd
    Returns:    BOOL - TRUE if successful
    History:
*************************************************************************/
BOOL InitKeys(HWND hwnd)
{
    HMODULE hModSelf;

	CScopeMutex csMutex;
	if (!csMutex.Create(g_szMutexNarrator, c_nMutexWait))
		return FALSE;

    // If someone else has a hook installed, fail.
    if (g_pGlobalData->hwndMSR)
        return FALSE;

    // Save off the hwnd to send messages to
    g_pGlobalData->hwndMSR = hwnd;
    DBPRINTF(TEXT("InitKeys:  hwndMSR = 0x%x hwnd = 0x%x\r\n"), g_pGlobalData->hwndMSR, hwnd);
    // Get the module handle for this DLL
    hModSelf = GetModuleHandle(TEXT("NarrHook.dll"));

    if(!hModSelf)
        return FALSE;
    
    // Set up the global keyboard hook
    g_hhookKey = SetWindowsHookEx(WH_KEYBOARD, // What kind of hook
                                KeyboardProc,// Proc to send to
                                hModSelf,    // Our Module
                                0);          // For all threads

    // and set up the global mouse hook
    g_hhookMouse = SetWindowsHookEx(WH_MOUSE,  // What kind of hook
                                  MouseProc, // Proc to send to
                                  hModSelf,  // Our Module
                                  0);        // For all threads

    // Return TRUE|FALSE based on result
    return g_hhookKey != NULL && g_hhookMouse != NULL;
}


/*************************************************************************
    Function:   UninitKeys
    Purpose:    Deinstall the hooks
    Inputs:     void
    Returns:    BOOL - TRUE if successful
    History:
*************************************************************************/
BOOL UninitKeys(void)
{
	CScopeMutex csMutex;
	if (!csMutex.Create(g_szMutexNarrator, c_nMutexWait))
		return FALSE;

    // Reset
    DBPRINTF(TEXT("UninitKeys setting hwndMSR NULL\r\n"));
    g_pGlobalData->hwndMSR = NULL;

    // Unhook keyboard if that was hooked
    if (g_hhookKey)
    {
        UnhookWindowsHookEx(g_hhookKey);
        g_hhookKey = NULL;
    }

    // Unhook mouse if that was hooked
    if (g_hhookMouse) 
    {
		UnhookWindowsHookEx(g_hhookMouse);
		g_hhookMouse = NULL;
    }

    return TRUE;
}


/*************************************************************************
    Function:   KeyboardProc
    Purpose:    Gets called for keys hit
    Inputs:     void
    Returns:    BOOL - TRUE if successful
    History:
*************************************************************************/
LRESULT CALLBACK KeyboardProc(int code,	        // hook code
                              WPARAM wParam,    // virtual-key code
                              LPARAM lParam)    // keystroke-message information
{
    int		state = 0;
    int		ihotk;

	g_pGlobalData->fDoingPassword = FALSE;

    if (code == HC_ACTION)
    {
        // If this is a key up, bail out now.
        if (!(lParam & 0x80000000))
        {
            g_pGlobalData->fMouseUp = TRUE;
            g_pGlobalData->nSpeakWindowSoon = FALSE;
            g_pGlobalData->fJustHadSpace = FALSE;
            if (lParam & 0x20000000) 
            { // get ALT state
                state = MSR_ALT;
                SpeakMute(0);
            }
            
            if (GetKeyState(VK_SHIFT) < 0)
                state |= MSR_SHIFT;
            
            if (GetKeyState(VK_CONTROL) < 0)
                state |= MSR_CTRL;
            
            for (ihotk = 0; ihotk < CKEYS_HOT; ihotk++)
            {
                if ((rgHotKeys[ihotk].keyVal == wParam) && 
                    (state == rgHotKeys[ihotk].status))
                {
                    // Call the function
                    SpeakMute(0);
                    (*rgHotKeys[ihotk].lFunction)(rgHotKeys[ihotk].nOption);
                    return(1);
                }
            }


// ROBSI: 10-11-99 -- Work Item: Should be able to use the code in OnFocusChangedEvent
//								 that sets the fDoingPassword flag, but that means 
//								 changing the handling of StateChangeEvents to prevent
//								 calling OnFocusChangedEvent. For now, we'll just use
//								 call GetGUIThreadInfo to determine the focused window
//								 and then rely on OLEACC to tell us if it is a PWD field.
			// ROBSI <begin>
			HWND			hwndFocus = NULL;
			GUITHREADINFO	gui;

			// Use the foreground thread.  If nobody is the foreground, nobody has
			// the focus either.
			gui.cbSize = sizeof(GUITHREADINFO);
			if ( GetGUIThreadInfo(0, &gui) )
			{
				hwndFocus = gui.hwndFocus;
			}

			if (hwndFocus != NULL) 
			{
				// Use OLEACC to detect password fields. It turns out to be more 
				// reliable than SendMessage(GetFocus(), EM_GETPASSWORDCHAR, 0, 0L).
        		VARIANT varChild;
				IAccessible *pIAcc = GetFocusedIAccessibile( hwndFocus, &varChild );
				if ( pIAcc )
				{
					// Test the password bit...
					VARIANT varState;
					VariantInit(&varState); 

					HRESULT hr = pIAcc->get_accState(varChild, &varState);

					if ((S_OK == hr) && (varState.vt == VT_I4) && (varState.lVal & STATE_SYSTEM_PROTECTED))
					{
						g_pGlobalData->fDoingPassword = TRUE;
					}
					
    				pIAcc->Release();
				}

				// ROBSI: OLEACC does not always properly detect password fields.
				// Therefore, we use Win32 as a backup.
				if (!g_pGlobalData->fDoingPassword)
				{
					TCHAR   szClassName[256];

					// Verify this control is an Edit or RichEdit control to avoid 
					// sending EM_ messages to random controls.
					// POTENTIAL BUG? If login dialog changes to another class, we'll break.
					if ( RealGetWindowClass( hwndFocus, szClassName, ARRAYSIZE(szClassName)) )
					{
						if ((0 == lstrcmp(szClassName, TEXT("Edit")))		||
							(0 == lstrcmp(szClassName, TEXT("RICHEDIT")))	||
							(0 == lstrcmp(szClassName, TEXT("RichEdit20A")))	||
							(0 == lstrcmp(szClassName, TEXT("RichEdit20W"))) 
						   )
						{
							g_pGlobalData->fDoingPassword = (SendMessage(hwndFocus, EM_GETPASSWORDCHAR, 0, 0L) != NULL);
						}
					}
				}

			}
			
			// ROBSI <end>

			if (g_pGlobalData->fDoingPassword)
			{
				// ROBSI: 10-11-99
				// Go ahead and speak keys that are not printable but will
				// help the user understand what state they are in.
				switch (wParam)
				{
					case VK_CAPITAL:
						if (g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS)
						{
							SpeakMute(0);
							if ( GetKeyState(VK_CAPITAL) & 0x0F )
								SpeakStringId(IDS_CAPS_ON);
							else
								SpeakStringId(IDS_CAPS_OFF);
						}
						break;

					case VK_NUMLOCK:
						if (g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS)
						{
							SpeakMute(0);
							if ( GetKeyState(VK_NUMLOCK) & 0x0F )
								SpeakStringId(IDS_NUM_ON);
							else
								SpeakStringId(IDS_NUM_OFF);
						}
						break;

					case VK_DELETE:
						if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
						{
							SpeakMute(0);
							SpeakStringId(IDS_DELETE);
						}
						break;

					case VK_INSERT:
						if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
						{
							SpeakMute(0);
							SpeakStringId(IDS_INSERT);
						}
						break;

					case VK_BACK:
						if (g_pGlobalData->nEchoChars & MSR_ECHOBACK)
						{
							SpeakMute(0);
							SpeakStringId(IDS_BACKSPACE);
						}
						break;

					case VK_TAB:
						SpeakMute(0);

						if (g_pGlobalData->nEchoChars & MSR_ECHOTAB)
							SpeakStringId(IDS_TAB);
						break;

					case VK_CONTROL:
						SpeakMute(0); // always mute when control held down!

						if ((g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS) && !(g_pGlobalData->fJustHadShiftKeys & MSR_CTRL))
						{
							SpeakStringId(IDS_CONTROL);
							// ROBSI: Commenting out to avoid modifying Global State
							// g_pGlobalData->fJustHadShiftKeys |= MSR_CTRL;  
						}
						break;

					default:
						SpeakMute(0);
						SpeakStringId(IDS_PASS);
						break;
				}

			    return (CallNextHookEx(g_hhookKey, code, wParam, lParam));
			}


            TCHAR buff[20];
            BYTE KeyState[256];
            UINT ScanCode;
            GetKeyboardState(KeyState);
            
            if ((g_pGlobalData->nEchoChars & MSR_ECHOALNUM) && 
                (ScanCode = MapVirtualKeyEx((UINT)wParam, 2,GetKeyboardLayout(0)))) 
            {
#ifdef UNICODE
                ToUnicode((UINT)wParam,ScanCode,KeyState, buff,10,0);
#else
                ToAscii((UINT)wParam,ScanCode,KeyState,(unsigned short *)buff,0);
#endif
                
                // Use 'GetStringTypeEx()' instead of _istprint()
                buff[1] = 0;
                WORD wCharType;
                WORD fPrintable = C1_UPPER|C1_LOWER|C1_DIGIT|C1_SPACE|C1_PUNCT|C1_BLANK|C1_XDIGIT|C1_ALPHA;
                
                GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, buff, 1, &wCharType);
                if (wCharType & fPrintable)
				{
					SpeakMute(0);
					SpeakStringAll(buff);
				}
            }

			// All new: Add speech for all keys...AK
            switch (wParam) {
            case VK_SPACE:
                g_pGlobalData->fJustHadSpace = TRUE;
                if (g_pGlobalData->nEchoChars & MSR_ECHOSPACE)
				{
					SpeakMute(0);
					SpeakStringId(IDS_SPACE);
				}
                break;

			case VK_LWIN:
			case VK_RWIN:
                if (g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS)
				{
					SpeakMute(0);
					g_pGlobalData->fStartPressed = TRUE;
                    SpeakStringId(IDS_WINKEY);
				}
				break;

			case VK_CAPITAL:
                if (g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS)
				{
					SpeakMute(0);
					if ( GetKeyState(VK_CAPITAL) & 0x0F )
						SpeakStringId(IDS_CAPS_ON);
					else
						SpeakStringId(IDS_CAPS_OFF);
				}
				break;

			case VK_SNAPSHOT:
                if (g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS)
				{
					SpeakMute(0);
					SpeakStringId(IDS_PRINT);
				}
				break;

			case VK_ESCAPE:
                if (g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS)
				{
					SpeakMute(0);
					SpeakStringId(IDS_ESC);
				}
				break;

			case VK_NUMLOCK:
                if (g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS)
				{
					SpeakMute(0);
					if ( GetKeyState(VK_NUMLOCK) & 0x0F )
						SpeakStringId(IDS_NUM_ON);
					else
						SpeakStringId(IDS_NUM_OFF);
				}
				break;

            case VK_DELETE:
                if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_DELETE);
				}
                break;

			case VK_INSERT:
                if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_INSERT);
				}
				break;

			case VK_HOME:
                if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_HOME);
				}
				break;

			case VK_END:
                if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_END);
				}
				break;

			case VK_PRIOR:
                if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_PAGEUP);
				}
				break;

			case VK_NEXT:
                if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_PAGEDOWN);
				}
				break;

            case VK_BACK:
                if (g_pGlobalData->nEchoChars & MSR_ECHOBACK)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_BACKSPACE);
				}
                break;

            case VK_TAB:
                SpeakMute(0);

                if (g_pGlobalData->nEchoChars & MSR_ECHOTAB)
                    SpeakStringId(IDS_TAB);
                break;

            case VK_CONTROL:
                SpeakMute(0); // always mute when control held down!

                if ((g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS) && !(g_pGlobalData->fJustHadShiftKeys & MSR_CTRL))
                {
                    SpeakStringId(IDS_CONTROL);
                    g_pGlobalData->fJustHadShiftKeys |= MSR_CTRL;
                }
                break;

            case VK_MENU:
                if ((g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS) && !(g_pGlobalData->fJustHadShiftKeys & MSR_ALT))
				{
					SpeakMute(0);
                    SpeakStringId(IDS_ALT);
				}
                break;

            case VK_SHIFT:
                if ((g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS) && !(g_pGlobalData->fJustHadShiftKeys & MSR_SHIFT))
				{
					SpeakMute(0);
	                SpeakStringId(IDS_SHIFT);
                    g_pGlobalData->fJustHadShiftKeys |= MSR_SHIFT;
				}
                break;

            case VK_RETURN:
                if (g_pGlobalData->nEchoChars & MSR_ECHOENTER)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_RETURN);
				}
                break;
            }
            
            // set flags for moving around edit controls
            g_pGlobalData->nMsrDoNext = MSR_DONOWT; 

			if (state == MSR_CTRL && (wParam == VK_LEFT || wParam == VK_RIGHT))
			{
				SpeakMute(0);
				g_pGlobalData->nMsrDoNext = MSR_DOWORD;
			}
			else if ((state & MSR_CTRL) && (state & MSR_SHIFT) && (wParam == VK_LEFT))
				g_pGlobalData->nMsrDoNext = MSR_DOWORD;
			else if ((state & MSR_CTRL) && (state & MSR_SHIFT) && (wParam == VK_RIGHT))
				g_pGlobalData->nMsrDoNext = MSR_DOWORDR;
			else if ((state & MSR_SHIFT) && (wParam == VK_LEFT)) 
				g_pGlobalData->nMsrDoNext = MSR_DOCHAR;
			else if ((state & MSR_SHIFT) && (wParam == VK_RIGHT)) 
				g_pGlobalData->nMsrDoNext = MSR_DOCHARR;
			else if ((state & MSR_CTRL) && (wParam == VK_UP || wParam == VK_DOWN))
				g_pGlobalData->nMsrDoNext = MSR_DOLINE;
			else if ((state & MSR_SHIFT) && (wParam == VK_UP))
				g_pGlobalData->nMsrDoNext = MSR_DOLINE;
			else if ((state & MSR_SHIFT) && (wParam == VK_DOWN))
				g_pGlobalData->nMsrDoNext = MSR_DOLINED;
			else if (state == 0) 
			{ // i.e. no shift keys
				switch (wParam) 
				{
					case VK_LEFT: 
					case VK_RIGHT:
						g_pGlobalData->nMsrDoNext = MSR_DOCHAR;
						SpeakMute(0);
						break;
            
					case VK_DOWN: 
					case VK_UP:
						g_pGlobalData->nMsrDoNext = MSR_DOLINE;
						SpeakMute(0);
						break;

					case VK_F3:
						if (GetForegroundWindow() == g_pGlobalData->hwndMSR) 
						{
							PostMessage(g_pGlobalData->hwndMSR, WM_MSRCONFIGURE, 0, 0);
							return(1);
						}
						break;
            
					case VK_F9:
						if (GetForegroundWindow() == g_pGlobalData->hwndMSR) 
						{
							PostMessage(g_pGlobalData->hwndMSR, WM_MSRQUIT, 0, 0);
							return(1);
						}
						 break;
				} // end switch wParam (keycode)
			} // end if no shift keys pressed
        } // end if key down
    } // end if code == HC_ACTION
    g_pGlobalData->fJustHadShiftKeys = state;

    return (CallNextHookEx(g_hhookKey, code, wParam, lParam));
}

/*************************************************************************
    Function:   MouseProc
    Purpose:    Gets called for mouse eventshit
    Inputs:     void
    Returns:    BOOL - TRUE if successful
    History:
*************************************************************************/
LRESULT CALLBACK MouseProc(int code,	        // hook code
                              WPARAM wParam,    // virtual-key code
                              LPARAM lParam)    // keystroke-message information
{
	CScopeMutex csMutex;
	if (!csMutex.Create(g_szMutexNarrator, c_nMutexWait))
		return 1;   // TODO not sure what to do here; MSDN is unclear about retval

    LRESULT retVal = CallNextHookEx(g_hhookMouse, code, wParam, lParam);

    if (code == HC_ACTION)
    {
		switch (wParam) 
        { // want to know if mouse is down
		    case WM_NCLBUTTONDOWN: 
            case WM_LBUTTONDOWN:
    		case WM_NCRBUTTONDOWN: 
            case WM_RBUTTONDOWN:
                // to keep sighted people happy when using mouse shut up 
                // the speech on mouse down
                // SpeakMute(0); 
                // Chnage to PostMessage works for now: a-anilk
                PostMessage(g_pGlobalData->hwndMSR, WM_MUTE, 0, 0);
                // If it is then don't move mouse pointer when focus set!
			    g_pGlobalData->fMouseUp = FALSE;
			    break;

		    case WM_NCLBUTTONUP: 
            case WM_LBUTTONUP:
            case WM_NCRBUTTONUP:
            case WM_RBUTTONUP:
//			    g_pGlobalData->fMouseUp = TRUE; Don't clear flag here - wait until key pressed before enabling auto mouse movemens again
			    break;
		}
    }

    return(retVal);
}


// --------------------------------------------------------------------------
//
//  Entry point:  DllMain()
//
// Some stuff only needs to be done the first time the DLL is loaded, and the
// last time it is unloaded, which is to set up the values for things in the 
// shared data segment, including SharedMemory support.
//
// InterlockedIncrement() and Decrement() return 1 if the result is 
// positive, 0 if  zero, and -1 if negative.  Therefore, the only
// way to use them practically is to start with a counter at -1.  
// Then incrementing from -1 to 0, the first time, will give you
// a unique value of 0.  And decrementing the last time from 0 to -1
// will give you a unique value of -1.
//
// --------------------------------------------------------------------------
BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID pvReserved)
{
    switch (dwReason) 
	{
		case DLL_PROCESS_ATTACH:
        g_Hinst = hinst;
        // Create the memory mapped file for shared global data
        CreateMappedFile();
		break;

		case DLL_PROCESS_DETACH:
        // Close the memory mapped file for shared global data
        CloseMappedFile();
        break;
    }

    return(TRUE);
}

/*************************************************************************
    Function:   WinEventProc
    Purpose:    Callback function handles events
    Inputs:     HWINEVENTHOOK hEvent - Handle of the instance of the event proc
                DWORD event - Event type constant
                HWND hwndMsg - HWND of window generating event
                LONG idObject - ID of object generating event
                LONG idChild - ID of child generating event (0 if object)
                DWORD idThread - ID of thread generating event
                DWORD dwmsEventTime - Timestamp of event
    Returns: 
    History:    
*************************************************************************/
void CALLBACK WinEventProc(HWINEVENTHOOK hEvent, DWORD event, HWND hwndMsg, 
                           LONG idObject, LONG idChild, DWORD idThread, 
                           DWORD dwmsEventTime)
{
    // NOTE: If any more events are handled by ProcessWinEvent, they must be 
    // added to this switch statement.
	// no longer will we get an IAccessible here - the helper thread will
	// get the info from the Stack and get and use the IAccessible there.

    switch (event)
    {
		case EVENT_OBJECT_STATECHANGE:
		case EVENT_OBJECT_VALUECHANGE:
		case EVENT_OBJECT_SELECTION:
		case EVENT_OBJECT_FOCUS:
		case EVENT_OBJECT_LOCATIONCHANGE:
		case EVENT_SYSTEM_MENUSTART:
		case EVENT_SYSTEM_MENUEND:
		case EVENT_SYSTEM_MENUPOPUPSTART:
		case EVENT_SYSTEM_MENUPOPUPEND:
		case EVENT_SYSTEM_SWITCHSTART:
		case EVENT_SYSTEM_FOREGROUND:
		case EVENT_OBJECT_SHOW:
			AddEventInfoToStack(event, hwndMsg, idObject, idChild, 
								idThread, dwmsEventTime);
			break;
    } // end switch (event)
}


/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns: 
    History:    
*************************************************************************/
void ProcessWinEvent(DWORD event, HWND hwndMsg, LONG idObject, LONG 
                     idChild, DWORD idThread,DWORD dwmsEventTime)
{
	TCHAR   szName[256];

	// What type of event is coming through?
	// bring secondary focus here: Get from Object inspector
	// bring mouse pointer here if flag set.
	
	if (g_pGlobalData->nReviewLevel != 2)
	{
		switch (event)
		{
			case EVENT_SYSTEM_SWITCHSTART:
				SpeakMute(0);
				SpeakString(TEXT("ALT TAB"));
				break;

			case EVENT_SYSTEM_MENUSTART:
			    break;

		    case EVENT_SYSTEM_MENUEND:
			    SpeakMute(0);
			    if (g_pGlobalData->fAnnounceMenu)
				    SpeakStringId(IDS_MENUEND);
			    break;
		    
		    case EVENT_SYSTEM_MENUPOPUPSTART:
			    if (g_pGlobalData->fAnnouncePopup)
				{
					SpeakMute(0);
				    SpeakStringId(IDS_POPUP);
				}
			    break;
			    
		    case EVENT_SYSTEM_MENUPOPUPEND:
			    SpeakMute(0);
			    if (g_pGlobalData->fAnnouncePopup)
				    SpeakStringId(IDS_POPUPEND);
			    break;
			    
		    case EVENT_OBJECT_STATECHANGE : 
                DBPRINTF(TEXT("EVENT_OBJECT_STATECHANGE\r\n"));
				// want to catch state changes on spacebar pressed
				switch (g_pGlobalData->fJustHadSpace) 
				{ 
					case 0 : // get out - only do this code if space just been pressed
						break;
					case 1 : 
					case 2 : // ignore the first and second time round!
						g_pGlobalData->fJustHadSpace++;
						break;
					case 3 : // second time around speak the item
						OnFocusChangedEvent(event, hwndMsg, idObject, idChild, dwmsEventTime);
						g_pGlobalData->fJustHadSpace = 0;
						break;
				}
				OnStateChangedEvent(event, hwndMsg, idObject, idChild, dwmsEventTime);
			    break;
			    
			case EVENT_OBJECT_VALUECHANGE : 
				 OnValueChangedEvent(event, hwndMsg, idObject, idChild, dwmsEventTime);
				break;
				    
			case EVENT_OBJECT_SELECTION : 
				if (GetParent(hwndMsg) == g_pGlobalData->hwndMSR) 
				{
					// don't do this for our own or list box throws a wobbler!
					break; 
				}
				
				// this comes in for list items a second time after the focus 
				// changes BUT that gets filtered by the double speak check.
				// What this catches is list item changes when cursor down in 
				// combo boxes!
				// Make it just works for them.
				
				OnSelectChangedEvent(event, hwndMsg, idObject, idChild, dwmsEventTime);
				break;
				
			case EVENT_OBJECT_FOCUS:
                DBPRINTF(TEXT("EVENT_OBJECT_FOCUS\r\n"));
				OnFocusChangedEvent(event, hwndMsg, idObject, idChild, dwmsEventTime);
				break;
				
			case EVENT_SYSTEM_FOREGROUND: // Window comes to front - speak its name!
				SpeakMute(0);
				SpeakStringId(IDS_FOREGROUND);

                TCHAR szClassName[100];
                // if the class name is CLASS_MS_WINNOTE or CLASS_HH_POPUP it's context senceitive help 
                // and the text will be read in OnFocusChangeEvent by SpeakObjectInfo.  So we don't need to
                // read the same text here and in SpeakWindow
            	GetClassName( hwndMsg, szClassName, ARRAYSIZE(szClassName) ); 
                if ( (lstrcmpi(szClassName, CLASS_MS_WINNOTE ) == 0) || (lstrcmpi(szClassName, CLASS_HH_POPUP ) == 0) )
                    break;

				GetWindowText(hwndMsg, szName, sizeof(szName)/sizeof(TCHAR));	// raid #113789
				SpeakString(szName);
				
				if (g_pGlobalData->fAnnounceWindow) 
				{
					g_pGlobalData->nSpeakWindowSoon = TRUE; // read window when next focus set
				}
				
				break;
				
			case EVENT_OBJECT_LOCATIONCHANGE:
				// Only the caret
				if (idObject != OBJID_CARET)
					return;

				OnLocationChangedEvent(event, hwndMsg, idObject, idChild, dwmsEventTime);
                break;

            case EVENT_OBJECT_SHOW:
                OnObjectShowEvent(event, hwndMsg, idObject, idChild, dwmsEventTime);
                break;

		} // end switch (event)
	} // end if review level != 2
	return;
}


/*************************************************************************
    Function:   OnValueChangedEvent
    Purpose:    Receives value events
    Inputs:     DWORD event        - What event are we processing
                HWND  hwnd         - HWND of window generating event
                LONG  idObject     - ID of object generating event
                LONG  idChild      - ID of child generating event (0 if object)
                DWORD idThread     - ID of thread generating event
                DWORD dwmsEventTime - Timestamp of event
    Returns:    BOOL - TRUE if succeeded
*************************************************************************/
BOOL OnValueChangedEvent(DWORD event, HWND hwnd,  LONG idObject, LONG idChild, 
                         DWORD dwmsTimeStamp)
{
    HRESULT         hr;
    OBJINFO         objCurrent;
	VARIANT         varRole;
    IAccessible*    pIAcc;
    VARIANT         varChild;
	TCHAR szName[200];

    hr = AccessibleObjectFromEvent (hwnd, idObject, idChild, &pIAcc, &varChild);
    if (SUCCEEDED(hr))
    {
        objCurrent.hwnd = hwnd;
        objCurrent.plObj = (long*)pIAcc;
	    objCurrent.varChild = varChild;
	    
	    VariantInit(&varRole);

	    hr = pIAcc->get_accRole(varChild, &varRole);

		if( FAILED(hr) || 
		   varRole.lVal != ROLE_SYSTEM_SPINBUTTON &&  g_pGlobalData->nMsrDoNext == MSR_DONOWT)
		{
			pIAcc->Release();
			return(FALSE);
		}

		g_pGlobalData->nMsrDoNext = MSR_DONOWT; // PB 22 Nov 1998 stop this firing more than once (probably)

		if (varRole.vt == VT_I4 && (
			(varRole.lVal == ROLE_SYSTEM_TEXT && g_pGlobalData->nMsrDoNext != MSR_DOLINE) ||
			 varRole.lVal == ROLE_SYSTEM_PUSHBUTTON || 
			 varRole.lVal == ROLE_SYSTEM_SCROLLBAR))
		{
			DBPRINTF (TEXT("Don't Speak <%s>\r\n"), szName);
			// don't speak 'cos it's an edit box (or others) changing value!
		}
		else if (!g_pGlobalData->fInternetExplorer) // don't do this for IE .. it speaks edit box too much.
		{
			DBPRINTF (TEXT("Now Speak!\r\n"));
			SpeakMute(0);
			SpeakObjectInfo(&objCurrent, FALSE);
		}
		else
			DBPRINTF (TEXT("Do nowt!\r\n"));

        pIAcc->Release();
    }

    return(TRUE);
}


/*************************************************************************
    Function:   OnSelectChangedEvent
    Purpose:    Receives selection change events - not from MSR though
    Inputs:     DWORD event    - What event are we processing
                HWND hwnd      - HWND of window generating event
                LONG idObject  - ID of object generating event
                LONG idChild   - ID of child generating event (0 if object)
                DWORD idThread - ID of thread generating event
                DWORD dwmsEventTime - Timestamp of event
    Returns:    BOOL - TRUE if succeeded
	Notes:		Maybe change this to only take combo-boxes?
*************************************************************************/
BOOL OnSelectChangedEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild, 
                          DWORD dwmsTimeStamp)
{
    HRESULT         hr;
    IAccessible*    pIAcc;
    OBJINFO         objCurrent;
	VARIANT         varRole;
    VARIANT         varChild;

    // if we've not had a cursor style movement then sack this as it could be 
    // scroll bar chaging or slider moving etc to reflect rapidy moving events

    hr = AccessibleObjectFromEvent (hwnd, idObject, idChild, &pIAcc, &varChild);
    if (SUCCEEDED(hr))
    {
        objCurrent.hwnd = hwnd;
        objCurrent.plObj = (long*)pIAcc;
	    objCurrent.varChild = varChild;
	    
	    VariantInit(&varRole); // heuristic!
	    hr = pIAcc->get_accRole(varChild, &varRole);
	    if ( FAILED(hr) )
	    {
            pIAcc->Release();
            return FALSE;
	    }

	    if (varRole.vt == VT_I4 &&
		    varRole.lVal == ROLE_SYSTEM_LISTITEM) 
        {
			TCHAR buffer[100];
			GetClassName(hwnd,buffer,100); // Is it sysListView32

            // "Don't mute here ... we lose the previous speech message which will
			// have spoken the list item IF we were cursoring to list item.
			// SpeakMute(0);
		    // don't speak unless it's a listitem
		    // e.g. Current Selection for Joystick from Joystick setup.
		    // this does mean that some list items get spoken twice!:AK
			// if ( lstrcmpi(buffer, CLASS_LISTVIEW) != 0)
			if ( !g_pGlobalData->fListFocus )
				SpeakObjectInfo(&objCurrent,FALSE);

			g_pGlobalData->fListFocus = FALSE;
	    }
        pIAcc->Release();
    }
	
    return(TRUE);
}

/*************************************************************************
    Function:   OnFocusChangedEvent
    Purpose:    Receives focus events
    Inputs:     DWORD event    - What event are we processing
